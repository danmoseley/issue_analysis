[
  {
    "author": "ahsonkhan",
    "labels": [
      "api-needs-work",
      "area-System.Text.Json",
      "partner-impact"
    ],
    "createdAt": "2019-01-23T05:40:50Z",
    "body": "We currently have line number and byte position in line as internal fields of the `JsonReaderState` and  `Utf8JsonReader` that are used as part of creating the JsonReaderException, when reading invalid JSON.\r\n\r\n```C#\r\n    public sealed partial class JsonReaderException : System.Exception\r\n    {\r\n        public JsonReaderException(string message, long lineNumber, long bytePositionInLine) { }\r\n        public long BytePositionInLine { get { throw null; } }\r\n        public long LineNumber { get { throw null; } }\r\n        public override void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) { }\r\n    }\r\n```\r\n\r\n**API addition:**\r\n```C#\r\npublic ref partial struct Utf8JsonReader\r\n{\r\n    public long LineNumber { get { throw null; } }\r\n    public long BytePositionInLine { get { throw null; } }\r\n}\r\n```\r\n\r\nIf a user wants schema validation (rather than checking if the JSON is valid according to spec) and decides to throw their own exception, exposing such information would be useful.\r\n\r\nOne such scenario is M.E.DependencyModel, where the caller is throwing a FormatException (for example if an array is expected or the first token is expected to be a start of an object):\r\n- https://github.com/dotnet/core-setup/blob/06292a87deb3880eb462aba17c81ac7657917272/src/managed/Microsoft.Extensions.DependencyModel/JsonTextReaderExtensions.cs#L83-L87\r\n- https://github.com/dotnet/core-setup/pull/5009#discussion_r249965040\r\n\r\n**Question:**\r\n- Should we expose it from the `Utf8JsonReader`, OR from the `JsonReaderState`, OR both? I don't see the need to expose it from the `JsonReaderState`, currently.\r\n\r\ncc @eerhardt, @JamesNK ",
    "number": 28482,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "THUMBS_UP",
          "createdAt": "2019-01-23T15:16:58Z",
          "user": "Symbai"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2019-09-17T16:30:17Z",
          "user": "OsmondJiang"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2020-12-07T11:10:45Z",
          "user": "atruskie"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-04-20T16:29:25Z",
          "user": "AleckAgakhan"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-12-06T00:00:02Z",
          "user": "ehavelaarsnz"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-01-06T11:40:30Z",
          "user": "wertzui"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-02-15T21:47:24Z",
          "user": "erdomke"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-05-24T13:42:18Z",
          "user": "techfan101"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-06-20T06:56:38Z",
          "user": "ivarne"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-06-24T21:17:21Z",
          "user": "dferretti"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-08-19T09:15:56Z",
          "user": "VaclavElias"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-10-18T12:42:47Z",
          "user": "stevejgordon"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-06-25T00:01:53Z",
          "user": "fgimian"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-10-02T20:58:35Z",
          "user": "rs-blade"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-11-02T09:53:38Z",
          "user": "czdietrich"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-12-11T09:49:01Z",
          "user": "nil4"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-12-14T16:17:07Z",
          "user": "qt-kaneko"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-01-23T17:17:24Z",
          "user": "enchart"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-05-13T23:39:41Z",
          "user": "darrelmiller"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-05-17T11:14:32Z",
          "user": "lskyum"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-07-22T08:32:19Z",
          "user": "cklutz"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-07-26T19:51:23Z",
          "user": "ygoe"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-07-26T20:17:03Z",
          "user": "zivkan"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-12-04T19:42:19Z",
          "user": "jbayardo"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-03-30T11:21:17Z",
          "user": "lipchev"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-04-19T10:23:05Z",
          "user": "MrJul"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-09-05T02:24:39Z",
          "user": "austinw-fineart"
        }
      ],
      "totalCount": 27,
      "endCursor": "Y3Vyc29yOnYyOpHODApwSw=="
    },
    "updatedAt": "2025-02-18T02:41:36Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": "CodeTherapist",
          "body": "I would like to do this :)",
          "createdAt": "2019-01-28T09:03:22Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2019-01-28T09:18:29Z",
                "user": "ahsonkhan"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-11-12T15:27:05Z",
                "user": "marcovisserFurore"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-12-18T14:00:00Z",
                "user": "aegoroff"
              }
            ],
            "totalCount": 3,
            "endCursor": "Y3Vyc29yOnYyOpHOD_gDtg=="
          },
          "updatedAt": "2019-01-28T09:03:22Z",
          "id": "MDEyOklzc3VlQ29tbWVudDQ1ODA0Njc4Nw=="
        },
        {
          "author": "ahsonkhan",
          "body": "> I would like to do this :)\r\n\r\nAwesome!\r\n\r\nThis API change is waiting for API-review and approval (which happen on Tuesdays). We generally wait for that before opening up a PR.\r\n\r\nHowever, if approved, the API shape will likely not change, so imo, feel free to get started on a PR if you like (marking it as blocked against this issue). Feel free to ping me for review or if you are blocked on anything. There are only two pending questions that need to be discussed in the review:\r\n1) Should we add the API at all?\r\n   - Imo, almost certainly yes.\r\n2) Should we expose it from the `Utf8JsonReader`, OR from the `JsonReaderState`, OR both?\r\n   - I would start with just adding it to `Utf8JsonReader` for now.",
          "createdAt": "2019-01-28T09:18:18Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2019-01-28T10:45:29Z",
          "id": "MDEyOklzc3VlQ29tbWVudDQ1ODA1MTA4Nw=="
        },
        {
          "author": "CodeTherapist",
          "body": "Thanks for the comprehensive information about the API-Review part - I guess it's the session that is streamed over youtube.\r\n\r\n> Should we expose it from the `Utf8JsonReader`, OR from the `JsonReaderState`, OR both? \r\n\r\nAccordingly to other similar API's ([Json.NET](https://github.com/JamesNK/Newtonsoft.Json/blob/509643a8952ce731e0207710c429ad6e67dc43db/Src/Newtonsoft.Json/JsonTextReader.cs#L2578), [XmlReader](https://github.com/dotnet/corefx/blob/90e11f77895a5c5363dd818b5c89c6f811eef2e6/src/System.Private.Xml/src/System/Xml/Core/XmlTextReaderImpl.cs#L1940)), this information is exposed on the reader directly. On the other hand, the `JsonReaderState` is about _state_ and would make sense to me - but not sure if my consideration is reasonable.\r\n\r\nThe `JsonReaderState` is already public exposed over the property [CurrentState](https://github.com/dotnet/corefx/blob/90e11f77895a5c5363dd818b5c89c6f811eef2e6/src/System.Text.Json/src/System/Text/Json/Reader/Utf8JsonReader.cs#L129) and would be accessible.",
          "createdAt": "2019-01-28T10:13:24Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2019-01-28T10:13:24Z",
          "id": "MDEyOklzc3VlQ29tbWVudDQ1ODA3MDM2OQ=="
        },
        {
          "author": "terrajobst",
          "body": "[Video](https://www.youtube.com/watch?v=jfJkaggdGws&t=0h0m0s)\n\nThis looks useful. We discussed whether we should expose this on the state as well so that consumers can use that information when invalid schema information was found (rather than when the reader detects invalid JSON).\r\n\r\nThe current design has the unfortunate behavior that the line/byte position represents where the next token will start reading. Note that this isn't even the start of next token (due to skipped whitespace). Since schema validation requires the token to be read, it's always at the end of the token, rather than at the beginning.\r\n\r\n@ahsonkhan please explore what the documentation for these APIs would say to explaint their behavior. We can then review wether that's something developers will be able to reason about.",
          "createdAt": "2019-02-05T18:28:11Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-05-01T16:23:45Z",
                "user": "Akarinnnnn"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOCaqHlQ=="
          },
          "updatedAt": "2019-10-03T23:34:41Z",
          "id": "MDEyOklzc3VlQ29tbWVudDQ2MDc0OTUxNA=="
        },
        {
          "author": "ahsonkhan",
          "body": "Though the change is relatively straightforward, the semantics of where line number and byte position in line is, for all cases, is nuanced. I think the current behavior is correct and makes sense, but requires more deliberation. Hence, moving this to 5.0, in case we want to change the semantics.\r\n\r\nThe remarks section capture the subtleties.\r\n```C#\r\n/// <summary>\r\n/// The number of lines read so far within the JSON payload (starting at 0).\r\n/// </summary>\r\n/// <remarks>\r\n/// This returns the current line number of the reader on which the last processed JSON \r\n/// token ends, not where it started.\r\n/// For property names, that means after the colon (including whatever whitespace or new line \r\n/// characters might be in between the end quote and colon). So, the line number won't always \r\n/// coincide with the line where the end of the property name itself can be found, but rather \r\n/// where the colon was found.\r\n/// Outside of multi-line comments, returning the end of any other token (rather than the start)\r\n/// has no affect on line number.\r\n/// See also <see cref=\"TokenStartIndex\"/>.\r\n/// </remarks>\r\npublic long LineNumber => _lineNumber;\r\n\r\n/// <summary>\r\n/// The number of bytes read so far within the current line of the JSON payload (starting at 0).\r\n/// </summary>\r\n/// <remarks>\r\n/// This returns the current position of the reader which is at the end of the last processed \r\n/// JSON token, not where it started.\r\n/// For property names, that means after the colon (including whatever whitespace or new line \r\n/// characters might be in between the end quote and colon). So, the position in line doesn't \r\n/// coincide with where the end of the property name itself can be found, but rather where the \r\n/// colon was found.\r\n/// See also <see cref=\"TokenStartIndex\"/>.\r\n/// </remarks>\r\npublic long BytePositionInLine => _bytePositionInLine;\r\n```\r\n\r\n```C#\r\n[Fact]\r\npublic static void LineNumberAndPositionSemantics()\r\n{\r\n    string str = \"{  \\\"foo\\\"\\r\\n:  \\\"bar\\\"  }\";\r\n    Utf8JsonReader reader = new Utf8JsonReader(Encoding.UTF8.GetBytes(str));\r\n\r\n    // Generally speaking, white space after a token is not eagerly consumed (only what's before)\r\n    reader.Read(); // Read the start object token\r\n    Assert.Equal(0, reader.LineNumber);\r\n    Assert.Equal(1, reader.BytePositionInLine);\r\n\r\n    // However, an exception is whitespace between property names and the colon that separates \r\n    // name/value is consumed\r\n    reader.Read(); \r\n    // Read the property name\r\n    // Cursor is now at the end of the colon, not at the end of the property name)\r\n    Assert.Equal(1, reader.LineNumber);\r\n    Assert.Equal(1, reader.BytePositionInLine);\r\n\r\n    reader.Read(); \r\n    // Read the value string (cursor is now at the end of the string token)\r\n    Assert.Equal(1, reader.LineNumber);\r\n    Assert.Equal(8, reader.BytePositionInLine);\r\n\r\n    str = \"  [  1 , 2  ]\";\r\n    reader = new Utf8JsonReader(Encoding.UTF8.GetBytes(str));\r\n\r\n    // Generally speaking, white space after a token is not eagerly consumed (only what's before)\r\n    reader.Read(); // Read the start array token\r\n    Assert.Equal(0, reader.LineNumber);\r\n    Assert.Equal(3, reader.BytePositionInLine);\r\n\r\n    reader.Read(); \r\n    // Read the first value, we don't read the comma, end right at the end of the number token\r\n    Assert.Equal(0, reader.LineNumber);\r\n    Assert.Equal(6, reader.BytePositionInLine);\r\n\r\n    reader.Read(); // Read the second value (cursor is now at the end of the 2nd number token)\r\n    Assert.Equal(0, reader.LineNumber);\r\n    Assert.Equal(10, reader.BytePositionInLine);\r\n\r\n    str = \"  [  1/*.\\r\\n.*/ , 2  ]\";\r\n    var options = new JsonReaderOptions { CommentHandling = JsonCommentHandling.Skip };\r\n    reader = new Utf8JsonReader(Encoding.UTF8.GetBytes(str), options);\r\n\r\n    // Generally speaking, white space after a token is not eagerly consumed (only what's before)\r\n    reader.Read(); // Read the start array token\r\n    Assert.Equal(0, reader.LineNumber);\r\n    Assert.Equal(3, reader.BytePositionInLine);\r\n\r\n    reader.Read(); \r\n    // Read the first value (we don't eagerly read the comment in any mode).\r\n    // End right at the end of the number token\r\n    Assert.Equal(0, reader.LineNumber);\r\n    Assert.Equal(6, reader.BytePositionInLine);\r\n\r\n    reader.Read(); \r\n    // Read the second value, skipping comments (cursor is now at the end of the 2nd number token)\r\n    Assert.Equal(1, reader.LineNumber);\r\n    Assert.Equal(7, reader.BytePositionInLine);\r\n\r\n    str = \"  [  1/*.\\r\\n.*/ , 2  ]\";\r\n    options = new JsonReaderOptions { CommentHandling = JsonCommentHandling.Allow };\r\n    reader = new Utf8JsonReader(Encoding.UTF8.GetBytes(str), options);\r\n\r\n    // Generally speaking, white space after a token is not eagerly consumed (only what's before)\r\n    reader.Read(); // Read the start array token\r\n    Assert.Equal(0, reader.LineNumber);\r\n    Assert.Equal(3, reader.BytePositionInLine);\r\n\r\n    reader.Read(); \r\n    // Read the first value (we don't eagerly read the comment in any mode).\r\n    // End right at the end of the number token\r\n    Assert.Equal(0, reader.LineNumber);\r\n    Assert.Equal(6, reader.BytePositionInLine);\r\n\r\n    reader.Read(); // Read the comment (cursor is now at the end of the comment token)\r\n    Assert.Equal(1, reader.LineNumber);\r\n    Assert.Equal(3, reader.BytePositionInLine);\r\n}\r\n```\r\n\r\nHere's the change as a starting point:\r\nhttps://github.com/dotnet/corefx/compare/master...ahsonkhan:ExposeLNandBPInLine?expand=1",
          "createdAt": "2019-10-24T22:48:56Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2019-10-24T22:48:56Z",
          "id": "MDEyOklzc3VlQ29tbWVudDU0NjEzMjk2Ng=="
        },
        {
          "author": "jeffhandley",
          "body": "I'm closing this issue as it hasn't had much traction/interest recently, it's not going to make .NET 7, and its value is lower than many other proposals in the System.Text.Json backlog.",
          "createdAt": "2022-04-06T01:31:10Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-04-06T01:31:10Z",
          "id": "IC_kwDODI9FZc5A8mn3"
        },
        {
          "author": "ewoutkramer",
          "body": "Maybe there wasn't much action because everyone is just waiting for this to be applied?  Were there open issues that needed to be resolved before this can be applied?",
          "createdAt": "2022-04-06T07:33:07Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-04-06T08:55:22Z",
                "user": "marcovisserFurore"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-04-06T16:40:17Z",
                "user": "eerhardt"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-10-22T21:08:55Z",
                "user": "AshleighAdams"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-12-20T12:16:14Z",
                "user": "markusschaber"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-01-23T17:15:56Z",
                "user": "enchart"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-05-17T08:39:35Z",
                "user": "Forestbrook"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-07-22T08:34:39Z",
                "user": "cklutz"
              }
            ],
            "totalCount": 7,
            "endCursor": "Y3Vyc29yOnYyOpHODrAjOA=="
          },
          "updatedAt": "2022-04-06T07:33:07Z",
          "id": "IC_kwDODI9FZc5A9u0f"
        },
        {
          "author": "jeffhandley",
          "body": "Thanks, @ewoutkramer. I'm reopening the issue; it will remain in the Future milestone as it's not planned for inclusion in .NET 7.",
          "createdAt": "2022-04-06T17:50:57Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-04-06T19:46:34Z",
                "user": "marcovisserFurore"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-04-06T20:00:05Z",
                "user": "ewoutkramer"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-01-23T17:16:01Z",
                "user": "enchart"
              }
            ],
            "totalCount": 3,
            "endCursor": "Y3Vyc29yOnYyOpHODTx_pQ=="
          },
          "updatedAt": "2022-04-06T17:50:57Z",
          "id": "IC_kwDODI9FZc5BAJwU"
        },
        {
          "author": "jam40jeff",
          "body": "@jeffhandley That's bad news.  Isn't this a very simple change?  It would be nice to be able to include this information when throwing `JsonException` from a custom converter.",
          "createdAt": "2022-04-08T19:08:53Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-04-08T19:11:18Z",
          "id": "IC_kwDODI9FZc5BKcxr"
        },
        {
          "author": "jeffhandley",
          "body": "We agree that it would be nice, as such this feature will remain in our backlog. Issue #63762 captures what we're focusing on during .NET 7.\r\n\r\nThanks!",
          "createdAt": "2022-04-08T21:41:08Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-04-08T21:41:08Z",
          "id": "IC_kwDODI9FZc5BK66s"
        },
        {
          "author": "ewoutkramer",
          "body": "@jam40jeff - I wrote a set of extension methods to get to these properties using reflection. Yeah, that's definitely not something I like to do, but it works (for now ;-)).",
          "createdAt": "2022-04-11T11:53:58Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-04-11T11:53:58Z",
          "id": "IC_kwDODI9FZc5BQ7y2"
        },
        {
          "author": "danmoseley",
          "body": "@jeffhandley is this a change that a community member could feasibly contribute? It's a little unclear from comments higher up whether there are subtleties that have to be considered, or perhaps exposing \"good enough\" values is straightforward and acceptable for now.",
          "createdAt": "2022-04-11T23:30:54Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-04-12T08:07:03Z",
                "user": "shadow-cs"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-01-23T17:16:14Z",
                "user": "enchart"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-07-26T19:54:05Z",
                "user": "ygoe"
              }
            ],
            "totalCount": 3,
            "endCursor": "Y3Vyc29yOnYyOpHODrvscg=="
          },
          "updatedAt": "2022-04-11T23:30:54Z",
          "id": "IC_kwDODI9FZc5BTu0U"
        },
        {
          "author": "jam40jeff",
          "body": "Could we at least get a helper method like the internal `JsonException ThrowHelper.GetJsonReaderException(...)` (accepting a string error message rather than a resource) to create a `JsonReaderException` with the appropriate values set?",
          "createdAt": "2022-04-12T03:40:19Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-09-16T18:24:06Z",
                "user": "olivier-spinelli"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-11-22T10:33:12Z",
                "user": "ewoutkramer"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-01-23T17:16:18Z",
                "user": "enchart"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-07-12T01:22:40Z",
                "user": "kornman00"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-01-06T18:09:03Z",
                "user": "bstime-tol"
              }
            ],
            "totalCount": 5,
            "endCursor": "Y3Vyc29yOnYyOpHOEBNsYQ=="
          },
          "updatedAt": "2022-04-12T03:40:19Z",
          "id": "IC_kwDODI9FZc5BUrCb"
        },
        {
          "author": "jeffhandley",
          "body": "@danmoseley I don't want to set a community contributor up for frustration by inviting a pull request that we won't be able to promptly review.\r\n\r\nAs is mentioned in #63762, we are continually revising our scope for .NET 7 as we progress through the release. When we hit our next notable checkpoint on the work we have underway right now, we will reassess our availability for being able to champion a community contribution here or bring this back into scope for .NET 7. At the moment though, I do not want to jeopardize #63686 or #63747 in favor of committing to this one.",
          "createdAt": "2022-04-12T17:20:46Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-04-12T17:20:46Z",
          "id": "IC_kwDODI9FZc5BYsXB"
        },
        {
          "author": "danmoseley",
          "body": "Fair enough ",
          "createdAt": "2022-04-12T17:43:17Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-04-12T17:43:17Z",
          "id": "IC_kwDODI9FZc5BYxNp"
        },
        {
          "author": "LostTime76",
          "body": "I have not read through this entire thread, but it is related to a thread that I opened some time ago about wanting line / col information. In addition to exposing line / col information elsewhere, what would be useful is exposing it on JsonElements within JsonDocs. If I get a JsonElement from a doc, I want to know where it is within the byte stream. Heck. I don't even care if you give me line or col information, I just want to know where it is in the data. I can convert the location to a line & col by counting new lines and characters. This would allow for precise doc error location information when a property value is not valid within your use case.\r\n\r\nI had assumed the reason for not giving line information on JsonElements had to do with not wanting to waste the extra bytes in the struct to lower memory size. However, I was wrong. **_You are already storing byte stream location inside the DB rows of the JsonDocument. for each token_**. Why then would I just not be able to call a method on JsonElement, such as JsonElement.GetLocation() to retrieve the location within the stream just like how you do lookups for all the other JsonElement methods using the _idx into the database? Wouldn't this be a very simple API addition? For now, I intend to hack my way into that field using reflection. \r\n\r\n![image](https://user-images.githubusercontent.com/62843610/167153158-f4eda678-5849-4807-93a9-13aa723e680b.png)\r\n\r\n\r\n",
          "createdAt": "2022-05-06T14:27:38Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-05-06T14:29:12Z",
          "id": "IC_kwDODI9FZc5CvQW0"
        },
        {
          "author": "olivier-spinelli",
          "body": "A simple `Utf8JsonReader.ThrowJsonException( string message )` (kind of @jam40jeff proposal) would definitely be great...",
          "createdAt": "2022-09-16T18:27:46Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "ROCKET",
                "createdAt": "2025-01-06T18:10:02Z",
                "user": "bstime-tol"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOEBNs5g=="
          },
          "updatedAt": "2022-09-16T18:27:46Z",
          "id": "IC_kwDODI9FZc5KfI9F"
        },
        {
          "author": "rs-blade",
          "body": "I would find it very useful if JsonReaderState also had public LineNumber and BytePositionInLine properties (not only the Utf8JsonReader)!\r\nBackground: We have an assertion framework that takes a state and forwards it to the exception generation. The state is transported via a generic parameter...so the Utf8JsonReader cannot be used here (as it is a ref struct), but the JsonReaderState can.\r\nI could imagine more cases where using the JsonReaderState and not the Utf8JsonReader is more feasible.",
          "createdAt": "2023-10-02T20:53:18Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-05-14T06:16:43Z",
          "id": "IC_kwDODI9FZc5n74An"
        },
        {
          "author": "tschodde",
          "body": "Dear all,\r\nwhat is the state of this extension? We use it as additional information for our users during the deserialization process, meaning, if we find errors in the structure which are NOT an error in json but for our models and, thus, we will not have the option to get an exception thrown by System.Text.Json. \r\n\r\nSo we either need the linenumber and position or an option on the reader to throw an exception, as stated by [olivier-spinelli](https://github.com/olivier-spinelli). ",
          "createdAt": "2023-12-08T07:46:20Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-05-14T06:17:03Z",
                "user": "rs-blade"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-06-25T15:17:26Z",
                "user": "czdietrich"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-03-14T13:13:37Z",
                "user": "markusschaber"
              }
            ],
            "totalCount": 3,
            "endCursor": "Y3Vyc29yOnYyOpHOEJ88gQ=="
          },
          "updatedAt": "2023-12-08T07:46:20Z",
          "id": "IC_kwDODI9FZc5uEpGx"
        },
        {
          "author": "darrelmiller",
          "body": "Now that we are migrating OpenAPI.NET https://github.com/microsoft/OpenAPI.NET over to use STJ it would be very helpful to be able to show line numbers of where validation errors occur.  We also have other validator libraries that apply a similar pattern for Copilot related scenarios that could benefit from having line numbers for both Utf8JsonReader and JsonNodes that are loaded via JsonDocument.ParseAsync.",
          "createdAt": "2024-05-13T23:45:43Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-05-13T23:45:43Z",
          "id": "IC_kwDODI9FZc59tOup"
        },
        {
          "author": "ygoe",
          "body": "Is anybody still interested in making this change? Here's the code, just add it to the file [System.Text.Json/System/Text/Json/Reader/Utf8JsonReader.cs](https://source.dot.net/#System.Text.Json/System/Text/Json/Reader/Utf8JsonReader.cs,eede8797be67ddbc):\r\n\r\n```cs\r\npublic long LineNumber => _lineNumber;\r\npublic long BytePositionInLine => _bytePositionInLine;\r\n```\r\n\r\nIs it that hard? When I face an invalid value while reading the source with Utf8JsonReader, I want to tell the user where the value can be found. At least approximately. Now I have nothing and the user has to guess and find it themselves. Very frustrating.\r\n\r\nI've made my own reader for a YAML-like format, inspired by this JSON reader, and I just added those properties. Works wonderfully! And it sure can here, too.",
          "createdAt": "2024-07-26T20:00:29Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-10-04T12:11:06Z",
                "user": "czdietrich"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-10-18T00:38:01Z",
                "user": "filzrev"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-11-01T15:01:13Z",
                "user": "alx9r"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-01-06T18:09:44Z",
                "user": "bstime-tol"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-01-23T15:01:59Z",
                "user": "4nds"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-02-03T18:48:54Z",
                "user": "dioptryk"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-02-18T02:37:02Z",
                "user": "jeremy-morren"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-02-19T12:58:10Z",
                "user": "samsosa"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-03-14T14:35:19Z",
                "user": "markusschaber"
              },
              {
                "content": "LAUGH",
                "createdAt": "2025-03-14T14:35:21Z",
                "user": "markusschaber"
              }
            ],
            "totalCount": 10,
            "endCursor": "Y3Vyc29yOnYyOpHOEJ9nNw=="
          },
          "updatedAt": "2024-07-26T20:00:29Z",
          "id": "IC_kwDODI9FZc6GUDHc"
        },
        {
          "author": "jeremy-morren",
          "body": "This is a critical feature (ability to throw helpful exceptions from custom converters). I cannot believe it hasn't been added yet.",
          "createdAt": "2025-02-18T02:41:35Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-02-18T02:41:35Z",
          "id": "IC_kwDODI9FZc6e0LrG"
        }
      ],
      "totalCount": 22,
      "endCursor": "Y3Vyc29yOnYyOpHOntC6xg=="
    },
    "url": "https://github.com/dotnet/runtime/issues/28482",
    "title": "Expose line number and byte position in line as public properties on Utf8JsonReader"
  },
  {
    "author": "terrajobst",
    "labels": [
      "enhancement",
      "area-System.Text.Json",
      "tenet-performance"
    ],
    "createdAt": "2019-03-11T20:26:29Z",
    "body": "_From @hez2010 on March 9, 2019 9:19_\n\n### Is your feature request related to a problem? Please describe.\r\nFeature request. Enable SIMD for the new Json APIs in ASP.NET Core 3.\r\n\r\n### Describe the solution you'd like\r\nSee [SimdJsonSharp](https://github.com/EgorBo/SimdJsonSharp)  \r\nWith SIMD support, SimdJsonSharp is faster than any existing Json library on .NET.  \r\nI think the new Json APIs in ASP.NET Core 3 should add SIMD support to improve its performance.\n\n_Copied from original issue: aspnet/AspNetCore#8366_",
    "number": 28937,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "THUMBS_UP",
          "createdAt": "2019-03-12T00:02:12Z",
          "user": "HFadeel"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2019-03-12T08:39:45Z",
          "user": "DSilence"
        },
        {
          "content": "HEART",
          "createdAt": "2019-03-12T09:41:52Z",
          "user": "Rodrigo-Andrade"
        },
        {
          "content": "HEART",
          "createdAt": "2019-03-12T10:26:57Z",
          "user": "EgorBo"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2019-03-12T13:08:51Z",
          "user": "steskalja"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2019-03-12T15:02:04Z",
          "user": "rducom"
        },
        {
          "content": "HEART",
          "createdAt": "2019-03-12T15:02:05Z",
          "user": "rducom"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2019-03-13T08:15:05Z",
          "user": "epicabsol"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2019-03-13T12:40:19Z",
          "user": "JanEggers"
        },
        {
          "content": "HEART",
          "createdAt": "2019-03-13T12:40:22Z",
          "user": "JanEggers"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2019-03-13T16:11:20Z",
          "user": "leis1015"
        },
        {
          "content": "HEART",
          "createdAt": "2019-03-13T16:11:32Z",
          "user": "leis1015"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2019-03-14T05:21:04Z",
          "user": "bgrainger"
        },
        {
          "content": "HEART",
          "createdAt": "2019-03-14T17:27:59Z",
          "user": "ZOXEXIVO"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2019-03-18T06:57:43Z",
          "user": "ycrumeyrolle"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2019-03-19T04:19:41Z",
          "user": "kronic"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2019-04-25T03:39:53Z",
          "user": "ryanelian"
        },
        {
          "content": "HEART",
          "createdAt": "2019-04-25T03:39:54Z",
          "user": "ryanelian"
        },
        {
          "content": "HEART",
          "createdAt": "2019-05-09T23:02:20Z",
          "user": "ahsonkhan"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2019-05-09T23:02:21Z",
          "user": "ahsonkhan"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2019-06-03T02:12:38Z",
          "user": "hez2010"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2019-06-14T22:52:09Z",
          "user": "AmrAlSayed0"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2019-07-03T23:14:44Z",
          "user": "ZOXEXIVO"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2019-09-25T04:05:22Z",
          "user": "xsoheilalizadeh"
        },
        {
          "content": "HEART",
          "createdAt": "2019-09-25T04:05:24Z",
          "user": "xsoheilalizadeh"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2020-04-09T13:56:59Z",
          "user": "aharpervc"
        },
        {
          "content": "HEART",
          "createdAt": "2020-04-09T13:57:00Z",
          "user": "aharpervc"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-05-10T18:28:47Z",
          "user": "expcat"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-01-14T01:24:49Z",
          "user": "antoniofreire"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-02-12T09:11:41Z",
          "user": "0xfeeddeadbeef"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-11-18T20:17:40Z",
          "user": "N0D4N"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-07-09T18:45:00Z",
          "user": "redthing1"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-10-11T20:51:38Z",
          "user": "franklbt"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-08-09T05:24:50Z",
          "user": "Rabadash8820"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-09-19T06:28:13Z",
          "user": "Meir017"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-09-23T07:14:07Z",
          "user": "issue-dispenser"
        }
      ],
      "totalCount": 36,
      "endCursor": "Y3Vyc29yOnYyOpHOAxSuIA=="
    },
    "updatedAt": "2022-10-13T17:17:50Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": "terrajobst",
          "body": "Hey @hez2010 that's a great suggestion. We're in the middle of providing a new perf oriented set of JSON APIs for .NET Core 3.0.\r\n\r\n@ahsonkhan, what's your take on this?",
          "createdAt": "2019-03-11T20:28:44Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2019-03-11T20:28:44Z",
          "id": "MDEyOklzc3VlQ29tbWVudDQ3MTcxNjQ3MQ=="
        },
        {
          "author": "Tornhoof",
          "body": "My personal take on this:\r\nIf you take a look at @EgorBo's SimdJsonSharp and the available benchmarks the structural symbol tape concept really shines the larger the data gets, especially if it is pretty-printed (i.e. much whitespace between relevant symbols). If that's not the case, e.g. no pretty-printing, most of the time is spent in parsing of the more complex data types. That's visibile in the benchmark, a simpler, \"not-as-valid\" double parser is easily ten times faster than the corefx version.\r\nStill I expect SimdJsonSharp (especially if it's further optimized) to be twice as fast (or more) for data sizes of 1kb and larger, compared to the \"normal\" approach of a byte-per-byte parser.",
          "createdAt": "2019-03-11T21:29:21Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2019-03-11T23:04:49Z",
                "user": "terrajobst"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2019-03-13T05:47:39Z",
                "user": "avgalex"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2019-03-13T08:15:57Z",
                "user": "epicabsol"
              }
            ],
            "totalCount": 3,
            "endCursor": "Y3Vyc29yOnYyOpHOAk5mzw=="
          },
          "updatedAt": "2019-03-11T21:29:21Z",
          "id": "MDEyOklzc3VlQ29tbWVudDQ3MTczNzQ3Nw=="
        },
        {
          "author": "terrajobst",
          "body": "I think we'll never have the option to be forgiving in parsing in the name of perf, due to security concerns. However, I don't see a reason why we shouldn't be speeding up the implementation using SIMD.",
          "createdAt": "2019-03-11T23:05:34Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2019-03-11T23:05:34Z",
          "id": "MDEyOklzc3VlQ29tbWVudDQ3MTc3NTQzMQ=="
        },
        {
          "author": "filipnavara",
          "body": "SimdJsonSharp does full validation, including checking for valid UTF-8. However, it is designed around parsing large chunks and may need to be adjusted to provide something more \"streamable\" and memory efficient in addition to being fast. I recommend reading the papers about original SimdJson to figure out what it does and how it accomplished it.",
          "createdAt": "2019-03-12T08:16:22Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2019-04-13T23:57:03Z",
                "user": "am11"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOAm4IUg=="
          },
          "updatedAt": "2019-03-12T12:26:56Z",
          "id": "MDEyOklzc3VlQ29tbWVudDQ3MTg5OTQzMg=="
        },
        {
          "author": "NinoFloris",
          "body": "Any news on this?",
          "createdAt": "2019-04-13T21:50:23Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2019-04-13T21:50:23Z",
          "id": "MDEyOklzc3VlQ29tbWVudDQ4Mjg5Mjg1Mg=="
        },
        {
          "author": "tannergooding",
          "body": "I'd defer to @ahsonkhan for his stance; but I would expect we aren't going to look into this for the 3.0 timeframe. Instead, 3.0 will likely aim towards getting the new API shipped and stable and perf improvements (like this) will be investigated for a future release.",
          "createdAt": "2019-04-14T02:10:45Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2019-05-09T23:02:17Z",
                "user": "ahsonkhan"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2019-06-19T11:04:16Z",
                "user": "Gnbrkm41"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2019-09-25T04:08:02Z",
                "user": "xsoheilalizadeh"
              }
            ],
            "totalCount": 3,
            "endCursor": "Y3Vyc29yOnYyOpHOAxSufQ=="
          },
          "updatedAt": "2019-04-14T02:10:45Z",
          "id": "MDEyOklzc3VlQ29tbWVudDQ4MjkxMjM0NQ=="
        },
        {
          "author": "ahsonkhan",
          "body": "> but I would expect we aren't going to look into this for the 3.0 timeframe. Instead, 3.0 will likely aim towards getting the new API shipped and stable and perf improvements (like this) will be investigated for a future release.\r\n\r\nPrecisely.\r\n\r\nThe SIMD work definitely looks promising and we should definitely investigate how we can incorporate it into the implementation of `System.Text.Json` APIs. I prefer we defer this work until after we have locked the API design and features for 3.0. If anyone wants to tackle parts of this or work on prototypes to incorporate some of the SIMD effort with the existing `Utf8JsonReader`, that would definitely be appreciated!",
          "createdAt": "2019-05-09T23:00:45Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "EYES",
                "createdAt": "2020-02-09T19:51:57Z",
                "user": "ycrumeyrolle"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOA7HATA=="
          },
          "updatedAt": "2019-05-09T23:00:45Z",
          "id": "MDEyOklzc3VlQ29tbWVudDQ5MTA5NzExMg=="
        },
        {
          "author": "RobertHenry6bev",
          "body": "See the paper https://arxiv.org/pdf/1902.08318.pdf on ideas for using SIMD\r\n\r\nSee the git repo https://github.com/simdjson/simdjson",
          "createdAt": "2020-04-09T03:55:38Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2020-04-09T03:55:38Z",
          "id": "MDEyOklzc3VlQ29tbWVudDYxMTMxMzk3MQ=="
        },
        {
          "author": "eiriktsarpalis",
          "body": "Next step would be to identify concrete vectorization opportunities in the codebase. STJ already uses vectorization indirectly via the encoding routines in `System.Text.Encodings.Web` and the Span helper methods.",
          "createdAt": "2022-09-02T15:24:48Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-09-02T15:24:48Z",
          "id": "IC_kwDODI9FZc5JpjxR"
        },
        {
          "author": "layomia",
          "body": "Triage: we should also assess prior art from other serializers and how they utilize SIMD.",
          "createdAt": "2022-10-13T17:17:50Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-10-13T17:17:50Z",
          "id": "IC_kwDODI9FZc5MK8Nb"
        }
      ],
      "totalCount": 10,
      "endCursor": "Y3Vyc29yOnYyOpHOTCvDWw=="
    },
    "url": "https://github.com/dotnet/runtime/issues/28937",
    "title": "Enable SIMD for JSON API"
  },
  {
    "author": "a11e99z",
    "labels": [
      "enhancement",
      "area-System.Text.Json",
      "json-functionality-doc"
    ],
    "createdAt": "2019-04-03T15:11:53Z",
    "body": "many JSON looks like this:\r\n{\"num\":\"123\",\"str\":\"hello\"}\r\nNumber can be in quotes too\r\n\r\nJsonElement.GetInt64() throws Exception that \"we need Number but we have a String\".\r\nI am sure that in quotes we have a Number, so code (GetInt64 and others) should ignore quotes and try parse number. and only in case when cannot parse Number(invalid chars) throw some Exception\r\n\r\nUPD\r\nOops! I used unclear title. better \r\n..JsonElement should parse Numbers in qoutes\r\n\r\nSUMMATION:\r\n1) GetInt64() and etc should parse Numbers(long,uint,decimal..) for String elements: ignore first and last quotes.\r\n2) add .AsSpan() method to JsonElement for cases when we want to do something with elements manually. we cannot access to element data  and do something useful or work around with some problem (.GetString(), .ToString(), .GetRawString() - stress GC and they are not solution)",
    "number": 29152,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "THUMBS_UP",
          "createdAt": "2019-07-10T01:16:00Z",
          "user": "IvanJosipovic"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2019-07-15T00:44:24Z",
          "user": "NickCraver"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2019-07-15T02:21:19Z",
          "user": "itsmecurtis"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-03-30T08:43:36Z",
          "user": "slang25"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-04-29T00:42:22Z",
          "user": "AlexandreArpinMotion"
        }
      ],
      "totalCount": 5,
      "endCursor": "Y3Vyc29yOnYyOpHOCvyf1A=="
    },
    "updatedAt": "2025-06-06T22:32:32Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": "a11e99z",
          "body": "in case that u suppose solution long.Parse( elem.GetString() ) - well, we lose all the advantage of not allocating memory.\r\nJsonDocument loose any advantages in case when JSON has many numbers(long,int,decimal) in quotes  and better to use Json.NET.",
          "createdAt": "2019-04-03T15:16:50Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2019-04-03T15:38:33Z",
          "id": "MDEyOklzc3VlQ29tbWVudDQ3OTUzNDIxNQ=="
        },
        {
          "author": "a11e99z",
          "body": "2) I can parse Number in quotes by myself but I cannot to get span of element or JSON-position (like in Utf8JsonReader.Position)\r\nso, add method to JsonElement.AsSpan() or something.\r\nIt simple and let us to get around a lot of problems cause we can do something with the elements manually.",
          "createdAt": "2019-04-03T15:20:19Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2019-04-03T15:30:01Z",
          "id": "MDEyOklzc3VlQ29tbWVudDQ3OTUzNTY5Mw=="
        },
        {
          "author": "ahsonkhan",
          "body": "cc @bartonjs ",
          "createdAt": "2019-04-04T03:17:30Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2019-04-04T03:17:30Z",
          "id": "MDEyOklzc3VlQ29tbWVudDQ3OTczNDMyOQ=="
        },
        {
          "author": "bartonjs",
          "body": "> add method to JsonElement.AsSpan() or something.\r\n\r\nThat's something we're explicitly keeping out of the API.  JsonDocument and JsonElement can apply over UTF-8 or UTF-16 data, exposing the span removes that abstraction.\r\n\r\n> Number can be in quotes too\r\n\r\nThe easy question is \"why is the number in a string instead of just being a number?\".  Once strings start being parsed there become questions of acceptable formats, and culture sensitivity, et cetera.  e.g. the number \"123,456\" is either bigger than 1000 (en-US) or between 100 and 1000 (en-UK).\r\n\r\nIf I understand the flow correctly, JValue's int-conversion only uses the \"N\" format, removing the culture and format problems.\r\n\r\nI don't suppose you have any sort of data suggesting how popular it is to transmit numbers as JSON strings instead of JSON numbers?\r\n\r\n> in case that u suppose solution long.Parse( elem.GetString() ) - well, we lose all the advantage of not allocating memory.\r\n\r\nIt's still significantly lower allocation than the equivalent in JValue, since this would allocate the number-string into gen0, you'd parse it, you'd lose the reference, and it'll avoid getting promoted to gen1.  In JsonTextReader to JValue the (sub)string got allocated during document traversal (probably getting promoted to gen1) along with lots of other short strings, and then much later is parsed (while still staying as a string held alive by the JValue).",
          "createdAt": "2019-04-04T04:08:53Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2019-04-04T04:46:30Z",
                "user": "ahsonkhan"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2019-04-05T20:04:23Z",
                "user": "Gnbrkm41"
              }
            ],
            "totalCount": 2,
            "endCursor": "Y3Vyc29yOnYyOpHOAmam9A=="
          },
          "updatedAt": "2019-04-04T04:08:53Z",
          "id": "MDEyOklzc3VlQ29tbWVudDQ3OTc0MjczOQ=="
        },
        {
          "author": "a11e99z",
          "body": "sometimes you've got data from server where u cannot change anything (Bitcoin exchange Binance for example). \r\n//                               timestamp: no quotes.              price change: have quotes\r\n[{\"e\":\"24hrTicker\",\"E\":1554206291885,\"s\":\"ETHBTC\",\"p\":\"-0.00230300\"... and many more numbers with quotes.\r\nAPI description https://github.com/binance-exchange/binance-official-api-docs/blob/master/web-socket-streams.md\r\n\r\nwell, we have data and we should to do something with this. \r\nwhen objects dont allow do something useful - such objects will not be used.\r\nwe live in the world where have many colors not just black and white. so, my request is not to do worse, is to do better with things that we have. \r\nall job that needed is couple lines of code. (I am not sure for that coz many method invocations inside)\r\n\r\nwrite now my codegenerator looks like (used Roslyn Scripting):\r\ncod.AppendLine( $\"if (nod.TryGetProperty( \\\"{fld.Name}\\\", out prop )) \" );\r\nif (ftyp == typeof( sbyte ) || ftyp == typeof( short ) || ftyp == typeof( int ) || ftyp == typeof( long ))\r\ncod.AppendLine( $\"\tres.{fld.Name} = ( System.{ftyp.Name} )(prop.Type == System.Text.Json.JsonValueType.String ? long.Parse( prop.GetString()) : prop.GetInt64());\" );\r\n// long.Parse( prop.GetString()) - \"failed\" use object.. better to use Json.NET and loose couple of milliseconds.\r\nlast line instead that I expected to work well (line where I dont expect Exception)\r\ncod.AppendLine( $\"\tres.{fld.Name} = ( System.{ftyp.Name} )prop.GetInt64());\" );\r\n\r\nwith prop.AsSpan() I can (try to) parse span manually without any allocation.\r\nwith prop.GetInt64() that parses Numbers in quotes I have simple working code without any allocation.\r\n\r\nwell, GetXXX() that parses numbers in quotes solve my problem and dont need add AsSpan(). \r\nbut AsSpan() will allow to use some hacks/optimization/access to JSON-element data in scenarios that we cant see right now.\r\n\r\nmy point is that we have numbers inside quotes in JSON and we can't change this. \r\nso we need some methods that allow us to parse those numbers without any string allocations.\r\nI dont know (dont care for sure) how to do this, maybe change current methods maybe add new ones\r\nGetStringAsInt64(), xxxUInt64, xxxDouble, xxxDecimal will be enough, no need for float, byte, int, ushort..",
          "createdAt": "2019-04-04T07:07:07Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2019-04-04T14:47:21Z",
          "id": "MDEyOklzc3VlQ29tbWVudDQ3OTc3NzE4Mg=="
        },
        {
          "author": "a11e99z",
          "body": "OFFTOPIC:\r\n\r\nwell, I can try to use Utf8JsonReader for my task and (I didnt try yet but IMO) it will increase my code twice and harder code-logic maybe 5 times.\r\n\r\nmaybe later I will want my code even faster and rewrite it (or will hire u to rewrite it :) ) for Utf8JsonReader but now I want simple MVP. next level will be native codegeneration (Roslyn, LLVM..), next - FPGA & HFT..\r\n\r\nin trading you dont need any allocations even in gen0 or Edens. u just cant stop (all) thread(s) for 10-50ms.\r\n\r\nwe can save 5ms in one type message from exchange vs Json.NET.. we have 10 message types, 100 instruments/securities, 10 another exchanges with 5 of them with numbers in quotes.. so u can save for 1second of real time >1second of CPU (many threads) of parse/GCcollect work that we can to spend to more useful work for real problem solution but not to fight with developer tasks.. \r\ncent saves the dollar.. millisecond saves the second",
          "createdAt": "2019-04-04T08:09:30Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "CONFUSED",
                "createdAt": "2019-04-05T20:32:47Z",
                "user": "Gnbrkm41"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOAmatUA=="
          },
          "updatedAt": "2019-04-04T09:34:06Z",
          "id": "MDEyOklzc3VlQ29tbWVudDQ3OTc5NTU3Mw=="
        },
        {
          "author": "Gnbrkm41",
          "body": "> I don't suppose you have any sort of data suggesting how popular it is to transmit numbers as JSON strings instead of JSON numbers?\r\n\r\n+1, I'm no JSON expert, but from what I can see I'm not sure if it is a common scenario to serialise numbers as string type. https://stackoverflow.com/a/15368259/10484567 A little bit of search seem to suggest that it's not a number once it's been quoted.\r\n\r\nI'm against adding supports for non-standard usages of common protocols. I think the benefits of implementing this in BCL are not worth the amount of efforts needed to do so.",
          "createdAt": "2019-04-05T20:20:42Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2019-04-05T20:21:22Z",
          "id": "MDEyOklzc3VlQ29tbWVudDQ4MDQwOTY4OA=="
        },
        {
          "author": "Gnbrkm41",
          "body": "@bartonjs by \"between 100 and 1000 (en-UK)\", I believe you've meant 'en-GB' 😀. The UK also uses full stop as decimal points, so '123,456' would be \"one hundred and twenty three thousand, four hundred and fifty six\". The point still holds in majority of European countries though. (e.g. 'fr-FR', 'de-DE'...)",
          "createdAt": "2019-04-05T20:29:43Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2019-04-05T20:29:43Z",
          "id": "MDEyOklzc3VlQ29tbWVudDQ4MDQxMjE5Ng=="
        },
        {
          "author": "Gnbrkm41",
          "body": "dotnet/corefx#36639 Could this solve your problem (if implemented)?",
          "createdAt": "2019-04-05T21:21:43Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2019-04-05T21:21:43Z",
          "id": "MDEyOklzc3VlQ29tbWVudDQ4MDQyNjA2MA=="
        },
        {
          "author": "bartonjs",
          "body": "> by \"between 100 and 1000 (en-UK)\", I believe you've meant 'en-GB' grinning\r\n\r\nYep, oops 🤭.   Though, looking at an old culture document I built it looks like en-UK doesn't (didn't?) exist, and en-GB used comma-and-period the same as en-US.  de-DE, OTOH, reverses them (like I thought \"en-UK\" did). -- But the write time on that doc is 2009, so maybe things have changed in the last 10 years :smile:.",
          "createdAt": "2019-04-05T22:28:03Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2019-04-05T22:28:03Z",
          "id": "MDEyOklzc3VlQ29tbWVudDQ4MDQ0MTcyNw=="
        },
        {
          "author": "Wildenhaus",
          "body": "> ... from what I can see I'm not sure if it is a common scenario to serialise numbers as string type ...\r\n\r\nWhen working with financial data, it is an industry standard to stringify numeric types in order to avoid rounding errors. In fact, [this is part of the reason](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/decimal) that the `Decimal` type has been introduced.\r\n\r\nIt would make perfect sense for `Utf8JsonReader` to at the very least allow the parsing of strings when calling `GetDecimal`, if not for other floating point types as well.\r\n\r\n",
          "createdAt": "2019-05-16T20:51:47Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2019-05-16T20:53:44Z",
          "id": "MDEyOklzc3VlQ29tbWVudDQ5MzIyNzQ4OA=="
        },
        {
          "author": "bartonjs",
          "body": "> When working with financial data, it is an industry standard to stringify numeric types in order to avoid rounding errors\r\n\r\nBut JSON numbers are already stringified.  The question is, does the financial industry send JSON like\r\n\r\n{ \"amount\": \"18.13\" } or { \"amount\": 18.13 }.  The former is a JsonValueType.String, the latter is a JsonValueType.Number, which is a still a string on the wire.",
          "createdAt": "2019-05-16T21:15:15Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2019-05-16T21:15:15Z",
          "id": "MDEyOklzc3VlQ29tbWVudDQ5MzIzNDU3NA=="
        },
        {
          "author": "Wildenhaus",
          "body": "> But JSON numbers are already stringified.\r\n\r\nTrue, but that doesn't consider platform-specific type handling. For instance, the JavaScript spec defines floating point numbers as 64-bit IEEE 754. Developers will use libraries like [decimal.js](https://github.com/MikeMcl/decimal.js/) or [BigInteger](https://github.com/peterolson/BigInteger.js) in order to avoid the precision limitations set by the spec. \r\n\r\nConsider what would happen if a JavaScript client tried to parse the number `0.987765432109876543210` from JSON. If it were in a number format, it would be rounded to `0.98776543210987655`, whereas if it were in string format, it could be handled differently and sent to a library supporting a larger precision. In the grand scheme of things, the way floating point numbers are handled is largely dependent on the platform consuming the serialized data.\r\n\r\nCoinbase, which is the leading cryptocurrency exchange based in the United States, [states that they have adopted the practice of stringifying floating point numbers](https://docs.pro.coinbase.com/#numbers) for this exact reason:\r\n\r\n> Decimal numbers are returned as strings to preserve full precision across platforms. When making a request, it is recommended that you also convert your numbers to strings to avoid truncation and precision errors. Integer numbers (like trade id and sequence) are unquoted.\r\n\r\n> The question is, does the financial industry send JSON like { \"amount\": \"18.13\" } or { \"amount\": 18.13 }\r\n\r\nActually, I'm almost certain that the most prevalent technique is to just ditch floating point numbers altogether in favor of 64-bit integers with separate decimal place tracking, but that can cause issues if the number happens to exceed a 64-bit integer's range.\r\n\r\n[It looks like JSON Schema has decided on this feature](https://github.com/json-schema-org/json-schema-spec/issues/361), but hasn't implemented it yet. Might be worth keeping an eye on.",
          "createdAt": "2019-05-16T22:09:46Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2019-05-18T18:16:44Z",
          "id": "MDEyOklzc3VlQ29tbWVudDQ5MzI0OTA3MA=="
        },
        {
          "author": "Gnbrkm41",
          "body": "That looks fair to me. ",
          "createdAt": "2019-05-17T12:00:57Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2019-05-17T12:00:57Z",
          "id": "MDEyOklzc3VlQ29tbWVudDQ5MzQyODI0Nw=="
        },
        {
          "author": "manigandham",
          "body": "Javascript is limited to 53 bits of precision so all 64-bit integers will be truncated. We have to use strings in JSON so that these values are transmitted correctly. This is standard industry practice because there's no other option.\r\n\r\nHaving the ability to both parse and write 64-bit integers as strings is a must, especially for JSON-based APIs.",
          "createdAt": "2019-06-24T01:42:15Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2019-06-26T22:58:52Z",
                "user": "Wildenhaus"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2019-07-15T04:27:07Z",
                "user": "scalablecory"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2019-07-15T04:27:52Z",
                "user": "sixlettervariables"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2019-07-30T10:07:42Z",
                "user": "khellang"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2020-11-06T23:53:43Z",
                "user": "Paul-Dempsey"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-10-21T14:56:36Z",
                "user": "steveharter"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-03-28T13:25:43Z",
                "user": "manigandham"
              }
            ],
            "totalCount": 7,
            "endCursor": "Y3Vyc29yOnYyOpHOCU8oQw=="
          },
          "updatedAt": "2019-09-29T09:14:31Z",
          "id": "MDEyOklzc3VlQ29tbWVudDUwNDgwOTg0Mg=="
        },
        {
          "author": "NickCraver",
          "body": "I have have hit this as well, but didn't find this issue (I'm using the `.Parse<T>()` API). Raised here: https://github.com/dotnet/corefx/issues/39473",
          "createdAt": "2019-07-15T00:39:22Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2019-07-15T02:13:17Z",
                "user": "theolivenbaum"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2019-07-15T15:05:56Z",
                "user": "Wildenhaus"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-04-29T00:43:42Z",
                "user": "AlexandreArpinMotion"
              }
            ],
            "totalCount": 3,
            "endCursor": "Y3Vyc29yOnYyOpHOC61AFQ=="
          },
          "updatedAt": "2019-07-15T00:39:22Z",
          "id": "MDEyOklzc3VlQ29tbWVudDUxMTI0ODcxOA=="
        },
        {
          "author": "manigandham",
          "body": "Now possible using the new Json converters on 3.0 preview-7\r\n\r\n```csharp\r\n    public class LongToStringSupport : JsonConverter<long>\r\n    {\r\n        public override long Read(ref Utf8JsonReader reader, Type type, JsonSerializerOptions options)\r\n        {\r\n            if (reader.TokenType == JsonTokenType.String && Int64.TryParse(reader.GetString(), out var number))\r\n                return number;\r\n\r\n            return reader.GetInt64();\r\n        }\r\n\r\n        public override void Write(Utf8JsonWriter writer, long value, JsonSerializerOptions options)\r\n        {\r\n            writer.WriteStringValue(value.ToString());\r\n        }\r\n    }\r\n```\r\n\r\n```csharp\r\nservices.AddControllersWithViews()\r\n   .AddJsonOptions(options =>\r\n   {\r\n        options.JsonSerializerOptions.Converters.Add(new LongToStringSupport());\r\n   });\r\n```",
          "createdAt": "2019-07-26T14:24:42Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "HEART",
                "createdAt": "2019-07-26T23:45:26Z",
                "user": "Wildenhaus"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOAtUa3w=="
          },
          "updatedAt": "2019-07-26T14:24:42Z",
          "id": "MDEyOklzc3VlQ29tbWVudDUxNTQ3NDc5OA=="
        },
        {
          "author": "zelyony",
          "body": "> ```cs\r\n> if (reader.TokenType == JsonTokenType.String && Int64.TryParse(reader.GetString(), out var number))\r\n>                 return number;\r\n> ```\r\n\r\nPoint of this issue is NOT to use GetString() for JsonTokenType.String that is really decimal or long.",
          "createdAt": "2019-08-03T20:26:42Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2019-08-03T20:26:42Z",
          "id": "MDEyOklzc3VlQ29tbWVudDUxNzk1MjM3Mw=="
        },
        {
          "author": "manigandham",
          "body": "@zelyony \r\n\r\nYea, it can be better. Here's an updated version to use the [same Utf8Parser code](https://github.com/dotnet/corefx/blob/master/src/System.Text.Json/src/System/Text/Json/Reader/Utf8JsonReader.TryGet.cs#L607): \r\n\r\n```csharp\r\npublic class LongToStringConverter : JsonConverter<long>\r\n{\r\n    public override long Read(ref Utf8JsonReader reader, Type type, JsonSerializerOptions options)\r\n    {\r\n        if (reader.TokenType == JsonTokenType.String)\r\n        {\r\n            ReadOnlySpan<byte> span = reader.HasValueSequence ? reader.ValueSequence.ToArray() : reader.ValueSpan;\r\n            if (Utf8Parser.TryParse(span, out long number, out int bytesConsumed) && span.Length == bytesConsumed)\r\n                return number;\r\n        }\r\n\r\n        return reader.GetInt64();\r\n    }\r\n\r\n    public override void Write(Utf8JsonWriter writer, long value, JsonSerializerOptions options)\r\n    {\r\n        writer.WriteStringValue(value.ToString());\r\n    }\r\n}\r\n```\r\n",
          "createdAt": "2019-08-04T09:06:30Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2019-08-05T06:45:11Z",
          "id": "MDEyOklzc3VlQ29tbWVudDUxNzk4NjU3NQ=="
        },
        {
          "author": "ahsonkhan",
          "body": "@manigandham, @zelyony - note that the latest converter sample that was shared won't work for numbers that are escaped since you are using the `ValueSpan` property to get the raw bytes (the previous sample using `GetString()` would work though). In case that scenario matters for your use case.\r\n\r\nSay, the digit 2 was instead escaped as `\\\\u0032`.\r\n```C#\r\nconst string json = \"\\\"123456789010\\\\u0032\\\"\";\r\n\r\nvar options = new JsonSerializerOptions();\r\noptions.Converters.Add(new LongToStringConverter());\r\n\r\n// throws System.InvalidOperationException : Cannot get the value of a token type 'String' as a number\r\n// since Utf8Parser.TryParse returned false\r\nlong val = JsonSerializer.Deserialize<long>(json, options);\r\nAssert.Equal(1234567890102, val);\r\n\r\nstring jsonSerialized = JsonSerializer.Serialize(val, options);\r\nAssert.Equal(\"\\\"1234567890102\\\"\", jsonSerialized);\r\n```\r\n",
          "createdAt": "2019-08-09T04:04:03Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2019-08-09T04:04:03Z",
          "id": "MDEyOklzc3VlQ29tbWVudDUxOTc2ODgyNw=="
        },
        {
          "author": "manigandham",
          "body": "@ahsonkhan Got it, thanks for the note. I guess both statements can be combined to handle that situation as well:\r\n\r\n```csharp\r\npublic class LongToStringConverter : JsonConverter<long>\r\n{\r\n    public override long Read(ref Utf8JsonReader reader, Type type, JsonSerializerOptions options)\r\n    {\r\n        if (reader.TokenType == JsonTokenType.String)\r\n        {\r\n            ReadOnlySpan<byte> span = reader.HasValueSequence ? reader.ValueSequence.ToArray() : reader.ValueSpan;\r\n            if (Utf8Parser.TryParse(span, out long number, out int bytesConsumed) && span.Length == bytesConsumed)\r\n                return number;\r\n\r\n            if (Int64.TryParse(reader.GetString(), out number))\r\n                return number;\r\n        }\r\n\r\n        return reader.GetInt64();\r\n    }\r\n\r\n    public override void Write(Utf8JsonWriter writer, long value, JsonSerializerOptions options)\r\n    {\r\n        writer.WriteStringValue(value.ToString());\r\n    }\r\n}\r\n```",
          "createdAt": "2019-08-09T05:54:24Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "HEART",
                "createdAt": "2022-11-02T18:43:46Z",
                "user": "HenrikHoyer"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOCu7EhA=="
          },
          "updatedAt": "2019-08-09T05:54:24Z",
          "id": "MDEyOklzc3VlQ29tbWVudDUxOTc4ODUxOA=="
        },
        {
          "author": "shaig4",
          "body": "I Have same issue with booleans, decimals and dates, \r\nshould be added a flag to enable quoted values.\r\n",
          "createdAt": "2019-09-29T06:46:08Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2019-09-29T06:51:32Z",
                "user": "mbont"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2019-10-23T17:28:34Z",
                "user": "stefando"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2020-01-29T10:26:07Z",
                "user": "manju064"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2020-06-20T10:47:21Z",
                "user": "huoyaoyuan"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2020-08-10T09:54:19Z",
                "user": "IanKemp"
              }
            ],
            "totalCount": 5,
            "endCursor": "Y3Vyc29yOnYyOpHOBM3www=="
          },
          "updatedAt": "2019-09-29T06:46:08Z",
          "id": "MDEyOklzc3VlQ29tbWVudDUzNjI1NzUwNw=="
        },
        {
          "author": "manigandham",
          "body": "@shaig4 - There's a comment about that option in the other issue: https://github.com/dotnet/corefx/issues/39473#issuecomment-526245607\r\n\r\nMaybe these issues should be merged to avoid duplicate discussions...",
          "createdAt": "2019-09-29T09:16:34Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2019-09-29T09:16:34Z",
          "id": "MDEyOklzc3VlQ29tbWVudDUzNjI3MzE1OA=="
        },
        {
          "author": "steveharter",
          "body": "Linking https://github.com/dotnet/corefx/issues/40120 as supporting quoted numbers in the the deserializer for dictionaries is a feature ask.",
          "createdAt": "2019-10-09T16:24:40Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2019-10-09T16:24:40Z",
          "id": "MDEyOklzc3VlQ29tbWVudDU0MDA3ODE3NQ=="
        },
        {
          "author": "huoyaoyuan",
          "body": "Please do this at low level if possible - definitely we don't want to allocate temporary strings like naïve converters will do.",
          "createdAt": "2020-06-20T14:33:25Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2020-06-20T14:33:25Z",
          "id": "MDEyOklzc3VlQ29tbWVudDY0NzAwMzI3Nw=="
        },
        {
          "author": "eiriktsarpalis",
          "body": "A few updates on this issue:\r\n\r\n* https://github.com/dotnet/runtime/issues/30255#issuecomment-658313884 Added support on the serialization layer via the `JsonNumberHandling` enum.\r\n* Superficially the new `JsonNode` type does not seem to honor `JsonNumberHandling`:\r\n\r\n```csharp\r\nvar options = new JsonSerializerOptions { NumberHandling = JsonNumberHandling.AllowReadingFromString };\r\nvar node = JsonSerializer.Deserialize<JsonNode>(@\"{ \"\"num\"\" : \"\"1\"\"}\", options);\r\nnode[\"num\"].GetValue<int>(); // System.InvalidOperationException: An element of type 'String' cannot be converted to a 'System.Int32'.\r\n```\r\n\r\n@steveharter is this something we should consider addressing in a future release?",
          "createdAt": "2021-10-20T15:34:12Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-10-20T15:34:12Z",
          "id": "IC_kwDODI9FZc44fhUA"
        },
        {
          "author": "steveharter",
          "body": "I do think having pushing these simpler serializer-only features like quoted numbers and [JsonIgnoreCondition](https://github.com/dotnet/runtime/issues/54184) down to node and element is goodness. Some may even make sense at the reader\\writer level.\r\n\r\nSince `JsonNode` is layered on `JsonElement` during deserialization, to support the various serializer-related features for node we would need to:\r\n- Add the appropriate knobs to the various option types:\r\n  - `JsonDocumentOptions`.\r\n  - `JsonNodeOptions`.\r\n  - Optionally to `JsonReaderOptions` and `JsonWriterOptions` if we want to expose that there; document\\element layers on the reader\\writer. We have to make sure performance doesn't degrade.\r\n- Implement the handling of the various options in `JsonElement`, `JsonNode` and optionally in `Utf8JsonReader\\Utf8JsonWriter` including adding new APIs to expose the functionality.\r\n- Address interop between the various options:\r\n  - Ensure that `JsonNodeOptions` properly transfers settings to `JsonDocumentOptions` and if appropriate, `JsonDocumentOptions` to `JsonReaderOptions` and `JsonWriterOptions`.\r\n  - Add helpers to obtain the type-specific options from an instance of `JsonSerializerOptions`. Currently we have internal methods already like `ToNodeOptions()`.\r\n  - Optionally, add additional overloads to document\\node\\reader\\writer to take `JsonSerializerOptions` instead of the type-specific options. Internally, the `jsonSerializerOptions.ToNodeOptions()` etc would be called to get the appropriate options.\r\n- Perhaps remove appropriate serializer logic since reader\\writer will be able to handle the functionality.\r\n",
          "createdAt": "2021-10-21T15:35:39Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-10-21T21:09:04Z",
          "id": "IC_kwDODI9FZc44jImu"
        },
        {
          "author": "mguinness",
          "body": "> Superficially the new `JsonNode` type does not seem to honor `JsonNumberHandling`\n\nIt's been several years since this was bought up, are there any plans to address this?\n\nEncountered this when trying to deserialize output from an API with coordinates in quotes.\n\nhttps://nominatim.openstreetmap.org/search?format=json&countrycodes=us&postalcode=60606\n\n```json\n[\n  {\n    \"place_id\": 353651515,\n    \"licence\": \"Data © OpenStreetMap contributors, ODbL 1.0. http://osm.org/copyright\",\n    \"lat\": \"41.8822913\",\n    \"lon\": \"-87.6363526\",\n    \"class\": \"place\",\n    \"type\": \"postcode\",\n    \"place_rank\": 21,\n    \"importance\": 0.12001,\n    \"addresstype\": \"postcode\",\n    \"name\": \"60606\",\n    \"display_name\": \"60606, Loop, Chicago, Cook County, Illinois, United States\",\n    \"boundingbox\": [\n      \"41.8322913\",\n      \"41.9322913\",\n      \"-87.6863526\",\n      \"-87.5863526\"\n    ]\n  }\n]\n```",
          "createdAt": "2025-06-06T22:32:31Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-06-06T22:32:31Z",
          "id": "IC_kwDODI9FZc6v5SMp"
        }
      ],
      "totalCount": 28,
      "endCursor": "Y3Vyc29yOnYyOpHOJpB8jQ=="
    },
    "url": "https://github.com/dotnet/runtime/issues/29152",
    "title": "Support JsonNumberHandling in JsonElement & JsonNode"
  },
  {
    "author": "shaggygi",
    "labels": [
      "enhancement",
      "area-System.Text.Json",
      "wishlist",
      "in-pr"
    ],
    "createdAt": "2019-06-14T16:28:09Z",
    "body": "Understanding this feature is not coming with .NET Core v3, are there current plans to begin reviewing/development soon after?\r\n\r\nGood job on initial work on new API :+1: \r\n\r\nAny feedback is appreciated.",
    "number": 29887,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "THUMBS_UP",
          "createdAt": "2019-08-17T17:55:22Z",
          "user": "samdozor"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2019-09-26T15:56:53Z",
          "user": "emmadavieswilcox"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2019-10-02T10:29:52Z",
          "user": "aye-dev"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2019-10-31T10:21:29Z",
          "user": "kucint"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2019-12-30T00:35:49Z",
          "user": "flemming-n-larsen"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2020-04-28T10:53:41Z",
          "user": "jokay"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2020-05-21T14:06:57Z",
          "user": "dutts"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2020-06-30T19:49:49Z",
          "user": "adamhewitt627"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2020-08-21T23:27:01Z",
          "user": "trevorlacey-msft"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2020-09-17T07:36:15Z",
          "user": "thomasdc"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2020-09-20T10:54:33Z",
          "user": "gregsdennis"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2020-10-21T19:04:58Z",
          "user": "andyfurniss4"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-03-02T07:09:22Z",
          "user": "azydevelopment"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-03-31T17:06:12Z",
          "user": "adiun"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-04-01T12:53:25Z",
          "user": "DavidStahl97"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-04-20T06:46:40Z",
          "user": "NN---"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-07-20T20:52:07Z",
          "user": "splitt3r"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-07-23T15:34:42Z",
          "user": "CodeFuller"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-08-11T18:10:48Z",
          "user": "Gladskih"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-09-26T13:27:48Z",
          "user": "WeihanLi"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-01-24T05:04:45Z",
          "user": "idilshod87"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-03-25T15:09:13Z",
          "user": "camillebarneaud"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-04-01T09:46:09Z",
          "user": "lucahost"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-04-24T07:49:59Z",
          "user": "ahdung"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-04-24T09:35:14Z",
          "user": "davidkudera"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-09-26T23:08:12Z",
          "user": "captainsafia"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-09-26T23:47:58Z",
          "user": "davidfowl"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-10-13T09:23:21Z",
          "user": "malaterre"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-10-27T14:15:49Z",
          "user": "amis92"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-02-26T18:13:50Z",
          "user": "bachratyg"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-03-31T02:53:49Z",
          "user": "dmitriyi-affinity"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-08-17T05:42:16Z",
          "user": "scharnyw"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-10-13T17:12:20Z",
          "user": "gtbuchanan"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-10-29T16:08:45Z",
          "user": "HungryDoctor"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-11-29T19:43:38Z",
          "user": "albus-sonitus"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-04-21T08:11:10Z",
          "user": "cirrusone"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-04-28T02:34:52Z",
          "user": "benlongo"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-04-30T02:42:34Z",
          "user": "pmgreg3"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-08-27T11:04:35Z",
          "user": "dalyIsaac"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-09-29T20:33:47Z",
          "user": "sherman89"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-12-14T11:36:21Z",
          "user": "Jure-BB"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-05-27T15:52:04Z",
          "user": "iamkisly"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-06-18T00:09:41Z",
          "user": "ThomasNieto"
        }
      ],
      "totalCount": 43,
      "endCursor": "Y3Vyc29yOnYyOpHOCZiAuA=="
    },
    "updatedAt": "2025-07-05T21:34:52Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": "ahsonkhan",
          "body": "It is on our road-map for the future: https://github.com/dotnet/corefx/blob/master/src/System.Text.Json/roadmap/README.md#out-of-current-scope--future-considerations",
          "createdAt": "2019-06-18T06:40:48Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2019-06-18T09:36:54Z",
                "user": "shaggygi"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2019-09-12T10:20:05Z",
                "user": "m-wild"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2019-09-26T15:56:57Z",
                "user": "emmadavieswilcox"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2019-10-31T10:21:40Z",
                "user": "kucint"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2019-12-03T13:52:33Z",
                "user": "ogrim"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2019-12-30T00:35:52Z",
                "user": "flemming-n-larsen"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2020-05-21T14:06:53Z",
                "user": "dutts"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-03-02T07:09:27Z",
                "user": "azydevelopment"
              }
            ],
            "totalCount": 8,
            "endCursor": "Y3Vyc29yOnYyOpHOBh2DgQ=="
          },
          "updatedAt": "2019-06-18T06:40:48Z",
          "id": "MDEyOklzc3VlQ29tbWVudDUwMjk2OTE1OA=="
        },
        {
          "author": "shmuelie",
          "body": "Anything more concrete than future? Trying to decide on library usage",
          "createdAt": "2019-11-04T15:58:52Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2019-11-04T16:00:52Z",
                "user": "emmadavieswilcox"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOA0N6Lw=="
          },
          "updatedAt": "2019-11-04T15:58:52Z",
          "id": "MDEyOklzc3VlQ29tbWVudDU0OTQyMDI1NQ=="
        },
        {
          "author": "ahsonkhan",
          "body": "The JSON schema spec is not stable enough and iterating quite frequently for us to add support yet (and a feature like this would require a lot more design/thinking - draft-08 now). Hence, I think this has to remain as future for now (which is to say that it isn't planned for 5.0).\r\n\r\nhttp://json-schema.org/\r\n![image](https://user-images.githubusercontent.com/6527137/68726121-5abefd00-0575-11ea-982e-dc0afc781152.png)\r\n",
          "createdAt": "2019-11-13T01:55:21Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2019-11-13T01:55:21Z",
          "id": "MDEyOklzc3VlQ29tbWVudDU1MzIwMTQ0Nw=="
        },
        {
          "author": "shmuelie",
          "body": "Reasonable. Sticking with JSON.NET for now then.",
          "createdAt": "2019-11-13T02:05:25Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-06-12T23:14:17Z",
                "user": "Gonkers"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOBueDXw=="
          },
          "updatedAt": "2019-11-13T02:05:25Z",
          "id": "MDEyOklzc3VlQ29tbWVudDU1MzIwMzgzNQ=="
        },
        {
          "author": "emmadavieswilcox",
          "body": "> @ahsonkhan: _“The JSON schema spec is not stable enough and iterating quite frequently for us to add support yet … ( … draft-08 now). …”_\r\n\r\nWould adding draft-07 support not still be a valid addition though, given a lot of the implementation could then be taken forward when draft-08 is stabilised, and at that point in time the majority of existing software that validates against a JSON schema will be doing so using draft-07 and older? I'm not contesting the decision by the way, just curious about how the roadmap items get prioritised 🙂\r\n",
          "createdAt": "2019-11-13T14:42:40Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2019-11-13T14:42:40Z",
          "id": "MDEyOklzc3VlQ29tbWVudDU1MzQzMzI5Mg=="
        },
        {
          "author": "emmadavieswilcox",
          "body": "> @SamuelEnglard : _“Reasonable. Sticking with JSON.NET for now then.”_\r\n\r\nIt's worth noting that Json.NET's schema validation functionality has been pulled-out of the main package and is now [its own thing](https://www.newtonsoft.com/jsonschema), which is **no longer free**. I found this out when I was recently working on some new validation stuff, and was a dealbreaker for what I was developing.\r\n\r\nFortunately, I stumbled across an alternative free library, called _Manatee.Json_, which provides much the same JSON schema validation functionality as Json.NET Schema; I'd highly recommend it based on my recent experiences with it, if free is something that's important to you or your project(s):\r\n\r\nhttps://www.github.com/gregsdennis/Manatee.Json\r\n",
          "createdAt": "2019-11-13T14:55:53Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2020-08-29T14:27:11Z",
                "user": "gregsdennis"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2020-12-15T19:51:13Z",
                "user": "krb3d"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-08-03T10:01:34Z",
                "user": "syedhamjath"
              }
            ],
            "totalCount": 3,
            "endCursor": "Y3Vyc29yOnYyOpHOCp5bFg=="
          },
          "updatedAt": "2019-11-13T14:55:53Z",
          "id": "MDEyOklzc3VlQ29tbWVudDU1MzQzODg5MQ=="
        },
        {
          "author": "shmuelie",
          "body": "> It's worth noting that Json.NET's schema validation functionality has been pulled-out of the main package and is now its own thing, which is no longer free. I found this out when I was recently working on some new validation stuff, and was a dealbreaker for what I was developing.\r\n>\r\n> Fortunately, I stumbled across an alternative free library, called Manatee.Json, which provides much the same JSON schema validation functionality as Json.NET Schema; I'd highly recommend it based on my recent experiences with it, if free is something that's important to you or your project(s):\r\n\r\nCurrently in a debate over if we can or cannot use Newtonsoft.Json.Schema and funny enough Manatee.Json was the suggested alternative!\r\n\r\nAnother alternative I found was [JSchema](https://github.com/microsoft/jschema). I liked that it does integrate nicely with JSON.NET but the API's lack of Stream support was a deal breaker for me.",
          "createdAt": "2019-11-13T15:24:42Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "LAUGH",
                "createdAt": "2019-11-13T15:28:59Z",
                "user": "emmadavieswilcox"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2019-11-13T15:29:01Z",
                "user": "emmadavieswilcox"
              }
            ],
            "totalCount": 2,
            "endCursor": "Y3Vyc29yOnYyOpHOA08zdQ=="
          },
          "updatedAt": "2019-11-13T15:24:42Z",
          "id": "MDEyOklzc3VlQ29tbWVudDU1MzQ1MTUzMQ=="
        },
        {
          "author": "emmadavieswilcox",
          "body": "@SamuelEnglard, ah no way, haha! Didn't know there was a current Microsoft solution for JSON schema stuff either. For me, the dealbreaker would be that it's only for draft-04 and nothing newer.\r\n",
          "createdAt": "2019-11-13T15:30:16Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2019-11-13T15:39:35Z",
                "user": "shmuelie"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOA084Pw=="
          },
          "updatedAt": "2019-11-13T15:30:16Z",
          "id": "MDEyOklzc3VlQ29tbWVudDU1MzQ1NDAyOA=="
        },
        {
          "author": "shmuelie",
          "body": "@andidavies92 as a quick update: end of the debate is we're using Newtonsoft.Json for creating the JSON and Manatee.Json for validation (not the best but time isn't with me)",
          "createdAt": "2019-11-13T17:50:33Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "HOORAY",
                "createdAt": "2019-11-14T12:47:16Z",
                "user": "emmadavieswilcox"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOA1Ck5w=="
          },
          "updatedAt": "2019-11-14T13:40:49Z",
          "id": "MDEyOklzc3VlQ29tbWVudDU1MzUyMzMyNw=="
        },
        {
          "author": "emmadavieswilcox",
          "body": "Nice, I did the same, but mostly because .NET Core 3 wasn't in GA when I wanted to start work on it. Plan to migrate the Json.NET stuff to .NET Core when I get the chance, as I now have unit and integration tests to check for regressions and performance tests to see whether I actually get much boosted performance.\r\n",
          "createdAt": "2019-11-14T12:49:16Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2019-11-14T13:49:18Z",
                "user": "shmuelie"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOA1C6hw=="
          },
          "updatedAt": "2019-11-14T12:49:16Z",
          "id": "MDEyOklzc3VlQ29tbWVudDU1Mzg3MzQ5NA=="
        },
        {
          "author": "wasabii",
          "body": "Look at Cogito.Json.Schema.Validation. it's a open source valuator. It's 190 times faster than Newtonsofts. I'm the author. I've got it in my head to fork a second library for System.Text.Json.\r\n\r\nIt would be pretty easy. If anybody wanted to help.",
          "createdAt": "2019-12-27T21:25:14Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2019-12-27T21:25:14Z",
          "id": "MDEyOklzc3VlQ29tbWVudDU2OTM0ODQ0Mg=="
        },
        {
          "author": "wasabii",
          "body": "Update: I began porting `Cogito.Json.Schema.Validation` to run on top of `System.Text.Json`. I have most of the basics working. Need to implement a few things like $ref support, and some per-schema version nuances.\r\n\r\nBut it's a good start, and validates quite a bit. For those of you who want to validate System.Text.Json streams, [Cogito.Text.Json.Schema](https://github.com/wasabii/Cogito.Text.Json.Schema) should get you pretty far. Pull requests for missing stuff accepted, of course. There's an alpha package on NuGet.\r\n\r\nThis validator is quite different from Newtonsofts. And quite faster. It actually compiles an `Expression` tree that implements the validation for a given Schema instance. And then you can execute the expression tree against a `JsonElement` to return pass or fail.\r\n\r\n@andidavies92  @SamuelEnglard ",
          "createdAt": "2019-12-29T00:12:48Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2019-12-29T00:12:48Z",
          "id": "MDEyOklzc3VlQ29tbWVudDU2OTQ2MTkyNw=="
        },
        {
          "author": "shmuelie",
          "body": "@wasabii looks interesting, though time says we're sticking with what we have for now.",
          "createdAt": "2020-01-02T15:39:46Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2020-01-02T15:39:46Z",
          "id": "MDEyOklzc3VlQ29tbWVudDU3MDI0NDgxOA=="
        },
        {
          "author": "Felk",
          "body": "@ahsonkhan \r\n\r\n> It is on our road-map for the future: https://github.com/dotnet/corefx/blob/master/src/System.Text.Json/roadmap/README.md#out-of-current-scope--future-considerations\r\n\r\nUnfortunately that link is dead. Is there another link where people can track this? Or will any updates be posted here and subscribing to this issue should be good?",
          "createdAt": "2020-04-07T18:16:18Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2020-04-07T18:16:18Z",
          "id": "MDEyOklzc3VlQ29tbWVudDYxMDU0MzAzNQ=="
        },
        {
          "author": "shmuelie",
          "body": "@Felk new link: https://github.com/dotnet/runtime/tree/master/src/libraries/System.Text.Json/roadmap#out-of-current-scope--future-considerations",
          "createdAt": "2020-04-07T19:13:48Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2020-04-07T22:00:10Z",
                "user": "Felk"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOBAcHOg=="
          },
          "updatedAt": "2020-04-07T19:13:48Z",
          "id": "MDEyOklzc3VlQ29tbWVudDYxMDU3MDQwMg=="
        },
        {
          "author": "martimors",
          "body": "This is my only reason for still using Json.NET. Would be a much appreciated feature indeed!",
          "createdAt": "2020-06-25T09:08:15Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-08-11T21:33:23Z",
                "user": "Gladskih"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOB2AUKA=="
          },
          "updatedAt": "2020-06-25T09:08:15Z",
          "id": "MDEyOklzc3VlQ29tbWVudDY0OTQwNzkxMg=="
        },
        {
          "author": "gregsdennis",
          "body": "I just released RC2 for [JsonSchema.Net](https://github.com/gregsdennis/json-everything) (on Nuget now).  It has full support for drafts 6 through 2019-09 and is built 100% on `System.Text.Json`.  (~Working on streaming support.~ Stream supported as of 1.0.0.)\r\n\r\n*@andidavies92, thanks for the shout-out on Manatee.Json, but this one is **so** much faster.... and still free.*",
          "createdAt": "2020-08-29T14:08:44Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2020-08-29T15:32:44Z",
                "user": "emmadavieswilcox"
              },
              {
                "content": "HOORAY",
                "createdAt": "2020-08-29T15:32:46Z",
                "user": "emmadavieswilcox"
              },
              {
                "content": "ROCKET",
                "createdAt": "2020-08-29T15:32:47Z",
                "user": "emmadavieswilcox"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2020-08-29T17:12:54Z",
                "user": "Felk"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2020-08-30T13:40:59Z",
                "user": "shaggygi"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2020-08-30T18:30:34Z",
                "user": "shmuelie"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2020-10-08T14:36:44Z",
                "user": "MatthewLymer"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2020-10-28T17:52:56Z",
                "user": "dajbych"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2020-12-13T15:31:48Z",
                "user": "dimaaan"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-01-28T15:23:24Z",
                "user": "np-13"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-02-12T04:11:18Z",
                "user": "ADustyOldMuffin"
              },
              {
                "content": "HOORAY",
                "createdAt": "2021-02-12T04:11:19Z",
                "user": "ADustyOldMuffin"
              },
              {
                "content": "ROCKET",
                "createdAt": "2021-02-12T04:11:19Z",
                "user": "ADustyOldMuffin"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-02-27T23:53:10Z",
                "user": "neoncitylights"
              },
              {
                "content": "HOORAY",
                "createdAt": "2021-02-27T23:53:11Z",
                "user": "neoncitylights"
              },
              {
                "content": "ROCKET",
                "createdAt": "2021-02-27T23:53:12Z",
                "user": "neoncitylights"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-04-20T06:47:38Z",
                "user": "NN---"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-04-27T02:50:47Z",
                "user": "chenzuo"
              },
              {
                "content": "HEART",
                "createdAt": "2021-04-27T02:50:54Z",
                "user": "chenzuo"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-05-09T13:29:11Z",
                "user": "brendonofficial"
              },
              {
                "content": "HEART",
                "createdAt": "2021-10-05T00:05:57Z",
                "user": "rcrathore"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-10-05T00:05:59Z",
                "user": "rcrathore"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-01-24T06:49:39Z",
                "user": "idilshod87"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-04-01T09:49:35Z",
                "user": "lucahost"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-04-24T14:33:16Z",
                "user": "WeihanLi"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-01-13T06:58:18Z",
                "user": "hsin19"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-02-02T22:56:26Z",
                "user": "dragorosson"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-03-31T02:55:10Z",
                "user": "dmitriyi-affinity"
              },
              {
                "content": "HOORAY",
                "createdAt": "2024-04-04T20:48:14Z",
                "user": "mrn06ody"
              }
            ],
            "totalCount": 29,
            "endCursor": "Y3Vyc29yOnYyOpHOCZikdw=="
          },
          "updatedAt": "2020-08-29T23:46:36Z",
          "id": "MDEyOklzc3VlQ29tbWVudDY4MzI5NTYwNw=="
        },
        {
          "author": "ahdung",
          "body": "Any news?",
          "createdAt": "2022-04-24T07:52:06Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-04-24T07:52:06Z",
          "id": "IC_kwDODI9FZc5CB3AS"
        },
        {
          "author": "gregsdennis",
          "body": "Since my previous post, [JsonSchema.Net](https://github.com/gregsdennis/json-everything) has become a (if not _the_) premier package for JSON Schema support in STJ.\n\nIt supports draft 6 through 2020-12, and I intend to keep it supporting the latest version.\n\nThere were some significant changes between drafts 4 and 6, which is why I don't support 4.  Additionally, given that draft 4 was released almost 9 years ago (6 was released 5 years ago), I would hope that any existing schemas that need to be used in new code will be updated.",
          "createdAt": "2022-04-24T14:21:32Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-04-24T14:32:37Z",
                "user": "WeihanLi"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-02-02T21:16:28Z",
                "user": "PramodValavala-MSFT"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-03-31T03:38:28Z",
                "user": "dmitriyi-affinity"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-09-11T02:01:53Z",
                "user": "algunion"
              }
            ],
            "totalCount": 4,
            "endCursor": "Y3Vyc29yOnYyOpHODGUfdA=="
          },
          "updatedAt": "2022-04-24T14:21:32Z",
          "id": "IC_kwDODI9FZc5CCHkT"
        },
        {
          "author": "gregsdennis",
          "body": "I have just released v4.1.0 of [JsonSchema.Net](https://www.nuget.org/packages/JsonSchema.Net) that adds validation during deserialization via a custom converter (factory) and a `[JsonSchema]` attribute.\r\n\r\nBasically, you expose a `JsonSchema` instance through a public static property and use the attribute on the type it describes to point to that schema instance.  Then when you use the `ValidatingJsonConverter` in the serializer options, it will use that schema to validate the payload before deserializing it.  If the validation fails, a `JsonException` is thrown with the JSON Schema output in the exception's `.Data` dictionary under the key `\"validation\"`.\r\n\r\nRead the [docs](https://json-everything.net/json-schema#schema-deserialization) for more info.\r\n\r\nMaybe this will help people here until official support is again pushed out to .NET 9.",
          "createdAt": "2023-05-01T00:28:30Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "HOORAY",
                "createdAt": "2023-05-01T00:31:16Z",
                "user": "AndrewKeepCoding"
              },
              {
                "content": "HOORAY",
                "createdAt": "2023-05-02T13:10:31Z",
                "user": "nkm8"
              },
              {
                "content": "HOORAY",
                "createdAt": "2023-05-10T16:23:36Z",
                "user": "eiriktsarpalis"
              }
            ],
            "totalCount": 3,
            "endCursor": "Y3Vyc29yOnYyOpHOC7d7KA=="
          },
          "updatedAt": "2023-05-01T21:14:11Z",
          "id": "IC_kwDODI9FZc5bJbOy"
        },
        {
          "author": "vhatuncev",
          "body": "> I have just released v4.1.0 of [JsonSchema.Net](https://www.nuget.org/packages/JsonSchema.Net) that adds validation during deserialization via a custom converter (factory) and a `[JsonSchema]` attribute.\r\n> \r\n> Basically, you expose a `JsonSchema` instance through a public static property and use the attribute on the type it describes to point to that schema instance. Then when you use the `ValidatingJsonConverter` in the serializer options, it will use that schema to validate the payload before deserializing it. If the validation fails, a `JsonException` is thrown with the JSON Schema output in the exception's `.Data` dictionary under the key `\"validation\"`.\r\n> \r\n> Read the [docs](https://json-everything.net/json-schema#schema-deserialization) for more info.\r\n> \r\n> Maybe this will help people here until official support is again pushed out to .NET 9.\r\n\r\nJust thinking, does it makes sense to throw an exception in case of validation failed? Valid payload or not looks like a usual situation and nothing exceptinal here. Also it does affect how the client code will be structured, with exception approach you need to wrap validation call with try catch block. In case of exception you getting some additional, minor but additional work to do for the runtime. Maybe IsValid() method will look better here?\r\n",
          "createdAt": "2023-09-04T10:37:16Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-09-04T10:37:16Z",
          "id": "IC_kwDODI9FZc5loKZL"
        },
        {
          "author": "gregsdennis",
          "body": "> does it makes sense to throw an exception in case of validation failed?\n\nWhy would it make sense to not throw an exception? Currently, if the serializer detects a required property that's not fulfilled in the data, it throws an exception.  This converter is just doing the same.\n\n> Maybe IsValid() method will look better here?\n\nYou can forego the schema-validating converter I built and manually validate the data separately before deserializing it.  (That's actually the primary purpose of the library.)  Then you get the validation results without an exception.  Once you know it's valid, then you can deserialize it.\n\nMy [blog post](https://blog.json-everything.net/posts/deserialization-with-schemas/) on adding the converter goes into a bit more detail on the mechanics.\n",
          "createdAt": "2023-09-04T11:31:03Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-06-08T18:51:55Z",
                "user": "alexeyshockov"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-07-11T17:33:57Z",
                "user": "pmgreg3"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-07-08T00:43:14Z",
                "user": "StephenHodgson"
              }
            ],
            "totalCount": 3,
            "endCursor": "Y3Vyc29yOnYyOpHOEZrdEA=="
          },
          "updatedAt": "2023-09-04T11:34:36Z",
          "id": "IC_kwDODI9FZc5loeDE"
        },
        {
          "author": "sherman89",
          "body": "Any news on when this will even be on the roadmap? It would be really nice to have built-in schema support and validation. Thank you!\n\nEDIT: Out of curiousity, what is Microsoft using to validate JSON schemas? For example in Azure Logic App there is a switch to enable schema validation, how is that done?",
          "createdAt": "2025-02-25T18:27:14Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-02-25T18:30:14Z",
          "id": "IC_kwDODI9FZc6f6kKg"
        },
        {
          "author": "gregsdennis",
          "body": "> what is Microsoft using to validate JSON schemas?\n\nThey're using JsonSchema.Net.",
          "createdAt": "2025-02-26T07:47:13Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-02-26T19:52:36Z",
                "user": "julealgon"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-02-26T21:16:44Z",
                "user": "sherman89"
              }
            ],
            "totalCount": 2,
            "endCursor": "Y3Vyc29yOnYyOpHOEHyyEg=="
          },
          "updatedAt": "2025-02-26T07:47:13Z",
          "id": "IC_kwDODI9FZc6f_XVT"
        },
        {
          "author": "shmuelie",
          "body": "> Any news on when this will even be on the roadmap? It would be really nice to have built-in schema support and validation. Thank you!\n> \n> EDIT: Out of curiousity, what is Microsoft using to validate JSON schemas? For example in Azure Logic App there is a switch to enable schema validation, how is that done?\n\nAs a MS team, I can also mention that we also use https://github.com/json-everything/json-everything, which has many other nice features for STJ like pointers and diffs",
          "createdAt": "2025-02-26T16:11:16Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-02-26T19:52:17Z",
                "user": "julealgon"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-02-26T21:16:48Z",
                "user": "sherman89"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-07-06T06:44:22Z",
                "user": "gregsdennis"
              }
            ],
            "totalCount": 3,
            "endCursor": "Y3Vyc29yOnYyOpHOEZeoLg=="
          },
          "updatedAt": "2025-02-26T16:11:16Z",
          "id": "IC_kwDODI9FZc6gEewb"
        },
        {
          "author": "Meir017",
          "body": "https://github.com/json-everything/json-everything is already part of the [.NET Foundation](https://dotnetfoundation.org/), any reason to implement it again?",
          "createdAt": "2025-02-26T16:27:53Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-02-26T17:30:00Z",
                "user": "alexeyshockov"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-07-06T06:44:23Z",
                "user": "gregsdennis"
              }
            ],
            "totalCount": 2,
            "endCursor": "Y3Vyc29yOnYyOpHOEZeoLw=="
          },
          "updatedAt": "2025-02-26T16:27:53Z",
          "id": "IC_kwDODI9FZc6gEpKR"
        },
        {
          "author": "shmuelie",
          "body": "At this point I would at most say it should be made inbox or into a `Microsoft.Extensions` library",
          "createdAt": "2025-02-26T18:56:36Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-02-26T18:56:36Z",
          "id": "IC_kwDODI9FZc6gF_1T"
        },
        {
          "author": "StephenHodgson",
          "body": "added a feature request for round trip JsonSchema support (POCO -> Schema -> POCO) \n\n- #117338",
          "createdAt": "2025-07-05T21:34:52Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-07-05T21:34:52Z",
          "id": "IC_kwDODI9FZc61Nz_L"
        }
      ],
      "totalCount": 28,
      "endCursor": "Y3Vyc29yOnYyOpHOoBHsGw=="
    },
    "url": "https://github.com/dotnet/runtime/issues/29887",
    "title": "[System.Text.Json] Json Schemas Support"
  },
  {
    "author": "hez2010",
    "labels": [
      "area-System.Text.Json",
      "backlog-cleanup-candidate"
    ],
    "createdAt": "2019-06-17T04:52:46Z",
    "body": "Use System.Json.Text in UWP,\r\n```csharp\r\nJsonSerializer.ToString(new { test = \"abc\" });\r\n```\r\n```\r\nFailure occurred while loading a type.\r\n\r\nThis operation cannot be carried out because metadata for the following object was removed for performance reasons: <unavailable>\r\nNo further information is available. Rebuild in debug mode for better information.\r\n```",
    "number": 29912,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "THUMBS_UP",
          "createdAt": "2019-06-28T07:56:41Z",
          "user": "EdiWang"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2020-01-28T23:13:12Z",
          "user": "BreeceW"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2020-02-08T20:55:13Z",
          "user": "michael-hawker"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-04-13T05:58:38Z",
          "user": "winston-de"
        }
      ],
      "totalCount": 4,
      "endCursor": "Y3Vyc29yOnYyOpHOBm60Ng=="
    },
    "updatedAt": "2022-02-18T18:35:57Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": "ahsonkhan",
          "body": "cc @MichalStrehovsky ",
          "createdAt": "2019-06-17T19:33:45Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2019-06-17T19:33:45Z",
          "id": "MDEyOklzc3VlQ29tbWVudDUwMjgyMDQyNw=="
        },
        {
          "author": "MichalStrehovsky",
          "body": "You can get more information in the exception message if you switch your build type to Debug and turn on .NET Native in the Debug configuration: switch the project configuration to Debug, and then in the project properties on the Build tab check the checkbox next to \"Compile with .NET Native tool chain\". The exception message will have more details after you do that.\r\n\r\nReflection-based serializers typically require RD.XML to make them work right out of the box. System.Text.Json wasn't tested on UWP and the experience will be rough.\r\n\r\nFor UWP, it's recommended to use existing serializers that the .NET Native compiler understands such as DataContractJsonSerializer or Netwonsoft.Json.\r\n\r\n(I should probably point out that the reason why the experience it's going to be more rough for System.Text.Json is because this is a framework assembly and a lot of the things in the .NET Native compiler that try to make reflection experience better don't kick in for framework assemblies - framework assemblies are expected to carry their own RD.XML that describes their dynamic behavior so that the compiler can do aggressive treeshaking on them to reduce their size. We didn't make an investment into RD.XML for System.Text.Json.)",
          "createdAt": "2019-06-18T14:18:43Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2019-06-18T14:37:50Z",
          "id": "MDEyOklzc3VlQ29tbWVudDUwMzE1NjQzMQ=="
        },
        {
          "author": "hez2010",
          "body": "@MichalStrehovsky \r\nI've got detailed exception message:\r\n```\r\n'System.Text.Json.Serialization.JsonPropertyInfoNotNullable<<>f__AnonymousType2<System.String>,System.String,System.String>' is missing metadata. For more information, please visit http://go.microsoft.com/fwlink/?LinkID=392859\r\n```\r\n\r\ntest code:\r\n```csharp\r\nJsonSerializer.ToString(new { test = \"abc\" });\r\n```",
          "createdAt": "2019-06-18T14:27:06Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2019-06-18T14:27:34Z",
          "id": "MDEyOklzc3VlQ29tbWVudDUwMzE2MDE3Mg=="
        },
        {
          "author": "MichalStrehovsky",
          "body": "Oh, okay, I actually looked and right now it's impossible to make System.Text.Json work on UWP. The `JsonPropertyInfoNotNullable` type is marked `[ReflectionBlocked]` in the implementation assembly so .NET Native will completely block it from reflection. No amount of RD.XML can fix that.\r\n\r\nWhen .NET Native support was deleted in CoreFX in dotnet/corefx#38170, along with it we deleted the logic that injects this attribute into framework assemblies. Next System.Text.Json release probably won't have that and we can try again.",
          "createdAt": "2019-06-18T14:39:30Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2019-06-18T14:39:30Z",
          "id": "MDEyOklzc3VlQ29tbWVudDUwMzE2NTc0OQ=="
        },
        {
          "author": "mqudsi",
          "body": "@MichalStrehovsky \r\n\r\n> it's impossible to make System.Text.Json work on UWP.\r\n\r\nOnly if using .NET Native, right? I think the latest version of UWP should run with the regular .NET Core 2.2 runtime otherwise, where STJ seems to be working OK for me.",
          "createdAt": "2019-06-19T02:44:20Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2019-06-19T02:44:20Z",
          "id": "MDEyOklzc3VlQ29tbWVudDUwMzM4MzkwNQ=="
        },
        {
          "author": "MichalStrehovsky",
          "body": ">  I think the latest version of UWP should run with the regular .NET Core 2.2 runtime otherwise, where STJ seems to be working OK for me.\r\n\r\n.NET Native is still a requirement to ship UWP apps to the Store.",
          "createdAt": "2019-06-19T07:17:39Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2019-06-19T07:17:39Z",
          "id": "MDEyOklzc3VlQ29tbWVudDUwMzQzODc5NQ=="
        },
        {
          "author": "sharwell",
          "body": "@ViktorHofer can you clarify  the resolution on all these issues that are getting closed?",
          "createdAt": "2019-10-21T12:27:01Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-01-16T03:12:44Z",
                "user": "darkguy2008"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOCKFpGQ=="
          },
          "updatedAt": "2019-10-21T12:27:01Z",
          "id": "MDEyOklzc3VlQ29tbWVudDU0NDQ5MTIwOQ=="
        },
        {
          "author": "ViktorHofer",
          "body": "@sharwell you asked that question already on another issue. Please see my response there.\r\n\r\nThis one actually was a mistake and needs to be re-opened.",
          "createdAt": "2019-10-21T12:29:43Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2019-10-21T12:29:43Z",
          "id": "MDEyOklzc3VlQ29tbWVudDU0NDQ5MjI5NQ=="
        },
        {
          "author": "p2pbsh",
          "body": "Just to bump this with something I discovered today, calls to JasonSerializer.Serialize() were working fine using UWP .NET Native against .NET Core 3.0. After updating to .NET Core 3.1 preview 3, calls to Serialize now fail with metadata exceptions.",
          "createdAt": "2019-12-03T18:47:12Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2019-12-03T18:47:12Z",
          "id": "MDEyOklzc3VlQ29tbWVudDU2MTMwMzMwMw=="
        },
        {
          "author": "h82258652",
          "body": "https://github.com/dotnet/runtime/issues/978#issuecomment-567613428\r\nI downgrade to 4.6.0 and it works fine without any rd.xml!",
          "createdAt": "2020-01-09T03:09:16Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2020-01-09T03:09:16Z",
          "id": "MDEyOklzc3VlQ29tbWVudDU3MjM2MjMxNQ=="
        },
        {
          "author": "michael-hawker",
          "body": "FYI @MattWhilden\r\n\r\nRelinking to our Windows Community Toolkit Issue [here](https://github.com/windows-toolkit/WindowsCommunityToolkit/issues/3060) as well.",
          "createdAt": "2020-02-08T21:00:21Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2020-02-12T01:42:19Z",
                "user": "h82258652"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOA7VV5A=="
          },
          "updatedAt": "2020-02-08T21:00:57Z",
          "id": "MDEyOklzc3VlQ29tbWVudDU4Mzc3NjQ1NA=="
        },
        {
          "author": "MattWhilden",
          "body": "[Here's](https://github.com/dotnet/runtime/issues/978) the issue I've been using to track this getting resolved. The current design question is around PreserveDependencyAttribute and whether it will be renamed/reused etc. In the mean time we'll need to have rd.xml workarounds.",
          "createdAt": "2020-02-11T19:12:44Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2020-02-12T01:42:23Z",
                "user": "h82258652"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOA7VV6g=="
          },
          "updatedAt": "2020-02-11T19:12:44Z",
          "id": "MDEyOklzc3VlQ29tbWVudDU4NDgwMjM0Nw=="
        },
        {
          "author": "mc0re",
          "body": "I added this to `rd.xml`, seems to work.\r\n```\r\n<Namespace Name=\"System.Text.Json.Serialization.Converters\" Browse=\"Required All\"/>\r\n```",
          "createdAt": "2020-06-03T21:27:32Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2020-06-04T00:30:19Z",
                "user": "h82258652"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2020-10-31T11:51:27Z",
                "user": "wjvii"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2020-11-09T17:28:29Z",
                "user": "JayBeavers"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-10-19T15:15:17Z",
                "user": "hez2010"
              }
            ],
            "totalCount": 4,
            "endCursor": "Y3Vyc29yOnYyOpHOB-619w=="
          },
          "updatedAt": "2020-06-03T21:27:32Z",
          "id": "MDEyOklzc3VlQ29tbWVudDYzODQ3MTM1MQ=="
        },
        {
          "author": null,
          "body": "Due to lack of recent activity, this issue has been marked as a candidate for backlog cleanup.  It will be closed if no further activity occurs within 14 more days. Any new comment (by anyone, not necessarily the author) will undo this process.\n\nThis process is part of the experimental [issue cleanup initiative](https://github.com/dotnet/runtime/issues/60288) we are currently trialing in a limited number of areas. Please share any feedback you might have in the linked issue.",
          "createdAt": "2021-10-19T15:03:53Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-10-19T15:03:53Z",
          "id": "IC_kwDODI9FZc44b0fm"
        },
        {
          "author": "mqudsi",
          "body": "It would be useful if we had some official indication of what the status of UWP is and how it fits into the .NET Core ecosystem in order to figure out if this issue even matters in the grand scheme of things. ",
          "createdAt": "2021-10-31T00:35:53Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-10-31T00:35:53Z",
          "id": "IC_kwDODI9FZc449YNr"
        }
      ],
      "totalCount": 15,
      "endCursor": "Y3Vyc29yOnYyOpHOOPWDaw=="
    },
    "url": "https://github.com/dotnet/runtime/issues/29912",
    "title": "System.Text.Json throw exceptions on UWP in Release Build"
  },
  {
    "author": "GSPP",
    "labels": [
      "api-needs-work",
      "area-System.Text.Json",
      "wishlist"
    ],
    "createdAt": "2019-08-04T17:35:22Z",
    "body": "`Utf8JsonWriter.Flush` flushes the underlying stream. I think this behavior should be decoupled from flushing the buffers of `Utf8JsonWriter`. I might want to flush the writer but not the stream.\r\n\r\nFor example, `FileStream.Flush` calls into the kernel which is not necessarily desired. Network-based streams (not `NetworkStream` itself) might cause packets to be sent prematurely. Compression streams might create inefficiently small chunks.\r\n\r\nOne solutions is to add a parameter:\r\n\r\n    void Flush(bool flushStream = false)\r\n\r\nAnother solution is to never flush the stream. User code can flush the stream by itself if it wants to.\r\n",
    "number": 30477,
    "reactions": {
      "hasNextPage": false,
      "nodes": [],
      "totalCount": 0,
      "endCursor": null
    },
    "updatedAt": "2024-10-28T08:59:11Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": "scalablecory",
          "body": "Can you give a more concrete sample of how you would use this? I'm having trouble imagining what I could do if I called `Flush(false)`.\r\n\r\nIs the goal to avoid growing the `Utf8JsonWriter` buffer when writing to a `Stream`?",
          "createdAt": "2019-08-05T21:07:55Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2019-08-05T21:07:55Z",
          "id": "MDEyOklzc3VlQ29tbWVudDUxODQwMDc0Ng=="
        },
        {
          "author": "GSPP",
          "body": "This is about performance. Please see the 2nd paragraph for concrete scenarios on how `Flush(true)` might hurt.\r\n\r\nTo flesh this out a bit: I might want to serialize many JSON documents into one stream. Possibly as part of a binary framing format. Then, I only want to flush the underlying stream once at the end and not after each JSON document.",
          "createdAt": "2019-08-06T08:17:03Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2020-03-11T16:04:14Z",
                "user": "rcollina"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOA92kwQ=="
          },
          "updatedAt": "2019-08-06T08:17:03Z",
          "id": "MDEyOklzc3VlQ29tbWVudDUxODU2MjY3Mw=="
        },
        {
          "author": "layomia",
          "body": "As a workaround, can you create a stream that ignores flush, and only flushes on dispose?",
          "createdAt": "2020-02-21T23:41:45Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2020-02-21T23:41:45Z",
          "id": "MDEyOklzc3VlQ29tbWVudDU4OTg4MjY4Ng=="
        },
        {
          "author": null,
          "body": "This issue has been marked with the `api-needs-work` label. This may suggest that the proposal requires further refinement before it can be considered for API review. Please refer to our [API review guidelines](https://github.com/dotnet/runtime/blob/main/docs/project/api-review-process.md) for a detailed description of the process. \n\nWhen ready to submit an amended proposal, please ensure that the original post in this issue has been updated, following the API proposal template and examples as provided in the guidelines.",
          "createdAt": "2021-10-15T19:37:28Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-10-15T19:37:28Z",
          "id": "IC_kwDODI9FZc44Taej"
        },
        {
          "author": "judilsteve",
          "body": "+1 for this\n\nI have some code for writing a stream of highly-compressible objects out into chunked JSON files with brotli compression. It works roughly like so:\n\n```C#\nvar desiredFileSizeBytes = 1024 * 1024 * 32; // 32MiB\nvar buffer = new MemoryStream(desiredFileSizeBytes);\nvar brotliStream = new BrotliStream(buffer, CompressionLevel.Optimal, leaveOpen: true);\nvar jsonWriter = new Utf8JsonWriter(brotliStream);\n\ntry\n{\n    jsonWriter.WriteStartArray();\n    var pendingItems = false;\n    var chunk = 0;\n\n    void FinaliseAndWriteToFile()\n    {\n        jsonWriter.WriteEndArray();\n        jsonWriter.Flush();\n        brotliStream.Dispose(); // Flush is not enough for BrotliStream; only Dispose will write the trailer\n        buffer.Flush();\n        buffer.Seek(0, SeekOrigin.Begin);\n\n        using var output = File.OpenWrite($\"Items_{chunk++}.json.br\");\n        buffer.CopyTo(output);\n    }\n\n    foreach(var item in items)\n    {\n        JsonSerializer.Serialize(jsonWriter, item);  // This internally calls jsonWriter.Flush(), which prematurely calls BrotliStream.Flush(), causing poor compression!\n        pendingItems = true;\n\n        if(buffer.Length >= desiredFileSizeBytes)\n        {\n            FinaliseAndWriteToFile();\n\n            brotliStream.Dispose();\n            buffer.Dispose();\n            buffer = new MemoryStream(desiredFileSizeBytes);\n            brotliStream = new BrotliStream(buffer, CompressionLevel.Optimal, leaveOpen: true);\n            jsonWriter.Reset(brotliStream);\n            jsonWriter.WriteStartArray();\n\n            pendingItems = false;\n        }\n    }\n\n    if(pendingItems)\n    {\n        FinaliseAndWriteToFile();\n    }\n}\nfinally\n{\n    brotliStream.Dispose();\n    buffer.Dispose();\n}\n```\n\nThe original solution was to simply hold a `List` of `item` objects until the `List` reached a certain size, then write it to a compressed file, but the memory used by the List was far too much. For the data we have, storing the partially-built compressed JSON in a `MemoryStream` reduces memory requirements by a factor of almost 100.\n\nHowever, due to the fact that `JsonSerializer.Serialize` calls `Utf8JsonWriter.Flush`, which then calls `Flush` on the underlying `BrotliStream` for every item written to the stream, the compression ratio is terrible (almost 4x worse) compared to the naive solution of writing out an entire chunk's worth of JSON (again, this uses far too much memory) and then compressing it all at once. I believe this is related to https://github.com/dotnet/runtime/issues/36245\n\nMy hacky solution was to wrap the `BrotliStream` in a `Stream` subclass that simply suppresses calls to `BrotliStream.Flush` unless a certain number of bytes have been written since the last `Flush` (a threshold of 128kiB was plenty). This allows the `BrotliStream` to use its internal buffers effectively and achieve good compression. I then had to define my own `ForceFlush` function on the `Stream` subclass which *always* flushes the underlying `BrotliStream`, and make sure to call `ForceFlush` wherever I would normally call `Flush`.\n\nAdding the proposed boolean parameter to allow *not* flushing the underlying stream (and plumbing it through to the `Utf8JsonWriter` overloads of `JsonWriter.Serialize`) when the `Utf8JsonWriter` is flushed would mean I no longer need to maintain this hack.",
          "createdAt": "2024-10-28T05:25:53Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-10-28T08:59:11Z",
          "id": "IC_kwDODI9FZc6ReFbE"
        }
      ],
      "totalCount": 5,
      "endCursor": "Y3Vyc29yOnYyOpHOkXhWxA=="
    },
    "url": "https://github.com/dotnet/runtime/issues/30477",
    "title": "Utf8JsonWriter.Flush should flush the underlying stream only optionally"
  },
  {
    "author": "am11",
    "labels": [
      "enhancement",
      "area-System.Text.Json"
    ],
    "createdAt": "2019-08-21T18:04:21Z",
    "body": "I am in the process of adding `System.Text.Json` parser to JSONTestSuite: https://github.com/am11/JSONTestSuite/tree/feature/dotnet-system-text-json/parsers/test_dotnet_system_text_json.\r\n\r\nCurrently, the following four tests are failing:\r\n\r\n1. [i_string_UTF-16LE_with_BOM.json](https://github.com/nst/JSONTestSuite/tree/e3d9a17/test_parsing/i_string_UTF-16LE_with_BOM.json)\r\n    * > System.Text.Json.JsonReaderException: '0xFF' is an invalid start of a value. LineNumber: 0 | BytePositionInLine: 0.\r\n2. [i_string_utf16BE_no_BOM.json](https://github.com/nst/JSONTestSuite/tree/e3d9a17/test_parsing/i_string_utf16BE_no_BOM.json)\r\n    * > System.Text.Json.JsonReaderException: '0x00' is an invalid start of a value. LineNumber: 0 | BytePositionInLine: 0.\r\n3. [i_string_utf16LE_no_BOM.json](https://github.com/nst/JSONTestSuite/tree/e3d9a17/test_parsing/i_string_utf16LE_no_BOM.json)\r\n    * > System.Text.Json.JsonReaderException: '0x00' is an invalid start of a value. LineNumber: 0 | BytePositionInLine: 1.\r\n4. [i_structure_500_nested_arrays.json](https://github.com/nst/JSONTestSuite/tree/e3d9a17/test_parsing/i_structure_500_nested_arrays.json)\r\n    * > System.Text.Json.JsonReaderException: The maximum configured depth of 64 has been exceeded. Cannot read next JSON array. LineNumber: 0 | BytePositionInLine: 64.\r\n    * AFAICT, this limit is not adjustable by API consumer.\r\n\r\nShould `NotSupportedException` be thrown in case of 1, 2 and 3 with message indicating that non-UTF8 encodings are unsupported?\r\n\r\nI found two places, where similar white-listing / checking for encoding is employed:\r\n\r\n1. https://github.com/dotnet/corefx/blob/f4344b0d3b45fc7c8f41e5c909ddcb2752bea0fa/src/System.Private.DataContractSerialization/src/System/Xml/EncodingStreamWrapper.cs#L22\r\n2. https://github.com/dotnet/corefx/blob/f4344b0d3b45fc7c8f41e5c909ddcb2752bea0fa/src/System.Private.DataContractSerialization/src/System/Runtime/Serialization/Json/JsonEncodingStreamWrapper.cs#L57-L63",
    "number": 1572,
    "reactions": {
      "hasNextPage": false,
      "nodes": [],
      "totalCount": 0,
      "endCursor": null
    },
    "updatedAt": "2021-10-21T20:22:40Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": "ahsonkhan",
          "body": "> I am in the process of adding `System.Text.Json` parser to JSONTestSuite\r\n\r\nAwesome! cc @layomia \r\n\r\nFrom the underlying `Utf8JsonReader`'s perspective:\r\n> Should `NotSupportedException` be thrown in case of 1, 2 and 3 with message indicating that non-UTF8 encodings are unsupported?\r\n\r\nMaybe, but the reader is called `Utf8JsonReader`, which implies it expected UTF-8 data (it's in the type name). Also, I don't know if encoding detection would be accurate and not hurt the performance of the common path. I think `JsonReaderException` for invalid JSON makes sense and when I see a `NotSupportedException`, I tend to think that the scenario could potentially be supported, and might be in the future, but the `Utf8JsonReader` would not support non-UTF8 encodings.\r\n\r\n> AFAICT, this limit is not adjustable by API consumer.\r\n\r\n`JsonReaderOptions` lets you set the `MaxDepth`, that can be passed in to the reader:\r\nhttps://github.com/dotnet/corefx/blob/a1578465f68f6793e7498152dc2d0d2f4eed3a4e/src/System.Text.Json/ref/System.Text.Json.cs#L335\r\n\r\nSimilarly, the `JsonDocumentOptions` has the same setting.\r\n\r\nThat said, from the `JsonDocument`'s perspective, which is currently encoding agnostic, it might be worth documenting clearly that the UTF-16 encoded text is currently not supported (with/without BOM), and maybe we can detect that up-front and throw a more meaningful exception.\r\n\r\ncc @bartonjs - thoughts on making `JsonDocument` throw NSE for UTF-16 text?",
          "createdAt": "2019-08-21T19:31:07Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2019-08-21T19:47:56Z",
                "user": "am11"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-12-11T08:45:43Z",
                "user": "Deantwo"
              }
            ],
            "totalCount": 2,
            "endCursor": "Y3Vyc29yOnYyOpHOD-hxpg=="
          },
          "updatedAt": "2019-08-21T19:32:22Z",
          "id": "MDEyOklzc3VlQ29tbWVudDUyMzYxNTIwOA=="
        },
        {
          "author": "am11",
          "body": "> MaxDepth\r\n\r\nThanks, I was looking at the wrong places with wrong keywords for this option. 😄  \\#4 is now fixed in branch.",
          "createdAt": "2019-08-21T19:50:02Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2019-08-21T19:50:02Z",
          "id": "MDEyOklzc3VlQ29tbWVudDUyMzYyMTk0Mw=="
        },
        {
          "author": "bartonjs",
          "body": "> thoughts on making JsonDocument throw NSE for UTF-16 text?\r\n\r\nIf that's the plan for the future we should change the name to `stream` (currently it's `utf8Stream`).  And, really, once it's going to throw the exception it could just finish with using the correct encoding to transform to char, and call the char-based overload with the resulting string.  (It's memory-aggressive, but might be better than an NSE?)",
          "createdAt": "2019-08-21T20:40:11Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2019-08-21T20:40:11Z",
          "id": "MDEyOklzc3VlQ29tbWVudDUyMzYzOTkyMw=="
        },
        {
          "author": "bartonjs",
          "body": "I think it's a reasonable change, though.  If we make it like today.",
          "createdAt": "2019-08-21T20:40:59Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2019-08-21T20:40:59Z",
          "id": "MDEyOklzc3VlQ29tbWVudDUyMzY0MDIzMw=="
        },
        {
          "author": "am11",
          "body": "> And, really, once it's going to throw the exception it could just finish with using the correct encoding to transform to char, and call the char-based overload with the resulting string.\r\n\r\nIMO, that would be a reasonable thing to do and will address https://github.com/dotnet/corefx/issues/39433.\r\n\r\n> (It's memory-aggressive, but might be better than an NSE?)\r\n\r\nThis could be an acceptable tradeoff for legacy interoperability, as the latest JSON format RFC 8259 mentions:\r\n\r\n>  #### 8.1.  Character Encoding\r\n>\r\n>  JSON text exchanged between systems that are not part of a closed\r\n   ecosystem MUST be encoded using UTF-8.",
          "createdAt": "2019-08-22T13:52:06Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2019-08-22T13:52:06Z",
          "id": "MDEyOklzc3VlQ29tbWVudDUyMzkxNTgxNQ=="
        },
        {
          "author": "ahsonkhan",
          "body": "Given where we are at for 3.0, this doesn't meet the bar, particularly because it requires a breaking change to rename the parameter from `utf8Json` to `stream`.\r\n\r\n`JsonDocument` and `JsonSerializer` accept streams that only contain UTF-8 encoded data (either if a UTF-8 BOM is present OR no BOM is present), and that's indicated by the parameter name.\r\n\r\nWe can re-consider making this change in the future and introduce logic to do BOM-detection for other encodings (UTF-16-LE/BE and UTF-32-LE/BE). Alternatively, we can consider adding the capability for the user to specify an encoding to fully support UTF-16 text (even if there is no UTF-16 BOM detected), similar to StreamReader (and to address https://github.com/dotnet/corefx/issues/39433).\r\n\r\nMoving to 5.0.",
          "createdAt": "2019-09-11T04:22:43Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2019-09-11T04:22:43Z",
          "id": "MDEyOklzc3VlQ29tbWVudDUzMDIxMzU5MQ=="
        },
        {
          "author": "ahsonkhan",
          "body": "Given we are planning to add a transcoding stream (https://github.com/dotnet/runtime/issues/30260), there is less need for supporting non-UTF-8 encoded streams in the serializer directly. The primary benefit of doing it natively would be performance. Moving to future.",
          "createdAt": "2020-02-20T21:54:27Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2020-02-20T21:54:27Z",
          "id": "MDEyOklzc3VlQ29tbWVudDU4OTM0MzY2NA=="
        },
        {
          "author": "Yomodo",
          "body": "Exactly the exception I get. Too bad.\r\n\r\n```\r\nvar gitDesc = new GitVersionDescriptor {Version = \"main\"};\r\n\r\n         foreach (var item in items.OrderBy(j => j.Path))\r\n         {\r\n            var fileName = Path.GetFileName(item.Path);\r\n\r\n            using var stream = _gitClient.GetItemContentAsync(repo.Id, $\"/{TemplatesRoot}/{fileName}\", versionDescriptor: gitDesc);\r\n            \r\n            using var task5 = JsonDocument.ParseAsync(await stream, MyModule.JsonDocumentOptions);\r\n            using var document = await task5;\r\n\r\n            yield return document.RootElement.Clone();\r\n         }\r\n\r\n\r\n\r\nSystem.Text.Json.JsonReaderException: '0xFF' is an invalid start of a value. LineNumber: 0 | BytePositionInLine: 0.\r\n   at System.Text.Json.ThrowHelper.ThrowJsonReaderException(Utf8JsonReader& json, ExceptionResource resource, Byte nextByte, ReadOnlySpan`1 bytes)\r\n   at System.Text.Json.Utf8JsonReader.ConsumeValue(Byte marker)\r\n   at System.Text.Json.Utf8JsonReader.ReadFirstToken(Byte first)\r\n   at System.Text.Json.Utf8JsonReader.ReadSingleSegment()\r\n   at System.Text.Json.Utf8JsonReader.Read()\r\n   at System.Text.Json.JsonDocument.Parse(ReadOnlySpan`1 utf8JsonSpan, JsonReaderOptions readerOptions, MetadataDb& database, StackRowStack& stack)\r\n   at System.Text.Json.JsonDocument.Parse(ReadOnlyMemory`1 utf8Json, JsonReaderOptions readerOptions, Byte[] extraRentedBytes)\r\n   at System.Text.Json.JsonDocument.ParseAsyncCore(Stream utf8Json, JsonDocumentOptions options, CancellationToken cancellationToken)\r\n```",
          "createdAt": "2021-02-23T22:04:03Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-03-09T10:38:01Z",
          "id": "MDEyOklzc3VlQ29tbWVudDc4NDU0NTI5Mw=="
        }
      ],
      "totalCount": 8,
      "endCursor": "Y3Vyc29yOnYyOpHOLsM2DQ=="
    },
    "url": "https://github.com/dotnet/runtime/issues/1572",
    "title": "non-UTF8 encoded JSON docs to throw NotSupportedException"
  },
  {
    "author": "khellang",
    "labels": [
      "api-suggestion",
      "area-System.Text.Json"
    ],
    "createdAt": "2019-08-27T08:12:20Z",
    "body": "## Rationale\r\n\r\nCurrently, it's a bit of a hassle to properly read a `Guid` using a custom format. You basically have to copy the implementation of `TryGetGuid` just to (more or less) change a single character (the format):\r\n\r\nhttps://github.com/dotnet/corefx/blob/7055b496a30dfe0f66a2f555cad31502473d144b/src/System.Text.Json/src/System/Text/Json/Reader/Utf8JsonReader.TryGet.cs#L942-L993\r\n\r\nAnd because `JsonReaderHelper` is internal, you also have to copy the implementation of `TryGetEscapedGuid`:\r\n\r\nhttps://github.com/dotnet/corefx/blob/7055b496a30dfe0f66a2f555cad31502473d144b/src/System.Text.Json/src/System/Text/Json/Reader/JsonReaderHelper.cs#L315-L339\r\n\r\n## Proposal\r\n\r\nI'd :heart: to see the following overloads added to System.Text.Json:\r\n\r\n```diff\r\nnamespace System.Text.Json\r\n{\r\n    public readonly partial struct JsonElement\r\n    {\r\n        public System.Guid GetGuid() { throw null; }\r\n+       public System.Guid GetGuid(char standardFormat) { throw null; }\r\n        public bool TryGetGuid(out System.Guid value) { throw null; }\r\n+       public bool TryGetGuid(char standardFormat, out System.Guid value) { throw null; }\r\n    }\r\n    public sealed partial class JsonString : System.Text.Json.JsonNode, System.IEquatable<System.Text.Json.JsonString>\r\n    {\r\n        public bool TryGetGuid(out System.Guid value) { throw null; }\r\n+       public bool TryGetGuid(char standardFormat, out System.Guid value) { throw null; }\r\n    }\r\n    public ref partial struct Utf8JsonReader\r\n    {\r\n        public System.Guid GetGuid() { throw null; }\r\n+       public System.Guid GetGuid(char standardFormat) { throw null; }\r\n        public bool TryGetGuid(out System.Guid value) { throw null; }\r\n+       public bool TryGetGuid(char standardFormat, out System.Guid value) { throw null; }\r\n    }\r\n}\r\n```\r\n\r\nThis would make it really easy to write a custom converter to work around dotnet/runtime#1567:\r\n\r\n```csharp\r\npublic sealed class JsonConverterGuid : JsonConverter<Guid>\r\n{\r\n    public override Guid Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)\r\n    {\r\n        if (reader.TryGetGuid('D', out Guid value))\r\n        {\r\n            return value;\r\n        }\r\n\r\n        if (reader.TryGetGuid('N', out value))\r\n        {\r\n            return value;\r\n        }\r\n\r\n        throw new FormatException(\"The JSON value is not in a supported Guid format.\");\r\n    }\r\n\r\n    public override void Write(Utf8JsonWriter writer, Guid value, JsonSerializerOptions options)\r\n    {\r\n        writer.WriteStringValue(value);\r\n    }\r\n}\r\n```\r\n\r\n## Notes\r\n\r\n - I chose `standardFormat` to mirror the `Utf8Parser` parameter names. Dunno whether that's a good name or not.\r\n - They're overloads as opposed to optional arguments to avoid a breaking change. I'm guessing that ship has sailed by now.\r\n - This proposal could also tackle the write side if that's desirable. I just started with reads cause that's where I stumbled right now.\r\n - This will bring us one step closer towards letting the user configure allowed formats (mentioned in https://github.com/dotnet/corefx/issues/40222#issuecomment-520628930)\r\n\r\n// @ahsonkhan @layomia @steveharter ",
    "number": 30692,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "THUMBS_UP",
          "createdAt": "2020-04-19T09:15:44Z",
          "user": "Laiteux"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-08-26T09:40:49Z",
          "user": "aureole82"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-09-03T13:56:21Z",
          "user": "JinsPeter"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-11-04T17:29:10Z",
          "user": "vyrotek"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-09-26T13:09:00Z",
          "user": "maksimnarkevichdp"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-07-31T07:29:42Z",
          "user": "Marcel0024"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-02-27T00:37:26Z",
          "user": "JustArchi"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-02-27T07:28:58Z",
          "user": "3ncy"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-03-12T17:34:50Z",
          "user": "khellang"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-03-10T15:46:00Z",
          "user": "SarahAmagno"
        }
      ],
      "totalCount": 10,
      "endCursor": "Y3Vyc29yOnYyOpHOC_5nrQ=="
    },
    "updatedAt": "2024-03-12T16:28:11Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": "layomia",
          "body": "From @stylesm in https://github.com/dotnet/runtime/issues/767:\r\n\r\n> `System.Text.Reader.Utf8JsonReader.TryGetGuid(out Guid value)`\r\n> \r\n> calls\r\n> \r\n> `System.Buffers.Text.Utf8Parser.TryParse(ReadOnlySpan<byte> source, out Guid value, out int bytesConsumed, char standardFormat = default)`\r\n> \r\n> However, when it does, it passes 'D' in as the `standardFormat` parameter, meaning only Guids in the format `nnnnnnnn-nnnn-nnnn-nnnn-nnnnnnnnnnnn` are parsed successfully.\r\n> \r\n> There are 4 Guid formats supported by Utf8Parser:\r\n> \r\n> ```\r\n>         ///     D (default)     nnnnnnnn-nnnn-nnnn-nnnn-nnnnnnnnnnnn\r\n>         ///     B               {nnnnnnnn-nnnn-nnnn-nnnn-nnnnnnnnnnnn}\r\n>         ///     P               (nnnnnnnn-nnnn-nnnn-nnnn-nnnnnnnnnnnn)\r\n>         ///     N               nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn\r\n> ```\r\n> \r\n> It would be great if `Utf8JsonReader.TryGetGuid(out Guid value)` supported the other three formats, defaulting to 'D' for backwards compatibility.\r\n> \r\n> This bubbles up into other APIs, e,g, `System.Text.Json`\r\n> \r\n> Am happy to take on dev work if this is agreed.\r\n> \r\n> Am in a rush and haven't checked contrib guidelines so likely update this later.\r\n\r\n",
          "createdAt": "2019-12-12T00:22:33Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2019-12-12T00:22:33Z",
          "id": "MDEyOklzc3VlQ29tbWVudDU2NDc5MzIzMw=="
        },
        {
          "author": "layomia",
          "body": "From @idzmitry in https://github.com/dotnet/runtime/issues/31627:\r\n\r\n> Here is a code snippet (F#)\r\n> \r\n> ```\r\n> open System\r\n> open System.Text.Json\r\n> \r\n> [<CLIMutable>]\r\n> type Test = {\r\n>     Id: Guid\r\n>     Text: string\r\n> }\r\n> \r\n> [<EntryPoint>]\r\n> let main _ =\r\n>     let str =\r\n>         {| Id = \"88f871231cee49e4bcfff12252d90410\"; Text = \"abc\" |}\r\n>         |> JsonSerializer.Serialize\r\n>     \r\n>     //works fine\r\n>     Guid.Parse \"88f871231cee49e4bcfff12252d90410\"\r\n>     |> printfn \"Guid: %A\"\r\n>     \r\n>     //fails\r\n>     JsonSerializer.Deserialize(str, typedefof<Test>)\r\n>     |> printfn \"Record: %A\"\r\n> \r\n>     0\r\n> ```\r\n> \r\n> `Guid.Parse` works fine at same time\r\n> .Net Core 3.1\r\n",
          "createdAt": "2020-02-02T18:38:43Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2020-02-02T18:38:43Z",
          "id": "MDEyOklzc3VlQ29tbWVudDU4MTE2MzgzNQ=="
        },
        {
          "author": "layomia",
          "body": "A workaround here is to use a custom converter to read/write with `Guid`.`Parse/ToString`, or for better performance `Utf8Parser/Formatter`.`TryParse/TryFormat`. For examples, see similar implementations for `DateTime` [here](https://docs.microsoft.com/en-us/dotnet/standard/datetime/system-text-json-support#when-using-).",
          "createdAt": "2020-02-02T18:42:48Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2020-02-03T20:10:15Z",
          "id": "MDEyOklzc3VlQ29tbWVudDU4MTE2NDE4Ng=="
        },
        {
          "author": "stylesm",
          "body": "> A workaround here is to use a custom converter to read/write with `Guid`.`Parse/ToString`, or for better performance `Utf8Parser/Formatter`.`TryParse/TryFormat`. For examples, see similar implementations for `DateTime` [here](https://github.com/dotnet/runtime/issues/30692).\r\n\r\nBut then we have to do this for every parse, whereas there is an existing Guid parsing method in Utf8JsonReader, which can be made extended but backwards compatible due to its default 'D'  format value, and which then makes life easier for a lot of other libraries.\r\n\r\nI don't think we should expect devs to write custom parsers to read Guids.",
          "createdAt": "2020-02-02T18:56:45Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2020-02-02T18:56:45Z",
          "id": "MDEyOklzc3VlQ29tbWVudDU4MTE2NTM2Mg=="
        },
        {
          "author": "khellang",
          "body": "> I don't think we should expect devs to write custom parsers to read Guids.\r\n\r\nIt's only if you're using a non-standard Guid format 😄 \r\n\r\n> But then we have to do this for every parse, whereas there is an existing Guid parsing method in Utf8JsonReader, which can be made extended but backwards compatible due to its default 'D' format value, and which then makes life easier for a lot of other libraries.\r\n\r\nThis issue is about adding these APIs to make it easier to parse non-standard Guid formats, using `Utf8JsonReader`. Are you saying you want to make the existing parse method(s) try all different formats when parsing? That would probably be a non-trivial performance hit.",
          "createdAt": "2020-02-03T07:44:23Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2020-02-03T07:44:23Z",
          "id": "MDEyOklzc3VlQ29tbWVudDU4MTI3OTU1NA=="
        },
        {
          "author": "stylesm",
          "body": "No, I'm suggesting we could add a format parameter with a default value. That would keep it backwards compatible and then default behaviour would be identical to what it is now. The performance hit would be negligible because further downstream we are already using a format parameter with a default value.\r\n\r\nThe standard Guid format is only standard in the .NET scope - plenty of other frameworks use different formats, and combining stacks is rather common. It is so common that the Guid parser in .NET supports these other formats.\r\n\r\nIf we were super concerned about performance then we could overload the method, meaning the original is unaffected.",
          "createdAt": "2020-02-03T07:51:38Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2020-02-03T07:57:17Z",
          "id": "MDEyOklzc3VlQ29tbWVudDU4MTI4MTU5Ng=="
        },
        {
          "author": "khellang",
          "body": "> No, I'm suggesting we could add a format parameter with a default value. That would keep it backwards compatible and then default behaviour would be identical to what it is now.\r\n\r\nThat's exactly what this issue is proposing though? 🤔 \r\n\r\n> The standard Guid format is only standard in the .NET scope - plenty of other frameworks use different formats, and combining stacks is rather common.\r\n\r\nNo, it's absolutely not. The canonical 8-4-4-4-12 format string is based on the record layout for the 16 bytes of the UUID, as specified by [RFC4122](https://tools.ietf.org/html/rfc4122). The RFC even contains an example implementation for this format.",
          "createdAt": "2020-02-03T07:57:33Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2020-02-03T07:57:33Z",
          "id": "MDEyOklzc3VlQ29tbWVudDU4MTI4MzM3OQ=="
        },
        {
          "author": "stylesm",
          "body": "> > No, I'm suggesting we could add a format parameter with a default value. That would keep it backwards compatible and then default behaviour would be identical to what it is now.\r\n> \r\n> That's exactly what this issue is proposing though? \r\n\r\nAre you arguing against your own proposal? Im confused by what you're suggesting (not trying to be awkward!) Adding an optional parameter with a default value won't cause a big performance hit.\r\n\r\n> > The standard Guid format is only standard in the .NET scope - plenty of other frameworks use different formats, and combining stacks is rather common.\r\n> \r\n> No, it's absolutely not. The canonical 8-4-4-4-12 format string is based on the record layout for the 16 bytes of the UUID, as specified by [RFC4122](https://tools.ietf.org/html/rfc4122). The RFC even contains an example implementation for this format.\r\n\r\nYou're right, that by standards, it had a default format. The existence of different format options in .net is evidence enough that others use different formats, and that other formats are de facto standards for their own frameworks.\r\n",
          "createdAt": "2020-02-03T08:06:20Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2020-02-03T08:07:47Z",
          "id": "MDEyOklzc3VlQ29tbWVudDU4MTI4NjI5Nw=="
        },
        {
          "author": "khellang",
          "body": "> Are you arguing against your own proposal? Im confused by what you're suggesting (not trying to be awkward!) Adding an optional parameter with a default value won't cause a big performance hit.\r\n\r\nI'm asking what your comment was about, since I don't see what value it added if it was basically saying exactly what the proposal says 😅 \r\n\r\n> You're right, that by standards, it had a default format. The existence of different format options in .net is evidence enough that others use different formats, and that other formats are de facto standards for their own frameworks.\r\n\r\nSure, and if you're using something non-standard, I think it's only reasonable that you have to tweak the (de-)serializer to fit your needs, i.e. write a custom converter 😄\r\n\r\nAnyway, @layomia's [comment](https://github.com/dotnet/runtime/issues/30692#issuecomment-581164186) was a *workaround*, not a solution. This issue tracks the API additions needed to tweak the behavior.",
          "createdAt": "2020-02-03T08:22:12Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2020-02-03T08:22:12Z",
          "id": "MDEyOklzc3VlQ29tbWVudDU4MTI5MTgwOQ=="
        },
        {
          "author": "JinsPeter",
          "body": "Can someone add a CustomConverter that works?\r\nI tried and stopped wondering  \r\n- when this converter be hit,\r\n-  what if it is hit with a non-enum string value?\r\n- Do I need to write a try catch around `reader.GetGuid()`\r\n\r\n\r\n",
          "createdAt": "2021-09-03T14:04:36Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-09-03T14:04:36Z",
          "id": "IC_kwDODI9FZc42ZKQp"
        },
        {
          "author": "layomia",
          "body": "From @AntonIOIOIO in https://github.com/dotnet/runtime/issues/59474:\r\n\r\n> ### Description\r\n> \r\n> When you call GetGuid() from JsonElement the only valid format is 00000000-0000-0000-0000-000000000000? \r\n> \r\n> Why is that?\r\n> \r\n> https://github.com/dotnet/corefx/blob/master/src/System.Text.Json/src/System/Text/Json/Node/JsonString.cs\r\n> \r\n> The code is hardcoded to \"D\".\r\n> public Guid GetGuid() => Guid.ParseExact(_value, \"D\");\r\n",
          "createdAt": "2021-09-24T19:01:08Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-09-24T19:01:08Z",
          "id": "IC_kwDODI9FZc43PrDV"
        },
        {
          "author": "layomia",
          "body": "We should consider this issue a general one for extended `Guid` support across the `System.Text.Json` types - serializer, reader, writer, DOMs etc.",
          "createdAt": "2021-09-24T19:06:12Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-09-24T19:06:24Z",
          "id": "IC_kwDODI9FZc43Prxz"
        },
        {
          "author": "eiriktsarpalis",
          "body": "A concern I have about the proposal is that the new Guid overloads in Utf8JsonWriter/Utf8JsonReader:\r\n\r\n1. Push more serialization concerns to the Utf8JsonWriter/Utf8JsonReader layer.\r\n2. Don't directly resolve the motivating use case: users still need to author and register a custom converter that calls into the new methods.\r\n\r\nI'm wondering if instead it might make more sense to:\r\n\r\n1. Make the converter more lenient by default (accept both 'D' and 'N' formats and potentially others). Would need to measure potential perf regressions here.\r\n2. Add APIs to Utf8JsonWriter/Utf8JsonReader that make authoring the proposed `Guid` overloads practical (read: zero allocation) via user-defined extension methods. This is already possible on the writer side and we're planning on similar functionality on the reader via https://github.com/dotnet/runtime/issues/54410.",
          "createdAt": "2021-10-25T18:42:57Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-10-26T06:48:52Z",
                "user": "LeaFrock"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-11-18T11:28:59Z",
                "user": "asbestos"
              }
            ],
            "totalCount": 2,
            "endCursor": "Y3Vyc29yOnYyOpHOCDG1gg=="
          },
          "updatedAt": "2021-10-25T18:43:25Z",
          "id": "IC_kwDODI9FZc44sjXw"
        },
        {
          "author": "LeaFrock",
          "body": "As I read in #77020, this issue seems won't be solved in .NET 8?",
          "createdAt": "2023-01-03T03:10:12Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-01-03T03:10:12Z",
          "id": "IC_kwDODI9FZc5RnqHU"
        },
        {
          "author": "davhdavh",
          "body": "It is quite silly considering that most other places, N variants of GUIDs work just fine.\r\nE.g. PageModel parameters, or [FromQuery] properties",
          "createdAt": "2023-01-06T10:25:03Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-01-06T10:25:03Z",
          "id": "IC_kwDODI9FZc5R3RBu"
        },
        {
          "author": "JustArchi",
          "body": "Still an issue as of .NET 8, I'd love to see this getting more attention, as I don't see any real reason why only standard format of Guid is supported.\r\n\r\n```csharp\r\ninternal sealed class GuidJsonConverter : JsonConverter<Guid> {\r\n\tpublic override Guid Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) {\r\n\t\ttry {\r\n\t\t\treturn Guid.Parse(reader.GetString()!);\r\n\t\t} catch {\r\n\t\t\t// Throw JsonException instead, which will be converted into standard message by STJ\r\n\t\t\tthrow new JsonException();\r\n\t\t}\r\n\t}\r\n\r\n\tpublic override void Write(Utf8JsonWriter writer, Guid value, JsonSerializerOptions options) {\r\n\t\twriter.WriteStringValue(value.ToString());\r\n\t}\r\n}\r\n```\r\n\r\nThis custom converter does the trick, even if naturally it could be done better with underlying implementation.",
          "createdAt": "2024-02-27T00:28:57Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-03-13T00:41:23Z",
                "user": "LeaFrock"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHODaVwBg=="
          },
          "updatedAt": "2024-03-08T08:37:11Z",
          "id": "IC_kwDODI9FZc51KE4u"
        },
        {
          "author": "nicolashemery",
          "body": "Hello,\r\n\r\nI've the same issue to use FromBodyAttributes on AzureFunction. For now i'm using @JustArchi solution (thanks).\r\nBut i agree with the global spirit of that thread, that the serializer by default should support more format option, or to allow parametrization.",
          "createdAt": "2024-03-12T16:28:10Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-03-12T16:28:10Z",
          "id": "IC_kwDODI9FZc52vJxH"
        }
      ],
      "totalCount": 17,
      "endCursor": "Y3Vyc29yOnYyOpHOdrycRw=="
    },
    "url": "https://github.com/dotnet/runtime/issues/30692",
    "title": "System.Text.Json - Add overloads for reading a Guid using a custom \"standard format\""
  },
  {
    "author": "GSPP",
    "labels": [
      "area-System.Text.Json",
      "help wanted"
    ],
    "createdAt": "2019-08-28T13:43:32Z",
    "body": "I have continued my [investigation](https://github.com/dotnet/corefx/issues/39974) into discrepancies between single segment mode and multi segment mode in Utf8JsonSerializer. I found a few cases where the values for BytesConsumed, BytePositionInLine or the error message deviate between modes. Depending on the segmentation chunking, the error message and position numbers can be different for the same JSON. This could be an issue for debuggability and diagnosing production errors. It seems desirable that the segment mode should not affect parsing outcome.\r\n\r\nIt seems there are two issues:\r\n\r\n1. Processing of literals such as \"true\".\r\n2. Comment handling.\r\n\r\nHere are the test cases:\r\n\r\n    static class ReproProgramCompare\r\n    {\r\n        public static void Run()\r\n        {\r\n            RunTestCase(\"fals\");\r\n            RunTestCase(\"tb:\");\r\n            RunTestCase(\"{\\\"\\\":tr\");\r\n            RunTestCase(\"[[n{\\\"a\\\":\");\r\n            RunTestCase(\"f-2.2e-2,-\");\r\n\r\n            RunTestCase(\"/+\");\r\n            RunTestCase(\"{/\");\r\n            RunTestCase(\"{/s\");\r\n            RunTestCase(\"{ /\");\r\n            RunTestCase(\"{} /\");\r\n        }\r\n\r\n        static void RunTestCase(string jsonString)\r\n        {\r\n            var result = GetResultCompare(new JsonInput(Encoding.UTF8.GetBytes(jsonString), true, false, JsonCommentHandling.Skip));\r\n\r\n            Console.WriteLine($\"Test case: \" + jsonString);\r\n\r\n            var messageOutput = $\"BytesConsumed: {result.Result1.BytesConsumed}, CurrentDepth: {result.Result1.CurrentDepth}, TokenStartIndex: {result.Result1.TokenStartIndex}, TokenType: {result.Result1.TokenType}, Exception: {result.Result1.Exception?.Message}\";\r\n            messageOutput += Environment.NewLine + $\"BytesConsumed: {result.Result2.BytesConsumed}, CurrentDepth: {result.Result2.CurrentDepth}, TokenStartIndex: {result.Result2.TokenStartIndex}, TokenType: {result.Result2.TokenType}, Exception: {result.Result2.Exception?.Message}\";\r\n\r\n            Console.WriteLine(messageOutput);\r\n            Console.WriteLine();\r\n        }\r\n\r\n        static CompareResult GetResultCompare(JsonInput jsonInput)\r\n        {\r\n            var result1 = GetResultJsonReaderSingleSegment(jsonInput);\r\n            var result2 = GetResultJsonReaderMultiSegment(jsonInput);\r\n\r\n            string differenceString = null;\r\n\r\n            var hasExceptionDifference =\r\n                (result1.Exception != null) != (result2.Exception != null) ||\r\n                (result1.Exception != null && result2.Exception != null && (result1.Exception.GetType() != result2.Exception.GetType() || result1.Exception.Message != result2.Exception.Message));\r\n\r\n            if (\r\n                hasExceptionDifference ||\r\n                result1.BytesConsumed != result2.BytesConsumed ||\r\n                result1.CurrentDepth != result2.CurrentDepth ||\r\n                result1.TokenStartIndex != result2.TokenStartIndex ||\r\n                result1.TokenType != result2.TokenType ||\r\n                false)\r\n            {\r\n                differenceString = $\"Exception: {hasExceptionDifference}, BytesConsumed: {result1.BytesConsumed != result2.BytesConsumed}, CurrentDepth: {result1.CurrentDepth != result2.CurrentDepth}, TokenStartIndex: {result1.TokenStartIndex != result2.TokenStartIndex}, TokenType: {result1.TokenType != result2.TokenType}\";\r\n            }\r\n\r\n            return new CompareResult(result1, result2, differenceString);\r\n        }\r\n\r\n        class CompareResult\r\n        {\r\n            public JsonResult Result1 { get; }\r\n            public JsonResult Result2 { get; }\r\n            public string DifferenceString { get; }\r\n\r\n            public CompareResult(JsonResult result1, JsonResult result2, string differenceString)\r\n            {\r\n                Result1 = result1;\r\n                Result2 = result2;\r\n                DifferenceString = differenceString;\r\n            }\r\n\r\n            public override string ToString()\r\n            {\r\n                return $\"{nameof(Result1)}: {Result1}, {nameof(Result2)}: {Result2}, {nameof(DifferenceString)}: {DifferenceString}\";\r\n            }\r\n        }\r\n\r\n        static JsonResult GetResultJsonReaderMultiSegment(JsonInput jsonInput)\r\n        {\r\n            static IEnumerable<Memory<byte>> SplitMemory(Memory<byte> memory, int chunkSize)\r\n            {\r\n                for (int startIndex = 0; startIndex < memory.Length; startIndex += chunkSize)\r\n                    yield return memory.Slice(startIndex, Math.Min(chunkSize, memory.Length - startIndex));\r\n            }\r\n\r\n            var memories = SplitMemory(jsonInput.JsonBytes, 1);\r\n\r\n            var jsonReader = new Utf8JsonReader(CreateReadOnlySequence(memories), jsonInput.IsFinalBlock, new JsonReaderState(jsonInput.GetJsonReaderOptions()));\r\n\r\n            var jsonResult = ConsumeJsonReader(jsonReader, jsonInput.JsonBytes.Length);\r\n\r\n            return jsonResult;\r\n        }\r\n\r\n        static JsonResult GetResultJsonReaderSingleSegment(JsonInput jsonInput)\r\n        {\r\n            var utf8JsonGuardPage = jsonInput.JsonBytes;\r\n\r\n            var jsonReader = new Utf8JsonReader(utf8JsonGuardPage, jsonInput.IsFinalBlock, new JsonReaderState(jsonInput.GetJsonReaderOptions()));\r\n\r\n            return ConsumeJsonReader(jsonReader, utf8JsonGuardPage.Length);\r\n        }\r\n\r\n        static JsonResult ConsumeJsonReader(Utf8JsonReader jsonReader, int inputLength)\r\n        {\r\n            Exception exception = null;\r\n            try\r\n            {\r\n                long lastBytesConsumed = 0;\r\n                long lastTokenStartIndex = -1;\r\n                JsonTokenType lastTokenType = JsonTokenType.None;\r\n\r\n                while (jsonReader.Read())\r\n                {\r\n                    if (jsonReader.BytesConsumed <= lastBytesConsumed)\r\n                        throw new Exception(\"State: BytesConsumed.\");\r\n\r\n                    if (jsonReader.TokenStartIndex <= lastTokenStartIndex)\r\n                        throw new Exception(\"State: TokenStartIndex.\");\r\n\r\n                    if (jsonReader.TokenType == lastTokenType &&\r\n                        (lastTokenType == JsonTokenType.False ||\r\n                         lastTokenType == JsonTokenType.True ||\r\n                         lastTokenType == JsonTokenType.Null ||\r\n                         lastTokenType == JsonTokenType.False ||\r\n                         lastTokenType == JsonTokenType.String ||\r\n                         lastTokenType == JsonTokenType.Number ||\r\n                         lastTokenType == JsonTokenType.PropertyName ||\r\n                         false))\r\n                        throw new Exception(\"State: TokenType.\");\r\n\r\n                    lastBytesConsumed = jsonReader.BytesConsumed;\r\n                    lastTokenStartIndex = jsonReader.TokenStartIndex;\r\n                    lastTokenType = jsonReader.TokenType;\r\n                }\r\n\r\n                if (jsonReader.IsFinalBlock && jsonReader.BytesConsumed != inputLength)\r\n                    throw new Exception(\"State: Incomplete.\");\r\n\r\n                if (jsonReader.IsFinalBlock &&\r\n                    (jsonReader.TokenType == JsonTokenType.StartArray ||\r\n                     jsonReader.TokenType == JsonTokenType.StartObject ||\r\n                     jsonReader.TokenType == JsonTokenType.None ||\r\n                     false))\r\n                    throw new Exception(\"State: Final TokenType.\");\r\n            }\r\n            catch (Exception ex)\r\n            {\r\n                exception = ex;\r\n            }\r\n\r\n            return new JsonResult(exception, jsonReader.BytesConsumed, jsonReader.CurrentDepth, jsonReader.TokenStartIndex, jsonReader.TokenType);\r\n        }\r\n\r\n        readonly struct JsonInput\r\n        {\r\n            public byte[] JsonBytes { get; }\r\n            public bool IsFinalBlock { get; }\r\n            public bool AllowTrailingCommas { get; }\r\n            public JsonCommentHandling CommentHandling { get; }\r\n\r\n            public JsonReaderOptions GetJsonReaderOptions() => new JsonReaderOptions() { AllowTrailingCommas = AllowTrailingCommas, CommentHandling = CommentHandling };\r\n\r\n            public JsonInput(byte[] jsonBytes, bool isFinalBlock, bool allowTrailingCommas, JsonCommentHandling commentHandling)\r\n            {\r\n                JsonBytes = jsonBytes;\r\n                IsFinalBlock = isFinalBlock;\r\n                AllowTrailingCommas = allowTrailingCommas;\r\n                CommentHandling = commentHandling;\r\n            }\r\n        }\r\n\r\n        class JsonResult\r\n        {\r\n            public Exception Exception { get; }\r\n            public long BytesConsumed { get; }\r\n            public int CurrentDepth { get; }\r\n            public long TokenStartIndex { get; }\r\n            public JsonTokenType TokenType { get; }\r\n\r\n            public JsonResult(Exception exception, long bytesConsumed, int currentDepth, long tokenStartIndex, JsonTokenType tokenType)\r\n            {\r\n                Exception = exception;\r\n                BytesConsumed = bytesConsumed;\r\n                CurrentDepth = currentDepth;\r\n                TokenStartIndex = tokenStartIndex;\r\n                TokenType = tokenType;\r\n            }\r\n\r\n            public override string ToString()\r\n            {\r\n                return $\"{nameof(Exception)}: {Exception}, {nameof(BytesConsumed)}: {BytesConsumed}, {nameof(CurrentDepth)}: {CurrentDepth}, {nameof(TokenStartIndex)}: {TokenStartIndex}, {nameof(TokenType)}: {TokenType}\";\r\n            }\r\n        }\r\n\r\n        public static ReadOnlySequence<T> CreateReadOnlySequence<T>(IEnumerable<Memory<T>> buffers) => SimpleReadOnlySequenceSegment<T>.Create(buffers);\r\n\r\n        class SimpleReadOnlySequenceSegment<T> : ReadOnlySequenceSegment<T>\r\n        {\r\n            internal static ReadOnlySequence<T> Create(IEnumerable<Memory<T>> buffers)\r\n            {\r\n                SimpleReadOnlySequenceSegment<T> segment = null;\r\n                SimpleReadOnlySequenceSegment<T> first = null;\r\n                foreach (Memory<T> buffer in buffers)\r\n                {\r\n                    var newSegment = new SimpleReadOnlySequenceSegment<T>()\r\n                    {\r\n                        Memory = buffer,\r\n                    };\r\n\r\n                    if (segment != null)\r\n                    {\r\n                        segment.Next = newSegment;\r\n                        newSegment.RunningIndex = segment.RunningIndex + segment.Memory.Length;\r\n                    }\r\n                    else\r\n                    {\r\n                        first = newSegment;\r\n                    }\r\n\r\n                    segment = newSegment;\r\n                }\r\n\r\n                if (first == null)\r\n                {\r\n                    first = segment = new SimpleReadOnlySequenceSegment<T>();\r\n                }\r\n\r\n                return new ReadOnlySequence<T>(first, 0, segment, segment.Memory.Length);\r\n            }\r\n        }\r\n    }\r\n\r\nOutput:\r\n\r\nTest case: fals\r\nBytesConsumed: 0, CurrentDepth: 0, TokenStartIndex: 0, TokenType: None, Exception: 'fals' is an invalid JSON literal. Expected the literal 'false'. LineNumber: 0 | BytePositionInLine: 4.\r\nBytesConsumed: 0, CurrentDepth: 0, TokenStartIndex: 0, TokenType: None, Exception: 'fal' is an invalid JSON literal. Expected the literal 'false'. LineNumber: 0 | BytePositionInLine: 4.\r\n\r\nTest case: tb:\r\nBytesConsumed: 0, CurrentDepth: 0, TokenStartIndex: 0, TokenType: None, Exception: 'tb:' is an invalid JSON literal. Expected the literal 'true'. LineNumber: 0 | BytePositionInLine: 1.\r\nBytesConsumed: 0, CurrentDepth: 0, TokenStartIndex: 0, TokenType: None, Exception: 'tb' is an invalid JSON literal. Expected the literal 'true'. LineNumber: 0 | BytePositionInLine: 1.\r\n\r\nTest case: {\"\":tr\r\nBytesConsumed: 4, CurrentDepth: 1, TokenStartIndex: 4, TokenType: PropertyName, Exception: 'tr' is an invalid JSON literal. Expected the literal 'true'. LineNumber: 0 | BytePositionInLine: 6.\r\nBytesConsumed: 4, CurrentDepth: 1, TokenStartIndex: 4, TokenType: PropertyName, Exception: 't' is an invalid JSON literal. Expected the literal 'true'. LineNumber: 0 | BytePositionInLine: 6.\r\n\r\nTest case: [[n{\"a\":\r\nBytesConsumed: 2, CurrentDepth: 1, TokenStartIndex: 2, TokenType: StartArray, Exception: 'n{\"a\":' is an invalid JSON literal. Expected the literal 'null'. LineNumber: 0 | BytePositionInLine: 3.\r\nBytesConsumed: 2, CurrentDepth: 1, TokenStartIndex: 2, TokenType: StartArray, Exception: 'n{' is an invalid JSON literal. Expected the literal 'null'. LineNumber: 0 | BytePositionInLine: 3.\r\n\r\nTest case: f-2.2e-2,-\r\nBytesConsumed: 0, CurrentDepth: 0, TokenStartIndex: 0, TokenType: None, Exception: 'f-2.2e-2,-' is an invalid JSON literal. Expected the literal 'false'. LineNumber: 0 | BytePositionInLine: 1.\r\nBytesConsumed: 0, CurrentDepth: 0, TokenStartIndex: 0, TokenType: None, Exception: 'f-' is an invalid JSON literal. Expected the literal 'false'. LineNumber: 0 | BytePositionInLine: 1.\r\n\r\nTest case: /+\r\nBytesConsumed: 0, CurrentDepth: 0, TokenStartIndex: 0, TokenType: None, Exception: '/' is an invalid start of a value. LineNumber: 0 | BytePositionInLine: 0.\r\nBytesConsumed: 1, CurrentDepth: 0, TokenStartIndex: 0, TokenType: None, Exception: '+' is invalid after '/' at the beginning of the comment. Expected either '/' or '*'. LineNumber: 0 | BytePositionInLine: 1.\r\n\r\nTest case: {/\r\nBytesConsumed: 1, CurrentDepth: 0, TokenStartIndex: 1, TokenType: StartObject, Exception: '/' is an invalid start of a value. LineNumber: 0 | BytePositionInLine: 1.\r\nBytesConsumed: 2, CurrentDepth: 0, TokenStartIndex: 1, TokenType: StartObject, Exception: Unexpected end of data while reading a comment. LineNumber: 0 | BytePositionInLine: 2.\r\n\r\nTest case: {/s\r\nBytesConsumed: 1, CurrentDepth: 0, TokenStartIndex: 1, TokenType: StartObject, Exception: '/' is an invalid start of a value. LineNumber: 0 | BytePositionInLine: 1.\r\nBytesConsumed: 2, CurrentDepth: 0, TokenStartIndex: 1, TokenType: StartObject, Exception: 's' is invalid after '/' at the beginning of the comment. Expected either '/' or '*'. LineNumber: 0 | BytePositionInLine: 2.\r\n\r\nTest case: { /\r\nBytesConsumed: 2, CurrentDepth: 0, TokenStartIndex: 2, TokenType: StartObject, Exception: '/' is an invalid start of a value. LineNumber: 0 | BytePositionInLine: 2.\r\nBytesConsumed: 3, CurrentDepth: 0, TokenStartIndex: 2, TokenType: StartObject, Exception: Unexpected end of data while reading a comment. LineNumber: 0 | BytePositionInLine: 3.\r\n\r\nTest case: {} /\r\nBytesConsumed: 3, CurrentDepth: 0, TokenStartIndex: 3, TokenType: EndObject, Exception: '/' is an invalid start of a value. LineNumber: 0 | BytePositionInLine: 3.\r\nBytesConsumed: 4, CurrentDepth: 0, TokenStartIndex: 3, TokenType: EndObject, Exception: Unexpected end of data while reading a comment. LineNumber: 0 | BytePositionInLine: 4.\r\n\r\n@ahsonkhan ",
    "number": 30706,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "THUMBS_UP",
          "createdAt": "2019-08-28T20:13:31Z",
          "user": "scalablecory"
        }
      ],
      "totalCount": 1,
      "endCursor": "Y3Vyc29yOnYyOpHOAveEPg=="
    },
    "updatedAt": "2022-12-04T14:50:24Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": "ahsonkhan",
          "body": "Thanks for the investigation and issue, @GSPP \r\n\r\nLooks like all the discrepancies you mentioned are for invalid JSON and exception messages. This is something we should fix for vNext. I have updated the issue title to reflect that. Please feel free to update it as you see fit (FYI, these issues related to the `Utf8JsonReader`, not serializer - so I updated that too).\r\n\r\nDid you find any issues with `BytesConsumed` for valid JSON or any other such discrepancy which could lead to correctness issues?",
          "createdAt": "2019-08-28T19:21:36Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2019-08-28T19:50:29Z",
                "user": "GSPP"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOAvd82g=="
          },
          "updatedAt": "2019-08-28T19:22:46Z",
          "id": "MDEyOklzc3VlQ29tbWVudDUyNTg4NjIzNQ=="
        },
        {
          "author": "GSPP",
          "body": "I did not find any (further) issues with valid JSON. I understand that invalid JSON is of lower priority.",
          "createdAt": "2019-08-28T19:55:57Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2019-08-29T06:11:58Z",
                "user": "ahsonkhan"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOAvfwSQ=="
          },
          "updatedAt": "2019-08-28T19:55:57Z",
          "id": "MDEyOklzc3VlQ29tbWVudDUyNTg5ODA2MQ=="
        },
        {
          "author": "WinCPP",
          "body": "@ahsonkhan @GSPP I was thinking of looking into this, if no one is...\r\n\r\nEDIT: It was a conflict of 3.x vs 5.x for TargetFramework. Looks like I am able to proceed with generation of console app using the above test code...\r\n\r\n~~I need a help, though. I am creating a `self-contained` application using my local build and for that I am first doing the steps at this link https://github.com/dotnet/corefx/blob/master/Documentation/project-docs/dogfooding.md#option-2-self-contained The self-contained app is to use the test code shared by @GSPP~~\r\n\r\n~~However running `dotnet restore`, I get these errors. Appreciate inputs on how to use the local build.~~\r\n\r\n```\r\nD:\\Home\\Test>dotnet restore\r\nD:\\Home\\Test\\Test.csproj : error NU1102: Unable to find package Microsoft.AspNetCore.App.Runtime.win-x64 with version (= 5.0.0-alpha1.19459.39)\r\nD:\\Home\\Test\\Test.csproj : error NU1102:   - Found 24 version(s) in dotnetcore-feed [ Nearest version: 3.0.0-preview4-19121-14 ]\r\nD:\\Home\\Test\\Test.csproj : error NU1102:   - Found 6 version(s) in nuget.org [ Nearest version: 3.0.0-preview9.19424.4 ]\r\nD:\\Home\\Test\\Test.csproj : error NU1102:   - Found 0 version(s) in Microsoft Visual Studio Offline Packages\r\nD:\\Home\\Test\\Test.csproj : error NU1102:   - Found 0 version(s) in CliFallbackFolder\r\n  Restore failed in 138.21 ms for D:\\Home\\Test\\Test.csproj.\r\n```",
          "createdAt": "2019-09-10T19:05:45Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2019-09-10T20:19:55Z",
          "id": "MDEyOklzc3VlQ29tbWVudDUzMDA3NzEzOA=="
        },
        {
          "author": null,
          "body": "Due to lack of recent activity, this issue has been marked as a candidate for backlog cleanup.  It will be closed if no further activity occurs within 14 more days. Any new comment (by anyone, not necessarily the author) will undo this process.\n\nThis process is part of the experimental [issue cleanup initiative](https://github.com/dotnet/runtime/issues/60288) we are currently trialing in a limited number of areas. Please share any feedback you might have in the linked issue.",
          "createdAt": "2021-10-17T00:34:41Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-10-17T00:34:41Z",
          "id": "IC_kwDODI9FZc44U_mX"
        },
        {
          "author": "GSPP",
          "body": "This issue had previously been scheduled for a fix but that seems to have been postponed. Is it really the right choice to let the bot close this? I suggest that a team member makes an explicit decision on whether this is to be fixed or by design.\r\n\r\nThe discrepancy in `BytesConsumed` seems to me to be the most critical point here. I don't know what this value is typically used for by callers. Maybe it is being used to advance a stream or pipe? In that case, that value would need to be accurate.\r\n",
          "createdAt": "2021-10-19T07:04:55Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-10-19T07:09:42Z",
          "id": "IC_kwDODI9FZc44aUkR"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Related to #30751 and #27949.",
          "createdAt": "2021-10-21T12:37:03Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-10-21T12:37:41Z",
          "id": "IC_kwDODI9FZc44ihD2"
        },
        {
          "author": "eiriktsarpalis",
          "body": "We won't have time to look at this during the 7.0 timeframe, moving to Future.",
          "createdAt": "2022-04-18T15:29:17Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-04-18T15:29:17Z",
          "id": "IC_kwDODI9FZc5Bp4zS"
        },
        {
          "author": "GSPP",
          "body": "When you fix this, I have way of improving my systematic testing system and I can provide more such validation. I might also be able to find bugs that are truly problematic. Right now, I'm kind of waiting because the logs are polluted with such low-priority items. My point being that if these low-priority issues are fixed this might enable me to find more serious issues.\r\n\r\nOf course, I respect your scheduling decision.",
          "createdAt": "2022-04-19T08:15:41Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-04-19T08:15:41Z",
          "id": "IC_kwDODI9FZc5Bszrg"
        },
        {
          "author": "layomia",
          "body": "@GSPP since you did the initial deep dive on finding this issue, would you consider offering a fix? This way the library gets better and you are unblocked for further investigation.",
          "createdAt": "2022-12-02T16:46:58Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-12-02T16:46:58Z",
          "id": "IC_kwDODI9FZc5PmnXe"
        },
        {
          "author": "GSPP",
          "body": "@layomia I'm really not set up to contribute right now but I might very well resume the investigation when unblocked. Lots more to try.",
          "createdAt": "2022-12-04T14:50:24Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-12-12T10:40:07Z",
                "user": "layomia"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOCxFQFw=="
          },
          "updatedAt": "2022-12-04T14:50:24Z",
          "id": "IC_kwDODI9FZc5PqFIx"
        }
      ],
      "totalCount": 10,
      "endCursor": "Y3Vyc29yOnYyOpHOT6hSMQ=="
    },
    "url": "https://github.com/dotnet/runtime/issues/30706",
    "title": "Discrepancies in Utf8JsonReader between single- and multi-segment modes for invalid JSON"
  },
  {
    "author": "GSPP",
    "labels": [
      "enhancement",
      "area-System.Text.Json"
    ],
    "createdAt": "2019-09-03T17:16:13Z",
    "body": "Execute the following program:\r\n\r\n\ttry\r\n\t{\r\n\t\tvar jsonBytes = Encoding.UTF8.GetBytes(\"{/\");\r\n\t\tvar readOnlySequence = Util.CreateReadOnlySequence(Util.SplitMemory(jsonBytes, 1));\r\n\t\tvar reader = new Utf8JsonReader(readOnlySequence, new JsonReaderOptions() { CommentHandling = JsonCommentHandling.Skip });\r\n\t\treader.Read();\r\n\t\treader = new Utf8JsonReader(readOnlySequence.Slice(1), true, reader.CurrentState); //reset reader, comment this out\r\n\t\treader.Read();\r\n\t}\r\n\tcatch (Exception ex)\r\n\t{\r\n\t\tConsole.WriteLine(ex);\r\n\t}\r\n\r\nNext, comment out the marked line. The error message changes from\r\n\r\n> System.Text.Json.JsonReaderException: '/' is an invalid start of a value. LineNumber: 0 | BytePositionInLine: 1.\r\n\r\nto\r\n\r\n> System.Text.Json.JsonReaderException: Unexpected end of data while reading a comment. LineNumber: 0 | BytePositionInLine: 2.\r\n\r\nNote, that multi-segment mode is used and `JsonCommentHandling.Skip` is set.\r\n\r\nThis code requires the following utility class:\r\n\r\n    static class Util\r\n    {\r\n        public static IEnumerable<Memory<byte>> SplitMemory(Memory<byte> memory, int chunkSize)\r\n        {\r\n            for (int startIndex = 0; startIndex < memory.Length; startIndex += chunkSize)\r\n                yield return memory.Slice(startIndex, Math.Min(chunkSize, memory.Length - startIndex));\r\n        }\r\n\r\n        public static ReadOnlySequence<T> CreateReadOnlySequence<T>(IEnumerable<Memory<T>> buffers) => SimpleReadOnlySequenceSegment<T>.Create(buffers);\r\n\r\n        class SimpleReadOnlySequenceSegment<T> : ReadOnlySequenceSegment<T>\r\n        {\r\n            internal static ReadOnlySequence<T> Create(IEnumerable<Memory<T>> buffers)\r\n            {\r\n                SimpleReadOnlySequenceSegment<T> segment = null;\r\n                SimpleReadOnlySequenceSegment<T> first = null;\r\n                foreach (Memory<T> buffer in buffers)\r\n                {\r\n                    var newSegment = new SimpleReadOnlySequenceSegment<T>()\r\n                    {\r\n                        Memory = buffer,\r\n                    };\r\n\r\n                    if (segment != null)\r\n                    {\r\n                        segment.Next = newSegment;\r\n                        newSegment.RunningIndex = segment.RunningIndex + segment.Memory.Length;\r\n                    }\r\n                    else\r\n                    {\r\n                        first = newSegment;\r\n                    }\r\n\r\n                    segment = newSegment;\r\n                }\r\n\r\n                if (first == null)\r\n                {\r\n                    first = segment = new SimpleReadOnlySequenceSegment<T>();\r\n                }\r\n\r\n                return new ReadOnlySequence<T>(first, 0, segment, segment.Memory.Length);\r\n            }\r\n        }\r\n    }\r\n\r\nThis discrepancy can cause behavior changes depending on how big chunks of data read from the network are. Recreating a reader from a state is required in streaming scenarios with async IO. I quote my reasoning for fixing this from my previous issue:\r\n\r\n> I found a few cases where the values for BytesConsumed, BytePositionInLine or the error message deviate between modes. Depending on the segmentation chunking, the error message and position numbers can be different for the same JSON. This could be an issue for debuggability and diagnosing production errors. It seems desirable that the segment mode should not affect parsing outcome.\r\n\r\nAlso, is `BytePositionInLine` used to make parsing decisions? It seems that `CheckLiteralMultiSegment` uses it. In that case, this might actually be a functional parsing bug.",
    "number": 30751,
    "reactions": {
      "hasNextPage": false,
      "nodes": [],
      "totalCount": 0,
      "endCursor": null
    },
    "updatedAt": "2022-09-02T16:02:16Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": "ahsonkhan",
          "body": "> The error message changes\r\n\r\nThis discrepancy is because of the differences in the code-paths for single-segment vs multi-segment payloads. When you slice the sequence during the creation of another `Utf8JsonReader`, it becomes single-segment. Without that, it remains multi-segment. That's a good test case, @GSPP.\r\n\r\nSingle-segment doesn't increment `_bytePositionInLine` before checking if there is any data left.\r\nhttps://github.com/dotnet/corefx/blob/70b4d01e18236c925c2d44d49fff7cbb4919dc43/src/System.Text.Json/src/System/Text/Json/Reader/Utf8JsonReader.cs#L2290-L2297\r\n\r\nMulti-segment does increment it:\r\nhttps://github.com/dotnet/corefx/blob/70b4d01e18236c925c2d44d49fff7cbb4919dc43/src/System.Text.Json/src/System/Text/Json/Reader/Utf8JsonReader.MultiSegment.cs#L2223-L2232\r\n\r\nWe changed the multi-segment code path for comment handling (https://github.com/dotnet/corefx/pull/38036). We should make similar changes to the single-segment path as well.\r\n\r\n> System.Text.Json.JsonReaderException: Unexpected end of data while reading a comment. LineNumber: 0 | BytePositionInLine: 2.\r\n\r\nI think this should be the expected exception thrown along with byte position set to 2, in both cases.\r\n\r\ncc @krwq \r\n\r\nGiven this is only affecting the exception thrown for invalid JSON in an edge case (and where we are in the product for 3.0), moving to 5.0. I don't think this behavioral discrepancy would have significant impact on callers.\r\n\r\n> Also, is `BytePositionInLine` used to make parsing decisions? It seems that `CheckLiteralMultiSegment` uses it. In that case, this might actually be a functional parsing bug.\r\n\r\nThat's a good point. However, I don't see any feasible link between when the byte position gets mismatched and when the parser hits the code path in `CheckLiteralMultiSegment` (particularly because the bug in byte position only occurs on invalid JSON parsing which throws/stops the parser, leaving it an undefined state to continue further anyway).",
          "createdAt": "2019-09-04T05:19:09Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2019-09-04T05:22:52Z",
          "id": "MDEyOklzc3VlQ29tbWVudDUyNzc0NDEzOA=="
        },
        {
          "author": "GSPP",
          "body": "I see! Thanks for the detailed reply.\r\n\r\nIndeed, all repro cases, which I can generate, have the `/` at the end. This is what triggers single-segment mode.\r\n\r\nI was experimenting with resetting the reader after each token. I was unable to generate other issues that way.\r\n\r\nClosing this since there is nothing to do.\r\n",
          "createdAt": "2019-09-08T12:41:07Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2019-09-08T12:42:34Z",
          "id": "MDEyOklzc3VlQ29tbWVudDUyOTE5ODk0OA=="
        },
        {
          "author": "ahsonkhan",
          "body": "> Closing this since there is nothing to do.\r\n\r\nI think its still worth making things consistent between the two code paths for completeness (hence re-opening). That said, it's unlikely for this issue to cause much concern for most use cases.\r\n\r\n> We changed the multi-segment code path for comment handling (https://github.com/dotnet/corefx/pull/38036). We should make similar changes to the single-segment path as well.\r\n\r\n> System.Text.Json.JsonReaderException: Unexpected end of data while reading a comment. LineNumber: 0 | BytePositionInLine: 2.\r\n\r\nI think this should be the expected exception thrown along with byte position set to 2, in both cases.",
          "createdAt": "2019-09-09T00:25:06Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2019-09-09T09:19:43Z",
                "user": "GSPP"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOAwKX9A=="
          },
          "updatedAt": "2019-09-09T00:25:06Z",
          "id": "MDEyOklzc3VlQ29tbWVudDUyOTI2MTMwOA=="
        },
        {
          "author": null,
          "body": "Due to lack of recent activity, this issue has been marked as a candidate for backlog cleanup.  It will be closed if no further activity occurs within 14 more days. Any new comment (by anyone, not necessarily the author) will undo this process.\n\nThis process is part of the experimental [issue cleanup initiative](https://github.com/dotnet/runtime/issues/60288) we are currently trialing in a limited number of areas. Please share any feedback you might have in the linked issue.",
          "createdAt": "2021-10-15T19:38:28Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-10-15T19:38:28Z",
          "id": "IC_kwDODI9FZc44Tamv"
        },
        {
          "author": "GSPP",
          "body": "@eiriktsarpalis I'm pinging you on this issue as well so that you can make a scheduling decision rather than letting the bot make it by default.",
          "createdAt": "2021-10-21T11:16:57Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-10-21T12:14:26Z",
                "user": "eiriktsarpalis"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOB_Q4Qg=="
          },
          "updatedAt": "2021-10-21T11:16:57Z",
          "id": "IC_kwDODI9FZc44iRp5"
        },
        {
          "author": "eiriktsarpalis",
          "body": "It still reproduces in .NET 6, here's a standalone reproduction:\r\n```csharp\r\nusing System;\r\nusing System.Text;\r\nusing System.Text.Json;\r\nusing System.Buffers;\r\n\r\nvar readOnlySequence = Utils.CreateReadOnlySequence(Encoding.UTF8.GetBytes(\"{\"), Encoding.UTF8.GetBytes(\"/\"));\r\nvar reader = new Utf8JsonReader(readOnlySequence, new JsonReaderOptions() { CommentHandling = JsonCommentHandling.Skip });\r\nreader.Read();\r\n\r\nvar clonedReader = new Utf8JsonReader(readOnlySequence.Slice(1), true, reader.CurrentState);\r\ntry { reader.Read(); } catch (JsonException ex) { Console.WriteLine($\"Expected error message: {ex.Message}\"); }\r\ntry { clonedReader.Read(); } catch (JsonException ex) { Console.WriteLine($\"Actual error message: {ex.Message}\"); };\r\n\r\npublic static class Utils\r\n{\r\n    public static ReadOnlySequence<T> CreateReadOnlySequence<T>(params T[][] buffers)\r\n    {\r\n        if (buffers == null || buffers.Length == 0)\r\n        {\r\n            return default;\r\n        }\r\n\r\n        if (buffers.Length == 1)\r\n        {\r\n            return new ReadOnlySequence<T>(buffers[0]);\r\n        }\r\n\r\n        var tail = new MySegment<T>(buffers[^1]);\r\n        MySegment<T>? current = tail;\r\n\r\n        for (int i = buffers.Length - 2; i >= 0; i--)\r\n        {\r\n            current = new MySegment<T>(buffers[i], current);\r\n        }\r\n\r\n        MySegment<T> head = current!;\r\n        long runningIndex = 0;\r\n\r\n        while (current != null)\r\n        {\r\n            current.SetRunningIndex(runningIndex);\r\n            runningIndex += current.Memory.Length;\r\n            current = (MySegment<T>?)current.Next;\r\n        }\r\n\r\n        return new ReadOnlySequence<T>(head, 0, tail, tail.Memory.Length);\r\n    }\r\n\r\n    private class MySegment<T> : ReadOnlySequenceSegment<T>\r\n    {\r\n        public MySegment(ReadOnlyMemory<T> memory, MySegment<T>? next = null)\r\n        {\r\n            Memory = memory;\r\n            Next = next;\r\n        }\r\n\r\n        public void SetRunningIndex(long index) => RunningIndex = index;\r\n    }\r\n}\r\n```\r\nPer @ahsonkhan's comments we should investigate the discrepancy although it doesn't seem like a high-enough priority issue.",
          "createdAt": "2021-10-21T12:25:56Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-10-21T12:25:56Z",
          "id": "IC_kwDODI9FZc44ie35"
        }
      ],
      "totalCount": 6,
      "endCursor": "Y3Vyc29yOnYyOpHOOInt-Q=="
    },
    "url": "https://github.com/dotnet/runtime/issues/30751",
    "title": "Resetting a Utf8JsonReader at a certain point causes discrepancy in BytePositionInLine"
  },
  {
    "author": "btecu",
    "labels": [
      "area-System.Text.Json",
      "wishlist"
    ],
    "createdAt": "2019-10-01T02:22:19Z",
    "body": "In JSON.NET you can:\r\n```\r\nJsonConvert.DefaultSettings = () => new JsonSerializerSettings {\r\n    DateTimeZoneHandling = DateTimeZoneHandling.Utc\r\n};\r\n```\r\n\r\nIs there anything similar in `System.Text.Json`?\r\nIf there is not an option to set the default, can it be passed in manually?\r\n\r\nAlso, what is the default (`Local`, `Utc`, `Unspecified`)?",
    "number": 1566,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "THUMBS_UP",
          "createdAt": "2019-10-07T17:59:45Z",
          "user": "KamranShahid"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2019-10-23T07:19:20Z",
          "user": "mehyaa"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2020-02-08T16:54:29Z",
          "user": "dougludlow"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2020-02-11T08:37:06Z",
          "user": "spiko-md"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2020-06-22T07:17:10Z",
          "user": "azydevelopment"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2020-07-29T12:26:23Z",
          "user": "dandry"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2020-09-24T06:32:28Z",
          "user": "daka01"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2020-09-28T15:21:34Z",
          "user": "nerumo"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2020-10-14T14:14:23Z",
          "user": "fen89"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2020-10-22T08:03:52Z",
          "user": "msmolka"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2020-11-12T01:31:49Z",
          "user": "717009629"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2020-12-05T18:39:39Z",
          "user": "titobf"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-01-17T07:17:37Z",
          "user": "chriswill"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-01-29T16:27:37Z",
          "user": "musakasim"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-02-02T18:42:15Z",
          "user": "danilobreda"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-02-02T20:40:20Z",
          "user": "artemsnezhny"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-02-24T21:42:59Z",
          "user": "davemanton"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-03-20T13:24:29Z",
          "user": "VadimOvchinnikov"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-03-30T19:55:41Z",
          "user": "ardalis"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-06-08T12:20:55Z",
          "user": "TheFireCookie"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-06-18T18:13:47Z",
          "user": "WeihanLi"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-07-12T06:54:14Z",
          "user": "saxmaster79"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-07-27T17:38:59Z",
          "user": "mrcunninghamz"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-09-13T18:20:05Z",
          "user": "ChrisSimmons"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-12-02T15:59:07Z",
          "user": "felschr"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-12-10T14:29:42Z",
          "user": "n-l-vasilyev"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-02-01T18:19:46Z",
          "user": "juanbassist"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-02-10T01:31:54Z",
          "user": "tmlima"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-02-25T11:52:07Z",
          "user": "WojciechNagorski"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-03-09T10:11:59Z",
          "user": "necipsunmaz"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-06-16T18:01:04Z",
          "user": "jmbryan4"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-06-30T15:19:50Z",
          "user": "a11delavar"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-07-07T10:28:11Z",
          "user": "xsoheilalizadeh"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-08-22T16:18:29Z",
          "user": "JasonFoglia"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-09-02T17:50:28Z",
          "user": "alitoufighi"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-09-16T16:50:18Z",
          "user": "enioluwas"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-09-28T06:57:36Z",
          "user": "abhith"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-10-25T12:24:25Z",
          "user": "activist"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-11-08T08:57:31Z",
          "user": "AlexanderFinkbeiner"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-12-02T21:42:50Z",
          "user": "TWhidden"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-12-10T20:31:39Z",
          "user": "Ch0bits"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-12-13T03:50:33Z",
          "user": "arthg"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-01-30T19:39:27Z",
          "user": "ddimkovikj"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-03-13T11:18:41Z",
          "user": "molnarm"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-04-19T08:49:21Z",
          "user": "pasestars"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-09-10T21:59:09Z",
          "user": "vernou"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-09-11T05:54:26Z",
          "user": "msedi"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-09-24T20:11:11Z",
          "user": "SergeyLukashov"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-09-29T10:00:27Z",
          "user": "xiety"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-10-20T05:45:21Z",
          "user": "drsmile1001"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-10-26T12:39:37Z",
          "user": "emilpalsson"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-10-28T11:49:12Z",
          "user": "BoundedChenn31"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-11-07T15:53:47Z",
          "user": "thepirat000"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-11-08T14:03:56Z",
          "user": "AlexandreBossard"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-12-05T20:05:10Z",
          "user": "WalissonPires"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-12-22T19:43:55Z",
          "user": "HebaruSan"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-02-15T22:10:25Z",
          "user": "croaton23"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-06-28T15:36:53Z",
          "user": "IchinichiQ"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-08-04T08:24:22Z",
          "user": "AtzeBK"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-09-25T19:09:52Z",
          "user": "ce-ey-herting"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-09-27T16:55:20Z",
          "user": "chaimtevel"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-10-10T15:48:17Z",
          "user": "nosalan"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-10-16T02:35:01Z",
          "user": "issue-dispenser"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-10-16T12:43:51Z",
          "user": "bronteq"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-10-16T16:47:52Z",
          "user": "mmarinchenko"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-10-16T20:01:19Z",
          "user": "cvocvo"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-10-17T05:58:09Z",
          "user": "holger-at-schottel-de"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-10-17T06:28:42Z",
          "user": "cplankl"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-10-17T06:39:07Z",
          "user": "John0King"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-10-17T23:29:13Z",
          "user": "hoangthanh28"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-10-23T12:46:23Z",
          "user": "bart-vmware"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-10-23T13:41:26Z",
          "user": "danielebanovaz"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-10-24T05:03:46Z",
          "user": "NN---"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-10-24T12:53:03Z",
          "user": "neon-sunset"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-10-28T08:41:58Z",
          "user": "andreizhvaleuski"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-11-03T09:30:31Z",
          "user": "AmrAlSayed0"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-11-11T15:03:22Z",
          "user": "pontusdacke"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-11-20T07:06:25Z",
          "user": "hf-kklein"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-01-09T09:24:32Z",
          "user": "schrufygroovy"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-01-30T21:58:18Z",
          "user": "Naskalin"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-02-18T16:44:56Z",
          "user": "ryandeering"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-05-15T05:47:28Z",
          "user": "ikeima"
        }
      ],
      "totalCount": 82,
      "endCursor": "Y3Vyc29yOnYyOpHOCE_IiA=="
    },
    "updatedAt": "2024-10-12T19:11:04Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": "steveharter",
          "body": "cc @layomia on dates\r\n\r\nSince a DateTime can be set in each of those formats (e.g. with and without the timezone\\offset), the reader\\writer (and thus the serializer) uses what is available and uses\\assumes an ISO 8601 format to represent that.",
          "createdAt": "2019-10-01T20:18:36Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2019-10-01T20:18:36Z",
          "id": "MDEyOklzc3VlQ29tbWVudDUzNzIxMTE1OA=="
        },
        {
          "author": "layomia",
          "body": "@btecu the ISO 8601 profile is used by default in the serializer, e.g. 2019-07-26T16:59:57-05:00.\r\n\r\nFor deserializing, if the datetime offset is given as \"hh:mm\", a DateTime with `DateTimeKind.Local` is created. \"Z\" will give `DateTimeKind.Utc`. If no offset is given, then a DateTime with `DateTimeKind.Unspecified` is created.\r\nThe reverse mapping applies to serialization: writing a `DateTime` with `DateTimeKind.Local` will yield an ISO representation with an \"hh:mm\"-formatted offset, and so on.\r\n\r\nFor more on DateTime and DateTimeOffset support in System.Text.Json, and how you can implement custom parsing or formatting, see https://docs.microsoft.com/en-us/dotnet/standard/datetime/system-text-json-support.",
          "createdAt": "2019-11-08T23:43:58Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2020-02-08T16:54:28Z",
                "user": "dougludlow"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-08-17T14:52:03Z",
                "user": "corfor"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-09-02T17:51:23Z",
                "user": "alitoufighi"
              }
            ],
            "totalCount": 3,
            "endCursor": "Y3Vyc29yOnYyOpHOCrmPxA=="
          },
          "updatedAt": "2019-11-08T23:43:58Z",
          "id": "MDEyOklzc3VlQ29tbWVudDU1MjAzMzc2MQ=="
        },
        {
          "author": "mpashkovskiy",
          "body": "@btecu unfortunately the only way, I think, to have the similar option in `System.Text.Json` is to do:\r\n\r\n```csharp\r\nservices.AddControllers()\r\n    .AddJsonOptions(options =>\r\n     {\r\n         options.JsonSerializerOptions.Converters.Add(new DateTimeConverter());\r\n     });\r\n```\r\n\r\nand implement DateTimeConverter like that\r\n\r\n```csharp\r\npublic class DateTimeConverter : JsonConverter<DateTime>\r\n{\r\n    public override DateTime Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)\r\n    {\r\n        return DateTime.Parse(reader.GetString());\r\n    }\r\n\r\n    public override void Write(Utf8JsonWriter writer, DateTime value, JsonSerializerOptions options)\r\n    {\r\n         writer.WriteStringValue(value.ToUniversalTime().ToString(\"yyyy'-'MM'-'dd'T'HH':'mm':'ssZ\"));\r\n    }\r\n}\r\n```",
          "createdAt": "2020-05-31T10:33:23Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2020-06-16T05:34:58Z",
                "user": "lavkeshdwivedi"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2020-06-22T10:31:55Z",
                "user": "JinsPeter"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2020-06-28T13:47:03Z",
                "user": "tmarkovski"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2020-09-28T12:45:58Z",
                "user": "Kiril1512"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2020-10-01T08:03:23Z",
                "user": "madhuteja"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2020-11-16T13:36:28Z",
                "user": "t-dambacher"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2020-12-05T18:40:28Z",
                "user": "titobf"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2020-12-14T16:20:20Z",
                "user": "dalle"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-04-09T18:30:53Z",
                "user": "crispywong"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-06-15T08:56:26Z",
                "user": "erikmoren"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-07-27T12:10:51Z",
                "user": "michalprikryl"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-09-14T19:38:24Z",
                "user": "iayti"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-10-14T08:54:12Z",
                "user": "lucagalli0"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-11-04T11:24:40Z",
                "user": "bogomazdmitry"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-12-06T11:25:38Z",
                "user": "b-zurg"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-12-10T11:32:57Z",
                "user": "nkoudelia"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-12-23T22:05:29Z",
                "user": "jonas1307"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-05-23T00:57:51Z",
                "user": "BowserCole"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-06-01T16:17:50Z",
                "user": "MattDahEpic"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-06-22T14:21:40Z",
                "user": "ampr64"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-06-30T15:21:53Z",
                "user": "a11delavar"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-07-25T07:25:01Z",
                "user": "xwmr1207"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-09-29T14:49:04Z",
                "user": "prabh-62"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-12-10T20:32:42Z",
                "user": "Ch0bits"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-05-27T15:18:55Z",
                "user": "AverageCakeSlice"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-09-04T09:59:40Z",
                "user": "vernou"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-10-09T16:17:16Z",
                "user": "stevenbenitez"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-10-26T09:15:40Z",
                "user": "billhong-just"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-12-13T15:36:13Z",
                "user": "7amou3"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-01-04T09:32:11Z",
                "user": "AndrewMitev"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-03-29T00:36:37Z",
                "user": "hheexx"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-06-11T14:58:35Z",
                "user": "alekseypashko"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-06-21T17:17:32Z",
                "user": "ws-t-kist"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-11-06T23:03:08Z",
                "user": "OrbelB"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-01-28T17:58:01Z",
                "user": "AbdulrahmanHallak"
              }
            ],
            "totalCount": 35,
            "endCursor": "Y3Vyc29yOnYyOpHOC8kG6w=="
          },
          "updatedAt": "2020-05-31T10:33:23Z",
          "id": "MDEyOklzc3VlQ29tbWVudDYzNjQ1MjUxMQ=="
        },
        {
          "author": "dalle",
          "body": "This extends @mpashkovskiy solution and relies on the functionality in `Utf8JsonReader`/`Utf8JsonWriter` for actual parsing/formatting.\r\n\r\n```c#\r\npublic class DateTimeConverter : JsonConverter<DateTime>\r\n{\r\n    public override DateTime Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)\r\n    {\r\n        return reader.GetDateTime().ToUniversalTime();\r\n    }\r\n\r\n    public override void Write(Utf8JsonWriter writer, DateTime value, JsonSerializerOptions options)\r\n    {\r\n         writer.WriteStringValue(value.ToUniversalTime());\r\n    }\r\n}\r\n```",
          "createdAt": "2020-12-15T10:33:44Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-05-24T06:06:50Z",
                "user": "peef"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-06-15T08:56:25Z",
                "user": "erikmoren"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-06-16T22:42:05Z",
                "user": "puscasu-ion-daniel"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-09-21T08:17:28Z",
                "user": "killerwife"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-10-26T13:37:43Z",
                "user": "eiriktsarpalis"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-12-06T11:25:35Z",
                "user": "b-zurg"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-12-10T11:33:00Z",
                "user": "nkoudelia"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-12-10T14:39:30Z",
                "user": "n-l-vasilyev"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-12-13T15:09:25Z",
                "user": "davidhenley"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-03-16T13:18:47Z",
                "user": "anasboumali"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-05-23T00:57:52Z",
                "user": "BowserCole"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-06-16T18:03:57Z",
                "user": "jmbryan4"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-06-30T15:22:14Z",
                "user": "a11delavar"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-08-10T05:13:29Z",
                "user": "PavelKalsin"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-09-07T07:49:50Z",
                "user": "eithe"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-09-29T14:49:09Z",
                "user": "prabh-62"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-10-17T20:38:05Z",
                "user": "enioluwas"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-10-25T12:24:42Z",
                "user": "activist"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-11-02T07:58:19Z",
                "user": "tillwolff"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-11-15T09:05:11Z",
                "user": "tinohager"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-12-10T20:32:55Z",
                "user": "Ch0bits"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-01-30T09:33:08Z",
                "user": "fdsmax"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-04-19T08:50:24Z",
                "user": "pasestars"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-04-28T11:53:13Z",
                "user": "aliegeni"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-05-27T15:18:44Z",
                "user": "AverageCakeSlice"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-09-04T09:59:42Z",
                "user": "vernou"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-12-07T18:58:18Z",
                "user": "davidruhmann"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-01-04T09:31:59Z",
                "user": "AndrewMitev"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-04-28T12:20:26Z",
                "user": "LucaZiegler"
              }
            ],
            "totalCount": 29,
            "endCursor": "Y3Vyc29yOnYyOpHOC8kG4Q=="
          },
          "updatedAt": "2020-12-15T10:33:44Z",
          "id": "MDEyOklzc3VlQ29tbWVudDc0NTIwMTI3MQ=="
        },
        {
          "author": "danilobreda",
          "body": "This solution **should come natively** so that we have the **best possible performance**. JsonConverter creates problems when poorly implemented.\r\nSometimes we can't control which Kind of datetime because of its origin being an ORM for example ... needing a .ToUniversalTime() just to satisfy json deserealization by adding a +00:00 or \"Z\"\r\nThis solution should be reviewed. :(",
          "createdAt": "2021-02-02T18:45:28Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-02-02T21:26:26Z",
                "user": "titobf"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-02-04T08:40:58Z",
                "user": "BobbyTable"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-02-24T21:41:01Z",
                "user": "davemanton"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-03-20T13:27:05Z",
                "user": "VadimOvchinnikov"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-04-15T13:13:13Z",
                "user": "andrea-cassioli-maersk"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-04-26T07:00:29Z",
                "user": "JustASquid"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-05-06T17:31:14Z",
                "user": "danilobreda"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-05-30T06:36:57Z",
                "user": "ptncafe"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-06-10T12:23:03Z",
                "user": "johankvint"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-06-23T04:23:04Z",
                "user": "cheema-corellian"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-07-12T06:20:40Z",
                "user": "hf-kklein"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-07-16T12:20:00Z",
                "user": "abuzar-hasanov-front"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-08-21T21:53:44Z",
                "user": "rodion-m"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-08-23T15:56:18Z",
                "user": "remotenode"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-09-29T19:46:51Z",
                "user": "seekingtheoptimal"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-10-05T05:29:42Z",
                "user": "andrewboyd-envirosuite"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-11-21T12:14:10Z",
                "user": "alx-ppv"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-01-05T07:28:18Z",
                "user": "wtlgo"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-02-10T01:34:00Z",
                "user": "tmlima"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-03-09T00:06:33Z",
                "user": "bscheurm"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-06-16T18:01:24Z",
                "user": "jmbryan4"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-09-02T17:51:50Z",
                "user": "alitoufighi"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-09-16T16:48:45Z",
                "user": "enioluwas"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-02-09T11:44:13Z",
                "user": "adamjez"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-04-19T08:51:35Z",
                "user": "pasestars"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-05-27T15:19:12Z",
                "user": "AverageCakeSlice"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-06-14T11:25:46Z",
                "user": "ionut-gheorghe"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-06-16T03:33:30Z",
                "user": "josephcooney"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-08-02T21:08:53Z",
                "user": "graves-k"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-10-26T09:16:20Z",
                "user": "billhong-just"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-10-26T12:40:11Z",
                "user": "emilpalsson"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-11-07T15:55:46Z",
                "user": "thepirat000"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-12-07T18:47:46Z",
                "user": "davidruhmann"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-04-26T11:33:54Z",
                "user": "ignj"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-07-21T09:04:19Z",
                "user": "mohamed-ferg-cko"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-09-26T13:36:58Z",
                "user": "sharpjs"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-10-28T08:26:51Z",
                "user": "bo4arov"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-11-05T15:37:49Z",
                "user": "gdmarconetto"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-01-31T20:56:55Z",
                "user": "reinaldocoelho"
              }
            ],
            "totalCount": 39,
            "endCursor": "Y3Vyc29yOnYyOpHOC6KdZw=="
          },
          "updatedAt": "2021-06-29T17:16:34Z",
          "id": "MDEyOklzc3VlQ29tbWVudDc3MTg4MjA3Nw=="
        },
        {
          "author": "amay5027",
          "body": "Just adding to @mpashkovskiy solution, you could use the SpecifyKind method in .Net to do this as follows:\r\n\r\n \r\n\r\n        public override DateTime Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)\r\n        {\r\n            return DateTime.Parse(reader.GetString());\r\n        }\r\n\r\n        public override void Write(Utf8JsonWriter writer, DateTime value, JsonSerializerOptions options)\r\n        {\r\n            writer.WriteStringValue(DateTime.SpecifyKind(value, DateTimeKind.Utc));\r\n        }\r\n    ",
          "createdAt": "2021-05-06T08:20:15Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-06-25T10:39:48Z",
                "user": "ysbakker"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-08-17T16:22:25Z",
                "user": "m4ss1m0g"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-08-21T21:55:47Z",
                "user": "rodion-m"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-09-13T19:30:06Z",
                "user": "NCBloodhound"
              },
              {
                "content": "CONFUSED",
                "createdAt": "2021-10-26T13:35:37Z",
                "user": "eiriktsarpalis"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-11-26T02:30:43Z",
                "user": "MaximBalaganskiy"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-12-05T01:19:43Z",
                "user": "logicbells"
              },
              {
                "content": "CONFUSED",
                "createdAt": "2021-12-24T18:11:01Z",
                "user": "devigo"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-05-23T00:57:57Z",
                "user": "BowserCole"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-02-16T22:36:17Z",
                "user": "tihomir-kit"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-04-19T08:58:15Z",
                "user": "pasestars"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-09-06T21:53:21Z",
                "user": "kcondic"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-10-26T13:27:39Z",
                "user": "emilpalsson"
              }
            ],
            "totalCount": 13,
            "endCursor": "Y3Vyc29yOnYyOpHODLBfsA=="
          },
          "updatedAt": "2021-05-06T08:21:04Z",
          "id": "MDEyOklzc3VlQ29tbWVudDgzMzMzMTUwMQ=="
        },
        {
          "author": "maulik-modi",
          "body": "@davidfowl and @JamesNK , what do you guys recommend here? We are building up new project using System.Text.json, want to ensure we use the right guidance and get benefit from system.text.json.",
          "createdAt": "2021-06-18T16:15:18Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-06-18T16:16:14Z",
          "id": "MDEyOklzc3VlQ29tbWVudDg2NDE0NTE5OA=="
        },
        {
          "author": "ysbakker",
          "body": "> Just adding to @mpashkovskiy solution, you could use the SpecifyKind method in .Net to do this as follows:\r\n> \r\n> ```\r\n>     public override DateTime Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)\r\n>     {\r\n>         return DateTime.Parse(reader.GetString());\r\n>     }\r\n> \r\n>     public override void Write(Utf8JsonWriter writer, DateTime value, JsonSerializerOptions options)\r\n>     {\r\n>         writer.WriteStringValue(DateTime.SpecifyKind(value, DateTimeKind.Utc));\r\n>     }\r\n> ```\r\n\r\nExactly what I was looking for! I save all DateTime as UTC in the database because I have different timezones in development and production. I then parse the UTC time to local time in the client, but by default the json serializer didn't append a \"Z\" so I had to do some ugly string concatenation to make it work. This solves that issue by specifying that the date is *already* in UTC and will therefore return a nice ISO string that javascript also understands. The issue with using `DateTime.ToUniversalTime()` in my case is that it assumes I save the timestamps in my local timezone.",
          "createdAt": "2021-06-25T10:47:44Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-09-29T20:12:49Z",
                "user": "seekingtheoptimal"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-09-07T06:09:24Z",
                "user": "adnan-kamili"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-09-07T08:16:15Z",
                "user": "eithe"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-01-12T12:05:09Z",
                "user": "VanDenHendeSimon"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-02-15T14:07:09Z",
                "user": "titouancreach"
              }
            ],
            "totalCount": 5,
            "endCursor": "Y3Vyc29yOnYyOpHOC2HdZg=="
          },
          "updatedAt": "2021-06-25T10:47:44Z",
          "id": "MDEyOklzc3VlQ29tbWVudDg2ODQxMTc4Mw=="
        },
        {
          "author": "maulik-modi",
          "body": "@ysbakker , javascript is not sending string ending with \"Z\"?",
          "createdAt": "2021-06-25T11:11:41Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-06-25T11:11:41Z",
          "id": "MDEyOklzc3VlQ29tbWVudDg2ODQyMzY5NQ=="
        },
        {
          "author": "ysbakker",
          "body": "> @ysbakker , javascript is not sending string ending with \"Z\"?\r\n\r\n[`Date.prototype.toISOString()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString) creates an ISO-compliant string, so this includes a \"Z\". You can try `(new Date()).toISOString()`, it should automatically convert to UTC too.",
          "createdAt": "2021-06-25T11:20:38Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-06-25T11:20:38Z",
          "id": "MDEyOklzc3VlQ29tbWVudDg2ODQyODMyNg=="
        },
        {
          "author": "xenod",
          "body": "Is there still no built in feature for forcing deserializer to add 'Z' to the end? I also need this feature.\r\n\r\nWe used this in Json.NET:\r\n\r\n`jsonSerializerSettings.DateTimeZoneHandling = DateTimeZoneHandling.Utc; //Make sure that Json dates are formatted with a 'Z' on the end!\r\njsonSerializerSettings.DateFormatHandling = DateFormatHandling.IsoDateFormat;`",
          "createdAt": "2021-06-29T08:04:57Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-11-21T18:57:13Z",
                "user": "tihomir-kit"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-03-12T17:34:07Z",
                "user": "dfaivre"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-07-19T10:20:53Z",
                "user": "angularsen"
              }
            ],
            "totalCount": 3,
            "endCursor": "Y3Vyc29yOnYyOpHODqpJhQ=="
          },
          "updatedAt": "2021-06-29T08:05:18Z",
          "id": "MDEyOklzc3VlQ29tbWVudDg3MDM3MzcxMw=="
        },
        {
          "author": "backnotprop",
          "body": ">   public override DateTime Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)\r\n>     {\r\n>         return DateTime.Parse(reader.GetString());\r\n>     }\r\n> \r\n>     public override void Write(Utf8JsonWriter writer, DateTime value, JsonSerializerOptions options)\r\n>     {\r\n>         writer.WriteStringValue(DateTime.SpecifyKind(value, DateTimeKind.Utc));\r\n>     }\r\n\r\nSame, except it was @dalle's solution that worked for me. This has been a world of pain for a globally distributed system. ",
          "createdAt": "2021-08-25T04:00:21Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-08-25T04:00:21Z",
          "id": "IC_kwDODI9FZc4187DK"
        },
        {
          "author": "maulik-modi",
          "body": "@backnotprop , @dalle , @amay5027 and @davidfowl ,\r\n\r\nWe decided not to use JsonConverter<DateTime> and instead pass DateTime as string for two reasons:\r\n1. We want to provide friendly message in case date time format is incorrect, we expect ISO8601 format for all incoming datetime inputs\r\n2.   return DateTime.Parse(reader.GetString()); provides datetime in local timezone, we instead store UTC DateTime\r\n\r\nOur solution was to wrap in an extension method:\r\n\r\n```\r\nstatic class DateTimeExtensions\r\n{\r\nconst string ISO8601DateTimeSecondsFormat = \"yyyy-MM-ddTHH:mm:ssZ\";\r\npublic static DateTime? ToDateTime(this string eventDateTime)\r\n{\r\nif(DateTime.TryParseExact(eventDateTime, ISO8601DateTimeSecondsFormat,\r\n                                             CultureInfo.InvariantCulture,\r\n                                             DateTimeStyles.RoundtripKind,\r\n                                             out DateTime dateTimeWithSeconds))\r\n  return dateTimeWithSeconds;\r\nelse\r\n return null;\r\n}\r\n```\r\n\r\nYour thoughts?",
          "createdAt": "2021-08-25T05:18:37Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-08-25T05:19:18Z",
          "id": "IC_kwDODI9FZc419B-c"
        },
        {
          "author": "killerwife",
          "body": "Also stumbled upon this issue, since every other system expects and ISO string in json. This does sound like an unnecessary hack.",
          "createdAt": "2021-09-21T08:18:21Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-09-21T08:18:21Z",
          "id": "IC_kwDODI9FZc43D0sM"
        },
        {
          "author": "maulik-modi",
          "body": "@rbhanda , Do we have an option to set this globally like Json.NET in .NET 6 ? Can you add it to backlog of .NET 7 otherwise?\r\n\r\n```\r\nJsonConvert.DefaultSettings = () => new JsonSerializerSettings {\r\n    DateTimeZoneHandling = DateTimeZoneHandling.Utc\r\n};\r\n```\r\n",
          "createdAt": "2021-09-21T08:48:26Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-10-26T14:11:12Z",
                "user": "yotkoKanchev"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-11-08T11:17:40Z",
                "user": "Karthigaiselvi-SF2856"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-02-02T15:51:22Z",
                "user": "mickelsonmichael"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-02-25T11:50:15Z",
                "user": "WojciechNagorski"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-03-08T15:55:01Z",
                "user": "necipsunmaz"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-05-22T23:48:37Z",
                "user": "BowserCole"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-07-08T14:00:51Z",
                "user": "vladboss61"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-07-10T11:58:32Z",
                "user": "pcontrerasp"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-07-20T08:32:40Z",
                "user": "NickyNest"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-10-04T12:50:29Z",
                "user": "HavermansStef"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-01-31T12:07:28Z",
                "user": "AlexandrSitdikov"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-07-19T10:47:36Z",
                "user": "angularsen"
              }
            ],
            "totalCount": 12,
            "endCursor": "Y3Vyc29yOnYyOpHODqpUqA=="
          },
          "updatedAt": "2021-09-21T08:48:26Z",
          "id": "IC_kwDODI9FZc43D54i"
        },
        {
          "author": "seekingtheoptimal",
          "body": "In almost every typical client-server web system the server uses and stores dates in UTC (default behavior for SQL DateTime mapping with EF Core for example), while browsers should show the local timezone as users are from all around the internet. Having this feature in a similar fashion to json.net - even if not making it the default behavior to break things - would just make a lot of sense.",
          "createdAt": "2021-09-29T19:12:19Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-08-02T21:09:03Z",
                "user": "graves-k"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-09-04T10:03:34Z",
                "user": "vernou"
              }
            ],
            "totalCount": 2,
            "endCursor": "Y3Vyc29yOnYyOpHODFqPyA=="
          },
          "updatedAt": "2021-09-29T19:12:19Z",
          "id": "IC_kwDODI9FZc43dc18"
        },
        {
          "author": "eiriktsarpalis",
          "body": "@amay5027 Note that the `DateTime.SpecifyKind` method does not convert the date to the new kind, it will simply swap the `DateTimeKind` and keep the same ticks value, which is not what most users would expect (it's certainly not how `DateTimeZoneHandling` works in Json.NET). I would recommend using the workaround as proposed in https://github.com/dotnet/runtime/issues/1566#issuecomment-745201271 instead.\r\n\r\n> This solution should come natively so that we have the best possible performance. JsonConverter creates problems when poorly implemented.\r\n\r\n@danilobreda what are the performance issues you are identified with the proposed workarounds? It would seem to me that the solution proposed in https://github.com/dotnet/runtime/issues/1566#issuecomment-745201271 would be as fast as a native feature.\r\n\r\n> Also stumbled upon this issue, since every other system expects and ISO string in json. This does sound like an unnecessary hack.\r\n\r\n@killerwife the default DateTime serialization uses ISO 8601. I believe the ask here is whether we should introduce a feature that automatically converts the TZ offsets on the serialization layer.",
          "createdAt": "2021-10-26T13:44:28Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-10-26T13:44:28Z",
          "id": "IC_kwDODI9FZc44va8w"
        },
        {
          "author": "danilobreda",
          "body": "@eiriktsarpalis I won't know what the performance issues are, and that's the idea. Using a solution that comes natively doesn't bring that kind of questioning.\r\nThis was already solved by **newtonsoft**, **a configuration should exist** for which way the conversion should take place. **For UTC Always, or use Kind of property (default).** https://github.com/dotnet/runtime/issues/1566#issuecomment-923770402",
          "createdAt": "2021-10-26T22:32:28Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-01-30T14:57:46Z",
                "user": "gldfdp"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOEEnjyQ=="
          },
          "updatedAt": "2021-10-26T22:36:20Z",
          "id": "IC_kwDODI9FZc44xCUp"
        },
        {
          "author": "eiriktsarpalis",
          "body": "> I won't know what the performance issues are, and that's the idea. Using a solution that comes natively doesn't bring that kind of questioning.\r\n\r\nI personally wouldn't agree with this line of thinking. Ultimately not every requested feature will find its way as an OOTB feature (or it may take multiple releases before it does). As such I wholeheartedly encourage building successful third-party extension libraries (there are quite a few quality ones already out there). As a maintainer I would prioritize addressing extensibility concerns in the core infrastructure over complete feature parity with other offerings.\r\n\r\nBottom line in this case, I would argue that the custom converter [proposed here](https://github.com/dotnet/runtime/issues/1566#issuecomment-745201271) as a workaround would be just as fast (and likely faster) than a configurable built-in converter.\r\n\r\n> This was already solved by newtonsoft, a configuration should exist for which way the conversion should take place. For UTC Always, or use Kind of property (default). \r\n\r\nI believe that the Newtonsoft offering might simply reflect the fact that earlier versions of the library didn't use ISO 8601 when serializing dates. This has been the only supported format in STJ from day 1, and as such any TZ information is always accurately represented in the underlying JSON.\r\n\r\nI guess I'm trying to better understand the motivating use cases, and I can only think of the following:\r\n\r\n1. The application uses `DateTime` instead of `DateTimeOffset` when representing dates, resulting in bugs when comparing dates of different kinds.\r\n2. The application uses `DateTime.Now` instead of `DateTime.UtcNow` and the host TZ itself is not UTC, resulting in local TZ offsets leaking in server responses.\r\n\r\nAm I forgetting something?",
          "createdAt": "2021-10-27T13:52:03Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-10-27T13:52:03Z",
          "id": "IC_kwDODI9FZc44zOkm"
        },
        {
          "author": "danilobreda",
          "body": "@eiriktsarpalis Applications that used JSON.NET with `DateTimeZoneHandling = DateTimeZoneHandling.Utc` and migrated to System.Text.Json.",
          "createdAt": "2021-10-27T19:23:31Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-12-13T15:07:17Z",
                "user": "davidhenley"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-02-25T11:52:10Z",
                "user": "WojciechNagorski"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-06-24T13:24:28Z",
                "user": "joakimsjo"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-06-30T15:24:15Z",
                "user": "a11delavar"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-07-10T11:59:19Z",
                "user": "pcontrerasp"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-09-07T07:28:47Z",
                "user": "eithe"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-09-15T18:53:17Z",
                "user": "MarkLeMerise"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-09-21T13:58:26Z",
                "user": "DLN-India"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-10-04T12:50:44Z",
                "user": "HavermansStef"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-08-20T22:34:36Z",
                "user": "L-E-son"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-09-11T17:46:14Z",
                "user": "justintoth"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-12-05T20:00:47Z",
                "user": "WalissonPires"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-07-19T10:47:57Z",
                "user": "angularsen"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-10-22T09:49:31Z",
                "user": "norfas"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-04-30T19:25:40Z",
                "user": "dimitri-dev"
              }
            ],
            "totalCount": 15,
            "endCursor": "Y3Vyc29yOnYyOpHOEQWU7w=="
          },
          "updatedAt": "2021-10-27T19:23:31Z",
          "id": "IC_kwDODI9FZc440Unr"
        },
        {
          "author": "AndiRudi",
          "body": "This is a really annoying thing when you want to upgrade to .net 6 because the default de-serialiser of a view model will add the timezone given by the frontend. If you forward this to a Postgres database you will get an error like `Cannot write DateTimeOffset with Offset=02:00:00 to PostgreSQL type ...`. Or am I missing something?",
          "createdAt": "2022-04-13T06:43:53Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-04-13T06:43:53Z",
          "id": "IC_kwDODI9FZc5BbFN_"
        },
        {
          "author": "eithe",
          "body": "Edit: **Please do not use this, see replies from @eiriktsarpalis and @OskarKlintrot below.**\r\n\r\nFor anyone who uses `DateTime?`, here is a nullable variant of @dalle's solution:\r\n\r\n```c#\r\npublic class NullableDateTimeConverter : JsonConverter<DateTime?>\r\n{\r\n    public override DateTime? Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)\r\n    {\r\n        return reader.TryGetDateTime(out var value) ? value.ToUniversalTime() : null;\r\n    }\r\n\r\n    public override void Write(Utf8JsonWriter writer, DateTime? value, JsonSerializerOptions options)\r\n    {\r\n        if (value.HasValue)\r\n        {\r\n            writer.WriteStringValue(value.Value.ToUniversalTime());\r\n        }\r\n        else\r\n        {\r\n            writer.WriteNullValue();\r\n        }\r\n    }\r\n}\r\n```",
          "createdAt": "2022-09-07T08:01:20Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "CONFUSED",
                "createdAt": "2022-09-07T09:01:55Z",
                "user": "eiriktsarpalis"
              },
              {
                "content": "CONFUSED",
                "createdAt": "2022-09-07T09:21:19Z",
                "user": "OskarKlintrot"
              },
              {
                "content": "CONFUSED",
                "createdAt": "2023-06-05T23:25:21Z",
                "user": "douglasg14b"
              },
              {
                "content": "CONFUSED",
                "createdAt": "2024-11-08T14:58:48Z",
                "user": "luckyycode"
              }
            ],
            "totalCount": 4,
            "endCursor": "Y3Vyc29yOnYyOpHOD6CJtw=="
          },
          "updatedAt": "2022-09-07T09:32:34Z",
          "id": "IC_kwDODI9FZc5J2lls"
        },
        {
          "author": "eiriktsarpalis",
          "body": "> For anyone who uses `DateTime?`\r\n\r\nWriting dedicated converters for nullable types is not recommended. Authoring a custom converter for the underlying struct should suffice, the generic nullable converter will compose with that.",
          "createdAt": "2022-09-07T09:01:45Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-09-07T09:25:13Z",
                "user": "OskarKlintrot"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-09-07T09:48:03Z",
                "user": "eithe"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-09-09T18:06:26Z",
                "user": "udlose"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-11-18T17:16:30Z",
                "user": "paulroho-orf"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-04-30T19:25:23Z",
                "user": "dimitri-dev"
              }
            ],
            "totalCount": 5,
            "endCursor": "Y3Vyc29yOnYyOpHOEQWUyg=="
          },
          "updatedAt": "2022-09-07T09:01:45Z",
          "id": "IC_kwDODI9FZc5J21ie"
        },
        {
          "author": "OskarKlintrot",
          "body": "And you can access the other converters from inside your converter (to avoid doing the convertion yourself if there's already a perfectly good converter at your disposal once you done with type checks or whatever you want to do):\r\n```\r\noptions.GetConverter(typeof(DateTime))\r\n```",
          "createdAt": "2022-09-07T09:25:06Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-09-07T09:32:57Z",
                "user": "eithe"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOCryzIQ=="
          },
          "updatedAt": "2022-09-07T09:25:06Z",
          "id": "IC_kwDODI9FZc5J279X"
        },
        {
          "author": "eithe",
          "body": "Thanks @eiriktsarpalis and @OskarKlintrot, will edit.",
          "createdAt": "2022-09-07T09:31:50Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-09-07T09:31:50Z",
          "id": "IC_kwDODI9FZc5J29vx"
        },
        {
          "author": "HarelM",
          "body": "Would be great to have some build it converter in .Net for these kind of scenarios.\r\nI'm trying to migrate my project from Newtonsoft.JSON to system.text.json and a lot of places are failing, some related to this, some related to other issues.\r\nI don't want to write a generic datetime converter that can parse a date well.\r\nI have an external API that is written in python that has a date of the format: `2021-08-30 23:26:46` for example. Previously it just worked.\r\nWhen I migrated to STJ this started failing. While I get the performance advantages of assuming everything is ISO, I still think there should be an easy way to say: \"hey, converter, this date isn't well formatted, but let's make sure you are able to parse it\" without writing a converter that was already written hundreds of times...",
          "createdAt": "2023-01-29T19:22:38Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-01-01T11:28:45Z",
                "user": "dmitry-cello"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-03-12T17:35:19Z",
                "user": "dfaivre"
              }
            ],
            "totalCount": 2,
            "endCursor": "Y3Vyc29yOnYyOpHODaTQCA=="
          },
          "updatedAt": "2023-01-29T19:22:38Z",
          "id": "IC_kwDODI9FZc5T6IiX"
        },
        {
          "author": "Astral100",
          "body": "If the goal is to get pure local time (by stripping timezone part from the datetime), then one solution I found is to change the contract of the received object properties to `DateTimeOffset` as described here (in **EDIT2** part): https://stackoverflow.com/questions/78450474/how-to-strip-off-timezone-part-from-datetime-to-leave-only-local-datetime-part/78450521?noredirect=1#comment138306952_78450521\r\n\r\nAnd then you could use `.DateTime` on the `DateTimeOffset` property.",
          "createdAt": "2024-05-09T07:11:17Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-05-09T07:11:17Z",
          "id": "IC_kwDODI9FZc59S009"
        },
        {
          "author": "jgador",
          "body": "Hi @dalle \n\nThank you for the solution above! It's almost there, but I noticed one subtle issue. When calling `reader.GetDateTime()`, the `DateTimeKind` is set to `Unspecified` if the input doesn't contain time zone information. The code converts the date time to UTC even though the original time zone is unknown. What we want is to treat the time as UTC when time zone information is present. If the `DateTimeKind` is not provided, we assume the value is already in UTC.\n\nHere's my proposed solution to handle this correctly:\n\n```c#\npublic override DateTime Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)\n{\n    var date = reader.GetDateTime();\n\n    return date.Kind == DateTimeKind.Utc\n        ? date\n        : DateTime.SpecifyKind(date, DateTimeKind.Utc);\n}\n``` \n",
          "createdAt": "2024-10-12T19:11:03Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-10-12T19:11:03Z",
          "id": "IC_kwDODI9FZc6PkU5d"
        }
      ],
      "totalCount": 28,
      "endCursor": "Y3Vyc29yOnYyOpHOSdvb8Q=="
    },
    "url": "https://github.com/dotnet/runtime/issues/1566",
    "title": "System.Text.Json default DateTimeZoneHandling"
  },
  {
    "author": "gary-holland",
    "labels": [
      "api-suggestion",
      "area-System.Text.Json",
      "partner-impact"
    ],
    "createdAt": "2019-10-04T06:09:26Z",
    "body": "Hi,  \r\n\r\nI'd like to request JsonPath support for querying the JsonDocument/JsonElement classes.  JsonPath provides similar capability to XPath (and even Sql) in that it allows queries to be performed against Json documents.  This currently represents a major gap for us shifting from Newtonsoft to system.text.json, as we provide JsonPath values as an input parameter to a data load process which can't be worked around via code.\r\n\r\nThe JsonPath syntax is described [here](https://goessner.net/articles/JsonPath/).\r\n\r\nThe equivalent functionality in the Newtonsoft library is:\r\n\r\n```csharp\r\nvar jsonPath = \"$.my.path\";\r\nvar json = JToken.Parse(jsonString);\r\nvar token = json.SelectToken(jsonPath);\r\n```\r\n\r\nThe following proposed syntax would work well in the JsonDocument structure:\r\n\r\n```csharp\r\nvar jsonPath = \"$.my.path\";\r\nvar jsonDoc = JsonDocument.Parse(json);\r\nvar element = jsonDoc.SelectElement(jsonPath); //returns JsonElement\r\nvar elements = jsonDoc.SelectElements(jsonPath); //returns JsonElement.ArrayEnumerator\r\n```\r\n\r\nThanks.",
    "number": 31068,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "THUMBS_UP",
          "createdAt": "2019-10-23T23:31:20Z",
          "user": "dazinator"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2019-11-11T17:33:45Z",
          "user": "JohnYoungers"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2019-11-20T21:20:21Z",
          "user": "dkmiller"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2019-12-05T06:52:18Z",
          "user": "LeaFrock"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2019-12-23T14:35:28Z",
          "user": "rrharvey"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2020-01-03T11:58:41Z",
          "user": "andrueastman"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2020-01-10T14:44:37Z",
          "user": "vlad2135"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2020-01-24T18:51:34Z",
          "user": "acolombi"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2020-01-28T10:45:28Z",
          "user": "george-chakhidze"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2020-02-01T07:04:29Z",
          "user": "KyleGobel"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2020-02-26T17:39:15Z",
          "user": "marcogomex"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2020-03-05T01:07:26Z",
          "user": "snblackout"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2020-03-09T13:56:08Z",
          "user": "BertrandJU"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2020-03-10T13:04:18Z",
          "user": "martinoss"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2020-03-15T11:30:34Z",
          "user": "se"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2020-03-23T08:36:41Z",
          "user": "cympatic"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2020-03-25T14:13:09Z",
          "user": "blankensteiner"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2020-03-29T16:59:47Z",
          "user": "azambrano"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2020-04-08T01:15:28Z",
          "user": "jasjae"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2020-04-14T15:54:12Z",
          "user": "paladin80"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2020-04-15T17:24:40Z",
          "user": "Licantrop0"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2020-05-19T08:13:13Z",
          "user": "steffen-wilke"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2020-05-19T08:14:59Z",
          "user": "BrightLight"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2020-05-21T18:40:16Z",
          "user": "Ansssss"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2020-05-25T22:41:57Z",
          "user": "richardwan"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2020-05-26T23:53:12Z",
          "user": "gitfool"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2020-05-28T18:09:52Z",
          "user": "zmhh"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2020-05-29T08:36:22Z",
          "user": "Laiteux"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2020-06-05T14:17:43Z",
          "user": "onionhammer"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2020-06-08T02:25:14Z",
          "user": "0xhelium"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2020-06-09T16:20:06Z",
          "user": "maririos"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2020-06-15T18:00:24Z",
          "user": "diegosps"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2020-06-16T16:50:36Z",
          "user": "jstafford5380"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2020-06-20T16:33:23Z",
          "user": "CePur"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2020-06-30T13:14:51Z",
          "user": "klapstoelpiloot"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2020-07-01T16:28:02Z",
          "user": "rcollina"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2020-07-06T10:00:22Z",
          "user": "fluttdev"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2020-07-06T10:28:30Z",
          "user": "maksimenko-stanislav"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2020-07-11T18:30:19Z",
          "user": "MikeChristensen"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2020-07-14T09:41:27Z",
          "user": "jimmymasaru"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2020-07-20T21:28:05Z",
          "user": "sliekens"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2020-07-23T15:00:37Z",
          "user": "tastimur"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2020-08-18T12:17:06Z",
          "user": "Arithmomaniac"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2020-08-21T15:25:30Z",
          "user": "rubo"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2020-08-26T09:18:37Z",
          "user": "loraderon"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2020-09-01T22:03:58Z",
          "user": "corredor28"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2020-09-08T13:50:33Z",
          "user": "TAGC"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2020-09-16T07:54:27Z",
          "user": "euyuil"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2020-09-21T03:54:09Z",
          "user": "dontpanic92"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2020-09-22T09:35:01Z",
          "user": "YohDeadfall"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2020-10-05T01:04:02Z",
          "user": "meziantou"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2020-10-16T23:38:49Z",
          "user": "NeoXtreem"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2020-10-25T21:17:25Z",
          "user": "MBurtsev"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2020-11-13T04:19:11Z",
          "user": "chertpong"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2020-11-17T16:51:28Z",
          "user": "maxreb"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2020-11-19T17:28:28Z",
          "user": "GF-Huang"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2020-11-19T18:02:03Z",
          "user": "winzig"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2020-11-25T07:35:12Z",
          "user": "msallin"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2020-11-25T12:39:08Z",
          "user": "WorldIsM"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2020-12-22T10:31:52Z",
          "user": "mg90707"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2020-12-24T00:17:44Z",
          "user": "morquan"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2020-12-28T19:53:50Z",
          "user": "CodyALohse"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-01-06T18:52:28Z",
          "user": "philfontaine"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-01-08T05:20:04Z",
          "user": "sanjaydebnath"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-01-11T17:02:09Z",
          "user": "hacst"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-01-21T11:04:56Z",
          "user": "Eulinky"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-01-28T11:16:18Z",
          "user": "shpikat"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-02-04T15:10:35Z",
          "user": "ZukkyBaig"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-02-10T15:11:53Z",
          "user": "musakasim"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-02-13T20:40:15Z",
          "user": "tzographos"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-02-22T16:26:44Z",
          "user": "imre-turi-cko"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-02-28T10:12:58Z",
          "user": "andrey-noskov"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-03-17T14:25:00Z",
          "user": "a510"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-03-31T17:50:52Z",
          "user": "dwerner80"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-04-13T16:58:50Z",
          "user": "suchoss"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-04-21T03:49:28Z",
          "user": "ProTip"
        },
        {
          "content": "ROCKET",
          "createdAt": "2021-04-23T11:31:11Z",
          "user": "mr5z"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-04-23T22:18:51Z",
          "user": "gdperkins"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-04-29T09:36:44Z",
          "user": "MartyIX"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-05-01T16:34:32Z",
          "user": "realityexists"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-05-04T22:48:47Z",
          "user": "tpaananen"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-05-09T23:08:21Z",
          "user": "ovpoddar"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-05-13T19:57:14Z",
          "user": "superstator"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-05-20T15:48:14Z",
          "user": "Euan-McVie"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-05-31T03:55:51Z",
          "user": "LGinC"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-06-15T17:10:26Z",
          "user": "FlorianLeChat"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-06-16T07:10:56Z",
          "user": "hectortosa"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-06-16T07:32:39Z",
          "user": "james-r-parker"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-06-21T21:41:56Z",
          "user": "juharris"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-07-05T06:42:51Z",
          "user": "hell-racer"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-07-07T07:26:54Z",
          "user": "snosrap"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-07-09T11:00:40Z",
          "user": "SemyonL"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-07-10T15:12:15Z",
          "user": "WeihanLi"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-07-15T14:06:54Z",
          "user": "kevbite"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-07-20T20:48:51Z",
          "user": "splitt3r"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-07-24T08:35:57Z",
          "user": "chadsowald"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-07-31T08:36:31Z",
          "user": "idzmitry"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-08-12T10:11:26Z",
          "user": "dhhoang"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-08-12T12:20:29Z",
          "user": "AlexBroitman"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-08-16T21:15:47Z",
          "user": "Gladskih"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-08-18T09:11:23Z",
          "user": "andrewafanasiev"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-08-23T20:17:04Z",
          "user": "DanielPeinhopf"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-08-27T10:52:24Z",
          "user": "jhoek"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-08-31T20:36:22Z",
          "user": "altso"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-09-08T09:37:50Z",
          "user": "karoly-ozsvart-betsson"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-09-13T22:24:07Z",
          "user": "AnthonyTongLee"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-09-16T19:07:22Z",
          "user": "kronic"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-10-05T12:45:29Z",
          "user": "alexeyshockov"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-10-10T09:30:55Z",
          "user": "AmrAlSayed0"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-10-11T13:23:15Z",
          "user": "Kontekst"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-10-27T12:13:02Z",
          "user": "delasource"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-10-30T10:52:37Z",
          "user": "Meyhem"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-11-03T14:57:48Z",
          "user": "trickpatty"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-11-06T12:51:17Z",
          "user": "ThomasOpiolka"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-11-09T21:43:06Z",
          "user": "53hornet"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-11-16T17:56:09Z",
          "user": "paolofulgoni"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-11-18T11:37:43Z",
          "user": "RWander"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-11-24T17:58:35Z",
          "user": "manuelfuchs"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-11-26T09:49:56Z",
          "user": "ackh"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-11-26T09:51:59Z",
          "user": "BrunoBieri"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-11-30T15:39:40Z",
          "user": "TheSylence"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-12-03T10:22:53Z",
          "user": "michaldobrodenka"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-12-14T22:32:44Z",
          "user": "HalidCisse"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-12-23T11:27:20Z",
          "user": "Thaina"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-01-04T06:52:38Z",
          "user": "IvanJosipovic"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-01-09T09:08:14Z",
          "user": "0xfeeddeadbeef"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-01-13T20:59:30Z",
          "user": "zorgoz"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-01-15T19:35:04Z",
          "user": "brandonmpetty"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-01-16T18:22:31Z",
          "user": "AcidJunkie303"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-01-28T12:04:42Z",
          "user": "MarioGruda"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-02-02T20:51:27Z",
          "user": "KriseevM"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-02-09T17:23:42Z",
          "user": "mguinness"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-02-09T18:49:48Z",
          "user": "takerukoushirou"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-02-10T05:16:18Z",
          "user": "viktor-svub"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-02-13T17:43:37Z",
          "user": "MeirMalka"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-02-17T12:13:06Z",
          "user": "blair55"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-03-02T15:29:18Z",
          "user": "mrapan"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-03-06T06:13:49Z",
          "user": "NoCodeMonkey"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-03-23T12:06:46Z",
          "user": "audunsolemdal"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-03-25T04:28:59Z",
          "user": "Leon99"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-03-28T15:51:02Z",
          "user": "RobinsonWM"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-04-06T22:43:43Z",
          "user": "skywalkerisnull"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-04-08T11:08:56Z",
          "user": "sergey-frolov"
        },
        {
          "content": "ROCKET",
          "createdAt": "2022-04-08T11:08:58Z",
          "user": "sergey-frolov"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-04-09T21:44:24Z",
          "user": "gowthamrang-ds"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-04-19T06:30:37Z",
          "user": "swimmesberger"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-04-21T11:47:40Z",
          "user": "tuscias"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-04-22T16:59:36Z",
          "user": "willnationsdev"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-04-27T07:30:07Z",
          "user": "warappa"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-04-28T06:28:45Z",
          "user": "Igorgro"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-04-29T08:30:32Z",
          "user": "qfyra"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-05-04T17:35:39Z",
          "user": "max-holmark"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-05-10T15:33:57Z",
          "user": "miqm"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-05-11T12:16:38Z",
          "user": "patrolez"
        },
        {
          "content": "ROCKET",
          "createdAt": "2022-05-12T02:52:49Z",
          "user": "m4cm3nz"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-05-18T18:14:47Z",
          "user": "askids"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-05-19T14:21:55Z",
          "user": "akiraveliara"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-05-25T09:58:48Z",
          "user": "7702244"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-05-29T09:20:21Z",
          "user": "janlunddk"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-06-04T17:05:12Z",
          "user": "tomas-pajurek"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-06-10T15:36:57Z",
          "user": "ygoe"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-07-01T09:51:09Z",
          "user": "xsoheilalizadeh"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-07-07T12:57:51Z",
          "user": "Bomret"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-07-10T16:48:19Z",
          "user": "asimmon"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-07-12T00:33:27Z",
          "user": "SeijiSuenaga"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-07-18T07:45:51Z",
          "user": "grishinalexey"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-08-02T20:00:13Z",
          "user": "RobinHSanner"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-08-17T01:02:18Z",
          "user": "AndreTheHunter"
        },
        {
          "content": "ROCKET",
          "createdAt": "2022-08-17T01:02:21Z",
          "user": "AndreTheHunter"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-08-21T20:04:06Z",
          "user": "conorlawton"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-08-24T13:31:00Z",
          "user": "loop-evgeny"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-09-01T11:27:06Z",
          "user": "sutyak"
        },
        {
          "content": "ROCKET",
          "createdAt": "2022-09-01T11:27:10Z",
          "user": "sutyak"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-09-01T18:05:32Z",
          "user": "vitorafgomes"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-09-01T21:42:35Z",
          "user": "mnmadscience"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-09-08T20:36:37Z",
          "user": "fccoryan"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-09-10T20:56:06Z",
          "user": "tpetchel"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-09-20T04:39:01Z",
          "user": "rmandvikar"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-10-07T12:03:01Z",
          "user": "patricksadowski"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-10-28T07:00:50Z",
          "user": "ioaznnis"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-10-31T09:00:18Z",
          "user": "jackletter"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-11-03T15:22:23Z",
          "user": "GerardSmit"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-11-04T06:35:13Z",
          "user": "Dan-Albrecht"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-11-11T09:46:41Z",
          "user": "chenzuo"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-11-14T21:22:54Z",
          "user": "MarianSWA"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-11-19T20:17:13Z",
          "user": "ramax495"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-11-29T10:51:20Z",
          "user": "zdenek-jelinek"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-12-10T05:20:25Z",
          "user": "symbiogenesis"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-12-19T13:35:03Z",
          "user": "blundell89"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-01-19T11:20:28Z",
          "user": "seanterry"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-01-22T22:39:07Z",
          "user": "dsidedp"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-01-28T15:25:25Z",
          "user": "Frassle"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-02-14T17:14:13Z",
          "user": "IanKemp"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-02-17T17:05:12Z",
          "user": "rgmz"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-02-28T14:06:25Z",
          "user": "robledop"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-03-02T20:18:53Z",
          "user": "rkoelbel"
        },
        {
          "content": "ROCKET",
          "createdAt": "2023-03-02T20:18:56Z",
          "user": "rkoelbel"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-03-03T22:29:38Z",
          "user": "mqh85"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-03-10T15:24:59Z",
          "user": "Mugafo"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-03-15T09:29:46Z",
          "user": "chrisusher-instanda"
        },
        {
          "content": "ROCKET",
          "createdAt": "2023-03-16T10:16:27Z",
          "user": "manojbaishya"
        },
        {
          "content": "HEART",
          "createdAt": "2023-03-16T10:16:31Z",
          "user": "manojbaishya"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-03-16T10:16:35Z",
          "user": "manojbaishya"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-03-22T12:42:40Z",
          "user": "campersau"
        },
        {
          "content": "ROCKET",
          "createdAt": "2023-03-27T22:05:38Z",
          "user": "KSemenenko"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-04-13T15:58:11Z",
          "user": "pentp"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-05-16T12:47:27Z",
          "user": "MoamenMohamed"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-05-31T20:15:42Z",
          "user": "mtaghavi2005"
        },
        {
          "content": "HEART",
          "createdAt": "2023-06-06T14:24:32Z",
          "user": "WeihanLi"
        },
        {
          "content": "ROCKET",
          "createdAt": "2023-06-08T20:43:08Z",
          "user": "jkone27"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-06-20T20:23:29Z",
          "user": "akarboush"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-06-24T00:04:35Z",
          "user": "TrentCullinan9412"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-06-27T02:54:20Z",
          "user": "alex-lutsenko"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-07-06T10:02:27Z",
          "user": "touseefdotdev"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-07-11T06:10:36Z",
          "user": "bxjg1987"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-07-12T14:14:09Z",
          "user": "latonz"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-07-14T05:18:19Z",
          "user": "konrad-jamrozik"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-07-14T16:25:06Z",
          "user": "Constante-ou-Mort"
        },
        {
          "content": "ROCKET",
          "createdAt": "2023-07-14T16:25:08Z",
          "user": "Constante-ou-Mort"
        },
        {
          "content": "HEART",
          "createdAt": "2023-07-14T16:25:09Z",
          "user": "Constante-ou-Mort"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-07-21T14:16:32Z",
          "user": "cristian-donati"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-08-04T17:55:08Z",
          "user": "zuev56"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-08-09T11:17:48Z",
          "user": "attila-f-nagy"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-08-18T11:23:25Z",
          "user": "viktoreinars"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-08-22T06:02:06Z",
          "user": "sevensolutions"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-08-27T00:01:54Z",
          "user": "kkdawkins"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-09-05T15:29:15Z",
          "user": "avsorokin"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-09-14T13:30:01Z",
          "user": "Madcow11200"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-09-20T09:01:21Z",
          "user": "OskarKlintrot"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-09-21T19:02:40Z",
          "user": "Mrxx99"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-09-22T20:19:10Z",
          "user": "jrdodds"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-09-27T12:29:21Z",
          "user": "mhehle"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-10-05T02:03:54Z",
          "user": "clement911"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-10-16T08:21:23Z",
          "user": "sanoki"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-10-19T11:04:24Z",
          "user": "kvpt"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-10-23T09:27:09Z",
          "user": "JSkimming"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-10-28T11:09:22Z",
          "user": "BoundedChenn31"
        },
        {
          "content": "EYES",
          "createdAt": "2023-10-28T11:39:51Z",
          "user": "aloraman"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-11-03T17:40:05Z",
          "user": "Andikki"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-11-03T23:06:08Z",
          "user": "mikehixson"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-11-14T12:44:26Z",
          "user": "valterc"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-11-15T16:43:04Z",
          "user": "wi-y"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-11-15T22:58:49Z",
          "user": "TranstecJasonD"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-11-19T16:56:50Z",
          "user": "Trivivium"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-12-07T08:18:49Z",
          "user": "WGroenestein"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-12-08T05:11:04Z",
          "user": "DriLLFreAK100"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-12-13T08:12:50Z",
          "user": "lucamontagna"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-12-13T14:57:56Z",
          "user": "real-zony"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-12-14T08:44:54Z",
          "user": "frankhaugen"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-12-17T04:22:29Z",
          "user": "christianrondeau"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-12-18T12:05:58Z",
          "user": "semyon2105"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-12-28T13:56:11Z",
          "user": "RenderMichael"
        },
        {
          "content": "ROCKET",
          "createdAt": "2024-01-15T22:20:28Z",
          "user": "raresChelariu"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-01-18T15:46:05Z",
          "user": "jehrenzweig-pi"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-01-19T09:54:54Z",
          "user": "ktsin"
        },
        {
          "content": "HEART",
          "createdAt": "2024-02-01T23:58:24Z",
          "user": "Mrxx99"
        },
        {
          "content": "ROCKET",
          "createdAt": "2024-02-01T23:58:25Z",
          "user": "Mrxx99"
        },
        {
          "content": "EYES",
          "createdAt": "2024-02-01T23:58:26Z",
          "user": "Mrxx99"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-02-07T08:06:47Z",
          "user": "hez2010"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-02-08T09:04:29Z",
          "user": "3ldar"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-02-08T21:45:20Z",
          "user": "rossgrambo"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-02-18T09:55:16Z",
          "user": "baratgabor"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-02-19T14:23:17Z",
          "user": "glirastes"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-02-22T12:00:48Z",
          "user": "markszente"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-02-22T19:40:55Z",
          "user": "dibarbet"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-02-29T11:07:38Z",
          "user": "mrn06ody"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-03-07T22:02:43Z",
          "user": "Harfel94"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-03-12T18:23:07Z",
          "user": "asilverman"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-03-15T09:29:37Z",
          "user": "dimyle"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-03-16T09:25:57Z",
          "user": "304NotModified"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-03-20T13:45:57Z",
          "user": "ilFusta"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-03-26T05:31:00Z",
          "user": "ralph-msft"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-04-03T18:14:37Z",
          "user": "IGx89"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-04-10T09:33:00Z",
          "user": "nvborisenko"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-04-12T21:13:25Z",
          "user": "User123698745"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-04-22T09:46:23Z",
          "user": "Harpush"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-04-25T14:52:07Z",
          "user": "ryanewtaylor"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-04-26T14:51:02Z",
          "user": "msschl"
        },
        {
          "content": "HEART",
          "createdAt": "2024-04-26T14:51:03Z",
          "user": "msschl"
        },
        {
          "content": "EYES",
          "createdAt": "2024-04-26T14:51:04Z",
          "user": "msschl"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-05-07T11:29:34Z",
          "user": "asos-pindasingh"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-05-13T11:58:30Z",
          "user": "abpk488"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-05-19T11:18:52Z",
          "user": "paule96"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-06-04T14:28:40Z",
          "user": "samuelbewick"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-06-05T07:34:57Z",
          "user": "nanney54"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-06-05T15:42:12Z",
          "user": "dcook-net"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-06-14T14:43:35Z",
          "user": "meixger"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-06-24T21:17:51Z",
          "user": "NBKRedSpy"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-06-27T01:46:38Z",
          "user": "swdigital-joe"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-06-30T20:31:44Z",
          "user": "kamisoft-fr"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-07-04T18:32:19Z",
          "user": "Apollo3zehn"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-07-09T15:39:14Z",
          "user": "ApacheTech"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-07-23T09:02:25Z",
          "user": "thuraua"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-07-24T20:48:04Z",
          "user": "mscottford"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-08-08T12:35:07Z",
          "user": "felipetofoli"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-08-14T11:52:33Z",
          "user": "Meir017"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-09-08T14:41:10Z",
          "user": "OronDF343"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-09-10T20:14:55Z",
          "user": "Osmodium"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-09-20T19:20:48Z",
          "user": "mryanmurphy"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-10-03T02:48:18Z",
          "user": "epDugas"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-10-05T19:48:53Z",
          "user": "rosieks"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-10-16T02:27:04Z",
          "user": "issue-dispenser"
        },
        {
          "content": "HEART",
          "createdAt": "2024-10-16T17:18:20Z",
          "user": "ghadzhigeorgiev"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-10-17T04:38:27Z",
          "user": "kzu"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-10-19T13:51:25Z",
          "user": "Sergey-Terekhin"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-10-22T09:51:05Z",
          "user": "lschloetterer"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-10-28T20:23:44Z",
          "user": "Okinodwa"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-10-30T00:11:30Z",
          "user": "githubfanster"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-11-14T15:31:51Z",
          "user": "Value-Lee"
        },
        {
          "content": "HEART",
          "createdAt": "2024-11-14T15:31:54Z",
          "user": "Value-Lee"
        },
        {
          "content": "ROCKET",
          "createdAt": "2024-11-14T15:31:55Z",
          "user": "Value-Lee"
        },
        {
          "content": "EYES",
          "createdAt": "2024-11-14T15:31:56Z",
          "user": "Value-Lee"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-11-19T09:17:02Z",
          "user": "apex-lachezar-gizdov"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-11-25T10:02:49Z",
          "user": "isaevdan"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-12-01T09:32:32Z",
          "user": "ahmednfwela"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-12-11T06:38:03Z",
          "user": "wxk0248"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-12-23T18:34:27Z",
          "user": "ashokbharathi"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-01-26T15:34:28Z",
          "user": "Abdragiz"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-01-30T16:02:08Z",
          "user": "Dubzer"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-02-11T13:15:18Z",
          "user": "bjarketrux"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-02-24T13:32:25Z",
          "user": "DAHAG-ArisNourbakhsh"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-03-03T12:21:23Z",
          "user": "abalaci"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-03-03T23:49:23Z",
          "user": "dszwajkowski"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-03-05T22:23:34Z",
          "user": "shravan2x"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-03-11T16:07:49Z",
          "user": "msiemens"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-03-20T11:36:30Z",
          "user": "kornakar"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-03-21T08:48:31Z",
          "user": "mthesing88"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-03-29T08:27:40Z",
          "user": "acartura"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-06-19T07:58:49Z",
          "user": "Broderick890"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-06-26T09:23:59Z",
          "user": "erwinkramer"
        },
        {
          "content": "HEART",
          "createdAt": "2025-06-26T09:24:01Z",
          "user": "erwinkramer"
        },
        {
          "content": "ROCKET",
          "createdAt": "2025-06-26T09:24:03Z",
          "user": "erwinkramer"
        },
        {
          "content": "EYES",
          "createdAt": "2025-06-26T09:24:05Z",
          "user": "erwinkramer"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-07-18T22:20:06Z",
          "user": "Athari"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-07-26T17:06:28Z",
          "user": "DamianMaslanka5"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-08-14T10:41:08Z",
          "user": "chris-scl"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-08-29T08:42:29Z",
          "user": "ahdung"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-09-14T01:21:11Z",
          "user": "aradalvand"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-09-16T12:33:08Z",
          "user": "lilinus"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-09-20T17:45:17Z",
          "user": "joelverhagen"
        }
      ],
      "totalCount": 340,
      "endCursor": "Y3Vyc29yOnYyOpHOBFTERw=="
    },
    "updatedAt": "2025-05-04T06:33:08Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": "dazinator",
          "body": "Just searched for a similar thing myself. The appropriate newtonsoft documentation for this: https://www.newtonsoft.com/json/help/html/QueryJsonSelectTokenJsonPath.htm\r\n\r\n",
          "createdAt": "2019-10-23T23:31:40Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-10-16T17:18:59Z",
                "user": "ghadzhigeorgiev"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOD2l4fA=="
          },
          "updatedAt": "2019-10-23T23:33:26Z",
          "id": "MDEyOklzc3VlQ29tbWVudDU0NTY3ODcyMA=="
        },
        {
          "author": "dkmiller",
          "body": "Seconding this. It would be extremely useful.",
          "createdAt": "2019-11-20T21:20:31Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2020-07-06T10:28:49Z",
                "user": "maksimenko-stanislav"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2020-11-25T12:39:26Z",
                "user": "WorldIsM"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-07-05T06:43:04Z",
                "user": "hell-racer"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-10-19T00:58:41Z",
                "user": "Agreyddous"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-01-26T14:53:40Z",
                "user": "suchoss"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-06-15T16:16:46Z",
                "user": "Cuneytt"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-07-07T09:39:13Z",
                "user": "Pvlerick"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-08-21T20:04:07Z",
                "user": "conorlawton"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-03-16T10:17:59Z",
                "user": "manojbaishya"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-11-02T09:24:42Z",
                "user": "gorillapower"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-01-13T22:31:42Z",
                "user": "verdantburrito"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-01-18T15:46:13Z",
                "user": "jehrenzweig-pi"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-03-15T22:00:10Z",
                "user": "johngagefaulkner"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-03-18T12:17:52Z",
                "user": "gdperkins"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-04-10T18:47:07Z",
                "user": "frivard-coveo"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-07-08T13:02:12Z",
                "user": "raresChelariu"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-07-09T15:40:11Z",
                "user": "ApacheTech"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-09-10T20:14:52Z",
                "user": "Osmodium"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-11-19T09:17:00Z",
                "user": "apex-lachezar-gizdov"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-01-29T11:27:46Z",
                "user": "nicktuckerequias"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-09-16T07:52:16Z",
                "user": "SaifAqqad"
              }
            ],
            "totalCount": 21,
            "endCursor": "Y3Vyc29yOnYyOpHOEiaSuQ=="
          },
          "updatedAt": "2019-11-20T21:20:31Z",
          "id": "MDEyOklzc3VlQ29tbWVudDU1NjQxMTk4Ng=="
        },
        {
          "author": "NickMSW",
          "body": "Would also like to push this up the stack. We want to use system.text.json but the lack of JsonPath is blocking us.",
          "createdAt": "2019-12-13T15:34:38Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2019-12-13T17:03:51Z",
                "user": "dkmiller"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2020-01-16T12:20:43Z",
                "user": "twenzel"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2020-01-22T19:15:19Z",
                "user": "akamor"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2020-01-24T18:52:16Z",
                "user": "acolombi"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2020-02-26T17:39:00Z",
                "user": "marcogomex"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2020-03-05T01:07:22Z",
                "user": "snblackout"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2020-03-23T08:36:37Z",
                "user": "cympatic"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2020-03-29T16:59:57Z",
                "user": "azambrano"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2020-04-08T01:15:35Z",
                "user": "jasjae"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2020-04-14T15:54:32Z",
                "user": "paladin80"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2020-05-01T03:08:36Z",
                "user": "jaime-olivares"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2020-05-11T02:25:47Z",
                "user": "m42martin"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2020-05-19T08:15:21Z",
                "user": "BrightLight"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2020-05-28T12:23:51Z",
                "user": "vdaron"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2020-06-21T16:09:57Z",
                "user": "AdamCaviness"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2020-07-06T10:28:39Z",
                "user": "maksimenko-stanislav"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2020-11-06T22:46:34Z",
                "user": "ADustyOldMuffin"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2020-11-25T12:39:30Z",
                "user": "WorldIsM"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-02-10T15:12:34Z",
                "user": "musakasim"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-02-10T20:46:15Z",
                "user": "EliPulsifer"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-02-22T19:30:42Z",
                "user": "simeyla"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-06-21T21:42:23Z",
                "user": "juharris"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-07-05T06:43:10Z",
                "user": "hell-racer"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-10-19T00:58:42Z",
                "user": "Agreyddous"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-11-06T12:51:39Z",
                "user": "ThomasOpiolka"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-12-14T22:33:45Z",
                "user": "HalidCisse"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-06-15T16:16:55Z",
                "user": "Cuneytt"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-06-30T19:13:38Z",
                "user": "hf-kklein"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-09-08T20:36:48Z",
                "user": "fccoryan"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-03-03T22:30:08Z",
                "user": "mqh85"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-03-16T10:18:01Z",
                "user": "manojbaishya"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-06-06T14:24:37Z",
                "user": "WeihanLi"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-09-11T09:37:39Z",
                "user": "xennialex"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-10-10T23:46:55Z",
                "user": "mmercan"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-01-15T22:19:54Z",
                "user": "raresChelariu"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-01-18T15:46:18Z",
                "user": "jehrenzweig-pi"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-04-10T18:47:12Z",
                "user": "frivard-coveo"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-07-09T15:40:13Z",
                "user": "ApacheTech"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-09-10T20:17:39Z",
                "user": "Osmodium"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-10-16T17:19:19Z",
                "user": "ghadzhigeorgiev"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-12-14T05:45:55Z",
                "user": "wxk0248"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-01-15T02:56:52Z",
                "user": "outfoxedmeng"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-01-29T11:27:56Z",
                "user": "nicktuckerequias"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-05-04T14:15:47Z",
                "user": "Meir017"
              }
            ],
            "totalCount": 44,
            "endCursor": "Y3Vyc29yOnYyOpHOCBdB7A=="
          },
          "updatedAt": "2019-12-13T15:34:38Z",
          "id": "MDEyOklzc3VlQ29tbWVudDU2NTQ4NTYwOA=="
        },
        {
          "author": "azambrano",
          "body": "In the meantime. I'm doing some experiment following the same strategy of the Json.net for support JsonPath but using System.Text.Json.JsonDocument [https://github.com/azambrano/JsonDocumentPath](https://github.com/azambrano/JsonDocumentPath)",
          "createdAt": "2020-03-31T04:14:27Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2020-04-08T01:14:33Z",
                "user": "jasjae"
              },
              {
                "content": "HEART",
                "createdAt": "2020-06-02T01:52:19Z",
                "user": "Laiteux"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2020-07-06T10:29:02Z",
                "user": "maksimenko-stanislav"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2020-11-25T12:40:36Z",
                "user": "WorldIsM"
              },
              {
                "content": "HEART",
                "createdAt": "2020-11-25T13:59:34Z",
                "user": "WorldIsM"
              },
              {
                "content": "HEART",
                "createdAt": "2020-12-19T01:23:54Z",
                "user": "stevo-knievo"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2020-12-19T01:23:55Z",
                "user": "stevo-knievo"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-07-05T06:43:30Z",
                "user": "hell-racer"
              },
              {
                "content": "HEART",
                "createdAt": "2021-12-14T22:33:51Z",
                "user": "HalidCisse"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-12-14T22:33:53Z",
                "user": "HalidCisse"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-01-04T06:53:46Z",
                "user": "IvanJosipovic"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-03-15T09:24:02Z",
                "user": "WeihanLi"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-07-08T13:02:28Z",
                "user": "raresChelariu"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-07-09T15:40:17Z",
                "user": "ApacheTech"
              }
            ],
            "totalCount": 14,
            "endCursor": "Y3Vyc29yOnYyOpHODo_wUA=="
          },
          "updatedAt": "2020-03-31T04:16:04Z",
          "id": "MDEyOklzc3VlQ29tbWVudDYwNjM4ODUzOA=="
        },
        {
          "author": "NinoFloris",
          "body": "@layomia did this and writedom move out of scope for 5.0?",
          "createdAt": "2020-04-13T13:37:42Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2020-06-05T15:09:08Z",
                "user": "dkmiller"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-07-09T15:40:18Z",
                "user": "ApacheTech"
              }
            ],
            "totalCount": 2,
            "endCursor": "Y3Vyc29yOnYyOpHODo_wUg=="
          },
          "updatedAt": "2020-04-13T13:37:42Z",
          "id": "MDEyOklzc3VlQ29tbWVudDYxMjkwMTczNQ=="
        },
        {
          "author": "zmhh",
          "body": "If this is implemented it would be nice to have the option for case insensitivity.",
          "createdAt": "2020-05-28T18:12:33Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-01-19T11:16:31Z",
                "user": "seanterry"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-01-15T22:20:18Z",
                "user": "raresChelariu"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-07-09T15:40:27Z",
                "user": "ApacheTech"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-10-16T17:20:08Z",
                "user": "ghadzhigeorgiev"
              }
            ],
            "totalCount": 4,
            "endCursor": "Y3Vyc29yOnYyOpHOD2l4_A=="
          },
          "updatedAt": "2020-05-28T18:12:33Z",
          "id": "MDEyOklzc3VlQ29tbWVudDYzNTUxMTc2Ng=="
        },
        {
          "author": "Laiteux",
          "body": "We want this",
          "createdAt": "2020-05-29T08:37:49Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2020-06-05T15:09:00Z",
                "user": "dkmiller"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2020-07-06T10:29:11Z",
                "user": "maksimenko-stanislav"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-04-07T21:47:12Z",
                "user": "wmartin129"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-08-10T09:20:49Z",
                "user": "dimabarbul"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-10-31T09:01:43Z",
                "user": "jackletter"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-06-06T14:24:48Z",
                "user": "WeihanLi"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-01-15T22:20:20Z",
                "user": "raresChelariu"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-07-09T15:40:28Z",
                "user": "ApacheTech"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-10-16T17:20:12Z",
                "user": "ghadzhigeorgiev"
              }
            ],
            "totalCount": 9,
            "endCursor": "Y3Vyc29yOnYyOpHOD2l5BQ=="
          },
          "updatedAt": "2020-05-29T08:37:49Z",
          "id": "MDEyOklzc3VlQ29tbWVudDYzNTg0OTM0OA=="
        },
        {
          "author": "onionhammer",
          "body": "This would be very useful",
          "createdAt": "2020-06-05T14:17:53Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2020-06-05T15:08:57Z",
                "user": "dkmiller"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2020-07-06T10:29:12Z",
                "user": "maksimenko-stanislav"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-09-01T18:05:43Z",
                "user": "vitorafgomes"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-09-28T16:33:41Z",
                "user": "WeihanLi"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-10-31T09:01:45Z",
                "user": "jackletter"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-01-15T22:20:22Z",
                "user": "raresChelariu"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-07-09T15:40:30Z",
                "user": "ApacheTech"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-09-10T20:18:02Z",
                "user": "Osmodium"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-10-16T17:20:15Z",
                "user": "ghadzhigeorgiev"
              }
            ],
            "totalCount": 9,
            "endCursor": "Y3Vyc29yOnYyOpHOD2l5EQ=="
          },
          "updatedAt": "2020-06-05T14:17:53Z",
          "id": "MDEyOklzc3VlQ29tbWVudDYzOTUyNDk2NQ=="
        },
        {
          "author": "blushingpenguin",
          "body": "I've ported the Newtonsoft.Json implementation to work with JsonDocument, along with the tests.\r\n\r\nnuget: https://www.nuget.org/packages/BlushingPenguin.JsonPath/\r\nsource: https://github.com/blushingpenguin/BlushingPenguin.JsonPath/",
          "createdAt": "2020-06-08T14:40:38Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2020-06-08T16:25:44Z",
                "user": "onionhammer"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2020-07-06T10:29:14Z",
                "user": "maksimenko-stanislav"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2020-08-18T12:17:26Z",
                "user": "Arithmomaniac"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2020-10-06T10:52:29Z",
                "user": "ricred"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-02-13T19:02:38Z",
                "user": "ThomasOpiolka"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-09-28T16:33:45Z",
                "user": "WeihanLi"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-03-16T10:18:24Z",
                "user": "manojbaishya"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-07-09T15:40:31Z",
                "user": "ApacheTech"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-10-03T08:19:24Z",
                "user": "naice"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-10-16T17:20:43Z",
                "user": "ghadzhigeorgiev"
              }
            ],
            "totalCount": 10,
            "endCursor": "Y3Vyc29yOnYyOpHOD2l5Pg=="
          },
          "updatedAt": "2020-06-08T14:40:38Z",
          "id": "MDEyOklzc3VlQ29tbWVudDY0MDY3MjY3OA=="
        },
        {
          "author": "Laiteux",
          "body": "> I've ported the Newtonsoft.Json implementation to work with JsonDocument, along with the tests.\r\n> \r\n> nuget: https://www.nuget.org/packages/BlushingPenguin.JsonPath/\r\n> source: https://github.com/blushingpenguin/BlushingPenguin.JsonPath/\r\n\r\nHello, what's the difference with this? https://github.com/azambrano/JsonDocumentPath",
          "createdAt": "2020-06-08T14:59:49Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2020-06-08T14:59:49Z",
          "id": "MDEyOklzc3VlQ29tbWVudDY0MDY4NDg3NQ=="
        },
        {
          "author": "blushingpenguin",
          "body": "It's pretty similar (it's also a port of Newtonsoft.Json's implementation), but is missing some of the functionality of the original and lacks a nuget package.  (AFAIK I've ported all of the original functionality).\r\n\r\nI could have forked that one, but my version is actually a port of https://github.com/blushingpenguin/MongoDB.Bson.Path (which is a version that works on the MongoDB.BsonDocument family).",
          "createdAt": "2020-06-08T15:16:03Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2020-06-08T15:16:03Z",
          "id": "MDEyOklzc3VlQ29tbWVudDY0MDY5NDU5Nw=="
        },
        {
          "author": "gregsdennis",
          "body": "More support for [JSON Path](https://github.com/gregsdennis/json-everything)",
          "createdAt": "2020-10-12T04:57:14Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_DOWN",
                "createdAt": "2020-11-06T22:51:14Z",
                "user": "ADustyOldMuffin"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-02-04T15:10:46Z",
                "user": "ZukkyBaig"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-04-27T07:15:41Z",
                "user": "rpnoll1977"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-08-19T00:53:48Z",
                "user": "danielsharvey"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-03-16T10:18:35Z",
                "user": "manojbaishya"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-04-20T16:26:41Z",
                "user": "ebekker"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-09-14T13:30:32Z",
                "user": "Madcow11200"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-11-14T14:42:35Z",
                "user": "Namoshek"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-12-01T13:36:37Z",
                "user": "elgonzo"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-08-14T11:53:01Z",
                "user": "Meir017"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-10-16T17:22:26Z",
                "user": "ghadzhigeorgiev"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-12-03T19:17:10Z",
                "user": "JobaDiniz"
              }
            ],
            "totalCount": 12,
            "endCursor": "Y3Vyc29yOnYyOpHOD9a_QQ=="
          },
          "updatedAt": "2020-10-12T04:57:53Z",
          "id": "MDEyOklzc3VlQ29tbWVudDcwNjg1OTQ2OQ=="
        },
        {
          "author": "GF-Huang",
          "body": "Does it merged into `.NET 5`?",
          "createdAt": "2020-11-19T17:29:09Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2020-11-25T12:41:21Z",
                "user": "WorldIsM"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOBX8yuw=="
          },
          "updatedAt": "2020-11-19T17:29:09Z",
          "id": "MDEyOklzc3VlQ29tbWVudDczMDUyNDcwOQ=="
        },
        {
          "author": "gregsdennis",
          "body": "@ADustyOldMuffin, what's with the downvote without an explanation?",
          "createdAt": "2020-11-19T23:19:21Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2020-11-19T23:19:21Z",
          "id": "MDEyOklzc3VlQ29tbWVudDczMDY5ODQ1OQ=="
        },
        {
          "author": "ZukkyBaig",
          "body": "Is this still being looked at? Without JSON path it is a hindrance. ",
          "createdAt": "2021-02-04T15:11:07Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-02-04T15:11:07Z",
          "id": "MDEyOklzc3VlQ29tbWVudDc3MzM4MDgyMA=="
        },
        {
          "author": "layomia",
          "body": "This feature is [proposed](https://github.com/orgs/dotnet/projects/20#card-50030830) for .NET 6, but not [committed](https://github.com/orgs/dotnet/projects/20#column-10973173). To be clear, we acknowledge that this is an important feature for many users, however, work on features with [higher priority](https://themesof.net/?q=System.Text.Json%20is:open%20kinds:teu) may prevent this from coming in .NET 6.",
          "createdAt": "2021-02-04T15:35:19Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-02-04T15:37:49Z",
                "user": "ZukkyBaig"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-02-10T15:13:46Z",
                "user": "musakasim"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-04-24T03:24:57Z",
                "user": "bjsmiley"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-02-01T14:35:29Z",
                "user": "onionhammer"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-06-15T16:17:41Z",
                "user": "Cuneytt"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-07-09T15:40:55Z",
                "user": "ApacheTech"
              }
            ],
            "totalCount": 6,
            "endCursor": "Y3Vyc29yOnYyOpHODo_wpg=="
          },
          "updatedAt": "2021-02-04T15:37:00Z",
          "id": "MDEyOklzc3VlQ29tbWVudDc3MzM5ODI5Mw=="
        },
        {
          "author": "gregsdennis",
          "body": ".Net and any other implementors should be aware that there is currently an effort to [standardize JSON Path](https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-jsonpath).  It would be a good idea to follow that progress and perhaps join the effort.  More people pushing it forward could help it go faster.",
          "createdAt": "2021-02-04T17:31:19Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-03-17T14:10:58Z",
                "user": "jaldinger"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-03-17T14:22:41Z",
                "user": "a510"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-04-21T03:57:26Z",
                "user": "ProTip"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-04-24T03:24:48Z",
                "user": "bjsmiley"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-05-13T19:57:10Z",
                "user": "superstator"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-06-11T13:42:16Z",
                "user": "malaterre"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-02-09T17:25:07Z",
                "user": "mguinness"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-03-29T00:59:55Z",
                "user": "tiwahu"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-12-01T13:37:04Z",
                "user": "elgonzo"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-07-09T15:40:56Z",
                "user": "ApacheTech"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-02-07T23:04:18Z",
                "user": "masonwheeler"
              }
            ],
            "totalCount": 11,
            "endCursor": "Y3Vyc29yOnYyOpHOEFr7vA=="
          },
          "updatedAt": "2021-02-04T17:32:26Z",
          "id": "MDEyOklzc3VlQ29tbWVudDc3MzQ3OTkxMQ=="
        },
        {
          "author": "jaldinger",
          "body": "I agree this is highly necessary. I also believe it should follow the proposed standard as closely as possible.",
          "createdAt": "2021-03-17T14:13:06Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-03-17T14:13:06Z",
          "id": "MDEyOklzc3VlQ29tbWVudDgwMTExNDQxMw=="
        },
        {
          "author": "steveharter",
          "body": "Note that there is now the `System.Text.Json.Nodes.Node` APIs that supports JsonPath via `GetPath()` and also support case-insensitivity for property names as was requested above.\r\n\r\nIf you already have an instance of a `JsonElement`, there is interop with `JsonDocument`\\`JsonElement` via static factory methods on the JsonNode-derived classes.\r\n\r\nAdding support for JsonPath to `JsonDocument`\\`JsonElement` will be decrease performance since the design today is based on a low-level \"metadata database\" design which is optimized to reduce memory usage and deferred value creation, and not directly extensible to add a \"parent\" and \"property name\" semantics required for JsonPath.",
          "createdAt": "2021-06-01T17:28:12Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-06-02T04:12:28Z",
                "user": "LeaFrock"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-06-02T08:07:27Z",
                "user": "loraderon"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-07-05T06:44:55Z",
                "user": "hell-racer"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-07-06T07:42:53Z",
                "user": "Vaskinn"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-07-10T15:44:01Z",
                "user": "WeihanLi"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-04-27T20:45:46Z",
                "user": "ghadzhigeorgiev"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-10-23T06:49:45Z",
                "user": "OskarKlintrot"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-07-09T15:41:14Z",
                "user": "ApacheTech"
              }
            ],
            "totalCount": 8,
            "endCursor": "Y3Vyc29yOnYyOpHODo_wzw=="
          },
          "updatedAt": "2021-06-01T17:28:12Z",
          "id": "MDEyOklzc3VlQ29tbWVudDg1MjMwOTIzMQ=="
        },
        {
          "author": "gregsdennis",
          "body": "@steveharter can you provide links, please? On which versions of .net is this available?\n\nAlso what support for JSON Path is there (given that there is no standard)?  Or is it just JSON-Path-like?",
          "createdAt": "2021-06-02T04:23:01Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-06-02T08:07:34Z",
                "user": "loraderon"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-06-02T15:47:07Z",
                "user": "jaldinger"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-06-21T21:48:17Z",
                "user": "juharris"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-07-06T07:42:49Z",
                "user": "Vaskinn"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-07-09T15:41:16Z",
                "user": "ApacheTech"
              }
            ],
            "totalCount": 5,
            "endCursor": "Y3Vyc29yOnYyOpHODo_w1g=="
          },
          "updatedAt": "2021-06-02T04:23:25Z",
          "id": "MDEyOklzc3VlQ29tbWVudDg1MjcwOTU2Mg=="
        },
        {
          "author": "WeihanLi",
          "body": "Great idea, and maybe better if implemented for `JsonNode`",
          "createdAt": "2021-07-10T15:43:00Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-07-10T15:43:00Z",
          "id": "MDEyOklzc3VlQ29tbWVudDg3NzY1NzkxMw=="
        },
        {
          "author": "steveharter",
          "body": "> @steveharter can you provide links, please? On which versions of .net is this available?\r\n\r\n`JsonNode` was added in Preview 4 of .NET 6.0.\r\n\r\nMoving to 7.0. Workarounds and extensions are possible; see https://github.com/dotnet/runtime/issues/55827 which also has JsonPath request to navigate to a child `JsonNode` and some sample extensions. I'll be providing additional samples for `JsonNode`, and perhaps `JsonElement` to handle simple navigation.\r\n\r\nNote that `JsonNode` has a `string GetPath()` and `.Parent` property but doesn't have built-in support for navigation and other JsonPath query syntax. That would be a larger feature, and could be adopted to `JsonElement` \\ `JsonDocument` as well.\r\n\r\nAlso, JsonPath query syntax and general navigation from a parent to a child with `JsonElement` \\ `JsonDocument` is possible with the existing architecture; what wouldn't really work is when `GetPath()` or `.Parent` is needed given a child node or asking for the \"property name\" of a given child node (which is the property name the parent has -- for example, asking for the \"property name\" on \"Address\" in a \"Order.Customer.Address\" hierarchy would return \"Customer\". This \".Parent\" behavior, however, is not part of JsonPath syntax anyway.\r\n",
          "createdAt": "2021-07-30T21:39:35Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "EYES",
                "createdAt": "2021-08-16T21:19:49Z",
                "user": "Gladskih"
              },
              {
                "content": "EYES",
                "createdAt": "2022-10-31T09:10:20Z",
                "user": "jackletter"
              }
            ],
            "totalCount": 2,
            "endCursor": "Y3Vyc29yOnYyOpHOCuvppg=="
          },
          "updatedAt": "2021-07-30T21:39:35Z",
          "id": "IC_kwDODI9FZc41DuKQ"
        },
        {
          "author": "danielaparker",
          "body": "In the interim, and possibly of use to some folks, here's another JSONPath .Net implementation that supports querying JsonDocument/JsonElement instances, [JsonCons.Net](https://github.com/danielaparker/JsonCons.Net)\r\n",
          "createdAt": "2021-08-10T18:26:27Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-03-15T09:39:31Z",
                "user": "viktor-svub"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-03-25T04:26:31Z",
                "user": "Leon99"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-04-27T07:29:42Z",
                "user": "warappa"
              }
            ],
            "totalCount": 3,
            "endCursor": "Y3Vyc29yOnYyOpHOCaBKCw=="
          },
          "updatedAt": "2021-08-10T18:26:27Z",
          "id": "IC_kwDODI9FZc41ay27"
        },
        {
          "author": "mcwarg",
          "body": "This is definitely a valuable feature for us to have. ",
          "createdAt": "2022-03-15T08:35:01Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-03-15T09:39:27Z",
                "user": "viktor-svub"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-03-16T01:28:18Z",
                "user": "beeradmoore"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-03-25T05:53:03Z",
                "user": "TrifonovSergey"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-03-29T11:56:48Z",
                "user": "pavelpeknica"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-03-31T23:39:39Z",
                "user": "jcoliz"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-04-06T18:38:55Z",
                "user": "alitas"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-04-08T11:19:34Z",
                "user": "sergey-frolov"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-04-09T21:44:38Z",
                "user": "gowthamrang-ds"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-04-13T20:01:20Z",
                "user": "udlose"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-04-20T21:28:13Z",
                "user": "argentini"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-04-27T07:26:42Z",
                "user": "warappa"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-05-05T08:57:29Z",
                "user": "Deathofdemigod"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-05-18T18:15:15Z",
                "user": "askids"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-05-19T14:22:10Z",
                "user": "akiraveliara"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-06-04T17:05:16Z",
                "user": "tomas-pajurek"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-06-13T12:37:22Z",
                "user": "ivanmagdic"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-09-28T16:33:15Z",
                "user": "WeihanLi"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-10-12T22:13:33Z",
                "user": "Marusyk"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-03-16T10:25:37Z",
                "user": "manojbaishya"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-01-18T15:47:21Z",
                "user": "jehrenzweig-pi"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-11-14T15:29:07Z",
                "user": "Value-Lee"
              }
            ],
            "totalCount": 21,
            "endCursor": "Y3Vyc29yOnYyOpHOD65fhQ=="
          },
          "updatedAt": "2022-03-15T08:35:01Z",
          "id": "IC_kwDODI9FZc4_o99L"
        },
        {
          "author": "krwq",
          "body": "Unfortunately we won't have time for this in 7.0, moving to 8.0",
          "createdAt": "2022-07-07T13:16:03Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "CONFUSED",
                "createdAt": "2022-07-07T13:51:37Z",
                "user": "danslapman"
              },
              {
                "content": "CONFUSED",
                "createdAt": "2022-07-08T02:32:33Z",
                "user": "Cuneytt"
              },
              {
                "content": "CONFUSED",
                "createdAt": "2022-08-31T07:51:32Z",
                "user": "OskarKlintrot"
              },
              {
                "content": "CONFUSED",
                "createdAt": "2022-09-01T11:27:22Z",
                "user": "sutyak"
              },
              {
                "content": "CONFUSED",
                "createdAt": "2022-09-09T09:47:03Z",
                "user": "RFlipper"
              },
              {
                "content": "CONFUSED",
                "createdAt": "2022-09-16T22:08:34Z",
                "user": "GerardSmit"
              },
              {
                "content": "CONFUSED",
                "createdAt": "2022-09-27T07:06:37Z",
                "user": "xavirec"
              },
              {
                "content": "CONFUSED",
                "createdAt": "2022-09-27T07:06:53Z",
                "user": "lduarte19"
              },
              {
                "content": "CONFUSED",
                "createdAt": "2022-10-07T12:08:25Z",
                "user": "patricksadowski"
              },
              {
                "content": "CONFUSED",
                "createdAt": "2022-10-12T22:13:42Z",
                "user": "Marusyk"
              },
              {
                "content": "THUMBS_DOWN",
                "createdAt": "2022-11-04T06:37:26Z",
                "user": "Dan-Albrecht"
              },
              {
                "content": "CONFUSED",
                "createdAt": "2022-12-23T09:57:55Z",
                "user": "Ark667"
              },
              {
                "content": "CONFUSED",
                "createdAt": "2023-03-16T10:25:31Z",
                "user": "manojbaishya"
              },
              {
                "content": "THUMBS_DOWN",
                "createdAt": "2023-03-22T22:36:29Z",
                "user": "bender-joe"
              },
              {
                "content": "CONFUSED",
                "createdAt": "2023-05-23T02:35:42Z",
                "user": "joezhang-sh"
              },
              {
                "content": "THUMBS_DOWN",
                "createdAt": "2023-09-20T08:26:56Z",
                "user": "IanKemp"
              },
              {
                "content": "CONFUSED",
                "createdAt": "2023-11-01T15:38:53Z",
                "user": "Nova-Logic"
              },
              {
                "content": "THUMBS_DOWN",
                "createdAt": "2023-12-15T15:28:02Z",
                "user": "m3nax"
              },
              {
                "content": "THUMBS_DOWN",
                "createdAt": "2024-01-13T22:32:05Z",
                "user": "verdantburrito"
              },
              {
                "content": "CONFUSED",
                "createdAt": "2024-01-13T22:32:08Z",
                "user": "verdantburrito"
              },
              {
                "content": "THUMBS_DOWN",
                "createdAt": "2024-01-18T15:47:24Z",
                "user": "jehrenzweig-pi"
              },
              {
                "content": "CONFUSED",
                "createdAt": "2024-02-22T12:01:04Z",
                "user": "markszente"
              },
              {
                "content": "THUMBS_DOWN",
                "createdAt": "2025-06-19T07:59:55Z",
                "user": "Broderick890"
              }
            ],
            "totalCount": 23,
            "endCursor": "Y3Vyc29yOnYyOpHOEXK-0g=="
          },
          "updatedAt": "2022-07-07T13:16:03Z",
          "id": "IC_kwDODI9FZc5GMLZH"
        },
        {
          "author": "gregsdennis",
          "body": "I think this is actually for the best since the spec isn't finished yet.\n\nMy implementation, [JsonPath.Net](https://github.com/gregsdennis/json-everything) supports `JsonElement` and `JsonNode`.",
          "createdAt": "2022-07-07T19:03:37Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "EYES",
                "createdAt": "2022-07-25T11:45:42Z",
                "user": "warappa"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOCoTepg=="
          },
          "updatedAt": "2023-09-20T08:32:00Z",
          "id": "IC_kwDODI9FZc5GODWE"
        },
        {
          "author": "krwq",
          "body": "Agreed with @gregsdennis, once spec is done we should bump priority",
          "createdAt": "2022-09-28T16:07:42Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "HEART",
                "createdAt": "2022-09-28T17:05:52Z",
                "user": "dkmiller"
              },
              {
                "content": "HEART",
                "createdAt": "2023-03-16T10:25:51Z",
                "user": "manojbaishya"
              }
            ],
            "totalCount": 2,
            "endCursor": "Y3Vyc29yOnYyOpHOC387sA=="
          },
          "updatedAt": "2022-09-28T16:07:42Z",
          "id": "IC_kwDODI9FZc5LK2CX"
        },
        {
          "author": "IanKemp",
          "body": "Assuming this isn't going to make .NET 8 either?",
          "createdAt": "2023-09-20T08:27:49Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-09-20T08:27:49Z",
          "id": "IC_kwDODI9FZc5m81Xi"
        },
        {
          "author": "jeffhandley",
          "body": "> Assuming this isn't going to make .NET 8 either?\r\n\r\nYou're correct, @IanKemp. This will be evaluated again during our .NET 9 planning.",
          "createdAt": "2023-10-02T17:19:42Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-10-19T15:33:36Z",
                "user": "terrajobst"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-10-23T06:47:39Z",
                "user": "OskarKlintrot"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-12-15T12:42:37Z",
                "user": "frankhaugen"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-12-17T04:22:22Z",
                "user": "christianrondeau"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-01-28T06:31:27Z",
                "user": "SaifAqqad"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-02-01T23:58:40Z",
                "user": "Mrxx99"
              }
            ],
            "totalCount": 6,
            "endCursor": "Y3Vyc29yOnYyOpHODVFXbA=="
          },
          "updatedAt": "2023-10-02T17:19:42Z",
          "id": "IC_kwDODI9FZc5n6sKd"
        },
        {
          "author": "frankhaugen",
          "body": "> > Assuming this isn't going to make .NET 8 either?\r\n> \r\n> You're correct, @IanKemp. This will be evaluated again during our .NET 9 planning.\r\n\r\nWhen is it scheduled on the \"docket\" for planning? (When will we have a decision)",
          "createdAt": "2023-12-15T12:44:10Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-12-15T16:27:44Z",
                "user": "dkmiller"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-12-28T13:55:02Z",
                "user": "RenderMichael"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-01-18T15:46:40Z",
                "user": "jehrenzweig-pi"
              },
              {
                "content": "EYES",
                "createdAt": "2024-01-18T15:47:41Z",
                "user": "jehrenzweig-pi"
              }
            ],
            "totalCount": 4,
            "endCursor": "Y3Vyc29yOnYyOpHODTJa2A=="
          },
          "updatedAt": "2023-12-15T12:44:10Z",
          "id": "IC_kwDODI9FZc5uvDDj"
        },
        {
          "author": "gregsdennis",
          "body": "The JSON Path specification has been released!\r\n\r\nhttps://www.rfc-editor.org/rfc/rfc9535.html\r\n\r\nAgain, JsonPath.Net fully supports the specification.  The library has been bumped to v1.0.0 with the release of the spec.",
          "createdAt": "2024-02-22T20:19:49Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "HOORAY",
                "createdAt": "2024-02-22T20:32:24Z",
                "user": "swimmesberger"
              },
              {
                "content": "HEART",
                "createdAt": "2024-02-22T20:59:42Z",
                "user": "IvanJosipovic"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-02-22T21:00:55Z",
                "user": "meixger"
              },
              {
                "content": "HOORAY",
                "createdAt": "2024-02-22T21:02:46Z",
                "user": "jerradneff"
              },
              {
                "content": "HEART",
                "createdAt": "2024-02-22T21:02:46Z",
                "user": "jerradneff"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-02-22T21:02:48Z",
                "user": "jerradneff"
              },
              {
                "content": "HOORAY",
                "createdAt": "2024-02-22T21:03:40Z",
                "user": "AjayKMehta"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-02-22T22:19:32Z",
                "user": "cbayles-gestalt"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-02-23T00:28:09Z",
                "user": "dazinator"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-02-23T07:18:01Z",
                "user": "frankhaugen"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-02-25T03:03:09Z",
                "user": "dkmiller"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-02-26T06:21:55Z",
                "user": "suraciii"
              },
              {
                "content": "HEART",
                "createdAt": "2024-02-27T04:57:54Z",
                "user": "centur"
              },
              {
                "content": "HOORAY",
                "createdAt": "2024-02-27T04:57:57Z",
                "user": "centur"
              },
              {
                "content": "HOORAY",
                "createdAt": "2024-02-28T10:31:16Z",
                "user": "amis92"
              },
              {
                "content": "ROCKET",
                "createdAt": "2024-02-28T10:31:18Z",
                "user": "amis92"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-04-17T05:21:59Z",
                "user": "cajuncoding"
              },
              {
                "content": "HEART",
                "createdAt": "2024-06-26T09:18:32Z",
                "user": "krajetum"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-06-28T08:22:54Z",
                "user": "sibbl"
              },
              {
                "content": "HEART",
                "createdAt": "2024-06-30T10:57:36Z",
                "user": "powareverb"
              },
              {
                "content": "HOORAY",
                "createdAt": "2024-06-30T10:57:37Z",
                "user": "powareverb"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-08-20T19:12:54Z",
                "user": "palhal"
              }
            ],
            "totalCount": 22,
            "endCursor": "Y3Vyc29yOnYyOpHODu916Q=="
          },
          "updatedAt": "2024-02-22T20:19:49Z",
          "id": "IC_kwDODI9FZc501ts_"
        },
        {
          "author": "peteraritchie",
          "body": "Related: https://josef.codes/some-basic-query-support-for-system-text-json-jsonpath-inspired/",
          "createdAt": "2024-03-01T19:21:35Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-10-21T23:21:12Z",
                "user": "huoshan12345"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOD3cTfQ=="
          },
          "updatedAt": "2024-03-01T19:21:35Z",
          "id": "IC_kwDODI9FZc51pYb1"
        },
        {
          "author": "frankhaugen",
          "body": "> The JSON Path specification has been released!\r\n> \r\n> https://www.rfc-editor.org/rfc/rfc9535.html\r\n> \r\n> Again, JsonPath.Net fully supports the specification. The library has been bumped to v1.0.0 with the release of the spec.\r\n\r\nThat is awesome and for my personal stuff this is great, but professionally, I might be limited by corporate policy to use 1st party (Microsoft), or 2nd party (.net foundation membered), or \"verified\" 3rd party, (Newtonsoft), libraries. \r\n\r\nI say corporate, but mostly those policies come from auditing agencies for things like SOC2 and ISO2700 -certifications. So for many its not an option to use your library as you don't provide support, personal/individual ownership of the library, and so its plausibly dangerous to use your library seen from the perspective of the corporate laywers and C-level management. Explaining that your lib is deserving of exception when others exist that might be less good but by other standards are \"safer\" on paper, is a lot of work.\r\n\r\nThat's why many of us are begging MS to add functionality like this, as we either have to write it ourselves, or use some 3 year out-of-date stuff, that tripple memory use, (like newtonsoft), to get some functionality that frankly should have been there from the start in the runtime when they started on JSON",
          "createdAt": "2024-03-12T19:31:32Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-03-12T19:41:02Z",
                "user": "jerradneff"
              },
              {
                "content": "HEART",
                "createdAt": "2024-03-12T19:41:05Z",
                "user": "jerradneff"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-05-19T11:24:26Z",
                "user": "paule96"
              }
            ],
            "totalCount": 3,
            "endCursor": "Y3Vyc29yOnYyOpHODiVpng=="
          },
          "updatedAt": "2024-03-12T19:31:32Z",
          "id": "IC_kwDODI9FZc52wXk0"
        },
        {
          "author": "danielaparker",
          "body": "> That's why many of us are begging MS to add functionality like this, as we either have to write it ourselves, or use some 3 year out-of-date stuff, that tripple memory use, (like newtonsoft), to get some functionality that frankly should have been there from the start in the runtime when they started on JSON\r\n\r\nIs JSONPath really necessary for querying JSONElement instances? Can't LINQ serve that purpose?",
          "createdAt": "2024-03-12T20:45:02Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-03-12T20:45:02Z",
          "id": "IC_kwDODI9FZc52w9VY"
        },
        {
          "author": "gregsdennis",
          "body": "> 2nd party (.net foundation membered)\n\nI've been looking for reasons to submit my `json-everything` project to .net foundation.  This is a good one.\n\nStill, I think it's the role of the developer to argued that well-established 3rd party libs are fine, even if it's on a case-by-case basis.",
          "createdAt": "2024-03-13T00:18:49Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-03-13T00:18:49Z",
          "id": "IC_kwDODI9FZc52x8BZ"
        },
        {
          "author": "gregsdennis",
          "body": "> as you don't provide support\n\nWhat makes you think this?\n\nI certainly do provide support.  Issues don't stay open long, and I usually respond within 12 hours (depending on whether I'm sleeping).  I also have a dedicated Slack workspace that's open for all.\n\nI don't offer a paid support \"tier\" because I treat every issue this way.  I'm employed by Postman specifically to work on JSON Schema (the spec and community) and this suite of libraries.\n\nBut if you have something else in mind that will result in lining my pockets, I'm open to ideas.",
          "createdAt": "2024-03-13T00:26:28Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-03-13T01:01:05Z",
                "user": "LeaFrock"
              },
              {
                "content": "HEART",
                "createdAt": "2024-03-13T01:02:40Z",
                "user": "IvanJosipovic"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-03-25T11:05:25Z",
                "user": "amis92"
              },
              {
                "content": "HEART",
                "createdAt": "2024-03-25T11:05:28Z",
                "user": "amis92"
              },
              {
                "content": "HEART",
                "createdAt": "2024-03-29T17:19:13Z",
                "user": "peteraritchie"
              },
              {
                "content": "HEART",
                "createdAt": "2024-06-30T10:58:58Z",
                "user": "powareverb"
              }
            ],
            "totalCount": 6,
            "endCursor": "Y3Vyc29yOnYyOpHODny62g=="
          },
          "updatedAt": "2024-03-13T00:26:28Z",
          "id": "IC_kwDODI9FZc52yA1N"
        },
        {
          "author": "gregsdennis",
          "body": "> functionality that frankly should have been there from the start in the runtime when they started on JSON\n\nI expect that by posting here you understand that software is iterative.\n\nJSON Path/Pointer/Schema/Patch/etc. are _extensions_ to JSON.  The primary functionality is data modeling and serialization, which is exactly what has been provided, and it's why this issue has been pushed back.\n\nBasics first.",
          "createdAt": "2024-03-13T00:29:53Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-03-14T19:48:23Z",
                "user": "peteraritchie"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-12-31T09:46:26Z",
                "user": "nguyenlamlll"
              }
            ],
            "totalCount": 2,
            "endCursor": "Y3Vyc29yOnYyOpHOEApLTQ=="
          },
          "updatedAt": "2024-03-13T00:29:53Z",
          "id": "IC_kwDODI9FZc52yC1o"
        },
        {
          "author": "LeaFrock",
          "body": ">  So for many its not an option to use your library as you don't provide support, personal/individual ownership of the library, and so its plausibly dangerous to use your library seen from the perspective of the corporate laywers and C-level management.\r\n\r\nThe open-source packages from a person/enterprise are not different when talking about 'dangerous'. Otherwise what's the meaning of `open-source`? Considering the risk of EOT, even MS abandons a lot of projects too. And what's the next then?  Keep *begging* MS to give you an exception? The corporate policy should give a standard to 'verify' 3rd libraries, and that's what MS hope to promote within .NET ecosystem too. \r\n\r\n> many of us are begging MS to add functionality like this\r\n\r\nThough I hope the runtime supports JsonPath, I also support 3rd community libraries while the runtime team has the right of saying NO. It's been long time since the .NET Framework time which developers *begging* MS to release ’everything‘. I really hope the .NET community grows up to achieve a balance which .NET developers rely on MS only to a limited extent. So, encourage, embrace, and engage community open-source projects.\r\n\r\nI stand with @gregsdennis. Appreciate a lot for your work!\r\n\r\nP.S. a similar case occurs in this discussion [CSV support in .NET Core](https://github.com/dotnet/runtime/discussions/37711).",
          "createdAt": "2024-03-13T02:02:19Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-03-13T02:09:29Z",
                "user": "gregsdennis"
              },
              {
                "content": "HEART",
                "createdAt": "2024-03-13T04:09:07Z",
                "user": "gregsdennis"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-03-13T15:06:38Z",
                "user": "superstator"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-03-25T11:05:21Z",
                "user": "amis92"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-03-29T15:05:03Z",
                "user": "patrolez"
              },
              {
                "content": "HEART",
                "createdAt": "2024-03-29T15:05:03Z",
                "user": "patrolez"
              }
            ],
            "totalCount": 6,
            "endCursor": "Y3Vyc29yOnYyOpHODcXyKA=="
          },
          "updatedAt": "2024-03-13T02:06:56Z",
          "id": "IC_kwDODI9FZc52zGto"
        },
        {
          "author": "ay-azara",
          "body": "Instead of a complex query mechanism could we get a JSON flatten function so we can deserialize to a `Dictionary<string, string>` and perform the \"lookup\" on the key?\r\n```json\r\n{\r\n    \"foo\": {\r\n        \"bar\": \"baz\"\r\n    }\r\n}\r\n```\r\n\r\n```json\r\n{\r\n    \"foo.bar\":  \"baz\"\r\n}\r\n```\r\n\r\n```csharp\r\n// Something like\r\nvar dict = json.Deserialize<Dictionary<string, string>>(JsonSerializer.Flatten(json))\r\nvar val = dict['foo.bar']\r\n```",
          "createdAt": "2024-03-29T15:12:52Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_DOWN",
                "createdAt": "2024-03-29T15:28:13Z",
                "user": "onionhammer"
              },
              {
                "content": "THUMBS_DOWN",
                "createdAt": "2024-03-29T16:05:39Z",
                "user": "dmitry-azaraev"
              },
              {
                "content": "THUMBS_DOWN",
                "createdAt": "2024-03-29T16:20:43Z",
                "user": "jerradneff"
              },
              {
                "content": "THUMBS_DOWN",
                "createdAt": "2024-03-29T17:26:48Z",
                "user": "peteraritchie"
              },
              {
                "content": "THUMBS_DOWN",
                "createdAt": "2024-07-24T13:19:03Z",
                "user": "idle-code"
              },
              {
                "content": "THUMBS_DOWN",
                "createdAt": "2025-04-29T05:01:32Z",
                "user": "Meir017"
              }
            ],
            "totalCount": 6,
            "endCursor": "Y3Vyc29yOnYyOpHOEQDYKQ=="
          },
          "updatedAt": "2024-03-29T15:25:47Z",
          "id": "IC_kwDODI9FZc541y8E"
        },
        {
          "author": "peteraritchie",
          "body": "> ```\r\n> var val = dict['foo.bar']\r\n> ```\r\n\r\nThat's getting really close to being a JSONPath expression, there's just an implied `$.` at the start of `foo.bar`.  With the notation you're proposing, how would you support collections and arrays?  i.e. one way to support that is to use JSONPath notation. :)",
          "createdAt": "2024-03-29T17:41:42Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-03-29T17:41:42Z",
          "id": "IC_kwDODI9FZc542cEY"
        },
        {
          "author": "gregsdennis",
          "body": "If you want a single value, you don't want JSON Path.  You want JSON Pointer: `/foo/bar`.  I have an implementation of that, too.",
          "createdAt": "2024-03-29T17:57:15Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-04-02T14:31:18Z",
                "user": "peteraritchie"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHODctfTQ=="
          },
          "updatedAt": "2024-03-29T17:57:15Z",
          "id": "IC_kwDODI9FZc542fjc"
        },
        {
          "author": "ay-azara",
          "body": "> > ```\r\n> > var val = dict['foo.bar']\r\n> > ```\r\n> \r\n> That's getting really close to being a JSONPath expression, there's just an implied `$.` at the start of `foo.bar`. With the notation you're proposing, how would you support collections and arrays? i.e. one way to support that is to use JSONPath notation. :)\r\n\r\nIt would be the index of the array/collection object. `foo.bar.0.baz`\r\n\r\nJust to clarify, when I said \"instead\" it was meant as a short term compromise, not \"you all should give up on JSON Path support\". From my perspective, the issue has been open since 2019 so I can only assume that implementing JSON Path is a bigger ask than a flattening function. I'm willing to settle for a less rigorous but still workable solution in the short term rather than a perfect solution that may never get implemented. It's fine if you don't want to settle, my use case is not as stringent as yours probably is.\r\n\r\nAnd I think Greg's json-everything is wonderful but for some orgs it's easier to use a library that has already been cleared for use.\r\n\r\nBased on the flurry of downvotes I see it's not something worth pushing further.",
          "createdAt": "2024-03-29T18:52:58Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-03-29T19:28:34Z",
          "id": "IC_kwDODI9FZc542syV"
        },
        {
          "author": "gregsdennis",
          "body": "@ay-azara to get you by, here's an extension that builds an index keyed by JSON Pointers:\r\n\r\n```c#\r\npublic static Dictionary<string, JsonNode?> Index(this JsonNode? node)\r\n{\r\n    var index = new Dictionary<string, JsonNode?>();\r\n    var search = new Queue<(string Pointer, JsonNode? Value)>();\r\n    search.Enqueue((string.Empty, node));\r\n\r\n    while (search.Any())\r\n    {\r\n        var current = search.Dequeue();\r\n        index[current.Pointer] = current.Value;\r\n        switch (current.Value)\r\n        {\r\n            case JsonObject obj:\r\n                index[current.Pointer] = obj;\r\n                foreach (var kvp in obj)\r\n                {\r\n                    search.Enqueue(($\"{current.Pointer}/{Encode(kvp.Key)}\", kvp.Value));\r\n                }\r\n                break;\r\n            case JsonArray arr:\r\n                index[current.Pointer] = arr;\r\n                for (var i = 0; i < arr.Count; i++)\r\n                {\r\n                    var value = arr[i];\r\n                    search.Enqueue(($\"{current.Pointer}/{i}\", value));\r\n                }\r\n\r\n                break;\r\n        }\r\n    }\r\n\r\n    return index;\r\n}\r\n\r\nprivate static string Encode(string value)\r\n{\r\n    if (value.All(c => c is not ('~' or '/'))) return value;\r\n\r\n    var builder = new StringBuilder();\r\n    foreach (var ch in value)\r\n    {\r\n        switch (ch)\r\n        {\r\n            case '~':\r\n                builder.Append(\"~0\");\r\n                break;\r\n            case '/':\r\n                builder.Append(\"~1\");\r\n                break;\r\n            default:\r\n                builder.Append(ch);\r\n                break;\r\n        }\r\n    }\r\n\r\n    return builder.ToString();\r\n}\r\n```\r\n\r\nAgain, pointers are ideal since each entry only identifies a single location.",
          "createdAt": "2024-03-31T22:14:15Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "HEART",
                "createdAt": "2024-04-01T21:57:02Z",
                "user": "ay-azara"
              },
              {
                "content": "HEART",
                "createdAt": "2025-01-22T15:55:43Z",
                "user": "pvanbuijtene"
              },
              {
                "content": "HEART",
                "createdAt": "2025-05-15T22:00:39Z",
                "user": "jlgingrich"
              }
            ],
            "totalCount": 3,
            "endCursor": "Y3Vyc29yOnYyOpHOEST2xA=="
          },
          "updatedAt": "2024-03-31T22:14:15Z",
          "id": "IC_kwDODI9FZc547wQX"
        },
        {
          "author": "ay-azara",
          "body": "@gregsdennis Thanks man, appreciate you taking the time :)",
          "createdAt": "2024-04-01T21:57:19Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-04-01T21:57:55Z",
          "id": "IC_kwDODI9FZc55CQxf"
        },
        {
          "author": "isaevdan",
          "body": "Any updates when this will be available? The issue is from 2019\nBTW Newtonsoft.Json has bugs in their implementation",
          "createdAt": "2024-11-25T10:03:51Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-11-25T10:04:35Z",
          "id": "IC_kwDODI9FZc6U3L7f"
        },
        {
          "author": "gregsdennis",
          "body": "@isaevdan as mentioned in a comment above, you can use JsonPath.Net if you need something now.",
          "createdAt": "2024-11-25T10:14:20Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-11-25T10:14:20Z",
          "id": "IC_kwDODI9FZc6U3T59"
        },
        {
          "author": "isaevdan",
          "body": "> [@isaevdan](https://github.com/isaevdan) as mentioned in a comment above, you can use JsonPath.Net if you need something now.\n\nYep, thanks and appreciate you work\nJust in progress in migrating to JsonPath.NET, but still weird it's not part of library :)",
          "createdAt": "2024-11-25T10:33:45Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-11-25T11:58:38Z",
                "user": "m3nax"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-11-25T13:10:33Z",
                "user": "macmarvin"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-11-25T16:14:21Z",
                "user": "frankhaugen"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-11-25T17:05:52Z",
                "user": "gregsdennis"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-12-10T19:36:45Z",
                "user": "BrycensRanch"
              }
            ],
            "totalCount": 5,
            "endCursor": "Y3Vyc29yOnYyOpHOD-cETw=="
          },
          "updatedAt": "2024-11-25T10:33:45Z",
          "id": "IC_kwDODI9FZc6U3pqB"
        },
        {
          "author": "isaevdan",
          "body": "Created JsonExtensions - wrapper with couple of  same methods as from NewtonsoftJson but with provided libraries, may be a good starting point for others who are going to do migration\n\n```\npublic static class JsonExtensions\n{\n    public static JsonNode SelectToken(this JsonNode node, string path,\n        PathEvaluationOptions options = null)\n    {\n        var jsonPath = JsonPath.Parse(path);\n        var matches = jsonPath.Evaluate(node, options).Matches;\n        if (matches.Count > 1)\n            throw new JsonException(\"Path returned multiple tokens.\");\n        return matches.FirstOrDefault()?.Value;\n    }\n\n    public static List<JsonNode> SelectTokens(this JsonNode node, string path,\n        PathEvaluationOptions options = null)\n    {\n        var jsonPath = JsonPath.Parse(path);\n        return\n            jsonPath.Evaluate(node, options)\n                .Matches\n                .Select(m => m.Value)\n                .ToList();\n    }\n\n    public static IList<JsonNode> Children(this JsonNode node)\n    {\n        return node switch\n        {\n            JsonArray array => array.ToList(),\n            JsonObject obj => obj.Select(e => e.Value).ToList(),\n            _ => []\n        };\n    }\n\n    public static JsonNode? ParseJsonNode(string text)\n    {\n        // Handle empty or null input text\n        if (string.IsNullOrWhiteSpace(text))\n        {\n            return null;\n        }\n\n        try\n        {\n            return JsonNode.Parse(text);\n        }\n        catch (JsonException)\n        {\n            return null;\n        }\n    }\n}\n```",
          "createdAt": "2024-11-25T13:23:03Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "HEART",
                "createdAt": "2024-11-25T13:47:13Z",
                "user": "ay-azara"
              },
              {
                "content": "HEART",
                "createdAt": "2024-11-25T16:14:35Z",
                "user": "frankhaugen"
              },
              {
                "content": "HEART",
                "createdAt": "2024-12-10T19:34:57Z",
                "user": "BrycensRanch"
              },
              {
                "content": "HEART",
                "createdAt": "2024-12-12T13:37:29Z",
                "user": "johniwasz"
              },
              {
                "content": "HEART",
                "createdAt": "2025-05-04T14:13:33Z",
                "user": "Meir017"
              }
            ],
            "totalCount": 5,
            "endCursor": "Y3Vyc29yOnYyOpHOEQuJ0A=="
          },
          "updatedAt": "2024-11-25T13:23:03Z",
          "id": "IC_kwDODI9FZc6U5Kkb"
        },
        {
          "author": "Meir017",
          "body": "https://github.com/json-everything/json-everything/tree/master/src/JsonPath can be used, and their docs https://docs.json-everything.net/path/basics/",
          "createdAt": "2025-04-29T05:04:46Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-04-29T08:08:37Z",
                "user": "ghadzhigeorgiev"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-06-26T09:24:14Z",
                "user": "erwinkramer"
              }
            ],
            "totalCount": 2,
            "endCursor": "Y3Vyc29yOnYyOpHOEYBPBg=="
          },
          "updatedAt": "2025-05-04T06:33:08Z",
          "id": "IC_kwDODI9FZc6pIDQZ"
        }
      ],
      "totalCount": 49,
      "endCursor": "Y3Vyc29yOnYyOpHORjC2Rw=="
    },
    "url": "https://github.com/dotnet/runtime/issues/31068",
    "title": "Add JsonPath support to JsonDocument/JsonElement"
  },
  {
    "author": "tb-mtg",
    "labels": [
      "api-suggestion",
      "area-System.Text.Json",
      "wishlist"
    ],
    "createdAt": "2019-11-08T02:24:51Z",
    "body": "Using System.Text.Json, is there any way to **Merge** like Json.Net does?\r\n\r\nsee Newtonsoft.Json.Linq.[JContainer.Merge](https://www.newtonsoft.com/json/help/html/M_Newtonsoft_Json_Linq_JContainer_Merge_1.htm)\r\n\r\n```\r\npublic void Merge(\r\n\tObject content,\r\n\tJsonMergeSettings settings\r\n)\r\n```",
    "number": 31433,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "THUMBS_UP",
          "createdAt": "2019-11-13T10:39:27Z",
          "user": "starnutoditopo"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2019-11-15T12:43:07Z",
          "user": "Ilchert"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2019-11-15T22:43:21Z",
          "user": "worldbeater"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2019-12-09T20:01:18Z",
          "user": "austindrenski"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2020-02-15T21:34:29Z",
          "user": "marian-margeta"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2020-11-04T15:37:21Z",
          "user": "edgythorn"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2020-11-25T16:21:12Z",
          "user": "zawor"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-04-13T05:03:41Z",
          "user": "CodeFontana"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-04-27T12:35:05Z",
          "user": "schmitch"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-05-10T00:17:38Z",
          "user": "binarynate"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-05-16T01:03:15Z",
          "user": "konrad-jamrozik"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-05-17T22:09:18Z",
          "user": "SamNutkins"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-06-11T16:26:08Z",
          "user": "Britvich"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-07-07T20:34:50Z",
          "user": "maxkoshevoi"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-07-14T21:57:32Z",
          "user": "mlafleur"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-08-10T18:49:23Z",
          "user": "Tiberriver256"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-10-06T09:31:10Z",
          "user": "Walluce"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-07-16T19:33:44Z",
          "user": "behrouz-s"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-09-27T18:25:40Z",
          "user": "mus65"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-01-03T06:45:35Z",
          "user": "sfmskywalker"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-01-09T22:08:15Z",
          "user": "umbarov"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-01-22T17:57:10Z",
          "user": "exytab"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-02-29T14:58:10Z",
          "user": "dp-sgr"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-03-08T15:48:38Z",
          "user": "a-gerasimov"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-03-15T01:00:28Z",
          "user": "ahdung"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-04-03T14:20:26Z",
          "user": "oleguchok"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-04-15T01:32:22Z",
          "user": "Kobus-Smit"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-04-24T07:13:24Z",
          "user": "alienwareone"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-06-30T13:51:41Z",
          "user": "meixger"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-08-02T08:05:16Z",
          "user": "enricobenedos"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-09-05T17:55:53Z",
          "user": "guimafelipe"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-10-16T02:39:04Z",
          "user": "issue-dispenser"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-10-29T20:28:01Z",
          "user": "Swimburger"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-11-11T15:00:39Z",
          "user": "TsvetanMilanov"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-11-25T19:38:19Z",
          "user": "chaimtevel"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-12-04T15:04:26Z",
          "user": "Bomret"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-02-16T05:19:22Z",
          "user": "adiamante"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-02-17T17:37:46Z",
          "user": "MarcusOtter"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-03-07T16:21:09Z",
          "user": "ryanewtaylor"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-03-13T21:09:07Z",
          "user": "cedx"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-03-18T17:42:05Z",
          "user": "AmelBawa-msft"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-05-25T05:33:03Z",
          "user": "douglasg14b"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-06-18T11:59:14Z",
          "user": "swh-cb"
        }
      ],
      "totalCount": 43,
      "endCursor": "Y3Vyc29yOnYyOpHODELo4Q=="
    },
    "updatedAt": "2025-05-25T21:04:43Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": "ahsonkhan",
          "body": "Since the `JsonDocument`, `JsonElement` APIs are read-only, you could workaround this by writing your own `Merge` method based on the `Utf8JsonWriter`.\r\n\r\nSuch an API makes more sense with the writable/modifiable DOM so we should consider adding this merge capability with that feature: https://github.com/dotnet/corefx/issues/39922\r\n\r\nIf your JSON objects **only contain non-null simple/primitive values** and the order in which the properties show up isn't particularly concerning, the following, relatively straightforward, code sample should work for you:\r\n\r\n```C#\r\npublic static string SimpleObjectMerge(string originalJson, string newContent)\r\n{\r\n    var outputBuffer = new ArrayBufferWriter<byte>();\r\n\r\n    using (JsonDocument jDoc1 = JsonDocument.Parse(originalJson))\r\n    using (JsonDocument jDoc2 = JsonDocument.Parse(newContent))\r\n    using (var jsonWriter = new Utf8JsonWriter(outputBuffer, new JsonWriterOptions { Indented = true }))\r\n    {\r\n        JsonElement root1 = jDoc1.RootElement;\r\n        JsonElement root2 = jDoc2.RootElement;\r\n\r\n        // Assuming both JSON strings are single JSON objects (i.e. {...})\r\n        Debug.Assert(root1.ValueKind == JsonValueKind.Object);\r\n        Debug.Assert(root2.ValueKind == JsonValueKind.Object);\r\n\r\n        jsonWriter.WriteStartObject();\r\n\r\n        // Write all the properties of the first document that don't conflict with the second\r\n        foreach (JsonProperty property in root1.EnumerateObject())\r\n        {\r\n            if (!root2.TryGetProperty(property.Name, out _))\r\n            {\r\n                property.WriteTo(jsonWriter);\r\n            }\r\n        }\r\n\r\n        // Write all the properties of the second document (including those that are duplicates which were skipped earlier)\r\n        // The property values of the second document completely override the values of the first\r\n        foreach (JsonProperty property in root2.EnumerateObject())\r\n        {\r\n            property.WriteTo(jsonWriter);\r\n        }\r\n\r\n        jsonWriter.WriteEndObject();\r\n    }\r\n\r\n    return Encoding.UTF8.GetString(outputBuffer.WrittenSpan);\r\n}\r\n```\r\n\r\n\r\n`Newtonsoft.Json` has different `null` handling when doing a merge where `null` doesn't override the value of the non-null property (when there are duplicates). I am not sure if you want that behavior or not. If that's needed, you would need to modify the above method to handle the `null` cases. Here are the modifications:\r\n\r\n```C#\r\npublic static string SimpleObjectMergeWithNullHandling(string originalJson, string newContent)\r\n{\r\n    var outputBuffer = new ArrayBufferWriter<byte>();\r\n\r\n    using (JsonDocument jDoc1 = JsonDocument.Parse(originalJson))\r\n    using (JsonDocument jDoc2 = JsonDocument.Parse(newContent))\r\n    using (var jsonWriter = new Utf8JsonWriter(outputBuffer, new JsonWriterOptions { Indented = true }))\r\n    {\r\n        JsonElement root1 = jDoc1.RootElement;\r\n        JsonElement root2 = jDoc2.RootElement;\r\n\r\n        // Assuming both JSON strings are single JSON objects (i.e. {...})\r\n        Debug.Assert(root1.ValueKind == JsonValueKind.Object);\r\n        Debug.Assert(root2.ValueKind == JsonValueKind.Object);\r\n\r\n        jsonWriter.WriteStartObject();\r\n\r\n        // Write all the properties of the first document that don't conflict with the second\r\n        // Or if the second is overriding it with null, favor the property in the first.\r\n        foreach (JsonProperty property in root1.EnumerateObject())\r\n        {\r\n            if (!root2.TryGetProperty(property.Name, out JsonElement newValue) || newValue.ValueKind == JsonValueKind.Null)\r\n            {\r\n                property.WriteTo(jsonWriter);\r\n            }\r\n        }\r\n\r\n        // Write all the properties of the second document (including those that are duplicates which were skipped earlier)\r\n        // The property values of the second document completely override the values of the first, unless they are null in the second.\r\n        foreach (JsonProperty property in root2.EnumerateObject())\r\n        {\r\n            // Don't write null values, unless they are unique to the second document\r\n            if (property.Value.ValueKind != JsonValueKind.Null || !root1.TryGetProperty(property.Name, out _))\r\n            {\r\n                property.WriteTo(jsonWriter);\r\n            }\r\n        }\r\n\r\n        jsonWriter.WriteEndObject();\r\n    }\r\n\r\n    return Encoding.UTF8.GetString(outputBuffer.WrittenSpan);\r\n}\r\n```\r\n\r\n**If your JSON objects can potentially contain nested JSON values including other objects and arrays**, you would want to extend the logic to handle that too. Something like this should work:\r\n```C#\r\npublic static string Merge(string originalJson, string newContent)\r\n{\r\n    var outputBuffer = new ArrayBufferWriter<byte>();\r\n\r\n    using (JsonDocument jDoc1 = JsonDocument.Parse(originalJson))\r\n    using (JsonDocument jDoc2 = JsonDocument.Parse(newContent))\r\n    using (var jsonWriter = new Utf8JsonWriter(outputBuffer, new JsonWriterOptions { Indented = true }))\r\n    {\r\n        JsonElement root1 = jDoc1.RootElement;\r\n        JsonElement root2 = jDoc2.RootElement;\r\n\r\n        if (root1.ValueKind != JsonValueKind.Array && root1.ValueKind != JsonValueKind.Object)\r\n        {\r\n            throw new InvalidOperationException($\"The original JSON document to merge new content into must be a container type. Instead it is {root1.ValueKind}.\");\r\n        }\r\n\r\n        if (root1.ValueKind != root2.ValueKind)\r\n        {\r\n            return originalJson;\r\n        }\r\n\r\n        if (root1.ValueKind == JsonValueKind.Array)\r\n        {\r\n            MergeArrays(jsonWriter, root1, root2);\r\n        }\r\n        else\r\n        {\r\n            MergeObjects(jsonWriter, root1, root2);\r\n        }\r\n    }\r\n\r\n    return Encoding.UTF8.GetString(outputBuffer.WrittenSpan);\r\n}\r\n\r\nprivate static void MergeObjects(Utf8JsonWriter jsonWriter, JsonElement root1, JsonElement root2)\r\n{\r\n    Debug.Assert(root1.ValueKind == JsonValueKind.Object);\r\n    Debug.Assert(root2.ValueKind == JsonValueKind.Object);\r\n\r\n    jsonWriter.WriteStartObject();\r\n\r\n    // Write all the properties of the first document.\r\n    // If a property exists in both documents, either:\r\n    // * Merge them, if the value kinds match (e.g. both are objects or arrays),\r\n    // * Completely override the value of the first with the one from the second, if the value kind mismatches (e.g. one is object, while the other is an array or string),\r\n    // * Or favor the value of the first (regardless of what it may be), if the second one is null (i.e. don't override the first).\r\n    foreach (JsonProperty property in root1.EnumerateObject())\r\n    {\r\n        string propertyName = property.Name;\r\n\r\n        JsonValueKind newValueKind;\r\n\r\n        if (root2.TryGetProperty(propertyName, out JsonElement newValue) && (newValueKind = newValue.ValueKind) != JsonValueKind.Null)\r\n        {\r\n            jsonWriter.WritePropertyName(propertyName);\r\n\r\n            JsonElement originalValue = property.Value;\r\n            JsonValueKind originalValueKind = originalValue.ValueKind;\r\n\r\n            if (newValueKind == JsonValueKind.Object && originalValueKind == JsonValueKind.Object)\r\n            {\r\n                MergeObjects(jsonWriter, originalValue, newValue); // Recursive call\r\n            }\r\n            else if (newValueKind == JsonValueKind.Array && originalValueKind == JsonValueKind.Array)\r\n            {\r\n                MergeArrays(jsonWriter, originalValue, newValue);\r\n            }\r\n            else\r\n            {\r\n                newValue.WriteTo(jsonWriter);\r\n            }\r\n        }\r\n        else\r\n        {\r\n            property.WriteTo(jsonWriter);\r\n        }\r\n    }\r\n\r\n    // Write all the properties of the second document that are unique to it.\r\n    foreach (JsonProperty property in root2.EnumerateObject())\r\n    {\r\n        if (!root1.TryGetProperty(property.Name, out _))\r\n        {\r\n            property.WriteTo(jsonWriter);\r\n        }\r\n    }\r\n\r\n    jsonWriter.WriteEndObject();\r\n}\r\n\r\nprivate static void MergeArrays(Utf8JsonWriter jsonWriter, JsonElement root1, JsonElement root2)\r\n{\r\n    Debug.Assert(root1.ValueKind == JsonValueKind.Array);\r\n    Debug.Assert(root2.ValueKind == JsonValueKind.Array);\r\n\r\n    jsonWriter.WriteStartArray();\r\n\r\n    // Write all the elements from both JSON arrays\r\n    foreach (JsonElement element in root1.EnumerateArray())\r\n    {\r\n        element.WriteTo(jsonWriter);\r\n    }\r\n    foreach (JsonElement element in root2.EnumerateArray())\r\n    {\r\n        element.WriteTo(jsonWriter);\r\n    }\r\n\r\n    jsonWriter.WriteEndArray();\r\n}\r\n```\r\n\r\nThis sample was tested with the following:\r\n```C#\r\n[Fact]\r\npublic static void JsonDocumentMergeTest_ComparedToJContainerMerge()\r\n{\r\n    string jsonString1 = @\"{\r\n        \"\"throw\"\": null,\r\n        \"\"duplicate\"\": null,\r\n        \"\"id\"\": 1,\r\n        \"\"xyz\"\": null,\r\n        \"\"nullOverride2\"\": false,\r\n        \"\"nullOverride1\"\": null,\r\n        \"\"william\"\": \"\"shakespeare\"\",\r\n        \"\"complex\"\": {\"\"overwrite\"\": \"\"no\"\", \"\"type\"\": \"\"string\"\", \"\"original\"\": null, \"\"another\"\":[]},\r\n        \"\"nested\"\": [7, {\"\"another\"\": true}],\r\n        \"\"nestedObject\"\": {\"\"another\"\": true}\r\n    }\";\r\n\r\n    string jsonString2 = @\"{\r\n        \"\"william\"\": \"\"dafoe\"\",\r\n        \"\"duplicate\"\": null,\r\n        \"\"foo\"\": \"\"bar\"\",\r\n        \"\"baz\"\": {\"\"temp\"\": 4},\r\n        \"\"xyz\"\": [1, 2, 3],\r\n        \"\"nullOverride1\"\": true,\r\n        \"\"nullOverride2\"\": null,\r\n        \"\"nested\"\": [1, 2, 3, null, {\"\"another\"\": false}],\r\n        \"\"nestedObject\"\": [\"\"wow\"\"],\r\n        \"\"complex\"\": {\"\"temp\"\": true, \"\"overwrite\"\": \"\"ok\"\", \"\"type\"\": 14},\r\n        \"\"temp\"\": null\r\n    }\";\r\n\r\n    JObject jObj1 = JObject.Parse(jsonString1);\r\n    JObject jObj2 = JObject.Parse(jsonString2);\r\n\r\n    jObj1.Merge(jObj2);\r\n    jObj2.Merge(JObject.Parse(jsonString1));\r\n\r\n    Assert.Equal(jObj1.ToString(), Merge(jsonString1, jsonString2));\r\n    Assert.Equal(jObj2.ToString(), Merge(jsonString2, jsonString1));\r\n}\r\n```\r\n\r\n**Note:** If performance is critical for your scenario, this method (even with writing indented) out-performs the Newtonsoft.Json's `Merge` method both in terms of runtime and allocations. That said, the implementation could be made faster depending on need (for instance, don't write indented, cache the `outputBuffer`, don't accept/return strings, etc.).\r\n\r\n``` ini\r\n\r\nBenchmarkDotNet=v0.12.0, OS=Windows 10.0.19041\r\nIntel Core i7-6700 CPU 3.40GHz (Skylake), 1 CPU, 8 logical and 4 physical cores\r\n.NET Core SDK=5.0.100-alpha1-015914\r\n  [Host]     : .NET Core 5.0.0 (CoreCLR 5.0.19.56303, CoreFX 5.0.19.56306), X64 RyuJIT\r\n  Job-LACFYV : .NET Core 5.0.0 (CoreCLR 5.0.19.56303, CoreFX 5.0.19.56306), X64 RyuJIT\r\n\r\nPowerPlanMode=00000000-0000-0000-0000-000000000000  \r\n\r\n```\r\n|          Method |     Mean |    Error |   StdDev |   Median |      Min |      Max | Ratio |  Gen 0 |  Gen 1 | Gen 2 | Allocated |\r\n|---------------- |---------:|---------:|---------:|---------:|---------:|---------:|------:|-------:|-------:|------:|----------:|\r\n| MergeNewtonsoft | 29.01 us | 0.570 us | 0.656 us | 28.84 us | 28.13 us | 30.19 us |  1.00 | 7.0801 | 0.0610 |     - |  28.98 KB |\r\n|       Merge_New | 16.41 us | 0.293 us | 0.274 us | 16.41 us | 16.02 us | 17.00 us |  0.57 | 1.7090 |      - |     - |   6.99 KB |\r\n\r\n```C#\r\n[BenchmarkCategory(Categories.CoreFX, Categories.JSON)]\r\n[Benchmark(Baseline = true)]\r\npublic string MergeNewtonsoft()\r\n{\r\n    JObject jObj1 = JObject.Parse(_jsonString1);\r\n    JObject jObj2 = JObject.Parse(_jsonString2);\r\n\r\n    jObj1.Merge(jObj2);\r\n\r\n    return jObj1.ToString();\r\n}\r\n\r\n[BenchmarkCategory(Categories.CoreFX, Categories.JSON)]\r\n[Benchmark]\r\npublic string Merge_New()\r\n{\r\n    return Merge(_jsonString1, _jsonString2);\r\n}\r\n```",
          "createdAt": "2020-01-03T06:18:31Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2020-01-06T01:24:54Z",
                "user": "tb-mtg"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2020-03-02T10:56:17Z",
                "user": "hmG3"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2020-08-30T15:17:39Z",
                "user": "RowlandBanks"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2020-09-23T14:04:14Z",
                "user": "MarioGruda"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2020-09-27T07:46:55Z",
                "user": "Arithmomaniac"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2020-11-23T02:39:26Z",
                "user": "dpr-dev"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2020-11-25T16:21:20Z",
                "user": "zawor"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-03-09T17:19:17Z",
                "user": "shupoval"
              },
              {
                "content": "HEART",
                "createdAt": "2021-05-25T20:13:16Z",
                "user": "twentytwokhz"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-06-02T02:28:07Z",
                "user": "saber-wang"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-09-27T18:53:07Z",
                "user": "andreibancioiu"
              },
              {
                "content": "HEART",
                "createdAt": "2021-09-27T18:53:10Z",
                "user": "andreibancioiu"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-01-06T11:37:20Z",
                "user": "FTWinston"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-01-13T12:31:49Z",
                "user": "loftum"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-02-17T07:59:17Z",
                "user": "Hyperyx"
              },
              {
                "content": "HEART",
                "createdAt": "2023-12-15T08:22:32Z",
                "user": "imiljkovic"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-03-08T15:49:50Z",
                "user": "a-gerasimov"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-09-04T09:04:14Z",
                "user": "HyphonGuo"
              },
              {
                "content": "HEART",
                "createdAt": "2024-09-05T09:25:09Z",
                "user": "asimmon"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-07-16T15:46:35Z",
                "user": "Mornante"
              }
            ],
            "totalCount": 20,
            "endCursor": "Y3Vyc29yOnYyOpHOEaz0TA=="
          },
          "updatedAt": "2020-01-03T06:33:40Z",
          "id": "MDEyOklzc3VlQ29tbWVudDU3MDQ3NTg1Mw=="
        },
        {
          "author": "tb-mtg",
          "body": "Thank you @ahsonkhan, hopefully this feature will be added.",
          "createdAt": "2020-01-06T01:36:32Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2020-01-06T01:36:32Z",
          "id": "MDEyOklzc3VlQ29tbWVudDU3MDk3MjYxNA=="
        },
        {
          "author": "ahsonkhan",
          "body": "@tb-mtg, as part of requirements, can you expand on your scenarios and what [JsonMergeSettings](https://www.newtonsoft.com/json/help/html/T_Newtonsoft_Json_Linq_JsonMergeSettings.htm) capabilities are necessary for the Merge APIs (for example `MergeArrayHandling`, `MergeNullValueHandling`, `PropertyNameComparison`).\r\n\r\nAre there others that `Newtonsoft.Json` doesn't support that would be needed? Do you generally merge two `JObjects`, or is it common to merge any two arbitrary `JContainers`? What should the behavior be of `JArray.Merge(some single JToken)`?\r\n\r\nAlso, what is your particular use case for such an API? Having context around sample usage would help answer some of the requirement questions as well.\r\n\r\n",
          "createdAt": "2020-01-07T02:03:47Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2020-01-07T02:04:48Z",
          "id": "MDEyOklzc3VlQ29tbWVudDU3MTM5OTA0OA=="
        },
        {
          "author": "vijer",
          "body": "Is there a way to do a join? I have two different json files with a common key and I've been looking for a way to filter and join the output. \r\n\r\nFor example, the controlling file contains categories and the items are in another file.  The filter would be where(rc.CategoryID == tt.CategoryID && rc.CategoryID == \"metals\" && tt.GameVersion == \"A\" || tt.GameVersion == \"2\")\r\n\r\nAll the examples I find are related to merging two files with the same structure. \r\n\r\n```\r\n\"ResourceCategories\": [\r\n    {\r\n      \"CategoryDescription\": \"Base Upgrades\",\r\n      \"CategoryID\": \"baseupgrades\",\r\n      \"IncludeCategory\": true,\r\n      \"GameVersion\": \"A\"\r\n    },\r\n```\r\n\r\nand the item file\r\n\r\n```\r\n\"TechType\": [\r\n    {\r\n      \"CategoryID\": \"crystalline\",\r\n      \"TechName\": \"Quartz\",\r\n      \"SpawnID\": \"quartz\",\r\n      \"TechID\": 1,\r\n      \"GameVersion\": \"A\"\r\n    },\r\n    {\r\n      \"CategoryID\": \"metals\",\r\n      \"TechName\": \"Metal Salvage\",\r\n      \"SpawnID\": \"scrapmetal\",\r\n      \"TechID\": 2,\r\n      \"GameVersion\": \"A\"\r\n    },\r\n    {\r\n      \"CategoryID\": \"outcrop\",\r\n      \"TechName\": \"Limestone Outcrop\",\r\n      \"SpawnID\": \"limestonechunk\",\r\n      \"TechID\": 4,\r\n      \"GameVersion\": \"A\"\r\n    },\r\n```",
          "createdAt": "2021-05-31T10:11:42Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-05-31T10:11:42Z",
          "id": "MDEyOklzc3VlQ29tbWVudDg1MTM4MzU1NQ=="
        },
        {
          "author": "PeterWone",
          "body": "> Is there a way to do a join? I have two different json files with a common key and I've been looking for a way to filter and join the output.\r\n\r\nGet the graphs as Json objects and use LINQ.",
          "createdAt": "2021-09-02T05:37:33Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-09-02T05:37:33Z",
          "id": "IC_kwDODI9FZc42T_Nx"
        },
        {
          "author": "eiriktsarpalis",
          "body": "I believe the new [`JsonNode`](https://docs.microsoft.com/en-us/dotnet/api/system.text.json.nodes.jsonnode?view=net-6.0) type that ships with .NET 6 might be more appropriate to expose this type of functionality. APIs are currently missing, but they are fairly easy to implement as extensions methods:\r\n```csharp\r\npublic static class JsonNodeExtensions\r\n{ \r\n    public static void AddRange(this JsonArray jsonArray, IEnumerable<JsonNode?> values)\r\n    {\r\n        foreach (var value in values)\r\n        {\r\n            jsonArray.Add(value);\r\n        }\r\n    }\r\n\r\n    public static void AddRange(this JsonObject jsonObject, IEnumerable<KeyValuePair<string, JsonNode?>> properties)\r\n    {\r\n        foreach (var kvp in properties)\r\n        {\r\n            jsonObject.Add(kvp);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\ncc @steveharter",
          "createdAt": "2021-10-25T18:06:13Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-10-25T18:07:18Z",
          "id": "IC_kwDODI9FZc44sb_7"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Closing in favor of #56592.",
          "createdAt": "2022-01-13T20:13:48Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-01-13T20:13:48Z",
          "id": "IC_kwDODI9FZc48WTs4"
        },
        {
          "author": "steveharter",
          "body": "I have concerns about add this feature when the options are not a simple \"ignore\" or \"replace\".\r\n\r\nThe existing semantics of Newtonsoft's `MergeNullValueHandling` and `PropertyNameComparison` are fairly intuitive however  the [MergeArrayHandling](https://www.newtonsoft.com/json/help/html/P_Newtonsoft_Json_Linq_JsonMergeSettings_MergeArrayHandling.htm) option is not. This option applies to both JSON arrays and JSON objects, and works fine if just \"ignore\" or \"replace\" is desired, but a \"merge\" requires an Equals() method which for JSON objects would typically be based on a \"key property\", and perhaps even a \"type identifier property\". For \"union\" that is a separate discussion for objects vs arrays. For ordered JSON arrays, the \"key\" could be the ordinal, but I think in many cases a true \"key\" would be desired. For these non-trivial merge cases, I believe Newtonsoft does a DeepEquals() here -- however that is not likely the expected behavior for these cases.\r\n\r\nSo I believe there are many scenarios where a \"merge\" done on objects would want a \"key property\" that typically relates to the primary key in a database. Without such a key, a \"merge\" would likely combine the properties of two independent objects which will likely not be incorrect. Consider:\r\n```\r\nCurrent Json:\r\n[\r\n{\"ID\":100, \"Name\":\"Steve\", \"PhoneExtension\":111},\r\n{\"ID\":101, \"Name\":\"Joe\", \"PhoneExtension\":222}\r\n]\r\n\r\nJSON to merge:\r\n[\r\n{\"ID\":101, \"PhoneExtension\":333}\r\n]\r\n\r\nResult? Normally I'd expect this\r\n[\r\n{\"ID\":100, \"Name\":\"Steve\", \"PhoneExtension\":111},\r\n{\"ID\":101, \"Name\":\"Joe\", \"PhoneExtension\":333}\r\n]\r\n\r\nand not, for example\r\n[\r\n{\"ID\":100, \"Name\":\"Steve\", \"PhoneExtension\":111},\r\n{\"ID\":101, \"Name\":\"Joe\", \"PhoneExtension\":222},\r\n{\"PhoneExtension\":333}\r\n]\r\n```\r\n\r\nAlso, since the options [should] apply throughout all nodes in the graph, recursively, (note they don't in Newtonsoft with \"concat\" and \"union\") some based on \"keys\" and some not, I don't see how useful this feature with merge\\union would be.\r\n\r\nSome options IMO:\r\n- Eirik's extension example [above ](https://github.com/dotnet/runtime/issues/31433#issuecomment-951173115) could be used for simple cases that don't have to deal with \"keys\", and at only one level (not recursive).\r\n- Extend Eirik's extension sample to provide a \"key\" property (probably needs to be a simple JsonValue type).\r\n- Add a callback pattern where the consumer needs to specify the \"replace\" or \"ignore\" semantics and perhaps \"merge\\union\" where custom logic would use the current Path of each node to determine the key and related merge semantics.\r\n- Add the concept of a \"key\" property to `JsonNode` by allowing it to be set on each node.",
          "createdAt": "2022-01-25T00:45:48Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-01-25T00:45:48Z",
          "id": "IC_kwDODI9FZc481pMM"
        },
        {
          "author": "PeterWone",
          "body": "@steveharter I think you're right. \r\n\r\nThe workaround offered to me was very practical and it is not difficult to use it to to handle the issues you mention. Personally I like the simplicity of merge as something you produce from two immutable graphs. ",
          "createdAt": "2022-01-25T00:54:27Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-01-25T00:54:27Z",
          "id": "IC_kwDODI9FZc481qX7"
        },
        {
          "author": "cajuncoding",
          "body": "For anyone else finding this thread while looking for a `SystemTextJson` compatible way to merge Json objects the way that `NewtonsoftJson` allowed, the new(er) JsonObject, JsonArray, and (their base) JsonNode provide a reasonably decent way to approach this and appear to be a lot more streamlined (less code) than the `JsonDocument` solution provided [above ](https://github.com/dotnet/runtime/issues/31433#issuecomment-570475853)by @ahsonkhan .\r\n\r\nHere's a streamlined implementation that has solved my use cases.  I haven't had any time yet to benchmark this against the JsonDocument approach above, or Newtonsoft for that matter, but other Json rewriting solutions I've implemented with System.Text.Json all proved to be significantly faster than the exact same logic with Newtonsoft.\r\n\r\nThe full solution below is also shared out via [my gist here . . .](https://gist.github.com/cajuncoding/bf78bdcf790782090d231590cbc2438f)  but I'm including here for posterity:\r\n\r\n_**EDIT: 07/11/2024 - Updated code to correctly fix missing handling when an object property value is actually a Json Array as described by @IdrissPiard below.**_\r\n\r\n```csharp\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text.Json;\r\nusing System.Text.Json.Nodes;\r\n\r\nnamespace CajunCoding\r\n{\r\n    public static class SystemTextJsonMergeExtensions\r\n    {\r\n        /// <summary>\r\n        /// Merges the specified Json Node into the base JsonNode for which this method is called.\r\n        /// It is null safe and can be easily used with null-check & null coalesce operators for fluent calls.\r\n        /// NOTE: JsonNodes are context aware and track their parent relationships therefore to merge the values both JsonNode objects\r\n        ///         specified are mutated. The Base is mutated with new data while the source is mutated to remove reverences to all\r\n        ///         fields so that they can be added to the base.\r\n        ///\r\n        /// Source taken directly from the open-source Gist here:\r\n        /// https://gist.github.com/cajuncoding/bf78bdcf790782090d231590cbc2438f\r\n        ///\r\n        /// </summary>\r\n        /// <param name=\"jsonBase\"></param>\r\n        /// <param name=\"jsonMerge\"></param>\r\n        /// <returns></returns>\r\n        /// <exception cref=\"ArgumentException\"></exception>\r\n        public static JsonNode Merge(this JsonNode jsonBase, JsonNode jsonMerge)\r\n        {\r\n            if (jsonBase == null || jsonMerge == null)\r\n                return jsonBase;\r\n\r\n            switch (jsonBase)\r\n            {\r\n                case JsonObject jsonBaseObj when jsonMerge is JsonObject jsonMergeObj:\r\n                {\r\n                    //NOTE: We must materialize the set (e.g. to an Array), and then clear the merge array so the node can then be \r\n                    //      re-assigned to the target/base Json; clearing the Object seems to be the most efficient approach...\r\n                    var mergeNodesArray = jsonMergeObj.ToArray();\r\n                    jsonMergeObj.Clear();\r\n                    \r\n                    foreach (var prop in mergeNodesArray)\r\n                    {\r\n                        jsonBaseObj[prop.Key] = jsonBaseObj[prop.Key] switch\r\n                        {\r\n                            JsonObject jsonBaseChildObj when prop.Value is JsonObject jsonMergeChildObj => jsonBaseChildObj.Merge(jsonMergeChildObj),\r\n                            JsonArray jsonBaseChildArray when prop.Value is JsonArray jsonMergeChildArray => jsonBaseChildArray.Merge(jsonMergeChildArray),\r\n                            _ => prop.Value\r\n                        };\r\n                    }\r\n                    break;\r\n                }\r\n                case JsonArray jsonBaseArray when jsonMerge is JsonArray jsonMergeArray:\r\n                {\r\n                    //NOTE: We must materialize the set (e.g. to an Array), and then clear the merge array,\r\n                    //      so they can then be re-assigned to the target/base Json...\r\n                    var mergeNodesArray = jsonMergeArray.ToArray();\r\n                    jsonMergeArray.Clear();\r\n                    foreach(var mergeNode in mergeNodesArray) jsonBaseArray.Add(mergeNode);\r\n                    break;\r\n                }\r\n                default:\r\n                    throw new ArgumentException($\"The JsonNode type [{jsonBase.GetType().Name}] is incompatible for merging with the target/base \" +\r\n                                                        $\"type [{jsonMerge.GetType().Name}]; merge requires the types to be the same.\");\r\n                \r\n            }\r\n\r\n            return jsonBase;\r\n        }\r\n\r\n        /// <summary>\r\n        /// Merges the specified Dictionary of values into the base JsonNode for which this method is called.\r\n        /// </summary>\r\n        /// <typeparam name=\"TKey\"></typeparam>\r\n        /// <typeparam name=\"TValue\"></typeparam>\r\n        /// <param name=\"jsonBase\"></param>\r\n        /// <param name=\"dictionary\"></param>\r\n        /// <param name=\"options\"></param>\r\n        /// <returns></returns>\r\n        public static JsonNode MergeDictionary<TKey, TValue>(this JsonNode jsonBase, IDictionary<TKey, TValue> dictionary, JsonSerializerOptions options = null)\r\n            => jsonBase.Merge(JsonSerializer.SerializeToNode(dictionary, options));\r\n    }\r\n}\r\n```\r\n\r\n",
          "createdAt": "2024-06-05T05:26:54Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-06-26T14:33:56Z",
                "user": "jsgoupil"
              },
              {
                "content": "HEART",
                "createdAt": "2024-06-27T14:03:19Z",
                "user": "meixger"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-07-28T08:12:01Z",
                "user": "johnnypea"
              }
            ],
            "totalCount": 3,
            "endCursor": "Y3Vyc29yOnYyOpHOEcIRzw=="
          },
          "updatedAt": "2024-07-12T04:43:32Z",
          "id": "IC_kwDODI9FZc6AFWMf"
        },
        {
          "author": "IdrissPiard",
          "body": "@cajuncoding Hey, I noticed on the members of the jsonBaseObj you only recurse if the member is of type JsonObject. But that exclude JsonArray as the parent type is JsonNode not JsonObject. \r\nThat means that you only ever go into the second case if the first call to Merge was done with JsonArray, and it also means it overwrites every arrays with the merge ones, erasing the source array content. \r\nIn case that isn't the intended behavior, the code should probably be something like:\r\n\r\n``` C#\r\n/// <summary>\r\n/// Merges the specified Json Node into the base JsonNode for which this method is called.\r\n/// It is null safe and can be easily used with null-check & null coalesce operators for fluent calls.\r\n/// NOTE: JsonNodes are context aware and track their parent relationships therefore to merge the values both JsonNode objects\r\n///         specified are mutated. The Base is mutated with new data while the source is mutated to remove reverences to all\r\n///         fields so that they can be added to the base.\r\n///\r\n/// Source taken directly from the open-source Gist here:\r\n/// https://gist.github.com/cajuncoding/bf78bdcf790782090d231590cbc2438f\r\n///\r\n/// </summary>\r\n/// <param name=\"jsonBase\"></param>\r\n/// <param name=\"jsonMerge\"></param>\r\n/// <returns></returns>\r\n/// <exception cref=\"ArgumentException\"></exception>\r\npublic static JsonNode Merge( this JsonNode jsonBase, JsonNode jsonMerge )\r\n{\r\n\tif(jsonBase == null || jsonMerge == null)\r\n\t\treturn jsonBase;\r\n\r\n\tswitch(jsonBase)\r\n\t{\r\n\tcase JsonObject jsonBaseObj when jsonMerge is JsonObject jsonMergeObj:\r\n\t\t{\r\n\t\t\t//NOTE: We must materialize the set (e.g. to an Array), and then clear the merge array so the node can then be \r\n\t\t\t//      re-assigned to the target/base Json; clearing the Object seems to be the most efficient approach...\r\n\t\t\tvar mergeNodesArray = jsonMergeObj.ToArray();\r\n\t\t\tjsonMergeObj.Clear();\r\n\r\n\t\t\tforeach(var prop in mergeNodesArray)\r\n\t\t\t{\r\n\t\t\t\tif(jsonBaseObj[ prop.Key ] is JsonNode jsonBaseChildNode && prop.Value is JsonNode jsonMergeChildNode)\r\n\t\t\t\t\tjsonBaseObj[ prop.Key ] = jsonBaseChildNode.Merge( jsonMergeChildNode );\r\n\t\t\t\telse\r\n\t\t\t\t\tjsonBaseObj[ prop.Key ] = prop.Value;\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\t}\r\n\tcase JsonArray jsonBaseArray when jsonMerge is JsonArray jsonMergeArray:\r\n\t\t{\r\n\t\t\t//NOTE: We must materialize the set (e.g. to an Array), and then clear the merge array,\r\n\t\t\t//      so they can then be re-assigned to the target/base Json...\r\n\t\t\tvar mergeNodesArray = jsonMergeArray.ToArray();\r\n\t\t\tjsonMergeArray.Clear();\r\n\t\t\tforeach(var mergeNode in mergeNodesArray) jsonBaseArray.Add( mergeNode );\r\n\t\t\tbreak;\r\n\t\t}\r\n\tdefault:\r\n\t\tthrow new ArgumentException( $\"The JsonNode type [{jsonBase.GetType().Name}] is incompatible for merging with the target/base \" +\r\n\t\t\t\t\t\t\t\t\t\t\t$\"type [{jsonMerge.GetType().Name}]; merge requires the types to be the same.\" );\r\n\r\n\t}\r\n\r\n\treturn jsonBase;\r\n}\r\n\r\n/// <summary>\r\n/// Merges the specified Dictionary of values into the base JsonNode for which this method is called.\r\n/// </summary>\r\n/// <typeparam name=\"TKey\"></typeparam>\r\n/// <typeparam name=\"TValue\"></typeparam>\r\n/// <param name=\"jsonBase\"></param>\r\n/// <param name=\"dictionary\"></param>\r\n/// <param name=\"options\"></param>\r\n/// <returns></returns>\r\npublic static JsonNode MergeDictionary<TKey, TValue>( this JsonNode jsonBase, IDictionary<TKey, TValue> dictionary, JsonSerializerOptions options = null )\r\n\t=> jsonBase.Merge( JsonSerializer.SerializeToNode( dictionary, options ) );\r\n```\r\n\r\n",
          "createdAt": "2024-07-11T11:50:45Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "EYES",
                "createdAt": "2024-07-11T19:09:49Z",
                "user": "meixger"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHODpW4aQ=="
          },
          "updatedAt": "2024-07-11T11:50:45Z",
          "id": "IC_kwDODI9FZc6EfBo1"
        },
        {
          "author": "cajuncoding",
          "body": "@IdrissPiard Unfortunately your proposed changes won't work and fail my unit test -- because `JsonValue` is also a `JsonNode`, and that results in hitting the type mismatch exception thrown by the top level logic of the merge process; which is needed to prevent infinite recursion.\r\n\r\nBut, you do raise a great point 👍in that I am missing a case whereby a property of a nested object might actually be a `JsonArray` and that case is missed; this wasn't covered my my initial use cases. The safe solution is actually to add an additional case to handle `JsonArray` just like the `JsonObject`....\r\n\r\nI have updated my code above, and also updated this in my original Gist.  In addition, for the reference of other's I've [added the Unit Test case](https://gist.github.com/cajuncoding/bf78bdcf790782090d231590cbc2438f?permalink_comment_id=5118888#gistcomment-5118888) that validates the common cases I've tested to my Gist thread -- and it now includes validation of this case also ✅.\r\n\r\n_fyi, your code formatter (or something) introduced some odd spacing & indentation changes so I had to normalize all that to see the differences..._",
          "createdAt": "2024-07-12T04:39:31Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "HEART",
                "createdAt": "2024-07-12T07:42:19Z",
                "user": "meixger"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-07-12T14:32:30Z",
                "user": "IdrissPiard"
              }
            ],
            "totalCount": 2,
            "endCursor": "Y3Vyc29yOnYyOpHODphEYg=="
          },
          "updatedAt": "2024-07-12T04:45:56Z",
          "id": "IC_kwDODI9FZc6EmGIM"
        },
        {
          "author": "TonyValenti",
          "body": "Hi All,\nI could really use the ability to merge JSON documents together as well.",
          "createdAt": "2025-01-21T10:50:52Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-01-21T10:50:52Z",
          "id": "IC_kwDODI9FZc6bO6wW"
        },
        {
          "author": "cajuncoding",
          "body": "@douglasg14b  if my gist works for your use case then it’s a fairly small bit of code to include… because otherwise `System.Text.Json` is quite amazing and for what it does handle it does it really really well!\n\nI may decide to push it to Nuget as a package for easy use…just thought it was small enough that a gist would suffice.\n\nUnrelated to the thread…but you are not foolish for recommending .Net (C#)… The real value of .Net is after JSON is deserialized into strongly typed compile safe code…there are many other more compelling reasons to consider .Net over JS+TypeScript…",
          "createdAt": "2025-05-25T07:02:22Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-05-25T07:28:20Z",
                "user": "meixger"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-05-25T21:05:00Z",
                "user": "douglasg14b"
              },
              {
                "content": "HEART",
                "createdAt": "2025-05-25T21:05:02Z",
                "user": "douglasg14b"
              }
            ],
            "totalCount": 3,
            "endCursor": "Y3Vyc29yOnYyOpHOETsGPQ=="
          },
          "updatedAt": "2025-05-25T07:02:49Z",
          "id": "IC_kwDODI9FZc6tT0bk"
        }
      ],
      "totalCount": 14,
      "endCursor": "Y3Vyc29yOnYyOpHOrU9G5A=="
    },
    "url": "https://github.com/dotnet/runtime/issues/31433",
    "title": "System.Text.Json Merge"
  },
  {
    "author": "ollie10",
    "labels": [
      "api-needs-work",
      "area-System.Text.Json"
    ],
    "createdAt": "2020-01-05T20:29:25Z",
    "body": "Hi, I'm stuck on this problem\r\n**.Net Core 3.1 Web App** with a page that uses **Google Maps Autocomplete** and I need to save the address and coordinates (**Latitude / Longitude as decimals**).\r\n\r\nCreating an **object in javascript** and sending it to the controller via **jQuery Ajax**.\r\n\r\nThe problem is the following:\r\n\r\n- I'm using the default **System.Text.Json** serializer / deserializer\r\n- The decimal values returned by **google Js** API are in this format: _**55.7539619**_ (for example)\r\n- I use a **route parameter to set statically the Culture** like site.com/spain/ for **es-ES** site.com/russia/ for **ru-RU**\r\n\r\nIn the controller all the other properties arrive correctly except the latitude and longitude which are **decimals**\r\n\r\nThe problem arises when a culture is being used and the number is not in the format of that culture in the way that the separator is comma (for Spain for example) and not the point (which is standard for javascript)\r\n\r\nSo i looked for some solutions but none of them seems solving completely the problem:\r\n\r\n- i could replace the dot with comma before sending but it won't work for US culture for example, and besides that I would lose precision\r\n\r\nIn Newtonsoft Json there was the possibility to specify the Culture as options of the serializer but System.Text.Json doesn't have a property like that.\r\nI think that System.Text.Json should deserialize Json in the correct format more than 'interpreting' the culture\r\n\r\nThis is the code I'm using:\r\n\r\n```javascript\r\npropertyToSave.OtherProp = 'text' // arrives correctly as all the other properties\r\npropertyToSave.Latitude = selectedPlace.geometry.location.lat(); //val: 55.7539619\r\npropertyToSave.Longitude = selectedPlace.geometry.location.lng();// val: 37.60819619999995\r\n\r\n$.ajax({\r\n\turl: \"/\" + countryInfo.EnglishName.toLowerCase() + \"/submit\",\r\n\tdataType: \"json\",\r\n\tmethod: \"POST\",\r\n\tdata: { property: propertyToSave, __RequestVerificationToken: $(\"input[name=__RequestVerificationToken]\").val() },\r\n\t....\r\n```\r\nI specify that if i replace dots with commas the values arrive correctly to the controller, in any other case the **properties are always 0**\r\n\r\nAny suggestion? Is a known problem? I suppose the Web API should suffer of this problem too",
    "number": 1366,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-06-07T01:43:42Z",
          "user": "IGx89"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-09-09T13:11:42Z",
          "user": "pciarach"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-10-14T10:35:00Z",
          "user": "MohamedAliTera"
        }
      ],
      "totalCount": 3,
      "endCursor": "Y3Vyc29yOnYyOpHOC7zOfA=="
    },
    "updatedAt": "2025-02-06T12:52:21Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": "ollie10",
          "body": "**Values sent by the browser:**\r\n\r\n![Sent](https://i.ibb.co/pX9WXhK/Screenshot-5.jpg)\r\n\r\n**Values received by the controller:**\r\n\r\n![Received](https://i.ibb.co/PM2QMy0/Screenshot-6.jpg)\r\n",
          "createdAt": "2020-01-05T20:40:17Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2020-01-05T20:40:17Z",
          "id": "MDEyOklzc3VlQ29tbWVudDU3MDk0NTYxNw=="
        },
        {
          "author": "Clockwork-Muse",
          "body": "> The decimal values returned by google Js API are in this format: 55.7539619 (for example)\r\n\r\nJavaScript, and thus most use of JSON, doesn't do `decimal` (base-10 floating point), it uses `double` (base-2 floating point).  This (probably) won't solve your problem, but it does mean that values that are transferred may not always be what you expect.\r\n\r\n> I use a route parameter to set statically the Culture like site.com/spain/ for es-ES site.com/russia/ for ru-RU\r\n\r\nThere's multiple problems with this, besides the one you're experiencing.  The biggest one is that individual countries can have multiple major languages; Spain, for example, has Catalan (`ca-ES`), Canada has Quebec-French (`fr-CA` - there can be some pretty big penalties for ignoring this one, by the way), etc.  It also ignores things like user preferences for display language.  It's use in a route may be dubious (it's difficult to tell what else you're doing with it) - if I'm looking at houses/apartments/whatever in Russia, does that mean the page suddenly renders in Russian?  That won't be helpful if I'm trying to book a vacation there...\r\n\r\nIf the user is logged in, respect whatever language they have selected in their profile.  If they're not, use the [`Accept-Language` header](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Language), if set.  Otherwise, take a guess based on IP range.\r\n\r\n<hr />\r\n\r\n>I specify that if i replace dots with commas the values arrive correctly to the controller, in any other case the properties are always 0\r\n\r\nSimply replacing the period with a comma would actually make it invalid JSON (since the comma is the attribute separator), so I'm suspicious that it works at all.  Your client-side code isn't what we'd be interested in - we'd need to see your controller code.  As it is, [in a trivial example I cannot reproduce your issue](https://dotnetfiddle.net/EvEKi5).\r\n\r\n(personally, I've always disliked relying on `CurrentCulture`, and would rather explicitly use a culture object for just those items that require it)",
          "createdAt": "2020-01-06T01:54:33Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2020-01-06T01:54:33Z",
          "id": "MDEyOklzc3VlQ29tbWVudDU3MDk3NDk1MQ=="
        },
        {
          "author": "ollie10",
          "body": "Hi @Clockwork-Muse thanks for reply, the use case of the route is to select a specific area more than a language, even if I see what you mean anyway for now I'm not planning to accept multiple languages for each country (not planning to publish in those countries right now).\r\n\r\nSo the question is another and very simple: how to pass the value _**55.7539619**_ passed me from google **selectedPlace.geometry.location.lat();** to a controller via ajax in a website perhaps that _(not caring all the discourse of routing etc etc_) has a culture fixed on whatever European country (or that accept the culture from the _Accept-Language_) where the decimal separator **is** the comma?\r\nMany thanks for your time",
          "createdAt": "2020-01-06T05:20:11Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2020-01-06T05:20:11Z",
          "id": "MDEyOklzc3VlQ29tbWVudDU3MTAwNzc3OA=="
        },
        {
          "author": "ollie10",
          "body": "Just to verify your thesis I made another test, I added all the configuration to support the culture en-US just adding the route site.com/usa/...\r\n\r\nNothing else added, no code changed on the client side, and with that everything works like a charm\r\n\r\n![alt text](https://i.ibb.co/DK0bVVG/Screenshot-8.jpg)\r\n\r\nAbout my controller code is a very normal controller accepting a ViewModel which has all the properties that I'm passing:\r\n\r\n ```csharp\r\n[Authorize]\r\n[ValidateAntiForgeryToken]\r\n[HttpPost]\r\npublic async Task<JsonResult> Submit(PropertyViewModel property)\r\n{\r\n...\r\n]\r\n```\r\n\r\n ```csharp\r\npublic class PropertyViewModel\r\n{\r\n...\r\n\t[Required]\r\n\tpublic decimal Latitude { get; set; }\r\n\r\n\t[Required]\r\n\tpublic decimal Longitude { get; set; }\r\n\r\n\t[Required]\r\n\tpublic string LatLng { get; set; }\r\n...\r\n}\r\n```",
          "createdAt": "2020-01-06T06:05:21Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2020-01-06T06:06:22Z",
          "id": "MDEyOklzc3VlQ29tbWVudDU3MTAxNjUxOQ=="
        },
        {
          "author": "ollie10",
          "body": "Just made another test to be sure: changing the type of the property to **double** instead of decimal solves the problem, so there should be some problem specific with **decimal** and the serialization",
          "createdAt": "2020-01-06T06:21:09Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2020-01-06T06:21:09Z",
          "id": "MDEyOklzc3VlQ29tbWVudDU3MTAxOTk4OA=="
        },
        {
          "author": "Clockwork-Muse",
          "body": "> Just to verify your thesis I made another test, I added all the configuration to support the culture en-US just adding the route site.com/usa/...\r\n\r\n... if you actually want the route to drive localization, actually use the locale or language codes, like a number of sites already do.  If you're just getting resources about a specific country, _don't_ do localization, because it's unrelated.",
          "createdAt": "2020-01-06T06:46:40Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2020-01-06T06:46:40Z",
          "id": "MDEyOklzc3VlQ29tbWVudDU3MTAyNTI0NQ=="
        },
        {
          "author": "ollie10",
          "body": "Hum, you seems not understanding correctly the problem... There websites that have a localization set in the configuration statically or taking localization with the header, at the end it doesn't matter, the problem is that when the CurrentCulture is **for any reason** (_settings, header, querystring etc etc_) set to something different than en-US the decimal number are not readed\r\n\r\nThat's the problem, what there is on top of it it doesn't matter, I can make a simple web app to show you without any code just with a Page and a Controller and using using the default culture of my PC and sending an object (with decimals) in JSON to the controller with ajax and the problem will arise anyway...",
          "createdAt": "2020-01-06T11:01:39Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2020-01-06T11:01:39Z",
          "id": "MDEyOklzc3VlQ29tbWVudDU3MTA5NzUxNw=="
        },
        {
          "author": "danmoseley",
          "body": ">  I can make a simple web app to show you\r\n\r\n@ollie10 perhaps you could make such a repro and push it up as a github repo? That's what many people do. Best of all, though, is a repro short enough (say up to 50 lines) that you can paste it in here and run it in a console app.",
          "createdAt": "2020-01-07T00:09:16Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2020-01-07T00:09:16Z",
          "id": "MDEyOklzc3VlQ29tbWVudDU3MTM3MTI4Ng=="
        },
        {
          "author": "ollie10",
          "body": "Hello @danmosemsft, @Clockwork-Muse I just pushed the repo with the example, you can find it here:\r\n\r\nhttps://github.com/ollie10/test.json.decimals/tree/master/Json.Test\r\n\r\nHere the view:\r\nhttps://github.com/ollie10/test.json.decimals/blob/master/Json.Test/Json.Test/Views/Home/Index.cshtml\r\n\r\nHere the controller:\r\nhttps://github.com/ollie10/test.json.decimals/blob/master/Json.Test/Json.Test/Controllers/HomeController.cs\r\n\r\nI publish also the results now I have another problem, the number is interpreted but the period is not taken into account if the Culture is **not en-US**, i show you the results:\r\n\r\nThe culture is taken in this case only from **the header**, nothing to do with the case I told you at the begging, standard .net Core code **without any customization in CultureProviders** and so on and the decimal is still misinterpeted.\r\n\r\n**en-US Culture:**\r\n![alt text](https://i.ibb.co/wQrCKzb/Test1.jpg)\r\n\r\n**it-IT Culture:**\r\n![alt text](https://i.ibb.co/PzFg54J/Test2.jpg)\r\n\r\nIn this example I just created a new Web Application with nothing inside except the page that sends the data via ajax, I added the code in the startup for allowing the localization\r\n ```csharp\r\n\r\nCultureInfo[] supportedCultures = new[] { new CultureInfo(\"en-US\"), new CultureInfo(\"it-IT\"), new CultureInfo(\"es-ES\") };\r\n\r\napp.UseRequestLocalization(new RequestLocalizationOptions() { SupportedCultures = supportedCultures, SupportedUICultures = supportedCultures }).UseEndpoints(endpoints =>\r\n\t\t   {\r\n\t\t\t   endpoints.MapControllerRoute(\r\n\t\t\t\t   name: \"default\",\r\n\t\t\t\t   pattern: \"{controller=Home}/{action=Index}/{id?}\");\r\n\t\t   });\r\n```",
          "createdAt": "2020-01-07T13:19:12Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2020-01-07T13:22:28Z",
          "id": "MDEyOklzc3VlQ29tbWVudDU3MTU4MjE2Mg=="
        },
        {
          "author": "danmoseley",
          "body": "Moving to dotnet/runtime where new issues go.",
          "createdAt": "2020-01-07T17:31:14Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2020-01-07T17:31:14Z",
          "id": "MDEyOklzc3VlQ29tbWVudDU3MTY4OTM5Ng=="
        },
        {
          "author": "bCamba",
          "body": "I am also having problems with this issue. @layomia Will this only be fixed in 5.0?\r\n",
          "createdAt": "2020-03-23T14:00:55Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2020-03-23T14:01:49Z",
          "id": "MDEyOklzc3VlQ29tbWVudDYwMjYwOTQ2OQ=="
        },
        {
          "author": "layomia",
          "body": "Moving this to future - adding built-in logic for culture-aware number handling is currently not on the roadmap for System.Text.Json. It looks like OP had a workaround which involved changing the property type from `decimal` to `double`. Another workaround here is to write a [custom converter](https://docs.microsoft.com/en-us/dotnet/standard/serialization/system-text-json-converters-how-to) to provide handling needed for each specific scenario.\r\n\r\nAny support that involves allowing commas in number payloads would need to build atop support for [deserializing quoted numbers](https://github.com/dotnet/runtime/issues/30255). The numbers would need to be quoted, otherwise the JSON payload would be malformed.",
          "createdAt": "2020-08-06T06:12:06Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2020-08-06T06:12:06Z",
          "id": "MDEyOklzc3VlQ29tbWVudDY2OTcyNDA2Ng=="
        },
        {
          "author": "eiriktsarpalis",
          "body": "If I'm understanding the OP correctly, the issue boils to the following reproduction:\r\n```csharp\r\nconst double number = 3.1415926;\r\nstring numberStr = number.ToString(System.Globalization.CultureInfo.GetCultureInfo(\"de-DE\")); // 3,1415926\r\nJsonSerializer.Deserialize<double>(numberStr); // throws JsonException: ',' is invalid after a single JSON value. Expected end of data.\r\n```\r\nWe might want to consider adding adding a `CultureInfo` property to `JsonSerializerOptions` like [Json.NET is doing](https://www.newtonsoft.com/json/help/html/P_Newtonsoft_Json_JsonSerializer_Culture.htm).",
          "createdAt": "2021-10-20T16:28:56Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-12-29T18:00:30Z",
                "user": "croban"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-04-27T21:41:10Z",
                "user": "FouadSsitou"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-07-14T10:31:20Z",
                "user": "ktiunov"
              }
            ],
            "totalCount": 3,
            "endCursor": "Y3Vyc29yOnYyOpHODAs3Ag=="
          },
          "updatedAt": "2021-10-20T16:28:56Z",
          "id": "IC_kwDODI9FZc44fs2V"
        },
        {
          "author": null,
          "body": "This issue has been marked with the `api-needs-work` label. This may suggest that the proposal requires further refinement before it can be considered for API review. Please refer to our [API review guidelines](https://github.com/dotnet/runtime/blob/main/docs/project/api-review-process.md) for a detailed description of the process. \n\nWhen ready to submit an amended proposal, please ensure that the original post in this issue has been updated, following the API proposal template and examples as provided in the guidelines.",
          "createdAt": "2021-10-20T16:29:39Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-10-20T16:29:39Z",
          "id": "IC_kwDODI9FZc44fs_Q"
        },
        {
          "author": "ollie10",
          "body": "Hello @eiriktsarpalis @layomia @danmoseley , any news on this topic? I just posted a [question on StackOverflow](https://stackoverflow.com/questions/71967431/system-text-json-unable-to-deserialize-doubles-properly-with-culture) becuase it's still happening, 2 years after has been reported...\r\n\r\nNothing to do? Many thanks",
          "createdAt": "2022-04-22T10:46:47Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-04-22T10:51:59Z",
          "id": "IC_kwDODI9FZc5B8dev"
        },
        {
          "author": "eiriktsarpalis",
          "body": "@ollie10 we haven't been able to prioritize this issue yet. Have you considered trying some of the suggested workarounds, like using a custom converter for decimal?",
          "createdAt": "2022-04-22T12:44:33Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-04-22T12:44:33Z",
          "id": "IC_kwDODI9FZc5B84J_"
        },
        {
          "author": "ollie10",
          "body": "At the moment i'm passing it as a string as another parameter and then deserializing it manually but it's as said a workaround...",
          "createdAt": "2022-04-22T12:47:20Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-04-22T12:47:20Z",
          "id": "IC_kwDODI9FZc5B84u2"
        },
        {
          "author": "eiriktsarpalis",
          "body": "That should not be necessary if you register a custom converter for your type, see https://docs.microsoft.com/en-us/dotnet/standard/serialization/system-text-json-converters-how-to?pivots=dotnet-6-0",
          "createdAt": "2022-04-22T12:59:35Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-04-22T12:59:35Z",
          "id": "IC_kwDODI9FZc5B87Jg"
        },
        {
          "author": "ollie10",
          "body": "many thanks @eiriktsarpalis I used this solution which is more elegant even if it remains a workaround and it's weird it hasn't been covered yet. I mean, these are numbers coming from javascript, javascript doesn't allow culture when serializing / deserializing, why the default behaviour of a controller should?\r\nAnyway if it is useful for someone this is my code and I added the DataAnnotation the the properties I want to deserialize\r\n\r\n```csharp \r\npublic class DoubleJsonConverter : JsonConverter<double>\r\n{\r\n\tpublic override double Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)\r\n\t{\r\n\t\treturn double.Parse(reader.GetString(), CultureInfo.InvariantCulture);\r\n\t}\r\n\r\n\tpublic override void Write(Utf8JsonWriter writer, double doubleValue, JsonSerializerOptions options)\r\n\t{\r\n\t\twriter.WriteStringValue(doubleValue.ToString(CultureInfo.InvariantCulture));\r\n\t}\r\n}\r\n```\r\n\r\nAnd on the property\r\n\r\n```csharp\r\n[JsonConverter(typeof(DoubleJsonConverter))]\r\npublic double Latitude { get; set; }\r\n```",
          "createdAt": "2022-04-22T15:22:58Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-04-22T16:18:44Z",
                "user": "eiriktsarpalis"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-03-04T02:45:18Z",
                "user": "tina-hello"
              }
            ],
            "totalCount": 2,
            "endCursor": "Y3Vyc29yOnYyOpHOEIWuEw=="
          },
          "updatedAt": "2022-04-22T15:52:43Z",
          "id": "IC_kwDODI9FZc5B9bQH"
        },
        {
          "author": "eiriktsarpalis",
          "body": "FWIW it should be possible to avoid annotating every single `double` property by adding the converter to the `JsonSerializerOptions.Converters` list.",
          "createdAt": "2022-04-22T16:18:38Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-04-22T16:18:38Z",
          "id": "IC_kwDODI9FZc5B9mdC"
        },
        {
          "author": "ollie10",
          "body": "Thanks but those two were the only two in the whole application",
          "createdAt": "2022-04-22T17:18:52Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-04-22T17:18:52Z",
          "id": "IC_kwDODI9FZc5B9xLL"
        },
        {
          "author": "ollie10",
          "body": "Hello again @eiriktsarpalis @danmoseley @layomia, I was double-checking the issue and seems is not solved.\r\nI mean the solution of the converter works properly, but I just realized I was terribly wrong, I'm **not** sending data posting a JSON from jQuery, but it's been sent via a normal post form via jQuery so the deserializer doesn't enter the equation, in fact the method _Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)_ is never been called when the controller needs to bind the posted form to the object\r\n\r\nSo I further investigated to send the object as a JSON but without any success: the **[FromBody]** annotation in the controller it doesn't work in my case (don't know if I'm doing something wrong) but even if it would work then I would have another problem: sending the **object as JSON** and sending the **__RequestVerificationToken** as a normal POST parameter to pass the check **[ValidateAntiForgeryToken]**\r\nAs far as I know, I cannot send some objects as JSON and some as normal POST parameters in the same ajax call, so I don't see it an option.\r\n\r\nThe curious thing is that I realized that a normal post would work if the thread culture is set in **en-US** which is not my case as I mentioned you before, I have a custom **RequestCultureProvider** that map the route **/panama/ to es-PA**, **/dominicana/ to es-DO** and so on.\r\n\r\nBut the big problem which I think is causing a lot of headaches is that I don't have a way to change the culture to interpret the values in a specified culture, what I can eventually do is passing the **Accept-Language** header in the call specifying the culture and in this way the way numbers are red.\r\n\r\n```js\r\n$.ajax({\r\n\turl: 'url',\r\n\tdata: { property: propertyToSave, __RequestVerificationToken: $('input[name=__RequestVerificationToken]').first().val() },\r\n\ttimeout: DEFAULT_AJAX_TIMEOUT,\r\n\tdataType: 'json', // this is what I'm expecting from the server not the format is sent\r\n\tmethod: 'POST',\r\n\tbeforeSend: function (request) {\r\n\t\trequest.setRequestHeader('Accept-Language', 'en-US');\r\n\t},\r\n...\r\n```\r\n\r\nI did it so but is not working, my question is: the framework shouldn't take this into account in order to bind objects instead of other things? This can cause a lot of troubles, for example, imagine if you have an application which doesn't set any culture on an American server which provides content to a browser which doesn't have the same culture.\r\n\r\nIn my case I'm setting it manually from the routing but if you don't do it so, it can take the one of the server or the browser depending on how it's configured and can cause a lot of troubles...\r\nDon't know if you see my point",
          "createdAt": "2022-04-28T10:18:34Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-04-28T10:18:34Z",
          "id": "IC_kwDODI9FZc5CSErz"
        },
        {
          "author": "eiriktsarpalis",
          "body": "It would seem like this is an issue related to aspnetcore MVC model binding? I would suggest filing filing a separate issue on the [aspnetcore ](https://github.com/dotnet/aspnetcore/) repo, and possibly incorporate an application with a minimal reproduction in your report.",
          "createdAt": "2022-04-28T10:49:13Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-04-28T10:49:13Z",
          "id": "IC_kwDODI9FZc5CSK5S"
        },
        {
          "author": "ArthurMa1978",
          "body": "The ask is adding a CultureInfo option into the [JsonDocumentOptions](https://learn.microsoft.com/en-us/dotnet/api/system.text.json.jsondocumentoptions?view=net-7.0) like [NewtonJson](https://www.newtonsoft.com/json/help/html/P_Newtonsoft_Json_JsonSerializer_Culture.htm) does.\r\nWe got similar issue, all serialize / deserialize operations will fail if [set culture](https://learn.microsoft.com/en-us/dotnet/api/system.globalization.cultureinfo.currentculture) to some special region, for example Russian (ru-RU).",
          "createdAt": "2023-04-11T06:48:51Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-04-11T06:51:54Z",
          "id": "IC_kwDODI9FZc5ZknNr"
        },
        {
          "author": "ollie10",
          "body": "Problem notified 3,5 years ago, still not solved. Probably, MS thinks the world is only the United States and the whole world uses points instead of commas, which is actually the other way around: the whole world uses commas instead of points. Maybe they will make us a grace for .NET 15...",
          "createdAt": "2023-06-29T15:12:52Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-06-29T15:41:29Z",
                "user": "sinand"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-07-31T14:59:11Z",
                "user": "alvipeo"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-09-28T19:56:39Z",
                "user": "mhcamillow"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-01-15T16:10:54Z",
                "user": "faethto"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-02-12T21:43:32Z",
                "user": "aradoorolesen"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-04-30T19:52:43Z",
                "user": "renanrcp"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-05-12T20:32:07Z",
                "user": "easis"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-05-25T21:48:52Z",
                "user": "lansman"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-07-16T16:09:57Z",
                "user": "7702244"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-09-09T13:11:48Z",
                "user": "pciarach"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-10-14T10:33:34Z",
                "user": "MohamedAliTera"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-10-28T09:58:22Z",
                "user": "kdlslyv"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-11-09T10:15:08Z",
                "user": "adrielairaldo"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-03-04T02:46:03Z",
                "user": "tina-hello"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-04-17T14:28:55Z",
                "user": "Rebel028"
              }
            ],
            "totalCount": 15,
            "endCursor": "Y3Vyc29yOnYyOpHOEOu80A=="
          },
          "updatedAt": "2023-06-29T15:12:52Z",
          "id": "IC_kwDODI9FZc5gKev-"
        },
        {
          "author": "ollie10",
          "body": "5 Years still no solution, this is unbelievable...",
          "createdAt": "2025-02-06T12:52:20Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-02-06T13:57:27Z",
                "user": "sinand"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-03-04T02:46:11Z",
                "user": "tina-hello"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-03-10T17:11:53Z",
                "user": "ranger-turtle"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-04-17T14:29:16Z",
                "user": "Rebel028"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-04-22T06:13:05Z",
                "user": "ArthurMa1978"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-06-07T16:05:25Z",
                "user": "DrkWzrd"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-06-08T19:38:15Z",
                "user": "HugoPeters"
              }
            ],
            "totalCount": 7,
            "endCursor": "Y3Vyc29yOnYyOpHOEV1mBA=="
          },
          "updatedAt": "2025-02-06T12:52:20Z",
          "id": "IC_kwDODI9FZc6dV1Wd"
        }
      ],
      "totalCount": 26,
      "endCursor": "Y3Vyc29yOnYyOpHOnVdVnQ=="
    },
    "url": "https://github.com/dotnet/runtime/issues/1366",
    "title": "Consider adding a JsonSerializerOptions.CultureInfo option"
  },
  {
    "author": "cleftheris",
    "labels": [
      "documentation",
      "area-System.Text.Json"
    ],
    "createdAt": "2020-01-15T14:44:49Z",
    "body": "Thanks for all your efforts. \r\n\r\nI believe that there is a strong case for an additional converter that will act as an Adapter between `System.ComponentModel.TypeConverter` marked on existing types with an attribute and the new serializer via the `System.Text.Json.Serialization.JsonConverter` . This could be either in the box (optionally) or **in the docs** as an example. \r\n\r\nAs I am migrating a number of aspnetcore projects to use the built in Json serializer I have noticed that there are numerous times I rely on serialization to do the right thing regarding models that are already decorated with a `TypeConverterAttribute` that is there to take care of automatic convesions to and from strings. With newtonsoft JsonConvert and aspnetcore it used to discover and use them under the hood by default whenever needed to convert to and from json. Lets say for example I have a `GeoPoint` class that is decorated with a `TypeConverterAttribute` (ComponentModel) instead of writing a new `JsonConverter` for that it would be nice to have something like the following.\r\n\r\n### The adapter\r\n```csharp\r\n    /// <summary>\r\n    /// Adapter between <see cref=\"System.ComponentModel.TypeConverter\"/> \r\n    /// and <see cref=\"JsonConverter\"/>\r\n    /// </summary>\r\n    public class TypeConverterJsonAdapter : JsonConverter<object>\r\n    {\r\n        public override object Read(\r\n            ref Utf8JsonReader reader,\r\n            Type typeToConvert,\r\n            JsonSerializerOptions options) {\r\n\r\n            var converter = TypeDescriptor.GetConverter(typeToConvert);\r\n            var text = reader.GetString();\r\n            return converter.ConvertFromString(text);\r\n        }\r\n\r\n        public override void Write(\r\n            Utf8JsonWriter writer,\r\n            object objectToWrite,\r\n            JsonSerializerOptions options) {\r\n\r\n            var converter = TypeDescriptor.GetConverter(objectToWrite);\r\n            var text = converter.ConvertToString(objectToWrite);\r\n            writer.WriteStringValue(text);\r\n        }\r\n        \r\n        public override bool CanConvert(Type typeToConvert) {\r\n            var hasConverter = typeToConvert.GetCustomAttributes<TypeConverterAttribute>(inherit: true).Any();\r\n            return hasConverter;\r\n        }\r\n    }\r\n```  \r\n\r\n### The model\r\n```csharp\r\n    /// <summary>\r\n    /// Geographic location\r\n    /// </summary>\r\n    [TypeConverter(typeof(GeoPointTypeConverter))]\r\n    public class GeoPoint\r\n    {\r\n        /// <summary>\r\n        /// The latitude\r\n        /// </summary>\r\n        public double Latitude { get; set; }\r\n\r\n        /// <summary>\r\n        /// The logitude\r\n        /// </summary>\r\n        public double Longitude { get; set; }\r\n    }\r\n\r\n    /// <summary>\r\n    /// Type converter for converting between <see cref=\"GeoPoint\"/> and <seealso cref=\"string\"/>\r\n    /// </summary>\r\n    public class GeoPointTypeConverter : TypeConverter\r\n    {\r\n          // ..... excluded for brevity ...\r\n    }\r\n```\r\n\r\n### the test\r\n```csharp\r\n        [Fact]\r\n        public void RoundtripTypeConverterAdapter() {\r\n            var options = new JsonSerializerOptions();\r\n            options.PropertyNamingPolicy = JsonNamingPolicy.CamelCase;\r\n            options.Converters.Add(new JsonStringEnumConverter());\r\n            options.Converters.Add(new TypeConverterJsonAdapter());\r\n            options.IgnoreNullValues = true;\r\n            var model = new TestModel { Point = GeoPoint.Parse(\"37.9888529,23.7037796\") };\r\n            var jsonExpected = \"{\\\"point\\\":\\\"37.9888529,23.7037796\\\"}\";\r\n            var json = JsonSerializer.Serialize(model, options);\r\n            Assert.Equal(jsonExpected, json);\r\n            var output = JsonSerializer.Deserialize<TestModel>(json, options);\r\n            Assert.Equal(model.Point.Latitude, output.Point.Latitude);\r\n        }\r\n\r\n        class TestModel\r\n        {\r\n            public GeoPoint Point { get; set; }\r\n        }\r\n```",
    "number": 1761,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "THUMBS_UP",
          "createdAt": "2020-01-15T14:49:58Z",
          "user": "giorgos07"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2020-02-19T12:46:14Z",
          "user": "techfan101"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2020-03-24T18:45:50Z",
          "user": "thomaslevesque"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2020-04-21T00:14:56Z",
          "user": "daniel-white"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2020-05-26T07:15:37Z",
          "user": "erictuvesson"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2020-06-05T10:53:30Z",
          "user": "Neme12"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2020-07-11T12:52:39Z",
          "user": "SkiTiSu"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-01-03T12:07:33Z",
          "user": "NN---"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-02-28T03:46:47Z",
          "user": "MikeStall"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-03-17T10:20:48Z",
          "user": "foresightyj"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-08-10T21:32:45Z",
          "user": "ishanpranav"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-06-01T10:55:58Z",
          "user": "Morilli"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-09-26T22:56:10Z",
          "user": "BoundedChenn31"
        },
        {
          "content": "HEART",
          "createdAt": "2024-11-10T15:04:00Z",
          "user": "pariesz"
        }
      ],
      "totalCount": 14,
      "endCursor": "Y3Vyc29yOnYyOpHOC8ib3w=="
    },
    "updatedAt": "2022-06-09T16:03:06Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": "erictuvesson",
          "body": "This is something I would like to see too!\r\n\r\nI would also like to have support for fallback to the normal parser when the point is an object in the JSON, the only way I see right now is to write the full converter of the object to load all fields if it's an object.\r\n\r\nFor example:\r\n```json\r\n{\r\n  \"point\": {\r\n    \"Latitude\": 37.9888529,\r\n    \"Longitude\": 23.7037796\r\n  }\r\n}\r\n```",
          "createdAt": "2020-05-26T07:21:48Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2020-05-26T07:21:48Z",
          "id": "MDEyOklzc3VlQ29tbWVudDYzMzg1NTMxNQ=="
        },
        {
          "author": "szmalec",
          "body": "@cleftheris\r\nThe proposed adapter does not seem to work if the TypeConverter attribute is added for the class property.\r\nIs it possible to construct such adapter that would also work for TypeConverter attributes added to class properties?\r\n\r\nUPDATE:\r\nIt does not work for:\r\n\r\n```c#\r\npublic class TestModel\r\n{\r\n    [TypeConverter(typeof(TestConverter))]\r\n    public IEnumerable<Guid?> Items { get; set; }\r\n}\r\n```\r\n\r\nbut work if wrapper is used:\r\n\r\n```c#\r\npublic class TestModel\r\n{\r\n    //[TypeConverter(typeof(TestConverter))]\r\n    public NullableGuidItems Items { get; set; }\r\n}\r\n\r\n[TypeConverter(typeof(TestConverter))]\r\npublic class NullableGuidItems: List<Guid?>\r\n{\r\n}\r\n```\r\n\r\n",
          "createdAt": "2020-06-26T12:17:21Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2020-06-29T15:09:36Z",
          "id": "MDEyOklzc3VlQ29tbWVudDY1MDE0ODMzNg=="
        },
        {
          "author": "cleftheris",
          "body": "Yes I see what you mean. \r\nI don't have an answer to this use case. One interesting thing here is that System.Text.Json does not take into account the runtime CLR type of the property value (as was the case with Newtonsoft Json) but instead uses the property type. So you are better of using concrete types there anyway. \r\n\r\nPS: If you end up making a subclass of `List<Guid?>` and decorate it with the TypeConverter you don't need to decorate the property as well.\r\n\r\nC.",
          "createdAt": "2020-06-26T16:36:26Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2020-06-29T15:09:01Z",
                "user": "szmalec"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOBI0-rA=="
          },
          "updatedAt": "2020-06-26T16:36:26Z",
          "id": "MDEyOklzc3VlQ29tbWVudDY1MDI3NTg3NQ=="
        },
        {
          "author": "cleftheris",
          "body": "@ahsonkhan @layomia  Recently I came across a case that I had a value type in a collection (lets say `List<GeoPoint>` or `GeoPoint[]`). In aforementioned case the Serializer would not be able to deserialize an throws an `InvalidCastException` with message \r\n>  Message: \r\n    System.InvalidCastException : Unable to cast object of type 'System.Collections.Generic.List`1[GeoPoint]' to type 'System.Collections.Generic.IList`1[System.Object]'.\r\n  Stack Trace: \r\n    JsonSerializer.ApplyValueToEnumerable[TProperty](TProperty& value, ReadStack& state)\r\n    JsonPropertyInfoNotNullableContravariant`4.OnReadEnumerable(ReadStack& state, Utf8JsonReader& reader)\r\n    JsonPropertyInfo.ReadEnumerable(JsonTokenType tokenType, ReadStack& state, Utf8JsonReader& reader)\r\n    JsonPropertyInfo.Read(JsonTokenType tokenType, ReadStack& state, Utf8JsonReader& reader)\r\n    JsonSerializer.ReadCore(JsonSerializerOptions options, Utf8JsonReader& reader, ReadStack& readStack)\r\n    JsonSerializer.ReadCore(Type returnType, JsonSerializerOptions options, Utf8JsonReader& reader)\r\n    JsonSerializer.Deserialize(String json, Type returnType, JsonSerializerOptions options)\r\n    JsonSerializer.Deserialize[TValue](String json, JsonSerializerOptions options)\r\n    TextJsonTests.RoundtripTypeConverterAdapterWithCollections() line 65\r\n\r\nI so I improved the `TypeConverterJsonAdapter` to do the right thing though the use of a `JsonConverterFactory`. Now it works both on collection properties as well as single item properties. Works both in the v4.7.x and the v5.0.0 of `System.Text.Json`\r\n\r\n### The adapter\r\n```csharp\r\n    /// <summary>\r\n    /// Adapter between <see cref=\"TypeConverter\"/> and <see cref=\"JsonConverter\"/>.\r\n    /// </summary>\r\n    public class TypeConverterJsonAdapter<T> : JsonConverter<T>\r\n    {\r\n        /// <inheritdoc/>\r\n        public override T Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) {\r\n            var converter = TypeDescriptor.GetConverter(typeToConvert);\r\n            var text = reader.GetString();\r\n            return (T)converter.ConvertFromString(text);\r\n        }\r\n\r\n        /// <inheritdoc/>\r\n        public override void Write(Utf8JsonWriter writer, T objectToWrite, JsonSerializerOptions options) {\r\n            var converter = TypeDescriptor.GetConverter(objectToWrite);\r\n            var text = converter.ConvertToString(objectToWrite);\r\n            writer.WriteStringValue(text);\r\n        }\r\n\r\n        /// <inheritdoc/>\r\n        public override bool CanConvert(Type typeToConvert) {\r\n            var hasConverter = typeToConvert.GetCustomAttributes<TypeConverterAttribute>(inherit: true).Any();\r\n            if (!hasConverter) {\r\n                return false;\r\n            }\r\n            return true;\r\n        }\r\n    }\r\n\r\n    /// <inheritdoc />\r\n    public class TypeConverterJsonAdapter : TypeConverterJsonAdapter<object> { }\r\n\r\n    /// <summary>\r\n    /// A factory used to create various <see cref=\"TypeConverterJsonAdapter{T}\"/> instances.\r\n    /// </summary>\r\n    public class TypeConverterJsonAdapterFactory : JsonConverterFactory\r\n    {\r\n        /// <inheritdoc />\r\n        public override bool CanConvert(Type typeToConvert) {\r\n            var hasConverter = typeToConvert.GetCustomAttributes<TypeConverterAttribute>(inherit: true).Any();\r\n            if (!hasConverter) {\r\n                return false;\r\n            }\r\n            return true;\r\n        }\r\n\r\n        /// <inheritdoc />\r\n        public override JsonConverter CreateConverter(Type typeToConvert, JsonSerializerOptions options) {\r\n            var converterType = typeof(TypeConverterJsonAdapter<>).MakeGenericType(typeToConvert);\r\n            return (JsonConverter)Activator.CreateInstance(converterType);\r\n        }\r\n    }\r\n```  \r\n\r\n### The model\r\n```csharp\r\n    /// <summary>\r\n    /// Geographic location\r\n    /// </summary>\r\n    [TypeConverter(typeof(GeoPointTypeConverter))]\r\n    public class GeoPoint\r\n    {\r\n        /// <summary>\r\n        /// The latitude\r\n        /// </summary>\r\n        public double Latitude { get; set; }\r\n\r\n        /// <summary>\r\n        /// The logitude\r\n        /// </summary>\r\n        public double Longitude { get; set; }\r\n    }\r\n\r\n    /// <summary>\r\n    /// Type converter for converting between <see cref=\"GeoPoint\"/> and <seealso cref=\"string\"/>\r\n    /// </summary>\r\n    public class GeoPointTypeConverter : TypeConverter\r\n    {\r\n          // ..... excluded for brevity ...\r\n    }\r\n```\r\nNo notice in the test I configure the options with the `TypeConverterJsonAdapterFactory` instead of the simple `TypeConverterJsonAdapter`.\r\n### the test\r\n```csharp\r\n        [Fact]\r\n        public void RoundtripTypeConverterAdapter_WithCollections() {\r\n            var options = new JsonSerializerOptions();\r\n            options.PropertyNamingPolicy = JsonNamingPolicy.CamelCase;\r\n            options.Converters.Add(new JsonStringEnumConverter());\r\n            options.Converters.Add(new TypeConverterJsonAdapterFactory());\r\n            options.IgnoreNullValues = true;\r\n            var model = new TestModel { \r\n                Point = GeoPoint.Parse(\"37.9888529,23.7037796\"), \r\n                PointList = new List<GeoPoint> {   \r\n                    GeoPoint.Parse(\"37.9888529,23.7037796\"), \r\n                    GeoPoint.Parse(\"37.9689383,23.7309977\")\r\n                } \r\n            };\r\n            var jsonExpected = \"{\\\"point\\\":\\\"37.9888529,23.7037796\\\",\\\"pointList\\\":[\\\"37.9888529,23.7037796\\\",\\\"37.9689383,23.7309977\\\"]}\";\r\n            var json = JsonSerializer.Serialize(model, options);\r\n            Assert.Equal(jsonExpected, json);\r\n            var output = JsonSerializer.Deserialize<TestModel>(json, options);\r\n            Assert.Equal(model.Point.Latitude, output.Point.Latitude);\r\n        }\r\n\r\n        class TestModel\r\n        {\r\n            public GeoPoint Point { get; set; }\r\n            public List<GeoPoint> PointList { get; set; }\r\n        }\r\n```\r\n\r\n",
          "createdAt": "2020-11-08T18:23:35Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-08-17T21:44:40Z",
                "user": "mateusdemboski"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-03-03T20:18:00Z",
                "user": "DarinMacRae"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-12-07T19:42:46Z",
                "user": "mikebm"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-06-01T10:55:55Z",
                "user": "Morilli"
              }
            ],
            "totalCount": 4,
            "endCursor": "Y3Vyc29yOnYyOpHODkIrHw=="
          },
          "updatedAt": "2020-11-08T18:23:35Z",
          "id": "MDEyOklzc3VlQ29tbWVudDcyMzY0NzMwNw=="
        }
      ],
      "totalCount": 4,
      "endCursor": "Y3Vyc29yOnYyOpHOKyH7Sw=="
    },
    "url": "https://github.com/dotnet/runtime/issues/1761",
    "title": "Document a System.Text.Json TypeConverter to JsonConverter Adapter"
  },
  {
    "author": "kostrse",
    "labels": [
      "enhancement",
      "area-System.Text.Json",
      "help wanted",
      "wishlist"
    ],
    "createdAt": "2020-02-03T06:12:14Z",
    "body": "IMHO, `IReadOnlyDictionary` should work identical to `IDictionary` when using with  `JsonExtensionData` attribute.\r\n\r\n```cs\r\n[JsonExtensionData]\r\npublic IReadOnlyDictionary<string, JsonElement> Payload { get; set; }\r\n```\r\n\r\nCurrently it fails with error:\r\n> System.InvalidOperationException: The data extension property 'Payload' does not match the required signature of IDictionary<string, JsonElement> or IDictionary<string, object>.\r\n\r\nThis is analogous to collection properties which can be defined as `List<T>`, `IList<T>` or `IReadOnlyList<T>` etc.",
    "number": 31645,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-09-29T05:14:30Z",
          "user": "bill-poole"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-07-29T17:01:13Z",
          "user": "dstarkowski"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-08-27T19:07:00Z",
          "user": "shravan2x"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-09-27T18:53:37Z",
          "user": "cdonnellytx"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-03-31T17:05:23Z",
          "user": "Swimburger"
        }
      ],
      "totalCount": 5,
      "endCursor": "Y3Vyc29yOnYyOpHODAr_gg=="
    },
    "updatedAt": "2023-01-27T15:01:37Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": "layomia",
          "body": "Triage: we should generalize this to support all dictionary types that the serializer supports as extension data. Supported types can be found here https://github.com/dotnet/docs/issues/15807#issuecomment-576941811.\r\n\r\nChanging the title to reflect this.",
          "createdAt": "2020-02-21T16:55:10Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2020-02-21T16:55:10Z",
          "id": "MDEyOklzc3VlQ29tbWVudDU4OTczOTgxNg=="
        },
        {
          "author": "layomia",
          "body": "Adding request for ImmutableDictionary from @mwikstrom in #32408:\r\n\r\n> Hi,\r\n> \r\n> I want to use an immutable dictionary to store json extension data.\r\n> \r\n> I tried to see if this is supported by writing the following test in an mstest project targeting netcoreapp3.1:\r\n> \r\n> ```cs\r\n> [TestClass]\r\n> public sealed class JsonExtensionDataTest\r\n> {\r\n>     class HasImmutableExtensionData\r\n>     {\r\n>         [JsonExtensionData]\r\n>         public ImmutableDictionary<string, JsonElement> ExtensionData { get; set; }\r\n>     }\r\n> \r\n>     [TestMethod]\r\n>     public void Can_deserialize_immutable_extension_data()\r\n>     {\r\n>         const string json = \"{\\\"foo\\\":123}\";\r\n>         var obj = JsonSerializer.Deserialize<HasImmutableExtensionData>(json);\r\n>         Assert.IsNotNull(obj.ExtensionData);\r\n>         Assert.IsTrue(obj.ExtensionData.ContainsKey(\"foo\"));\r\n>     }\r\n> }\r\n> ```\r\n> \r\n> That test fails with a `NullReferenceException` which surprised me:\r\n> \r\n> ```\r\n>  Can_deserialize_immutable_extension_data\r\n>    Source: JsonExtensionDataTest.cs line 42\r\n>    Duration: 39 ms\r\n> \r\n>   Message: \r\n>     Test method JsonExtensionDataTest.JsonExtensionDataTest.Can_deserialize_immutable_extension_data threw exception: \r\n>     System.NullReferenceException: Object reference not set to an instance of an object.\r\n>   Stack Trace: \r\n>     JsonSerializer.CreateDataExtensionProperty(JsonPropertyInfo jsonPropertyInfo, ReadStack& state)\r\n>     JsonSerializer.ReadCore(JsonSerializerOptions options, Utf8JsonReader& reader, ReadStack& readStack)\r\n>     JsonSerializer.ReadCore(Type returnType, JsonSerializerOptions options, Utf8JsonReader& reader)\r\n>     JsonSerializer.Deserialize(String json, Type returnType, JsonSerializerOptions options)\r\n>     JsonSerializer.Deserialize[TValue](String json, JsonSerializerOptions options)\r\n>     JsonExtensionDataTest.Can_deserialize_immutable_extension_data() line 45\r\n> ```\r\n> \r\n> I consider the experienced behavior a bug. Another exception should have been thrown.\r\n> \r\n> I would also like to request future support for using `ImmutableDictionary<TKey, TValue>` as backer for `[JsonExtensionData]`.\r\n\r\n",
          "createdAt": "2020-02-21T16:57:36Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2020-02-22T05:28:50Z",
          "id": "MDEyOklzc3VlQ29tbWVudDU4OTc0MDgzMw=="
        },
        {
          "author": "Romanx",
          "body": "Hey there,\r\n\r\nI'd love to pick this up and take a look at getting these types serializing. Could the issue be assigned to me?",
          "createdAt": "2020-04-06T21:57:58Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2020-04-06T21:57:58Z",
          "id": "MDEyOklzc3VlQ29tbWVudDYxMDA1ODcyMw=="
        },
        {
          "author": "layomia",
          "body": "@Romanx, certainly. Please let me know if you run into any issue or have any questions.",
          "createdAt": "2020-04-07T05:01:25Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2020-04-07T05:05:33Z",
          "id": "MDEyOklzc3VlQ29tbWVudDYxMDE3NDcwMw=="
        },
        {
          "author": "Romanx",
          "body": "@layomia I can't seem to get the project to build. \r\n\r\nI've forked and cloned the repo, built everything following [this]().  when I opened vs using `build -vs System.Text.Json` but i'm getting errors in the ref project about `Project System.Memory is not compatible with netcoreapp5.0`. \r\n\r\nIf i unload that project then I get get everything to build but i can't seem to get the tests to run and looking in the test output from VS i'm seeing\r\n`None of the specified source(s) 'C:\\Projects\\dotnet-runtime\\artifacts\\bin\\System.Text.Json.Tests\\Debug\\System.Text.Json.Tests.dll' is valid. Fix the above errors/warnings and then try again.`\r\n\r\nFollowing that path i find that my output is being put into a folder `netcoreapp5.0-Debug` so prefixed with the TFM.\r\n\r\nI may be being dense and have missed something obvious but any help would be appreciated for a first timer!",
          "createdAt": "2020-04-07T19:20:22Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2020-04-07T19:20:22Z",
          "id": "MDEyOklzc3VlQ29tbWVudDYxMDU3MzIwOQ=="
        },
        {
          "author": "layomia",
          "body": "@Romanx can you share the output if running `dotnet --info`? Also what version of Visual Studio are you running?\r\n\r\nDid you build the repo before running `build -vs System.Text.Json` as described in [this doc](https://github.com/dotnet/runtime/blob/e298818e7c1327178de8168ed785c0e23d14d298/docs/workflow/building/libraries/README.md)? Specifically - \r\n\r\n```bat\r\n:: From root:\r\ngit clean -xdf\r\ngit pull upstream master & git push origin master\r\n:: Build Debug libraries on top of Release runtime:\r\nbuild -subset clr+libs -runtimeConfiguration Release\r\n```",
          "createdAt": "2020-04-08T22:41:48Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2020-04-08T22:41:48Z",
          "id": "MDEyOklzc3VlQ29tbWVudDYxMTIzMTMyNw=="
        },
        {
          "author": "Romanx",
          "body": "Hey,\r\n\r\nThe results from `dotnet --info` is:\r\n```\r\n.NET Core SDK (reflecting any global.json):\r\n Version:   5.0.100-preview.4.20202.8\r\n Commit:    074b436c3d\r\n\r\nRuntime Environment:\r\n OS Name:     Windows\r\n OS Version:  10.0.18362\r\n OS Platform: Windows\r\n RID:         win10-x64\r\n Base Path:   C:\\Program Files\\dotnet\\sdk\\5.0.100-preview.4.20202.8\\\r\n\r\nHost (useful for support):\r\n  Version: 5.0.0-preview.3.20169.1\r\n  Commit:  bc28cbef85.NET Core SDK (reflecting any global.json):\r\n Version:   5.0.100-preview.4.20202.8\r\n Commit:    074b436c3d\r\n\r\nRuntime Environment:\r\n OS Name:     Windows\r\n OS Version:  10.0.18362\r\n OS Platform: Windows\r\n RID:         win10-x64\r\n Base Path:   C:\\Program Files\\dotnet\\sdk\\5.0.100-preview.4.20202.8\\\r\n\r\nHost (useful for support):\r\n  Version: 5.0.0-preview.3.20169.1\r\n  Commit:  bc28cbef85\r\n```\r\n\r\nI was running VS `16.5.3` but then remembered the post for preview 2 saying you have to use the preview VS so installed that so tried with `16.6 Preview 2.1` although had to open it manually since `./build -vs System.Text.Json` didn't open with preview\r\n\r\nAfter building in 16.6 the ref project errors went away but the test error looking for the dll in the wrong directory persisted.",
          "createdAt": "2020-04-09T10:22:50Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2020-04-09T10:22:50Z",
          "id": "MDEyOklzc3VlQ29tbWVudDYxMTQ1MjI3OQ=="
        },
        {
          "author": "safern",
          "body": "> 'C:\\Projects\\dotnet-runtime\\artifacts\\bin\\System.Text.Json.Tests\\Debug\\System.Text.Json.Tests.dll' is valid.\r\n\r\nAnipik it seems like the path is missing the TFM, was this fixed with yesterday's PR as well? \r\n\r\nI think if you don't open with `build -vs ...` you won't be able to run the tests because we're setting some environment variables needed for VSTest to run against the lively built shared framework. If it didn't open with preview, you might be missing the Preview devenv in the path, or you're opening a developer command prompt that is not preview, could you make sure that is not the case? ",
          "createdAt": "2020-04-10T20:23:39Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2020-04-10T20:23:39Z",
          "id": "MDEyOklzc3VlQ29tbWVudDYxMjIwMTM5Ng=="
        },
        {
          "author": "layomia",
          "body": "> Anipik it seems like the path is missing the TFM, was this fixed with yesterday's PR as well?\r\n\r\ncc @Anipik ",
          "createdAt": "2020-04-10T20:25:23Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "LAUGH",
                "createdAt": "2020-04-10T20:31:27Z",
                "user": "safern"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOBAyYUg=="
          },
          "updatedAt": "2020-04-10T20:25:23Z",
          "id": "MDEyOklzc3VlQ29tbWVudDYxMjIwMjAyOA=="
        },
        {
          "author": "Romanx",
          "body": "I managed to get the tests running on my machine after marking sure my default program for `.sln` files was the preview version of devenv and after pulling from master which seems to have fixed the TFM problem.\r\n\r\nI started taking a look using the `ImmutableDictionary` example from above to help guide me through the codebase. The reason it stops is that `jsonPropertyInfo.RuntimeClassInfo.CreateObject` value for types such as ImmutableDictionary is null since there is no valid constructor.\r\n\r\nThe reason that these types work in the context of normal json collections for is that a specific JsonConverter is used and the read items are stored in an intermediate dictionary and then converted into the correct output type when the collection has been fully read.\r\n\r\nThat method would not work here without work since the items we need to add are not in order since they're the items without a matched property. \r\n\r\nIt would be good to be able to reuse the JsonConverter method since the conversions are already there and any new types would work however the JsonConverter uses the ReadStack for state which I think would cause the reading to break.\r\n\r\nI'm not sure the best course of action from here, creating an interim dictionary and then converting to the output type at the end seems to be right idea however where to start with that is the next question. \r\n\r\nAdding a dictionary to the `JsonPropertyInfo` for the ExtensionData and converting before returning the final result by exposing the collection conversion from the JsonConverter seems like it would work but adding a property to `JsonPropertyInfo` for this one case feels wrong.\r\n\r\nHopefully that ramble makes some sense 😄 ",
          "createdAt": "2020-04-11T15:06:23Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2020-04-11T15:06:23Z",
          "id": "MDEyOklzc3VlQ29tbWVudDYxMjQ0MTY0OA=="
        },
        {
          "author": "layomia",
          "body": "> Hopefully that ramble makes some sense 😄\r\n\r\n@Romanx, yes it does 😄\r\n\r\n> Adding a dictionary to the JsonPropertyInfo for the ExtensionData\r\n\r\n`JsonPropertyInfo` and `JsonClassInfo` are used to cache type metadata & to set/get properties, and can be used by multiple threads at the same time. They thus can't store any (de)serialization specific state as this won't be thread-safe.\r\n\r\n`ReadStackFrame` would be a good place to add a new dictionary property to temporarily hold extension data, as each instance is specific to the deserialization of one object.\r\n\r\n> converting before returning the final result by exposing the collection conversion from the JsonConverter\r\n\r\nAfter deserialization, logic similar to what you've seen in the dictionary converters can be used to instantiate and populate the desired dictionary type. I expect this conversion to take place in the converter for the object, not one of the dictionary converters.\r\n\r\n> I managed to get the tests running on my machine\r\n\r\nGlad you were able to get this to work.",
          "createdAt": "2020-04-13T23:11:31Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2020-04-13T23:11:31Z",
          "id": "MDEyOklzc3VlQ29tbWVudDYxMzE0MDk4Mg=="
        },
        {
          "author": "Romanx",
          "body": "I'm sure you'll get a notification but i've just pushed up the branch and opened the PR for this. I'm aware there's likely to be changes so I'll wait for them. Thanks for being so kind and helpful with this 👍 \r\n\r\nI'm not wild about the internal `Convert` method on TypeConverter to access the `GetCreatorDelegate` so anything thoughts in that area would be welcome",
          "createdAt": "2020-04-18T15:08:21Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2020-04-18T15:08:21Z",
          "id": "MDEyOklzc3VlQ29tbWVudDYxNTg4NjY2NA=="
        },
        {
          "author": "krwq",
          "body": "@Romanx I assume you don't work on that anymore. This will be much easier to fix once populating objects is supported. There is a chance I will address this as part of that work but no promises (even if I don't it's going to be much easier to do).",
          "createdAt": "2023-01-27T14:54:12Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-01-27T14:54:38Z",
          "id": "IC_kwDODI9FZc5T1z19"
        },
        {
          "author": "Romanx",
          "body": "No problem removing me from this @krwq. After the PR got closed I didn't go back to taking a look at this but good to know there may be hope for this yet! :)",
          "createdAt": "2023-01-27T15:01:37Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-01-27T15:01:37Z",
          "id": "IC_kwDODI9FZc5T1195"
        }
      ],
      "totalCount": 14,
      "endCursor": "Y3Vyc29yOnYyOpHOU9dfeQ=="
    },
    "url": "https://github.com/dotnet/runtime/issues/31645",
    "title": "Support using any dictionary as JsonExtensionData"
  },
  {
    "author": "eiriktsarpalis",
    "labels": [
      "area-System.Text.Json",
      "wishlist"
    ],
    "createdAt": "2020-02-14T12:23:30Z",
    "body": "Forwarding a [report on twitter](https://twitter.com/Horusiath/status/1228190227870568449) about System.Text.Json failures when subjected to property-based testing.\r\n\r\nIt seems that the STJ parser is choking on scenaria that the Newtonsoft.Json implementation is perfectly capable of handling. I've transcribed the original report [into a standalone project](https://github.com/eiriktsarpalis/stj-bug).\r\n\r\ncc @Horusiath",
    "number": 32291,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "THUMBS_UP",
          "createdAt": "2020-02-14T13:37:54Z",
          "user": "Horusiath"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-08-17T04:22:52Z",
          "user": "WeihanLi"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-12-14T10:14:21Z",
          "user": "loraderon"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-04-04T21:41:44Z",
          "user": "p10tyr"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-12-30T07:12:36Z",
          "user": "RenderMichael"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-01-08T16:31:41Z",
          "user": "colejohnson66"
        }
      ],
      "totalCount": 6,
      "endCursor": "Y3Vyc29yOnYyOpHOC9-U4Q=="
    },
    "updatedAt": "2025-01-08T11:19:19Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": "GrabYourPitchforks",
          "body": "What is the actual test string it's failing on? The JSON deserializer mandates strict well-formedness by default (unlike Newtonsoft.Json), but there are toggles so that the caller can opt in to more relaxed behavior if necessary.",
          "createdAt": "2020-02-14T17:05:26Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2020-02-14T17:05:26Z",
          "id": "MDEyOklzc3VlQ29tbWVudDU4NjM3ODUyMA=="
        },
        {
          "author": "eiriktsarpalis",
          "body": "> What is the actual test string it's failing on?\r\n\r\nFor instance `\"\\\"\\u0018\\\"\"`, or any string with improperly escaped characters.\r\n\r\n> there are toggles so that the caller can opt in to more relaxed behavior if necessary.\r\n\r\nCould you point me to that config? I'm looking at [JsonDocumentOptions](https://docs.microsoft.com/en-us/dotnet/api/system.text.json.jsondocumentoptions?view=netcore-3.1) and can't find something relevant.",
          "createdAt": "2020-02-14T17:20:28Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2020-02-14T17:20:28Z",
          "id": "MDEyOklzc3VlQ29tbWVudDU4NjM4NDQ2Mg=="
        },
        {
          "author": "GrabYourPitchforks",
          "body": "You found the right doc, but it looks like there's no switch for opting in to malformed string handling. There's a switch malformed array handling and a few other cases. If malformed string handling is an important scenario the team should consider an opt in switch for it. It would not be enabled by default, however.",
          "createdAt": "2020-02-14T17:27:14Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2020-02-14T17:27:14Z",
          "id": "MDEyOklzc3VlQ29tbWVudDU4NjM4NzAxOA=="
        },
        {
          "author": "eiriktsarpalis",
          "body": "Being able to handle malformed json is important, since it can often come from sources you do not control. I can attest from prior experience that Newtonsoft is excellent at dealing with this.",
          "createdAt": "2020-02-14T17:33:00Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "HEART",
                "createdAt": "2023-10-13T13:16:10Z",
                "user": "taylorchasewhite"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHODJkAuQ=="
          },
          "updatedAt": "2020-02-14T17:33:00Z",
          "id": "MDEyOklzc3VlQ29tbWVudDU4NjM4OTY1Mg=="
        },
        {
          "author": "GrabYourPitchforks",
          "body": "We made a stance that we allow only well-formed payloads by default, both for security and correctness reasons. Newtonsoft is very liberal in what it allows by default (malformed payload processing, cyclic references, invalid UTF-16 generation, comment fudging). When I was doing red team work one of my favorite vectors was using these non-compliant-on-by-default behaviors to exploit applications. :)\r\n\r\nWhen I'm back on a proper desktop I'll modify this item to track adding a switch to relax the string processing behavior.",
          "createdAt": "2020-02-14T17:40:03Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2020-02-14T17:48:45Z",
                "user": "eiriktsarpalis"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-04-17T17:32:05Z",
                "user": "mklement0"
              }
            ],
            "totalCount": 2,
            "endCursor": "Y3Vyc29yOnYyOpHODeijxQ=="
          },
          "updatedAt": "2020-02-14T17:40:03Z",
          "id": "MDEyOklzc3VlQ29tbWVudDU4NjM5MjYxNQ=="
        },
        {
          "author": "eiriktsarpalis",
          "body": "A few other examples of invalid json that occur too frequently in the wild:\n\n* Missing quotes in property names: `{ foo : 42 }`\n* Singly quoted string literals: `{ 'foo' : 42  }`\n* Trailing commas: `{ \"foo\" : 42,  }` (already covered by `JsonDocumentOptions`)\n* Missing commas: `{ \"foo\" : 42 \\n \"bar\" : false }`\n* Invalid JSON strings: `\"\\\"` or `\"Misses low surrogate: \\uD801\"`\n* Trailing data after complete JSON document: https://github.com/dotnet/runtime/issues/33030",
          "createdAt": "2020-02-14T18:04:45Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "ROCKET",
                "createdAt": "2023-04-04T21:42:10Z",
                "user": "p10tyr"
              },
              {
                "content": "ROCKET",
                "createdAt": "2023-10-13T13:16:39Z",
                "user": "taylorchasewhite"
              },
              {
                "content": "ROCKET",
                "createdAt": "2024-04-17T16:32:10Z",
                "user": "SteveL-MSFT"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-04-17T17:32:13Z",
                "user": "mklement0"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-01-08T16:31:59Z",
                "user": "colejohnson66"
              }
            ],
            "totalCount": 5,
            "endCursor": "Y3Vyc29yOnYyOpHOEBiJaQ=="
          },
          "updatedAt": "2025-01-08T11:19:19Z",
          "id": "MDEyOklzc3VlQ29tbWVudDU4NjQwMjkzOA=="
        },
        {
          "author": "GrabYourPitchforks",
          "body": "Looks like you beat me to changing the title! Thanks :)",
          "createdAt": "2020-02-14T20:00:03Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2020-02-14T20:00:03Z",
          "id": "MDEyOklzc3VlQ29tbWVudDU4NjQ1MDY2Ng=="
        },
        {
          "author": null,
          "body": "Due to lack of recent activity, this issue has been marked as a candidate for backlog cleanup.  It will be closed if no further activity occurs within 14 more days. Any new comment (by anyone, not necessarily the author) will undo this process.\n\nThis process is part of the experimental [issue cleanup initiative](https://github.com/dotnet/runtime/issues/60288) we are currently trialing in a limited number of areas. Please share any feedback you might have in the linked issue.",
          "createdAt": "2021-10-19T17:03:03Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-10-19T17:03:03Z",
          "id": "IC_kwDODI9FZc44cOW_"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Adding to https://github.com/dotnet/runtime/issues/32291#issuecomment-586402938 we might also consider exposing a setting for tolerating unescaped control characters in string values.",
          "createdAt": "2021-10-22T16:58:21Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-10-22T16:58:21Z",
          "id": "IC_kwDODI9FZc44nOrN"
        },
        {
          "author": "ClementeGao",
          "body": "@eiriktsarpalis @GrabYourPitchforks  When there are special characters in the JSON string, how can I ignore them and how can I configure them\r\nsee issue  #69502 ",
          "createdAt": "2022-05-19T07:37:33Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-05-19T10:36:43Z",
          "id": "IC_kwDODI9FZc5DbvIH"
        },
        {
          "author": "p10tyr",
          "body": "Hello . \r\nIs there any option for Missing quotes in property names - Because apparently that is a normal thing from Python or PHP. I am receiving JSON from a 3rd party like this and I'm stuck now. \r\n\r\nI cant use string on API because the content type is JSON so it says failing to convert JSON to string.. yay not happy. I can use object as a last resort because it just tries to convert it to an object and getting `\"'t' is an invalid start of a property name. Expected a '\\\"'` \r\n\r\nSeems like I have to go back to Newtonsoft as I cant find any works arounds. Wasted 2 hours on this issue",
          "createdAt": "2023-04-04T21:53:08Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-10-13T13:16:58Z",
                "user": "taylorchasewhite"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-01-30T02:32:20Z",
                "user": "cli00004"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-04-17T17:24:30Z",
                "user": "mklement0"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-01-08T16:32:04Z",
                "user": "colejohnson66"
              }
            ],
            "totalCount": 4,
            "endCursor": "Y3Vyc29yOnYyOpHOEBiJfA=="
          },
          "updatedAt": "2023-04-04T21:53:08Z",
          "id": "IC_kwDODI9FZc5ZNRJE"
        },
        {
          "author": "am11",
          "body": "Just ran into this limitation while upgrading (~15yo) System.Web.Helpers.Json -based reader code to System.Text.Json.Nodes. I will switch to Newtonsoft.Json instead.\r\n\r\nHaving laxed parsing option in STJ, which encompasses Newtonsoft && S.W.H.Json behavior, is a definite improvement.",
          "createdAt": "2023-11-06T08:43:00Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-11-06T08:43:00Z",
          "id": "IC_kwDODI9FZc5q8zn1"
        },
        {
          "author": "huoyaoyuan",
          "body": "Hitting exactly the behaviors mentioned here. I'm extracting a JSON object from some JavaScript and I can confidently determine its start. It contains unquoted property names, trailing commas, and more JavaScript content after the object.",
          "createdAt": "2024-04-16T11:37:43Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-04-16T11:37:43Z",
          "id": "IC_kwDODI9FZc56uA-K"
        },
        {
          "author": "CyrusNajmabadi",
          "body": "JavaScript should produce legal Json.  How is your js producing the value?",
          "createdAt": "2024-04-16T15:20:26Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_DOWN",
                "createdAt": "2025-01-08T16:32:13Z",
                "user": "colejohnson66"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOEBiJlg=="
          },
          "updatedAt": "2024-04-16T15:20:26Z",
          "id": "IC_kwDODI9FZc56vzHR"
        },
        {
          "author": "huoyaoyuan",
          "body": "The browser engine is just more tolerant about Javascript code.",
          "createdAt": "2024-04-16T18:05:29Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-04-16T18:05:29Z",
          "id": "IC_kwDODI9FZc56w_mX"
        },
        {
          "author": "CyrusNajmabadi",
          "body": "@huoyaoyuan that didn't really answer my question.  Can you provide a repro where you're producing a json object in JS using a browser engine and it's not generating legal json?  ",
          "createdAt": "2024-04-17T02:46:05Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-04-17T02:46:05Z",
          "id": "IC_kwDODI9FZc56zMpc"
        },
        {
          "author": "huoyaoyuan",
          "body": "@CyrusNajmabadi the code I'm parsing is like this:\r\n```js\r\nObject.defineProperty(object1, \"p\", {\r\n    value: {\r\n        foo : \"bar\",\r\n        isEnabled : true,\r\n        content : { \"title\": \"title\", \"id\": 123, \"Text\": \"Text\" }\r\n    }\r\n});\r\n```\r\nYes it's inconsistent about property name, but browser and console just accepts it.",
          "createdAt": "2024-04-17T02:55:54Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-04-17T02:55:54Z",
          "id": "IC_kwDODI9FZc56zPg7"
        },
        {
          "author": "CyrusNajmabadi",
          "body": "That's a JavaScript object, not Json.  Json is a subset. \n\nIf you *serialize* that object to Json (using the actual js APIs for that purpose) you'll get Json that can be parsed. \n\n--\n\nTo be as clear as possible, Json is not for parsing arbitrary JavaScript.  It's for Json objects. ",
          "createdAt": "2024-04-17T04:05:18Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-04-17T09:50:46Z",
                "user": "eiriktsarpalis"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHODeenZA=="
          },
          "updatedAt": "2024-04-17T04:05:18Z",
          "id": "IC_kwDODI9FZc56zb7b"
        },
        {
          "author": "SteveL-MSFT",
          "body": "Having options for the JSON document during parsing to be more lenient would be great for interactive users using PowerShell https://github.com/PowerShell/PowerShell/issues/21338",
          "createdAt": "2024-04-17T16:34:03Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-04-17T16:34:03Z",
          "id": "IC_kwDODI9FZc5642gl"
        }
      ],
      "totalCount": 19,
      "endCursor": "Y3Vyc29yOnYyOpHOeuNoJQ=="
    },
    "url": "https://github.com/dotnet/runtime/issues/32291",
    "title": "System.Text.Json parser should optionally tolerate malformed json"
  },
  {
    "author": "ahsonkhan",
    "labels": [
      "area-System.Text.Json",
      "increase-code-coverage",
      "test-enhancement",
      "help wanted"
    ],
    "createdAt": "2020-02-14T23:44:20Z",
    "body": "Let's try to get the test coverage of all components of the JSON stack closer to 100%, where feasible. \r\nWe are in pretty good shape (well over 90%+). It tends to be much easier to maintain the bar once we hit 100% since any drop becomes clear/visible.\r\n\r\nOne component that is effectively at 100% is `JsonElement`. Let's see if we can get there for the rest.\r\n\r\nThat said, we shouldn't bend over backwards to try to get to 100% for things like testing all the conditions of a `Debug.Asserts` or return line after a throw. If some code is unreachable or not used, update/delete it.\r\n\r\n**Some test improvements are relatively easy to do, so I encourage folks who want to help contribute to `System.Text.Json` to start there.** Others might require more work to bridge the test gap.\r\n\r\n```text\r\n +------------------+--------+--------+--------+\r\n  | Module           | Line   | Branch | Method |\r\n  +------------------+--------+--------+--------+\r\n  | System.Text.Json | 94.04% | 91.22% | 98.05% |\r\n  +------------------+--------+--------+--------+\r\n  +---------+--------+--------+--------+\r\n  |         | Line   | Branch | Method |\r\n  +---------+--------+--------+--------+\r\n  | Total   | 94.04% | 91.22% | 98.05% |\r\n  +---------+--------+--------+--------+\r\n  | Average | 94.04% | 91.22% | 98.05% |\r\n  +---------+--------+--------+--------+\r\n```\r\n**Here's our current JSON test coverage numbers for .NET Core** (including outerloop which takes ~10 minutes to generate):\r\n[report.zip](https://github.com/dotnet/runtime/files/4207266/report.zip)\r\n\r\n**Steps to generate:**\r\nFollowing the steps from https://github.com/dotnet/runtime/blob/master/docs/workflow/building/libraries/README.md#quick-start\r\n```text\r\n1) build.cmd clr+libs -rc Release (this step takes ~10-20 minutes)\r\n2) cd src\\libraries\\System.Text.Json\\tests\r\n3) If you want a quick report (~2 minutes), don't run the outerloop tests.\r\n   a) dotnet build /t:Test /p:Coverage=true /p:BuildTargetFramework=net6.0\r\n   b) dotnet build /t:Test /p:Coverage=true /p:BuildTargetFramework=net6.0 /p:Outerloop=true\r\n```\r\n\r\n**Here are some good starting points:**\r\n1) JsonDocumentOptions\r\nhttps://github.com/dotnet/runtime/blob/f5874b08b53665ce950b76b628deb63abecaee85/src/libraries/System.Text.Json/src/System/Text/Json/Document/JsonDocumentOptions.cs#L12\r\n- [x] a)\r\n![image](https://user-images.githubusercontent.com/6527137/74575890-90410100-4f3d-11ea-8465-915f9258ba39.png)\r\n\r\n2) JsonHelpers\r\nhttps://github.com/dotnet/runtime/blob/f5874b08b53665ce950b76b628deb63abecaee85/src/libraries/System.Text.Json/src/System/Text/Json/JsonHelpers.cs#L12\r\n- [ ] a) \r\n![image](https://user-images.githubusercontent.com/6527137/74576082-5ae8e300-4f3e-11ea-9971-d02d4655a73e.png)\r\n- [x] b)\r\n![image](https://user-images.githubusercontent.com/6527137/74576101-69cf9580-4f3e-11ea-892a-324d16b4f4db.png)\r\n- [ ] c)\r\n![image](https://user-images.githubusercontent.com/6527137/74576111-705e0d00-4f3e-11ea-93bd-42ac793c918f.png)\r\n- [ ] d)\r\n![image](https://user-images.githubusercontent.com/6527137/74576127-823fb000-4f3e-11ea-8368-e831991fa1e1.png)\r\n\r\n3) JsonClassInfo\r\nhttps://github.com/dotnet/runtime/blob/f5874b08b53665ce950b76b628deb63abecaee85/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/JsonClassInfo.cs#L17\r\n- [ ] a)\r\n![image](https://user-images.githubusercontent.com/6527137/74575800-304a5a80-4f3d-11ea-9863-3b8cd2da9f70.png)\r\n- [x] b)\r\n![image](https://user-images.githubusercontent.com/6527137/74575813-43f5c100-4f3d-11ea-8fd8-357158ec440b.png)\r\n- [ ] c)\r\n![image](https://user-images.githubusercontent.com/6527137/74575828-55d76400-4f3d-11ea-8a0f-9e404966450f.png)\r\n\r\n4) JsonPropertyInfo\r\nhttps://github.com/dotnet/runtime/blob/f5874b08b53665ce950b76b628deb63abecaee85/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/JsonPropertyInfo.cs#L14\r\n- [ ] a)\r\n![image](https://user-images.githubusercontent.com/6527137/74576152-94b9e980-4f3e-11ea-8d48-f33598b02e9f.png)\r\n\r\n5) JsonPropertyInfoOfTTypeToConvert\r\nhttps://github.com/dotnet/runtime/blob/f5874b08b53665ce950b76b628deb63abecaee85/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/JsonPropertyInfoOfTTypeToConvert.cs#L14\r\n- [ ] a)\r\n![image](https://user-images.githubusercontent.com/6527137/74576187-ae5b3100-4f3e-11ea-9343-4ad968f6779f.png)\r\n\r\n6) JsonReaderHelper\r\nhttps://github.com/dotnet/runtime/blob/f5874b08b53665ce950b76b628deb63abecaee85/src/libraries/System.Text.Json/src/System/Text/Json/Reader/JsonReaderHelper.cs#L13\r\n- [x] a)\r\n![image](https://user-images.githubusercontent.com/6527137/74576240-d9de1b80-4f3e-11ea-8219-8d3a46c40307.png)\r\n\r\n7) JsonSerializer\r\nhttps://github.com/dotnet/runtime/blob/527adf211a45046876d680480e45131b5334fcf6/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/JsonSerializer.Read.HandleMetadata.cs#L10\r\n- [x] a)\r\n![image](https://user-images.githubusercontent.com/6527137/74576415-79031300-4f3f-11ea-9809-ac9476b2ad99.png)\r\n- [ ] b)\r\n![image](https://user-images.githubusercontent.com/6527137/74576351-3ccfb280-4f3f-11ea-9b02-f6a8950488db.png)\r\n- [ ] c)\r\n![image](https://user-images.githubusercontent.com/6527137/74576396-6d175100-4f3f-11ea-8235-686224c13a8f.png)\r\n- [ ] d)\r\n![image](https://user-images.githubusercontent.com/6527137/74576426-86200200-4f3f-11ea-91a1-3b9fe2f22854.png)\r\n- [ ] e)\r\n![image](https://user-images.githubusercontent.com/6527137/74576434-91732d80-4f3f-11ea-8e65-7e3130d218c3.png)\r\n- [x] f)\r\n![image](https://user-images.githubusercontent.com/6527137/74576440-9d5eef80-4f3f-11ea-9702-f3284a13805c.png)\r\n\r\n8) JsonSerializerOptions\r\nhttps://github.com/dotnet/runtime/blob/527adf211a45046876d680480e45131b5334fcf6/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/JsonSerializerOptions.cs#L15\r\n- [ ] a)\r\n![image](https://user-images.githubusercontent.com/6527137/74576453-ae0f6580-4f3f-11ea-9318-3572e57f50d9.png)\r\n\r\n9) ArrayConverter\r\nhttps://github.com/dotnet/runtime/blob/527adf211a45046876d680480e45131b5334fcf6/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/Converters/Collection/ArrayConverter.cs#L14\r\n- [ ] a)\r\n![image](https://user-images.githubusercontent.com/6527137/74576494-d72ff600-4f3f-11ea-8658-0a94794b053f.png)\r\n\r\n10) ConcurrentStackOfTConverter\r\nhttps://github.com/dotnet/runtime/blob/527adf211a45046876d680480e45131b5334fcf6/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/Converters/Collection/ConcurrentStackOfTConverter.cs#L11\r\n- [ ] a)\r\n![image](https://user-images.githubusercontent.com/6527137/74576522-fcbcff80-4f3f-11ea-92c9-4727db1a0a5f.png)\r\n\r\n11) JsonConverterOfT.cs\r\nhttps://github.com/dotnet/runtime/blob/b95e523a3003a5744506239ceaac2aafa3ac9a9d/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/JsonConverterOfT.cs#L14\r\n- [ ] a)\r\n![image](https://user-images.githubusercontent.com/6527137/74576556-355cd900-4f40-11ea-8d04-9ffd25ec2003.png)\r\n- [ ] b)\r\n![image](https://user-images.githubusercontent.com/6527137/74576562-3beb5080-4f40-11ea-8d0f-1e2812086f9e.png)\r\n- [ ] c)\r\n![image](https://user-images.githubusercontent.com/6527137/74576573-43125e80-4f40-11ea-8494-3b425f8d2be8.png)\r\n\r\n\r\ncc @Jozkee, @layomia, @steveharter ",
    "number": 32341,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "THUMBS_UP",
          "createdAt": "2020-03-25T14:47:05Z",
          "user": "memark"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2020-06-17T20:12:14Z",
          "user": "Havunen"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2020-06-24T08:41:08Z",
          "user": "doublnt"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-10-02T00:10:52Z",
          "user": "jmoralesv"
        }
      ],
      "totalCount": 4,
      "endCursor": "Y3Vyc29yOnYyOpHOCy92Bw=="
    },
    "updatedAt": "2021-10-21T17:27:26Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": "alanisaac",
          "body": "I can pick up some of this work, so long as it'd be OK for a first contribution to the dotnet runtime.  I've started on a couple in a draft PR (#32705), and will continue to work through them.",
          "createdAt": "2020-02-23T04:17:20Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "HEART",
                "createdAt": "2020-02-25T20:31:46Z",
                "user": "ahsonkhan"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2020-03-25T14:47:00Z",
                "user": "memark"
              }
            ],
            "totalCount": 2,
            "endCursor": "Y3Vyc29yOnYyOpHOA_HEHA=="
          },
          "updatedAt": "2020-02-23T04:17:20Z",
          "id": "MDEyOklzc3VlQ29tbWVudDU5MDAyNDkyNA=="
        },
        {
          "author": "alexvy86",
          "body": "@ahsonkhan I started looking into this and ran into an issue running the tests, which I then traced to [the fact that the `RebuildAndTest` target was recently removed](https://github.com/dotnet/runtime/issues/33171). Maybe you want to update the commands in the description of this issue? (`/t:RebuildAndTest` becomes `/t:Test`)\r\n```\r\n   a) dotnet msbuild /t:Test /p:Coverage=true\r\n   b) dotnet msbuild /t:Test /p:Coverage=true /p:Outerloop=true\r\n```",
          "createdAt": "2020-04-02T05:18:05Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2020-04-02T05:23:00Z",
                "user": "jozkee"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2020-04-03T20:53:26Z",
                "user": "ahsonkhan"
              }
            ],
            "totalCount": 2,
            "endCursor": "Y3Vyc29yOnYyOpHOBAGWNQ=="
          },
          "updatedAt": "2020-04-02T05:18:05Z",
          "id": "MDEyOklzc3VlQ29tbWVudDYwNzYyNjU5Ng=="
        },
        {
          "author": "jozkee",
          "body": "@alexvy86 done; thanks for pointing that out.",
          "createdAt": "2020-04-02T05:32:44Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2020-04-02T05:32:44Z",
          "id": "MDEyOklzc3VlQ29tbWVudDYwNzYzMDQxMA=="
        },
        {
          "author": "ahsonkhan",
          "body": "> I started looking into this and ran into an issue running the tests\r\n\r\nDo the build instructions need to be updated as well (step 1) or did that work as expected for you? I know there were some recent changes there too (cc @ViktorHofer).",
          "createdAt": "2020-04-03T20:56:09Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2020-04-03T20:56:09Z",
          "id": "MDEyOklzc3VlQ29tbWVudDYwODY1NDAzNQ=="
        },
        {
          "author": "alexvy86",
          "body": "The build worked fine, it was only running the tests that wasn't working.",
          "createdAt": "2020-04-03T21:00:01Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2020-04-03T21:00:48Z",
                "user": "ahsonkhan"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOBAGZtA=="
          },
          "updatedAt": "2020-04-03T21:00:01Z",
          "id": "MDEyOklzc3VlQ29tbWVudDYwODY1NTU1NQ=="
        },
        {
          "author": "thall90",
          "body": "I'm looking at testing portions of 2 (`JsonHelpers`) for a first-time contribution, and was wondering: \r\nis it acceptable to expose internal classes for testing with something like `[assembly: InternalsVisibleTo(\"System.Text.Json.Tests\")]`, or should these classes be tested via outcomes of areas calling their methods?",
          "createdAt": "2020-04-19T20:54:47Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2020-04-19T21:03:19Z",
          "id": "MDEyOklzc3VlQ29tbWVudDYxNjIyMzY4Mg=="
        },
        {
          "author": "jozkee",
          "body": "@thall90  My understanding is that we should avoid using `InternalsVisibleTo` on test projects as much as we can, I think there has also been efforts to remove its usage on several projects.\r\nSee related discussions:\r\nhttps://github.com/dotnet/corefx/pull/42879#discussion_r393850831\r\nhttps://github.com/dotnet/runtime/issues/14520#issuecomment-98319086\r\n\r\n\r\n",
          "createdAt": "2020-04-20T01:39:37Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2020-04-20T16:46:51Z",
                "user": "thall90"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOBBpC8Q=="
          },
          "updatedAt": "2020-04-20T01:39:37Z",
          "id": "MDEyOklzc3VlQ29tbWVudDYxNjI2NDc0Mw=="
        },
        {
          "author": "thall90",
          "body": "Sounds good. Thanks!",
          "createdAt": "2020-04-20T16:47:06Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2020-04-20T16:47:06Z",
          "id": "MDEyOklzc3VlQ29tbWVudDYxNjY3NjUzMQ=="
        },
        {
          "author": "KimKiHyuk",
          "body": "@thall90 you still work in progress on JsonHelpers?\r\n\r\nif not, i hope to take it",
          "createdAt": "2020-08-12T11:31:18Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2020-08-12T14:00:53Z",
          "id": "MDEyOklzc3VlQ29tbWVudDY3MjgxNjc1MQ=="
        },
        {
          "author": "GMous",
          "body": "It looks like the steps to generate coverage report need to be updated. Parameters \"-subsetCategory\" are no longer available. New version:\r\nbuild.cmd -subset Clr -c Release && build.cmd -subset Libraries /p:CoreCLRConfiguration=Release",
          "createdAt": "2020-09-19T15:08:19Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2020-09-19T15:08:19Z",
          "id": "MDEyOklzc3VlQ29tbWVudDY5NTIzOTg3Mg=="
        },
        {
          "author": "ViktorHofer",
          "body": "build.cmd clr+libs -c Release",
          "createdAt": "2020-09-19T15:37:05Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2020-09-19T17:24:12Z",
                "user": "ahsonkhan"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2020-09-22T06:39:05Z",
                "user": "GMous"
              }
            ],
            "totalCount": 2,
            "endCursor": "Y3Vyc29yOnYyOpHOBRF8pA=="
          },
          "updatedAt": "2020-09-19T15:37:19Z",
          "id": "MDEyOklzc3VlQ29tbWVudDY5NTI3NTA0Mw=="
        },
        {
          "author": "z77ma",
          "body": "Hey guys. Wanted to get an actual coverage report, but the tests/report generating working sooo slow which confuses me a bit, I'm certain I missed smth and I'd appreciate an advice here. If it's important, then builds in both Debug and Release configuration are fine and take 'normal' time for such big code-base.",
          "createdAt": "2020-10-18T15:42:59Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2020-10-18T15:42:59Z",
          "id": "MDEyOklzc3VlQ29tbWVudDcxMTIzNzE0Ng=="
        },
        {
          "author": "ViktorHofer",
          "body": "> but the tests/report generating working sooo slow which confuses me a bit, I'm certain I missed smth and I'd appreciate an advice here.\r\n\r\nhey @z77ma, what do you mean by slow? Do you have data to share?",
          "createdAt": "2020-10-19T17:09:22Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2020-10-19T17:09:22Z",
          "id": "MDEyOklzc3VlQ29tbWVudDcxMjMwNTkwMQ=="
        },
        {
          "author": "jozkee",
          "body": "@z77ma @ViktorHofer it sounds like the runtime subset was built on Debug configuration. \r\n\r\n@z77ma did you build using the suggested configuration?\r\n> build.cmd clr+libs -c Release",
          "createdAt": "2020-10-19T21:55:29Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2020-10-19T22:03:00Z",
          "id": "MDEyOklzc3VlQ29tbWVudDcxMjQ2NDE4Mw=="
        },
        {
          "author": "ahsonkhan",
          "body": "I updated the instructions in the original post of the issue:\r\n\r\n**Steps to generate:**\r\nFollowing the steps from https://github.com/dotnet/runtime/blob/master/docs/workflow/building/libraries/README.md#quick-start\r\n```text\r\n1) build.cmd clr+libs -rc Release (this step takes ~10-20 minutes)\r\n2) cd src\\libraries\\System.Text.Json\\tests\r\n3) If you want a quick report (~2 minutes), don't run the outerloop tests (which would take ~10 minutes).\r\n   a) dotnet build /t:Test /p:Coverage=true /p:BuildTargetFramework=net6.0\r\n   b) dotnet build /t:Test /p:Coverage=true /p:BuildTargetFramework=net6.0 /p:Outerloop=true\r\n```",
          "createdAt": "2020-10-20T08:09:06Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2020-10-20T08:31:01Z",
                "user": "jozkee"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOBUBlHQ=="
          },
          "updatedAt": "2020-10-20T08:09:19Z",
          "id": "MDEyOklzc3VlQ29tbWVudDcxMjY3NDg4OA=="
        },
        {
          "author": "z77ma",
          "body": "Hey all.\r\n@ViktorHofer, well I didn't preserve any results from that runs, but the longest attempt I had the patience to wait for lasted for approx. 3h and I killed the process afterward. \r\n@Jozkee, yes, I did use the suggested configuration. Basically, my question came as a result of an unexpected duration of a test run in Release configuration.\r\nAnyway, today I tried to repeat all steps from scratch in order to provide more information and some statistics for you. And the issue seems to be gone. Though I can't completely explain what caused the described behavior. The things that differ from my previous attempt are: I build the whole runtime on Release configuration (build.cmd -c Release) and then I used the build command with the -rc flag, as @ahsonkhan suggested.\r\nNone of the above doesn't convince me to be a cure. So all looks like I messed smth with the configurations and run tests on Debug build.\r\nI appreciate your help and suggestions. Cheers)",
          "createdAt": "2020-11-01T22:10:34Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2020-11-01T23:50:42Z",
                "user": "ViktorHofer"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOBVYG7g=="
          },
          "updatedAt": "2020-11-01T22:10:34Z",
          "id": "MDEyOklzc3VlQ29tbWVudDcyMDE1OTU5NA=="
        }
      ],
      "totalCount": 16,
      "endCursor": "Y3Vyc29yOnYyOpHOKuzDag=="
    },
    "url": "https://github.com/dotnet/runtime/issues/32341",
    "title": "Help get System.Text.Json test coverage to 100% (or close to it)"
  },
  {
    "author": "ahsonkhan",
    "labels": [
      "area-System.Text.Json",
      "backlog-cleanup-candidate"
    ],
    "createdAt": "2020-02-15T01:53:28Z",
    "body": "https://github.com/dotnet/runtime/blob/d4b06b1a9e3c56e343c42efad2211c04c196a0cf/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/JsonSerializer.Read.Stream.cs#L95\r\n\r\ncc @steveharter ",
    "number": 32355,
    "reactions": {
      "hasNextPage": false,
      "nodes": [],
      "totalCount": 0,
      "endCursor": null
    },
    "updatedAt": "2022-02-18T18:34:02Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": "davidfowl",
          "body": "ArrayBufferWriter doesn't pool currently. That's likely a performance regression",
          "createdAt": "2020-02-15T02:04:04Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2020-02-15T02:04:04Z",
          "id": "MDEyOklzc3VlQ29tbWVudDU4NjU0MjY2Nw=="
        },
        {
          "author": "ahsonkhan",
          "body": "Yep, agreed. Since this is used internally, in this case, we can consider using `PooledByteBufferWriter` just like what we do on the Serialize/Write side.",
          "createdAt": "2020-02-15T02:23:25Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2020-02-15T02:40:21Z",
                "user": "davidfowl"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOA7qxvQ=="
          },
          "updatedAt": "2020-02-15T02:23:25Z",
          "id": "MDEyOklzc3VlQ29tbWVudDU4NjU0NDMzMw=="
        },
        {
          "author": "scalablecory",
          "body": "Consider using the `ArrayBuffer` we use in System.Net.",
          "createdAt": "2020-02-15T09:00:45Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2020-02-15T09:00:45Z",
          "id": "MDEyOklzc3VlQ29tbWVudDU4NjU2OTk3MA=="
        },
        {
          "author": "ahsonkhan",
          "body": "That's essentially identical to `PooledByteBufferWriter`, if it also implemented the `IBufferWriter<byte>` interface (with slightly different growth logic). We should consider merging these and having only one copy.\r\n\r\nhttps://github.com/dotnet/runtime/blob/f06f46c049e442d34950884783b4b85f7e6c1532/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/PooledByteBufferWriter.cs#L13-L16",
          "createdAt": "2020-02-15T09:24:38Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2020-02-17T09:35:42Z",
                "user": "gfoidl"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOA7vVZQ=="
          },
          "updatedAt": "2020-02-15T09:25:40Z",
          "id": "MDEyOklzc3VlQ29tbWVudDU4NjU3MTY1Nw=="
        },
        {
          "author": null,
          "body": "Due to lack of recent activity, this issue has been marked as a candidate for backlog cleanup.  It will be closed if no further activity occurs within 14 more days. Any new comment (by anyone, not necessarily the author) will undo this process.\n\nThis process is part of the experimental [issue cleanup initiative](https://github.com/dotnet/runtime/issues/60288) we are currently trialing in a limited number of areas. Please share any feedback you might have in the linked issue.",
          "createdAt": "2021-10-17T00:34:52Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-10-17T00:34:52Z",
          "id": "IC_kwDODI9FZc44U_mu"
        },
        {
          "author": "ahsonkhan",
          "body": "The source still has the todo comment, likely worth addressing manually, or closing explicitly.",
          "createdAt": "2021-10-19T23:56:50Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-10-20T12:01:11Z",
                "user": "eiriktsarpalis"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOB_Ej3A=="
          },
          "updatedAt": "2021-10-19T23:56:50Z",
          "id": "IC_kwDODI9FZc44dQN_"
        }
      ],
      "totalCount": 6,
      "endCursor": "Y3Vyc29yOnYyOpHOOHUDfw=="
    },
    "url": "https://github.com/dotnet/runtime/issues/32355",
    "title": "Investigate switching to ArrayBufferWriter impl to simplify grow logic when reading from stream in JsonSerializer"
  },
  {
    "author": "stevendarby",
    "labels": [
      "area-System.Text.Json",
      "wishlist"
    ],
    "createdAt": "2020-03-09T21:59:33Z",
    "body": "Newtonsoft.Json has a `ErrorHandler` call back that lets you inspect and continue on error. MVC uses this to report all the errors during JSON deserialization\r\n\r\n* https://www.newtonsoft.com/json/help/html/P_Newtonsoft_Json_JsonSerializerSettings_Error.htm\r\n* https://github.com/dotnet/aspnetcore/blob/master/src/Mvc/Mvc.NewtonsoftJson/src/NewtonsoftJsonInputFormatter.cs#L175\r\n* https://github.com/dotnet/aspnetcore/blob/master/src/Mvc/Mvc.NewtonsoftJson/src/NewtonsoftJsonInputFormatter.cs#L224-L276\r\n\r\nThe ask is to consider doing something similar for S.T.J\r\n\r\n\r\n-------------------------------------\r\n# Original issue text\r\n### Describe the bug\r\nIf my request model has a DateTime but an invalid date string is supplied in the JSON, an error is added to the ModelState, e.g. \"The JSON value could not be converted to System.DateTime. Path: $.dateProperty | LineNumber: 1 | BytePositionInLine: 43.\"\r\n\r\nNo other validation messages are added because model binding appears to completely halt at this step. If I disable the automatic 400 response I can see the model is null.\r\n\r\nThis differs from Newtonsoft - invalid dates would add an error message but the model binding and validation process would continue. This allows you to catch and report all validation errors to the user. With STJ, if there are two invalid dates, the user can only find out about one at a time.\r\n\r\nAs the JSON as a whole is not malformed, it's just that the format of one of the values is wrong, I really think the model binding/validation should continue.\r\n\r\n### Further technical details\r\n- ASP.NET Core version: 3.1\r\n.NET Core SDK (reflecting any global.json):\r\n Version:   3.1.101\r\n Commit:    b377529961\r\n\r\nRuntime Environment:\r\n OS Name:     Windows\r\n OS Version:  10.0.18362\r\n OS Platform: Windows\r\n RID:         win10-x64\r\n Base Path:   C:\\Program Files\\dotnet\\sdk\\3.1.101\\\r\n\r\nHost (useful for support):\r\n  Version: 3.1.1\r\n  Commit:  a1388f194c\r\n\r\n.NET Core SDKs installed:\r\n  2.0.3 [C:\\Program Files\\dotnet\\sdk]\r\n  2.1.102 [C:\\Program Files\\dotnet\\sdk]\r\n  2.1.104 [C:\\Program Files\\dotnet\\sdk]\r\n  2.1.200 [C:\\Program Files\\dotnet\\sdk]\r\n  2.1.202 [C:\\Program Files\\dotnet\\sdk]\r\n  2.1.402 [C:\\Program Files\\dotnet\\sdk]\r\n  2.1.508 [C:\\Program Files\\dotnet\\sdk]\r\n  2.1.701 [C:\\Program Files\\dotnet\\sdk]\r\n  2.2.108 [C:\\Program Files\\dotnet\\sdk]\r\n  2.2.301 [C:\\Program Files\\dotnet\\sdk]\r\n  3.0.100 [C:\\Program Files\\dotnet\\sdk]\r\n  3.1.101 [C:\\Program Files\\dotnet\\sdk]\r\n\r\n.NET Core runtimes installed:\r\n  Microsoft.AspNetCore.All 2.1.4 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.All]\r\n  Microsoft.AspNetCore.All 2.1.12 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.All]\r\n  Microsoft.AspNetCore.All 2.1.15 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.All]\r\n  Microsoft.AspNetCore.All 2.2.6 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.All]\r\n  Microsoft.AspNetCore.All 2.2.8 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.All]\r\n  Microsoft.AspNetCore.App 2.1.4 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.AspNetCore.App 2.1.12 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.AspNetCore.App 2.1.15 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.AspNetCore.App 2.2.6 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.AspNetCore.App 2.2.8 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.AspNetCore.App 3.0.0 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.AspNetCore.App 3.1.1 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.NETCore.App 2.0.3 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 2.0.6 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 2.0.7 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 2.0.9 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 2.1.4 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 2.1.12 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 2.1.15 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 2.2.6 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 2.2.8 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 3.0.0 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 3.1.1 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.WindowsDesktop.App 3.0.0 [C:\\Program Files\\dotnet\\shared\\Microsoft.WindowsDesktop.App]\r\n  Microsoft.WindowsDesktop.App 3.1.1 [C:\\Program Files\\dotnet\\shared\\Microsoft.WindowsDesktop.App]\r\n- Visual Studio 2019 \r\n",
    "number": 38049,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "THUMBS_UP",
          "createdAt": "2020-06-18T16:26:27Z",
          "user": "nhart12"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-04-04T08:26:51Z",
          "user": "stevendarby"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-08-08T19:20:04Z",
          "user": "ianc1"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-11-10T20:59:47Z",
          "user": "omidkrad"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-02-14T14:58:04Z",
          "user": "penguinawesome"
        },
        {
          "content": "HEART",
          "createdAt": "2022-02-14T14:58:12Z",
          "user": "penguinawesome"
        },
        {
          "content": "ROCKET",
          "createdAt": "2022-05-02T15:25:04Z",
          "user": "penguinawesome"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-05-05T02:05:23Z",
          "user": "sellorio2"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-05-12T00:39:14Z",
          "user": "yeica"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-05-23T14:50:36Z",
          "user": "kolinekp"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-06-07T19:34:43Z",
          "user": "Mark-Branscum"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-07-01T15:39:42Z",
          "user": "svickers"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-07-07T16:38:23Z",
          "user": "martincostello"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-07-12T18:44:20Z",
          "user": "SyntOwl"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-07-14T07:26:13Z",
          "user": "Edelbitter"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-07-17T01:10:21Z",
          "user": "eatdrinksleepcode"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-07-24T09:53:13Z",
          "user": "arutskoy"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-08-02T05:09:18Z",
          "user": "nirajagarwal"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-08-22T08:16:56Z",
          "user": "dd-inno"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-08-24T13:54:36Z",
          "user": "gary-roach"
        },
        {
          "content": "HEART",
          "createdAt": "2022-08-24T13:54:39Z",
          "user": "gary-roach"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-08-29T17:21:03Z",
          "user": "StefanBulka"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-09-02T13:16:58Z",
          "user": "ulfkri"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-09-26T21:33:56Z",
          "user": "alefranz"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-09-28T00:27:30Z",
          "user": "metaturso"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-11-07T11:25:30Z",
          "user": "ragnar474"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-11-09T23:07:44Z",
          "user": "Driedas"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-11-12T18:26:52Z",
          "user": "BigBang1112"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-11-15T10:46:08Z",
          "user": "clane2812"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-11-21T22:21:19Z",
          "user": "fitzychan"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-11-29T11:41:47Z",
          "user": "lynkz-matt-psaltis"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-01-12T01:39:25Z",
          "user": "jarroda"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-01-13T14:06:39Z",
          "user": "olivermue"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-01-14T23:28:45Z",
          "user": "mpdelbuono"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-01-23T20:04:48Z",
          "user": "joelweiss"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-01-26T07:01:06Z",
          "user": "gokhanabatay"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-02-09T00:29:54Z",
          "user": "domn1995"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-03-10T11:42:23Z",
          "user": "MikhailIvanou"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-04-26T21:32:22Z",
          "user": "bkaidbb"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-06-03T15:41:24Z",
          "user": "Vleerian"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-07-30T21:32:49Z",
          "user": "Wuerike"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-08-11T11:31:09Z",
          "user": "artembrizinskij"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-09-02T17:19:17Z",
          "user": "KoenZomers"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-09-08T08:19:12Z",
          "user": "ultradevel"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-09-20T14:17:58Z",
          "user": "akamyshanov"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-09-26T11:50:07Z",
          "user": "jukkahyv"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-10-26T17:58:05Z",
          "user": "cshaw-dmg"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-11-30T15:07:45Z",
          "user": "JaimeStill"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-12-05T13:35:52Z",
          "user": "justintoth"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-12-16T17:42:03Z",
          "user": "YuriySlobodenyuk"
        },
        {
          "content": "ROCKET",
          "createdAt": "2023-12-16T17:42:11Z",
          "user": "TrezorTop"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-12-16T17:42:12Z",
          "user": "TrezorTop"
        },
        {
          "content": "HEART",
          "createdAt": "2023-12-16T17:42:13Z",
          "user": "TrezorTop"
        },
        {
          "content": "ROCKET",
          "createdAt": "2023-12-16T17:42:19Z",
          "user": "YuriySlobodenyuk"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-12-22T13:34:17Z",
          "user": "ijat"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-12-29T20:46:17Z",
          "user": "Ghost4Man"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-01-05T11:28:34Z",
          "user": "Garand-Gary"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-02-20T00:51:39Z",
          "user": "Blaisor"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-02-26T07:45:44Z",
          "user": "PTerentev"
        },
        {
          "content": "HEART",
          "createdAt": "2024-02-26T07:45:46Z",
          "user": "PTerentev"
        },
        {
          "content": "ROCKET",
          "createdAt": "2024-02-26T07:45:47Z",
          "user": "PTerentev"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-03-11T13:39:01Z",
          "user": "vaishnaviithamraju"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-04-11T19:23:15Z",
          "user": "danbopes"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-04-13T03:47:55Z",
          "user": "Tape-Worm"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-04-25T18:11:44Z",
          "user": "colindawson"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-05-15T02:58:31Z",
          "user": "ben-smith-dev"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-06-05T10:54:18Z",
          "user": "Genmutant"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-06-12T09:00:18Z",
          "user": "antoinebj"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-08-26T06:12:46Z",
          "user": "Naveen61097"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-08-26T08:21:44Z",
          "user": "vishal2447"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-08-26T11:59:18Z",
          "user": "floatingbrij"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-09-03T20:33:46Z",
          "user": "victorsebrito"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-10-08T00:05:36Z",
          "user": "davidcoderman"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-10-16T02:31:08Z",
          "user": "issue-dispenser"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-10-23T12:59:54Z",
          "user": "HO-COOH"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-10-29T13:41:12Z",
          "user": "psmycz"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-10-31T10:29:21Z",
          "user": "cheng0000"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-11-04T13:41:17Z",
          "user": "r-ising"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-11-06T10:27:29Z",
          "user": "sherman89"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-11-18T08:55:25Z",
          "user": "evorios"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-01-03T20:09:35Z",
          "user": "mirekkukla"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-01-27T12:02:59Z",
          "user": "bart-vmware"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-02-28T12:14:47Z",
          "user": "sergiu-enache"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-03-04T10:44:12Z",
          "user": "JWMB"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-03-12T19:54:17Z",
          "user": "DonKedero"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-05-01T05:37:21Z",
          "user": "ldugdale-tmx"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-06-04T00:06:42Z",
          "user": "MegaXa"
        }
      ],
      "totalCount": 87,
      "endCursor": "Y3Vyc29yOnYyOpHOC0sAIg=="
    },
    "updatedAt": "2025-03-31T19:36:21Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": "stevendarby",
          "body": "Digging around the source code a bit, the Newtonsoft deserializer doesn't stop on exceptions and it allows you to attach an error handler to deal with exceptions that occur during deserialization. The input formatter makes use of that error handler to add errors to the ModelState while the deserialization process continues to the end. \r\n\r\nThe STJ deserializer stops on the first exception, and while that exception is added to the ModelState (if an appropriate exception type) it means you cannot build up a complete ModelState of all the errors.\r\n\r\nI would really like to see the Newtonsoft feature come to STJ / the STJ input formatter.",
          "createdAt": "2020-03-10T07:32:33Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2020-03-10T07:32:33Z",
          "id": "MDEyOklzc3VlQ29tbWVudDU5Njk0Mzk2Mg=="
        },
        {
          "author": "pranavkm",
          "body": "@ericstj would you consider a feature like this for System.Text.Json? \r\n\r\nNewtonsoft.Json has a `ErrorHandler` call back that lets you inspect and continue on error. MVC uses this to report all the errors during JSON deserialization\r\n\r\n* https://www.newtonsoft.com/json/help/html/P_Newtonsoft_Json_JsonSerializerSettings_Error.htm\r\n* https://github.com/dotnet/aspnetcore/blob/master/src/Mvc/Mvc.NewtonsoftJson/src/NewtonsoftJsonInputFormatter.cs#L175\r\n* https://github.com/dotnet/aspnetcore/blob/master/src/Mvc/Mvc.NewtonsoftJson/src/NewtonsoftJsonInputFormatter.cs#L224-L276",
          "createdAt": "2020-03-10T18:00:48Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2020-06-17T21:38:33Z",
                "user": "stevendarby"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-02-14T14:58:46Z",
                "user": "penguinawesome"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-07-01T15:37:20Z",
                "user": "svickers"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-07-24T09:53:23Z",
                "user": "arutskoy"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-01-13T14:06:56Z",
                "user": "olivermue"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-12-05T13:36:04Z",
                "user": "justintoth"
              }
            ],
            "totalCount": 6,
            "endCursor": "Y3Vyc29yOnYyOpHODOjcLw=="
          },
          "updatedAt": "2020-03-10T18:00:48Z",
          "id": "MDEyOklzc3VlQ29tbWVudDU5NzIyOTg5OA=="
        },
        {
          "author": "ericstj",
          "body": "I'm not sure we've considered such a feature before.  @sharter @layomia what do you think?",
          "createdAt": "2020-03-10T18:46:05Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2020-03-10T18:46:05Z",
          "id": "MDEyOklzc3VlQ29tbWVudDU5NzI1MTM2OA=="
        },
        {
          "author": "steveharter",
          "body": "This was discussed early on when we evaluated Newtonsoft features for priority and this feature was discouraged, although the discussion did say that MVC uses it. @JamesNK @glennc \r\n",
          "createdAt": "2020-03-11T14:59:55Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2020-03-11T14:59:55Z",
          "id": "MDEyOklzc3VlQ29tbWVudDU5NzY4NDM1Mw=="
        },
        {
          "author": "JamesNK",
          "body": "I'm not a fan of ErrorHandler. Attempting to resume after an error is too unreliable.",
          "createdAt": "2020-03-11T19:10:15Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2020-06-18T18:32:48Z",
                "user": "GrabYourPitchforks"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2020-06-19T12:25:39Z",
                "user": "Tornhoof"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-10-19T15:20:57Z",
                "user": "eiriktsarpalis"
              },
              {
                "content": "CONFUSED",
                "createdAt": "2022-04-08T21:04:08Z",
                "user": "stevendarby"
              },
              {
                "content": "CONFUSED",
                "createdAt": "2022-05-12T00:37:19Z",
                "user": "yeica"
              },
              {
                "content": "CONFUSED",
                "createdAt": "2022-05-23T14:51:46Z",
                "user": "kolinekp"
              },
              {
                "content": "CONFUSED",
                "createdAt": "2022-08-24T13:51:58Z",
                "user": "gary-roach"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-12-09T00:16:11Z",
                "user": "gokhanabatay"
              },
              {
                "content": "CONFUSED",
                "createdAt": "2023-01-25T18:21:31Z",
                "user": "eddie-lee-msft"
              },
              {
                "content": "THUMBS_DOWN",
                "createdAt": "2023-12-05T13:36:19Z",
                "user": "justintoth"
              },
              {
                "content": "THUMBS_DOWN",
                "createdAt": "2024-04-13T03:45:23Z",
                "user": "Tape-Worm"
              },
              {
                "content": "THUMBS_DOWN",
                "createdAt": "2024-08-26T11:41:32Z",
                "user": "mergmann"
              },
              {
                "content": "CONFUSED",
                "createdAt": "2024-08-26T11:41:33Z",
                "user": "mergmann"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-09-20T06:33:40Z",
                "user": "zhyy2008z"
              }
            ],
            "totalCount": 14,
            "endCursor": "Y3Vyc29yOnYyOpHODy-icg=="
          },
          "updatedAt": "2020-03-11T19:10:15Z",
          "id": "MDEyOklzc3VlQ29tbWVudDU5NzgxNjUxNQ=="
        },
        {
          "author": "stevendarby",
          "body": "Surely one can conceive of there existing a set of errors that can be considered safe to resume from, making it then a case of deciding which errors fall in this set. Newtonsoft may have tried to resume from too many different types of error, making it unreliable. Could STJ implement this feature more conservatively and therefore more reliably?\r\n\r\nThe particular DateTime example I've given here seems a good example of a resumable error. If I wanted to safely convert a string to a DateTime I would just use one of the TryParse methods - can't the deserialization process take a similar approach?\r\n\r\nThis extends to JsonConverters too, where there is no obvious direct means of reporting what I would class as a validation error. Ideally, as you're using a strongly typed language, you want a date and time property on your model to be a DateTime, therefore you rely on the string in the JSON to be converted at some point. But that means the point of conversion is really the only point at which you can validate the string format. \r\n\r\nYou might want to enforce a particular ISO 8601 compliant representation in requests, so you create a JsonConverter to parse the string with an exact format. If it fails, there is no real option other than to let the FormatException be caught by the MVC input formatter so it can be added to the model state. If the user has made multiple date format mistakes it seems reasonable that these all be reported at once, which isn't possible with the current approach of bombing out entirely.\r\n\r\nA workaround might be to have this as a string property on your model and validate it after model minding, but not using a DateTime just to get around this doesn't seem like a reasonable workaround.\r\n\r\nI'm considering DateTime in particular because it's the example I've come across but I think it could extend to other sorts of conversions too.",
          "createdAt": "2020-03-11T19:51:09Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-08-02T21:37:10Z",
                "user": "eatdrinksleepcode"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-07-01T15:37:42Z",
                "user": "svickers"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-08-24T13:53:09Z",
                "user": "gary-roach"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-12-29T20:45:20Z",
                "user": "Ghost4Man"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-05-15T02:59:12Z",
                "user": "ben-smith-dev"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-08-26T11:41:46Z",
                "user": "mergmann"
              }
            ],
            "totalCount": 6,
            "endCursor": "Y3Vyc29yOnYyOpHODvrX_g=="
          },
          "updatedAt": "2020-03-11T20:57:45Z",
          "id": "MDEyOklzc3VlQ29tbWVudDU5NzgzNDcwNA=="
        },
        {
          "author": "stevendarby",
          "body": "Just wondering if this came up in “next sprint planning”?",
          "createdAt": "2020-06-17T18:08:06Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2020-06-17T18:08:06Z",
          "id": "MDEyOklzc3VlQ29tbWVudDY0NTUzNDcwOQ=="
        },
        {
          "author": "pranavkm",
          "body": "@snappyfoo not as yet. That said, it's fairly unlikely MVC could \\ would do anything if the feature does not exist in the formatter.",
          "createdAt": "2020-06-17T18:13:06Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2020-06-17T18:13:06Z",
          "id": "MDEyOklzc3VlQ29tbWVudDY0NTUzNzMwNA=="
        },
        {
          "author": "stevendarby",
          "body": "@pranavkm Thanks for the update. Is there a more appropriate repo to raise the issue with the formatter, and do you think it’s worth doing that?",
          "createdAt": "2020-06-17T18:44:52Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2020-06-17T18:44:52Z",
          "id": "MDEyOklzc3VlQ29tbWVudDY0NTU1MzY2OQ=="
        },
        {
          "author": "pranavkm",
          "body": "Let me transfer the issue to the runtime repo with a rewording. If they decide to add a feature, we could take advantage of it in MVC.",
          "createdAt": "2020-06-17T18:54:50Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2020-06-17T19:08:29Z",
                "user": "stevendarby"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOBHvEkA=="
          },
          "updatedAt": "2020-06-17T18:54:50Z",
          "id": "MDEyOklzc3VlQ29tbWVudDY0NTU1ODg5MQ=="
        },
        {
          "author": "Dotnet-GitSync-Bot",
          "body": "I couldn't figure out the best area label to add to this issue. Please help me learn by adding exactly one [area label](https://github.com/dotnet/runtime/blob/master/docs/area-owners.md).",
          "createdAt": "2020-06-17T18:55:03Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2020-06-17T18:55:03Z",
          "id": "MDEyOklzc3VlQ29tbWVudDY0NTU1OTAyNQ=="
        },
        {
          "author": "chrisjmccrum",
          "body": "+1 Looking for this feature - I now need to import Newtonsoft into my project for one edge case where the json maybe malformed. Having the option to continue to serialization and default the properties with errors would be super-helpful. I found this issue when searching SO ( https://stackoverflow.com/questions/26107656/ignore-parsing-errors-during-json-net-data-parsing)",
          "createdAt": "2022-01-16T03:57:54Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-01-16T03:57:54Z",
          "id": "IC_kwDODI9FZc48bXMi"
        },
        {
          "author": "penguinawesome",
          "body": "+1 for this feature. This feature is very important to determine all the fields that are invalid.",
          "createdAt": "2022-02-14T15:00:05Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-05-12T00:38:39Z",
                "user": "yeica"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-12-02T09:32:19Z",
                "user": "hosseinitabar"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-07-31T21:35:11Z",
                "user": "abelykh0"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-08-26T11:42:25Z",
                "user": "mergmann"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-11-18T08:54:04Z",
                "user": "evorios"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-01-03T20:09:23Z",
                "user": "mirekkukla"
              }
            ],
            "totalCount": 6,
            "endCursor": "Y3Vyc29yOnYyOpHOEA-DUQ=="
          },
          "updatedAt": "2022-02-14T15:00:05Z",
          "id": "IC_kwDODI9FZc498L0Y"
        },
        {
          "author": "ysiivan",
          "body": "+1\r\nThe inability to act (ignore or otherwise) on an exception thrown when serializing a property is a show stopper for me.  \r\n",
          "createdAt": "2022-04-25T18:35:12Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-04-25T18:43:05Z",
          "id": "IC_kwDODI9FZc5CGJe6"
        },
        {
          "author": "pilucdes",
          "body": "+1",
          "createdAt": "2022-05-02T14:53:08Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-05-02T14:53:08Z",
          "id": "IC_kwDODI9FZc5CdXpH"
        },
        {
          "author": "stevendarby",
          "body": "Can everyone who has or wants to reply with +1 please (also?) thumbs up the original post as it influences priority.\n\nSee https://github.com/dotnet/runtime/blob/main/CONTRIBUTING.md#finding-existing-issues\n\nThanks",
          "createdAt": "2022-05-02T15:18:17Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-05-02T15:24:55Z",
                "user": "penguinawesome"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-05-24T12:18:36Z",
                "user": "kuldeepGDI"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-06-01T00:36:34Z",
                "user": "arzzzae"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-07-01T15:39:54Z",
                "user": "svickers"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-09-30T17:12:35Z",
                "user": "jhafzoff"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-10-27T19:23:57Z",
                "user": "tim-loaded"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-12-09T00:17:22Z",
                "user": "gokhanabatay"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-03-05T06:44:54Z",
                "user": "papaja"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-06-02T20:04:50Z",
                "user": "MetalMonkey-GSD"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-07-30T21:32:42Z",
                "user": "Wuerike"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-09-08T08:18:52Z",
                "user": "ultradevel"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-12-05T13:36:40Z",
                "user": "justintoth"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-02-28T09:35:32Z",
                "user": "Matodor"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-08-01T03:29:41Z",
                "user": "MaxMahem"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-01-31T08:29:39Z",
                "user": "zsr2531"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-02-28T12:14:04Z",
                "user": "sergiu-enache"
              }
            ],
            "totalCount": 16,
            "endCursor": "Y3Vyc29yOnYyOpHOEIBhog=="
          },
          "updatedAt": "2022-05-02T15:18:17Z",
          "id": "IC_kwDODI9FZc5Cde6J"
        },
        {
          "author": "aaronegger",
          "body": "+1",
          "createdAt": "2022-07-13T12:00:18Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-07-13T12:00:18Z",
          "id": "IC_kwDODI9FZc5GhSzc"
        },
        {
          "author": "akovanev",
          "body": "A must have feature for api calls when some data may come inconsistent. It's a shame that it's still not resolved.",
          "createdAt": "2022-07-30T08:39:59Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-08-02T05:09:40Z",
                "user": "nirajagarwal"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-09-30T17:12:31Z",
                "user": "jhafzoff"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-10-24T13:59:53Z",
                "user": "pjoiner"
              }
            ],
            "totalCount": 3,
            "endCursor": "Y3Vyc29yOnYyOpHOCuX1QQ=="
          },
          "updatedAt": "2022-07-30T08:39:59Z",
          "id": "IC_kwDODI9FZc5HiFjI"
        },
        {
          "author": "clane2812",
          "body": "A must have: we have a postgres with some 'invalid' json on a special entity - when deserialzing the data from the database an exception is stored on the entity and thrown on the first access to the object. We can handle the exception in the use case of reading from the database, but what is the way to overwrite the invalid data with some valid json? When accessing the database for writing, the above exception occurs directly. Perhaps i have missed something, but actually it seems to me that i cannot write and fix my database without ignoring this deserialization-exception... ",
          "createdAt": "2022-11-15T10:42:54Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-11-15T10:42:54Z",
          "id": "IC_kwDODI9FZc5OYzcs"
        },
        {
          "author": "hosseinitabar",
          "body": "It's a shame that after 2 years of this issue, Microsoft has not implemented this. It's a MUST requirement. It's not a choice. Of course in any data serialization or deserialization or any batch operation one must have the capability to get a report.",
          "createdAt": "2022-12-02T09:33:12Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-06-04T13:17:44Z",
                "user": "MetalMonkey-GSD"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-07-30T21:32:23Z",
                "user": "Wuerike"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-10-09T05:57:11Z",
                "user": "Abbossbek"
              }
            ],
            "totalCount": 3,
            "endCursor": "Y3Vyc29yOnYyOpHODJA1Gw=="
          },
          "updatedAt": "2022-12-02T09:33:12Z",
          "id": "IC_kwDODI9FZc5Pkjv0"
        },
        {
          "author": "gokhanabatay",
          "body": "+1 I agree others https://github.com/dotnet/runtime/issues/44390",
          "createdAt": "2022-12-09T00:18:40Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-12-09T00:19:33Z",
          "id": "IC_kwDODI9FZc5QFe0c"
        },
        {
          "author": "lancer1977",
          "body": "+1",
          "createdAt": "2023-01-06T04:26:38Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-01-06T04:26:38Z",
          "id": "IC_kwDODI9FZc5R2E03"
        },
        {
          "author": "mpdelbuono",
          "body": "> I'm not a fan of ErrorHandler. Attempting to resume after an error is too unreliable.\r\n\r\n@JamesNK I'm hoping that this can be reconsidered - there are scenarios beyond \"attempting to resume\" where an error handler is important. Consider the case where you're reading from a read-once stream (quite common in web applications). If deserialization fails, you now get an exception saying what happened, but you have no way of knowing what the data was that caused the failure. Even if you catch the exception, there's no way for you to see the data because the stream is already consumed.\r\n\r\nA proper error handling hook would provide that information saying \"I couldn't deserialize this, you figure it out\". It doesn't have to enable continuing from this point, but it would at least enable logging to saying \"here's the thing that couldn't be deserialized\" so you can figure out what's wrong.",
          "createdAt": "2023-01-14T23:25:35Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-12-29T20:47:27Z",
                "user": "Ghost4Man"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHODQzRoA=="
          },
          "updatedAt": "2023-01-14T23:25:35Z",
          "id": "IC_kwDODI9FZc5Sbk_G"
        },
        {
          "author": "kampilan",
          "body": "I use this in my logging framework to ignore properties that throw an Exception simply for being read. Timeout on MemoryStream for example. \r\n\r\n@JamesNK Not being a fan as a reason to not implement is paternalism run amok. You were a fan of it enough to have originally implemented it. \r\n\r\n+1\r\n",
          "createdAt": "2023-01-25T13:43:50Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-01-25T13:43:50Z",
          "id": "IC_kwDODI9FZc5TqeRK"
        },
        {
          "author": "JamesNK",
          "body": "I was a fan of this feature. That's why I added it. Then I discovered how many problems it has.\r\n\r\nError handling created dozens of bugs that needed to be fixed because handling errors would leave the deserializer or reader in an unexpected state. There are still bugs in Newtonsoft.Json from this, and the feature is 10 years old.\r\n\r\nAnother problem was handling errors causing the deserializer to go into an infinite loop. For example, a deserializer is configured to handle errors, but the error comes from the underlying stream being closed. The deserializer will DOS itself, ignoring the stream-closed errors infinitely. There are many situations like this when parsing, and each one needs to be thought about carefully or you've created a really easy way to take down a server.",
          "createdAt": "2023-01-25T14:03:12Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-09-20T06:37:58Z",
                "user": "zhyy2008z"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHODy-juA=="
          },
          "updatedAt": "2023-01-25T14:03:12Z",
          "id": "IC_kwDODI9FZc5TqldK"
        },
        {
          "author": "akovanev",
          "body": "@JamesNK \r\n\r\nIt may have problems, that's fine, as you don't force developers to use this feature. However, there are many different scenarios where it is difficult to underestimate it.\r\n\r\nLet me give you a real use case. One day you have to import more than 100 thousand items with lots of properties. The import procedure takes up to 3h on you local environment and a little faster on prod. You expect that you know all about the format but you actually don't. Of course you don't deserialize 100K objects with one operation but still you struggle to achieve as less operations as possible. So you deserialize collections. And then it appears that about 500 items of 100K have the unexpected format for you. If there was no error handling feature like this in Newtonsoft, I don't know how much effort and time it would take to just log and find all the issues. And then after the big update you continue catch some nice portions of data for some period after. And no, you cannot update the datasource explicitly, so the only way is desereialize and process.\r\n\r\nThat would be really helpful if `System.Text.Json` could somehow give this option. It is still a framework feature.\r\n",
          "createdAt": "2023-01-25T16:34:07Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-10-29T23:24:29Z",
                "user": "sgtHoloToaster"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOD4oExw=="
          },
          "updatedAt": "2023-01-25T16:34:07Z",
          "id": "IC_kwDODI9FZc5TrcK_"
        },
        {
          "author": "kampilan",
          "body": "Thanks for the clarification James.\r\n\r\nAll great reasons not to use it. But I have none of those problems. It works exactly the way I need it to work. If I choose to do something stupid and bring down a server that's my problem. Let me make that choice. If I ask for 6 feet of rope I don't expect the clerk to ask me if I am going to hang myself before selling it to me.. This is not unreasonable functionality. And it's totally opt in. You have to ask for it. Buyer beware.\r\n\r\nThanks\r\nJim",
          "createdAt": "2023-01-25T16:41:50Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-10-09T06:01:33Z",
                "user": "Abbossbek"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-10-29T23:24:55Z",
                "user": "sgtHoloToaster"
              }
            ],
            "totalCount": 2,
            "endCursor": "Y3Vyc29yOnYyOpHOD4oFHg=="
          },
          "updatedAt": "2023-01-25T16:41:50Z",
          "id": "IC_kwDODI9FZc5Trev4"
        },
        {
          "author": "osexpert",
          "body": "For logging, it would be nice to have option to ignore fields/properties that can not be serialized due too not allowed to (eg. Type, MethodInfo) or because no formatter exist for the type. Could choose to ignore via a delegate where we can choose what to do (eg. Omit field/property, blank it/to null, use ToString etc)\r\n\r\nEdit: but Maybe this should be split into 2 issues (one for serialize and one for deserialize, it is completely different issues, where the deserialize invalid data problem is probably 100x more work than the serialize unsuported data problem)",
          "createdAt": "2023-04-27T10:44:15Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-01-03T14:38:22Z",
                "user": "seb-barton"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-07-31T01:03:50Z",
                "user": "andre-ss6"
              }
            ],
            "totalCount": 2,
            "endCursor": "Y3Vyc29yOnYyOpHODsMItA=="
          },
          "updatedAt": "2023-04-27T10:47:20Z",
          "id": "IC_kwDODI9FZc5a7H1C"
        },
        {
          "author": "ultradevel",
          "body": "+1 from me\r\nIt's really annoying when Deserialize just returns null without giving any indication of the error.\r\nThis makes System.Text.Json unusable for real-world development, where you mostly don't have any influence on the producer of the json you have to consume. Error handling is a must have.\r\nI don't understand why this issue is being put on the back burner here.",
          "createdAt": "2023-09-08T08:06:08Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-10-09T06:02:39Z",
                "user": "Abbossbek"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-04-13T03:49:47Z",
                "user": "Tape-Worm"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-07-16T02:24:46Z",
                "user": "Blaisor"
              }
            ],
            "totalCount": 3,
            "endCursor": "Y3Vyc29yOnYyOpHODp4cZA=="
          },
          "updatedAt": "2023-09-08T08:16:39Z",
          "id": "IC_kwDODI9FZc5l_6gT"
        },
        {
          "author": "Abbossbek",
          "body": "In my case, this is very necessary. I have a list of files in the object, 100 thousand files are parsed at once. In one file list, the files became a nested list, because the back end is written in node js. So I can't parse anything as a single error. These files are not important, but it's a pity that I can't get anything. Please add this feature.",
          "createdAt": "2023-10-09T06:20:56Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-10-09T06:20:56Z",
          "id": "IC_kwDODI9FZc5oc5IR"
        },
        {
          "author": "alimoh1372",
          "body": "+1 \r\nI need it in my logging System.I want serialize the object passed to the logging system.when error occurred on one or more field, I need to continue serializing and ignore that field.\r\njust like Newtonsoft.Json it can Chooseable,and default value false for this feature.",
          "createdAt": "2024-01-29T04:53:10Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-03-12T19:59:46Z",
                "user": "DonKedero"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOEJoDxQ=="
          },
          "updatedAt": "2024-01-29T04:53:10Z",
          "id": "IC_kwDODI9FZc5yFLFc"
        },
        {
          "author": "ultradevel",
          "body": "It doesn't look like the people behind System.Text.Json will ever rise to the challenge of integrating a working error handler.\r\nThey may close the ticket with a simple piece of advice: Use Newtonsoft.",
          "createdAt": "2024-01-29T08:31:20Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "LAUGH",
                "createdAt": "2024-01-29T10:27:54Z",
                "user": "RoelantM"
              },
              {
                "content": "LAUGH",
                "createdAt": "2024-04-13T03:47:49Z",
                "user": "Tape-Worm"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-04-17T14:02:02Z",
                "user": "anghelnicolae"
              },
              {
                "content": "LAUGH",
                "createdAt": "2024-07-16T02:26:09Z",
                "user": "Blaisor"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-08-01T03:27:53Z",
                "user": "MaxMahem"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-08-07T09:14:03Z",
                "user": "rodrigochapeta"
              },
              {
                "content": "LAUGH",
                "createdAt": "2024-08-07T09:14:04Z",
                "user": "rodrigochapeta"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-08-26T11:42:51Z",
                "user": "mergmann"
              },
              {
                "content": "LAUGH",
                "createdAt": "2024-08-26T11:42:53Z",
                "user": "mergmann"
              },
              {
                "content": "CONFUSED",
                "createdAt": "2024-08-29T13:33:55Z",
                "user": "danmoseley"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-09-10T18:37:43Z",
                "user": "nwalker-et"
              }
            ],
            "totalCount": 11,
            "endCursor": "Y3Vyc29yOnYyOpHOEhttQg=="
          },
          "updatedAt": "2024-01-29T08:31:20Z",
          "id": "IC_kwDODI9FZc5yGFon"
        },
        {
          "author": "colindawson",
          "body": "I've just hit this same problem.   I'm trying to write some generic error handle, which needs to be able to serialise anything.   I want to have a general error handler, so that anything that any property that cannot be serialised because of say a PlatformSupportException is simply ignored completely, as I don't need 100% covarage, it's more important that it doesn't throw an exception or run out of memory (which is what netwonsoft does.",
          "createdAt": "2024-04-25T18:16:39Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-04-25T18:16:39Z",
          "id": "IC_kwDODI9FZc572f62"
        },
        {
          "author": "Demmon98",
          "body": "+1 from me",
          "createdAt": "2024-06-06T11:16:06Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_DOWN",
                "createdAt": "2024-08-26T11:46:43Z",
                "user": "jukkahyv"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHODvrZng=="
          },
          "updatedAt": "2024-06-06T11:16:06Z",
          "id": "IC_kwDODI9FZc6ARiBk"
        },
        {
          "author": "tomasz-majewski",
          "body": "+1",
          "createdAt": "2024-06-11T09:37:21Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_DOWN",
                "createdAt": "2024-08-26T11:46:41Z",
                "user": "jukkahyv"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHODvrZmg=="
          },
          "updatedAt": "2024-06-11T09:37:21Z",
          "id": "IC_kwDODI9FZc6AwxSS"
        },
        {
          "author": "daniulian94",
          "body": "+1",
          "createdAt": "2024-07-16T10:20:17Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_DOWN",
                "createdAt": "2024-08-26T11:47:04Z",
                "user": "jukkahyv"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHODvrZvA=="
          },
          "updatedAt": "2024-07-16T10:20:17Z",
          "id": "IC_kwDODI9FZc6E81pL"
        },
        {
          "author": "Muthu2627",
          "body": "+1 \r\n",
          "createdAt": "2024-08-26T11:40:27Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_DOWN",
                "createdAt": "2024-08-26T11:47:02Z",
                "user": "jukkahyv"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHODvrZuw=="
          },
          "updatedAt": "2024-08-26T11:40:27Z",
          "id": "IC_kwDODI9FZc6Jr87-"
        },
        {
          "author": "dlidstrom",
          "body": "I too came looking for error handling support when deserializing. However I now realize that it may be possible to combine STJ with `System.ComponentModel.DataAnnotations` and do a post-deserialize validation. That's a good enough solution in many cases, IMO.",
          "createdAt": "2024-08-29T08:18:11Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-08-29T08:18:11Z",
          "id": "IC_kwDODI9FZc6KGoFi"
        },
        {
          "author": "sherman89",
          "body": "This would be very useful to have so that the users don't have to fix their JSON \"line by line\".\n\nSo if I have\n```\nvar json =\n    \"\"\"\n    {\n      \"startDate\": \"invalid\",\n      \"endDate\": \"nope\"\n    }\n    \"\"\";\n```\n\nThen I want to get an error on both properties, not just `startDate`.\n\nI probably could work around this by deserializing to some object/dynamic type, but that would definitely hurt code readability significantly.",
          "createdAt": "2024-11-06T10:31:17Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-01-03T20:08:07Z",
                "user": "mirekkukla"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOEA-C0Q=="
          },
          "updatedAt": "2024-11-06T10:31:17Z",
          "id": "IC_kwDODI9FZc6SlhMw"
        },
        {
          "author": "mirekkukla",
          "body": "> Error handling created dozens of bugs that needed to be fixed because handling errors would leave the deserializer or reader in an unexpected state\n\nUnderstood that it's _hard_ to do this right, and nice to hear that the core team agrees this is conceptually desirable behavior. Fingers crossed we'll cross the threshold whereby it's deemed worth the effort 😁",
          "createdAt": "2025-01-03T20:16:45Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-01-03T20:17:07Z",
          "id": "IC_kwDODI9FZc6ZK33Y"
        },
        {
          "author": "vitasystems",
          "body": "5 years later this is still lacking.  I have felt really hesitant to move to System.Text.Json. An open issue like this is what really proves me right.",
          "createdAt": "2025-01-20T05:21:42Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-01-20T05:31:52Z",
                "user": "ultradevel"
              },
              {
                "content": "THUMBS_DOWN",
                "createdAt": "2025-01-20T16:08:00Z",
                "user": "chrisoverzero"
              },
              {
                "content": "THUMBS_DOWN",
                "createdAt": "2025-01-21T05:18:49Z",
                "user": "CyrusNajmabadi"
              }
            ],
            "totalCount": 3,
            "endCursor": "Y3Vyc29yOnYyOpHOEDWOfw=="
          },
          "updatedAt": "2025-01-20T05:21:42Z",
          "id": "IC_kwDODI9FZc6bDiLn"
        },
        {
          "author": "JWMB",
          "body": "Similar to @colindawson, @ultradevel et.al, I too could see no other solution than to switch back to Newtonsoft for dumping unknown types during error handling. Will you comment on (the soon 2-yr-old) suggestion from @osexpert to split this into serializer/deserializer issues?",
          "createdAt": "2025-03-04T10:48:42Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-03-04T10:48:42Z",
          "id": "IC_kwDODI9FZc6gwdmv"
        },
        {
          "author": "gregsdennis",
          "body": "[JsonSchema.Net](https://github.com/json-everything/json-everything) (my library) provides a `JsonConverter` that can provide schema validation during serialization ([docs](https://docs.json-everything.net/schema/serialization/)).\n\nI've been toying with it more practically over the past few days, and I've found a good solution to integrate it into ASP.Net.  I'll probably publish this as an extension, but I thought I'd share it here as well.\n\nIn addition to the converter, you need two components:  a model binder and an action filter.\n\n<details>\n<summary>Model binder</summary>\n\n```c#\npublic class ValidatingJsonModelBinder : IModelBinder\n{\n    public async Task BindModelAsync(ModelBindingContext bindingContext)\n    {\n        if (bindingContext == null)\n        {\n            throw new ArgumentNullException(nameof(bindingContext));\n        }\n\n        // For body binding, we need to read the request body\n        if (bindingContext.BindingSource == BindingSource.Body)\n        {\n            bindingContext.HttpContext.Request.EnableBuffering();\n            using var reader = new StreamReader(bindingContext.HttpContext.Request.Body, leaveOpen: true);\n            var body = await reader.ReadToEndAsync();\n            bindingContext.HttpContext.Request.Body.Position = 0;\n\n            if (string.IsNullOrEmpty(body))\n            {\n                return;\n            }\n\n            try\n            {\n                var options = bindingContext.HttpContext.RequestServices.GetRequiredService<IOptions<JsonOptions>>().Value.JsonSerializerOptions;\n                var model = JsonSerializer.Deserialize(body, bindingContext.ModelType, options);\n                bindingContext.Result = ModelBindingResult.Success(model);\n            }\n            catch (JsonException jsonException)\n            {\n                if (jsonException.Data.Contains(\"validation\") && \n                    jsonException.Data[\"validation\"] is EvaluationResults validationResults)\n                {\n                    var errors = ExtractValidationErrors(validationResults);\n                    if (errors.Any())\n                    {\n                        foreach (var error in errors)\n                        {\n                            bindingContext.ModelState.AddModelError(error.Path, error.Message);\n                        }\n                        bindingContext.Result = ModelBindingResult.Failed();\n                        return;\n                    }\n                }\n\n                bindingContext.ModelState.AddModelError(bindingContext.FieldName, jsonException, bindingContext.ModelMetadata);\n                bindingContext.Result = ModelBindingResult.Failed();\n            }\n            return;\n        }\n\n        // For other binding sources, use the value provider\n        var valueProviderResult = bindingContext.ValueProvider.GetValue(bindingContext.ModelName);\n        if (valueProviderResult == ValueProviderResult.None)\n        {\n            return;\n        }\n\n        bindingContext.ModelState.SetModelValue(bindingContext.ModelName, valueProviderResult);\n\n        try\n        {\n            var value = valueProviderResult.FirstValue;\n            if (string.IsNullOrEmpty(value))\n            {\n                return;\n            }\n\n            var options = bindingContext.HttpContext.RequestServices.GetRequiredService<IOptions<JsonOptions>>().Value.JsonSerializerOptions;\n            var model = JsonSerializer.Deserialize(value, bindingContext.ModelType, options);\n            bindingContext.Result = ModelBindingResult.Success(model);\n        }\n        catch (JsonException jsonException)\n        {\n            bindingContext.ModelState.AddModelError(bindingContext.ModelName, jsonException, bindingContext.ModelMetadata);\n            bindingContext.Result = ModelBindingResult.Failed();\n        }\n    }\n\n    static List<(string Path, string Message)> ExtractValidationErrors(EvaluationResults validationResults)\n    {\n        var errors = new List<(string Path, string Message)>();\n        ExtractValidationErrorsRecursive(validationResults, errors);\n        return errors;\n    }\n\n    static void ExtractValidationErrorsRecursive(EvaluationResults results, List<(string Path, string Message)> errors)\n    {\n        if (results.IsValid)\n        {\n            return;\n        }\n\n        if (results.Errors != null)\n        {\n            foreach (var error in results.Errors)\n            {\n                errors.Add((results.InstanceLocation.ToString(), error.Value));\n            }\n        }\n\n        foreach (var detail in results.Details)\n        {\n            ExtractValidationErrorsRecursive(detail, errors);\n        }\n    }\n}\n\npublic class ValidatingJsonModelBinderProvider : IModelBinderProvider\n{\n    public IModelBinder? GetBinder(ModelBinderProviderContext context)\n    {\n        if (context == null)\n        {\n            throw new ArgumentNullException(nameof(context));\n        }\n\n        // Only use this binder for types that have the JsonSchema attribute\n        if (context.Metadata.ModelType.GetCustomAttributes(typeof(JsonSchemaAttribute), true).Any())\n        {\n            return new ValidatingJsonModelBinder();\n        }\n\n        return null;\n    }\n}\n```\n\n</details>\n\n<details>\n<summary>Action filter</summary>\n\n```c#\npublic class JsonSchemaValidationFilter : IActionFilter\n{\n    public void OnActionExecuting(ActionExecutingContext context)\n    {\n        if (!context.ModelState.IsValid)\n        {\n            var errors = context.ModelState\n                .Where(x => x.Value?.Errors.Any() == true)\n                .SelectMany(x => x.Value!.Errors.Select(e => new\n                {\n                    Path = x.Key,\n                    Message = e.ErrorMessage,\n                }))\n                .Where(e => string.IsNullOrEmpty(e.Path) || e.Path.StartsWith('/'))\n                .GroupBy(x => x.Path)\n                .ToDictionary(x => x.Key, x => x.Select(e => e.Message).ToList());\n\n            if (errors.Count == 0)\n            {\n                return;\n            }\n\n            var problemDetails = new ProblemDetails\n            {\n                Type = \"https://your.domain/errors/validation\",\n                Title = \"Validation Error\",\n                Status = 400,\n                Detail = \"One or more validation errors occurred.\",\n                Extensions =\n                {\n                    [\"errors\"] = errors,\n                },\n            };\n\n            context.Result = new BadRequestObjectResult(problemDetails);\n        }\n    }\n\n    public void OnActionExecuted(ActionExecutedContext context)\n    {\n        // No-op\n    }\n} \n```\n\n</details>\n\nThis makes a fair attempt to isolate pertinent error messages but it's not perfect.  It has particular trouble at optional branches in the schema (`anyOf`, `if`/`then`/`else`, etc.).  Read [my post](https://json-schema.org/blog/posts/interpreting-output) on this for more info on why it's hard.\n\nTo integrate these into your server, add the following in your startup:\n\n```c#\nservices.AddControllersWithViews(o => // or without views\n{\n    // ...\n    o.Filters.Add<JsonSchemaValidationFilter>();\n    o.ModelBinderProviders.Insert(0, new ValidatingJsonModelBinderProvider());\n    // ...\n}).AddJsonOptions(o =>\n{\n    // ...\n    o.JsonSerializerOptions.Converters.Add(new ValidatingJsonConverter\n        {\n            OutputFormat = OutputFormat.Hierarchical,\n            RequireFormatValidation = true,\n        }\n    );\n    // ...\n});\n```\n\nThen follow the instructions in the [library docs](https://docs.json-everything.net/schema/serialization/) to enable validation during serialization for each model that you want validated.  This will involve creating a schema for your models and referencing that schema in the `[JsonSchema]` attribute.  (The schema can be hosted in any type.)\n\n```c#\n[JsonSchema(typeof(Person), nameof(Schema))]\npublic record Person(string Name, int Age)\n{\n    public static JsonSchema Schema =\n        new JsonSchemaBuilder()\n            .Type(SchemaValueType.Object)\n            .Properties(\n                (\"name\", new JsonSchemaBuilder().Type(SchemaValueType.String)),\n                (\"age\", new JsonSchemaBuilder()\n                    .Type(SchemaValueType.Integer)\n                    .Minimum(0)\n                )\n            )\n            .Required(\"name\", \"age\");\n}\n```\n\nWhen you use this model as a parameter in a controller method, the validating converter will be invoked.  If there are any schema validation errors, the binder will grab them, then the filter will organize them into a 400 response with a `ProblemDetails` body containing all of the errors, grouped by payload location.  The call never makes it to the controller unless schema validation passes.",
          "createdAt": "2025-03-31T19:36:21Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-03-31T19:36:21Z",
          "id": "IC_kwDODI9FZc6k8Fjd"
        }
      ],
      "totalCount": 43,
      "endCursor": "Y3Vyc29yOnYyOpHOpPBY3Q=="
    },
    "url": "https://github.com/dotnet/runtime/issues/38049",
    "title": "System.Text.Json Add a feature that allows gathering all exceptions encountered when parsing json"
  },
  {
    "author": "terrajobst",
    "labels": [
      "api-approved",
      "area-System.Text.Json",
      "code-analyzer",
      "code-fixer",
      "in-pr"
    ],
    "createdAt": "2020-03-19T16:42:33Z",
    "body": "The rule should flag cases where a reader is passed around by value.\n\n**Category**: Reliability",
    "number": 33772,
    "reactions": {
      "hasNextPage": false,
      "nodes": [],
      "totalCount": 0,
      "endCursor": null
    },
    "updatedAt": "2023-11-21T17:39:19Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": "jeffhandley",
          "body": "Estimates:\r\n* Analyzer: Small\r\n* Fixer: Large",
          "createdAt": "2020-03-21T00:42:50Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2020-03-21T00:42:50Z",
          "id": "MDEyOklzc3VlQ29tbWVudDYwMTk2NzI2OQ=="
        },
        {
          "author": "carlossanlop",
          "body": "@terrajobst is this what you intend the analyzer/fixer to do?:\r\nUpdate: The answer below was \"yes\" :)\r\n\r\nSuggested severity: Warning\r\n\r\n### Before\r\n```cs\r\nstatic void Main()\r\n{\r\n    Utf8JsonReader reader = new(/**/);\r\n    MyMethod(reader);\r\n}\r\n\r\nstatic void MyMethod(Utf8JsonReader reader)\r\n{\r\n}\r\n```\r\n\r\n### After\r\n```cs\r\nstatic void Main()\r\n{\r\n    Utf8JsonReader reader = new(/**/);\r\n    MyMethod(ref reader);\r\n}\r\n\r\nstatic void MyMethod(ref Utf8JsonReader reader)\r\n{\r\n}\r\n```",
          "createdAt": "2021-01-15T19:39:19Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-06-03T17:10:36Z",
          "id": "MDEyOklzc3VlQ29tbWVudDc2MTE1NjU1NA=="
        },
        {
          "author": "carlossanlop",
          "body": "Ping @terrajobst , @GrabYourPitchforks and @bartonjs to help clarify our question above.",
          "createdAt": "2021-02-23T21:27:53Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-02-23T21:28:41Z",
          "id": "MDEyOklzc3VlQ29tbWVudDc4NDUyNDczNA=="
        },
        {
          "author": "bartonjs",
          "body": "Yep, the before/after is correct.",
          "createdAt": "2021-02-23T22:20:13Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-02-23T22:20:13Z",
          "id": "MDEyOklzc3VlQ29tbWVudDc4NDU1NDQ2Mw=="
        },
        {
          "author": "GrabYourPitchforks",
          "body": "Is the fixer's behavior of \"whenever you see a byval argument, change it to byref\" viable? That likely won't catch local copies being made within a method.",
          "createdAt": "2021-02-23T22:28:05Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-02-23T22:28:05Z",
          "id": "MDEyOklzc3VlQ29tbWVudDc4NDU1ODg4Ng=="
        },
        {
          "author": "bartonjs",
          "body": "The fixer doesn't have to fix everything.\r\n\r\nMethod-call copies are probably almost always wrong.  Local copies might be intentional, but if they're rare they can always suppress.  (e.g. JsonDocument does a local copy to reset the ref if it hits an \"I need more data\" state)",
          "createdAt": "2021-02-23T22:33:51Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-02-23T22:33:51Z",
          "id": "MDEyOklzc3VlQ29tbWVudDc4NDU2MTgzNg=="
        },
        {
          "author": "GrabYourPitchforks",
          "body": "Sounds reasonable. Carry on! :)",
          "createdAt": "2021-02-23T22:38:16Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-02-23T22:38:16Z",
          "id": "MDEyOklzc3VlQ29tbWVudDc4NDU2Mzk4NQ=="
        },
        {
          "author": "carlossanlop",
          "body": "Thank you, both! I'll mark this as ready for review.",
          "createdAt": "2021-02-24T02:24:03Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-02-24T02:24:03Z",
          "id": "MDEyOklzc3VlQ29tbWVudDc4NDcwMDUxNg=="
        },
        {
          "author": "bartonjs",
          "body": "[Video](https://www.youtube.com/watch?v=m8JAKGO8zrI&t=0h22m24s)\n\nSeverity: Warning\r\nCategory: Reliability\r\n\r\n* The analyzer, and the messaging, should be more generalized, like \"Do not pass mutable value type '{0}' by value.\"\r\n* We should have a list of well-known problematic types, like Utf8JsonReader, but also support loading other types from config.\r\n  * Some types may be able to be identified heuristically, like \"ends in Enumerator, is a value type, and is a nested type\"\r\n  * The list should also include SpinLock\r\n* The analyzer should look for method parameter declarations where the parameter is of one of these types and the parameter mode is not ref or out (either by-value or in/readonly-ref).\r\n  * It should also look for these types in \"output positions\", like property declared types or method returns.\r\n* The fixer should change the parameter to be by ref, and then (as a stretch goal) update calls appropriately (if able).\r\n",
          "createdAt": "2021-06-03T17:46:59Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-06-03T19:15:47Z",
          "id": "MDEyOklzc3VlQ29tbWVudDg1NDA2MTM2OA=="
        },
        {
          "author": "NewellClark",
          "body": "I would like to be assigned to this, please.",
          "createdAt": "2021-08-26T10:35:17Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-08-26T16:50:35Z",
                "user": "buyaa-n"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOB378Aw=="
          },
          "updatedAt": "2021-08-26T10:35:17Z",
          "id": "IC_kwDODI9FZc42BN3E"
        },
        {
          "author": "NewellClark",
          "body": "I just ran my [working prototype](https://github.com/NewellClark/roslyn-analyzers/tree/do-not-pass-mutable-value-types-by-value) against dotnet/runtime and I found quite a few false positives in the `System.Text.Json` library. I found several false positives for the return by-value error in [JsonElement.cs](https://github.com/dotnet/runtime/blob/main/src/libraries/System.Text.Json/src/System/Text/Json/Document/JsonElement.cs) (`EnumerateArray()` and `EnumerateObject()`). \r\nI also found several pass by-value false positives in [ThrowHelper.Serialization.cs](https://github.com/dotnet/runtime/blob/main/src/libraries/System.Text.Json/src/System/Text/Json/ThrowHelper.Serialization.cs). \r\n\r\nWe may be able to improve the struct-enumerator heuristic to eliminate the return-by-value false positives. Currently, we recognize any nested value type that ends with \"Enumerator\" as a mutable value type, and we suppress diagnostics for methods named \"GetEnumerator\". We could also suppress methods containing \"Enumerate\", though I question whether that scenario is common enough to warrant special-casing. Might just be easier to suppress the warning in the runtime libraries.\r\nAlternatively, we could simply not show a warning for method return values, since methods are likely to be factory methods. All of the return value false positives in dotnet/runtime were factory methods. I think properties should still be reported, though.\r\n\r\nAs for the pass by-value false positives, all of them are pass by-reference read-only parameters. I'm going to suggest that we not report diagnostics for \"in\" parameters. Since \"in\" is a language feature that beginners don't typically use, I think it's safe to assume that someone who marks a parameter as \"in\" likely knows what they're doing.",
          "createdAt": "2021-09-06T15:15:06Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-09-07T13:33:35Z",
          "id": "IC_kwDODI9FZc42dkc6"
        },
        {
          "author": "buyaa-n",
          "body": "Moving to future milestone as the PR blocked with [an open question](https://github.com/dotnet/roslyn-analyzers/pull/5454#issuecomment-916290292)",
          "createdAt": "2023-08-14T16:20:21Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-08-14T16:20:21Z",
          "id": "IC_kwDODI9FZc5j_t5h"
        }
      ],
      "totalCount": 12,
      "endCursor": "Y3Vyc29yOnYyOpHOY_7eYQ=="
    },
    "url": "https://github.com/dotnet/runtime/issues/33772",
    "title": "Do not pass Utf8JsonReader by value"
  },
  {
    "author": "terrajobst",
    "labels": [
      "api-approved",
      "area-System.Text.Json",
      "code-analyzer",
      "code-fixer",
      "in-pr"
    ],
    "createdAt": "2020-03-19T16:43:01Z",
    "body": "In general, constructor arguments who initialize should match properties (casing aside). There are also cases where serializers will match properties to constructor parameters in order to construct immutable types. This would address that too.\r\n\r\nWe should limit this to types/constructs we consider being used by the JSON serializer.\r\n\r\n**Category**: Design",
    "number": 33796,
    "reactions": {
      "hasNextPage": false,
      "nodes": [],
      "totalCount": 0,
      "endCursor": null
    },
    "updatedAt": "2023-11-21T17:39:46Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": "jeffhandley",
          "body": "Estimates:\r\n* Analyzer: Medium\r\n* Fixer: Small",
          "createdAt": "2020-03-21T00:29:59Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2020-03-21T00:29:59Z",
          "id": "MDEyOklzc3VlQ29tbWVudDYwMTk2NTEyMA=="
        },
        {
          "author": "jeffhandley",
          "body": "We need to detect an inclusion approach; we want to focus on the JSON deserialization scenario.",
          "createdAt": "2020-03-23T17:09:23Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2020-03-23T17:09:23Z",
          "id": "MDEyOklzc3VlQ29tbWVudDYwMjczNDE5NQ=="
        },
        {
          "author": "bartonjs",
          "body": "This should only apply to constructors painted with the `[JsonConstructor]` attribute, but should be prepared to account for other enrollment scenarios.\r\n\r\n* For each parameter name in the parameter list of an included constructor\r\n  * If there is not a property on the type hierarchy at that level whose name is OrdinalIgnoreCase equal to the parameter name, report a diagnostic against the parameter (ideally just the name).\r\n\r\nIf the engine already has a \"close match\" name detector, then a fixer could suggest correcting a typo; but otherwise a fixer seems too open of a problem (unless other bright ideas surface).",
          "createdAt": "2020-03-24T06:47:00Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2020-03-24T07:52:14Z",
                "user": "jeffhandley"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOA-8HZQ=="
          },
          "updatedAt": "2020-03-24T06:47:18Z",
          "id": "MDEyOklzc3VlQ29tbWVudDYwMzA1NDM4Mw=="
        },
        {
          "author": "jeffhandley",
          "body": "For existing violations in `runtime`, we likely would not apply the fix since changing parameter names would often be a breaking change.",
          "createdAt": "2020-05-26T20:40:25Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2020-05-26T20:40:25Z",
          "id": "MDEyOklzc3VlQ29tbWVudDYzNDI2Njk5MA=="
        },
        {
          "author": "swtrse",
          "body": "It should also considered that the JsonPropertyAttribute should be able to decorate constructor parameters.\r\nThis way the exact name in case sensitive format can be defined for the constructor parameters and the actual parameter name does not matter at all.\r\nIf done in an other way this would be fine too but there should be a way to exacly define the json names for the parameters in an case sensitive way.\r\n\r\n@bartonjs \r\nI strongly opose the option where the match is done with an IgnoreCase equal at least when the global options are not set to case insensitive name resolution.",
          "createdAt": "2020-06-24T10:53:50Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2020-06-24T11:05:42Z",
          "id": "MDEyOklzc3VlQ29tbWVudDY0ODc0ODg3Mg=="
        },
        {
          "author": "danmoseley",
          "body": "@jeffhandley is this 5.0 work?",
          "createdAt": "2020-07-30T17:31:35Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2020-07-30T17:31:35Z",
          "id": "MDEyOklzc3VlQ29tbWVudDY2NjU0NzIxNg=="
        },
        {
          "author": "jeffhandley",
          "body": "@danmosemsft Moved to Future. Thanks.\n\nWe will target delivering this off-cycle soon after 5.0 since it will be good to get this out before folks start producing code that will violate the rule.",
          "createdAt": "2020-07-30T18:27:12Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2020-07-30T18:27:12Z",
          "id": "MDEyOklzc3VlQ29tbWVudDY2NjU4MzM2NA=="
        },
        {
          "author": "psxvoid",
          "body": "Hi,\r\n\r\nMay I \"book\" this issue as \"up-for-grabs\"?",
          "createdAt": "2021-02-05T10:53:53Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-02-05T18:12:20Z",
                "user": "buyaa-n"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOBfE3tQ=="
          },
          "updatedAt": "2021-02-05T10:53:53Z",
          "id": "MDEyOklzc3VlQ29tbWVudDc3Mzk1ODUxMg=="
        },
        {
          "author": "danmoseley",
          "body": "@psxvoid you are welcome, I assigned it to you. (@buyaa-n I am assuming we are not working on this since it's not assigned)",
          "createdAt": "2021-02-05T18:05:01Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-02-05T18:12:22Z",
                "user": "buyaa-n"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-02-06T01:28:59Z",
                "user": "psxvoid"
              }
            ],
            "totalCount": 2,
            "endCursor": "Y3Vyc29yOnYyOpHOBfHMig=="
          },
          "updatedAt": "2021-02-05T18:05:01Z",
          "id": "MDEyOklzc3VlQ29tbWVudDc3NDE5NDQ1NQ=="
        },
        {
          "author": "buyaa-n",
          "body": "> I am assuming we are not working on this since it's not assigned\r\n\r\nThat is right",
          "createdAt": "2021-02-05T18:12:52Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-02-06T07:41:43Z",
                "user": "psxvoid"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOBfHokA=="
          },
          "updatedAt": "2021-02-05T18:12:52Z",
          "id": "MDEyOklzc3VlQ29tbWVudDc3NDE5OTA1MA=="
        },
        {
          "author": "psxvoid",
          "body": "Thank you.\r\n\r\nI've spent some time on initial planning, and I'm wondering whether the following questions can be addressed before the implementation:\r\n\r\n1. Should this analyzer also check field names? See note (3).\r\n2. Should this analyzer be only applied to constructors marked as \"JsonConstructor\" from \"System.Text.Json.Serialization\" namespace, and not from \"Newtonsoft.Json\"?\r\n3. What target namespace should be used for this analyzer? See note (5).\r\n\r\nNotes:\r\n(1) I'm assuming this analyzer is also must be applied to C# 9 Records (and structs). This is a valid usage:\r\n> ```cs\r\n> public record Person\r\n> {\r\n>    public string FirstName { get; init; }\r\n>    public string LastName { get; init; }\r\n>\r\n>    [JsonConstructor]\r\n>    public Person(string firstName, string lastName)\r\n>      => (FirstName, LastName) = (firstName, lastName);\r\n> }\r\n> ```\r\n\r\n(2) I'm assuming this analyzer should also be applied to VB.\r\n\r\n(3) This [Migrate from Newtonsoft.Json to System.Text.Json - .NET | Microsoft Docs](https://docs.microsoft.com/en-us/dotnet/standard/serialization/system-text-json-migrate-from-newtonsoft-how-to?pivots=dotnet-5-0#public-and-non-public-fields) doc says:\r\n\r\n> In `System.Text.Json`, use the `JsonSerializerOptions.IncludeFields` global setting or the `[JsonInclude]` attribute to include public fields when serializing or deserializing. For an example, see Include fields.\r\n\r\n(4) It seems like uninitialized public properties are not a responsibility of this analyzer. Example:\r\n> ```cs\r\n> public class C\r\n> {\r\n>     public int P1 { get; }\r\n>     public int? P2 { get; }\r\n> \r\n>     [JsonConstructor]\r\n>     public C(int p1)\r\n>     {\r\n>         this.P1 = p1;\r\n>         // P2 is not initialized\r\n>     }\r\n> }\r\n> ```\r\n\r\n(5) It seems like this analyzer belongs to the \"Design\" category. As far as I can see, most of them reside in:\r\n> `NetAnalyzers\\Core\\Microsoft.CodeQuality.Analyzers\\ApiDesignGuidelines`\r\n\r\nbut this issue is also marked as `area-System.Runtime` label, and it could be also applicable to VB. Because of that, should it be placed here:\r\n\r\n> `NetAnalyzers\\Core\\Microsoft.NetCore.Analyzers\\Runtime`",
          "createdAt": "2021-02-06T08:53:01Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-02-06T08:53:01Z",
          "id": "MDEyOklzc3VlQ29tbWVudDc3NDQyNzg0MA=="
        },
        {
          "author": "buyaa-n",
          "body": "@psxvoid sorry for the late reply, saw your questions just today: \r\n\r\n> 1. Should this analyzer also check field names? See note (3).\r\n\r\n I don't think so, [JsonConstructor] attribute doesn't seem to apply/used for setting fields cc @bartonjs, @layomia   \r\n\r\n> 2. Should this analyzer be only applied to constructors marked as \"JsonConstructor\" from \"System.Text.Json.Serialization\" namespace, and not from \"Newtonsoft.Json\"?\r\n\r\nYes, only from \"System.Text.Json.Serialization\" \r\n\r\n> 3. What target namespace should be used for this analyzer? See note (5).\r\n\r\n `NetAnalyzers\\Core\\Microsoft.NetCore.Analyzers\\Runtime`, you might want to check our [instruction for Netcore analyers](https://github.com/dotnet/roslyn-analyzers/blob/master/docs/NetCore_GettingStarted.md)\r\n\r\n> Notes:\r\n> (1) I'm assuming this analyzer is also must be applied to C# 9 Records (and structs). This is a valid usage:\r\n> > ```cs\r\n> > public record Person\r\n> > {\r\n> >    public string FirstName { get; init; }\r\n> >    public string LastName { get; init; }\r\n> >\r\n> >    [JsonConstructor]\r\n> >    public Person(string firstName, string lastName)\r\n> >      => (FirstName, LastName) = (firstName, lastName);\r\n> > }\r\n> > ```\r\n\r\nIf the attribute can be applied for them then the analyzer also should cover them\r\n\r\n(2) I'm assuming this analyzer should also be applied to VB.\r\n\r\nYes, the analyzer can be implemented using language-agnostic APIs, so most likely you don't need to do anything extra for VB except adding VB tests\r\n\r\n(4) It seems like uninitialized public properties are not a responsibility of this analyzer. Example:\r\n> ```cs\r\n> public class C\r\n> {\r\n>     public int P1 { get; }\r\n>     public int? P2 { get; }\r\n> \r\n>     [JsonConstructor]\r\n>     public C(int p1)\r\n>     {\r\n>         this.P1 = p1;\r\n>         // P2 is not initialized\r\n>     }\r\n> }\r\n> ```\r\n\r\nI think so, i assume we only warn if parameter `p1` haven't had matching property cc @bartonjs ",
          "createdAt": "2021-02-24T01:31:27Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-02-24T04:44:49Z",
                "user": "psxvoid"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOBhI3_w=="
          },
          "updatedAt": "2021-02-24T01:31:27Z",
          "id": "MDEyOklzc3VlQ29tbWVudDc4NDY2NjQxMQ=="
        },
        {
          "author": "psxvoid",
          "body": "@buyaa-n Thanks a lot! Then I'll omit fields verification in the analyser if no additional feedback is provided.\r\n\r\n The last question I still have is related to naming styles. Currently, it's possible to set custom prefixes for field/property names in `.editorconfig`, e.g. set `_` (underscore) prefix for private properties. It seems like the analyser should be able to read such options. Without reading and respecting such options a group of users that have set a custom naming style for their projects can get false-positives, e.g. a property `_data` will not much a constructor parameter `data`. For example, here is an article that demonstrates the ability to set a custom prefix, suffix, word-separator and capitalization: [Configure Visual Studio to Name Private Fields with Underscore | ardalis.com](https://ardalis.com/configure-visual-studio-to-name-private-fields-with-underscore/).\r\n \r\nHowever, naming style options (code/classes responsible for them) are only available in the `Roslyn` repository and not in `RoslynAnalyzers`. It may be a bit harder to \"port\" them because they are internal to the `Roslyn` repo and have a lot of internal dependencies. I had spent some time \"porting\" them (copy-paste, and it seems like a very time-consuming operation) and wondering whether someone from the Roslyn team can recommend a standard and more effective way of doing it (e.g. marking `IPerLanguageOption2` and `NamingStyleOptions` classes `public` in `Roslyn` repo).",
          "createdAt": "2021-02-24T05:32:35Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-02-24T05:42:42Z",
                "user": "buyaa-n"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOBhJISQ=="
          },
          "updatedAt": "2021-02-24T05:32:35Z",
          "id": "MDEyOklzc3VlQ29tbWVudDc4NDc5MTQ3NA=="
        },
        {
          "author": "buyaa-n",
          "body": "> @buyaa-n Thanks a lot! Then I'll omit fields verification in the analyser if no additional feedback is provided.\r\n\r\nSorry i was about to update my comment, turns out it is related to fields: `Each parameter in constructor 'Void .ctor(...) on type 'XYZ' must bind to an object property or field on deserialization. Each parameter name must match with a property or field on the object. The match can be case-insensitive.` So if no matching property we can check for fields match.\r\n\r\nIf there is matched field another thing we could flag for field might be `[JsonInclude]` attribute, but the attribute is not required in case  `JsonSerializerOptions.IncludeFields` set to true, but in most cases, we cannot check if that option is set, so that might be a bit  noisy",
          "createdAt": "2021-02-24T05:40:11Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-02-24T05:40:46Z",
                "user": "psxvoid"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOBhJH0g=="
          },
          "updatedAt": "2021-02-24T05:41:20Z",
          "id": "MDEyOklzc3VlQ29tbWVudDc4NDc5NDkzNQ=="
        },
        {
          "author": "buyaa-n",
          "body": "> The last question I still have is related to naming styles. Currently, it's possible to set custom prefixes for field/property names in .editorconfig, e.g. set _ (underscore) prefix for private properties. It seems like the analyser should be able to read such options. Without reading and respecting such options a group of users that have set a custom naming style for their projects can get false-positives, e.g. a property _data will not much a constructor parameter data. For example, here is an article that demonstrates the ability to set a custom prefix, suffix, word-separator and capitalization: Configure Visual Studio to Name Private Fields with Underscore | ardalis.com.\r\n\r\nIs `JsonSerializer` account/respects that?  Can the serializer set property `_data` with constructor parameter `data` when such styling defined? (most likely not). If it can serialize then yes it is false positive and we need to account styling, but if it cannot then the analyzer should still flag that i think CC @bartonjs @layomia ",
          "createdAt": "2021-02-24T05:50:38Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-02-24T05:55:05Z",
          "id": "MDEyOklzc3VlQ29tbWVudDc4NDc5OTcwOQ=="
        },
        {
          "author": "psxvoid",
          "body": "> Is `JsonSerializer` account/respects that? Can the serializer set property `_data` with constructor parameter data when such styling defined? \r\n\r\nYes, I'm sorry; it seems like `JsonConstructor` doesn't account for that and throws an `InvalidOperationException` with the following text:\r\n\r\n`Each parameter in constructor 'Void .ctor(xxx)' on type 'yyy' must bind to an object property or field on deserialization.`\r\n\r\nIt means, as long as the behaviour of the `JsonConstructor` attribute doesn't change, `NamingStyleOptions` can be ignored. Thank you for helping me to understand that.\r\n\r\nBut this still can be an issue:\r\n> If there is matched field another thing we could flag for field might be `[JsonInclude]` attribute, but the attribute is not required in case `JsonSerializerOptions.IncludeFields` set to true, but in most cases, we cannot check if that option is set, so that might be a bit noisy.\r\n\r\nI'm not sure whether there is an infrastructure to share options between .NET packages, but it may be a nice one to have.",
          "createdAt": "2021-02-24T06:48:09Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-02-24T06:48:09Z",
          "id": "MDEyOklzc3VlQ29tbWVudDc4NDgzNDkzMg=="
        },
        {
          "author": "buyaa-n",
          "body": "> It means, as long as the behaviour of the `JsonConstructor` attribute doesn't change, NamingStyleOptions can be ignored. \r\n\r\nRight, thanks for checking that\r\n\r\n> I'm not sure whether there is an infrastructure to share options between .NET packages, but it may be a nice one to have.\r\n\r\nSorry, it is not an `infrastructure` option it is `JsonSerializerOptions` can be set/used during serialization \r\n```cs\r\n   var options = new JsonSerializerOptions\r\n   {\r\n        IncludeFields = true,\r\n   };\r\n   var forecast = JsonSerializer.Deserialize<Foo>(json, options);\r\n```\r\nWhich mostly will not be available for static analysis of the declaration of a POCO, that is why i said `most cases, we cannot check if that option is set`\r\n",
          "createdAt": "2021-02-24T07:05:01Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-02-24T07:05:01Z",
          "id": "MDEyOklzc3VlQ29tbWVudDc4NDg0NDIzNg=="
        },
        {
          "author": "psxvoid",
          "body": "> Sorry, it is not an infrastructure option it is `JsonSerializerOptions` that can be set/used during serialization\r\n\r\nSorry, for confusing you, I totally get the point. Though `JsonSerializerOptions` can be defined in code, and Roslyn can compile the code on the fly and get those options, most likely it shouldn't be done in the scope of this analyzer. Because `JsonSerializerOptions` can also be defined in different ways, e.g. in AspNetCore in the `Startup.cs`:\r\n\r\n```csharp\r\npublic void ConfigureServices(IServiceCollection services)\r\n{\r\n\tservices.AddControllers().AddJsonOptions((JsonOptions o) =>\r\n\t{\r\n\t\to.JsonSerializerOptions.IgnoreNullValues = true;\r\n\t});\r\n}\r\n```\r\n\r\nBy \"infrastructure\" I meant that it would be nice to have some kind of a unified way of sharing package options (like `JsonSerializationOptions` or `NamingStyleOptions`) between different .NET packages without involving .editorconfig or other external files. But I was just thinking out loud and it's not directly related to this issue, sorry once again.",
          "createdAt": "2021-02-24T08:10:07Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-02-24T16:53:14Z",
                "user": "buyaa-n"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOBhO5Bw=="
          },
          "updatedAt": "2021-02-24T08:10:07Z",
          "id": "MDEyOklzc3VlQ29tbWVudDc4NDg4NTYyMA=="
        },
        {
          "author": "bartonjs",
          "body": "I might be wrong here, but I believe that the JsonSerializer/JsonConstructor behavior for fields only considers public fields.  So the analyzer can compare ctor parameter names to field names directly, and ctor parameter names to property names with a camel-to-Pascal conversion.\r\n\r\nI don't think there should be any warning about unset properties... they could be just doing calculations.\r\n\r\n```C#\r\npublic class SomeClass\r\n{\r\n    public string PropOne { get; }\r\n\r\n    [JsonConstructor]\r\n    public SomeClass(string propOne)\r\n    {\r\n        PropOne = propOne;\r\n    }\r\n\r\n    public int PropTwo => PropOne.Length;\r\n}\r\n```\r\n\r\nIt's only \"hey, there's a ctor parameter here that I'll never figure out how to populate, since it doesn't map to anything that would have been chosen as an automatic name in serialization\" that should warn.\r\n\r\n```C#\r\n\r\n```C#\r\npublic class SomeClass\r\n{\r\n    public string PropOne { get; }\r\n\r\n    [JsonConstructor]\r\n    public SomeClass(string propOne, int otherParam)\r\n    {\r\n        PropOne = propOne;\r\n    }\r\n\r\n    public int PropTwo => PropOne.Length;\r\n}\r\n```\r\n\r\nThere's not enough data to know where an `otherParam` value should come from, so the type isn't automagically constructable.",
          "createdAt": "2021-02-24T16:00:51Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-02-24T16:53:18Z",
                "user": "buyaa-n"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-03-01T09:53:02Z",
                "user": "psxvoid"
              }
            ],
            "totalCount": 2,
            "endCursor": "Y3Vyc29yOnYyOpHOBhs_Eg=="
          },
          "updatedAt": "2021-02-24T16:00:51Z",
          "id": "MDEyOklzc3VlQ29tbWVudDc4NTE4MDIxOA=="
        },
        {
          "author": "psxvoid",
          "body": "> I might be wrong here, but I believe that the JsonSerializer/JsonConstructor behaviour for fields only considers public fields. So the analyzer can compare ctor parameter names to field names directly, and ctor parameter names to property names with a camel-to-Pascal conversion.\r\n\r\nIt seems you are correct. Let's consider an example:\r\n\r\n```csharp\r\npublic class Person\r\n{\r\n    public int age;\r\n\r\n    [JsonConstructor]\r\n    public Person(int age)\r\n    {\r\n        this.age = age;\r\n    }\r\n}\r\n```\r\n\r\nWe will get `InvalidOperationException` if we attempt to deserialize such class. But if we add `IncludeFields` option (or add `JsonInclude` attribute to the `age` field):\r\n\r\n```csharp\r\nvar options = new JsonSerializerOptions { IncludeFields = true };\r\n```\r\n\r\nThen the class will be deserialized correctly without any runtime errors.\r\n\r\nBut for **private** fields the `InvalidOperationException` will be thrown every time on deserialization despite the presence of the options/attribute. I'm wondering whether we have to take it into account in a code-fix (as well as add another diagnostic message). The code-fix for such a case may recommend making the field public instead of renaming it. But public fields are not recommended by some best-practices, and it may be better to suggest to convert such a field into public property.\r\n\r\n\r\n> It's only \"hey, there's a ctor parameter here that I'll never figure out how to populate, since it doesn't map to anything that would have been chosen as an automatic name in serialization\" that should warn.\r\n\r\nThis situation is most likely the responsibility of `ReviewUnusedParametersAnalyzer`. But because it doesn't responsible for **runtime** behaviour, we may want to handle it in this issue. In such a case, it may be reasonable to add yet another code fix and diagnostic message to this analyzer.\r\n\r\nThank you for revealing those cases.",
          "createdAt": "2021-03-02T07:51:01Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-03-02T07:51:01Z",
          "id": "MDEyOklzc3VlQ29tbWVudDc4ODY5NzI4Ng=="
        },
        {
          "author": "buyaa-n",
          "body": "> This situation is most likely the responsibility of ReviewUnusedParametersAnalyzer. But because it doesn't responsible for runtime behaviour, we may want to handle it in this issue. In such a case, it may be reasonable to add yet another code fix and diagnostic message to this analyzer.\r\n\r\n@psxvoid I think the developer could have left a parameter without using/setting it on purpose. Plus JsonSerializer does not throw in that case, so i don't think we should warn for unused parameter, especially with a `warning` severity level",
          "createdAt": "2021-04-08T01:03:23Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-04-08T01:03:23Z",
          "id": "MDEyOklzc3VlQ29tbWVudDgxNTM3MjI1NQ=="
        },
        {
          "author": "psxvoid",
          "body": "@buyaa-n @genlu Hi!\r\n\r\nSorry, it took a bit longer than \"soon\" to come back to this issue. May I jump in and continue the implementation?\r\n\r\nI saw @genlu as an assignee to the PR and I'm not sure what does it mean.",
          "createdAt": "2021-06-20T04:40:34Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-06-20T04:40:34Z",
          "id": "MDEyOklzc3VlQ29tbWVudDg2NDQ5ODU1OQ=="
        },
        {
          "author": "buyaa-n",
          "body": "> Sorry, it took a bit longer than \"soon\" to come back to this issue. May I jump in and continue the implementation?\r\n\r\nSure, please continue the implementation, thank you!\r\n\r\n> I saw @genlu as an assignee to the PR and I'm not sure what does it mean.\r\n\r\nWe are assigned to your PR for review only, we will review your PR when you finish the implemenation",
          "createdAt": "2021-06-21T04:30:09Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-06-22T07:03:59Z",
                "user": "psxvoid"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOBvnUwg=="
          },
          "updatedAt": "2021-06-21T04:30:09Z",
          "id": "MDEyOklzc3VlQ29tbWVudDg2NDcxODU3OA=="
        },
        {
          "author": "SoggyBottomBoy",
          "body": "If a property is tagged with the JsonPropertyName which has a value matching the constructor param name, should this not find a match?\r\n\r\n```csharp\r\npublic class Example\r\n{\r\n    [JsonConstructor]\r\n    public Example(string Name)\r\n    {\r\n        FirstName = Name;\r\n    }\r\n\r\n    [JsonPropertyName(\"Name\")]\r\n    public string FirstName { get; }\r\n}\r\n\r\npublic class ExampleTest\r\n{\r\n    [Test]\r\n    public void JsonRoundTrip()\r\n    {\r\n        var test = new Example(\"Joe\");\r\n        string output = JsonSerializer.Serialize(test);\r\n        var result = JsonSerializer.Deserialize<Example>(output);\r\n\r\n        Assert.Equals(test.FirstName, result.FirstName);\r\n    }\r\n}\r\n```\r\n\r\nRunning the test above gives:\r\n`System.InvalidOperationException: 'Each parameter in the deserialization constructor on type 'Tests.Serialization.Example' must bind to an object property or field on deserialization. Each parameter name must match with a property or field on the object. The match can be case-insensitive.'`\r\n\r\nI'm trying to add json attributes to an existing library in which the models (combination of structs and classes), don't always have the property name matching the constructor parameter. ",
          "createdAt": "2022-09-18T23:39:09Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-09-18T23:39:09Z",
          "id": "IC_kwDODI9FZc5Kh8X7"
        },
        {
          "author": null,
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\nIn general, constructor arguments who initialize should match properties (casing aside). There are also cases where serializers will match properties to constructor parameters in order to construct immutable types. This would address that too.\r\n\r\nWe should limit this to types/constructs we consider being used by the JSON serializer.\r\n\r\n**Category**: Design\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>terrajobst</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>psxvoid</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`api-approved`, `area-System.Text.Json`, `code-analyzer`, `code-fixer`, `in-pr`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>Future</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2022-11-01T20:46:34Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-11-01T20:46:34Z",
          "id": "IC_kwDODI9FZc5NbwGl"
        },
        {
          "author": "eiriktsarpalis",
          "body": "@carlossanlop was the `in-pr` label applied correctly? I couldn't a find a PR linked to this issue.",
          "createdAt": "2023-07-05T15:18:25Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-07-05T15:18:25Z",
          "id": "IC_kwDODI9FZc5grWhw"
        },
        {
          "author": "buyaa-n",
          "body": "The PR is in roslyn-analyzers repo: https://github.com/dotnet/roslyn-analyzers/pull/4877",
          "createdAt": "2023-07-05T16:15:58Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-07-05T16:15:58Z",
          "id": "IC_kwDODI9FZc5grwFJ"
        },
        {
          "author": "eiriktsarpalis",
          "body": "@buyaa-n could you link the PR to this issue? I don't seem to have permissions in the roslyn-analyzers repo.",
          "createdAt": "2023-07-05T19:00:25Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-07-05T19:00:25Z",
          "id": "IC_kwDODI9FZc5gsm-M"
        },
        {
          "author": "carlossanlop",
          "body": "@eiriktsarpalis https://github.com/dotnet/roslyn-analyzers/pull/4877",
          "createdAt": "2023-07-05T19:40:45Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-07-05T19:40:45Z",
          "id": "IC_kwDODI9FZc5gs4za"
        },
        {
          "author": "carlossanlop",
          "body": "Someone please correct me if I'm wrong: I don't think we can link issues to PRs across repos. That's why I had to add the label manually.\r\n\r\nEdit: I might be wrong, I can see this in the PR:\r\n\r\n![image](https://github.com/dotnet/runtime/assets/1175054/16d1807d-c219-4ee6-922f-744a7d3a75a6)\r\n",
          "createdAt": "2023-07-05T19:41:41Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-07-05T19:42:26Z",
          "id": "IC_kwDODI9FZc5gs5nM"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Yeah I think it's only possible if you explicitly add a `Fix <link>` statement in the OP of the PR.",
          "createdAt": "2023-07-05T19:43:56Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-07-05T19:43:56Z",
          "id": "IC_kwDODI9FZc5gs7S0"
        },
        {
          "author": "buyaa-n",
          "body": "As there were no progress in the [PR](https://github.com/dotnet/roslyn-analyzers/pull/4877) moving into future milestone, CC @psxvoid.",
          "createdAt": "2023-08-14T16:16:39Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-08-14T16:16:39Z",
          "id": "IC_kwDODI9FZc5j_sCm"
        }
      ],
      "totalCount": 32,
      "endCursor": "Y3Vyc29yOnYyOpHOY_7Apg=="
    },
    "url": "https://github.com/dotnet/runtime/issues/33796",
    "title": "Constructor parameters should match property names"
  },
  {
    "author": "leopripos",
    "labels": [
      "api-approved",
      "area-System.Text.Json"
    ],
    "createdAt": "2020-03-26T06:01:04Z",
    "body": "**EDIT** We have an implementation provided by #100017, so might as well expedite an API review --@eiriktsarpalis \r\n\r\n```diff\r\nnamespace System.Text.Json;\r\n\r\npublic abstract class JsonNamingPolicy\r\n{\r\n        public static JsonNamingPolicy CamelCase { get; }\r\n        public static JsonNamingPolicy KebabCaseLower { get; }\r\n        public static JsonNamingPolicy KebabCaseUpper { get; }\r\n        public static JsonNamingPolicy SnakeCaseLower { get; }\r\n        public static JsonNamingPolicy SnakeCaseUpper { get; }\r\n+       public static JsonNamingPolicy PascalCase { get; }\r\n}\r\n\r\nnamespace System.Text.JsonSerialization;\r\n\r\npublic enum JsonKnownNamingPolicy\r\n{\r\n    Unspecified = 0,\r\n    CamelCase = 1,\r\n    SnakeCaseLower = 2,\r\n    SnakeCaseUpper = 3,\r\n    KebabCaseLower = 4,\r\n    KebabCaseUpper = 5,\r\n+   PascalCase = 6,\r\n}\r\n```\r\n\r\n<details><summary>Original Proposal</summary>\r\nPerhaps (correct me if I'm wrong), the recommended naming policy for PascalCase uses default naming policy (set to null) because we write out code in PascalCase.\r\n\r\nIf the scenario like this: I have data in dictionary,  and I want to convert them to pascal case, \r\n```\r\nvar dictionary = new Dictionary<string, string>\r\n{\r\n    { \"test\", \"Test Data\" }\r\n};\r\n\r\nvar json = JsonSerializer.Serialize(dictionary, new JsonSerializerOptions\r\n{\r\n    DictionaryKeyPolicy = null\r\n});\r\nConsole.WriteLine(json); // Outputs: {\"test\":\"Test Data\"}\r\n\r\nExpected: {\"Test\":\"Test Data\"}\r\n```\r\nThe output is `{\"test\":\"Test Data\"}`.  It will be a bug/ambiguous if we use concept `Using default naming policy for PascalCase`.\r\n\r\n3 scenarios:\r\n- Just use default (no change) from CamelCase or PascalCase.\r\n- Convert to PascalCase from CamelCase or PascalCase\r\n- Convert to CamelCase from CamelCase or PascalCase\r\n\r\nSo, I think we need new JsonPascalCaseNamingPolicy.\r\n</details>",
    "number": 34114,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "THUMBS_UP",
          "createdAt": "2020-08-16T10:49:43Z",
          "user": "leotsarev"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-08-22T13:41:34Z",
          "user": "granadacoder"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-09-12T12:19:24Z",
          "user": "BjornDeRijcke"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-10-17T19:25:06Z",
          "user": "enioluwas"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-10-27T22:02:59Z",
          "user": "ArminShoeibi"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-10-30T03:35:28Z",
          "user": "bit365"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-11-07T07:50:54Z",
          "user": "kirylvolkau"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-11-14T10:35:03Z",
          "user": "leonhardkratz"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-11-15T16:36:39Z",
          "user": "omon77"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-01-12T08:17:15Z",
          "user": "ahi-el"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-01-25T11:45:32Z",
          "user": "dineshygv"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-01-26T10:49:48Z",
          "user": "sanghel-orbyta"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-01-26T13:04:39Z",
          "user": "Mrlnvndn"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-01-31T14:48:41Z",
          "user": "matheusdotcodes"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-02-06T16:03:06Z",
          "user": "WhatzGames"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-04-07T09:09:32Z",
          "user": "thisBrian"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-04-18T10:07:06Z",
          "user": "CleanCodeX"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-04-19T16:45:27Z",
          "user": "piersb"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-04-25T18:07:55Z",
          "user": "petrkoutnycz"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-06-22T14:28:59Z",
          "user": "levdimov"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-06-24T10:18:18Z",
          "user": "leopripos"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-08-08T03:28:07Z",
          "user": "crozone"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-08-16T19:36:42Z",
          "user": "weitzhandler"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-08-23T15:22:48Z",
          "user": "austinkispotta-gep"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-08-23T17:29:12Z",
          "user": "rytelk"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-10-02T05:47:48Z",
          "user": "Aangbaeck"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-10-05T08:26:57Z",
          "user": "raymens"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-10-09T13:36:16Z",
          "user": "nikitakaralius"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-10-16T11:18:58Z",
          "user": "Stolpe"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-10-18T03:43:55Z",
          "user": "lindexi"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-11-08T07:56:59Z",
          "user": "fusselrulezz"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-11-16T20:43:52Z",
          "user": "vassourita"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-11-17T12:03:59Z",
          "user": "CaioPloomes"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-12-03T20:59:09Z",
          "user": "acraven"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-01-21T17:46:24Z",
          "user": "ApacheTech"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-01-22T15:12:48Z",
          "user": "Hypenate"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-01-26T01:51:44Z",
          "user": "CodersaurusRex"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-02-08T18:36:31Z",
          "user": "nixonjoshua98"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-02-22T13:47:16Z",
          "user": "BelarusVadzim"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-03-02T11:50:40Z",
          "user": "Uriil"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-03-18T15:12:48Z",
          "user": "ctunna"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-03-20T11:54:00Z",
          "user": "CoderAllan"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-03-20T15:52:09Z",
          "user": "lilinus"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-04-01T13:14:21Z",
          "user": "WeihanLi"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-04-04T07:43:16Z",
          "user": "ayodejii"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-04-14T14:00:58Z",
          "user": "Xor-el"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-04-16T11:27:08Z",
          "user": "Rogn"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-04-16T21:14:56Z",
          "user": "heathbm"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-04-17T12:12:21Z",
          "user": "emiltang"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-04-26T10:33:29Z",
          "user": "lucajung"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-04-30T13:11:27Z",
          "user": "marco-carvalho"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-05-07T19:18:57Z",
          "user": "sand-head"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-05-24T11:06:13Z",
          "user": "pregress"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-06-13T10:16:38Z",
          "user": "crjc"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-06-17T12:51:32Z",
          "user": "julealgon"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-06-18T20:13:38Z",
          "user": "jamesbrookeparcel2go"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-06-25T08:26:23Z",
          "user": "maciejklimasstonex"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-07-23T08:03:29Z",
          "user": "thuraua"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-07-25T01:55:46Z",
          "user": "evgeni-nabokov"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-07-28T09:46:08Z",
          "user": "miazga"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-07-31T19:50:31Z",
          "user": "migueloliveiradev"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-08-05T12:58:41Z",
          "user": "martincostello"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-10-04T16:49:29Z",
          "user": "konarx"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-10-12T10:26:23Z",
          "user": "elendil-software"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-10-21T01:07:41Z",
          "user": "jakem72360"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-11-12T15:21:31Z",
          "user": "thomasdc"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-12-14T11:36:10Z",
          "user": "Jure-BB"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-12-17T10:01:50Z",
          "user": "POFerro"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-12-21T21:25:26Z",
          "user": "aeslinger0"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-12-23T16:13:51Z",
          "user": "dubeg"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-01-15T08:18:01Z",
          "user": "Abuntxa"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-01-28T16:05:33Z",
          "user": "tr00st"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-01-29T13:43:09Z",
          "user": "Saibamen"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-01-29T14:47:09Z",
          "user": "Camble"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-02-04T12:34:05Z",
          "user": "modsmoss"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-02-14T16:40:23Z",
          "user": "tim-sandberg"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-03-04T16:53:21Z",
          "user": "vladimir-bukreev"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-03-05T08:58:22Z",
          "user": "SteveWilkes"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-03-13T14:11:53Z",
          "user": "bdominguez"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-03-26T19:33:09Z",
          "user": "daniatic"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-03-27T13:56:08Z",
          "user": "sandisa"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-03-27T13:56:25Z",
          "user": "bernards-gulbis"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-04-01T14:45:17Z",
          "user": "nzeemin"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-04-15T11:33:11Z",
          "user": "Jimmys20"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-04-22T20:44:32Z",
          "user": "mguinness"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-04-28T13:55:22Z",
          "user": "p10tyr"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-05-13T10:35:17Z",
          "user": "mci-kmd"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-05-14T12:32:24Z",
          "user": "anderstofte"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-05-18T04:41:11Z",
          "user": "avsorokin"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-05-20T12:33:03Z",
          "user": "zade107"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-05-27T15:36:35Z",
          "user": "Drru97"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-07-09T04:58:15Z",
          "user": "splitt3r"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-07-18T22:11:48Z",
          "user": "Athari"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-08-14T17:25:01Z",
          "user": "unsafePtr"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-08-21T07:36:07Z",
          "user": "paulius-anuzas-tg"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-08-30T16:48:30Z",
          "user": "skuzminoff"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-09-09T16:08:26Z",
          "user": "mashbcoding"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-09-18T06:01:21Z",
          "user": "scharnyw"
        }
      ],
      "totalCount": 98,
      "endCursor": "Y3Vyc29yOnYyOpHOC3gb4w=="
    },
    "updatedAt": "2025-04-22T21:06:53Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": "jozkee",
          "body": ">the recommended naming policy for PascalCase uses default naming policy (set to null) because we write out code in PascalCase.\r\n\r\nA `null` naming policy will leave the property names/dictionary keys unchanged, it will not enforce Pascal case.\r\n\r\n> Using default naming policy for PascalCase.\r\n\r\nI don't think there is official documentation stating that. If there is, it is clearly wrong. \r\n\r\nWith that said, you can write your own naming policy that converts from camel case to pascal case. \r\nSee [Use a custom JSON property naming policy](https://docs.microsoft.com/en-us/dotnet/standard/serialization/system-text-json-how-to#use-a-custom-json-property-naming-policy).\r\n\r\nNow, if this is about having a built-in policy for pascal case, we could evaluate adding that and re-open this issue. Closing for now.",
          "createdAt": "2020-03-26T23:40:46Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "EYES",
                "createdAt": "2025-01-08T20:52:32Z",
                "user": "aeslinger0"
              },
              {
                "content": "EYES",
                "createdAt": "2025-03-26T12:47:48Z",
                "user": "ApacheTech"
              }
            ],
            "totalCount": 2,
            "endCursor": "Y3Vyc29yOnYyOpHOELhn7g=="
          },
          "updatedAt": "2020-03-26T23:40:46Z",
          "id": "MDEyOklzc3VlQ29tbWVudDYwNDc0MTUxOA=="
        },
        {
          "author": "jozkee",
          "body": "Re-opening and setting the milestone for future; after discussing with other folks in the JSON team, adding a built-in pascal case policy is probably something that we want to do at some point. ",
          "createdAt": "2020-03-27T21:40:29Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-03-26T12:47:31Z",
                "user": "ApacheTech"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOELhnww=="
          },
          "updatedAt": "2020-03-27T21:40:29Z",
          "id": "MDEyOklzc3VlQ29tbWVudDYwNTMyNjg5OQ=="
        },
        {
          "author": "eiriktsarpalis",
          "body": "Related to #782",
          "createdAt": "2021-10-15T19:42:23Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-10-15T19:42:23Z",
          "id": "IC_kwDODI9FZc44TbHQ"
        },
        {
          "author": "granadacoder",
          "body": "> //adding a built-in pascal case policy is probably something that we want to do at some point.//\r\n\r\nI would upvote this if there was a way.\r\n\r\nThis has been one of our biggest headaches moving from Newtonsoft to System.Text.Json.\r\n\r\nBelow is the Newtonsoft version: (for future internet searchers)\r\n\r\n        public void ConfigureServices(IServiceCollection services)\r\n        {\r\n            services.AddControllers().AddNewtonsoftJson(\r\n                options =>\r\n                {\r\n                    // Use the default property (Pascal) casing.\r\n                    options.SerializerSettings.ContractResolver = new DefaultContractResolver();\r\n                });\r\n\r\n\r\nThank you for considering it in the base library.",
          "createdAt": "2022-08-22T13:50:47Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-10-18T03:44:25Z",
                "user": "lindexi"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-11-17T12:04:41Z",
                "user": "CaioPloomes"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-01-29T18:35:56Z",
                "user": "kjkrum"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-03-20T11:53:43Z",
                "user": "CoderAllan"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-03-26T12:47:57Z",
                "user": "ApacheTech"
              }
            ],
            "totalCount": 5,
            "endCursor": "Y3Vyc29yOnYyOpHOELhn_g=="
          },
          "updatedAt": "2022-08-22T13:50:47Z",
          "id": "IC_kwDODI9FZc5I3Dpy"
        },
        {
          "author": "eiriktsarpalis",
          "body": "> I would upvote this if there was a way.\r\n\r\nAdding a 👍 reaction to the OP should help boost the issue's popularity.",
          "createdAt": "2022-09-02T13:08:27Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-11-30T13:55:09Z",
                "user": "AlwaysHC"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-03-21T22:22:45Z",
                "user": "Kaveinator"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-04-18T10:06:29Z",
                "user": "CleanCodeX"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-04-21T00:30:09Z",
                "user": "welldtr"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-05-05T08:38:46Z",
                "user": "Patrick-Glatt-Vitra"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-07-10T20:21:34Z",
                "user": "stanislav-poliakov"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-08-08T03:28:03Z",
                "user": "crozone"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-11-08T07:57:06Z",
                "user": "fusselrulezz"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-11-16T20:43:34Z",
                "user": "vassourita"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-11-16T21:05:31Z",
                "user": "truibascikiploomes"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-11-17T12:04:06Z",
                "user": "CaioPloomes"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-12-19T11:29:12Z",
                "user": "JakobWl"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-04-05T10:06:58Z",
                "user": "mchilicki"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-04-21T15:19:28Z",
                "user": "kyle-revio"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-07-15T10:28:49Z",
                "user": "zak-c-lmk"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-08-03T12:59:25Z",
                "user": "gthvmt"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-03-04T16:53:14Z",
                "user": "vladimir-bukreev"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-03-26T12:47:59Z",
                "user": "ApacheTech"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-03-27T07:27:37Z",
                "user": "urosek"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-07-25T17:14:19Z",
                "user": "IDisposable"
              }
            ],
            "totalCount": 20,
            "endCursor": "Y3Vyc29yOnYyOpHOEb9B_Q=="
          },
          "updatedAt": "2022-09-02T13:08:27Z",
          "id": "IC_kwDODI9FZc5JpAOt"
        },
        {
          "author": "Patrick-Glatt-Vitra",
          "body": "Seems still not added? 3 Years???",
          "createdAt": "2023-05-05T08:40:07Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "CONFUSED",
                "createdAt": "2024-03-22T15:32:24Z",
                "user": "danmoseley"
              },
              {
                "content": "CONFUSED",
                "createdAt": "2024-04-10T22:33:14Z",
                "user": "thepirat000"
              },
              {
                "content": "CONFUSED",
                "createdAt": "2024-06-26T16:42:56Z",
                "user": "atylicki-incomm"
              },
              {
                "content": "CONFUSED",
                "createdAt": "2024-07-23T08:06:07Z",
                "user": "thuraua"
              },
              {
                "content": "CONFUSED",
                "createdAt": "2024-10-21T01:08:42Z",
                "user": "jakem72360"
              },
              {
                "content": "CONFUSED",
                "createdAt": "2025-01-13T13:35:29Z",
                "user": "dartasen"
              },
              {
                "content": "CONFUSED",
                "createdAt": "2025-01-16T05:01:19Z",
                "user": "soooooyoung"
              },
              {
                "content": "CONFUSED",
                "createdAt": "2025-03-26T12:48:01Z",
                "user": "ApacheTech"
              },
              {
                "content": "CONFUSED",
                "createdAt": "2025-08-14T12:32:39Z",
                "user": "WSkwieVolue"
              }
            ],
            "totalCount": 9,
            "endCursor": "Y3Vyc29yOnYyOpHOEeTgpg=="
          },
          "updatedAt": "2023-05-05T08:40:07Z",
          "id": "IC_kwDODI9FZc5bjFme"
        },
        {
          "author": "crozone",
          "body": "Yeah this should probably be built into the framework...",
          "createdAt": "2023-08-08T03:28:24Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-08-08T03:28:24Z",
          "id": "IC_kwDODI9FZc5jeKan"
        },
        {
          "author": "ApacheTech",
          "body": "Just adding my support for this.\r\n\r\n`JsonNamingPolicy.PascalCase` is sorely missing.\r\n\r\nScenario: I'm writing case-sensitive forms based KVPs for banking transactions.\r\n\r\nWhile I can ensure that keys are in pascal case manually, it's besides the point. By serialising the values to JSON, I can ensure the formatting is in any of the formats, other than the only format that is accepted. I should be able to add a specific validation check on serialiser to ensure that keys are serialised as PascalCase, in exactly the same way as any of the other formats.",
          "createdAt": "2024-01-21T17:52:56Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-01-22T15:13:42Z",
                "user": "Hypenate"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-01-29T01:23:46Z",
                "user": "crozone"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-02-08T18:36:28Z",
                "user": "nixonjoshua98"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-02-22T13:47:10Z",
                "user": "BelarusVadzim"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-03-01T07:42:13Z",
                "user": "MichalRuta"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-03-15T11:58:48Z",
                "user": "UsefulJeroen"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-03-20T11:54:20Z",
                "user": "CoderAllan"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-03-20T23:56:28Z",
                "user": "jpdillingham"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-03-22T17:54:18Z",
                "user": "nicolashemery"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-04-10T16:43:56Z",
                "user": "leilaamo"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-04-16T21:15:04Z",
                "user": "heathbm"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-04-19T06:45:25Z",
                "user": "jesperll"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-04-19T10:04:37Z",
                "user": "esolCrusador"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-05-16T20:35:42Z",
                "user": "JWMB"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-05-28T20:45:08Z",
                "user": "oreze"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-06-28T10:43:44Z",
                "user": "dkAnBlWo"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-07-31T19:46:33Z",
                "user": "migueloliveiradev"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-09-09T12:17:36Z",
                "user": "LukaszRumak"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-01-16T05:01:25Z",
                "user": "soooooyoung"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-06-08T12:34:09Z",
                "user": "hinenat-bh"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-07-18T22:12:39Z",
                "user": "Athari"
              }
            ],
            "totalCount": 21,
            "endCursor": "Y3Vyc29yOnYyOpHOEbKAEw=="
          },
          "updatedAt": "2024-01-21T17:54:03Z",
          "id": "IC_kwDODI9FZc5xaQqC"
        },
        {
          "author": "jai-dewani",
          "body": "I faced issues while upgrading our Legacy codebase from .NET Framework 4.8 to .NET 8. \r\n\r\nLearned the hard way that .NET Framework 4.8 uses PascalCase Json formatting by default while .NET 8 uses CamelCase. \r\nSince this is a part of legacy system, updating all the services consuming this project to use CamelCase json deserialization is not possible. \r\n\r\nSince this is missing from System.Text.Json, I had to write my own PascalCase Serializer  \r\n\r\n```\r\n    public class PascalCaseJsonNamingPolicy : JsonNamingPolicy\r\n    {\r\n        public override string ConvertName(string name)\r\n        {\r\n            if (string.IsNullOrEmpty(name) || !char.IsLower(name[0]))\r\n            {\r\n                return name;\r\n            }\r\n\r\n#if NETCOREAPP\r\n            return string.Create(name.Length, name, (chars, value) =>\r\n            {\r\n                value.CopyTo(chars);\r\n                FixCasing(chars);\r\n            });\r\n#else\r\n            char[] chars = name.ToCharArray();\r\n            FixCasing(chars);\r\n            return new string(chars);\r\n#endif\r\n        }\r\n\r\n        private static void FixCasing(Span<char> chars)\r\n        {\r\n            chars[0] = char.ToUpperInvariant(chars[0]);\r\n        }\r\n    }\r\n```",
          "createdAt": "2024-06-17T07:26:08Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-11-04T04:29:31Z",
                "user": "serious-kurlzz"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-07-31T15:52:44Z",
                "user": "serherca"
              }
            ],
            "totalCount": 2,
            "endCursor": "Y3Vyc29yOnYyOpHOEcrh-w=="
          },
          "updatedAt": "2024-06-17T07:26:08Z",
          "id": "IC_kwDODI9FZc6BfbKC"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Moving to 10.0.0 since feature development for .NET 9 is now concluded.",
          "createdAt": "2024-07-23T19:02:05Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "CONFUSED",
                "createdAt": "2024-11-18T07:07:30Z",
                "user": "alwaqfi"
              },
              {
                "content": "CONFUSED",
                "createdAt": "2024-12-12T10:45:23Z",
                "user": "qin-guan"
              },
              {
                "content": "CONFUSED",
                "createdAt": "2025-01-15T14:51:34Z",
                "user": "dartasen"
              },
              {
                "content": "CONFUSED",
                "createdAt": "2025-01-19T13:34:29Z",
                "user": "robinwilson16"
              },
              {
                "content": "CONFUSED",
                "createdAt": "2025-03-26T12:48:03Z",
                "user": "ApacheTech"
              }
            ],
            "totalCount": 5,
            "endCursor": "Y3Vyc29yOnYyOpHOELhoDA=="
          },
          "updatedAt": "2024-07-23T19:02:05Z",
          "id": "IC_kwDODI9FZc6F3_T0"
        },
        {
          "author": "bartonjs",
          "body": "[Video](https://www.youtube.com/watch?v=mUMGod4PVq8&t=0h23m23s)\n\nLooks good as proposed\r\n\r\n```C#\r\nnamespace System.Text.Json\r\n{\r\n    public partial class JsonNamingPolicy\r\n    {\r\n        public static JsonNamingPolicy PascalCase { get; }\r\n    }\r\n}\r\n\r\nnamespace System.Text.Json.Serialization\r\n{\r\n    public partial enum JsonKnownNamingPolicy\r\n    {\r\n        PascalCase = 6,\r\n    }\r\n}\r\n```",
          "createdAt": "2024-07-25T17:34:17Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-03-26T12:48:23Z",
                "user": "ApacheTech"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOELhoNA=="
          },
          "updatedAt": "2024-07-25T19:02:21Z",
          "id": "IC_kwDODI9FZc6GLEDZ"
        },
        {
          "author": "ChefBDawg",
          "body": "Can this please get merged? Migrating from Newtonsoft to System.Text on NET8 is impossible without this, as it defaults to CamelCase. Even using a custom Policy doesn't work, which tells me there is something under the hood still leveraging CamelCase.",
          "createdAt": "2025-01-29T13:36:55Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-01-31T01:18:16Z",
                "user": "crozone"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-02-10T11:34:36Z",
                "user": "tkononowiczsolwit"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-02-18T20:28:23Z",
                "user": "GrantShotwell"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-03-26T12:48:26Z",
                "user": "ApacheTech"
              }
            ],
            "totalCount": 4,
            "endCursor": "Y3Vyc29yOnYyOpHOELhoPA=="
          },
          "updatedAt": "2025-01-29T13:36:55Z",
          "id": "IC_kwDODI9FZc6cQ5PM"
        },
        {
          "author": "daniatic",
          "body": "@ChefBDawg\n\nmaybe this helps:\n\n```\nbuilder.Services.AddControllers().AddJsonOptions(options => {\n        // some serializer options defined here have an effect but not all like NamingPolicy\n        // note that AddJsonOptions has to be called in order for ConfigureHttpJsonOptions to work properly\n        // because it needs this service registration\n\t// options.JsonSerializerOptions.PropertyNamingPolicy = null; // had no effect\n\t// options.JsonSerializerOptions.Converters.Add(new JsonStringEnumConverter()); // had effect\n});\n\nbuilder.Services.ConfigureHttpJsonOptions(options => {\n\toptions.SerializerOptions.PropertyNamingPolicy = null; // defining it here, it works and keeps the casing from the c# type definitions\n});\n\n```\n",
          "createdAt": "2025-02-28T21:43:18Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-02-28T21:53:47Z",
          "id": "IC_kwDODI9FZc6gbn92"
        },
        {
          "author": "dartasen",
          "body": "@eiriktsarpalis What's the status of that feature ? Is there any awaiting pre-requisite for adding that into System.Text.Json ? Can we help the team in some way ?\n\nSeems like an insane amount of time (5y+) has passed over a straight forward feature and we still have no clue if this will be in .NET 10\n\nLooking at the .NET API Review video, PascalCase is almost as used as CamelCase in the .NET ecosystem, this is not a niche feature in c# at all.  Yes, it can be solved by adding a custom converter that can be written in 10 minutes but this is not what anyone asked for when trying to migrate a bunch of apps from Json.NET to System.Text.Json",
          "createdAt": "2025-03-26T10:57:38Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-03-26T12:48:35Z",
                "user": "ApacheTech"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOELhoUA=="
          },
          "updatedAt": "2025-03-26T11:00:59Z",
          "id": "IC_kwDODI9FZc6kJtwb"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Very unlikely this will be included in .NET 10 at this point.",
          "createdAt": "2025-03-26T11:11:49Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "CONFUSED",
                "createdAt": "2025-03-26T11:32:06Z",
                "user": "dartasen"
              },
              {
                "content": "THUMBS_DOWN",
                "createdAt": "2025-03-26T12:48:42Z",
                "user": "ApacheTech"
              }
            ],
            "totalCount": 2,
            "endCursor": "Y3Vyc29yOnYyOpHOELhoXQ=="
          },
          "updatedAt": "2025-03-26T11:11:49Z",
          "id": "IC_kwDODI9FZc6kJ2UV"
        },
        {
          "author": "dartasen",
          "body": "Can we do something to make this happen ? Is the original PR good enough ?",
          "createdAt": "2025-03-26T11:25:03Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-03-26T11:25:03Z",
          "id": "IC_kwDODI9FZc6kJ-Re"
        },
        {
          "author": "eiriktsarpalis",
          "body": "If you take a look at the PR you will see there are open questions about how this should be implemented. I don't think there can be much progress without some degree of involvement from the team, and this simply isn't something we can commit to right now.",
          "createdAt": "2025-03-26T12:45:27Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-03-26T12:45:27Z",
          "id": "IC_kwDODI9FZc6kKv20"
        },
        {
          "author": "ApacheTech",
          "body": "Just to remind of the importance for this, a solid use case is serialising data for use with case-sensitive merchant bank APIs, to ensure compliance with PCI-DSS SAQ regulations. The more we tamper with the data we send to the API, the more auditing needs to be done, and right now, we have to justify the extra validation as \"Microsoft still has a five year old support ticket in place to implement a simple fix that would mean we don't need to process the data manually.\". It doesn't sit well.",
          "createdAt": "2025-03-26T12:54:45Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "EYES",
                "createdAt": "2025-04-13T11:06:46Z",
                "user": "crozone"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOEOGGrA=="
          },
          "updatedAt": "2025-03-26T12:54:45Z",
          "id": "IC_kwDODI9FZc6kK2aP"
        },
        {
          "author": "eiriktsarpalis",
          "body": "> \"Microsoft still has a five year old support ticket in place to implement a simple fix that would mean we don't need to process the data manually.\". It doesn't sit well.\n\nTo be clear, we have many old issues sitting in the backlog. We commit to servicing regressions and security bugs in due course, but new feature requests are a matter of resourcing and business priorities.",
          "createdAt": "2025-03-26T13:24:18Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-03-26T13:24:18Z",
          "id": "IC_kwDODI9FZc6kLK81"
        },
        {
          "author": "ApacheTech",
          "body": "I am aware. But, the external auditors are not. And I cannot write \"Microsoft has many old issues lying in its backlog\" on a PCI-DSS audit form.",
          "createdAt": "2025-03-26T13:26:07Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-04-22T21:06:52Z",
          "id": "IC_kwDODI9FZc6kLMMV"
        },
        {
          "author": "vadim-wotch",
          "body": "Why is it so challenging to implement the PascalCase? How is it fundamentally different from the camelCase?",
          "createdAt": "2025-04-11T03:39:51Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-04-11T03:39:51Z",
          "id": "IC_kwDODI9FZc6mo-A6"
        },
        {
          "author": "mguinness",
          "body": "At a minimum the omission of PascalCase should be mentioned in [How to customize property names and values with System.Text.Json](https://learn.microsoft.com/en-us/dotnet/standard/serialization/system-text-json/customize-properties) as it is puzzling.  Discoverability of this issue is problematic as evidenced by [JsonNamingPolicy.PascalCase](https://developercommunity.visualstudio.com/t/JsonNamingPolicyPascalCase/10581551) in VS Dev Community.",
          "createdAt": "2025-04-22T20:55:54Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-04-22T21:02:05Z",
                "user": "ApacheTech"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOEPSQEw=="
          },
          "updatedAt": "2025-04-22T20:55:54Z",
          "id": "IC_kwDODI9FZc6oO2Xa"
        }
      ],
      "totalCount": 22,
      "endCursor": "Y3Vyc29yOnYyOpHOqDtl2g=="
    },
    "url": "https://github.com/dotnet/runtime/issues/34114",
    "title": "[System.Text.Json] Add JsonPascalCaseNamingPolicy."
  },
  {
    "author": "minato7",
    "labels": [
      "area-System.Text.Json"
    ],
    "createdAt": "2020-04-20T10:07:42Z",
    "body": "This is an issue found while upgrading to System.Text.Json in Asp.NET Core 3.1. We have two webservices which interact based on Json contract. \n\nWhen webservice1 based on ASP.NET Core, serializes using System.Text.Json a data with datatype **double with value 312.0** is passed to Python webservice, we expect serialization to have double value, but this is not the case with System.Text.Json.\n\nThis double value is serialized as int value which is causing our webservice2 to treat it as **int value 312** and causing variation in floating point results.\n\nThis was working perfectly fine with Newtonsoft.Json, as it treats double value 312.0 on serialization to be 312.0\n\nI have uploaded the repo in this link:\nhttps://github.com/minato7/IssueSystemTextJsonDouble\n\nMy assumption is if a contract has double datatype, it should be treated as double upon serialization and if it converts to int datatype this is an unexpected behavior, **there should be an option provided to treat this double like FloatParseHandling in Newtonsoft.Json** to achieve this behavior in System.Text.Json.",
    "number": 35195,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "THUMBS_UP",
          "createdAt": "2020-05-08T13:51:05Z",
          "user": "kwinkel"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2020-06-01T07:36:05Z",
          "user": "lillo42"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2020-06-11T08:32:05Z",
          "user": "SigmundVik"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2020-11-13T19:20:55Z",
          "user": "Logerfo"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-05-03T17:17:46Z",
          "user": "deepumi"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-04-11T14:38:57Z",
          "user": "rekhamoturislx"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-09-27T07:30:28Z",
          "user": "mayphi"
        }
      ],
      "totalCount": 7,
      "endCursor": "Y3Vyc29yOnYyOpHOC7Xbdw=="
    },
    "updatedAt": "2025-07-28T17:58:43Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @jozkee\nNotify danmosemsft if you want to be subscribed.",
          "createdAt": "2020-04-20T10:07:45Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2020-04-20T10:07:45Z",
          "id": "MDEyOklzc3VlQ29tbWVudDYxNjQ0NzM2MA=="
        },
        {
          "author": "weichch",
          "body": "Some discussion on [original SO post](https://stackoverflow.com/questions/61316308/system-text-json-serializes-a-value-1-0-of-type-double-to-an-value-1-of-type-int) for cross reference.",
          "createdAt": "2020-04-20T10:46:31Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2020-04-20T10:47:08Z",
          "id": "MDEyOklzc3VlQ29tbWVudDYxNjQ2ODA1Mg=="
        },
        {
          "author": "Clockwork-Muse",
          "body": ".... the first answer on SO points out: \r\n\r\n> What you have seen is a known portability issue with JSON:\r\n\r\n.... so from that point of view there's nothing \"wrong\" with `System.Text.Json`...\r\nWhat the answerer is pointing out is that JSON itself doesn't specify \"type\" for numbers, that's up to the programming language/api.\r\n\r\nUltimately, regardless of whether we adopt this suggestion, you should make your python code resilient in the face of this sort of input, especially if you may have external clients using this API.  If your API needs to do math on these numbers, it should be making sure it's deserialized them into the proper types first, not relied on them being formatted in a certain way.",
          "createdAt": "2020-04-20T15:47:37Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2020-04-20T16:06:58Z",
                "user": "IanKemp"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2020-04-21T07:16:11Z",
                "user": "minato7"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-05-27T16:40:45Z",
                "user": "eiriktsarpalis"
              }
            ],
            "totalCount": 3,
            "endCursor": "Y3Vyc29yOnYyOpHOET9baQ=="
          },
          "updatedAt": "2020-04-20T15:47:37Z",
          "id": "MDEyOklzc3VlQ29tbWVudDYxNjYzOTUwMA=="
        },
        {
          "author": "layomia",
          "body": "The [\"G17\" standard format](https://docs.microsoft.com/dotnet/standard/base-types/standard-numeric-format-strings#the-general-g-format-specifier) is used by serializer when serializing `double` types. This format omits the decimal point and/or trailing zeros, if they are not required for the data to roundtrip.\r\n\r\nWriting the smallest output required to round trip allows (de)serialization to be faster, and is employed by the serializer when when writing instances of other types, e.g. [`DateTime{Offset}`](https://docs.microsoft.com/en-us/dotnet/standard/datetime/system-text-json-support#support-for-formatting).",
          "createdAt": "2020-04-21T05:19:56Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2020-04-21T07:16:32Z",
                "user": "minato7"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-07-09T21:41:02Z",
                "user": "zgudino"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-05-17T12:35:32Z",
                "user": "Reyhn3"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-05-27T16:32:01Z",
                "user": "eiriktsarpalis"
              }
            ],
            "totalCount": 4,
            "endCursor": "Y3Vyc29yOnYyOpHOET9WUw=="
          },
          "updatedAt": "2020-04-21T05:19:56Z",
          "id": "MDEyOklzc3VlQ29tbWVudDYxNjk1ODE1OQ=="
        },
        {
          "author": "minato7",
          "body": "> The \"G17\" standard format is used by serializer when serializing double types. This format omits the decimal point and/or trailing zeros, if they are not required for the data to roundtrip.\r\n\r\nThis information is quite useful to understand what is happening under the hood, I have observed some truncation of double value coming from Python application and I could relate with G17 standard format.\r\n",
          "createdAt": "2020-04-21T13:20:54Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2020-04-21T13:20:54Z",
          "id": "MDEyOklzc3VlQ29tbWVudDYxNzE3NTQ3OA=="
        },
        {
          "author": "minato7",
          "body": "> Ultimately, regardless of whether we adopt this suggestion, you should make your python code resilient in the face of this sort of input, especially if you may have external clients using this API.\r\n\r\n@Clockwork-Muse Yes, we realized with this migration process to improve our input parsing, although our python web application is an internal microservice, we decided to make it resilient to any type of input.\r\n",
          "createdAt": "2020-04-21T13:27:06Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2020-04-21T13:27:06Z",
          "id": "MDEyOklzc3VlQ29tbWVudDYxNzE3OTAwOQ=="
        },
        {
          "author": null,
          "body": "Due to lack of recent activity, this issue has been marked as a candidate for backlog cleanup.  It will be closed if no further activity occurs within 14 more days. Any new comment (by anyone, not necessarily the author) will undo this process.\n\nThis process is part of the experimental [issue cleanup initiative](https://github.com/dotnet/runtime/issues/60288) we are currently trialing in a limited number of areas. Please share any feedback you might have in the linked issue.",
          "createdAt": "2021-10-15T20:01:28Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-10-15T20:01:28Z",
          "id": "IC_kwDODI9FZc44TdmA"
        },
        {
          "author": null,
          "body": "This issue will now be closed since it had been marked `no recent activity` but received no further activity in the past 14 days. It is still possible to reopen or comment on the issue, but please note that the issue will be locked if it remains inactive for another 30 days.",
          "createdAt": "2021-11-05T01:02:06Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-11-05T01:02:06Z",
          "id": "IC_kwDODI9FZc45UA71"
        },
        {
          "author": "OneCrazyRussian",
          "body": "I've recently stumbled upon this while migrating from .Net Framework to .Net 6 while serializing same model (using net standard 2.0 models during migration process) \r\n\r\nPascalCase/camelCase naming difference can be switched via JsonSerializerOptions.PropertyNamingPolicy, it would be convenient to have a similar option for floating and fixed point numbers for a switch or a style of number output",
          "createdAt": "2022-05-23T08:53:30Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-06-23T18:38:20Z",
                "user": "Arcturuss"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-08-01T22:02:47Z",
                "user": "smendoza88"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-08-12T14:04:35Z",
                "user": "MirzaMerdovic"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-09-05T14:25:27Z",
                "user": "m-m-0-0"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-09-26T11:57:20Z",
                "user": "stan-sz"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-11-18T21:46:04Z",
                "user": "ameb1981"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-12-15T17:08:16Z",
                "user": "Danfrid"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-01-16T12:51:54Z",
                "user": "patricksadowski"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-02-01T16:16:58Z",
                "user": "colinmazu"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-03-24T06:10:22Z",
                "user": "stevejgordon"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-04-13T14:02:43Z",
                "user": "RachelDavids"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-10-10T18:34:47Z",
                "user": "franciscoasantos"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-10-17T07:41:26Z",
                "user": "TrentSkyDomain"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-02-20T22:54:45Z",
                "user": "rmoore-metafora"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-04-12T13:49:44Z",
                "user": "htotmada"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-04-17T13:09:03Z",
                "user": "otto-gebb"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-05-09T12:37:28Z",
                "user": "tlb-brunoreginato"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-05-21T09:34:09Z",
                "user": "MikhailIzvekov"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-06-07T07:03:27Z",
                "user": "Larry57"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-07-09T12:41:10Z",
                "user": "AnTiiK"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-11-15T15:03:46Z",
                "user": "luckyycode"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-02-09T15:17:11Z",
                "user": "Sella-GH"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-06-23T07:15:11Z",
                "user": "minato7"
              }
            ],
            "totalCount": 23,
            "endCursor": "Y3Vyc29yOnYyOpHOEXiGxw=="
          },
          "updatedAt": "2022-05-23T08:53:30Z",
          "id": "IC_kwDODI9FZc5DnUUv"
        },
        {
          "author": "niemyjski",
          "body": "Any idea if this will be resolved, seems like a blocking issue",
          "createdAt": "2025-05-27T14:17:35Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-05-27T14:17:35Z",
          "id": "IC_kwDODI9FZc6tnCno"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Having taken a closer look, I agreed with the sentiment of https://github.com/dotnet/runtime/issues/35195#issuecomment-616958159 and https://github.com/dotnet/runtime/issues/35195#issuecomment-616639500. This is behaviour is by design and reflects the fact that IEEE floating points don't distinguish between `1`, `1.0`, `1E0`, or `1.000`. \n\nAs a workaround, you could try writing a custom converter piggybacking on `decimal`, where decimal points are representable:\n\n```C#\nusing System.Text.Json;\nusing System.Text.Json.Serialization;\n\nJsonSerializerOptions options = new()\n{\n    Converters =\n    {\n        new DoubleWithDecimalPointConverter()\n    }\n};\n\nConsole.WriteLine(JsonSerializer.Serialize<double>(1, options)); // 1.0\n\npublic sealed class DoubleWithDecimalPointConverter : JsonConverter<double>\n{\n    public override double Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)\n    {\n        return reader.GetDouble();\n    }\n\n    public override void Write(Utf8JsonWriter writer, double value, JsonSerializerOptions options)\n    {\n        if (double.IsInteger(value))\n        {\n            writer.WriteNumberValue((decimal)value * 1.0M);\n        }\n        else\n        {\n            writer.WriteNumberValue(value);\n        }\n    }\n}\n```",
          "createdAt": "2025-05-27T16:45:55Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-05-27T16:45:55Z",
          "id": "IC_kwDODI9FZc6tpPcT"
        },
        {
          "author": "niemyjski",
          "body": "@captainsafia Can we please get this one fixed?",
          "createdAt": "2025-07-28T13:14:08Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-07-28T13:14:08Z",
          "id": "IC_kwDODI9FZc66ZS1y"
        }
      ],
      "totalCount": 12,
      "endCursor": "Y3Vyc29yOnYyOpHOumUtcg=="
    },
    "url": "https://github.com/dotnet/runtime/issues/35195",
    "title": "System.Text.Json changes the data datatype from double to int on serialization"
  },
  {
    "author": "NinoFloris",
    "labels": [
      "area-System.Text.Json",
      "wishlist"
    ],
    "createdAt": "2020-04-21T12:04:00Z",
    "body": "I'd like to know how to compose an outer generic type with an inner object in such a way the inner object is embedded (unwrapped/flattened) in the outer type during serialization.\r\n\r\nToday JsonSerializer will always emit object start/end when called in a custom jsonconverter (as it would when calling it outside) There seems to be no mechanism to leave out the start/end delimiters. Together with the fact no metadata api is exposed by STJ means embedding is extremely difficult.\r\n\r\nExample 'pseudocode'\r\n```cs\r\npublic class Toggle<T> \r\n{\r\n    private Toggle(bool enabled, T? data = null)\r\n    {\r\n        Enabled = enabled;\r\n        Data = data;\r\n    }\r\n\r\n    public bool Enabled { get; }\r\n    public T? Data { get; }\r\n\r\n    public CreateDisabled() => new Toggle(false);\r\n    public CreateEnabled(T data) => new Toggle(true, data);\r\n}\r\n\r\npublic class Data \r\n{\r\n    public bool Foo { get; set } \r\n    public int Bar { get; set; }\r\n}\r\n\r\nJsonSerializer.Serialize(Toggle<Data>.CreateEnabled(new Data { Foo = false, Bar = 1 });\r\n\r\n```\r\n\r\nI would want to have a way to create a converter such that the output of that Serialize call is embedding Data in Toggle like this.\r\n\r\n```json\r\n{\r\n    \"enabled\": true,\r\n    \"foo\": false,\r\n    \"bar\": 1\r\n}\r\n```",
    "number": 35240,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-03-21T07:20:03Z",
          "user": "Chakrygin"
        }
      ],
      "totalCount": 1,
      "endCursor": "Y3Vyc29yOnYyOpHOC2rZow=="
    },
    "updatedAt": "2022-09-02T16:26:22Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @jozkee\nNotify danmosemsft if you want to be subscribed.",
          "createdAt": "2020-04-21T12:04:04Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2020-04-21T12:04:04Z",
          "id": "MDEyOklzc3VlQ29tbWVudDYxNzEzNzc0NQ=="
        },
        {
          "author": "layomia",
          "body": "Do you know of prior art in other serializers to achieve this flattening operation?\r\n\r\nThis is achievable with the converter model by handwriting each property as desired, either statically or with reflection:\r\n\r\n```csharp\r\nusing System;\r\nusing System.Text.Json;\r\nusing System.Text.Json.Serialization;\r\n\t\t\t\t\t\r\npublic class Program\r\n{\r\n\tpublic static void Main()\r\n\t{\r\n\t\tvar options = new JsonSerializerOptions();\r\n\t\toptions.Converters.Add(new ToggleConverter());\r\n\r\n\t\tstring x = JsonSerializer.Serialize(Toggle<Data>.CreateEnabled(new Data { Foo = false, Bar = 1 }), options);\r\n\t\tConsole.WriteLine(x);\r\n\t}\r\n\t\r\n\tpublic class Toggle<T> \r\n\t{\r\n\t\tprivate Toggle(bool enabled, T data)\r\n\t\t{\r\n\t\t\tEnabled = enabled;\r\n\t\t\tData = data;\r\n\t\t}\r\n\r\n\t\tpublic bool Enabled { get; }\r\n\t\tpublic T Data { get; }\r\n\r\n\t\tpublic static Toggle<T> CreateDisabled() => new Toggle<T>(false, (T)(object)null);\r\n\t\tpublic static Toggle<T> CreateEnabled(T data) => new Toggle<T>(true, data);\r\n\t}\r\n\r\n\tpublic class Data \r\n\t{\r\n\t\tpublic bool Foo { get; set; } \r\n\t\tpublic int Bar { get; set; }\r\n\t}\r\n\r\n\tpublic class ToggleConverter : JsonConverter<Toggle<Data>>\r\n\t{\r\n\t\tpublic override Toggle<Data> Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)\r\n\t\t{\r\n\t\t\tthrow new NotImplementedException();\r\n\t\t}\r\n\t\t\r\n\t\tpublic override void Write(Utf8JsonWriter writer, Toggle<Data> value, JsonSerializerOptions options)\r\n\t\t{\r\n\t\t  \twriter.WriteStartObject();\r\n\r\n\t\t\t// Written this way to show how complex objects can be written/composed with JsonSerializer.\r\n\t\t  \twriter.WritePropertyName(\"enabled\");\r\n\t\t  \tJsonSerializer.Serialize(writer, value.Enabled);\r\n\r\n\t\t  \twriter.WritePropertyName(\"foo\");\r\n\t\t  \tJsonSerializer.Serialize(writer, value.Data.Foo);\r\n\r\n\t\t  \twriter.WritePropertyName(\"bar\");\r\n\t\t  \tJsonSerializer.Serialize(writer, value.Data.Bar);\r\n\r\n\t\t  \twriter.WriteEndObject();\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\nAs you mention, exposing type/property metadata that the serializer relies on could make this easier in the future - https://github.com/dotnet/runtime/issues/34456.",
          "createdAt": "2020-04-21T17:32:17Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2020-12-03T02:59:25Z",
                "user": "admirpajalic"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOBYuhvg=="
          },
          "updatedAt": "2020-04-21T17:32:17Z",
          "id": "MDEyOklzc3VlQ29tbWVudDYxNzMwNjA2Ng=="
        },
        {
          "author": "NinoFloris",
          "body": "This isn't easily possible for any T as was the point of me having `Toggle<T>` being a generic type.\r\n\r\n>\t\t\t// Written this way to show how complex objects can be written/composed with JsonSerializer.\r\n\r\nI'd say calling it composition is pretty disingenuous , there's no composition of behavior here, just manual inlining.",
          "createdAt": "2020-04-21T17:36:53Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2020-04-21T17:43:15Z",
          "id": "MDEyOklzc3VlQ29tbWVudDYxNzMwODc1Mg=="
        },
        {
          "author": "NinoFloris",
          "body": "https://www.logicbig.com/tutorials/misc/jackson/json-unwrapped.html\r\n\r\nJackson supports this\r\n\r\nProbably quite some functional language serializers do as well, because this is key to great support for unions (which are often cross cutting generic types)",
          "createdAt": "2020-04-21T17:40:20Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2020-04-21T17:44:56Z",
          "id": "MDEyOklzc3VlQ29tbWVudDYxNzMxMDY0Ng=="
        },
        {
          "author": "layomia",
          "body": "> This isn't easily possible for any T as was the point of me having Toggle<T> being a generic type.\r\n\r\nThat is just a concrete example. You can define a generic converter and use the factory pattern to handle various `T`s:\r\n\r\nhttps://docs.microsoft.com/en-us/dotnet/standard/serialization/system-text-json-converters-how-to#steps-to-follow-the-factory-pattern",
          "createdAt": "2020-04-21T20:59:42Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2020-04-21T20:59:42Z",
          "id": "MDEyOklzc3VlQ29tbWVudDYxNzQxMTMyMw=="
        },
        {
          "author": "NinoFloris",
          "body": "I'm sorry, I'm a little bit frustrated by your response.\n\nHow can I embed a type I don't know of which properties exist? Maybe that T is a collection, or an object I'd like to have serialized exactly like JsonSerializer does, because maybe there's a custom converter registered for that T etcetera. It's not as simple as \"just ask reflection for all public properties\"\n\nThink about it from the perspective of, Toggle lives in a library, T is up to the user.",
          "createdAt": "2020-04-21T21:51:50Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2020-04-21T21:53:01Z",
          "id": "MDEyOklzc3VlQ29tbWVudDYxNzQzMzEzNg=="
        },
        {
          "author": "layomia",
          "body": "> I'm sorry, I'm a little bit frustrated by your response.\r\n>\r\n> How can I embed a type I don't know of which properties exist? Maybe that T is a collection, or an object I'd like to have serialized exactly like JsonSerializer does, because maybe there's a custom converter registered for that T etcetera. It's not as simple as \"just ask reflection for all public properties\"\r\n\r\nI agree that it is not easy to do the sort of composition you seek by reflecting over the properties of arbirtrary types, while honoring the options specified at the root call to the serializer (including using custom converters). I was just pointing out that it is in fact possible.\r\n\r\nWe are aware that \"composition\"  is not easy to do with the current converter model, and plan to address this. However, this work is out of scope for 5.0.",
          "createdAt": "2020-04-21T22:52:44Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2020-04-21T22:52:44Z",
          "id": "MDEyOklzc3VlQ29tbWVudDYxNzQ1MzYwMw=="
        },
        {
          "author": "NinoFloris",
          "body": "Good to hear it's on your radar.\n\nI do know about generic converters, they work well in general cases, mostly because T can be resolved via a call to the serializer, with the caveat this only works for the shape of a nested value. This is the main inflexibility I wanted to point out.\n\nIn any case thanks for taking the time.",
          "createdAt": "2020-04-21T23:28:14Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2020-04-21T23:28:14Z",
          "id": "MDEyOklzc3VlQ29tbWVudDYxNzQ2MzY5MA=="
        },
        {
          "author": "eiriktsarpalis",
          "body": "> How can I embed a type I don't know of which properties exist? Maybe that T is a collection, or an object I'd like to have serialized exactly like JsonSerializer does, because maybe there's a custom converter registered for that T etcetera. It's not as simple as \"just ask reflection for all public properties\"\r\n\r\nCorrect me if I'm wrong, but my understanding of the unwrap feature is that it is constrained to `T` types that serialize as JSON objects. And given our converter model, it is likely this would never be supported for `T` types that define custom converters. \r\n\r\nA possible solution might be to add [`JsonExtensionDataAttribute`](https://docs.microsoft.com/en-us/dotnet/api/system.text.json.serialization.jsonextensiondataattribute?view=net-5.0)-like attribute that acts on properties with POCOs. It might be interesting to investigate how such a feature deals with naming conflicts (e.g. both `Toggle<T>` and `Data` containing a property with the same name).",
          "createdAt": "2021-10-19T14:57:27Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-10-19T14:57:27Z",
          "id": "IC_kwDODI9FZc44by6b"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Related to #55120.",
          "createdAt": "2022-09-02T16:26:21Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-09-02T16:26:21Z",
          "id": "IC_kwDODI9FZc5JpzLH"
        }
      ],
      "totalCount": 10,
      "endCursor": "Y3Vyc29yOnYyOpHOSacyxw=="
    },
    "url": "https://github.com/dotnet/runtime/issues/35240",
    "title": "System.Text.Json embed object into custom jsonconverter"
  },
  {
    "author": "layomia",
    "labels": [
      "area-System.Text.Json",
      "test-enhancement",
      "help wanted"
    ],
    "createdAt": "2020-04-29T17:04:13Z",
    "body": "Following up on https://github.com/dotnet/runtime/pull/35046#discussion_r417063819:\r\n\r\nIn async tests for collections, we don't assert the result of serializing dictionaries with `ReferenceHandling.Preserve` active. This is because across multiple serialization operations, `ref` and `id` and metadata IDs may not be the same due to non-deterministic order of elements returned by `GetEnumerator()` for dictionaries. It is thus hard to compare the serialized results:\r\n\r\nhttps://github.com/dotnet/runtime/blob/0fa0b905f65e57f5eb64dd556a07ead522930c8a/src/libraries/System.Text.Json/tests/Serialization/Stream.Collections.cs#L98-L102\r\n\r\nWe can include these types by overriding the `GetEnumerator` method for these collections to return a deterministic order, and/or using types with deterministic order e.g. `OrderedDictionary`, `SortedDictionary`.",
    "number": 35611,
    "reactions": {
      "hasNextPage": false,
      "nodes": [],
      "totalCount": 0,
      "endCursor": null
    },
    "updatedAt": "2021-10-21T15:26:21Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @jozkee\nNotify danmosemsft if you want to be subscribed.",
          "createdAt": "2020-04-29T17:04:16Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2020-04-29T17:04:16Z",
          "id": "MDEyOklzc3VlQ29tbWVudDYyMTM0MTE1MA=="
        },
        {
          "author": "JoshSchreuder",
          "body": "@layomia I was able to add the deterministic dictionmary types pretty easily (I think), but what's the intended approach for `overriding the GetEnumerator method for these collections to return a deterministic order`?\r\n\r\nWere you thinking something like subclassing all the dictionary types with overridden `GetEnumerator` and using those in the test, or is this possible to do with `Reflection.Emit` without using subclasses?",
          "createdAt": "2020-06-06T01:42:27Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2020-06-06T01:42:27Z",
          "id": "MDEyOklzc3VlQ29tbWVudDYzOTk0ODE3Mg=="
        },
        {
          "author": "layomia",
          "body": "> Were you thinking something like subclassing all the dictionary types with overridden GetEnumerator and using those in the test\r\n\r\n@JoshSchreuder  yeah we can just use custom dictionaries in those tests. This would be a good approach if you're still interested in fixing this.\r\n\r\nPerhaps a [SortedDictionary ](https://docs.microsoft.com/dotnet/api/system.collections.generic.sorteddictionary-2?view=netcore-3.1) can be used as well.",
          "createdAt": "2020-07-31T18:24:52Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2020-07-31T20:50:03Z",
          "id": "MDEyOklzc3VlQ29tbWVudDY2NzI4NjQ1Ng=="
        },
        {
          "author": "layomia",
          "body": "Moving to future as we have ample coverage for the relevant scenario, which is reference handling for POCOs.",
          "createdAt": "2020-07-31T20:50:54Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2020-07-31T20:50:54Z",
          "id": "MDEyOklzc3VlQ29tbWVudDY2NzM1MTAwMw=="
        }
      ],
      "totalCount": 4,
      "endCursor": "Y3Vyc29yOnYyOpHOJ8b32w=="
    },
    "url": "https://github.com/dotnet/runtime/issues/35611",
    "title": "Assert async-serialized content of dictionaries with ReferenceHandling.Preserve active"
  },
  {
    "author": "nathan-alden-sr",
    "labels": [
      "api-needs-work",
      "area-System.Text.Json",
      "wishlist"
    ],
    "createdAt": "2020-06-08T21:40:11Z",
    "body": "See this closed issue for reference: #29648.\r\n\r\nI feel like the creator of the linked issue did not do a good job explaining why a feature that honors case-affecting options for `[JsonPropertyName]` names is valuable. The issue with _not_ doing this is it forces my DTOs to know about the `JsonSerializerOptions` being used to serialize them; it's essentially a leaky abstraction. DTOs should not be hardcoded to expect certain options.\r\n\r\nThere are likely several ways to solve this problem. We could have a boolean on `JsonPropertyNameAttribute` that tells the serializer/deserializer to honor case:\r\n```cs\r\n[JsonPropertyName(\"foo\", honorCaseProcessing: true)]\r\n```\r\nor it could also be specified in `JsonSerializerOptions` similar to the code referenced in the closed issue.\r\n\r\nTo make this crystal clear:\r\n```cs\r\npublic class Dto\r\n{\r\n    [JsonPropertyName(\"foo\")] // How does it know about the options used to serialize it?\r\n    public bool Foo { get; set; }\r\n}\r\n```\r\nSomewhere far from `Dto`:\r\n```\r\nJsonSerializer.Serialize(\r\n    new Dto(),\r\n    new JsonSerializerOptions { PropertyNamingPolicy = JsonNamingPolicy.CamelCase });\r\n```",
    "number": 37614,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "THUMBS_UP",
          "createdAt": "2020-06-09T18:59:33Z",
          "user": "etreff-tillster"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-10-25T03:15:56Z",
          "user": "xparadoxical"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-11-15T19:37:14Z",
          "user": "Duranom"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-09-28T14:49:06Z",
          "user": "MaceWindu"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-12-12T15:51:03Z",
          "user": "biancahuluban"
        }
      ],
      "totalCount": 5,
      "endCursor": "Y3Vyc29yOnYyOpHOC9a-3A=="
    },
    "updatedAt": "2024-01-08T11:05:14Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": "layomia",
          "body": "From @buyaa-n in https://github.com/dotnet/runtime/issues/29648:\r\n\r\n> For Newtonsoft.Json need to set OverrideSpecifiedNames option too\r\n> \r\n> ```cs\r\n>    NamingStrategy = new CamelCaseNamingStrategy\r\n>    {\r\n>        OverrideSpecifiedNames = true\r\n>    }\r\n> ```\r\n> \r\n> anyways, if you guys think its not needed then am fine with closing\r\n\r\n",
          "createdAt": "2020-11-06T20:35:00Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2020-11-06T20:35:00Z",
          "id": "MDEyOklzc3VlQ29tbWVudDcyMzI4Nzg4NA=="
        },
        {
          "author": "eiriktsarpalis",
          "body": "Starting with .NET 7, one possible workaround is to use a [custom contract resolver](https://github.com/dotnet/runtime/issues/63686) which applies naming policies directly to `JsonPropertyInfo.Name`. This would allow using a naming policy agnostic JsonPropertyNameAttribute declaration.",
          "createdAt": "2022-09-02T16:43:05Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-09-02T16:43:05Z",
          "id": "IC_kwDODI9FZc5Jp3Bd"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Per https://github.com/dotnet/runtime/issues/96426, we should consider exposing a similar setting to the `JsonPolymorphicAttribute`/`JsonDerivedTypeAttribute` APIs as well.",
          "createdAt": "2024-01-08T11:05:13Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-01-08T11:05:13Z",
          "id": "IC_kwDODI9FZc5wGpvn"
        }
      ],
      "totalCount": 3,
      "endCursor": "Y3Vyc29yOnYyOpHOcBqb5w=="
    },
    "url": "https://github.com/dotnet/runtime/issues/37614",
    "title": "Reconsider applying property case processing to custom JsonPropertyNameAttribute names"
  },
  {
    "author": "SigmundVik",
    "labels": [
      "question",
      "area-System.Text.Json",
      "backlog-cleanup-candidate"
    ],
    "createdAt": "2020-06-23T12:32:35Z",
    "body": "We are in the process of migrating from `Newtonsoft.Json` to `System.Text.Json` following similar steps as described [here](https://docs.microsoft.com/en-us/dotnet/standard/serialization/system-text-json-migrate-from-newtonsoft-how-to).\r\n\r\nUnfortunately `System.Text.Json` exception messages are of lower quality than the corresponding exception messages produced by `Newtonsoft.Json`.  In our ASP.NET Core application this gets exacerbated for the validation errors and the end result is an API which is less user friendly.  Please see this [issue ](https://github.com/dotnet/aspnetcore/issues/23256 )for more details.\r\n\r\nIn the following examples we try to deserialize a JSON string to this class:\r\n```C#\r\n    public class Model\r\n    {\r\n        public Guid Id { get; set; }\r\n        public int Integer { get; set; }\r\n        public string String { get; set; }\r\n    }\r\n```\r\nFor the different `jsonString` values listed below, this code was executed:\r\n```C#\r\n            try\r\n            {\r\n                Model model = Newtonsoft.Json.JsonConvert.DeserializeObject<Model>(jsonString);\r\n            }\r\n            catch (Newtonsoft.Json.JsonException oldEx)\r\n            {\r\n                // The value of oldEx.Message will be listed below.\r\n            }\r\n\r\n            try\r\n            {\r\n                Model model = System.Text.Json.JsonSerializer.Deserialize<Model>(jsonString);\r\n            }\r\n            catch (System.Text.Json.JsonException newEx)\r\n            {\r\n                // The value of newEx will be listed below.\r\n            }\r\n```\r\nExample 1:\r\n```\r\n            string jsonString =\r\n                @\"{\r\n                    \"\"Id\"\": \"\"00000000-0000-0000-0000-00000000000x\"\"\r\n                }\";\r\n=>\r\noldEx: \"Error converting value \\\"00000000-0000-0000-0000-00000000000x\\\" to type 'System.Guid'. Path 'Id', line 2, position 64.\"\r\nnewEx: \"The JSON value could not be converted to System.Guid. Path: $.Id | LineNumber: 1 | BytePositionInLine: 64.\"\r\n```\r\nExample 2:\r\n```\r\n            string jsonString =\r\n                @\"{\r\n                    \"\"Integer\"\": 2x\r\n                }\";\r\n=>\r\noldEx: \"Input string '2x' is not a valid integer. Path 'Integer', line 2, position 33.\"\r\nnewEx: \"'x' is an invalid end of a number. Expected a delimiter. Path: $.Integer | LineNumber: 1 | BytePositionInLine: 32.\"\r\n```\r\nExample 3:\r\n```\r\n            string jsonString =\r\n                @\"{\r\n                    \"\"string\"\": 2 x\r\n                }\";\r\n=>\r\noldEx: \"After parsing a value an unexpected character was encountered: x. Path 'string', line 2, position 32.\"\r\nnewEx: \"'x' is invalid after a value. Expected either ',', '}', or ']'. Path: $ | LineNumber: 1 | BytePositionInLine: 32.\"\r\n```\r\nAll of these error messages are now harder to understand.  In addition, the paths are less helpful and humans do not start counting line numbers from zero.  It would be great if `System.Text` could produce exception error messages that were of the same quality as `Newtonsoft.Json`.\r\n\r\nAlso, with this JSON string:\r\n```C#\r\n            string jsonString =\r\n                @\"{\r\n                    \"\"string\"\": 2\r\n                }\";\r\n```\r\nthen there is no exception thrown for neither `Newtonsoft.Json` nor `System.Text.Json`, but the deserialized values differ: `model.string` is `\"2\"` for `Newtonsoft.Json` (this kind of leniency and the lack of a [strict mode](https://github.com/JamesNK/Newtonsoft.Json/issues/646) in `Newtonsoft.Json` is one the reasons we wanted to migrate in the first place).  However, `System.Text.Json` leaves `model.string` as `null`, which is odd (I would have expected an exception here).  In the ASP.NET Core application this case results in a validation error when using `System.Text.Json`.",
    "number": 38269,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "EYES",
          "createdAt": "2023-09-22T09:03:25Z",
          "user": "fowl2"
        }
      ],
      "totalCount": 1,
      "endCursor": "Y3Vyc29yOnYyOpHOCyyABQ=="
    },
    "updatedAt": "2022-08-17T23:38:59Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": "ahsonkhan",
          "body": "\r\n> Also, with this JSON string:\r\n> \r\n> ```cs\r\n>             string jsonString =\r\n>                 @\"{\r\n>                     \"\"string\"\": 2\r\n>                 }\";\r\n> ```\r\n> \r\n> then there is no exception thrown for neither `Newtonsoft.Json` nor `System.Text.Json`, but the deserialized values differ: `model.string` is `\"2\"` for `Newtonsoft.Json` (this kind of leniency and the lack of a [strict mode](https://github.com/JamesNK/Newtonsoft.Json/issues/646) in `Newtonsoft.Json` is one the reasons we wanted to migrate in the first place). However, `System.Text.Json` leaves `model.string` as `null`, which is odd (I would have expected an exception here). In the ASP.NET Core application this case results in a validation error when using `System.Text.Json`.\r\n\r\nFor this particular case, it is because there is no case-sensitive matching property within the `Model` class that exactly matches with the name `string`. S.T.J is case-sensitive by default. It would be equivalent to passing in something like `\"{\\\"foo\\\": 2}\"`. That property is just ignored.\r\n\r\nYou could annotate your model with the expected name, or add a case-insensitive option to the serializer, and/or use a built-in/custom naming policy.\r\n\r\n```C#\r\npublic class Model\r\n{\r\n    public Guid Id { get; set; }\r\n    public int Integer { get; set; }\r\n    [JsonPropertyName(\"string\")]\r\n    public string String { get; set; }\r\n}\r\n```\r\nOR\r\n```C#\r\nvar options = new JsonSerializerOptions { PropertyNameCaseInsensitive = true };\r\nModel model = System.Text.Json.JsonSerializer.Deserialize<Model>(jsonString, options);\r\n```\r\nOR\r\n```C#\r\nvar options = new JsonSerializerOptions { PropertyNamingPolicy = JsonNamingPolicy.CamelCase };\r\nModel model = System.Text.Json.JsonSerializer.Deserialize<Model>(jsonString, options);\r\n```\r\n\r\nAnd then you get the exception:\r\n```text\r\nSystem.Text.Json.JsonException: The JSON value could not be converted to System.String. Path: $.string | LineNumber: 1 | BytePositionInLine: 31.\r\n ---> System.InvalidOperationException: Cannot get the value of a token type 'Number' as a string.\r\n```",
          "createdAt": "2020-07-15T21:22:56Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2020-07-20T18:05:39Z",
                "user": "SigmundVik"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOBK476Q=="
          },
          "updatedAt": "2020-07-15T21:22:56Z",
          "id": "MDEyOklzc3VlQ29tbWVudDY1OTAxOTMzNg=="
        },
        {
          "author": "osexpert",
          "body": "> humans do not start counting line numbers from zero\r\n\r\nGood point. But I don't think machines count line numbers from zero either:-D Looks like a bug to me.",
          "createdAt": "2020-11-12T21:40:40Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2020-11-12T21:40:47Z",
          "id": "MDEyOklzc3VlQ29tbWVudDcyNjM1NzQyOQ=="
        },
        {
          "author": null,
          "body": "Due to lack of recent activity, this issue has been marked as a candidate for backlog cleanup.  It will be closed if no further activity occurs within 14 more days. Any new comment (by anyone, not necessarily the author) will undo this process.\n\nThis process is part of the experimental [issue cleanup initiative](https://github.com/dotnet/runtime/issues/60288) we are currently trialing in a limited number of areas. Please share any feedback you might have in the linked issue.",
          "createdAt": "2021-10-15T19:23:49Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-10-15T19:23:49Z",
          "id": "IC_kwDODI9FZc44TYEi"
        },
        {
          "author": "bart-degreed",
          "body": "This is just great. Even today, STJ lacks many critical features from Newtonsoft and is still full of bugs and design flaws. Lots of issues were opened by the community, which often got a response along the lines of \"we'll wait and see if more people need this.\" But you forgot that those issues get auto-locked or auto-closed, so no one can upvote them anymore today. We're all very disappointed with .NET 6, which should have addressed the big STJ issues above all else. Traditionally, it always takes Microsoft a few versions before getting it right, so the masses wait for that. You should have gotten it right by now. If we could upvote, you'd be shocked by the number of developers struggling with adopting STJ in real projects. But now all innovation has stopped in Newtonsoft and we are stuck with an inferior replacement. Thanks a lot!",
          "createdAt": "2021-10-18T08:11:56Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-10-18T12:12:36Z",
          "id": "IC_kwDODI9FZc44WvVu"
        },
        {
          "author": "eiriktsarpalis",
          "body": "From the OP I can deduce the following actionable suggestions:\r\n\r\n- Change the `lineNumber` and `bytePositionInLine` reporting from 0-based to 1-based. I think that's doable however I suspect it would be a breaking since this merely reflects the API of [`JsonException`](https://docs.microsoft.com/en-us/dotnet/api/system.text.json.jsonexception.bytepositioninline?view=net-5.0) which clearly states that these numbers are 0-based. I think there's an argument to be made about these figures needing to be human readable, but we still need to be careful about this. cc @ahsonkhan @bartonjs @layomia for thoughts.\r\n- Have `Utf8JsonReader` include the raw JSON value in the exception message whenever [a `FormatException` is thrown](https://github.com/dotnet/runtime/blob/074e8f0e697e94ab2ecaaedaf6e6d0b5b92b484c/src/libraries/System.Text.Json/src/System/Text/Json/ThrowHelper.cs#L574-L659). I get that it can be useful when debugging code, but from a security perspective it can sometimes be considered harmful (e.g. because PII from prod might leak to an insecure log aggregator). I'm not sure what  our policy is from the .NET perspective, and if eliding raw content from our FormatExceptions is intentional. cc @GrabYourPitchforks",
          "createdAt": "2021-10-18T13:34:03Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-10-18T13:34:36Z",
          "id": "IC_kwDODI9FZc44X1xQ"
        },
        {
          "author": "NinoFloris",
          "body": "Another actionable thing would be to have 'public' messages on JsonException (probably as a new property). Today it mentions 'change the reader options' (trailing comma error), full type names and other such internal concerns. It's hardly feasible to have to manually match *every* json exception message and build a nice one from constituent parts again.\r\n\r\nAsp.net core mvc model binding is also notorious for spewing internal details like that.\r\nI can't ship a public api that responds with those kind of messages to clients (not end users). While recovering the diagnostic value another way amounts to writing your own serializer. That or painstakingly finding all relevant messages to match on and hoping they don't change.\n\nHaving a nullable property for a public message  would help a lot, we'll defer to a generic message if it's null.\n",
          "createdAt": "2022-08-10T12:13:14Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-08-10T15:19:41Z",
          "id": "IC_kwDODI9FZc5IKBrs"
        },
        {
          "author": "danmoseley",
          "body": "@blowdart  the issue of policy around sensitive info in exception messages again. ",
          "createdAt": "2022-08-10T14:56:10Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-08-10T14:56:10Z",
          "id": "IC_kwDODI9FZc5IKz5U"
        },
        {
          "author": "bkoelman",
          "body": "How about adding a boolean property `JsonSerializerOptions.IncludeSensitiveDataInExceptions` (`false` by default), that enables application developers to get more details? This is [quite common](https://docs.microsoft.com/en-us/dotnet/api/microsoft.entityframeworkcore.dbcontextoptionsbuilder.enablesensitivedatalogging?view=efcore-6.0) to provide.\r\n\r\nThen anyone can decide when its appropriate to turn it on, for example:\r\n- wrapped in a `#if DEBUG`\r\n- based on `app.Environment.IsDevelopment()` or `ASPNETCORE_ENVIRONMENT` environment variable\r\n- based on externally stored configuration, so it can be turned on in prod for a short amount of time (in extreme scenarios)\r\n",
          "createdAt": "2022-08-17T23:38:22Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-08-17T23:38:59Z",
          "id": "IC_kwDODI9FZc5Io1Zj"
        }
      ],
      "totalCount": 8,
      "endCursor": "Y3Vyc29yOnYyOpHOSKNWYw=="
    },
    "url": "https://github.com/dotnet/runtime/issues/38269",
    "title": "Migrating from Newtonsoft.Json to System.Text.Json reduces quality of error messages"
  },
  {
    "author": "eerhardt",
    "labels": [
      "area-System.Text.Json",
      "size-reduction"
    ],
    "createdAt": "2020-07-01T23:51:56Z",
    "body": "When trimming a Blazor WASM app, the last usage of Reflection.Emit (after fixing #38678) is coming from System.Text.Json.Serialization.JsonSerializerOptions:\r\n\r\nhttps://github.com/dotnet/runtime/blob/d89772ae2c8ce4f7e0bb7af4891619ff759ee1c0/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/JsonSerializerOptions.cs#L423-L438\r\n\r\nHowever, on Mono WASM, `RuntimeFeature.IsDynamicCodeCompiled` is always false, so using Reflection.Emit is probably a waste, and it brings in a decent amount of code. In my investigations I find it removing ~50KB of IL if we trim this usage of Reflection.Emit.\r\n\r\nWe should change this code to something more like:\r\n\r\n```C#\r\n        internal MemberAccessor MemberAccessorStrategy\r\n        {\r\n            get\r\n            {\r\n                if (_memberAccessorStrategy == null)\r\n                {\r\n#if NETFRAMEWORK || NETCOREAPP\r\n                    if (RuntimeFeature.IsDynamicCodeCompiled)\r\n                    {\r\n                        _memberAccessorStrategy = new ReflectionEmitMemberAccessor();\r\n                    }\r\n                    else\r\n                    {\r\n                        _memberAccessorStrategy = new ReflectionMemberAccessor();\r\n                    }\r\n#else\r\n                    _memberAccessorStrategy = new ReflectionMemberAccessor();\r\n#endif\r\n                }\r\n\r\n                return _memberAccessorStrategy;\r\n            }\r\n        }\r\n```\r\n\r\nWith changing the code to the above, on a default template Blazor WASM app, I am seeing size savings of:\r\n\r\n| Build          | Size     |\r\n|----------------|----------|\r\n| master         | 3,366,912 bytes |\r\n| #38729             | 3,039,232 bytes |\r\n| #38729 + this change   | 2,990,080 bytes |\r\n\r\nSo almost a 50 KB savings by allowing the removing all usages of System.Reflection.Emit.\r\n\r\ncc @steveharter @layomia @vitek-karas @marek-safar ",
    "number": 38693,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "THUMBS_UP",
          "createdAt": "2020-07-03T12:28:24Z",
          "user": "MichalStrehovsky"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2020-07-06T15:21:44Z",
          "user": "steveharter"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-05-11T23:35:41Z",
          "user": "davidfowl"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-05-20T19:56:46Z",
          "user": "ericstj"
        }
      ],
      "totalCount": 4,
      "endCursor": "Y3Vyc29yOnYyOpHOBrpshg=="
    },
    "updatedAt": "2022-09-02T15:45:59Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": "steveharter",
          "body": "FWIW we [previously used](https://github.com/dotnet/runtime/commit/5b083defd67e1ddd124478327954c1f7431f447e#diff-06cd88e9e618b6da44f0f2d91397d85bR327-R334) `RuntimeFeature.IsDynamicCodeSupported` but that API requires netstandard 2.1, and we only had support for 2.0 in STJ.dll and due to the switch to netcoreapp (instead of netstandard) it was decided not worth the hit of a larger package just for this.\r\n\r\nBut using an ifdef branch for netcoreapp that checks RuntimeFeature should work great.",
          "createdAt": "2020-07-06T15:27:15Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2020-07-06T15:27:15Z",
          "id": "MDEyOklzc3VlQ29tbWVudDY1NDMwNjYxMg=="
        },
        {
          "author": "eerhardt",
          "body": "I ran the attached JSON perf application with and without this change.\r\n\r\n[Program (1).zip](https://github.com/dotnet/runtime/files/4880733/Program.1.zip)\r\n\r\n### 5.0.0-preview.8.20354.5\r\n| serialize      | deserialize | writer   |\r\n|----------------|-------------|----------|\r\n| Serialization took 1509 ms | Deserialization took 4619 ms | Writer took 1252 ms |\r\n| Serialization took 1548 ms | Deserialization took 4690 ms | Writer took 1272 ms |\r\n| Serialization took 1537 ms | Deserialization took 4743 ms | Writer took 1224 ms |\r\n\r\n### Proposed change\r\n| serialize      | deserialize | writer   |\r\n|----------------|-------------|----------|\r\n| Serialization took 1843 ms | Deserialization took 5391 ms| Writer took 1196 ms |\r\n| Serialization took 1832 ms | Deserialization took 5364 ms| Writer took 1196 ms |\r\n| Serialization took 1847 ms | Deserialization took 5338 ms| Writer took 1185 ms |\r\n\r\nSo it is ~15-20% slower to use the Reflection based strategy after everything is warmed up. (Note this is explicitly not testing the time it takes to emit IL during warmup.)",
          "createdAt": "2020-07-06T18:56:58Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2020-07-06T18:56:58Z",
          "id": "MDEyOklzc3VlQ29tbWVudDY1NDQwOTUzNA=="
        },
        {
          "author": "eerhardt",
          "body": "Since the performance tradeoff of taking this change isn't necessarily a net-win, we won't be making this change in 5.0. Moving to 6.0.",
          "createdAt": "2020-07-30T19:55:11Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2020-07-30T19:55:11Z",
          "id": "MDEyOklzc3VlQ29tbWVudDY2NjY0NzIxNA=="
        },
        {
          "author": "eerhardt",
          "body": "With the advent of the JSON source generator, we can solve the ~15-20% slower to use Reflection based strategy issue above by telling places that need fast JSON Serialization to use the source generator.\r\n\r\nWith that in mind, I created a prototype of introducing a feature switch in System.Text.Json to use the `ReflectionMemberAccessor` in order to allow for trimming the Ref.Emit code. See the prototype here:\r\n\r\nhttps://github.com/dotnet/runtime/commit/59c60c6392585dd92b200a13ca55e14d8793a684\r\n\r\nThis allows for the following size savings (.br compressed):\r\n\r\n**Before**: 2,644,974 bytes\r\n**After**: 2,628,106 bytes (with new feature switch set)\r\n\r\nSo roughly **16.5KB** .br compressed size savings.\r\n\r\nThis could be an alternative approach to allow for the Ref.Emit code to be trimmed in a default Blazor WASM app, even if not all the places that use JSON Serialization use the source generator.",
          "createdAt": "2021-05-11T23:25:44Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-05-12T01:53:14Z",
                "user": "layomia"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-05-17T15:27:36Z",
                "user": "SamMonoRT"
              }
            ],
            "totalCount": 2,
            "endCursor": "Y3Vyc29yOnYyOpHOBrGO-g=="
          },
          "updatedAt": "2021-05-11T23:25:44Z",
          "id": "MDEyOklzc3VlQ29tbWVudDgzOTI3ODE2NA=="
        },
        {
          "author": "eerhardt",
          "body": "Now that the `microsoft-net-sdk-blazorwebassembly-aot` workload is functional, I was able to retest trimming out the Reflection.Emit code along with re-linking the `dotnet.wasm` assembly (which also trims the native Reflection.Emit code).\r\n\r\nUsing the rough numbers of summing all the *.br files in the publish directory, here are the results I am seeing:\r\n\r\n|                       |  No Relinking | Relinking |\r\n|-----------------------|---------------|-----------|\r\n| Include Ref.Emit code | 2,537 KB      | 2,509 KB  |\r\n| Trim Ref.Emit code    | 2,519 KB      | 2,484 KB  |\r\n\r\nSo paired with the re-linking feature, if we can trim away the Reflection.Emit code, it would trim 25 KB compressed. And if you aren’t re-linking we’d save the estimated ~18 KBs, as above.\r\n\r\nHowever, it still comes at a tradeoff for throughput. I re-ran the above `Program (1).zip` application using the latest .NET 6 bits with this feature switch, and I'm seeing the following results:\r\n\r\n### Ref.Emit + re-linking:\r\n\r\n|           | serialize | deserialize | writer |\r\n|-----------|-----------|-------------|--------|\r\n|           | 605 ms    | 894 ms      | 501 ms |\r\n|           | 577 ms    | 842 ms      | 424 ms |\r\n|           | 570 ms    | 833 ms      | 422 ms |\r\n|           | 543 ms    | 803 ms      | 402 ms |\r\n|           | 586 ms    | 826 ms      | 457 ms |\r\n| Averages: | 576.2     | 839.6       | 441.2  |\r\n\r\n### Trim Ref.Emit + re-linking:\r\n\r\n|           | serialize | deserialize | writer |\r\n|-----------|-----------|-------------|--------|\r\n|           | 845 ms    | 1463 ms     | 414 ms |\r\n|           | 859 ms    | 1453 ms     | 406 ms |\r\n|           | 872 ms    | 1493 ms     | 411 ms |\r\n|           | 820 ms    | 1414 ms     | 396 ms |\r\n|           | 866 ms    | 1432 ms     | 386 ms |\r\n| Averages: | 852.4     | 1451        | 402.6  |\r\n\r\nAs you can see, the performance of Json serialization has gotten drastically better from my original numbers (I may have been on a different machine as well). However, the difference between using Ref.Emit vs. Reflection has gotten wider. For \"serialize\" - ~48% worse, and for deserialize - ~73% worse.\r\n\r\nFor ahead-of-time (AOT) compilation, here are the differences:\r\n\r\nSize difference, the only file that changes when using AOT is the `dotnet.wasm` file. \r\n\r\n|                       |  dotnet.wasm.br |\r\n|-----------------------|---------------|\r\n| Include Ref.Emit code | 2,938 KB      |\r\n| Trim Ref.Emit code    | 2,876 KB      |\r\n\r\nSo a ~62 KB .br compressed size savings.\r\n\r\nThe throughput ratio between Ref.Emit vs Reflection is about the same on AOT as it is on non-AOT:\r\n\r\n### Ref.Emit + AOT:\r\n\r\n|           | serialize | deserialize | writer |\r\n|-----------|-----------|-------------|--------|\r\n|           | 443 ms    | 457 ms      | 200 ms |\r\n|           | 421 ms    | 476 ms      | 178 ms |\r\n|           | 432 ms    | 452 ms      | 182 ms |\r\n|           | 418 ms    | 454 ms      | 180 ms |\r\n|           | 440 ms    | 457 ms      | 179 ms |\r\n| Averages: | 430.8     | 459.2       | 183.8  |\r\n\r\n### Trim Ref.Emit + AOT:\r\n\r\n|           | serialize | deserialize | writer |\r\n|-----------|-----------|-------------|--------|\r\n|           | 635 ms    | 825 ms      | 179 ms |\r\n|           | 627 ms    | 815 ms      | 202 ms |\r\n|           | 632 ms    | 783 ms      | 182 ms |\r\n|           | 636 ms    | 825 ms      | 182 ms |\r\n|           | 598 ms    | 766 ms      | 181 ms |\r\n| Averages: | 623.3     | 802.8       | 185.2  |",
          "createdAt": "2021-05-17T23:17:01Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-05-17T23:17:01Z",
          "id": "MDEyOklzc3VlQ29tbWVudDg0MjcwNDI0NA=="
        },
        {
          "author": "marek-safar",
          "body": "@radekdoulik @BrzVlad could you work with Eric to investigate why no ref-emit AOT case is noticeably slower and if the code is fully AOTed or not.",
          "createdAt": "2021-05-18T06:34:35Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-05-18T06:36:28Z",
          "id": "MDEyOklzc3VlQ29tbWVudDg0Mjg4OTc0NA=="
        },
        {
          "author": "radekdoulik",
          "body": "I tried to replicate it locally with browser-bench sample and I see similar results (interp/amd64/chrome):\r\n\r\n| measurement | main | issue 38693 |\r\n|-:|-:|-:|\r\n|   Json, non-ASCII text serialize |     7.8816ms |     9.3470ms |\r\n| Json, non-ASCII text deserialize |    11.9814ms |    14.3489ms |\r\n|            Json, small serialize |     0.2291ms |     0.3512ms |\r\n|          Json, small deserialize |     0.3620ms |     0.5877ms |\r\n|            Json, large serialize |    67.3947ms |   102.0784ms |\r\n|          Json, large deserialize |   100.0189ms |   162.3636ms |\r\n",
          "createdAt": "2021-06-14T14:41:20Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-06-14T14:41:20Z",
          "id": "MDEyOklzc3VlQ29tbWVudDg2MDc0MDExMg=="
        },
        {
          "author": "marek-safar",
          "body": "I think that still does not explain what is causing AOT SRE free version to be about 50% slower than the SRE version which is mostly interpreted.",
          "createdAt": "2021-06-14T16:04:51Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-06-14T16:04:51Z",
          "id": "MDEyOklzc3VlQ29tbWVudDg2MDgwNDQyOA=="
        },
        {
          "author": "radekdoulik",
          "body": "> I think that still does not explain what is causing AOT SRE free version to be about 50% slower than the SRE version which is mostly interpreted.\r\n\r\nIndeed, I started looking into that and wanted to share that I can replicate it too, with different simple app without Blazer involved.",
          "createdAt": "2021-06-14T17:04:57Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-06-14T17:04:57Z",
          "id": "MDEyOklzc3VlQ29tbWVudDg2MDg0NDA3OA=="
        },
        {
          "author": "eerhardt",
          "body": "Moving to Future. I don't think this work can happen until the runtime performance impact is decreased. With the current numbers, the runtime performance impact is too great for the small size reduction.",
          "createdAt": "2021-07-30T16:11:52Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-07-30T16:11:52Z",
          "id": "IC_kwDODI9FZc41DENS"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Appears to have been fixed by #54027.",
          "createdAt": "2022-09-02T15:38:52Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-09-02T15:38:52Z",
          "id": "IC_kwDODI9FZc5JpnYL"
        },
        {
          "author": "eerhardt",
          "body": "There are 2 different switches here:\r\n\r\n* IsDynamicCodeSupported - can I IL Emit at all?\r\n* IsDynamicCodeCompiled - If I can, will the code I emit be compiled to assembly-level code?\r\n\r\n#54027 allows JsonSerializer work at all when you can't IL Emit code. This issue is to track the 2nd case, when you can IL Emit code, but it get interpreted.",
          "createdAt": "2022-09-02T15:45:59Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-09-02T16:45:38Z",
                "user": "eiriktsarpalis"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOCrmDlw=="
          },
          "updatedAt": "2022-09-02T15:45:59Z",
          "id": "IC_kwDODI9FZc5JppKQ"
        }
      ],
      "totalCount": 12,
      "endCursor": "Y3Vyc29yOnYyOpHOSaaSkA=="
    },
    "url": "https://github.com/dotnet/runtime/issues/38693",
    "title": "JsonSerializerOptions.MemberAccessorStrategy shouldn't use Reflection.Emit when IsDynamicCodeCompiled is false"
  },
  {
    "author": "meziantou",
    "labels": [
      "enhancement",
      "area-System.Text.Json"
    ],
    "createdAt": "2020-07-04T23:44:00Z",
    "body": "## Description\r\n\r\nWhen migrating to S.T.Json from Newtonsoft.Json I got an error when serializing a `CultureInfo`.\r\n\r\n````c#\r\nJsonSerializer.Serialize(CultureInfo.GetCultureInfo(\"en-US\"));\r\n````\r\n\r\nThis is ok that the json serializer doesn't handle every possible type. In this case I wrote a custom JsonConverter and it works well.\r\n\r\nHowever, it tooks me a few minutes to find the problematic property in my model as the message/call stack doesn't include any useful data.\r\n\r\n````\r\nUnhandled exception. System.Text.Json.JsonException: A possible object cycle was detected. This can either be due to a cycle or if the object depth is larger than the maximum allowed depth of 64. Consider using ReferenceHandler.Preserve on JsonSerializerOptions to support cycles.\r\n   at System.Text.Json.ThrowHelper.ThrowJsonException_SerializerCycleDetected(Int32 maxDepth)\r\n   at System.Text.Json.Serialization.JsonConverter`1.TryWrite(Utf8JsonWriter writer, T value, JsonSerializerOptions options, WriteStack& state)\r\n   at System.Text.Json.JsonPropertyInfo`1.GetMemberAndWriteJson(Object obj, WriteStack& state, Utf8JsonWriter writer)\r\n   at System.Text.Json.Serialization.Converters.ObjectDefaultConverter`1.OnTryWrite(Utf8JsonWriter writer, T value, JsonSerializerOptions options, WriteStack& state)\r\n   at System.Text.Json.Serialization.JsonConverter`1.TryWrite(Utf8JsonWriter writer, T value, JsonSerializerOptions options, WriteStack& state)\r\n...\r\n   at System.Text.Json.JsonPropertyInfo`1.GetMemberAndWriteJson(Object obj, WriteStack& state, Utf8JsonWriter writer)\r\n   at System.Text.Json.Serialization.Converters.ObjectDefaultConverter`1.OnTryWrite(Utf8JsonWriter writer, T value, JsonSerializerOptions options, WriteStack& state)\r\n   at System.Text.Json.Serialization.JsonConverter`1.TryWrite(Utf8JsonWriter writer, T value, JsonSerializerOptions options, WriteStack& state)\r\n   at System.Text.Json.Serialization.JsonConverter`1.WriteCore(Utf8JsonWriter writer, T value, JsonSerializerOptions options, WriteStack& state)\r\n   at System.Text.Json.JsonSerializer.WriteCore[TValue](JsonConverter jsonConverter, Utf8JsonWriter writer, TValue value, JsonSerializerOptions options, WriteStack& state)\r\n   at System.Text.Json.JsonSerializer.WriteCore[TValue](Utf8JsonWriter writer, TValue value, Type inputType, JsonSerializerOptions options)\r\n   at System.Text.Json.JsonSerializer.Serialize[TValue](TValue value, Type inputType, JsonSerializerOptions options)\r\n   at System.Text.Json.JsonSerializer.Serialize[TValue](TValue value, JsonSerializerOptions options)\r\n   at ConsoleApp6.Program.Main(String[] args) in C:\\Users\\user\\source\\repos\\ConsoleApp6\\ConsoleApp6\\Program.cs:line 12\r\n````\r\n\r\nI think this could be useful to add the name of the property and its type when this exception is thrown. Maybe it's even possible to get the full property path. In my case, knowing that the problematic property is \"Parent\" of type \"CultureInfo\" would have helped.\r\n\r\nBTW, S.T.Json could also support serializing CultureInfo out of the box but this is another issue.\r\n\r\n### Configuration\r\n\r\n````\r\n<PackageReference Include=\"System.Text.Json\" Version=\"5.0.0-preview.6.20305.6\" />\r\n````\r\n",
    "number": 38786,
    "reactions": {
      "hasNextPage": false,
      "nodes": [],
      "totalCount": 0,
      "endCursor": null
    },
    "updatedAt": "2023-02-18T20:59:18Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": "layomia",
          "body": "cc @Jozkee ",
          "createdAt": "2020-07-06T16:03:16Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2020-07-06T16:03:16Z",
          "id": "MDEyOklzc3VlQ29tbWVudDY1NDMyNjMxNQ=="
        },
        {
          "author": "jozkee",
          "body": "> Maybe it's even possible to get the full property path.\r\n\r\n@meziantou can you try looking at `JsonException.Path` property, is it of any help?\r\nHow did you end up solving this issue? Did you try the suggested workaround of setting `ReferenceHandler.Preserve`?",
          "createdAt": "2020-07-06T22:06:19Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2020-07-06T22:06:19Z",
          "id": "MDEyOklzc3VlQ29tbWVudDY1NDQ4OTEwOA=="
        },
        {
          "author": "meziantou",
          "body": "> can you try looking at JsonException.Path property, is it of any help?\r\n\r\nIndeed, `JsonException.Path` contains the full path which is very nice:\r\n\r\n```\r\n$.Parent.Parent.Parent.Parent.Parent.Parent.Parent.Parent.Parent.Parent.Parent.Parent.Parent.Parent.Parent.Parent.Parent.Parent.Parent.Parent.Parent.Parent.Parent.Parent.Parent.Parent.Parent.Parent.Parent.Parent.Parent.Parent.Parent.Parent.Parent.Parent.Parent.Parent.Parent.Parent.Parent.Parent.Parent.Parent.Parent.Parent.Parent.Parent.Parent.Parent.Parent.Parent.Parent.Parent.Parent.Parent.Parent.Parent.Parent.Parent.Parent.Parent.Parent.Parent\r\n```\r\n\r\nMaybe it should be part of the exception message, so it would be displayed in `JsonException.ToString()`.\r\n\r\n> How did you end up solving this issue?\r\n\r\nI use a custom JsonConverter for CultureInfo. It uses `CultureInfo.Name` when serializing and use `CultureInfo.Get()` when deserializing.\r\n\r\n> Did you try the suggested workaround of setting ReferenceHandler.Preserve?\r\n\r\nI don't think this is a good workaround here. Even if that _work_ for serialization, I don't think it will correctly instantiate the CultureInfo when deserializing.",
          "createdAt": "2020-07-06T22:46:58Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2020-07-06T22:49:55Z",
                "user": "jozkee"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-07-01T09:00:34Z",
                "user": "BjornDeRijcke"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-08-28T14:25:28Z",
                "user": "raffaeler"
              }
            ],
            "totalCount": 3,
            "endCursor": "Y3Vyc29yOnYyOpHOB4KK7Q=="
          },
          "updatedAt": "2020-07-06T22:46:58Z",
          "id": "MDEyOklzc3VlQ29tbWVudDY1NDUwMTU2Ng=="
        },
        {
          "author": "jozkee",
          "body": "I think including the full JSON path here could be too cumbersome, I was thinking that we could append the last property name before throwing but that would not work well for reference loops in arrays (e.g: `List<object>` which has an element that points to itself).\r\n\r\n> I use a custom JsonConverter for CultureInfo.\r\n\r\n@meziantou that's a nice workaround.",
          "createdAt": "2020-07-06T23:01:15Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2020-07-06T23:01:15Z",
          "id": "MDEyOklzc3VlQ29tbWVudDY1NDUwNTQ3MA=="
        },
        {
          "author": "meziantou",
          "body": "Adding the full path could be useful. In this case the `Parent` property is not part of my code (it is a property of `System.Globalization.CultureInfo`), so just knowing this name may not be that useful for debugging. \r\nThe full path would be useful to know the actual property to fix but I understand this could be cumbersome. Maybe the path could be trimmed to only keep the path before the cycle (e.g. `$.A.B.C.Parent`).\r\n\r\nAnother idea is to change the message to indicate that the `Path` property exists and it could be useful for debugging.\r\n",
          "createdAt": "2020-07-06T23:18:50Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2020-07-19T21:09:53Z",
                "user": "cmanoliu"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-08-28T14:25:46Z",
                "user": "raffaeler"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-10-25T18:08:49Z",
                "user": "eiriktsarpalis"
              }
            ],
            "totalCount": 3,
            "endCursor": "Y3Vyc29yOnYyOpHOB_v4OQ=="
          },
          "updatedAt": "2020-07-06T23:18:50Z",
          "id": "MDEyOklzc3VlQ29tbWVudDY1NDUxMDM0Nw=="
        },
        {
          "author": "jozkee",
          "body": "> Maybe the path could be trimmed to only keep the path before the cycle (e.g. $.A.B.C.Parent).\r\n\r\nThat implies saving a reference of each object in the current object branch and then removing them when we are done with it, that's probably very expensive. The fact about that error message is that we are not detecting a _cycle_, we are just validating that the `MaxDepth` is not exceeded.\r\nhttps://github.com/dotnet/runtime/blob/682141eca64f82207bee39e7edf218a0e14daeeb/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/JsonConverterOfT.cs#L241-L244\r\n\r\nHowever I think maybe we can do something to make the message clearer as you suggests.",
          "createdAt": "2020-07-07T00:39:46Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2020-07-07T00:39:46Z",
          "id": "MDEyOklzc3VlQ29tbWVudDY1NDUzMjYyMQ=="
        },
        {
          "author": "raffaeler",
          "body": "Other execeptions in System.Text.Json already provide the `Path` in the message.\r\nI expected to see that piece of information here as well.\r\nCan't the path eventually be rebuilt in the case of the exception without affecting the general perf?",
          "createdAt": "2021-08-28T19:00:13Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-08-28T19:00:13Z",
          "id": "IC_kwDODI9FZc42GgCR"
        },
        {
          "author": "layomia",
          "body": "May I ask why `CultureInfo` is being serialized in the first place? Seems like one of the types we should [explicitly not support](https://github.com/dotnet/runtime/blob/3f51e1449f78041bd4f213602f2bbfa4af321dde/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/Converters/Value/UnsupportedTypeConverterFactory.cs).\r\n\r\nI think the object-cycle exception message is fine for general use-cases, just that a `NotSupportedException` would be more appropriate when serializing `CultureInfo`.",
          "createdAt": "2022-12-02T16:40:55Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_DOWN",
                "createdAt": "2023-12-13T23:44:27Z",
                "user": "brasky"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHODPhJHQ=="
          },
          "updatedAt": "2022-12-02T16:40:55Z",
          "id": "IC_kwDODI9FZc5Pml9g"
        },
        {
          "author": "meziantou",
          "body": "> May I ask why CultureInfo is being serialized in the first place? Seems like one of the types we should [explicitly not support](https://github.com/dotnet/runtime/blob/3f51e1449f78041bd4f213602f2bbfa4af321dde/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/Converters/Value/UnsupportedTypeConverterFactory.cs).\r\n\r\nI converted a code from Newtonsoft.Json to S.T.Json. Using Newtonsoft.Json, `Console.WriteLine(JsonConvert.SerializeObject(CultureInfo.GetCultureInfo(\"en-US\")));` works and serialize the culture name: `\"en-US\"`",
          "createdAt": "2022-12-02T16:47:18Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-12-02T16:47:18Z",
          "id": "IC_kwDODI9FZc5PmndR"
        },
        {
          "author": "ultimaweapon",
          "body": "@layomia may I ask what is the reason why `CultureInfo` should not serialized?",
          "createdAt": "2023-01-19T02:25:07Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-01-19T02:25:07Z",
          "id": "IC_kwDODI9FZc5TOsUb"
        },
        {
          "author": "MaxAtoms",
          "body": "The path has been added to the exception text in the meantime.\r\nIt was added with #56903, if I am not mistaken: [`ThrowJsonException_SerializerCycleDetected`](https://github.com/dotnet/runtime/pull/56903/files#diff-c66b1e2fa7e56fa69d79ef94b550941ddcb6519a97e8700b46001a84ce2ccb32R88). From my point of view, this issue can be closed.",
          "createdAt": "2023-02-18T20:59:18Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-02-18T20:59:18Z",
          "id": "IC_kwDODI9FZc5VlBRM"
        }
      ],
      "totalCount": 11,
      "endCursor": "Y3Vyc29yOnYyOpHOVZQUTA=="
    },
    "url": "https://github.com/dotnet/runtime/issues/38786",
    "title": "System.Text.Json object cycle error message could be better"
  },
  {
    "author": "albracko",
    "labels": [
      "api-needs-work",
      "area-System.Text.Json"
    ],
    "createdAt": "2020-07-27T08:30:17Z",
    "body": "I'm referring to this issue https://github.com/dotnet/runtime/issues/30746 that was closed with limit of 125MB staying fixed opposed to being configurable.\r\n\r\nIt was argued that there would be no common cases hitting the 125MB limit. Such cases probably never occur on UI but there are such cases...for example if you have a REST API that returns JSON document which has some document encoded as a base64 in a single field or it has another JSON document nested inside a single field as a string which is used for digital signing and verification of it. \r\nAnd i have such a case where i'm digitally signing some JSON document and the creating a new JSON where the payload field (contains my JSON document) is larger than the 125MB limit.",
    "number": 39953,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-08-27T17:42:35Z",
          "user": "thracx"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-09-26T07:56:24Z",
          "user": "GSPP"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-09-02T16:10:08Z",
          "user": "Viir"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-03-22T15:49:18Z",
          "user": "THammond9"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-06-23T16:34:38Z",
          "user": "icnocop"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-09-30T07:28:27Z",
          "user": "bramom"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-10-22T10:47:35Z",
          "user": "neman"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-10-26T09:25:21Z",
          "user": "ricred"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-11-16T20:52:51Z",
          "user": "peteygao"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-11-23T15:52:40Z",
          "user": "JanKotschenreuther"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-01-19T13:30:17Z",
          "user": "Luk164"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-01-22T23:58:18Z",
          "user": "CEbbinghaus"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-06-04T15:10:12Z",
          "user": "shargon"
        }
      ],
      "totalCount": 13,
      "endCursor": "Y3Vyc29yOnYyOpHODDRStw=="
    },
    "updatedAt": "2025-06-04T15:19:56Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": "Dotnet-GitSync-Bot",
          "body": "I couldn't figure out the best area label to add to this issue. If you have write-permissions please help me learn by adding exactly one [area label](https://github.com/dotnet/runtime/blob/master/docs/area-owners.md).",
          "createdAt": "2020-07-27T08:30:20Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2020-07-27T08:30:20Z",
          "id": "MDEyOklzc3VlQ29tbWVudDY2NDIwMDEyMA=="
        },
        {
          "author": "thracx",
          "body": "Why set arbitrary limitations that cannot be adjusted, when all use-cases can be accommodated by having default values that cannot be overwritten in those use-cases?  `System.Text.Json` is designed to be standards compliant, and the standard does not specify such limits - from [rfc8259#section-9](https://datatracker.ietf.org/doc/html/rfc8259#section-9), implementations may set limits, but no limiting values are suggested or recommended.  This only adds a limitation to this implementation and this is not clearly specified in the documentation.\r\n\r\nFor my use-case, the [migration guide](https://docs.microsoft.com/en-us/dotnet/standard/serialization/system-text-json-migrate-from-newtonsoft-how-to) did not specify these limitations and I am only learning about this hard-stop issue late during testing after having long completed the development.\r\n\r\nI suggest adding options similar to `JsonSerializerOptions.MaxDepth` to replace or override the [constants](https://github.com/dotnet/corefx/blob/master/src/System.Text.Json/src/System/Text/Json/JsonConstants.cs) such as `JsonConstants.MaxCharacterTokenSize`, `JsonConstants.MaxBase64ValueTokenSize,` etc.\r\n\r\nIf support for larger values is not added, then the [second suggestion](https://github.com/dotnet/docs/issues/25839#issue-981489467) is to update all the documentation so that these limitations are clear and upfront, so others can know in advance if they need to stay with `JavaScriptSerializer`/[NewtonSoft.Json](https://www.newtonsoft.com/json)/etc.",
          "createdAt": "2021-08-27T18:20:07Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-08-27T18:47:29Z",
                "user": "am11"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-10-05T19:21:56Z",
                "user": "Mrxx99"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-12-16T08:21:38Z",
                "user": "t00"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-08-09T04:46:16Z",
                "user": "gbtb"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-10-26T09:25:48Z",
                "user": "ricred"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-01-31T07:31:07Z",
                "user": "Take-A-Byte"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-06-14T10:27:56Z",
                "user": "jcoolsen"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-10-08T14:53:01Z",
                "user": "nihaal-ION"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-06-04T15:15:02Z",
                "user": "shargon"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-06-18T09:37:47Z",
                "user": "scharnyw"
              }
            ],
            "totalCount": 10,
            "endCursor": "Y3Vyc29yOnYyOpHOEXB-hg=="
          },
          "updatedAt": "2021-08-27T18:24:32Z",
          "id": "IC_kwDODI9FZc42FaTX"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Agree that this should likely be made configurable.",
          "createdAt": "2021-10-15T19:49:05Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-10-15T19:49:05Z",
          "id": "IC_kwDODI9FZc44TcBa"
        },
        {
          "author": null,
          "body": "This issue has been marked with the `api-needs-work` label. This may suggest that the proposal requires further refinement before it can be considered for API review. Please refer to our [API review guidelines](https://github.com/dotnet/runtime/blob/main/docs/project/api-review-process.md) for a detailed description of the process. \n\nWhen ready to submit an amended proposal, please ensure that the original post in this issue has been updated, following the API proposal template and examples as provided in the guidelines.",
          "createdAt": "2021-10-15T19:49:27Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-10-15T19:49:27Z",
          "id": "IC_kwDODI9FZc44TcEh"
        },
        {
          "author": "minhtuanit",
          "body": "Any update with this issue?",
          "createdAt": "2022-01-28T07:05:34Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "EYES",
                "createdAt": "2022-01-28T14:03:33Z",
                "user": "thracx"
              },
              {
                "content": "EYES",
                "createdAt": "2022-01-28T20:57:17Z",
                "user": "JonathanHess"
              },
              {
                "content": "EYES",
                "createdAt": "2022-02-07T02:24:23Z",
                "user": "minhtuanit"
              },
              {
                "content": "EYES",
                "createdAt": "2022-02-11T17:59:02Z",
                "user": "5sdev"
              },
              {
                "content": "EYES",
                "createdAt": "2022-02-14T10:40:38Z",
                "user": "soulgaard"
              },
              {
                "content": "EYES",
                "createdAt": "2022-03-08T17:32:59Z",
                "user": "inf9144"
              },
              {
                "content": "EYES",
                "createdAt": "2022-05-21T14:52:01Z",
                "user": "Digbigpig"
              },
              {
                "content": "EYES",
                "createdAt": "2025-06-04T15:34:18Z",
                "user": "shargon"
              }
            ],
            "totalCount": 8,
            "endCursor": "Y3Vyc29yOnYyOpHOEVU2Qw=="
          },
          "updatedAt": "2022-01-28T07:05:34Z",
          "id": "IC_kwDODI9FZc49CB6E"
        },
        {
          "author": "inf9144",
          "body": "This hardcoded thing just crashed my production site. Fix ahead or do i need a new serializer?",
          "createdAt": "2022-03-08T17:27:55Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-05-10T14:21:38Z",
                "user": "erdihu"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-06-04T15:34:27Z",
                "user": "shargon"
              }
            ],
            "totalCount": 2,
            "endCursor": "Y3Vyc29yOnYyOpHOEVU2Xg=="
          },
          "updatedAt": "2022-03-08T17:27:55Z",
          "id": "IC_kwDODI9FZc4_TTEf"
        },
        {
          "author": "erdihu",
          "body": "Is the only solution to this issue is to go back to Newtonsoft? I really do not want to lose all the perks of using System.Text.Json but I also need to support large JSON data.",
          "createdAt": "2022-05-10T14:24:55Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-06-14T10:30:40Z",
                "user": "jcoolsen"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-06-04T15:34:36Z",
                "user": "shargon"
              }
            ],
            "totalCount": 2,
            "endCursor": "Y3Vyc29yOnYyOpHOEVU2fw=="
          },
          "updatedAt": "2022-05-10T14:24:55Z",
          "id": "IC_kwDODI9FZc5C54L7"
        },
        {
          "author": "albracko",
          "body": "Yeah, sadly for the time being, the only solution is to use Newtonsoft for big JSON fields",
          "createdAt": "2022-05-11T04:57:19Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-05-11T04:57:19Z",
          "id": "IC_kwDODI9FZc5C8ndA"
        },
        {
          "author": "kasperk81",
          "body": "> Agree that this should likely be made configurable.\r\n\r\ninstead of making it configurable, how about remove the limit? let it scale with system's available resources and let the stack overflow in worse case.",
          "createdAt": "2022-05-11T08:51:05Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-05-11T11:23:58Z",
                "user": "inf9144"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-10-12T18:11:31Z",
                "user": "osexpert"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-10-26T09:26:35Z",
                "user": "ricred"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-11-16T20:54:33Z",
                "user": "peteygao"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-06-14T10:30:53Z",
                "user": "jcoolsen"
              }
            ],
            "totalCount": 5,
            "endCursor": "Y3Vyc29yOnYyOpHODlq7TA=="
          },
          "updatedAt": "2022-05-11T08:51:05Z",
          "id": "IC_kwDODI9FZc5C9XU5"
        },
        {
          "author": "albracko",
          "body": "i'm for any of those 2 options as long as it doesn't have the hard limit",
          "createdAt": "2022-05-11T08:56:28Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-05-11T11:24:01Z",
                "user": "inf9144"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOCcQdDg=="
          },
          "updatedAt": "2022-05-11T08:56:28Z",
          "id": "IC_kwDODI9FZc5C9Y5P"
        },
        {
          "author": "Luk164",
          "body": "Just hit the issue as well, wanted to serialize a dataset and it was just over the hard limit.",
          "createdAt": "2022-08-10T07:36:31Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-08-10T07:36:39Z",
          "id": "IC_kwDODI9FZc5II2qt"
        },
        {
          "author": "eiriktsarpalis",
          "body": "This discussion https://github.com/dotnet/corefx/pull/40792/files#r320546088 might provide insight into why the limits were introduced originally and why they might actually not be necessary.",
          "createdAt": "2022-09-02T13:36:08Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-09-02T16:09:56Z",
                "user": "Viir"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-09-02T18:54:10Z",
                "user": "thracx"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-09-05T09:11:23Z",
                "user": "Luk164"
              }
            ],
            "totalCount": 3,
            "endCursor": "Y3Vyc29yOnYyOpHOCrqHUg=="
          },
          "updatedAt": "2022-09-02T13:36:08Z",
          "id": "IC_kwDODI9FZc5JpHgD"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Related issue: #61089",
          "createdAt": "2022-09-02T16:41:13Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-09-02T18:54:46Z",
                "user": "thracx"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOCrmamA=="
          },
          "updatedAt": "2022-09-02T16:41:13Z",
          "id": "IC_kwDODI9FZc5Jp2p9"
        },
        {
          "author": "osexpert",
          "body": " \"640K ought to be enough for anybody.\"",
          "createdAt": "2022-10-12T18:12:42Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "LAUGH",
                "createdAt": "2023-06-05T07:37:32Z",
                "user": "scharnyw"
              },
              {
                "content": "LAUGH",
                "createdAt": "2023-10-13T03:25:51Z",
                "user": "Dx-hualuo"
              },
              {
                "content": "LAUGH",
                "createdAt": "2023-11-16T20:55:02Z",
                "user": "peteygao"
              },
              {
                "content": "LAUGH",
                "createdAt": "2024-01-19T12:02:53Z",
                "user": "sxotney"
              },
              {
                "content": "LAUGH",
                "createdAt": "2024-01-19T13:31:51Z",
                "user": "Luk164"
              },
              {
                "content": "LAUGH",
                "createdAt": "2024-06-14T10:35:38Z",
                "user": "jcoolsen"
              },
              {
                "content": "LAUGH",
                "createdAt": "2025-04-09T13:30:31Z",
                "user": "Amwins-Bass-Guy"
              }
            ],
            "totalCount": 7,
            "endCursor": "Y3Vyc29yOnYyOpHOENi4-A=="
          },
          "updatedAt": "2022-10-12T18:12:42Z",
          "id": "IC_kwDODI9FZc5MFrXH"
        },
        {
          "author": "albracko",
          "body": "Sorry, but if YOU don't need it that doesn't automatically mean everybody else doesn't need it.\r\nYOU is not ANYBODY/EVERYBODY ;) ",
          "createdAt": "2022-10-13T05:06:43Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-11-23T16:24:27Z",
                "user": "Luk164"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-03-11T05:01:28Z",
                "user": "cct-kishi-daisuke"
              }
            ],
            "totalCount": 2,
            "endCursor": "Y3Vyc29yOnYyOpHODaDxMw=="
          },
          "updatedAt": "2022-10-13T05:06:43Z",
          "id": "IC_kwDODI9FZc5MHglF"
        },
        {
          "author": "krwq",
          "body": "Would any of these two help here?\r\n- https://github.com/dotnet/runtime/issues/78159\r\n- https://github.com/dotnet/runtime/issues/67337\r\n",
          "createdAt": "2022-11-23T13:41:01Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-11-23T13:41:01Z",
          "id": "IC_kwDODI9FZc5O-y6Z"
        },
        {
          "author": "albracko",
          "body": "None of those would help in my case since they are both talking about streaming. I on the other had need to serialize the object into a JSON string which i also have to store. \r\nIf it were just a case of returning this JSON through REST API, then yeah, those 2 issues that are talking about streaming would help.",
          "createdAt": "2022-12-23T06:39:45Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-12-23T06:39:45Z",
          "id": "IC_kwDODI9FZc5RR-E4"
        },
        {
          "author": "AlanMacdonald",
          "body": "@stephentoub this is pretty painful. I just got this on a dotnet 6 production system with a background job that processes customer documents that calls out to other internal APIs for some work and uses the httpClient.PostAsJsonAsync method. In this case the customer document was huge and way above average size. You had comments on https://github.com/dotnet/corefx/pull/40792/files#r320546088 that sounded like you were hoping these limits could be removed in a future version.\r\n\r\nIt is very counterintuitive to hit an arbitrary limit in an otherwise enterprise level framework. I will need to look into whether I can change the serializer to NewtonSoft and keep these http client calls the same or change the code to not use them so we can control the serializer or look into alternatives to handle rare cases of extremely large documents.\r\n\r\nIt would be great if the limit here was available memory and not an arbitrary restriction.",
          "createdAt": "2023-04-25T13:04:16Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-04-25T13:04:16Z",
          "id": "IC_kwDODI9FZc5atCk8"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Reopening to track some of the other hardcoded limits such as the following:\r\n\r\nhttps://github.com/dotnet/runtime/blob/39e022d338e3d78c79b938aef8b14201a4546ab6/src/libraries/System.Text.Json/src/System/Text/Json/JsonConstants.cs#L71-L73",
          "createdAt": "2023-05-02T13:27:33Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-05-02T13:28:22Z",
                "user": "stephentoub"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-05-02T17:07:37Z",
                "user": "Viir"
              },
              {
                "content": "HEART",
                "createdAt": "2023-10-20T19:26:27Z",
                "user": "EmanueleBaron"
              }
            ],
            "totalCount": 3,
            "endCursor": "Y3Vyc29yOnYyOpHODKeMng=="
          },
          "updatedAt": "2023-05-02T13:27:33Z",
          "id": "IC_kwDODI9FZc5bSHlZ"
        },
        {
          "author": "EmanueleBaron",
          "body": "Good night!!\r\n\r\nHas the limit on json been removed in the latest version on System.Text.Json?\r\n\r\nI have the problem in my API in production :(",
          "createdAt": "2023-10-20T01:36:17Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-10-20T01:40:38Z",
          "id": "IC_kwDODI9FZc5pnaRF"
        },
        {
          "author": "eiriktsarpalis",
          "body": "If you're asking about the fix in https://github.com/dotnet/runtime/pull/85334, it should be available with .NET 8. You can try it out today using the RC2 NuGet package: https://www.nuget.org/packages/System.Text.Json/8.0.0-rc.2.23479.6",
          "createdAt": "2023-10-20T10:49:14Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-10-20T11:34:23Z",
                "user": "Viir"
              },
              {
                "content": "HEART",
                "createdAt": "2023-10-20T19:26:42Z",
                "user": "EmanueleBaron"
              }
            ],
            "totalCount": 2,
            "endCursor": "Y3Vyc29yOnYyOpHODKeMtA=="
          },
          "updatedAt": "2023-10-20T10:49:14Z",
          "id": "IC_kwDODI9FZc5ppnWO"
        },
        {
          "author": "sxotney",
          "body": "I'm not sure if it's resolved or I'm missing something. I came across this problem in .NET 8.0 GA. My use case being users of our systems wish to download a csv format of their data from our Blazor based reporting tool. These data downloads could easily stretch to over 125mb\r\n\r\nI send a base64 string representation of the csv to the JSRuntime and a download is then triggered via a javascript call. It's a neat solution that I'd prefer to keep and can't think of any workarounds due to the JSRuntime dependency.\r\n",
          "createdAt": "2024-01-19T12:20:51Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-01-19T12:20:51Z",
          "id": "IC_kwDODI9FZc5xRJF8"
        },
        {
          "author": "Luk164",
          "body": "> I'm not sure if it's resolved or I'm missing something. I came across this problem in .NET 8.0 GA. My use case being users of our systems wish to download a csv format of their data from our Blazor based reporting tool. These data downloads could easily stretch to over 125mb\n> \n> I send a base64 string representation of the csv to the JSRuntime and a download is then triggered via a javascript call. It's a neat solution that I'd prefer to keep and can't think of any workarounds due to the JSRuntime dependency.\n> \n\nHonestly for that case it might be better to instead generate a file in multiple steps and download that, this issue has been with us for way too long to wait for it to get resolved",
          "createdAt": "2024-01-19T13:29:31Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-01-22T10:45:58Z",
                "user": "sxotney"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHODTi5Xw=="
          },
          "updatedAt": "2024-01-19T13:29:31Z",
          "id": "IC_kwDODI9FZc5xRj_I"
        },
        {
          "author": "rohkhann",
          "body": "What is the defined limit for S for Deserialization of a json string into a json document? I see the max limit be defined as : 166_666_666 for MaxCharacterTokenSize but in the fix in this pr:[#85534](https://github.com/dotnet/runtime/pull/85334) it seems to be Int.MaxValue/4 * 3",
          "createdAt": "2024-06-03T22:50:40Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-06-03T22:50:40Z",
          "id": "IC_kwDODI9FZc5_7UQs"
        },
        {
          "author": "shargon",
          "body": "That my case, this should be configurable ",
          "createdAt": "2025-06-04T15:11:02Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-06-04T15:11:02Z",
          "id": "IC_kwDODI9FZc6vQx4w"
        },
        {
          "author": "shargon",
          "body": "In my case seems that there is a kind of race condition, sometimes it works, and when it start to fail, already fails for the next times, always with the same data",
          "createdAt": "2025-06-04T15:19:54Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-06-04T15:19:54Z",
          "id": "IC_kwDODI9FZc6vQ5Cr"
        }
      ],
      "totalCount": 26,
      "endCursor": "Y3Vyc29yOnYyOpHOr0OQqw=="
    },
    "url": "https://github.com/dotnet/runtime/issues/39953",
    "title": "The JSON value of length n is too large and not supported #2"
  },
  {
    "author": "directhex",
    "labels": [
      "test-failure",
      "area-System.Text.Json",
      "os-windows",
      "runtime-mono"
    ],
    "createdAt": "2020-09-24T14:35:52Z",
    "body": "### Description\r\n\r\nThere may be a performance regression in Mono on Windows (or the test suite has grown and we can no longer finish it in time), as we are now frequently timing out our CI in System.Text.Json.Tests\r\n\r\nSystem.Text.Json.Tests, commit 6c27393: https://helix.dot.net/api/2019-06-17/jobs/2798f22e-585e-4940-a1ba-5eac77edc617/workitems/System.Text.Json.Tests\r\n\r\nSystem.Text.Json.Tests, commit 3d75475: https://helix.dot.net/api/2019-06-17/jobs/fa673262-133f-4f16-baf9-0cc657cb74fc/workitems/System.Text.Json.Tests\r\n\r\nSystem.Text.Json.Tests, commit 0446e4f: https://helix.dot.net/api/2019-06-17/jobs/e803feb0-ce9c-4645-b3a0-25ce0947fc37/workitems/System.Text.Json.Tests\r\n\r\nSystem.Text.Json.Tests, commit 2269b06: https://helix.dot.net/api/2019-06-17/jobs/54f496ef-5f53-4d46-9169-f18480ca70c5/workitems/System.Text.Json.Tests\r\n\r\nSystem.Text.Json.Tests, commit 8933510: https://helix.dot.net/api/2019-06-17/jobs/0653fec5-7b16-4d4c-9741-543f68c35dec/workitems/System.Text.Json.Tests\r\n\r\nSystem.Text.Json.Tests, commit fd09c80: https://helix.dot.net/api/2019-06-17/jobs/257bbeea-72ae-4c05-8f42-6a48a4a555ce/workitems/System.Text.Json.Tests\r\n\r\n<!-- runfo report start -->\r\nRunfo Tracking Issue: [System.Text.Json.Tests Mono Windows Failure](https://runfo.azurewebsites.net/tracking/issue/24)\r\n|Build|Definition|Kind|Run Name|\r\n|---|---|---|---|\r\n\r\n\r\n\r\nBuild Result Summary\r\n|Day Hit Count|Week Hit Count|Month Hit Count|\r\n|---|---|---|\r\n|0|0|0|\r\n\r\n<!-- runfo report end -->\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
    "number": 42677,
    "reactions": {
      "hasNextPage": false,
      "nodes": [],
      "totalCount": 0,
      "endCursor": null
    },
    "updatedAt": "2022-09-02T13:37:33Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": "Jacksondr5",
          "body": "Commit 0446e4f did add a large outer loop test that we estimate added about 8 seconds to the inner loop test execution time ([relevant PR discussion](https://github.com/dotnet/runtime/pull/40601#discussion_r493159641)).  As such, we marked it as outer loop.  I can't verify how much the individual test contributes to the outer loop run since I'm having issues building on my local right now.  It is worth noting that this new test is based off a test with similar structure and behavior, so I'm not sure if this commit really made a difference or not.",
          "createdAt": "2020-09-25T02:13:15Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2020-09-25T02:13:15Z",
          "id": "MDEyOklzc3VlQ29tbWVudDY5ODY4MTIxMA=="
        },
        {
          "author": "jaredpar",
          "body": "runfo query for this failure https://runfo.azurewebsites.net/search/tests/?bq=definition%3Aruntime+started%3A%7E7&tq=System.Text.Json.Tests",
          "createdAt": "2020-09-29T22:36:14Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2020-09-29T22:36:14Z",
          "id": "MDEyOklzc3VlQ29tbWVudDcwMTAyODM4NA=="
        },
        {
          "author": "ViktorHofer",
          "body": "cc @layomia @ericstj @steveharter ",
          "createdAt": "2020-10-01T07:06:26Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2020-10-01T07:06:26Z",
          "id": "MDEyOklzc3VlQ29tbWVudDcwMTkzNDc4Ng=="
        },
        {
          "author": "ViktorHofer",
          "body": "I believe this happening on CoreClr as well: https://github.com/dotnet/runtime/issues/42817",
          "createdAt": "2020-10-01T07:06:49Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2020-10-01T15:19:15Z",
          "id": "MDEyOklzc3VlQ29tbWVudDcwMTkzNTAxMg=="
        },
        {
          "author": "layomia",
          "body": "Just merged a PR disabling the relevant tests on Mono + Windows - https://github.com/dotnet/runtime/pull/42960. Removing `blocking-clean-ci` label for now.",
          "createdAt": "2020-10-02T04:01:41Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2020-10-02T04:02:01Z",
          "id": "MDEyOklzc3VlQ29tbWVudDcwMjUxMzQ4OA=="
        },
        {
          "author": "layomia",
          "body": "Linking my comment from https://github.com/dotnet/runtime/pull/42960#issuecomment-702458318. cc @ViktorHofer ",
          "createdAt": "2020-10-03T22:40:25Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2020-10-03T22:40:25Z",
          "id": "MDEyOklzc3VlQ29tbWVudDcwMzE3MzI3NA=="
        }
      ],
      "totalCount": 6,
      "endCursor": "Y3Vyc29yOnYyOpHOKemSmg=="
    },
    "url": "https://github.com/dotnet/runtime/issues/42677",
    "title": "Mono System.Text.Json.Tests on Windows timing out"
  },
  {
    "author": "JSkimming",
    "labels": [
      "enhancement",
      "api-suggestion",
      "area-System.Text.Json",
      "Team:Libraries"
    ],
    "createdAt": "2020-11-09T21:15:05Z",
    "body": "### Description\r\n\r\nI'm trying to deserialise an object from a json string. In this case the constructor allows a nullable value type as the parameter, setting a non-null property (defaulting if `null`).\r\n\r\nI expect (since it is the behaviour with **Newtonsoft.Json**) the serializer to handle compatible constructor and bound value type properties (or fields) where the only difference is one is nullable.\r\n\r\nThe following demonstrates the issue:\r\n\r\n```csharp\r\npublic class Example\r\n{\r\n    public Example(Guid? aGuid) => AGuid = aGuid ?? Guid.Empty;\r\n    public Guid AGuid { get; }\r\n}\r\n\r\nExample original = new Example(Guid.NewGuid());\r\n\r\n// Works with Newtonsoft.Json.\r\nstring withJsonNet = JsonConvert.SerializeObject(original);\r\nJsonConvert.DeserializeObject<Example>(withJsonNet);\r\n\r\n// Fails with System.Text.Json.\r\nstring withSystemTextJson = System.Text.Json.JsonSerializer.Serialize(original);\r\nSystem.Text.Json.JsonSerializer.Deserialize<Example>(withSystemTextJson);\r\n```\r\n\r\nAn `InvalidOperationException` is thrown from the method `System.Text.Json.JsonSerializer.Deserialize` :\r\n\r\n> **System.InvalidOperationException**: Each parameter in constructor 'Void .ctor(System.Nullable`1[System.Guid])' on type 'Example' must bind to an object property or field on deserialization. Each parameter name must match with a property or field on the object. The match can be case-insensitive.\r\n\r\n### Configuration\r\n\r\nI'm building an ASP.NET Core app targeting `netcoreapp3.1`, and using [version 5.0.0-rc.2.20475.5 of System.Text.Json](https://www.nuget.org/packages/System.Text.Json/5.0.0-rc.2.20475.5). I'm also using [version 12.0.3 of Newtonsoft.Json](https://www.nuget.org/packages/Newtonsoft.Json/12.0.3).\r\n\r\n### Other information\r\n\r\nStack Trace:\r\n\r\n```\r\nSystem.InvalidOperationException: Each parameter in constructor 'Void .ctor(System.Nullable`1[System.Guid])' on type 'Example' must bind to an object property or field on deserialization. Each parameter name must match with a property or field on the object. The match can be case-insensitive.\r\n   at System.Text.Json.ThrowHelper.ThrowInvalidOperationException_ConstructorParameterIncompleteBinding(ConstructorInfo constructorInfo, Type parentType)\r\n   at System.Text.Json.Serialization.Converters.ObjectWithParameterizedConstructorConverter`1.OnTryRead(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options, ReadStack& state, T& value)\r\n   at System.Text.Json.Serialization.JsonConverter`1.TryRead(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options, ReadStack& state, T& value)\r\n   at System.Text.Json.Serialization.JsonConverter`1.ReadCore(Utf8JsonReader& reader, JsonSerializerOptions options, ReadStack& state)\r\n   at System.Text.Json.JsonSerializer.ReadCore[TValue](JsonConverter jsonConverter, Utf8JsonReader& reader, JsonSerializerOptions options, ReadStack& state)\r\n   at System.Text.Json.JsonSerializer.ReadCore[TValue](Utf8JsonReader& reader, Type returnType, JsonSerializerOptions options)\r\n   at System.Text.Json.JsonSerializer.Deserialize[TValue](String json, Type returnType, JsonSerializerOptions options)\r\n   at System.Text.Json.JsonSerializer.Deserialize[TValue](String json, JsonSerializerOptions options)\r\n   at <custom code>\r\n```\r\n",
    "number": 44428,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-01-25T19:04:41Z",
          "user": "NN---"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-04-02T08:43:39Z",
          "user": "c0nstexpr"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-04-06T10:12:45Z",
          "user": "mungojam"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-07-23T09:42:46Z",
          "user": "KrzysztofBranicki"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-07-26T09:58:58Z",
          "user": "Timovzl"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-09-30T13:41:42Z",
          "user": "eiriktsarpalis"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-10-27T07:02:34Z",
          "user": "koheatel"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-02-19T17:41:38Z",
          "user": "stamminator"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-05-10T16:56:57Z",
          "user": "daiplusplus"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-09-19T13:41:09Z",
          "user": "aokellermann"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-11-10T15:36:11Z",
          "user": "SicJG"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-11-21T22:35:40Z",
          "user": "FarmV"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-01-06T18:13:45Z",
          "user": "TehGM"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-05-27T00:35:09Z",
          "user": "golf1052"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-06-02T22:08:27Z",
          "user": "jeremycook"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-06-26T08:25:35Z",
          "user": "plachor"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-06-26T08:33:27Z",
          "user": "marekott"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-06-29T13:05:54Z",
          "user": "EgorChernobrovkin"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-09-18T10:04:49Z",
          "user": "grsw92"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-01-14T12:59:48Z",
          "user": "MaximKitsenko"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-06-05T08:29:25Z",
          "user": "cajuncoding"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-07-30T11:48:00Z",
          "user": "Szer"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-07-30T11:54:55Z",
          "user": "KeterSCP"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-07-30T16:49:40Z",
          "user": "countneuroman"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-08-08T20:13:50Z",
          "user": "andrew-kuzovov"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-09-10T16:48:30Z",
          "user": "LeszekKalibrate"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-11-01T04:37:25Z",
          "user": "RenderMichael"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-11-03T09:38:16Z",
          "user": "AmrAlSayed0"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-01-17T16:27:36Z",
          "user": "Brokolis"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-05-16T04:08:43Z",
          "user": "HaraldMuehlhoffCC"
        }
      ],
      "totalCount": 30,
      "endCursor": "Y3Vyc29yOnYyOpHODCciWA=="
    },
    "updatedAt": "2025-07-22T11:41:30Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": "layomia",
          "body": "Why make the constructor parameter nullable? The `AGuid` property is non-nullable which means that `null` will never be serialized. Are you expecting `null` JSON tokens to bind with the parameter on deserialization? Where would this JSON come from?",
          "createdAt": "2020-11-12T18:42:18Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2020-11-12T18:42:18Z",
          "id": "MDEyOklzc3VlQ29tbWVudDcyNjI2NTM5MQ=="
        },
        {
          "author": "JSkimming",
          "body": "Thanks for the reply @layomia\r\n\r\nTo present a minimal use-case the example is intentionally trivial.\r\n\r\nMy situation is rather more complex. We have several scenarios where having the parameter as nullable was desirable (and worked well using **Newtonsoft.Json**), some of which we can, and have, resolved by making the parameter non-nullable.\r\n\r\nBut there are other scenarios where a nullable parameter with a non-nullable property is still preferred. One being where we have an unknown number of legacy objects that are serialised to a store with null values. The use-cases have since been updated where new instances are not serialised with null, but we still want to support the de-serialization of the legacy objects.\r\n\r\nIf we had been using **System.Text.Json** at the time, we probably would have implemented the solution differently, but as I highlighted above **Newtonsoft.Json** worked.\r\n\r\nHope the context helps.\r\n\r\nUltimately though, this is a difference in behaviour with **Newtonsoft.Json**. It looks like you are trying to resolve edge cases in to make **System.Text.Json** _\"the standard JSON stack for .NET.\"_ (See Issue #43620). And this is one such edge case.",
          "createdAt": "2020-11-13T07:18:46Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-07-26T09:59:09Z",
                "user": "Timovzl"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOBz0zHQ=="
          },
          "updatedAt": "2020-11-13T07:23:19Z",
          "id": "MDEyOklzc3VlQ29tbWVudDcyNjU3MDA3MA=="
        },
        {
          "author": "layomia",
          "body": "From @https://github.com/NN--- in https://github.com/dotnet/runtime/issues/46480:\r\n\r\n> ### Description\r\n> ```cs\r\n>     public class Q\r\n>     {\r\n>         [JsonConstructor]\r\n>         public Q(int? x)\r\n>         {\r\n>             if (x is null) throw new Exception();\r\n>             X = x.Value;\r\n>         }\r\n>         \r\n>         public int X { get; }\r\n>     }\r\n> ```\r\n> \r\n> Given string:\r\n> \r\n> ```cs\r\n> var str = JsonSerializer.Deserialize<Q>(\"{\\\"X\\\":123}\" \");\r\n> ```\r\n> \r\n> It is deserialized fine with Newtonsoft, but not with System.Text.\r\n> The reason is that constructor parameter type is `int?` while the property has type of `int`.\r\n> Newtonsoft doesn't validate it, giving an option to do anything in the constructor.\r\n> \r\n> There are possible workarounds but they are not as simple as the original code:\r\n> \r\n> Make property private and add a public non nullable:\r\n> \r\n> ```cs\r\n>     public class Q\r\n>     {\r\n>         [JsonConstructor]\r\n>         public Q(int? x)\r\n>         {\r\n>             if (x is null) throw new Exception();\r\n>             X = x.Value;\r\n>         }\r\n> \r\n>         public int? X { get; }\r\n> \r\n>         [JsonIgnore]\r\n>         public int NonNullableX => X!.Value;\r\n>     }\r\n> ```\r\n> \r\n> Annotate nullable as non nullable, however it requires explicit call to `Value`.:\r\n> \r\n> ```cs\r\n>     public class Q\r\n>     {\r\n>         [JsonConstructor]\r\n>         public Q(int? x)\r\n>         {\r\n>             if (x is null) throw new Exception();\r\n>             X = x.Value;\r\n>         }\r\n> \r\n>         [DisallowNull][NotNull]\r\n>         public int? X { get; }\r\n>     }\r\n> ```\r\n> \r\n> ### Configuration\r\n> ### Regression?\r\n> Not a regression.\r\n> \r\n> ### Other information\r\n\r\n",
          "createdAt": "2021-01-25T17:12:30Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-01-26T14:22:17Z",
                "user": "light-traveller"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHODUPQDw=="
          },
          "updatedAt": "2021-01-25T17:12:30Z",
          "id": "MDEyOklzc3VlQ29tbWVudDc2Njk2ODI4NQ=="
        },
        {
          "author": "layomia",
          "body": "We could look into relaxing the matching algorithm here if it proves to be unwieldy. The workaround here is to refactor the POCO code slightly to make the property type and the constructor parameter type the same. This issue will not be treated as high priority until a blocked and non-trivial scenario is provided.",
          "createdAt": "2021-01-25T17:14:54Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-01-25T17:14:54Z",
          "id": "MDEyOklzc3VlQ29tbWVudDc2Njk2OTc4NA=="
        },
        {
          "author": "GabeDeBacker",
          "body": "Deserializing JSON into an object that can be bound to WPF\\XAML is likely very common place and converting an incoming IEnumerable<x> into a observable collection that XAML can use is also likely common.\r\n\r\nNot supporting this limits System.Text.Json's use with an XAML\\WPF\\UWP apps.",
          "createdAt": "2021-01-25T19:17:50Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-04-02T08:44:27Z",
                "user": "c0nstexpr"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-07-26T10:00:38Z",
                "user": "Timovzl"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-01-14T19:48:10Z",
                "user": "SmartmanApps"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-09-04T09:56:47Z",
                "user": "ntix"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-01-17T16:29:49Z",
                "user": "Brokolis"
              }
            ],
            "totalCount": 5,
            "endCursor": "Y3Vyc29yOnYyOpHOEDAxfQ=="
          },
          "updatedAt": "2021-01-25T19:17:50Z",
          "id": "MDEyOklzc3VlQ29tbWVudDc2NzA1MDI0NQ=="
        },
        {
          "author": "JSkimming",
          "body": "> This issue will not be treated as high priority until a blocked and non-trivial scenario is provided.\r\n\r\n@layomia As I explained, the example is trivial to present a minimal use-case. I also went on to explain the non-trivial scenario:\r\n\r\n>  we have an unknown number of legacy objects that are serialised to a store with null values. The use-cases have since been updated where new instances are not serialised with null, but we still want to support the de-serialization of the legacy objects.\r\n\r\nWe are also blocked. Our workaround is to stick with **Newtonsoft.Json**.",
          "createdAt": "2021-01-25T21:26:49Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-01-14T19:47:52Z",
                "user": "SmartmanApps"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOCKBqXA=="
          },
          "updatedAt": "2021-01-26T07:13:27Z",
          "id": "MDEyOklzc3VlQ29tbWVudDc2NzEyMzU0NQ=="
        },
        {
          "author": "layomia",
          "body": "Thanks for the responses and expanding on the importance here. There are definitely various scenarios where loosening the matching restrictions is helpful. We can address this in the .NET 6.0 release.",
          "createdAt": "2021-01-25T23:49:29Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-01-26T00:57:50Z",
          "id": "MDEyOklzc3VlQ29tbWVudDc2NzE4NjUwOQ=="
        },
        {
          "author": "layomia",
          "body": "From @GabeDeBacker in https://github.com/dotnet/runtime/issues/47422#:\r\n\r\n> ### Description\r\n> System.Text.Json deserialization requires that a property type match the constructor type for immutable properties even though the constructor can convert the type.\r\n> \r\n> This is a simple example of a class that will convert an incoming IEnumerable to a ReadOnlyObservableCollection for XAML binding.\r\n> \r\n> ```cs\r\n>         [JsonConstructor]\r\n>         public Logger(IEnumerable<LogEntry> entries)\r\n>         {\r\n>             this.Entries = new ReadOnlyObservableCollection<LogEntry>(this.entries);\r\n>         }\r\n> \r\n>         public ReadOnlyObservableCollection<LogEntry> Entries { get; }\r\n> ```\r\n> \r\n> When desrializing from JSON, this fails.\r\n> \r\n> Changing the property to be IEnumerable allows the deserialization to succeed, but that means I would need to add “another” property to this class for XAML binding to work. (Which is what this class is used for). The below just doesn’t seem right and was not something I had to do when using NewtonSoft\r\n> \r\n> ```cs\r\n>         public Logger(IEnumerable<LogEntry> entries)\r\n>         {\r\n>             this.Entries = entries;\r\n>             this.ObersvableEntries = new ReadOnlyObservableCollection<LogEntry>(this.entries);\r\n>         }\r\n> \r\n>         public IEnumerable<LogEntry> Entries { get; }\r\n> \r\n>         [JsonIgnore]\r\n>         public ReadOnlyObservableCollection<LogEntry> ObersvableEntries { get; }\r\n> ```",
          "createdAt": "2021-01-26T00:15:47Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-01-26T00:15:47Z",
          "id": "MDEyOklzc3VlQ29tbWVudDc2NzE5NTYyMw=="
        },
        {
          "author": "layomia",
          "body": "Today, we expect an exact match between the constructor parameter type and the immutable property type. This is too restrictive in two major cases:\r\n\r\n- mapping nullable value-type ctor args to immutable properties of a non-nullable version of the type, as described in the description above https://github.com/dotnet/runtime/issues/44428#issue-739367850:\r\n\r\n    ```cs\r\n    public class Example\r\n    {\r\n        public Guid AGuid { get; }\r\n        public Example(Guid? aGuid) => AGuid = aGuid ?? Guid.Empty;\r\n    }\r\n    ```\r\n\r\n- scenarios where a reasonable conversion can be made between the ctor param type and the destination immutable property type, for example the scenario in https://github.com/dotnet/runtime/issues/44428#issuecomment-767195623:\r\n\r\n    ```cs\r\n    public class Logger\r\n    {\r\n        public ReadOnlyObservableCollection<LogEntry> Entries { get; }\r\n        public Logger(IEnumerable<LogEntry> entries) => Entries = new ReadOnlyObservableCollection<LogEntry>(entries);\r\n    }\r\n    ```\r\n\r\nWe can loosen the restriction and support these scenarios by checking that the ctor parameter is assignable from the immutable property type. This new algorithm is in accordance with the serializer always round-tripping (i.e being able to deserialize whatever we serialize), and maintains a high probability that the incoming JSON is compatible with the target ctor param. This is important to avoid unintentional data loss.\r\n\r\nIf there are more reasonable scenarios that will not be satisfied with this proposal, we can evaluate them and perhaps adjust further.",
          "createdAt": "2021-01-26T00:59:07Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-01-26T07:15:07Z",
                "user": "JSkimming"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-09-10T16:52:04Z",
                "user": "LeszekKalibrate"
              }
            ],
            "totalCount": 2,
            "endCursor": "Y3Vyc29yOnYyOpHODxtS8w=="
          },
          "updatedAt": "2021-01-26T00:59:07Z",
          "id": "MDEyOklzc3VlQ29tbWVudDc2NzIxMDYzOQ=="
        },
        {
          "author": "layomia",
          "body": "We can also, or alternatively, consider a property on `JsonConstructorAttribute`, that indicates no restriction between the ctor parameter type and the immutable property type. This would allow them to be two arbitrarily different types, basically an \"I know what I'm doing mode\". It would still be required for their CLR names to match.\r\n\r\n```cs\r\n/// <summary>\r\n/// When placed on a constructor, indicates that the constructor should be used to create\r\n/// instances of the type on deserialization.\r\n/// </summary>\r\n[AttributeUsage(AttributeTargets.Constructor, AllowMultiple = false)]\r\npublic sealed class JsonConstructorAttribute : JsonAttribute\r\n{\r\n    /// <summary>\r\n    /// When <see cref=\"true\" />, indicates that no restriction should be placed on the types of a constructor\r\n    /// parameter and a property when there is a case-insensitive match between their names.\r\n    /// </summary>\r\n    public bool UseRelaxedPropertyMatching { get; set; }\r\n\r\n    /// <summary>\r\n    /// Initializes a new instance of <see cref=\"JsonConstructorAttribute\"/>.\r\n    /// </summary>\r\n    public JsonConstructorAttribute() { }\r\n}\r\n```\r\n\r\nA global option can be considered as well, to support non-owned types where we can't decorate with an attribute:\r\n\r\n```cs\r\npublic sealed class JsonSerializerOptions\r\n{\r\n    /// <summary>\r\n    /// When <see cref=\"true\" />, indicates that no restriction should be placed on the types of a constructor\r\n    /// parameter and a property when there is a case-insensitive match between their names.\r\n    /// </summary>\r\n    public bool ConstructorUseRelaxedPropertyMatching { get; set; }\r\n}\r\n```\r\n\r\n---\r\n\r\nAll of this design assumes that there will always be a requirement that every constructor parameter binds to an object property, per the original spec for this feature: https://github.com/dotnet/runtime/pull/33095.",
          "createdAt": "2021-01-26T01:20:31Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-01-26T02:25:59Z",
                "user": "GabeDeBacker"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-01-26T07:16:02Z",
                "user": "JSkimming"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-07-26T10:02:09Z",
                "user": "Timovzl"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-11-10T15:41:51Z",
                "user": "SicJG"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-09-10T15:37:31Z",
                "user": "LeszekKalibrate"
              }
            ],
            "totalCount": 5,
            "endCursor": "Y3Vyc29yOnYyOpHODxssPg=="
          },
          "updatedAt": "2021-01-26T11:39:02Z",
          "id": "MDEyOklzc3VlQ29tbWVudDc2NzIxNzg3Mg=="
        },
        {
          "author": "GabeDeBacker",
          "body": "@layomia - Implementing either (or both) of what you mentioned above (the JsonConstructorAttribute argument or is the constructor argument assignable from the property type) would be great additions! Thanks for the conversation",
          "createdAt": "2021-01-26T02:25:15Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-01-26T11:39:35Z",
                "user": "layomia"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOBdtRow=="
          },
          "updatedAt": "2021-01-26T02:25:15Z",
          "id": "MDEyOklzc3VlQ29tbWVudDc2NzI0MjA2Mw=="
        },
        {
          "author": "layomia",
          "body": "> We can also, or alternatively, consider a property on `JsonConstructorAttribute`, that indicates no restriction between the ctor parameter type and the immutable property type. This would allow them to be two arbitrarily different types, basically an \"I know what I'm doing mode\". It would still be required for their CLR names to match.\r\n\r\nWe would likely still need to support the \"mapping nullable value-type ctor args to immutable properties of a non-nullable version of the type\" case by default - https://github.com/dotnet/runtime/issues/44428#issue-739367850.",
          "createdAt": "2021-01-26T13:28:15Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-01-26T14:23:28Z",
                "user": "JSkimming"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOBdum4g=="
          },
          "updatedAt": "2021-01-26T13:28:15Z",
          "id": "MDEyOklzc3VlQ29tbWVudDc2NzU0MDU4MQ=="
        },
        {
          "author": "layomia",
          "body": "Co-assigning @GabeDeBacker to provide the implementation for this feature, as discussed offline.",
          "createdAt": "2021-01-27T17:10:15Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-01-27T17:10:15Z",
          "id": "MDEyOklzc3VlQ29tbWVudDc2ODQzMzU1OQ=="
        },
        {
          "author": "GabeDeBacker",
          "body": "I did find an example of where a property type is not assignable from the constructor argument type.\r\nYou cannot construct a SecureString from a string.\r\n\r\n```c#\r\npublic class ClassThatStoresSecureStrings\r\n{\r\n    using System;\r\n    using System.Security;\r\n\r\n   public ClassThatStoresSecureStrings(string userId, string password)\r\n   {\r\n            // This code repeats for password.\r\n            this.UserId = new SecureString();\r\n            foreach (var ch in userId)\r\n            {\r\n                this.UserId.AppendChar(ch);\r\n            }\r\n\r\n            this.UserId.MakeReadOnly();\r\n   }\r\n\r\n   public SecureString UserId { get; }\r\n   public SecureString Password {get; }\r\n}\r\n```",
          "createdAt": "2021-03-04T17:58:38Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-09-04T10:01:57Z",
                "user": "ntix"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-09-10T16:53:20Z",
                "user": "LeszekKalibrate"
              }
            ],
            "totalCount": 2,
            "endCursor": "Y3Vyc29yOnYyOpHODxtTnw=="
          },
          "updatedAt": "2021-03-04T17:58:38Z",
          "id": "MDEyOklzc3VlQ29tbWVudDc5MDgxMTM0OQ=="
        },
        {
          "author": "layomia",
          "body": "From @terrajobst in https://github.com/dotnet/runtime/issues/53303:\r\n\r\n> I have the following class:\r\n> \r\n> ```cs\r\n> public sealed class CrawledAreaOwnerEntry\r\n> {\r\n>     public CrawledAreaOwnerEntry(string area, string lead, IEnumerable<string> owners)\r\n>     {\r\n>         Area = area;\r\n>         Lead = lead;\r\n>         Owners = owners.ToArray();\r\n>     }\r\n> \r\n>     public string Area { get; }\r\n>     public string Lead { get; }\r\n>     public IReadOnlyList<string> Owners { get; }\r\n> }\r\n> ```\r\n> \r\n> When deserializing it, I get the following exception:\r\n> \r\n> ```\r\n> System.InvalidOperationException: Each parameter in constructor 'Void .ctor(System.String, System.String, System.Collections.Generic.IEnumerable`1[System.String])' on type \r\n> 'IssueDb.CrawledAreaOwnerEntry' must bind to an object property or field on deserialization. Each parameter name must match with a property or field on the object.\r\n> The match can be case-insensitive.\r\n>    at System.Text.Json.ThrowHelper.ThrowInvalidOperationException_ConstructorParameterIncompleteBinding(ConstructorInfo constructorInfo, Type parentType)\r\n>    at System.Text.Json.Serialization.Converters.ObjectWithParameterizedConstructorConverter`1.OnTryRead(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options, ReadStack& state, T& value)\r\n>    at System.Text.Json.Serialization.JsonConverter`1.TryRead(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options, ReadStack& state, T& value)\r\n>    at System.Text.Json.Serialization.Converters.DictionaryDefaultConverter`3.OnTryRead(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options, ReadStack& state, TCollection& value)\r\n>    at System.Text.Json.Serialization.JsonConverter`1.TryRead(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options, ReadStack& state, T& value)\r\n>    at System.Text.Json.JsonPropertyInfo`1.ReadJsonAndSetMember(Object obj, ReadStack& state, Utf8JsonReader& reader)\r\n>    at System.Text.Json.Serialization.Converters.ObjectDefaultConverter`1.OnTryRead(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options, ReadStack& state, T& value)\r\n>    at System.Text.Json.Serialization.JsonConverter`1.TryRead(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options, ReadStack& state, T& value)\r\n>    at System.Text.Json.Serialization.JsonConverter`1.ReadCore(Utf8JsonReader& reader, JsonSerializerOptions options, ReadStack& state)\r\n>    at System.Text.Json.JsonSerializer.ReadCore[TValue](JsonReaderState& readerState, Boolean isFinalBlock, ReadOnlySpan`1 buffer, JsonSerializerOptions options, ReadStack& state, JsonConverter converterBase)\r\n>    at System.Text.Json.JsonSerializer.ReadAsync[TValue](Stream utf8Json, Type returnType, JsonSerializerOptions options, CancellationToken cancellationToken)\r\n>    at IssueDb.Crawling.CrawledRepo.LoadAsync(String path) in /home/runner/work/issuesof.net/issuesof.net/src/IssueDb/Crawling/CrawledRepo.cs:line 43\r\n> ```\r\n> \r\n> It seems the serializer requires the types of the properties to be identical to the parameter. That feels overly restrictive to me; it seems we should only require that the property type is assignable to the parameter type.\r\n\r\n",
          "createdAt": "2021-05-27T15:37:11Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-07-22T18:34:55Z",
                "user": "daiplusplus"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-10-15T13:21:00Z",
                "user": "martindybal"
              }
            ],
            "totalCount": 2,
            "endCursor": "Y3Vyc29yOnYyOpHOB-fEdw=="
          },
          "updatedAt": "2021-05-27T15:37:11Z",
          "id": "MDEyOklzc3VlQ29tbWVudDg0OTczNTM1OQ=="
        },
        {
          "author": "layomia",
          "body": "Unassigning @GabeDeBacker https://github.com/dotnet/runtime/pull/47661#issuecomment-856936994.",
          "createdAt": "2021-06-08T17:09:10Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-06-08T17:09:10Z",
          "id": "MDEyOklzc3VlQ29tbWVudDg1Njk0Mzg4MA=="
        },
        {
          "author": "layomia",
          "body": "We couldn't get to this in .NET 6.0 but can consider for .NET 7.",
          "createdAt": "2021-07-23T00:24:32Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-07-23T00:24:32Z",
          "id": "IC_kwDODI9FZc40xO-p"
        },
        {
          "author": "daiplusplus",
          "body": "[Reposting my reply](https://github.com/dotnet/runtime/issues/45190#issuecomment-885165783) to #45190 (@layomia asked me to repost it here)\r\n\r\nThis is my use-case for wanting support for private primary-constructors and multiple primary-constructors, and partial mapping between properties and ctor parameters:\r\n\r\n----------\r\n\r\nI know `System.Text.Json` won't invoke `private` members by default, but I'm surprised and disappointed that we cannot explicitly denote private constructors with `[JsonConstructor]`.\r\n\r\nIdeally I'd like to reuse the same DTO types in `Newtonsoft.Json` and `System.Text.Json` contexts (with suitable `using JsonPropertyAttribute = System.Text.Json.Serialization.JsonPropertyNameAttribute` in `#if USE_STJ` at the top of the `.cs` file), however my projects tend to use primary-constructors which STJ doesn't support, so I can't use the above trick just yet.\r\n\r\n- [ ] Allow `[JsonConstructor]` with `private` constructors, even when a `public` constructor is available.\r\n  * This is essential for cases where a type has different constructors for different states, with per-state validation logic (for an example, see my `class SqlDbTypeRef` in the expanding region below). Exposing a `public` constructor that has parameters for all properties would allow consumers to unwittingly circumvent the validation rules - and requiring us to reimplementing the validation logic in this new constructor is not endearing me to use STJ over NJ.\r\n- [ ] Allow `[JsonPropertyName]` on constructor parameters and use `JsonPropertyNameAttribute.Name` to map them to C# properties' `JsonPropertyNameAttribute.Name` instead of their C# property names.\r\n  * This make it easier to write DTOs that are more resilient to unintentional symbol renames when refactoring - especially as Visual Studio's C# Refactor-Rename tool does not currently rename constructor parameters that are assigned to POCO properties.\r\n  * Allowing explicit JSON property names on ctor parameters also allows us to tweak serialization vs. deserialization logic without needing too much effort.\r\n  * A use-case for this is when you want the same DTO to intentionally ignore or drop certain properties when deserializing but still serialize them _and_ you're using code-gen or T4 to generate DTOs and having to use custom logic in the ctor is just too much effort.\r\n- [ ] Allow partial `[JsonConstructor]` parameter-to-property mapping.\r\n  * This is useful when the private `[JsonConstructor]` is also used by a `public static` factory method and additional details are routed through there but would not come from JSON - so the constructor has more parameters than JSON properties.\r\n\r\nFor example, I have a class that represents a `SqlDbType` with `length`, `precision`, and `scale` parameters - this is what I currently have working with `Newtonsoft.Json`:\r\n\r\n----------\r\n\r\n<details>\r\n  <summary>Click to expand!</summary>\r\n\r\n```\r\npublic partial class SqlDbTypeRef\r\n{\r\n\t/// <summary>For <see cref=\"System.Data.SqlDbType\"/> types without parameters.</summary>\r\n\t/// <exception cref=\"ArgumentException\">When the <paramref name=\"dbType\"/> value used requires length, precision, or scale parameter values.</exception>\r\n\tpublic SqlDbTypeRef( SqlDbType dbType )\r\n\t{\r\n\t\tSqlDbTypeParameters p = SqlDbTypeExtensions.GetParameters( dbType );\r\n\t\tif( p == SqlDbTypeParameters.None )\r\n\t\t{\r\n\t\t\tInt16? length = null;\r\n\t\t\tif( SqlDbTypeExtensions.HasImplicitLength( dbType, out Int16 implicitLength ) ) length = implicitLength;\r\n\r\n\t\t\tthis.SqlDbType = dbType;\r\n\t\t\tthis.Length    = length;\r\n\t\t\tthis.Precision = null;\r\n\t\t\tthis.Scale     = null;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tthrow new ArgumentException( message: \"SqlDbType.{0} is parameterized: {1}\".Fmt( dbType, p ), paramName: nameof(dbType) );\r\n\t\t}\r\n\t}\r\n\t\t\r\n\t/// <summary>For <see cref=\"SqlDbType.Binary\"/>, <see cref=\"SqlDbType.VarBinary\"/>, <see cref=\"SqlDbType.Char\"/>, <see cref=\"SqlDbType.NChar\"/>, <see cref=\"SqlDbType.NVarChar\"/>, <see cref=\"SqlDbType.VarChar\"/>.</summary>\r\n\tpublic SqlDbTypeRef( SqlDbType dbType, Int16 length )\r\n\t{\r\n\t\tSqlDbTypeParameters p = SqlDbTypeExtensions.GetParameters( dbType );\r\n\t\tif( p == SqlDbTypeParameters.Length )\r\n\t\t{\r\n\t\t\tthis.SqlDbType = dbType;\r\n\t\t\tthis.Length    = length;\r\n\t\t\tthis.Precision = null;\r\n\t\t\tthis.Scale     = null;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tthrow new ArgumentException( message: \"SqlDbType.{0} requires {1}\".Fmt( dbType, p ), paramName: nameof(dbType) );\r\n\t\t}\r\n\t}\r\n\r\n\t/// <summary>For <see cref=\"SqlDbType.DateTime2\"/>, <see cref=\"SqlDbType.DateTimeOffset\"/>, <see cref=\"SqlDbType.Float\"/>.</summary>\r\n\tpublic SqlDbTypeRef( SqlDbType dbType, Byte precision )\r\n\t{\r\n\t\tSqlDbTypeParameters p = SqlDbTypeExtensions.GetParameters( dbType );\r\n\t\tif( p == SqlDbTypeParameters.Precision )\r\n\t\t{\r\n\t\t\tthis.SqlDbType = dbType;\r\n\t\t\tthis.Length    = null;\r\n\t\t\tthis.Precision = precision;\r\n\t\t\tthis.Scale     = null;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tthrow new ArgumentException( message: \"SqlDbType.{0} requires {1}\".Fmt( dbType, p ), paramName: nameof(dbType) );\r\n\t\t}\r\n\t}\r\n\r\n\t/// <summary>For <see cref=\"SqlDbType.Decimal\"/>.</summary>\r\n\tpublic SqlDbTypeRef( SqlDbType dbType, Byte precision, Byte scale )\r\n\t{\r\n\t\tSqlDbTypeParameters p = SqlDbTypeExtensions.GetParameters( dbType );\r\n\t\tif( p == SqlDbTypeParameters.PrecisionAndScale )\r\n\t\t{\r\n\t\t\tthis.SqlDbType = dbType;\r\n\t\t\tthis.Length    = null;\r\n\t\t\tthis.Precision = precision;\r\n\t\t\tthis.Scale     = scale;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tthrow new ArgumentException( message: \"SqlDbType.{0} requires {1}\".Fmt( dbType, p ), paramName: nameof(dbType) );\r\n\t\t}\r\n\t}\r\n\r\n\t[JsonConstructor]\r\n\tprivate SqlDbTypeRef(\r\n\t\t[JsonProperty( \"type\"   )] SqlDbType dbType,\r\n\t\t[JsonProperty( \"length\" )] Int16?    length,\r\n\t\t[JsonProperty( \"precision\" )] Byte?     precision,\r\n\t\t[JsonProperty( \"scale\"  )] Byte?     scale\r\n\t)\r\n\t{\r\n\t\tthis.SqlDbType = dbType;\r\n\t\tthis.Length    = length;\r\n\t\tthis.Precision = precision;\r\n\t\tthis.Scale     = scale;\r\n\t}\r\n\r\n\t[JsonProperty( \"type\" )]\r\n\tpublic SqlDbType SqlDbType { get; }\r\n\r\n\t[JsonProperty( \"length\", NullValueHandling = NullValueHandling.Ignore )]\r\n\tpublic Int16?    Length    { get; }\r\n\t\t\r\n\t[JsonProperty( \"precision\", NullValueHandling = NullValueHandling.Ignore )]\r\n\tpublic Byte?     Precision { get; }\r\n\t\t\r\n\t[JsonProperty( \"scale\", NullValueHandling = NullValueHandling.Ignore )]\r\n\tpublic Byte?     Scale     { get; }\r\n}\r\n```\r\n</details>\r\n\r\n\r\n-----\r\n",
          "createdAt": "2021-08-18T01:27:37Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-09-18T23:57:06Z",
                "user": "douglasg14b"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOCsa_mw=="
          },
          "updatedAt": "2021-08-18T01:27:37Z",
          "id": "IC_kwDODI9FZc41sD-0"
        },
        {
          "author": "raffaeler",
          "body": "@layomia I landed here from https://github.com/dotnet/runtime/issues/59804\r\n\r\nI am not sure if I understand correctly your proposal, so I try to rephrase it.\r\n\r\nWhen I apply `JsonConstructorAttribute`, I would like the deserialization to just match the signature of the constructor marked with `JsonConstructorAttribute` with zero requirements over the properties.\r\n* Use that constructor even if its visibility is private/internal/whatever\r\n* Match the parameter types/names according to the json being deserialized\r\n* It will be up to the developer to initialize the object state (properties/fields)\r\n\r\nAre you going in this direction?\r\n\r\nThank you!",
          "createdAt": "2021-10-29T11:06:39Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-10-29T11:08:23Z",
                "user": "daiplusplus"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-11-01T10:56:01Z",
                "user": "Timovzl"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-09-18T23:57:19Z",
                "user": "douglasg14b"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-06-02T22:11:52Z",
                "user": "jeremycook"
              }
            ],
            "totalCount": 4,
            "endCursor": "Y3Vyc29yOnYyOpHOC9DYTg=="
          },
          "updatedAt": "2021-10-29T11:06:39Z",
          "id": "IC_kwDODI9FZc445uA3"
        },
        {
          "author": "layomia",
          "body": "@raffaeler\r\n\r\n> Use that constructor even if its visibility is private/internal/whatever\r\n\r\nYes this is an enhancement we plan to make as part of this work. In the source-gen case, only `public` and `internal` ctors can be used, so the generator will issue a diagnostic if the attribute is placed on a ctor that is not accessible to the generated code.\r\n\r\n> Match the parameter types/names according to the json being deserialized\r\n\r\n> It will be up to the developer to initialize the object state (properties/fields)\r\n\r\nGiven further feedback from scenarios like https://github.com/dotnet/runtime/issues/44428#issuecomment-900743092, I'm inclined to have the serializer perform no validation on ctor parameter/property binding wrt to names and data type, and just have the user perform whatever validation they need within the constructor, or using one of the deserialization callbacks (`IJsonOnDerializing`, `IJsonOnDeserialized`)",
          "createdAt": "2021-11-22T23:29:15Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-11-22T23:29:15Z",
          "id": "IC_kwDODI9FZc46LKmu"
        },
        {
          "author": "daiplusplus",
          "body": "@layomia why arbitrarily restrict it to `public` and `internal` - why not `private` ctors? If a `private` ctor has `[JsonConstructor]` then it still should be used. There are plenty of reasons for wanting to make a ctor private to prevent _human_ users but still want JSON deserialization to use it. A good reason for this is that defining a `private` _primary constructor_ is considerably less work than writing up a full contract-resolver/`JsonConverter` implementation.\r\n\r\nWhat _benefits_, **exactly**, come from prohibiting `private` constructors?",
          "createdAt": "2021-11-23T00:51:23Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-11-23T00:51:23Z",
          "id": "IC_kwDODI9FZc46LVIZ"
        },
        {
          "author": "raffaeler",
          "body": "@layomia \r\n> [...] I'm inclined to have the serializer perform no validation on ctor parameter/property binding [...]\r\n\r\nYes please. The whole point of JSON specs is to be greedy. Exceptions should be thrown only in extreme (wrong casts) cases.\r\nSo I agree also with @Jehoel that you should not limit to any visibility modifier when applying the attribute.\r\n\r\nAlso, given you are going into the generation space, please provide the opportunity to extend it.\r\nI created my Json converter that dynamically transform a graph and it would be nice if I can exten the default generation from my converters. \r\nBTW, as I convert a whole tree in a single converter, the benchmark tells me that I'm faster.",
          "createdAt": "2021-11-23T07:51:04Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-11-23T07:51:04Z",
          "id": "IC_kwDODI9FZc46MB20"
        },
        {
          "author": "Timovzl",
          "body": "> In the source-gen case, only public and internal ctors can be used\r\n\r\n@layomia It is still desirable to _be able_ to use the source generator, even if we need or want to keep our constructors private. If no constructor is available to the source generator, could it please use `FormatterServices.GetUninitializedObject()` instead?\r\n\r\n> [...] I'm inclined to have the serializer perform no validation on ctor parameter/property binding [...]\r\n\r\nMy suggestion helps with this as well.",
          "createdAt": "2021-11-24T12:01:11Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-11-24T12:01:11Z",
          "id": "IC_kwDODI9FZc46SDcu"
        },
        {
          "author": "terrajobst",
          "body": "@raffaeler \r\n\r\n> Yes please. The whole point of JSON specs is to be greedy. Exceptions should be thrown only in extreme (wrong casts) cases.\r\n> So I agree also with @Jehoel that you should not limit to any visibility modifier when applying the attribute.\r\n\r\nI'd be careful with designs like this. For example, my team takes API design and breaking changes extremely seriously but even we don't review any changes to privates. If serialization magically binds to privates it becomes much more likely for developers to break serialization by making changes to state they reasonably thought to be unobservable. There aren't really any good reasons to bind to privates for serialization; in my experience it's virtually always preferable to limit the serializer to public state. And in cases where there isn't a good alternative, I'd rather we extend the serializer's feature set to enable it than to bind to privates. \r\n\r\nAlso, moving forward we want to support code generation. That's a lot harder because you can't access privates statically.\r\n\r\n@layomia \r\n\r\n> I'm inclined to have the serializer perform no validation on ctor parameter/property binding wrt to names and data type, and just have the user perform whatever validation they need within the constructor, or using one of the deserialization callbacks (`IJsonOnDerializing`, `IJsonOnDeserialized`)\r\n\r\nWhat do you mean by \"no validation\"? Presumably for naming you mean ignoring casing and not enforcing that the propery/parameter match, but you'd still match that the property from the JSON payload can be assigned to the parameter, right?",
          "createdAt": "2021-11-25T00:18:59Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-11-25T00:18:59Z",
          "id": "IC_kwDODI9FZc46U0-J"
        },
        {
          "author": "daiplusplus",
          "body": "@terrajobst \r\n\r\n> For example, my team takes API design and breaking changes extremely seriously but even we don't review any changes to privates. \r\n\r\nWith respect, working on a platform or framework is different to working on an end-application or web-service. Most .NET users use Newtonsoft.Json over System.Text, and in Newtonsoft it's already well established that `[JsonConstructor]` works with private constructors (e.g. [this works just fine](https://gist.github.com/Jehoel/1c4a480d902503e7c8888028609bba08)), and so the presence of the  `[JsonConstructor]`  attribute overrides any `private` accessibility modifiers - and means it _should_ be reviewed for breaking changes, whereas your argument seems to be \"it means we can't depend _only_ on access-modifiers for examining breaking changes\" which isn't a compelling argument. And I note that breaking-changes can happen just-as-easily inside other `private` members, e.g. if an `ISerializable`'s `GetObjectData` calls into some private method.\r\n\r\n> If serialization magically binds to privates...\r\n\r\nNo-one is advocating for _magic_, undocumented, or otherwise [_astonishing_](https://en.wikipedia.org/wiki/Principle_of_least_astonishment) behavior: we're just saying \"the `[JsonConstructor]`  attribute should trump access-modifiers\".\r\n\r\n> ...it becomes much more likely for developers to break serialization by making changes to state they reasonably thought to be unobservable.\r\n\r\nA private constructor isn't comparable to a private field or private property: a constructor doesn't represent any kind of state.\r\n\r\nBut FWIW, back in .NET Framework 2.0 and WCF, the `[DataMember]` attribute [**does** support `private` properties](https://stackoverflow.com/questions/17859105/datamember-attribute-on-private-members-whats-happening-under-the-hood) (it's just opt-in instead of opt-out).\r\n\r\n> There aren't really any good reasons to bind to privates for serialization; in my experience it's virtually always preferable to limit the serializer to public state.\r\n\r\nIs that a default (i.e. require explicit opt-in to serialize `private` members, a-la `[DataMember]`), or are you suggesting it should be a hard restriction that cannot be overridden by application code?\r\n\r\n>  I'd rather we extend the serializer's feature set to enable it than to bind to privates.\r\n\r\nI'm unsure what you're describing here.\r\n\r\n",
          "createdAt": "2021-11-25T04:01:36Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-01-03T10:43:15Z",
                "user": "Timovzl"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-02-19T17:44:43Z",
                "user": "stamminator"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-09-18T23:59:08Z",
                "user": "douglasg14b"
              }
            ],
            "totalCount": 3,
            "endCursor": "Y3Vyc29yOnYyOpHOCsa_tQ=="
          },
          "updatedAt": "2021-11-25T04:03:39Z",
          "id": "IC_kwDODI9FZc46V2xx"
        },
        {
          "author": "raffaeler",
          "body": "@terrajobst Thank you for your answer.\r\nI understand the reason you mentioned, but the attribute is an opt-in that you decide to adopt with all the pros/cons.\r\nThere are times where you don't want to publish the constructor to the outside world and the simple method would be to instruct the serializer to use the provided constructor.  I totally undetstand that this could prevent the code generation option, but not all code needs more perf.\r\n\r\nAnyway, the point I am mostly concerned about my initial point. The current binding validations are too strict because they bind json properties to the name and types of the properties instead of relying **only** on the JsonConstructor parameters. This is a big stopper in many versioning scenarios (and please do not ask people to write a JsonConverter for these use-cases).\r\n\r\nAlso, please reconsider the JsonConstructor applied at class level for records so that we can finally use primary constructors where multiple ctors exist.\r\n\r\nTIA\r\n",
          "createdAt": "2021-11-25T07:55:44Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-01-03T10:43:40Z",
                "user": "Timovzl"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOCIWJLw=="
          },
          "updatedAt": "2021-11-25T07:55:44Z",
          "id": "IC_kwDODI9FZc46WSmT"
        },
        {
          "author": "layomia",
          "body": "> @layomia\r\n\r\n>> I'm inclined to have the serializer perform no validation on ctor parameter/property binding wrt to names and data type, and just have the user perform whatever validation they need within the constructor, or using one of the deserialization callbacks (IJsonOnDerializing, IJsonOnDeserialized)\r\n\r\n> What do you mean by \"no validation\"? Presumably for naming you mean ignoring casing and not enforcing that the propery/parameter match, but you'd still match that the property from the JSON payload can be assigned to the parameter, right?\r\n\r\n@terrajobst my initial thought was that the ctor binding logic should be loosened to allow a match between a parameter & a property if the parameter type is assignable to the property type. However, I keep seeing scenarios like the one pointed about by @GabeDeBacker above, where this would not be sufficient:\r\n\r\n```cs\r\npublic class ClassThatStoresSecureStrings\r\n{\r\n    using System;\r\n    using System.Security;\r\n\r\n   public ClassThatStoresSecureStrings(string userId, string password)\r\n   {\r\n            // This code repeats for password.\r\n            this.UserId = new SecureString();\r\n            foreach (var ch in userId)\r\n            {\r\n                this.UserId.AppendChar(ch);\r\n            }\r\n\r\n            this.UserId.MakeReadOnly();\r\n   }\r\n\r\n   public SecureString UserId { get; }\r\n   public SecureString Password {get; }\r\n}\r\n```\r\n\r\nI think it's okay to rule this as an edge-case for now & circle back if there's significant feedback later. In either case, we'd still require that every ctor param matches to a property, and for their names to match (case insensitive match would be okay). \r\n\r\nI also think that it's okay to allow `[JsonConstructor]` to work non-public ctors since several folks have expressed that they desire this functionality (https://github.com/dotnet/runtime/issues/31511, https://github.com/dotnet/runtime/issues/38327), and we already some precedent in form of support for non-public _accessors_ on public properties when `[JsonInclude]` is used. However, it would be a breaking change since, unfortunately, `[JsonConstructor]` is silently ignored on non-public ctors today (in contrast to `[JsonInclude]` on non-public props/fields which throws `InvalidOperationException`). The breaking change is somewhat mitigated by the fact the serializer is likely to still throw `NotSupportedException` in the general case, as there'll be no ctor to use.\r\n\r\n> @layomia why arbitrarily restrict it to public and internal - why not private ctors? \r\n\r\nAs previously mentioned (https://github.com/dotnet/runtime/issues/44428#issuecomment-978538377). The source gen restriction of public/internal ctors only is not arbitrary, since source-gen doesn't have access to members that are not public or internal. In the future, if we design a source-gen mode where the code is generated directly on the serializable type, we could enable non-public/internal member support for source-gen.\r\n\r\n---\r\n\r\nMy current feel for the implementation changes as a result of this issue/discussion would be the following:\r\n\r\n1. Rather than require a ctor param type and the target property type to match exactly, we would allow binding if the ctor param type is assignable to the property type.\r\n2. Allow `[JsonConstructor]` on non-public ctors with the reflection serializer.",
          "createdAt": "2022-01-10T23:21:29Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-01-10T23:21:29Z",
          "id": "IC_kwDODI9FZc48Kulw"
        },
        {
          "author": "raffaeler",
          "body": "@layomia I don't understand this point\r\n\r\n> 1. Rather than require a ctor param type and the target property type to match exactly, we would allow binding if the ctor param type is assignable to the property type.\r\n\r\nThe whole point of only matching the ctor parameters is because there is not match with the parameters. In many use-cases I need to modify the data (including the type) of the serialized data to some other type that is expressed in the property. The ctor is the best point where we can resolve the mismatch.\r\n\r\nLooking at this from another perspective: json has a different type system than .NET. If I appoint a ctor to be the \"resolver\" for a type system discrepancy, it would not make sense that any validation is applied to the final property which only gets the converted data.",
          "createdAt": "2022-01-11T07:50:15Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-01-12T22:41:15Z",
                "user": "Timovzl"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-09-20T08:02:30Z",
                "user": "daiplusplus"
              }
            ],
            "totalCount": 2,
            "endCursor": "Y3Vyc29yOnYyOpHOCsf7Yg=="
          },
          "updatedAt": "2022-01-11T07:50:15Z",
          "id": "IC_kwDODI9FZc48Ln7U"
        },
        {
          "author": "layomia",
          "body": "@raffaeler - that's the whole issue with the request to loosen the binding logic. On one hand we have the fact that STJ asserts that serialization should be round-trippable, requiring that we have reasonable binding between ctor params and properties. This lets us know that payloads that can be deserialized must also be serializable. On the other hand we have somewhat niche scenarios like yours that need to circumvent this validation. I'll spend sometime codifying the various options which might lead to API review where we can get more feedback on what direction to take. cc @dotnet/area-system-text-json ",
          "createdAt": "2022-01-21T22:43:51Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-01-21T22:43:51Z",
          "id": "IC_kwDODI9FZc48u3Si"
        },
        {
          "author": "raffaeler",
          "body": "@layomia I understand the dilemma but please do not forget the nature of the json serialization which is lazy and greedy in total contrast with the strong validation policy throwing exception that you would do on, for example, an xml serialization.\r\n\r\nMaybe you can add an option to explicitly opt-in the ability to just map the ctor without validating the property mappings.\r\nIt can either be a new `JsonSerializerOptions` or a `JsonConstructor` property.",
          "createdAt": "2022-01-22T11:06:36Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-02-19T17:46:21Z",
                "user": "stamminator"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-09-20T08:02:57Z",
                "user": "daiplusplus"
              }
            ],
            "totalCount": 2,
            "endCursor": "Y3Vyc29yOnYyOpHOCsf7gQ=="
          },
          "updatedAt": "2022-01-22T11:06:36Z",
          "id": "IC_kwDODI9FZc48v47r"
        },
        {
          "author": "fabio-s-franco",
          "body": "This is one of the most painful aspects of System.Text.Json. It has been by far the greatest time pit since I started using it.\r\n\r\nTo me it makes no sense whatsoever that there is a match between constructor name and type to a corresponding class member. Once we are inside the constructor, the control is already handed over, why care to which property and how a constructor parameter is being assigned to? This becomes specially annoying with inheritance.\r\n\r\nEven if there is a conflict (when they do match), there are so many ways to make this simpler and less of debugging hell. Just default one of the following available choices:\r\n- Constructor precedence (my preferred default). Just pop the json node it if it successfully serializes to a constructor parameter.\r\n- Exception if exact type mismatch\r\n- Closest match to source json type. If not inferable, take constructor as precedence\r\n\r\nTo me this beats the whole purpose of JSON's interoperability. With all converters and all, this really shouldn't be necessary. Specially given we can specially decorate a constructor specifically for the purpose of deserialization. Maybe this could be a behavior (albeit still less strict) for when there is no specifically decorated JsonConstructor?\r\n\r\n",
          "createdAt": "2022-01-29T22:47:38Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-01-30T10:09:03Z",
                "user": "KrzysztofBranicki"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-01-30T15:15:13Z",
                "user": "Timovzl"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-02-18T19:10:20Z",
                "user": "TanvirArjel"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-02-19T17:47:31Z",
                "user": "stamminator"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-04-07T07:50:38Z",
                "user": "tpatel6"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-08-29T21:45:01Z",
                "user": "aokellermann"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-09-20T08:03:12Z",
                "user": "daiplusplus"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-10-04T20:06:37Z",
                "user": "nhwilly"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-03-01T16:39:39Z",
                "user": "MSACATS"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-06-02T22:13:56Z",
                "user": "jeremycook"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-07-24T22:39:37Z",
                "user": "Greenscreener"
              }
            ],
            "totalCount": 11,
            "endCursor": "Y3Vyc29yOnYyOpHODraZeg=="
          },
          "updatedAt": "2022-01-29T22:47:38Z",
          "id": "IC_kwDODI9FZc49GEZh"
        },
        {
          "author": "eiriktsarpalis",
          "body": "We won't have time to work on this for .NET 7, moving to future.",
          "createdAt": "2022-05-10T16:54:46Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "CONFUSED",
                "createdAt": "2022-06-10T14:30:13Z",
                "user": "MithrilMan"
              },
              {
                "content": "CONFUSED",
                "createdAt": "2022-08-03T14:19:53Z",
                "user": "sethpjacobs"
              },
              {
                "content": "CONFUSED",
                "createdAt": "2022-08-29T21:45:24Z",
                "user": "aokellermann"
              },
              {
                "content": "CONFUSED",
                "createdAt": "2022-09-18T23:59:15Z",
                "user": "douglasg14b"
              },
              {
                "content": "CONFUSED",
                "createdAt": "2022-09-20T01:25:45Z",
                "user": "fabio-s-franco"
              },
              {
                "content": "CONFUSED",
                "createdAt": "2022-09-20T07:54:29Z",
                "user": "daiplusplus"
              },
              {
                "content": "CONFUSED",
                "createdAt": "2022-10-10T12:04:17Z",
                "user": "mr-panucci"
              },
              {
                "content": "CONFUSED",
                "createdAt": "2022-11-21T22:29:10Z",
                "user": "FarmV"
              },
              {
                "content": "CONFUSED",
                "createdAt": "2024-07-24T22:39:58Z",
                "user": "Greenscreener"
              }
            ],
            "totalCount": 9,
            "endCursor": "Y3Vyc29yOnYyOpHODraZlw=="
          },
          "updatedAt": "2022-05-10T16:54:46Z",
          "id": "IC_kwDODI9FZc5C6i_i"
        },
        {
          "author": "douglasg14b",
          "body": "This is sad and is one of just a couple features that Newtonsoft has by default that STJ does not. that continually stops us (and even other libs & frameworks) from ever using it.\n\nWe try every couple .Net versions, and have thus far been disappointed every time by how strict, to the point of blocking, it's usage continues to be when the whole point of JSON is (as others have mentioned) to be greedy.\n\nI can only hope that one day STJ becomes a drop in replacement for Newtonsoft, if ever.\n\nThough I'm not sure if reputation damage will pass for a while. Most .Net devs I work with turn up their nose to STJ by default at this point, even if it has improved, because of constant poor experiences using it :/",
          "createdAt": "2022-09-19T00:03:02Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-09-19T11:09:18Z",
                "user": "KrzysztofBranicki"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-09-19T13:40:56Z",
                "user": "aokellermann"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-09-20T07:54:44Z",
                "user": "daiplusplus"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-10-04T13:41:15Z",
                "user": "nhwilly"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-11-07T09:22:37Z",
                "user": "heron1"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-09-04T10:02:18Z",
                "user": "ntix"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-10-12T14:09:41Z",
                "user": "RafalKiszczyszyn"
              }
            ],
            "totalCount": 7,
            "endCursor": "Y3Vyc29yOnYyOpHODJcuqQ=="
          },
          "updatedAt": "2022-09-19T00:04:43Z",
          "id": "IC_kwDODI9FZc5Kh9eL"
        },
        {
          "author": "eiriktsarpalis",
          "body": "One possible solution might be to expose a flag on either `JsonSerializerOptions` or `JsonConstructorAttribute` that completely disables matching constructor parameters to property types, roughly:\r\n```C#\r\nnamespace System.Text.Json;\r\n\r\npublic class JsonSerializerOptions\r\n{\r\n     public bool RequireMatchingPropertyForConstructorParamers { get; set; } = true;\r\n}\r\n\r\npublic class JsonConstructorAttribute\r\n{\r\n     public bool RequireMatchingPropertyForConstructorParamers { get; set; } = true;\r\n}\r\n```\r\nwhich would make the following POCOs legal from a serialization perspective:\r\n```C#\r\nJsonSerializer.Deserialize<MyPoco>(\"{ ... }\"); // succeeds deserialization\r\n\r\npublic class MyPoco\r\n{\r\n    [JsonConstructor(RequireMatchingPropertyForConstructorParamers = true)]\r\n    public MyPoco(int p1, int p2, int p3) { }\r\n}\r\n```",
          "createdAt": "2022-11-10T18:19:48Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-02-27T10:06:14Z",
                "user": "fabio-s-franco"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-07-04T13:18:43Z",
                "user": "opcodewriter"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-08-21T10:37:24Z",
                "user": "KrzysztofBranicki"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-07-24T22:40:30Z",
                "user": "Greenscreener"
              }
            ],
            "totalCount": 4,
            "endCursor": "Y3Vyc29yOnYyOpHODraZtw=="
          },
          "updatedAt": "2022-11-10T18:19:48Z",
          "id": "IC_kwDODI9FZc5OH9M4"
        },
        {
          "author": "raffaeler",
          "body": "@eiriktsarpalis\r\nThe `JsonSerializerOptions` is the only possible solution as the `JsonConstructor` is definitely broken (not be available for default ctors in C# records).\r\nThe only possible alternative would be a new attribute on the type rather than on the ctor.",
          "createdAt": "2022-11-10T19:10:30Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "HEART",
                "createdAt": "2023-07-06T06:14:59Z",
                "user": "opcodewriter"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOC_-MGA=="
          },
          "updatedAt": "2022-11-10T19:10:30Z",
          "id": "IC_kwDODI9FZc5OINVj"
        },
        {
          "author": "layomia",
          "body": "[Triage] This work should include a fix for https://github.com/dotnet/runtime/issues/56999. Repro below. Also see https://github.com/dotnet/runtime/issues/56999#issuecomment-895271264.\r\n\r\n> ### Description\r\n> I would expect the below to work, however it does not. Maybe because covariant return types are new and not yet handled in System.Text.Json yet. I think the example speaks for itself but let me know if more information is required.\r\n> \r\n> ### Configuration\r\n> * Which version of .NET is the code running on? .NET 5.0\r\n> * What is the architecture (x64, x86, ARM, ARM64)? x64\r\n> * Do you know whether it is specific to that configuration? It is not.\r\n> \r\n> ### Non-working Example\r\n> Using **covariant** return type read-only properties passed through derived constructor does **not** work.\r\n> \r\n> https://dotnetfiddle.net/IsNX3q\r\n> \r\n> ```cs\r\n> using System;\r\n> using System.Text.Json;\r\n> using System.Text.Json.Serialization;\r\n> \t\t\t\t\t\r\n> public class Program\r\n> {\r\n> \tpublic static void Main()\r\n> \t{\r\n> \t\tvar json = \"{ \\\"prop\\\": { \\\"id\\\": \\\"abc\\\", \\\"num\\\": 2 } }\";\r\n> \t\tvar obj = JsonSerializer.Deserialize<DerivedClass>(json);\r\n> \t\tConsole.WriteLine(obj?.Property?.Id ?? \"null\");\r\n> \t\tConsole.WriteLine(obj?.Property?.Number?.ToString() ?? \"null\");\r\n> \t}\r\n> \t\r\n> \tpublic class BaseClass\r\n> \t{\r\n> \t\tpublic BaseClass(BaseProperty property)\r\n> \t\t{\r\n> \t\t\tProperty = property;\r\n> \t\t}\r\n> \r\n> \t\t[JsonPropertyName(\"prop\")]\r\n> \t\tpublic virtual BaseProperty Property { get; }\r\n> \t}\r\n> \t\r\n> \tpublic class DerivedClass : BaseClass\r\n> \t{\r\n> \t\tpublic DerivedClass(DerivedProperty property)\r\n> \t\t\t: base(property)\r\n> \t\t{\r\n> \t\t}\r\n> \r\n> \t\tpublic override DerivedProperty Property { get; }\r\n> \t}\r\n> \t\r\n> \tpublic class BaseProperty\r\n> \t{\r\n> \t\t[JsonPropertyName(\"id\")]\r\n> \t\tpublic string Id { get; set; }\r\n> \t}\r\n> \t\r\n> \tpublic class DerivedProperty : BaseProperty\r\n> \t{\r\n> \t\t[JsonPropertyName(\"num\")]\r\n> \t\tpublic int? Number { get; set; }\r\n> \t}\r\n> }\r\n> ```\r\n> \r\n> Output:\r\n> \r\n> ```\r\n> null\r\n> null\r\n> ```\r\n> \r\n> ### Working Example\r\n> Using **non-covariant** return type read-only properties passed through derived constructor **does** work:\r\n> \r\n> ```cs\r\n> using System;\r\n> using System.Text.Json;\r\n> using System.Text.Json.Serialization;\r\n> \t\t\t\t\t\r\n> public class Program\r\n> {\r\n> \tpublic static void Main()\r\n> \t{\r\n> \t\tvar json = \"{ \\\"prop\\\": { \\\"id\\\": \\\"abc\\\", \\\"num\\\": 2 } }\";\r\n> \t\tvar obj = JsonSerializer.Deserialize<DerivedClass>(json);\r\n> \t\tConsole.WriteLine(obj?.Property?.Id ?? \"null\");\r\n> \t}\r\n> \t\r\n> \tpublic class BaseClass\r\n> \t{\r\n> \t\tpublic BaseClass(BaseProperty property)\r\n> \t\t{\r\n> \t\t\tProperty = property;\r\n> \t\t}\r\n> \r\n> \t\t[JsonPropertyName(\"prop\")]\r\n> \t\tpublic virtual BaseProperty Property { get; }\r\n> \t}\r\n> \t\r\n> \tpublic class DerivedClass : BaseClass\r\n> \t{\r\n> \t\tpublic DerivedClass(BaseProperty property)\r\n> \t\t\t: base(property)\r\n> \t\t{\r\n> \t\t}\r\n> \t}\r\n> \t\r\n> \tpublic class BaseProperty\r\n> \t{\r\n> \t\t[JsonPropertyName(\"id\")]\r\n> \t\tpublic string Id { get; set; }\r\n> \t}\r\n> }\r\n> ```\r\n> \r\n> Output:\r\n> \r\n> ```\r\n> abc\r\n> ```\r\n\r\n",
          "createdAt": "2022-12-02T16:28:36Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-12-02T16:54:30Z",
          "id": "IC_kwDODI9FZc5Pmi8I"
        },
        {
          "author": "mathieubergouniouxcab",
          "body": "Something that no one mentioned : If the error message could at least indicate **what parameter** caused the issue then that would be the bare minimum. \r\n\r\nThis question is asked countless times in StackOverflow, it's a huge waste of time for many devs, who have to go through each parameter one by one like cavemen, and wonder : \"is it the spelling? Is it that it is nullable?\", etc.\r\n\r\n",
          "createdAt": "2023-06-22T10:37:12Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-06-22T10:37:12Z",
          "id": "IC_kwDODI9FZc5fgthU"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Hi @mathieubergouniouxcab would you be interested in contributing a PR that improves the error message?",
          "createdAt": "2023-06-22T12:57:24Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-06-22T12:57:24Z",
          "id": "IC_kwDODI9FZc5fhZvP"
        },
        {
          "author": "mathieubergouniouxcab",
          "body": "> Hi @mathieubergouniouxcab would you be interested in contributing a PR that improves the error message?\r\n\r\nHi Eirik,\r\nI'm perplexed by your answer. I thought System.Text.Json was funded by Microsoft?\r\n",
          "createdAt": "2023-06-22T13:32:11Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-06-22T13:32:11Z",
          "id": "IC_kwDODI9FZc5fhnNX"
        },
        {
          "author": "eiriktsarpalis",
          "body": "It is also an open source project that happily accepts community contributions. The team can only deliver a limited amount of features and fixes per release -- this particular issue is not slated for .NET 8 hence my suggestion.",
          "createdAt": "2023-06-22T13:37:56Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-06-22T17:24:34Z",
                "user": "terrajobst"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOC-u4xQ=="
          },
          "updatedAt": "2023-06-22T13:37:56Z",
          "id": "IC_kwDODI9FZc5fhpcX"
        },
        {
          "author": "fabio-s-franco",
          "body": "Of course not, why would it be? It is only a huge waste of time for a lot of people and people have been struggling with it for at least three years only.\r\n\r\nI have personally witnessed a fair amount of people go back to newtonsoft and miss all the other good things about this api because they did not want to put up with this anymore.\r\n\r\nI wish I had more time to go down the rabbit hole as I consider it personal and would gladly submit a PR as By far the aspect that caused more waste of my time I have ever encountered.  But since I really don't have enough time to work on this one, all it's left for now is hope.\r\n\r\nAnd with that hope that I soon get some time to spend on side projects.\r\n\r\n",
          "createdAt": "2023-06-23T12:00:05Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_DOWN",
                "createdAt": "2023-06-25T04:15:55Z",
                "user": "chrisoverzero"
              },
              {
                "content": "HEART",
                "createdAt": "2023-06-25T20:23:21Z",
                "user": "dukedagmor"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-06-26T07:19:55Z",
                "user": "mathieubergouniouxcab"
              }
            ],
            "totalCount": 3,
            "endCursor": "Y3Vyc29yOnYyOpHOC_BTJA=="
          },
          "updatedAt": "2023-06-23T12:00:55Z",
          "id": "IC_kwDODI9FZc5fnd4p"
        },
        {
          "author": "douglasg14b",
          "body": "> I have personally witnessed a fair amount of people go back to newtonsoft and miss all the other good things about this api because they did not want to put up with this anymore.\r\n\r\nThis is the norm it seems. When `System.Text.Json` doesn't have sane defaults, global configuration, extremely poor drilling ergonomics, explicitly doesn't follow the greedy pattern of Json, and fails to address fundamental QoL issues that Newtonsoft has had for ages. It's just not a good fit. It should \"Just Work\", but it doesn't, not even close. And despite community complaints & requests, feature owners just keep on push back on making it actually nice to use because it needs to be \"C#'y\"\r\n\r\nI keep trying out System.Text.Json every.single.relaease, year over year. And the same fundamental ergonomic & usability failures just keep on keeping on.\r\n\r\nThis is particularly egregious when I had a new C# dev (C++ & TS dev before) approach me yesterday and say that he really doesn't like or want to continue working with C#. His experience with System.Text.Json set the whole tone & stage for what he thinks C# is. While that is a bit premature, it's not exactly uncommon for new devs to have a terrible experience with some native support and then just write off the ecosystem entirely.\r\n\r\nIt's bad for image, it's bad for adoption, and it's bad for ergonomics. And there is *active* pressure to keep it that way, to explicitly keep it's surface area awkward and full of 'gotchas'. It should not be a default recommendation. **It's great for advanced & internal use**, don't get me wrong, but for your Java/Pythos/JS/...etc  devs poking at C# to see if they like it, it's a turnoff.\r\n\r\nPushing people to make FOSS contributions to something that has user-facing *design* issues, that are *explicit* isn't really  solution. Even moreso when one sees the graveyard of pushed-back feature requests for foundational concerns. That's gotta start at the top.\r\n\r\n**I love C#/.Net. Which is why I'm so passionate about this, it's frustrating.**\r\n\r\n/rant 😒",
          "createdAt": "2023-06-24T22:40:05Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-06-26T07:20:31Z",
                "user": "mathieubergouniouxcab"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-08-03T18:07:46Z",
                "user": "fabio-s-franco"
              },
              {
                "content": "HEART",
                "createdAt": "2023-08-03T18:07:51Z",
                "user": "fabio-s-franco"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-09-04T10:26:29Z",
                "user": "ntix"
              },
              {
                "content": "HEART",
                "createdAt": "2024-05-13T18:28:19Z",
                "user": "GMPrakhar"
              }
            ],
            "totalCount": 5,
            "endCursor": "Y3Vyc29yOnYyOpHODhpeYg=="
          },
          "updatedAt": "2023-06-24T22:49:42Z",
          "id": "IC_kwDODI9FZc5ftfQK"
        },
        {
          "author": "mathieubergouniouxcab",
          "body": "well @eiriktsarpalis I'm not going to enter the polemics, but I guess the bottled up frustration in the messages above is a good hint that maybe the logging part should be re-prioritized after 3 years (this thread started in Nov 2020) 😄 ",
          "createdAt": "2023-06-26T07:28:31Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-06-26T07:29:04Z",
          "id": "IC_kwDODI9FZc5fxt4c"
        },
        {
          "author": "KrzysztofBranicki",
          "body": "Hi, are there any plans to address problems mentioned earlier in .NET 8.0? As I described in this issue https://github.com/dotnet/runtime/issues/55318 which was closed and linked here two years ago, this serializer is not very useful for scenarios when you want to use it for serializing Aggregates modeled using Domain Driven Design principles and store them in document database. That's because it can't handled encapsulation (which is quite important in DDD :)). I would understand that the goal of creating this serializer in the first place was to create fast general purpose JSON serializer for .NET and not something that is only for serializing simple DTOs in web API endpoints.",
          "createdAt": "2023-06-26T09:46:44Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-06-26T09:48:36Z",
                "user": "plachor"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-06-26T09:49:52Z",
                "user": "grsw92"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-06-26T09:50:19Z",
                "user": "marekott"
              }
            ],
            "totalCount": 3,
            "endCursor": "Y3Vyc29yOnYyOpHOC_CS1A=="
          },
          "updatedAt": "2023-06-26T09:46:44Z",
          "id": "IC_kwDODI9FZc5fynBB"
        },
        {
          "author": "eiriktsarpalis",
          "body": "> This is the norm it seems. When `System.Text.Json` doesn't have sane defaults, global configuration, extremely poor drilling ergonomics, explicitly doesn't follow the greedy pattern of Json, and fails to address fundamental QoL issues that Newtonsoft has had for ages. It's just not a good fit. It should \"Just Work\", but it doesn't, not even close. And despite community complaints & requests, feature owners just keep on push back on making it actually nice to use because it needs to be \"C#'y\"\r\n\r\n@douglasg14b it would help if you could open issues that specifically break down the issues you are facing and we might even be able to offer recommendations, workarounds or even prioritize relevant improvements.\r\n\r\n> I'm not going to enter the polemics, but I guess the bottled up frustration in the messages above is a good hint that maybe the logging part should be re-prioritized after 3 years (this thread started in Nov 2020)\r\n\r\n@mathieubergouniouxcab the System.Text.Json backlog currently consists of [210 open issues](https://github.com/dotnet/runtime/issues?q=is%3Aissue+is%3Aopen+label%3Aarea-System.Text.Json) which we want to address at some point. While I understand the frustration of being impacted by one specific issue, we generally do try to prioritize based on impact and popularity and this issue has been cut from .NET 8.",
          "createdAt": "2023-06-26T14:01:11Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-06-26T14:01:11Z",
          "id": "IC_kwDODI9FZc5f0Vec"
        },
        {
          "author": "mathieubergouniouxcab",
          "body": "> the System.Text.Json backlog currently consists of [210 open issues]. We prioritize them based on impact and popularity\r\n\r\nUnderstood. I haven't found one specifically dealing with logging _which parameter_ is causing a deserialization fail. Could you confirm that such entry does not exist? If so, then I will create it -- in order for it to have its own thread and its own voting system (and stop polluting this one).\r\n \r\n",
          "createdAt": "2023-06-26T14:33:11Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-06-26T14:33:11Z",
          "id": "IC_kwDODI9FZc5f0k7e"
        },
        {
          "author": "eiriktsarpalis",
          "body": "AFAIK you're the first to bring up that concern. I think it's reasonable to factor into a separate issue since it's of much smaller scope.",
          "createdAt": "2023-06-26T14:42:55Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-06-26T14:42:55Z",
          "id": "IC_kwDODI9FZc5f0pjg"
        },
        {
          "author": "mathieubergouniouxcab",
          "body": "> AFAIK you're the first to bring up that concern. I think it's reasonable to factor into a separate issue since it's of much smaller scope.\r\n\r\nI found 8+ entries in your bug tracker related to the error \"Each parameter in constructor (...) must bind to a field on deserialization\". Devs so obsessed with grinding the issues one by one that they forgot it's 1,000 different flavours of the same issue. https://i.imgur.com/B0St5fv.png",
          "createdAt": "2023-06-26T14:47:21Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-06-26T14:47:43Z",
          "id": "IC_kwDODI9FZc5f0rer"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Care to share the issues that specifically requests this concern?\r\n\r\n> Something that no one mentioned : If the error message could at least indicate what parameter caused the issue then that would be the bare minimum.",
          "createdAt": "2023-06-26T14:51:26Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-06-26T14:51:26Z",
          "id": "IC_kwDODI9FZc5f0tUk"
        },
        {
          "author": "mathieubergouniouxcab",
          "body": "> Care to share the issues that specifically requests this concern?\r\n\r\nThe google query I used : \r\n\r\n`site:https://github.com/dotnet/runtime/issues/   Each parameter in constructor must bind to an object property or field on deserialization`\r\n\r\nI only clicked on the 8 first ones but there's 20+. \r\nHere are some metrics to evaluate the impact : \r\n- Most of them complain that the **typing** is too strict (e.g. fails to recognize that a List can be deserialized as a IEnumerable )\r\n- very few mention issues witht he parameter's **name**. But imho it's a classic case of [survivor bias](https://www.trevorbragdon.com/when-data-gives-the-wrong-solution/), as in : we see only the \"valid\" issues that made it to the tracker. We don't see the stupid ones, e.g. typos in parameters names, even though they took just as long to spot and fix.\r\n",
          "createdAt": "2023-06-26T14:58:37Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-06-26T15:39:46Z",
          "id": "IC_kwDODI9FZc5f0wVA"
        },
        {
          "author": "eiriktsarpalis",
          "body": "What is the point you are trying to make? Most of the issues in that query are closed which means that either the error string appears tangentially or the issue has been closed as duplicate of the very issue we are discussing in right now. ",
          "createdAt": "2023-06-26T15:08:22Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-06-26T15:08:22Z",
          "id": "IC_kwDODI9FZc5f01N0"
        },
        {
          "author": "mathieubergouniouxcab",
          "body": "Precisely. They are duplicates. Which means the **same** issue keeps coming back like a boomerang because users are not sure if it's by design and report it as a bug, when a clearer message would help.\r\n\r\nSo anyways, here's the issue created : \r\nhttps://github.com/dotnet/runtime/issues/88048\r\n\r\n",
          "createdAt": "2023-06-26T15:23:36Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "CONFUSED",
                "createdAt": "2023-06-26T15:28:24Z",
                "user": "eiriktsarpalis"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOC_EkRA=="
          },
          "updatedAt": "2023-06-27T07:30:29Z",
          "id": "IC_kwDODI9FZc5f08c3"
        },
        {
          "author": "eiriktsarpalis",
          "body": "> Precisely. They are duplicates. Which means the same issue keeps coming back like a boomerang because devs are not sure if it's by design, when a clearer message would help.\r\n\r\nWhat exactly are you proposing? That we stop closing duplicates so that it somehow makes the issue more pronounced or discoverable? That never works in practice. When we close a duplicate we link to the original issue and encourage folks to upvote and contribute there.",
          "createdAt": "2023-06-26T15:34:38Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-06-26T15:34:38Z",
          "id": "IC_kwDODI9FZc5f1Ar9"
        },
        {
          "author": "mathieubergouniouxcab",
          "body": "> What exactly are you proposing? That we stop closing duplicates ?\r\n\r\nNo, I'm not suggesting anything. I think a misunderstanding happened at some point in the recent messages. Let's move on: I'm done with this topic, I'm interested only in the error message, as you saw in #88048 . I'll stop polluting this thread now. Thanks for the time and efforts! <3",
          "createdAt": "2023-06-26T15:37:34Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-06-26T15:40:39Z",
                "user": "eiriktsarpalis"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-01-14T12:59:42Z",
                "user": "MaximKitsenko"
              }
            ],
            "totalCount": 2,
            "endCursor": "Y3Vyc29yOnYyOpHODSfsBA=="
          },
          "updatedAt": "2023-06-26T15:38:06Z",
          "id": "IC_kwDODI9FZc5f1B2b"
        },
        {
          "author": "Greenscreener",
          "body": "Hi! \r\n\r\nSince this has been silent for over a year, I thought I might chip in with my current use case.\r\n\r\nI'm currently working with an API, that looks like this:\r\n```json\r\n{\r\n  \"content\": { ... },\r\n  \"type\": \"text\"\r\n}\r\n```\r\nWhere the `type` property determines the type of the object stored in the `content` property. This is somewhat similar to what is possible with [polymorphic serialization type discriminators](https://learn.microsoft.com/en-us/dotnet/standard/serialization/system-text-json/polymorphism?pivots=dotnet-8-0#polymorphic-type-discriminators), just that the type is outside the object instead of inside it. \r\n\r\nI'm trying to implement serialization of this type by adding a JsonConstructor, which receives the `content` property as a `JsonObject`. A suitable type is then picked using the `type` property and a `JsonSerializer.Serialize<Type>(obj)` is called to serialize the type. Here is the relevant snippet:\r\n\r\n```cs\r\n\tpublic record Event(\r\n\t\tEventContent content,\r\n\t\tstring type\r\n\t) {\r\n\t\t[JsonConstructor]\r\n\t\tpublic Event(JsonObject content, string type) : this(EventContent.FromJSON(type, content), type) {}\r\n\t};\r\n```\r\n\r\nThis is exactly the case where I'd need a \"I know what I'm doing\" mode, since the parameters will never, by design, match.\r\n\r\nI find somewhat fascinating that adding a toggle like is so much work it couldn't be done in two versions, but I digress.\r\n\r\nPS: If anyone has any idea for a workaround, it would help me a lot. If you're interested, here's the whole file where the issue lies: https://gitlab.com/Greenscreener/matrix-dotnet/-/blob/master/MatrixApi.cs?ref_type=heads",
          "createdAt": "2024-07-24T22:47:16Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-07-24T22:47:16Z",
          "id": "IC_kwDODI9FZc6GDU7c"
        },
        {
          "author": "Greenscreener",
          "body": "FYI: I've found a workaround, but I find it incredibly ugly:\r\n\r\n```cs\r\n\tpublic record Event {\r\n\t\t[JsonIgnore]\r\n\t\tpublic EventContent content {get;}\r\n\t\t[JsonPropertyName(\"content\")]\r\n\t\tpublic JsonObject _content {init; private get;}\r\n\t\tpublic string type {get;}\r\n\t\t\r\n\t\tpublic Event(JsonObject _content, string type) {\r\n\t\t\tthis.content = EventContent.FromJSON(type, _content);\r\n\t\t\tthis._content = _content;\r\n\t\t\tthis.type = type;\r\n\t\t}\r\n\t}\r\n```\r\n\r\nEDIT: This does not work for serialization, oh well, back to the drawing board.",
          "createdAt": "2024-07-25T23:31:54Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-07-26T08:11:31Z",
          "id": "IC_kwDODI9FZc6GNDWU"
        },
        {
          "author": "Timovzl",
          "body": "@Greenscreener To complete the workaround to include serialization, could you perhaps use a calculated `_content` getter that serializes `content` based on `type`? Very annoyingly, you'd lose the outer serialization options, but it could be better than nothing.",
          "createdAt": "2024-07-30T08:49:50Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-07-30T08:49:50Z",
          "id": "IC_kwDODI9FZc6Gk47J"
        },
        {
          "author": "Greenscreener",
          "body": "@Timovzl I ended up writing a huge custom converter that handles my entire use case, FWIW, here's the source: https://gitlab.com/Greenscreener/matrix-dotnet/-/blob/master/PolymorphicJson.cs?ref_type=heads",
          "createdAt": "2024-07-30T18:20:45Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-07-30T18:20:45Z",
          "id": "IC_kwDODI9FZc6GpL09"
        },
        {
          "author": "terrajobst",
          "body": "@Greenscreener\r\n\r\n> EDIT: This does not work for serialization, oh well, back to the drawing board.\r\n\r\nA custom converter (like what you have now) is probably the cleanest solution. But for the record, you could achieve your scenario also like this:\r\n\r\n```JSONC\r\n{\r\n  \"content\": { /* ... */ },\r\n  \"type\": \"text\"\r\n}\r\n```\r\n\r\nIf the type is read-only/immutable the following would work:\r\n\r\n```C#\r\nclass DataHolder\r\n{\r\n    public DataHolder(string type, JsonObject content)\r\n    {\r\n        Type = type;\r\n        ContentJson = content;\r\n        Content = GetObjectForJson(type, content);\r\n    }\r\n\r\n    public string Type { get; }\r\n\r\n    [JsonProperty(\"content\")]\r\n    [EditorBrowsable(EditorBrowsableState.Never)]\r\n    public JsonObject ContentJson { get; }\r\n\r\n    [JsonIgnore]\r\n    public object Content { get; }\r\n\r\n    private object GetObjectForJson(string type, JsonObject content)\r\n    {\r\n        // custom logic\r\n    }\r\n}\r\n```\r\n\r\nIf the type is meant to be mutable, I'd go with something like this:\r\n\r\n```C#\r\nclass DataHolder\r\n{\r\n    private string _type;\r\n    private JsonObject _contentJson;\r\n    private object _content;\r\n\r\n    [JsonConstructor]\r\n    public DataHolder(string type, JsonObject content)\r\n    {\r\n        _type = type;\r\n        _contentJson = content;\r\n        _content = GetObjectForJson(type, content);\r\n    }\r\n\r\n    public DataHolder(object content)\r\n    {\r\n        _type = GetTypeForObject(content);\r\n        _contentJson = GetJsonForObject(content);\r\n        _content = content;\r\n    }\r\n\r\n    public string Type => _type;\r\n\r\n    [JsonProperty(\"content\")]\r\n    [EditorBrowsable(EditorBrowsableState.Never)]\r\n    public JsonObject ContentJson => _contentJson;\r\n\r\n    [JsonIgnore]\r\n    public object Content\r\n    {\r\n        get;\r\n        set \r\n        {\r\n            _type = GetTypeForObject(value);\r\n            _contentJson = GetObjectForJson(value);\r\n            _content = value;\r\n        }\r\n    }\r\n\r\n    private static object GetObjectForJson(string type, JsonObject content)\r\n    {\r\n        // custom logic\r\n    }\r\n\r\n    private static string GetTypeForObject(object content)\r\n    {\r\n        // custom logic \r\n    }\r\n\r\n    private static JsonObject GetJsonForObject(object content)\r\n    {\r\n        // custom logic \r\n    }\r\n}\r\n```",
          "createdAt": "2024-07-30T21:45:05Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "HEART",
                "createdAt": "2024-07-30T21:48:52Z",
                "user": "Greenscreener"
              },
              {
                "content": "HEART",
                "createdAt": "2024-08-05T22:30:07Z",
                "user": "DemoBytom"
              }
            ],
            "totalCount": 2,
            "endCursor": "Y3Vyc29yOnYyOpHODs5DZw=="
          },
          "updatedAt": "2024-07-30T21:45:05Z",
          "id": "IC_kwDODI9FZc6GqaNV"
        },
        {
          "author": "Timovzl",
          "body": "Without a custom converter, the issue remains that the (de)serialization logic will not receive the `JsonSerializerOptions` being used by the outer serializer. When serializing, the output format of the inner JSON may then mismatch in casing, enum representation, custom conversions, etc. When deserializing, the result may be incorrect or incomplete.",
          "createdAt": "2024-08-01T13:34:22Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-08-01T13:34:22Z",
          "id": "IC_kwDODI9FZc6G45sx"
        },
        {
          "author": "terrajobst",
          "body": "> Without a custom converter, the issue remains that the (de)serialization logic will not receive the `JsonSerializerOptions` being used by the outer serializer. When serializing, the output format of the inner JSON may then mismatch in casing, enum representation, custom conversions, etc. When deserializing, the result may be incorrect or incomplete.\r\n\r\nThat's right. Generally speaking, here is how to think about it:\r\n\r\n1. If you want quick way to tweak the result types by wrapping or restructuring the data, the property approach will work. However, this generally assumes that you either need custom serialization logic that is independent of the outer serialization (e.g. a custom format) or you just don't like the managed presentation (e.g. instead of an array of objects you want to return some custom type that the serializer can't easily construct).\r\n\r\n2. If you want to recurse into the serializer, then you almost always want a custom converter. It's the only way to access the serialization options and/or ask nested data to go through the same serializer.",
          "createdAt": "2024-08-05T21:53:26Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-08-05T21:53:41Z",
          "id": "IC_kwDODI9FZc6HTTcS"
        },
        {
          "author": "fabio-s-franco",
          "body": "Is there still a point to this thread? It seems a bit of a waste of time. People continue to pitch in, spending their time on something that gets no serious attention. It's better to just mark it as not planned rather than pushing for 4 years. I have done what any sane person that touched this would do: Look for a better alternative. \r\nI have abandoned the usage of this API for over a year now, it is not worth the frustration and the amount of friction it creates within teams.\r\nThere were a bunch of enhancements to json serialization and deserialization, but what is the point if usability is not addressed. If people are pushed away from using it, then enhancements are made for a niche that stayed with it. I don't know how adoption is nowadays, and keep watching this thread, but I my feeling is that it hasn't gotten more popular since.",
          "createdAt": "2024-08-06T16:55:07Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-08-06T19:28:58Z",
                "user": "KrzysztofBranicki"
              },
              {
                "content": "CONFUSED",
                "createdAt": "2024-08-07T15:47:31Z",
                "user": "eiriktsarpalis"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-09-10T16:57:16Z",
                "user": "LeszekKalibrate"
              }
            ],
            "totalCount": 3,
            "endCursor": "Y3Vyc29yOnYyOpHODxtVig=="
          },
          "updatedAt": "2024-08-06T16:55:07Z",
          "id": "IC_kwDODI9FZc6HZ-OD"
        },
        {
          "author": "eiriktsarpalis",
          "body": "While the existing restriction is well-intentioned in that it ensures that users don't write models that are not round-tripable, it's pretty painful in the cases where it doesn't work. We could try to make the matching algorithm smarter so that similarly shaped types are considered equivalent, however I doubt this would be addressing the problem completely. There are many cases where a mismatch could be intentional (e.g. because the type is only used for deserialization).\r\n\r\nI think the best course of action is to expose a switch that disables constructor parameter matching for a given type, or globally.\r\n\r\n## API Proposal\r\n\r\n```diff\r\nnamespace System.Text.Json.Serialization;\r\n\r\npublic partial class JsonConstructorAttribute\r\n{\r\n+   public bool DisableParameterMatching { get; set; }\r\n}\r\n```\r\nAnd for the global variant:\r\n```diff\r\nnamespace System.Text.Json;\r\n\r\npublic partial class JsonSerializerOptions\r\n{\r\n+   public bool DisableConstuctorParameterMatching { get; set; }\r\n}\r\n\r\nnamespace System.Text.Json.Serialization;\r\n\r\npublic partial class JsonSourceGenerationOptionsAttribute\r\n{\r\n+   public bool DisableConstuctorParameterMatching { get; set; }\r\n}\r\n```\r\n\r\n## API Usage\r\n\r\n```C#\r\nJsonSerializer.Deserialize<MyPoco>(\"\"\"{\"x\" : 1, \"y\" : 2 }\"\"\"); // Succeeds\r\n\r\npublic class MyPoco\r\n{\r\n     [JsonConstructor(DisableParameterMatching = true)]\r\n     public MyPoco(int x, int y) { }\r\n}\r\n```",
          "createdAt": "2024-08-07T16:00:59Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-08-08T08:28:07Z",
                "user": "Timovzl"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHODtPEWQ=="
          },
          "updatedAt": "2024-08-07T16:00:59Z",
          "id": "IC_kwDODI9FZc6Hh58y"
        },
        {
          "author": "raffaeler",
          "body": "@eiriktsarpalis This was indeed the [initial proposal](https://github.com/dotnet/runtime/issues/44428#issuecomment-767217872): \r\nPlease ensure to add a global option in the `JsonSerializerOptions` (the proposed property was `ConstructorUseRelaxedPropertyMatching `) so that we can use it without attribute decoration.\r\nPlease also consider [this comment](https://github.com/dotnet/runtime/issues/44428#issuecomment-976231860).",
          "createdAt": "2024-08-07T16:15:21Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-08-07T16:34:36Z",
                "user": "eiriktsarpalis"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-08-07T18:30:13Z",
                "user": "zeroskyx"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-08-08T08:28:10Z",
                "user": "Timovzl"
              }
            ],
            "totalCount": 3,
            "endCursor": "Y3Vyc29yOnYyOpHODtPEXw=="
          },
          "updatedAt": "2024-08-07T16:15:21Z",
          "id": "IC_kwDODI9FZc6HiAe5"
        },
        {
          "author": "terrajobst",
          "body": "@eiriktsarpalis \r\n\r\n> While the existing restriction is well-intentioned in that it ensures that users don't write models that are not round-tripable\r\n\r\nCould you explain what this means? Naively, I'd say that as long as there is an implicit conversion from the property type to the parameter type round-tripping is guaranteed by the constructor. For example, if the parameter is nullable and the property isn't or if the parameter is `IEnumerable<T>` but the property is `T[]` or `ImmutableArray<T>`. There is, of course, cost to check for that, but the check would only execute where it currently fails the type comparison checks, so it won't regress the most common cases.\r\n\r\nPersonally, I'd hate to see an opt-in for this feature. I guess an opt-out would be reasonable, but it seems weird given that the alternative is throwing an error.",
          "createdAt": "2024-08-07T18:23:39Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-08-07T18:30:21Z",
                "user": "zeroskyx"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-08-07T19:24:21Z",
                "user": "KrzysztofBranicki"
              }
            ],
            "totalCount": 2,
            "endCursor": "Y3Vyc29yOnYyOpHODtKxGQ=="
          },
          "updatedAt": "2024-08-07T18:23:39Z",
          "id": "IC_kwDODI9FZc6Hi4Q9"
        },
        {
          "author": "eiriktsarpalis",
          "body": "> > While the existing restriction is well-intentioned in that it ensures that users don't write models that are not round-tripable\r\n> \r\n> Could you explain what this means? Naively, I'd say that as long as there is an implicit conversion from the property type to the parameter type round-tripping is guaranteed by the constructor.\r\n\r\nI think it's reasonable to relax the restriction on the basis of a type relationship (allow constructor parameters that are assignable/convertible from the corresponding property parameter, on the basis of the principle that valid deserialization inputs should be a superset of the valid serialization outputs). My point though is that the problem extends beyond the narrow scope of subtyping, for example one might reasonably expect that this is a valid model:\r\n```C#\r\npublic class MyPoco(IEnumerable<IEnumerable<string>> tokens)\r\n{\r\n    public ImmutableArray<ImmutableArray<string>> Tokens { get; } = tokens.Select(x => x.ToImmutableArray()).ToImmutableArray();\r\n}\r\n```\r\nIn which case there is no type relationship, even though structurally speaking the parameter and property types are equivalent.",
          "createdAt": "2024-08-08T08:17:19Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-08-08T08:17:19Z",
          "id": "IC_kwDODI9FZc6HnTQd"
        },
        {
          "author": "terrajobst",
          "body": "> for example one might reasonably expect that this is a valid model:\r\n\r\nThat's fair, but I think this would violate our stated goal because it can't be roundtripped (and as far as I can tell nobody is asking for that yet).\r\n\r\nI suspect our solution probably needs to support more than `Type.IsAssignableFrom`, specifically handle conversion operators.",
          "createdAt": "2024-08-08T17:32:17Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-08-08T17:33:32Z",
          "id": "IC_kwDODI9FZc6Hrgrs"
        },
        {
          "author": "eiriktsarpalis",
          "body": "> That's fair, but I think this would violate our stated goal because it can't be roundtripped\r\n\r\nWhy not? The shapes of the two types are equivalent.\r\n\r\n> (and as far as I can tell nobody is asking for that yet).\r\n\r\nWe've had a few duplicates historically asking for variations of the same thing. I'm not saying we should actually build this, the point is we should have an \"I know what I'm doing\" mode that disables matching altogether.\r\n\r\n> suspect our solution probably needs to support more than Type.IsAssignableFrom, specifically handle conversion operators.\r\n\r\nI think that's fair, although it will be tricky to implement full parity with language semantics using reflection.",
          "createdAt": "2024-08-08T17:38:44Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-08-08T17:38:44Z",
          "id": "IC_kwDODI9FZc6HrjNq"
        },
        {
          "author": "terrajobst",
          "body": "> I'm not saying we should actually build this, the point is we should have an \"I know what I'm doing\" mode that disables matching altogether.\r\n\r\nI think I'm missing how this would work? It seems if the values the constructor accepts can't be derived in an automatic fashion from the properties, then round tripping will fail. Having an expert mode wouldn't change that, right?",
          "createdAt": "2024-08-08T17:44:14Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-08-08T17:44:14Z",
          "id": "IC_kwDODI9FZc6HrlWL"
        },
        {
          "author": "eiriktsarpalis",
          "body": "That's correct, however oftentimes this might be desirable (e.g. because the type is binding model so we only care about deserialization). At the same time, parameter matching itself doesn't offer any strong guarantees wrt round tripping properties, there are many reasons why it might still fail for a particular model (abstract types, non-public constructors).",
          "createdAt": "2024-08-08T18:33:09Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-08-08T18:33:09Z",
          "id": "IC_kwDODI9FZc6Hr4Sg"
        },
        {
          "author": "LeszekKalibrate",
          "body": "4 years later and still simple deserialization, assign value for nullable param in ctor when there is non nullable field/property is not working.",
          "createdAt": "2024-09-10T17:01:10Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-09-10T18:13:14Z",
                "user": "JSkimming"
              },
              {
                "content": "HEART",
                "createdAt": "2024-09-11T07:40:07Z",
                "user": "dukedagmor"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-09-14T17:21:46Z",
                "user": "jolexxa"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-10-05T22:54:13Z",
                "user": "NullQubit"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-04-24T10:54:08Z",
                "user": "JarFrank"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-04-30T05:41:12Z",
                "user": "douglasg14b"
              },
              {
                "content": "HEART",
                "createdAt": "2025-04-30T05:41:12Z",
                "user": "douglasg14b"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-05-07T22:44:00Z",
                "user": "frankdevelopr"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-07-13T08:09:01Z",
                "user": "FarmV"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-07-22T11:37:03Z",
                "user": "KrzysztofBranicki"
              }
            ],
            "totalCount": 10,
            "endCursor": "Y3Vyc29yOnYyOpHOEbclHw=="
          },
          "updatedAt": "2024-09-10T17:12:56Z",
          "id": "IC_kwDODI9FZc6LkGYo"
        },
        {
          "author": "NullQubit",
          "body": "> 4 years later and still simple deserialization, assign value for nullable param in ctor when there is non nullable field/property is not working.\r\n\r\nNot only that, this is also not working, which is extremely surprising to me\r\n\r\n```\r\npublic class Book\r\n{\r\n    public IReadOnlyList<string> Pages { get; }\r\n\r\n    public Book(IEnumerable<string> pages)\r\n    {\r\n        Pages = pages.ToList().AsReadOnly();\r\n    }\r\n}\r\n```\r\n\r\n",
          "createdAt": "2024-10-05T23:04:33Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-01-02T20:47:31Z",
                "user": "mirekkukla"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-04-03T02:01:48Z",
                "user": "barjonas"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-04-24T10:54:07Z",
                "user": "JarFrank"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-05-07T22:44:11Z",
                "user": "frankdevelopr"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-05-08T16:45:45Z",
                "user": "MithrilMan"
              }
            ],
            "totalCount": 5,
            "endCursor": "Y3Vyc29yOnYyOpHOERW_Lg=="
          },
          "updatedAt": "2024-10-05T23:04:54Z",
          "id": "IC_kwDODI9FZc6OxCvH"
        },
        {
          "author": "barjonas",
          "body": "Without `JsonContructor`, there's no clean way to stop the constructor from (rightly) complaining that some properties might still be null. With it, for now, there's no way to tolerate incomplete data. What if someone changed the locks while you were on your round trip?\n\nConsider this class:\n\n```csharp\n[method: JsonConstructor]\npublic class Animal(string? name, int? legCount, bool? hasLegs, Subphyla? subphyla, ImmutableArray<double>? toothSizes)\n{\n    public Animal(string name) : this(name, null, null, null, null) {}\n    public string Name { get; set; } = \n        name ?? throw new Exception(\"All animals must have a name\");\n    public bool HasLegs { get; set; } = \n        hasLegs ?? (!legCount.HasValue || legCount > 0); //Migrate legacy property legCount\n    public Subphyla Subphyla { get; set; } = \n        subphyla.HasValue && Enum.IsDefined<Subphyla>(subphyla.Value) ? subphyla.Value : Subphyla.Mammal;\n    public ImmutableArray<double> ToothSizes { get; set; } = \n        toothSizes ?? [];\n}\n```\nI don't know of a more terse way to achieve all this:\n1. Define some values as optional, providing a default if missing.\n2. Define other values as mandatory, throwing a rich exception if missing.\n3. Stand up to null state analysis.\n4. Provide migration logic from serialized data from past versions.\n5. Avoid unnecessary assignments of default values just in case they're not set by the deserializer.\n\nIt also supports inheritance and nesting very naturally and integrates well with logic to create new objects away from deserialization. I use this everywhere for settings, where version upgrades often mean new settings being introduced that will not be present in old data.\n\nBy adding the `JsonConstructor` attribute, I'm declaring that _I'm_ taking responsibility for declaring what inputs I'm expecting from the serial data and how they're going to map to my object. Nobody is adding that attribute by mistake or because it was the default template. I would expect the deserilaizer for a `Type` to look for a `JsonConstructor` first. If it finds one, why bother wasting cycles looking any further? What else would it need to know? What is the class of bug it's protecting me from? If all non-nullable parameters in the `JsonConstructor` are found in the serial data, round trip is **done** ✅ Pass nulls for nullable parameters that weren't matched and move let me deal with it! If I have a non-nullable parameter that is not found in the data then _that's_ the time for an exception.\n\n",
          "createdAt": "2025-04-03T17:28:27Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-04-03T17:42:56Z",
          "id": "IC_kwDODI9FZc6lfb4w"
        },
        {
          "author": "KrzysztofBranicki",
          "body": "@eiriktsarpalis are there any plans to address this issue in the near future? ",
          "createdAt": "2025-07-22T11:39:20Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-07-22T12:19:49Z",
                "user": "raffaeler"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOEbc52A=="
          },
          "updatedAt": "2025-07-22T11:39:20Z",
          "id": "IC_kwDODI9FZc646he8"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Not immediately, no. Sorry.",
          "createdAt": "2025-07-22T11:41:30Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-07-22T11:41:30Z",
          "id": "IC_kwDODI9FZc646jA3"
        }
      ],
      "totalCount": 75,
      "endCursor": "Y3Vyc29yOnYyOpHOX9MFQA=="
    },
    "url": "https://github.com/dotnet/runtime/issues/44428",
    "title": "[JsonSerializer] Relax restrictions on ctor param type to immutable property type matching where reasonable"
  },
  {
    "author": "mattchidley",
    "labels": [
      "bug",
      "area-System.Text.Json"
    ],
    "createdAt": "2020-12-15T19:43:58Z",
    "body": "### Description\r\n\r\nI have a List of objects whose constructors take 'in' parameters of DateTime and TimeSpan.\r\n\r\n```c#\r\npublic class TestClass\r\n    {\r\n        public TestClass(in DateTime dateTime, in TimeSpan timeSpan)\r\n        {\r\n            DateTime = dateTime;\r\n            TimeSpan = timeSpan;\r\n        }\r\n\r\n        public DateTime DateTime { get; set; }\r\n\r\n        public TimeSpan TimeSpan { get; set; }\r\n    }\r\n```\r\n    \r\nWhen serializing a list of these objects, I am seeing the exception in the title being thrown:\r\n\r\n![image](https://user-images.githubusercontent.com/32843265/102264291-6cdf3d80-3ee3-11eb-91c4-bf0d7f2b556b.png)\r\n\r\n![image](https://user-images.githubusercontent.com/32843265/102264313-77013c00-3ee3-11eb-8325-2357f8bc0a95.png)\r\n\r\nThis is specifically being thrown at IEnumerableDefaultConverter.cs line 255:\r\n\r\n`state.Current.DeclaredJsonPropertyInfo = state.Current.JsonClassInfo.ElementClassInfo!.PropertyInfoForClassInfo;`\r\n\r\nUnfortunately I have absolutely no clue what the issue is here. I'm hoping you might be able to help.",
    "number": 46088,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "EYES",
          "createdAt": "2023-07-30T14:27:06Z",
          "user": "akurone"
        }
      ],
      "totalCount": 1,
      "endCursor": "Y3Vyc29yOnYyOpHOCxoAFA=="
    },
    "updatedAt": "2022-09-29T18:05:46Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": "Dotnet-GitSync-Bot",
          "body": "I couldn't figure out the best area label to add to this issue. If you have write-permissions please help me learn by adding exactly one [area label](https://github.com/dotnet/runtime/blob/master/docs/area-owners.md).",
          "createdAt": "2020-12-15T19:44:00Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2020-12-15T19:44:00Z",
          "id": "MDEyOklzc3VlQ29tbWVudDc0NTUyMzMzMQ=="
        },
        {
          "author": "GrabYourPitchforks",
          "body": "Looks like _System.Text.Json_ doesn't understand byrefs as ctor arguments? You can work around this for now by removing the `in` keyword from your ctor parameters.",
          "createdAt": "2020-12-16T01:28:52Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2020-12-16T01:28:52Z",
          "id": "MDEyOklzc3VlQ29tbWVudDc0NTcwNDAxNg=="
        },
        {
          "author": "ilanb1996",
          "body": "Hi @GrabYourPitchforks\r\nIm looking for an issue to take as my fist contribution and stumbled upon this issue.\r\nDo you think its ok if i take it on me?",
          "createdAt": "2021-04-18T20:54:22Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-04-18T20:54:22Z",
          "id": "MDEyOklzc3VlQ29tbWVudDgyMjA1OTY5Mg=="
        },
        {
          "author": "GrabYourPitchforks",
          "body": "@layomia - thoughts?",
          "createdAt": "2021-04-18T22:56:33Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-04-18T22:56:33Z",
          "id": "MDEyOklzc3VlQ29tbWVudDgyMjA3NjY4OA=="
        },
        {
          "author": "layomia",
          "body": "@GrabYourPitchforks, @ilanb1996 sounds good, thanks! I'll assign the issue to you - please tag me with any questions.",
          "createdAt": "2021-04-19T05:09:03Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-04-19T05:51:42Z",
                "user": "ilanb1996"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOBnn41w=="
          },
          "updatedAt": "2021-04-19T05:09:03Z",
          "id": "MDEyOklzc3VlQ29tbWVudDgyMjE2OTU5OQ=="
        },
        {
          "author": "ilanb1996",
          "body": "Hey @layomia , sorry for not updating recently, had been busy with work (just started new position).\r\nI'll start working on it this week, hope ill have a failing test by Friday afternoon and then ill submit a fix.",
          "createdAt": "2021-05-04T20:51:45Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-10-22T18:26:25Z",
          "id": "MDEyOklzc3VlQ29tbWVudDgzMjIzNzIxOA=="
        },
        {
          "author": "GrabYourPitchforks",
          "body": "Congrats on your new position! 🥳\r\nPlease feel free to reach out if you need assistance with anything.",
          "createdAt": "2021-05-04T21:42:37Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-10-22T18:26:41Z",
          "id": "MDEyOklzc3VlQ29tbWVudDgzMjI2NzE1Nw=="
        },
        {
          "author": "ilanb1996",
          "body": "@GrabYourPitchforks Im trying to run the tests in the solution (im working on `System.Text.Json`) but i cant build the project from visual studio. I tried using the `build.sh` script and it worked but i want to run only the tests relevant to the code im changing from visual studio. running the tests from `build.sh` takes very long time.\r\n\r\n![image](https://user-images.githubusercontent.com/62503566/117546138-aac73480-b031-11eb-8828-f8df036a3511.png)\r\n",
          "createdAt": "2021-05-08T16:14:23Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-10-22T18:26:48Z",
          "id": "MDEyOklzc3VlQ29tbWVudDgzNTQxNjQ1Ng=="
        },
        {
          "author": "ilanb1996",
          "body": "@GrabYourPitchforks Hey just bumping the issue... ",
          "createdAt": "2021-05-21T16:20:14Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-10-22T18:26:48Z",
          "id": "MDEyOklzc3VlQ29tbWVudDg0NjA3ODAyMw=="
        },
        {
          "author": "GrabYourPitchforks",
          "body": "Apologies, didn't see your earlier message.\r\n\r\nI've seen the \"Binary stream '101' does not contain a valid BinaryHeader.\" error before. Not sure what causes it, but `git clean -xdf` and rebuilding the repo has always resolved it for me.\r\n\r\nHere's the workflow I use to run tests within a single project. The first two lines below build the runtime & libraries & unit tests (but does not run them!), and the last line runs the unit tests for the specific project I care about. (Replace the path to _-proj_ below as appropriate.)\r\n\r\n```txt\r\nbuild -s clr -c Release\r\nbuild -s libs+libs.tests -rc Release\r\nbuild -proj src\\libraries\\System.Blah\\tests\\System.Blah.Tests.csproj -rc Release -test\r\n```\r\n\r\nI believe that VS's unit test runner will start working as long as you've run the first two lines above first, then you can use the IDE.",
          "createdAt": "2021-05-21T17:18:34Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-10-22T18:26:54Z",
          "id": "MDEyOklzc3VlQ29tbWVudDg0NjExNTU3OQ=="
        },
        {
          "author": "ilanb1996",
          "body": "@GrabYourPitchforks thanks for the reply :) \r\nWhen i run the second command i get the following error:\r\n```\r\nBuild FAILED.\r\n\r\n/Users/ilan.beloglovsky/Desktop/personal/runtime/src/libraries/Microsoft.Extensions.DependencyInjection/src/ServiceLookup/CallSiteFactory.cs(252,21): Trim analysis error IL2062: Microsoft.Extensions.DependencyInjection.ServiceLookup.CallSiteFactory.TryCreateExact(ServiceDescriptor,Type,CallSiteChain,Int32): Value passed to parameter 'implementationType' of method 'Microsoft.Extensions.DependencyInjection.ServiceLookup.CallSiteFactory.CreateConstructorCallSite(ResultCache,Type,Type,CallSiteChain)' can not be statically determined and may not meet 'DynamicallyAccessedMembersAttribute' requirements. [/Users/ilan.beloglovsky/Desktop/personal/runtime/src/libraries/src.proj]\r\n/Users/ilan.beloglovsky/Desktop/personal/runtime/src/libraries/Microsoft.Extensions.DependencyInjection/src/ServiceLookup/CallSiteFactory.cs(293,17): Trim analysis error IL2062: Microsoft.Extensions.DependencyInjection.ServiceLookup.CallSiteFactory.TryCreateOpenGeneric(ServiceDescriptor,Type,CallSiteChain,Int32,Boolean): Value passed to parameter 'implementationType' of method 'Microsoft.Extensions.DependencyInjection.ServiceLookup.CallSiteFactory.CreateConstructorCallSite(ResultCache,Type,Type,CallSiteChain)' can not be statically determined and may not meet 'DynamicallyAccessedMembersAttribute' requirements. [/Users/ilan.beloglovsky/Desktop/personal/runtime/src/libraries/src.proj]\r\n```\r\nI use mac with dotnet 6.0.100-preview.3.21202.5",
          "createdAt": "2021-05-21T18:11:33Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-10-22T18:26:59Z",
          "id": "MDEyOklzc3VlQ29tbWVudDg0NjE0NDczMg=="
        },
        {
          "author": "ilanb1996",
          "body": "@GrabYourPitchforks any suggestions with the above issue?",
          "createdAt": "2021-05-30T17:47:34Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-10-22T18:27:05Z",
          "id": "MDEyOklzc3VlQ29tbWVudDg1MTAzNjE4NQ=="
        },
        {
          "author": "ilanb1996",
          "body": "So i've decided to uninstall dotnet 6 and try to use dotnet 5 instead, i used this https://docs.microsoft.com/en-us/dotnet/core/install/remove-runtime-sdk-versions?pivots=os-macos article for it but when i list the version of dotnet i get the following message\r\n`  6.0.100-preview.3.21202.5  (x64)  [Cannot uninstall version 6.0.0 and above] `\r\nIs it worth trying investigate further in this direction or the build scripts should work with dotnet 6 as well?",
          "createdAt": "2021-06-09T19:12:16Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-10-22T18:27:12Z",
          "id": "MDEyOklzc3VlQ29tbWVudDg1ODAxOTI2MA=="
        },
        {
          "author": "GrabYourPitchforks",
          "body": "@layomia do you have any thoughts on the problem the contributor is experiencing?",
          "createdAt": "2021-06-09T19:42:05Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-10-22T18:27:12Z",
          "id": "MDEyOklzc3VlQ29tbWVudDg1ODA0MTk5OA=="
        },
        {
          "author": "layomia",
          "body": "@ilanb1996 I'm surprised you were seeing trim analysis errors (https://github.com/dotnet/runtime/issues/46088#issuecomment-846144732) when running the build. @eerhardt / @joperezr is this expected?\r\n\r\nHave you synced with the latest changes from the main branch? I'd start a clean build of the latest changes from main, stick with a dotnet6 SDK, then try the steps from https://github.com/dotnet/runtime/issues/46088#issuecomment-846115579.\r\n\r\ncc @ViktorHofer in case there's further guidance on building for MacOS here.",
          "createdAt": "2021-06-09T20:12:36Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-10-22T18:27:22Z",
          "id": "MDEyOklzc3VlQ29tbWVudDg1ODA2OTUwMw=="
        },
        {
          "author": "eerhardt",
          "body": "> I'm surprised you were seeing trim analysis errors (#46088 (comment)) when running the build. @eerhardt / @joperezr is this expected?\r\n\r\nNo, you shouldn't be seeing those, assuming you have the right SDK installed.",
          "createdAt": "2021-06-09T20:42:10Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-10-22T18:27:24Z",
          "id": "MDEyOklzc3VlQ29tbWVudDg1ODA4NjI0Mw=="
        },
        {
          "author": "ViktorHofer",
          "body": "> Is it worth trying investigate further in this direction or the build scripts should work with dotnet 6 as well?\r\n\r\nThe repository actually requires that the dotnet 6.0 Preview 3 SDK is installed if you want to use tools like Visual Studio or VSCode. There are helper files and switches in the repository to avoid that global install, i.e. the dotnet.cmd/sh scripts which use a local bootstrapped SDK or the build.cmd -vs switch which opens VS with a modified path so that it again uses the locally bootstrapped SDK. But usually I would recommend to install a matching SDK globally if possible.\r\n\r\nI don't think you would be able to build individual libraries with an earlier SDK as the sdk version specified in the repo's global.json specifies the min required version that msbuild checks on.\r\n\r\n@ilanb1996 what's the current commit you're on?",
          "createdAt": "2021-06-09T20:50:57Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-10-22T18:27:30Z",
          "id": "MDEyOklzc3VlQ29tbWVudDg1ODA5MTQ0OA=="
        },
        {
          "author": "ilanb1996",
          "body": "@ViktorHofer Im on 43b1ce5d6b6",
          "createdAt": "2021-06-10T07:09:56Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-10-22T18:27:35Z",
          "id": "MDEyOklzc3VlQ29tbWVudDg1ODM3MzA0Mw=="
        },
        {
          "author": "ViktorHofer",
          "body": "> @ViktorHofer Im on 43b1ce5\r\n\r\nThanks for letting us know. Would it be possible for you to rebase onto the current main's HEAD? I assume that some of the issues that you were seeing will go away by doing so. After rebasing make sure that you do a clean build:\r\n\r\n```\r\ngit clean -xdf\r\n./build.sh clr+libs -rc Release\r\n```",
          "createdAt": "2021-06-10T07:36:54Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-06-12T10:02:36Z",
                "user": "ilanb1996"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOBuc69g=="
          },
          "updatedAt": "2021-10-22T18:27:40Z",
          "id": "MDEyOklzc3VlQ29tbWVudDg1ODM4ODk0MA=="
        },
        {
          "author": "ilanb1996",
          "body": "> > @ViktorHofer Im on [43b1ce5](https://github.com/dotnet/runtime/commit/43b1ce5d6b6218798452ea1da2941d75e6eca101)\r\n> \r\n> Thanks for letting us know. Would it be possible for you to rebase onto the current main's HEAD? I assume that some of the issues that you were seeing will go away by doing so. After rebasing make sure that you do a clean build:\r\n> \r\n> ```\r\n> git clean -xdf\r\n> ./build.sh clr+libs -rc Release\r\n> ```\r\n\r\nI did all the steps you suggested but i still cant build the project from visual studio for mac... \r\n![image](https://user-images.githubusercontent.com/62503566/121779526-ced3e380-cba4-11eb-8690-906cac9ce8bd.png)\r\nI tried restoring the nuget packages but it failed, I think they want dotnet core 6 preview 4 (i have only preview 3)\r\nthats the error:\r\n```\r\nGetting restore information for solution /Users/ilan.beloglovsky/Desktop/personal/runtime/src/libraries/System.Text.Json/System.Text.Json.sln\r\nA compatible installed .NET Core SDK for global.json version [6.0.100-preview.4.21255.9] from [/Users/ilan.beloglovsky/Desktop/personal/runtime/global.json] was not found\r\nInstall the [6.0.100-preview.4.21255.9] .NET Core SDK or update [/Users/ilan.beloglovsky/Desktop/personal/runtime/global.json] with an installed .NET Core SDK:\r\n\r\nA compatible installed .NET Core SDK for global.json version [6.0.100-preview.4.21255.9] from [/Users/ilan.beloglovsky/Desktop/personal/runtime/global.json] was not found\r\nInstall the [6.0.100-preview.4.21255.9] .NET Core SDK or update [/Users/ilan.beloglovsky/Desktop/personal/runtime/global.json] with an installed .NET Core SDK:\r\n\r\n/Applications/Visual Studio.app/Contents/Resources/lib/monodevelop/bin/MSBuild/Current/bin/NuGet.targets(163,5): error MSB4018: The \"WriteRestoreGraphTask\" task failed unexpectedly. [/var/folders/lb/7y8pln9x32b6rdv9hdz9d2cmdczs2t/T/NuGetScratch/rbxapid8.ufa.nugetinputs.targets]\r\n/Applications/Visual Studio.app/Contents/Resources/lib/monodevelop/bin/MSBuild/Current/bin/NuGet.targets(163,5): error MSB4018: NuGet.Frameworks.FrameworkException: Invalid framework identifier ''. [/var/folders/lb/7y8pln9x32b6rdv9hdz9d2cmdczs2t/T/NuGetScratch/rbxapid8.ufa.nugetinputs.targets]\r\n/Applications/Visual Studio.app/Contents/Resources/lib/monodevelop/bin/MSBuild/Current/bin/NuGet.targets(163,5): error MSB4018:   at NuGet.Frameworks.NuGetFramework.GetShortFolderName (NuGet.Frameworks.IFrameworkNameProvider mappings) [0x0006f] in <6320f402f7944f8eb51291e628b0cb3f>:0  [/var/folders/lb/7y8pln9x32b6rdv9hdz9d2cmdczs2t/T/NuGetScratch/rbxapid8.ufa.nugetinputs.targets]\r\n/Applications/Visual Studio.app/Contents/Resources/lib/monodevelop/\r\nbin/MSBuild/Current/bin/NuGet.targets(163,5): error MSB4018:   at NuGet.Frameworks.NuGetFramework.GetShortFolderName () [0x00006] in <6320f402f7944f8eb51291e628b0cb3f>:0  [/var/folders/lb/7y8pln9x32b6rdv9hdz9d2cmdczs2t/T/NuGetScratch/rbxapid8.ufa.nugetinputs.targets]\r\n/Applications/Visual Studio.app/Contents/Resources/lib/monodevelop/bin/MSBuild/Current/bin/NuGet.targets(163,5): error MSB4018:   at NuGet.ProjectModel.PackageSpecWriter.WriteMetadataTargetFrameworks (NuGet.RuntimeModel.IObjectWriter writer, NuGet.ProjectModel.ProjectRestoreMetadata msbuildMetadata) [0x00074] in <32c305740b2d40cfb589237fb6cd3658>:0  [/var/folders/lb/7y8pln9x32b6rdv9hdz9d2cmdczs2t/T/NuGetScratch/rbxapid8.ufa.nugetinputs.targets]\r\n/Applications/Visual Studio.app/Contents/Resources/lib/monodevelop/bin/MSBuild/Current/bin/NuGet.targets(163,5): error MSB4018:   at NuGet.ProjectModel.PackageSpecWriter.SetMSBuildMetadata (NuGet.RuntimeModel.IObjectWriter writer, NuGet.ProjectModel.PackageSpec packageSpec) [0x00119] in <32c305740b2d40cfb5\r\n89237fb6cd3658>:0  [/var/folders/lb/7y8pln9x32b6rdv9hdz9d2cmdczs2t/T/NuGetScratch/rbxapid8.ufa.nugetinputs.targets]\r\n/Applications/Visual Studio.app/Contents/Resources/lib/monodevelop/bin/MSBuild/Current/bin/NuGet.targets(163,5): error MSB4018:   at NuGet.ProjectModel.PackageSpecWriter.Write (NuGet.ProjectModel.PackageSpec packageSpec, NuGet.RuntimeModel.IObjectWriter writer) [0x000bf] in <32c305740b2d40cfb589237fb6cd3658>:0  [/var/folders/lb/7y8pln9x32b6rdv9hdz9d2cmdczs2t/T/NuGetScratch/rbxapid8.ufa.nugetinputs.targets]\r\n/Applications/Visual Studio.app/Contents/Resources/lib/monodevelop/bin/MSBuild/Current/bin/NuGet.targets(163,5): error MSB4018:   at NuGet.ProjectModel.DependencyGraphSpec.Write (NuGet.RuntimeModel.IObjectWriter writer, System.Action`2[T1,T2] writeAction) [0x0009b] in <32c305740b2d40cfb589237fb6cd3658>:0  [/var/folders/lb/7y8pln9x32b6rdv9hdz9d2cmdczs2t/T/NuGetScratch/rbxapid8.ufa.nugetinputs.targets]\r\n/Applications/Visual Studio.app/Contents/Resources/lib/monodevelop/bin/MSBuild/Current/bin/NuG\r\net.targets(163,5): error MSB4018:   at NuGet.ProjectModel.DependencyGraphSpec.Save (System.String path) [0x00024] in <32c305740b2d40cfb589237fb6cd3658>:0  [/var/folders/lb/7y8pln9x32b6rdv9hdz9d2cmdczs2t/T/NuGetScratch/rbxapid8.ufa.nugetinputs.targets]\r\n/Applications/Visual Studio.app/Contents/Resources/lib/monodevelop/bin/MSBuild/Current/bin/NuGet.targets(163,5): error MSB4018:   at NuGet.Build.Tasks.WriteRestoreGraphTask.Execute () [0x000e8] in <cf2b79aeaf2349769d5a80e504e6400c>:0  [/var/folders/lb/7y8pln9x32b6rdv9hdz9d2cmdczs2t/T/NuGetScratch/rbxapid8.ufa.nugetinputs.targets]\r\n/Applications/Visual Studio.app/Contents/Resources/lib/monodevelop/bin/MSBuild/Current/bin/NuGet.targets(163,5): error MSB4018:   at Microsoft.Build.BackEnd.TaskExecutionHost.Microsoft.Build.BackEnd.ITaskExecutionHost.Execute () [0x00029] in <e45f684672594c219e19c34e591a0726>:0  [/var/folders/lb/7y8pln9x32b6rdv9hdz9d2cmdczs2t/T/NuGetScratch/rbxapid8.ufa.nugetinputs.targets]\r\n/Applications/Visual Studio.app/Contents/Resources/lib/monodeve\r\nlop/bin/MSBuild/Current/bin/NuGet.targets(163,5): error MSB4018:   at Microsoft.Build.BackEnd.TaskBuilder.ExecuteInstantiatedTask (Microsoft.Build.BackEnd.ITaskExecutionHost taskExecutionHost, Microsoft.Build.BackEnd.Logging.TaskLoggingContext taskLoggingContext, Microsoft.Build.BackEnd.TaskHost taskHost, Microsoft.Build.BackEnd.ItemBucket bucket, Microsoft.Build.BackEnd.TaskExecutionMode howToExecuteTask) [0x002b9] in <e45f684672594c219e19c34e591a0726>:0  [/var/folders/lb/7y8pln9x32b6rdv9hdz9d2cmdczs2t/T/NuGetScratch/rbxapid8.ufa.nugetinputs.targets]\r\n\r\n  3.1.408 [/usr/local/share/dotnet/sdk]\r\n  3.1.409 [/usr/local/share/dotnet/sdk]\r\n  5.0.202 [/usr/local/share/dotnet/sdk]\r\n  5.0.203 [/usr/local/share/dotnet/sdk]\r\n  5.0.301 [/usr/local/share/dotnet/sdk]\r\n  6.0.100-preview.3.21202.5 [/usr/local/share/dotnet/sdk]\r\n  3.1.408 [/usr/local/share/dotnet/sdk]\r\n  3.1.409 [/usr/local/share/dotnet/sdk]\r\n  5.0.202 [/usr/local/share/dotnet/sdk]\r\n  5.0.203 [/usr/local/share/dotnet/sdk]\r\n  5.0.301 [/usr/local/share/dotnet/sdk]\r\n  6.0.100-preview.3.21202.5 [/usr/local/share/dotnet/sdk]\r\n\r\nMSBuild exited with code 1\r\n```\r\nI'll try install preview 4 and update if that helps resolve the issue",
          "createdAt": "2021-06-12T14:37:15Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-10-22T18:27:42Z",
          "id": "MDEyOklzc3VlQ29tbWVudDg2MDA2MjA4NA=="
        },
        {
          "author": "ViktorHofer",
          "body": "> I did all the steps you suggested but i still cant build the project from visual studio for mac...\r\n\r\nI encountered that issue myself and filed https://github.com/dotnet/runtime/issues/53422 to find a mitigation for it. Meanwhile I found a workaround which is to build the `System.Runtime.CompilerServices.Unsafe.ilproj` project manually once in the solution (either inside VS/VS4Mac or on the CLI) before trying to build the rest of the projects in the solution file.\r\n\r\n> I'll try install preview 4 and update if that helps resolve the issue\r\n\r\nYes, please do so. We just recently - last week - switched to depending on 6.0 Preview 4.",
          "createdAt": "2021-06-14T10:51:45Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-10-22T18:27:49Z",
          "id": "MDEyOklzc3VlQ29tbWVudDg2MDU5MDMzOA=="
        },
        {
          "author": "ilanb1996",
          "body": "> > I did all the steps you suggested but i still cant build the project from visual studio for mac...\r\n> \r\n> I encountered that issue myself and filed #53422 to find a mitigation for it. Meanwhile I found a workaround which is to build the `System.Runtime.CompilerServices.Unsafe.ilproj` project manually once in the solution (either inside VS/VS4Mac or on the CLI) before trying to build the rest of the projects in the solution file.\r\n> \r\n> > I'll try install preview 4 and update if that helps resolve the issue\r\n> \r\n> Yes, please do so. We just recently - last week - switched to depending on 6.0 Preview 4.\r\n\r\nSwitching to preview 4 didnt do anything\r\nI've noticed that `System.Runtime.CompilerServices.Unsafe.ilproj` is failing to load to the solution, could that be the source of my problems? Any idea how i make it load properly?\r\n![image](https://user-images.githubusercontent.com/62503566/121881918-8b9a8180-cd18-11eb-89e5-5c59a4558790.png)\r\n",
          "createdAt": "2021-06-14T10:56:52Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-10-22T18:27:55Z",
          "id": "MDEyOklzc3VlQ29tbWVudDg2MDU5MzEzNg=="
        },
        {
          "author": "ViktorHofer",
          "body": "> I've noticed that System.Runtime.CompilerServices.Unsafe.ilproj is failing to load to the solution, could that be the source of my problems? Any idea how i make it load properly?\r\n\r\nDo you have a log of why it's failing to load? You should be able to find that in the output window - though I never used VS4M so take that suggestion with a grain of salt...",
          "createdAt": "2021-06-14T13:00:12Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-10-22T18:28:01Z",
          "id": "MDEyOklzc3VlQ29tbWVudDg2MDY2NDU4MQ=="
        },
        {
          "author": "eiriktsarpalis",
          "body": "Out of curiosity, what should be our expected approach to fixing this? I presume the error occurs when attempting to instantiate [`SmallObjectWithParameterizedConstructorConverter<>`](https://github.com/dotnet/runtime/blob/3cc122bf0e50ef3ceb73eb368a0a5ae1676ae75b/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/Converters/Object/ObjectWithParameterizedConstructorConverter.Small.cs#L14-L22) with `DateTime&` as a type parameter. Presumably we'd have to fall back to [LargeObjectWithParameterizedConstructorConverterWithReflection](https://github.com/dotnet/runtime/blob/main/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/Converters/Object/ObjectWithParameterizedConstructorConverter.Large.Reflection.cs#L14)?",
          "createdAt": "2021-10-22T18:36:57Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-10-22T18:36:57Z",
          "id": "IC_kwDODI9FZc44nfJ-"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Once we address this issue we should make sure to re-enable the following disabled test:\r\n\r\nhttps://github.com/dotnet/runtime/blob/1a0c9cac0ae3c511a51217736e212495510e85b4/src/libraries/System.Text.Json/tests/Common/ConstructorTests/ConstructorTests.ParameterMatching.cs#L1295-L1301",
          "createdAt": "2022-08-05T20:09:27Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-08-05T20:09:27Z",
          "id": "IC_kwDODI9FZc5H7pG7"
        }
      ],
      "totalCount": 25,
      "endCursor": "Y3Vyc29yOnYyOpHOR-6Ruw=="
    },
    "url": "https://github.com/dotnet/runtime/issues/46088",
    "title": "System.Text.Json does not support constructors with byref parameters."
  },
  {
    "author": "TannerBrunscheon",
    "labels": [
      "area-System.Text.Json",
      "wishlist"
    ],
    "createdAt": "2020-12-23T21:23:02Z",
    "body": "### Description\r\nSystem.Text.Json\r\nI have the use case where I need to customize the write of a JsonConverter on certain POCOs. To accomplish this, I am using the JsonConverterFactory to make a generic JsonConverter that overwrites the write function. The issue I am running into is on the read overwrite. Since this converter is generic, it is being used for the reading and writing of the POCO. All the code I have seen is throwing a NotImplementedException on read, which bubbles up in my code. Other things I have tried is using JsonConverter. Deserialize to try to call the default converters read but that seems to reference the same read that is running causing a recursive loop. \r\n\r\n### Configuration\r\n\r\n.Net 5\r\n\r\n### Code\r\n\r\nI am using it as a decorator of a class.\r\n```\r\n[JsonConverter(typeof(JsonPropertyConverter))]\r\n\tpublic class Model\r\n```\r\nThis doesn't work\r\n```\r\nprivate class JsonConverterInner<T> : JsonConverter<T>\r\n\t\t{\r\n\t\t\tJsonSerializerOptions _options;\r\n\r\n\t\t\tpublic JsonPropertyOrderConverterInner(JsonSerializerOptions options)\r\n\t\t\t{\r\n\t\t\t\t_options = options;\r\n\t\t\t}\r\n\r\n\t\t\tpublic override T Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) \r\n\t\t\t{\r\n\t\t\t\tthrow new NotImplementedException(\"Don't use me to read JSON\");\r\n\t\t\t}\r\n\t\t\tpublic override void Write(Utf8JsonWriter writer, T value, JsonSerializerOptions options)\r\n\t\t\t{\r\n(value edits here)\r\n\t\t\t\tJsonSerializer.Serialize(writer, value, options);\r\n\t\t\t}\r\n\t\t}\r\n```\r\nThis also doesnt work\r\n```\r\npublic override T Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) =>\r\n    JsonSerializer.Deserialize<T>(ref reader, options)\r\n```",
    "number": 46372,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "EYES",
          "createdAt": "2020-12-28T01:34:35Z",
          "user": "rcollina"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-07-24T00:00:48Z",
          "user": "aradalvand"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-07-27T20:55:07Z",
          "user": "dgrechka"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-09-18T22:50:32Z",
          "user": "KoenZomers"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-10-04T13:45:08Z",
          "user": "Mohamed-Effat"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-12-18T10:53:39Z",
          "user": "Xriuk"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-02-02T10:01:31Z",
          "user": "Alikont"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-03-07T17:31:27Z",
          "user": "IanKemp"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-04-11T12:51:00Z",
          "user": "ikesnowy"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-05-14T16:06:57Z",
          "user": "aco-mreble"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-06-06T08:02:17Z",
          "user": "gbtb"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-07-11T14:04:30Z",
          "user": "julealgon"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-07-26T10:19:07Z",
          "user": "vukasinpetrovic"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-09-07T21:59:35Z",
          "user": "gavar"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-09-12T21:54:36Z",
          "user": "NateRickard"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-10-07T08:44:19Z",
          "user": "austinw-fineart"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-10-16T02:55:52Z",
          "user": "issue-dispenser"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-10-22T21:45:26Z",
          "user": "skarpovru"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-11-12T15:14:34Z",
          "user": "delixfe"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-11-18T16:17:19Z",
          "user": "luckyycode"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-02-05T15:00:38Z",
          "user": "jukkahyv"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-07-18T21:36:18Z",
          "user": "Athari"
        }
      ],
      "totalCount": 22,
      "endCursor": "Y3Vyc29yOnYyOpHODHoWTA=="
    },
    "updatedAt": "2025-07-07T20:15:51Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": "TannerBrunscheon",
          "body": "Does anyone have any idea on how to do this?",
          "createdAt": "2021-01-04T14:37:06Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-01-04T14:37:06Z",
          "id": "MDEyOklzc3VlQ29tbWVudDc1NDAxMTQ2NA=="
        },
        {
          "author": "layomia",
          "body": "Are you describing the need for a feature where a converter could indicate that only one out of the `Read` and `Write` method should be called when (de)serializing? For example, [`CanRead`](https://www.newtonsoft.com/json/help/html/P_Newtonsoft_Json_JsonConverter_CanRead.htm) and [`CanWrite`](https://www.newtonsoft.com/json/help/html/P_Newtonsoft_Json_JsonConverter_CanWrite.htm) properties from Newtosonft.Json?\r\n\r\n---\r\n\r\n> Other things I have tried is using JsonConverter. Deserialize to try to call the default converters read but that seems to reference the same read that is running causing a recursive loop.\r\n\r\nOn the recursive loop/stack overflow due to calling back into the serializer from a custom converter, please see this [doc example](https://docs.microsoft.com/dotnet/standard/serialization/system-text-json-migrate-from-newtonsoft-how-to?pivots=dotnet-5-0#required-properties).",
          "createdAt": "2021-01-25T17:33:58Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-01-25T17:33:58Z",
          "id": "MDEyOklzc3VlQ29tbWVudDc2Njk4Mzc1MQ=="
        },
        {
          "author": "layomia",
          "body": "Linking https://github.com/dotnet/runtime/issues/36785 since it addresses extensible converters.",
          "createdAt": "2021-01-25T17:35:40Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-01-25T17:35:40Z",
          "id": "MDEyOklzc3VlQ29tbWVudDc2Njk4NDc5NA=="
        },
        {
          "author": "TannerBrunscheon",
          "body": "> Are you describing the need for a feature where a converter could indicate that only one out of the Read and Write method should be called when (de)serializing? For example, CanRead and CanWrite properties from Newtosonft.Json?\r\n\r\nYeah basically I need a write only converter\r\n\r\n>On the recursive loop/stack overflow due to calling back into the serializer from a custom converter, please see this doc example.\r\n\r\nI tried doing something like \r\n```\r\npublic override T Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) =>\r\n    JsonSerializer.Deserialize<T>(ref reader)\r\n```\r\nas the docs suggest and it got caught in the loop again.\r\n",
          "createdAt": "2021-01-25T18:23:25Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-07-08T07:38:32Z",
                "user": "Rebel028"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOEZuBCg=="
          },
          "updatedAt": "2021-01-25T18:23:25Z",
          "id": "MDEyOklzc3VlQ29tbWVudDc2NzAxNzYyMg=="
        },
        {
          "author": "layomia",
          "body": "> Yeah basically I need a write only converter\r\n\r\nThanks.\r\n\r\nNoting this as a reasonable feature request. It requires extensive design, particularly around if two different converters can handle the same type (i.e one handles read, and the other handles write).",
          "createdAt": "2021-01-25T18:41:07Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-01-25T18:41:07Z",
          "id": "MDEyOklzc3VlQ29tbWVudDc2NzAyODc0MA=="
        },
        {
          "author": "layomia",
          "body": "> I tried doing something like\r\n> \r\n> public override T Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) =>\r\n>     JsonSerializer.Deserialize<T>(ref reader)\r\n> as the docs suggest and it got caught in the loop again.\r\n\r\n@TannerBrunscheon - can you please provide a full repro, showing the call to the serializer & all types in the object graph? I'm trying to understand if there's a bug here, which would likely need a separate issue to address.",
          "createdAt": "2021-01-25T18:43:26Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-01-25T18:44:04Z",
          "id": "MDEyOklzc3VlQ29tbWVudDc2NzAzMDA2MQ=="
        },
        {
          "author": "TannerBrunscheon",
          "body": "[TextJSONRepro.zip](https://github.com/dotnet/runtime/files/5874806/TextJSONRepro.zip)\r\n\r\n@layomia One thing I noticed when creating this repro is that when taking in a value, if you call Deserialize **or** Serialize on the same value that you took in, you get the same stack overflow error. I don't know why you would ever do this except in cases of read only/write only converters and thus it would be solved by adding in read only/write only converters. ",
          "createdAt": "2021-01-26T17:09:34Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-01-26T17:09:34Z",
          "id": "MDEyOklzc3VlQ29tbWVudDc2NzY4OTM0Nw=="
        },
        {
          "author": "layomia",
          "body": "@TannerBrunscheon - the workaround for the stack-overflow is to make sure that the converter that the serializer picks for the type you are passing is not the same converter that you are in. This might involve not passing the same options instance that was passed to the converter. This approach and others are documented over here: https://docs.microsoft.com/dotnet/standard/serialization/system-text-json-migrate-from-newtonsoft-how-to?pivots=dotnet-5-0#required-properties.\r\n\r\n---\r\n\r\nFor the feature to have a read or write-only converter, we can consider that for the future.",
          "createdAt": "2021-04-09T15:51:48Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-04-09T20:32:18Z",
                "user": "TannerBrunscheon"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOBmqWaQ=="
          },
          "updatedAt": "2021-04-09T15:51:48Z",
          "id": "MDEyOklzc3VlQ29tbWVudDgxNjc3ODQxMw=="
        },
        {
          "author": "eiriktsarpalis",
          "body": "> For the feature to have a read or write-only converter, we can consider that for the future.\r\n\r\nWhat would be the expected behavior of a read-only or write-only converter when we attempt to read or write, respectively? I'm guessing it would fall back to the default converter for the type? Or would it simply fail the operation?",
          "createdAt": "2022-09-02T16:12:26Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-09-02T16:12:26Z",
          "id": "IC_kwDODI9FZc5Jpv0u"
        },
        {
          "author": "adam8797",
          "body": "Any updates on this? This is quite a useful feature of Newtonsoft that is making transitioning to System.Text.Json a bit tricky in some aspects.",
          "createdAt": "2023-08-01T14:37:26Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-08-01T14:37:26Z",
          "id": "IC_kwDODI9FZc5i-J5P"
        },
        {
          "author": "eiriktsarpalis",
          "body": "You can try using the following workaround to get read-only and write-only converters with default fallback semantics (assuming you're using the reflection serializer):\r\n```C#\r\npublic abstract class ReadOnlyJsonConverter<T> : JsonConverter<T>\r\n{\r\n    private readonly JsonConverter<T> _fallbackConverter = (JsonConverter<T>)JsonSerializerOptions.Default.GetConverter(typeof(T));\r\n\r\n    public sealed override void Write(Utf8JsonWriter writer, T value, JsonSerializerOptions options)\r\n        => _fallbackConverter.Write(writer, value, options);\r\n}\r\n\r\npublic abstract class WriteOnlyJsonConverter<T> : JsonConverter<T>\r\n{\r\n    private readonly JsonConverter<T> _fallbackConverter = (JsonConverter<T>)JsonSerializerOptions.Default.GetConverter(typeof(T));\r\n\r\n    public sealed override T? Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)\r\n        => _fallbackConverter.Read(ref reader, typeToConvert, options);\r\n}\r\n```\r\nThen implement your read-only or write-only custom converter by deriving from the relevant class:\r\n```C#\r\npublic class MyIntConverter : WriteOnlyJsonConverter<int>\r\n{\r\n    public override void Write(Utf8JsonWriter writer, int value, JsonSerializerOptions options)\r\n        => writer.WriteStringValue(value.ToString(CultureInfo.InvariantCulture));\r\n}\r\n```\r\n\r\n> Any updates on this?\r\n\r\nWe have no plans on implementing built-in `CanRead` and `CanWrite` support to STJ's `JsonConverter` currently. The reason fundamentally is that it would be nontrivial to support fallback semantics for the case of the source generated serializer (which `JsonConverter` also needs to support).",
          "createdAt": "2023-08-01T15:07:21Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-02-23T12:57:31Z",
                "user": "fopsdev"
              },
              {
                "content": "EYES",
                "createdAt": "2024-07-11T09:18:18Z",
                "user": "Balkoth"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-07-26T10:19:14Z",
                "user": "vukasinpetrovic"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-10-22T21:23:48Z",
                "user": "skarpovru"
              }
            ],
            "totalCount": 4,
            "endCursor": "Y3Vyc29yOnYyOpHOD3m1ug=="
          },
          "updatedAt": "2023-08-01T15:07:21Z",
          "id": "IC_kwDODI9FZc5i-XNq"
        },
        {
          "author": "adam8797",
          "body": "@eiriktsarpalis thank you for the snippets! I'll try these out. ",
          "createdAt": "2023-08-01T15:10:37Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-08-01T15:10:37Z",
          "id": "IC_kwDODI9FZc5i-Ynz"
        },
        {
          "author": "Xriuk",
          "body": "> > For the feature to have a read or write-only converter, we can consider that for the future.\r\n> \r\n> What would be the expected behavior of a read-only or write-only converter when we attempt to read or write, respectively? I'm guessing it would fall back to the default converter for the type? Or would it simply fail the operation?\r\n\r\nCouldn't the converter simply throw NotSupportedException like said in this paragraph (and the following one)?\r\nhttps://learn.microsoft.com/en-us/dotnet/standard/serialization/system-text-json/converters-how-to?pivots=dotnet-8-0#notsupportedexception\r\n> When you want to disallow certain types, throw a NotSupportedException.\r\n\r\nI'm guessing this is (or could be) supported in both Read/Write and then the serialized would look for the next converter in the list which should be the default one.",
          "createdAt": "2023-12-18T10:59:37Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-12-18T10:59:37Z",
          "id": "IC_kwDODI9FZc5u37Zg"
        },
        {
          "author": "Balkoth",
          "body": "@eiriktsarpalis \r\nYour snippets crash with a stackoverflow exception at initializing `_fallbackConverter `.",
          "createdAt": "2024-07-11T09:19:45Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-07-08T07:41:50Z",
                "user": "Rebel028"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOEZuCxg=="
          },
          "updatedAt": "2024-07-11T09:19:45Z",
          "id": "IC_kwDODI9FZc6Ed7iH"
        },
        {
          "author": "eiriktsarpalis",
          "body": "@Balkoth you should avoid specifying the custom converter via `JsonConverterAttribute` because it creates a circular dependency. Use `JsonSerializerOptions.Converters` instead.",
          "createdAt": "2024-07-11T10:35:51Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-07-11T10:35:51Z",
          "id": "IC_kwDODI9FZc6Eeg45"
        },
        {
          "author": "Balkoth",
          "body": "But then there is no need to do it this way if you have to specify it at the location you use it. Because at this point i can just use one that does `throw NotImplementedException` as no reading is going on there.\r\n\r\nTo me this seems like basic functionality to call the default `Read` or `Write` methods in case you only need to modify one of them. And to have any positive gains it needs to be possible directly in the converter implementing `JsonConverter<T>`.",
          "createdAt": "2024-07-11T11:47:13Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-07-13T19:09:38Z",
                "user": "rebecacalazans"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-07-08T07:42:11Z",
                "user": "Rebel028"
              }
            ],
            "totalCount": 2,
            "endCursor": "Y3Vyc29yOnYyOpHOEZuC8Q=="
          },
          "updatedAt": "2024-07-11T12:41:33Z",
          "id": "IC_kwDODI9FZc6EfAJZ"
        },
        {
          "author": "eiriktsarpalis",
          "body": "> To me this seems like basic functionality to call the default Read or Write methods\r\n\r\nIt's simply not possible given the way that STJ is currently architected. Adding a `JsonConverterAttribute` annotation on a type sets the default converter for that type. There is [this issue](https://github.com/dotnet/runtime/issues/63791) that proposes exposing the built-in converter types, but this would require specifying an explicit fallback for the type you are working with.",
          "createdAt": "2024-07-11T12:47:03Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-07-11T12:47:03Z",
          "id": "IC_kwDODI9FZc6EffYq"
        },
        {
          "author": "Balkoth",
          "body": "Then make it possible? What is holding you back?\r\n\r\nThis feels like Microsoft invented virtual methods but without __super to call the base class.",
          "createdAt": "2024-07-11T12:50:38Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "LAUGH",
                "createdAt": "2025-01-31T13:38:05Z",
                "user": "thepirat000"
              },
              {
                "content": "LAUGH",
                "createdAt": "2025-07-18T21:46:32Z",
                "user": "Athari"
              }
            ],
            "totalCount": 2,
            "endCursor": "Y3Vyc29yOnYyOpHOEbJ4Iw=="
          },
          "updatedAt": "2024-07-11T12:55:49Z",
          "id": "IC_kwDODI9FZc6Efhqw"
        },
        {
          "author": "eiriktsarpalis",
          "body": "> Then make it possible? What is holding you back?\r\n\r\nOther priorities. We are currently working on issues flagged with the 9.0.0 milestone.\r\n\r\n> This feels like Microsoft invented virtual methods but without __super to call the base class.\r\n\r\nConverters use a fundamentally different composition model, so it's the not the best analogy.",
          "createdAt": "2024-07-11T13:01:29Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-07-11T13:01:29Z",
          "id": "IC_kwDODI9FZc6EfoAu"
        },
        {
          "author": "Balkoth",
          "body": "So this issue is open since Dec 2020 and googling for this problem finds lot of results without resolution, as there is none as you just confirmed. So when will this issue make it?\r\n\r\nNot being able to call the default for `Read` and `Write` is basically a showstopper. Was this never brought up when `JsonConverter<T>` was designed?",
          "createdAt": "2024-07-11T13:11:09Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-01-31T13:38:40Z",
                "user": "thepirat000"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-07-08T07:42:37Z",
                "user": "Rebel028"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-07-18T21:46:55Z",
                "user": "Athari"
              }
            ],
            "totalCount": 3,
            "endCursor": "Y3Vyc29yOnYyOpHOEbJ4UA=="
          },
          "updatedAt": "2024-07-11T13:12:52Z",
          "id": "IC_kwDODI9FZc6EftZK"
        },
        {
          "author": "eiriktsarpalis",
          "body": "> as there is none as you just confirmed.\r\n\r\nLike I said, using `JsonSerializerOptions.Converters` instead of `JsonConverterAttribute` provides the workaround that you require.\r\n\r\n> Was this never brought up when JsonConverter<T> was designed?\r\n\r\nNo library or abstraction can cater to *every* requirement. You can use the suggested workaround, or you can wait until a solution in this space is implemented.",
          "createdAt": "2024-07-11T13:42:38Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_DOWN",
                "createdAt": "2025-07-08T07:42:59Z",
                "user": "Rebel028"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOEZuDYw=="
          },
          "updatedAt": "2024-07-11T13:42:38Z",
          "id": "IC_kwDODI9FZc6Ef_Bl"
        },
        {
          "author": "julealgon",
          "body": "@Xriuk \r\n> Couldn't the converter simply throw NotSupportedException like said in this paragraph (and the following one)? https://learn.microsoft.com/en-us/dotnet/standard/serialization/system-text-json/converters-how-to?pivots=dotnet-8-0#notsupportedexception\r\n> \r\n> > When you want to disallow certain types, throw a NotSupportedException.\r\n> \r\n> I'm guessing this is (or could be) supported in both Read/Write and then the serialized would look for the next converter in the list which should be the default one.\r\n\r\nExceptions should be used for exceptional behavior. Using `NotSupportedException` to skip a converter and move to the next one would be a bad use of exceptions (also known as \"use exception as control flow\") and would also be slow due to how slow exceptions are in general. It is not a good idea to ever introduce exceptions in these flows because they can happen very frequently under normal situations.",
          "createdAt": "2024-07-11T14:13:51Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-07-11T14:13:51Z",
          "id": "IC_kwDODI9FZc6EgRTK"
        },
        {
          "author": "adam8797",
          "body": "I think @layomia had it right back in 2021 when this issue was first opened. \r\n\r\n> Are you describing the need for a feature where a converter could indicate that only one out of the `Read` and `Write` method should be called when (de)serializing? For example, [`CanRead`](https://www.newtonsoft.com/json/help/html/P_Newtonsoft_Json_JsonConverter_CanRead.htm) and [`CanWrite`](https://www.newtonsoft.com/json/help/html/P_Newtonsoft_Json_JsonConverter_CanWrite.htm) properties from Newtosonft.Json?\r\n> \r\n\r\nNewtonsoft.Json seemed to inform much of the design of this library, and they solved this issue quite simply with `CanRead` and `CanWrite` properties. I think keeping in line with that would also help those who are porting over from Newtonsoft.",
          "createdAt": "2024-07-11T14:26:09Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-07-11T14:27:39Z",
          "id": "IC_kwDODI9FZc6EgYzl"
        },
        {
          "author": "julealgon",
          "body": "@adam8797 why not just have 2 interfaces, one for reading and another for writing, and if you want to support both, you implement both?\r\n\r\nThat seems like a better design to me than having `CanRead` / `CanWrite` properties (sometimes coupled with throwing `NotSupportedException` like `Stream` does).",
          "createdAt": "2024-07-11T16:49:09Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-01-31T13:39:17Z",
                "user": "thepirat000"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-07-08T07:43:11Z",
                "user": "Rebel028"
              }
            ],
            "totalCount": 2,
            "endCursor": "Y3Vyc29yOnYyOpHOEZuDfg=="
          },
          "updatedAt": "2024-07-11T16:49:09Z",
          "id": "IC_kwDODI9FZc6EhrOV"
        },
        {
          "author": "adam8797",
          "body": "Few reasons I think the `CanRead`/`CanWrite` way is the way the maintainers should pursue:\r\n\r\n1. **Compatibility.** It wouldn't require a breaking change to the `JsonConverter<T>` type. New virtual get-only properties could be added which default to `true`, so that the behavior of existing converters remains the same.\r\n2. **We've been here before.** To my previous point, `Newtonsoft.Json` did this already. That in and of itself doesn't mean its the best way, but we know it works. \r\n3. **Ease of adoption** I've had to port a few projects now from using `Newtonsoft.Json` to `System.Text.Json` (the reason I'm interested in this issue) and I've had to port converters which used that `CanRead`/`CanWrite` properties. Lowering the friction to move to this library would (imho) help adoption. We still have a few projects which use `Newtonsoft.Json` on .net8 because we still need weird obscure features it supports, and this is one of them. \r\n4. **Performance** I'll admit there may be a better way this could be done with pattern matching, but I think there's a good chance you'll run into reflection while trying to implement the interface approach, especially once generics get involved. A single virtual property call is going to be faster then reflection.\r\n\r\nBit shakier on that last bullet, because that may be totally solvable. However I think the first three points still stand, and provided enough of a reason to take the `CanRead`/`CanWrite` approach",
          "createdAt": "2024-07-12T17:01:35Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-07-08T07:43:50Z",
                "user": "Rebel028"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOEZuD5A=="
          },
          "updatedAt": "2024-07-12T17:01:35Z",
          "id": "IC_kwDODI9FZc6Era-P"
        },
        {
          "author": "rjgotten",
          "body": "Wouldn't even need `CanRead` / `CanWrite` explicitly. Just extend the contract for JsonConverterFactory to include an overloaded signature for `CanConvert` - e.g.\r\n\r\n```cs\r\nbool CanConvert(Type typeToConvert, SerializationDirection direction)\r\n```\r\nwhere\r\n```cs\r\npublic enum SerializationDirection \r\n{\r\n  Read,\r\n  Write\r\n}\r\n```",
          "createdAt": "2024-09-10T11:24:41Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-11-12T20:10:37Z",
                "user": "natalie-o-perret"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-01-31T13:39:43Z",
                "user": "thepirat000"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-07-08T07:44:23Z",
                "user": "Rebel028"
              }
            ],
            "totalCount": 3,
            "endCursor": "Y3Vyc29yOnYyOpHOEZuEQQ=="
          },
          "updatedAt": "2024-09-10T11:24:41Z",
          "id": "IC_kwDODI9FZc6Lf5q_"
        },
        {
          "author": "rjgotten",
          "body": "> @eiriktsarpalis \r\n> It's simply not possible given the way that STJ is currently architected. Adding a `JsonConverterAttribute` annotation on a type sets the default converter for that type. There is [this issue](https://github.com/dotnet/runtime/issues/63791) that proposes exposing the built-in converter types, but this would require specifying an explicit fallback for the type you are working with.\r\n\r\nIt's actually entirely possible.\r\nAnd I built it.\r\n\r\nThe lynchpin for it is in\r\n```cs\r\nJsonTypeInfo.CreateJsonTypeInfo(Type typeToConvert, JsonSerializerOptions options)\r\n```\r\n\r\nThis overload skips checking the `[JsonConverter]` attributes. It uses only the custom converters from the `JsonSerializerOptions .Converters` collection and the built-in converters.\r\n\r\nYou can achieve a 'use-only-for-reading' or 'use-only-for-writing' adapter over a `JsonConverter` with it, which will fall through to the next eligible custom converter or built-in converter:\r\n\r\n```cs\r\npublic sealed class ReadOnly<TInner> : JsonConverterFactory\r\n  where TInner: JsonConverter, new()\r\n  \r\npublic sealed class WriteOnly<TInner> : JsonConverterFactory\r\n  where TInner: JsonConverter, new()\r\n``` \r\n\r\nThe converter factories here would create converters that delegate to instances of `TInner` (and flatten `TInner` if its a `JsonConverterFactory` itself) for reading or writing using the usual technique of casting the `TInner` converter to `JsonConverter<TValue>` and directly accessing its `Read` or `Write` method.\r\n\r\nFor the _other_ branch, where `TInner` should _not_ be used, they instead derive a cloned `JsonSerializerOptions` that adds _another_ converter factory to the front of the list of converters, which will then match this type with highest priority. Because STJ gives precedence to global converters over attributes on types, it will pre-empt those as well and _will_ be selected when performing a nested `JsonSerializer.Serialize` or `.Deserialize` call passing either the writer or reader and these modified options.\r\n\r\nThat new converter factory can then inside its `CreateConverter` create a _third_ set of options, from which it removes itself again and which it then uses with the `JsonTypeInfo.CreateJsonTypeInfo` overload mentioned at the beginning to pull out the matching `JsonConverter` implementation from either the remaining custom converters, or the built-in converters.\r\n\r\nThus 'skipping' over any `[JsonConverter(typeof(ReadOnly<>))]` or `[JsonConverter(typeof(WriteOnly<>))]` attribute on the type itself, when writing or reading respectively, and falling through to whatever the 'next converter in line' would be.\r\n\r\n-------\r\n...\r\nCome to think of it - you could probably lift the `JsonTypeInfo.CreateJsonTypeInfo` usage into the first converter factory and explicitly establish the precise fallback converter there already, then pass separate read and write delegated converters into the wrapping converter the first factory spits out.\r\n\r\n_[EDIT]: Yes, indeed you totally could..._",
          "createdAt": "2024-09-11T19:26:24Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "ROCKET",
                "createdAt": "2025-07-08T07:47:25Z",
                "user": "Rebel028"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-07-08T07:47:27Z",
                "user": "Rebel028"
              }
            ],
            "totalCount": 2,
            "endCursor": "Y3Vyc29yOnYyOpHOEZuGIg=="
          },
          "updatedAt": "2024-09-11T20:45:15Z",
          "id": "IC_kwDODI9FZc6LvtAs"
        },
        {
          "author": "Methuselah96",
          "body": "@eiriktsarpalis The workaround you suggested [here](https://github.com/dotnet/runtime/issues/46372#issuecomment-1660515178) doesn't seem to work when writing objects when a read-only converter is present. I suspect it has something to with the object properties not being calculated as expected?\n\nHere's my sample code:\n```csharp\nusing System.Text.Json;\nusing System.Text.Json.Serialization;\n\npublic abstract class ReadOnlyJsonConverter<T> : JsonConverter<T>\n{\n    private readonly JsonConverter<T> _fallbackConverter =\n        (JsonConverter<T>)JsonSerializerOptions.Default.GetConverter(typeof(T));\n\n    public sealed override void Write(\n        Utf8JsonWriter writer,\n        T value,\n        JsonSerializerOptions options\n    ) => _fallbackConverter.Write(writer, value, options);\n}\n\npublic record Test(int Value);\n\npublic class MyTestConverter : ReadOnlyJsonConverter<Test>\n{\n    public override Test Read(\n        ref Utf8JsonReader reader,\n        Type typeToConvert,\n        JsonSerializerOptions options\n    )\n    {\n        if (reader.TokenType != JsonTokenType.StartObject)\n            throw new JsonException();\n\n        reader.Read();\n        if (reader.TokenType != JsonTokenType.PropertyName)\n            throw new JsonException();\n\n        string? propertyName = reader.GetString();\n        if (propertyName != \"Thing\")\n            throw new JsonException();\n\n        reader.Read();\n        if (reader.TokenType != JsonTokenType.Number)\n            throw new JsonException();\n        var value = reader.GetInt32();\n\n        reader.Read();\n        if (reader.TokenType != JsonTokenType.EndObject)\n            throw new JsonException();\n\n        return new Test(value);\n    }\n}\n\npublic static class Program\n{\n    public static void Main(string[] args)\n    {\n        var options = new JsonSerializerOptions { Converters = { new MyTestConverter() } };\n\n        var test = new Test(5);\n\n        Console.WriteLine($\"Expected: {JsonSerializer.Serialize(test)}\");\n        Console.WriteLine($\"Actual: {JsonSerializer.Serialize(test, options)}\");\n    }\n}\n```\n\nHere's the output:\n```\nExpected: {\"Value\":5}\nActual: {}\n```\n\nDo you have any suggestions for how to accomplish this with objects?",
          "createdAt": "2025-07-02T02:23:54Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-07-07T15:31:05Z",
                "user": "jeremybparagon"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOEZnuhw=="
          },
          "updatedAt": "2025-07-02T18:20:27Z",
          "id": "IC_kwDODI9FZc60Xxcq"
        },
        {
          "author": "Methuselah96",
          "body": "Maybe the behavior I mentioned above is an incarnation of https://github.com/dotnet/runtime/issues/50205?",
          "createdAt": "2025-07-07T20:15:51Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-07-07T20:15:51Z",
          "id": "IC_kwDODI9FZc61lHA_"
        }
      ],
      "totalCount": 29,
      "endCursor": "Y3Vyc29yOnYyOpHOtZRwPw=="
    },
    "url": "https://github.com/dotnet/runtime/issues/46372",
    "title": "Consider supporting read-only or write-only JsonConverters"
  },
  {
    "author": "weifenluo",
    "labels": [
      "api-suggestion",
      "area-System.Text.Json"
    ],
    "createdAt": "2021-01-31T13:11:08Z",
    "body": "## Background and Motivation\r\n\r\n<!--\r\nWe welcome API proposals! We have a process to evaluate the value and shape of new API. There is an overview of our process [here](https://github.com/dotnet/runtime/blob/master/docs/project/api-review-process.md). This template will help us gather the information we need to start the review process.\r\nFirst, please describe the purpose and value of the new API here.\r\n-->\r\nCurrently, `JsonConverter<T>.ReadNumberWithCustomHandling` and `WriteNumberWithCustomHandling` are internal, which are not callable from custom (de)serializers.\r\n\r\n## Proposed API\r\n\r\n<!--\r\nPlease provide the specific public API signature diff that you are proposing. For example:\r\n```diff\r\nnamespace System.Collections.Generic\r\n{\r\n-    public class HashSet<T> : ICollection<T>, ISet<T> {\r\n+    public class HashSet<T> : ICollection<T>, ISet<T>, IReadOnlySet<T> {\r\n     }\r\n```\r\nYou may find the [Framework Design Guidelines](https://github.com/dotnet/runtime/blob/master/docs/coding-guidelines/framework-design-guidelines-digest.md) helpful.\r\n-->\r\n\r\nWe can add the following `INumberConverter<T>` interface:\r\n\r\n```\r\npublic interface INumberConverter<T>\r\n{\r\n    T ReadNumber(ref Utf8JsonReader reader, JsonNumberHandling handling);\r\n    void WriteNumber(Utf8JsonWriter writer, T value, JsonNumberHandling handling);\r\n}\r\n```\r\n\r\nand converters which override `ReadNumberWithCustomHandling` and `WriteNumberWithCustomHandling` should implement this interface, such as `Int32Converter`.\r\n\r\n## Usage Examples\r\n\r\n<!--\r\nPlease provide code examples that highlight how the proposed API additions are meant to be consumed.\r\nThis will help suggest whether the API has the right shape to be functional, performant and useable.\r\nYou can use code blocks like this:\r\n``` C#\r\n// some lines of code here\r\n```\r\n-->\r\n\r\nIn custom (de)serializers, we can invoke converters with extra `JsonNumberHandling` parameter, for example:\r\n\r\n```\r\nWriteValue(Utf8JsonWriter writer, T value, Converter<T> converter, JsonNumberHandling handling)\r\n{\r\n    if (converter is INumberConverter<T> numberConverter)\r\n        numberConverter.WriteNumber(writer, value, handling);\r\n    ...\r\n}\r\n```\r\n\r\n## Alternative Designs\r\n\r\n<!--\r\nWere there other options you considered, such as alternative API shapes?\r\nHow does this compare to analogous APIs in other ecosystems and libraries?\r\n-->\r\nI can't figure out any other way for custom (de)serializers to consume converter with an extra `JsonNumberHandling` parameter.\r\n\r\n## Risks\r\n\r\n<!--\r\nPlease mention any risks that to your knowledge the API proposal might entail, such as breaking changes, performance regressions, etc.\r\n-->\r\nThis is an addition to existing API with a simple interface implementation, the risk should be minimal, if any.",
    "number": 47689,
    "reactions": {
      "hasNextPage": false,
      "nodes": [],
      "totalCount": 0,
      "endCursor": null
    },
    "updatedAt": "2023-09-09T16:18:22Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @eiriktsarpalis, @layomia\nSee info in area-owners.md if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\n## Background and Motivation\r\n\r\n<!--\r\nWe welcome API proposals! We have a process to evaluate the value and shape of new API. There is an overview of our process [here](https://github.com/dotnet/runtime/blob/master/docs/project/api-review-process.md). This template will help us gather the information we need to start the review process.\r\nFirst, please describe the purpose and value of the new API here.\r\n-->\r\nCurrently, `JsonConverter<T>.ReadNumberWithCustomHandling` and `WriteNumberWithCustomHandling` are internal, which are not callable from custom (de)serializers.\r\n\r\n## Proposed API\r\n\r\n<!--\r\nPlease provide the specific public API signature diff that you are proposing. For example:\r\n```diff\r\nnamespace System.Collections.Generic\r\n{\r\n-    public class HashSet<T> : ICollection<T>, ISet<T> {\r\n+    public class HashSet<T> : ICollection<T>, ISet<T>, IReadOnlySet<T> {\r\n     }\r\n```\r\nYou may find the [Framework Design Guidelines](https://github.com/dotnet/runtime/blob/master/docs/coding-guidelines/framework-design-guidelines-digest.md) helpful.\r\n-->\r\n\r\nWe can add the following `INumberConverter<T>` interface:\r\n\r\n```\r\npublic interface INumberConverter<T>\r\n{\r\n    T ReadNumber(ref Utf8JsonReader reader, JsonNumberHandling handling);\r\n    void WriteNumber(Utf8JsonWriter writer, T value, JsonNumberHandling handling);\r\n}\r\n```\r\n\r\nand converters which override `ReadNumberWithCustomHandling` and `WriteNumberWithCustomHandling` should implement this interface, such as `Int32Converter`.\r\n\r\n## Usage Examples\r\n\r\n<!--\r\nPlease provide code examples that highlight how the proposed API additions are meant to be consumed.\r\nThis will help suggest whether the API has the right shape to be functional, performant and useable.\r\nYou can use code blocks like this:\r\n``` C#\r\n// some lines of code here\r\n```\r\n-->\r\n\r\nIn custom (de)serializers, we can invoke converters with extra `JsonNumberHandling` parameter, for example:\r\n\r\n```\r\nWriteValue(Utf8JsonWriter writer, T value, Converter<T> converter, JsonNumberHandling handling)\r\n{\r\n    if (converter is INumberConverter<T> numberConverter)\r\n        numberConverter.WriteNumber(writer, value, handler);\r\n    ...\r\n}\r\n```\r\n\r\n## Alternative Designs\r\n\r\n<!--\r\nWere there other options you considered, such as alternative API shapes?\r\nHow does this compare to analogous APIs in other ecosystems and libraries?\r\n-->\r\nI can't figure out any other way for custom (de)serializers to consume converter with an extra `JsonNumberHandling` parameter.\r\n\r\n## Risks\r\n\r\n<!--\r\nPlease mention any risks that to your knowledge the API proposal might entail, such as breaking changes, performance regressions, etc.\r\n-->\r\nThis is an addition to existing API with a simple interface implementation, the risk should be minimal, if any.\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>weifenluo</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`api-suggestion`, `area-System.Text.Json`, `untriaged`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2021-01-31T13:11:13Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-01-31T13:11:13Z",
          "id": "MDEyOklzc3VlQ29tbWVudDc3MDM4MDQ3OA=="
        },
        {
          "author": "layomia",
          "body": "What kind of custom logic would you like to implement in these methods that are not handled in the default implementations for the various internal number converters? Just trying to understand the motivation here.",
          "createdAt": "2021-02-01T18:32:38Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-02-01T18:32:38Z",
          "id": "MDEyOklzc3VlQ29tbWVudDc3MTA2NTc5Ng=="
        },
        {
          "author": "weifenluo",
          "body": "There is no custom logic I would like to implement in these methods that are not handled in the default implementations for the various internal number converters. Instead I would like to **consume** the default implementations for the various internal number converters.\r\n\r\nThe (only) reason converters exist, is to be consumed by (de)serializers, either built-in or custom. Currently, `JsonConverter<T>.ReadNumberWithCustomHandling` and `JsonConverter<T>.WriteNumberWithCustomHandling` are internal, like a \"backdoor\" to built-in (de)serializers only. This is an anti-pattern IMO.\r\n\r\nLong story short, I'm now developing (de)serializers for something like `System.Data.DataTable` and `System.Data.DataRow`, which self-contains the metadata. These (de)serializers bypasses `JsonClassInfo` and `JsonPropertyInfo`, implement its own state (`ReadStack`/`WriteStack`), and read/write JSON via converters directly. I'm expecting framework like `System.Text.Json`, should treat built-in and custom (de)serializers equally.\r\n\r\nBTW, there is another \"backdoor\", `JsonConverter<T>.TryRead` and `JsonConverter<T>.TryWrite`, which handles state/continuation of (de)serialization. I understand this is a design decision in favor of performance, to choose the state (`ReadStack`/`WriteStack`) as `ref struct`, over the usability/extensibility. This, however, makes converters work for simple data type only.\r\n\r\nThere are two extensibility point of `System.Text.Json`: custom converter and custom (de)serializers utilizing low level `Utf8JsonReader` and `Utf8JsonWriter`. However, when coming across custom complex objects, none of the options works satisfactorily.",
          "createdAt": "2021-02-02T00:12:52Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-02-02T00:12:52Z",
          "id": "MDEyOklzc3VlQ29tbWVudDc3MTI0OTc4NQ=="
        },
        {
          "author": "weifenluo",
          "body": "I really hope this can be added to a planned release. It's easy to implement, and has no risk IMO.",
          "createdAt": "2021-02-02T01:21:22Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-02-02T01:21:22Z",
          "id": "MDEyOklzc3VlQ29tbWVudDc3MTI3NzM4OQ=="
        },
        {
          "author": "weifenluo",
          "body": "Here is the workaround by using reflection (hope the implementation will not change!):\r\n\r\n``` C#\r\nusing System;\r\nusing System.Linq.Expressions;\r\nusing System.Reflection;\r\nusing System.Runtime.CompilerServices;\r\nusing System.Text.Json;\r\nusing System.Text.Json.Serialization;\r\n\r\nnamespace ...\r\n{\r\n    // There is no interface to expose number handling for built-in converters:\r\n    // https://github.com/dotnet/runtime/issues/47689\r\n    // We have to use reflection to call:\r\n    // JsonConverter.IsInternalConverterForNumberType, JsonConverter<T>.ReadNumberWithCustomHandling\r\n    // and JsonConverter<T>.WriteNumberWithCustomHandling.\r\n    internal static class JsonConverterNumberHandling\r\n    {\r\n        internal static readonly Func<JsonConverter, bool> IsInternalConverterForNumberTypeGetter = BuildIsInternalConverterForNumberTypeGetter();\r\n\r\n        private static Func<JsonConverter, bool> BuildIsInternalConverterForNumberTypeGetter()\r\n        {\r\n            var fieldInfo = typeof(JsonConverter).GetField(nameof(IsInternalConverterForNumberType), BindingFlags.NonPublic | BindingFlags.Instance)!;\r\n\r\n            var paramJsonConverter = Expression.Parameter(typeof(JsonConverter));\r\n            var expr = Expression.Field(paramJsonConverter, fieldInfo);\r\n            return Expression.Lambda<Func<JsonConverter, bool>>(expr, paramJsonConverter).Compile();\r\n        }\r\n\r\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\r\n        public static bool IsInternalConverterForNumberType(this JsonConverter jsonConverter)\r\n        {\r\n            return IsInternalConverterForNumberTypeGetter(jsonConverter);\r\n        }\r\n\r\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\r\n        public static T ReadNumberWithCustomHandling<T>(this JsonConverter<T> jsonConverter, ref Utf8JsonReader reader, JsonNumberHandling handling)\r\n        {\r\n            return JsonConverterNumberHandling<T>.ReadNumberWithCustomHandling(jsonConverter, ref reader, handling);\r\n        }\r\n\r\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\r\n        private static void WriteNumberWithCustomHandling<T>(this JsonConverter<T> jsonConverter, Utf8JsonWriter writer, T value, JsonNumberHandling handling)\r\n        {\r\n            JsonConverterNumberHandling<T>.WriteNumberWithCustomHandling(jsonConverter, writer, value, handling);\r\n        }\r\n\r\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\r\n        public static void WriteValue<T>(this JsonConverter<T> jsonConverter, Utf8JsonWriter writer, T value, JsonSerializerOptions options, JsonNumberHandling? handling)\r\n        {\r\n            if (handling.HasValue)\r\n                jsonConverter.WriteNumberWithCustomHandling(writer, value, handling.Value);\r\n            else\r\n                jsonConverter.Write(writer, value, options);\r\n        }\r\n    }\r\n\r\n    internal static class JsonConverterNumberHandling<T>\r\n    {\r\n        internal delegate T ReadNumberWithCustomHandlingDelegate(JsonConverter<T> jsonConverter, ref Utf8JsonReader utf8JsonReader, JsonNumberHandling numberHandling);\r\n\r\n        internal static readonly ReadNumberWithCustomHandlingDelegate ReadNumberWithCustomHandling = BuildReadNumberWithCustomHandling();\r\n        internal static readonly Action<JsonConverter<T>, Utf8JsonWriter, T, JsonNumberHandling> WriteNumberWithCustomHandling = BuildWriteNumberWithCustomHandling();\r\n\r\n        private static ReadNumberWithCustomHandlingDelegate BuildReadNumberWithCustomHandling()\r\n        {\r\n            var methodInfo = typeof(JsonConverter<T>).GetMethod(nameof(ReadNumberWithCustomHandling), BindingFlags.Instance | BindingFlags.NonPublic)!;\r\n            var paramJsonConverter = Expression.Parameter(typeof(JsonConverter<T>));\r\n            var paramUtf8Reader = Expression.Parameter(typeof(Utf8JsonReader).MakeByRefType());\r\n            var paramNumberHandling = Expression.Parameter(typeof(JsonNumberHandling));\r\n            var expr = Expression.Call(paramJsonConverter, methodInfo, paramUtf8Reader, paramNumberHandling);\r\n            return Expression.Lambda<ReadNumberWithCustomHandlingDelegate>(expr, paramJsonConverter, paramUtf8Reader, paramNumberHandling).Compile();\r\n        }\r\n\r\n        private static Action<JsonConverter<T>, Utf8JsonWriter, T, JsonNumberHandling> BuildWriteNumberWithCustomHandling()\r\n        {\r\n            var methodInfo = typeof(JsonConverter<T>).GetMethod(nameof(WriteNumberWithCustomHandling), BindingFlags.Instance | BindingFlags.NonPublic)!;\r\n            var paramJsonConverter = Expression.Parameter(typeof(JsonConverter<T>));\r\n            var paramUtf8Writer = Expression.Parameter(typeof(Utf8JsonWriter));\r\n            var paramValue = Expression.Parameter(typeof(T));\r\n            var paramNumberHandling = Expression.Parameter(typeof(JsonNumberHandling));\r\n            var expr = Expression.Call(paramJsonConverter, methodInfo, paramUtf8Writer, paramValue, paramNumberHandling);\r\n            return Expression.Lambda<Action<JsonConverter<T>, Utf8JsonWriter, T, JsonNumberHandling>>(expr, paramJsonConverter, paramUtf8Writer, paramValue, paramNumberHandling).Compile();\r\n        }\r\n    }\r\n}\r\n```",
          "createdAt": "2021-03-28T01:54:05Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-03-28T01:54:05Z",
          "id": "MDEyOklzc3VlQ29tbWVudDgwODgzMDk5OQ=="
        },
        {
          "author": "eiriktsarpalis",
          "body": "I believe this might be possible to address by exposing the `OnTryWrite` and `OnTryRead` methods, something we are considering for 7.0.0 (related to the wider theme of #36785). This would require exposing the `WriteStack` and `ReadStack` types and also the `NumberHandling` field as a read-only property.\r\n\r\nI don't believe we should add an `INumberConverter<T>` interface. Exposing the specific `WriteNumberWithCustomHandling`/`ReadNumberWithCustomHandling` seems like a very niche use case, and we should instead be focusing on making the converter model more composable.",
          "createdAt": "2021-10-22T17:31:01Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-10-22T17:32:37Z",
          "id": "IC_kwDODI9FZc44nUZ6"
        },
        {
          "author": "weifenluo",
          "body": "`NumberHandling` and `WriteStack`/ `ReadStack` are two different things at different layer of the serialization tree: `NumberHandling` is the leaf, whereas `WriteStack`/`ReadStack` are branches.\r\n\r\nI don't agree this is a very niche use case. This is required by any serious custom serializer which bypasses the standard `WriteStack`/`ReadStack`.",
          "createdAt": "2021-10-23T08:39:34Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-10-23T08:39:34Z",
          "id": "IC_kwDODI9FZc44oaZ3"
        },
        {
          "author": "eiriktsarpalis",
          "body": "> NumberHandling and WriteStack/ ReadStack are two different things at different layer of the serialization tree: NumberHandling is the leaf, whereas WriteStack/ReadStack are branches.\r\n\r\nThat's not quite right, WriteStack and ReadStack are stacks and as such they do expose the NumberHandling specific to the current node being serialized. I should have probably clarified that the current actual location of the property is `WriteStack.Current.NumberHandling`.",
          "createdAt": "2021-10-23T09:43:27Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-10-23T09:43:27Z",
          "id": "IC_kwDODI9FZc44ocLP"
        },
        {
          "author": "weifenluo",
          "body": "What I meant is that `NumberHandling` is used to read/write values, whereas `WriteStack`/`ReadStack` is used to process the structure of the serialization. A custom serializer may implement its own structural logic, but it should reuse the existing, lower-level `NumberHandling`.",
          "createdAt": "2021-10-23T10:11:01Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-10-23T10:11:01Z",
          "id": "IC_kwDODI9FZc44oc-c"
        },
        {
          "author": "eiriktsarpalis",
          "body": "> A custom serializer may implement its own structural logic, but it should reuse the existing, lower-level NumberHandling.\r\n\r\nI'm not sure I understand. Do you have a use case where the proposed methods would get called by something other than the `JsonSerializer` infrastructure?",
          "createdAt": "2021-10-25T09:53:37Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-10-25T09:53:37Z",
          "id": "IC_kwDODI9FZc44qyR2"
        },
        {
          "author": "weifenluo",
          "body": "> > A custom serializer may implement its own structural logic, but it should reuse the existing, lower-level NumberHandling.\r\n> \r\n> I'm not sure I understand. Do you have a use case where the proposed methods would get called by something other than the `JsonSerializer` infrastructure?\r\n\r\nYes, I've done developing a custom serializer totally has nothing to do with the standard `JsonSerializer`, targeting data objects similar to `System.Data`'s `DataRow` and `DataTable`. These data objects contains its own metadata to process the structure. This issue and #50629 are two true blockers. For #50629, I chose to give up showing LineNumber and BytePositionInLine in the exception message; for this issue, I have to use reflection workaround as posted earlier.",
          "createdAt": "2021-10-25T13:20:14Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-10-25T13:28:23Z",
          "id": "IC_kwDODI9FZc44re3k"
        },
        {
          "author": "eiriktsarpalis",
          "body": "So presumably you're looking for a way to reuse all the primitive number converters on top of your custom serializer implementation? That seems like a niche use case to me, it's unlikely we'd add more methods to `JsonConverter<T>` just to accommodate that. If you're writing a new serializer, I would probably recommend using a custom converter type that matches your requirements.",
          "createdAt": "2021-10-25T13:32:41Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-10-25T13:32:41Z",
          "id": "IC_kwDODI9FZc44rhs_"
        },
        {
          "author": "weifenluo",
          "body": "I'm not sure I'm the only one that have to write a custom serializer. Apparently STJ should not assume the top-level object can only be POCO or collection, which is supported by the standard `JsonSerializer` infrastructure. Your recommendation is not acceptable because custom serializer and custom converter type are two different things at different layer, again.",
          "createdAt": "2021-10-25T13:43:07Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-10-25T13:43:07Z",
          "id": "IC_kwDODI9FZc44rj4b"
        },
        {
          "author": "devigo",
          "body": "I would like to deserialize an empty string to a `null` value for all `Nullable<T>` value types using System.Text.Json when `JsonSerializerOptions.NumberHandling` is set to  `JsonNumberHandling.AllowReadingFromString`.\r\nTo do this (\"\" -> null), I implemented a custom `NullableConverterFactory` and `NullableConverter<T>` in .NET Core 3.1, but I faced with an issue for numbers represented as a string in .NET 5. To fix this, as I understood it, I need access to `JsonConverter.IsInternalConverterForNumberType`, `JsonConverter<T>.ReadNumberWithCustomHandling` and `JsonConverter<T>.WriteNumberWithCustomHandling`.\r\nSo far I'm using the workaround by using reflection https://github.com/dotnet/runtime/issues/47689#issuecomment-808830999\r\nCould you make the listed methods at least `protected` or point out the correct way to implement the desired behavior?\r\n\r\ndemo: https://dotnetfiddle.net/4bWxDM\r\nversion for .NET Core 3.1\r\n``` cs\r\nusing System.Diagnostics;\r\nusing System.Linq.Expressions;\r\nusing System.Reflection;\r\nusing System.Runtime.CompilerServices;\r\n\r\nnamespace System.Text.Json.Serialization\r\n{\r\n    // https://stackoverflow.com/questions/65022834/how-to-deserialize-an-empty-string-to-a-null-value-for-all-nullablet-value-t\r\n    public class NullableConverterFactory : JsonConverterFactory\r\n    {\r\n        public override bool CanConvert(Type typeToConvert)\r\n        {\r\n            return Nullable.GetUnderlyingType(typeToConvert) != null;\r\n        }\r\n\r\n        public override JsonConverter CreateConverter(Type typeToConvert, JsonSerializerOptions options)\r\n        {\r\n            Debug.Assert(typeToConvert.GetGenericArguments().Length > 0);\r\n\r\n            var valueTypeToConvert = typeToConvert.GetGenericArguments()[0];\r\n\r\n            var valueConverter = options.GetConverter(valueTypeToConvert);\r\n            Debug.Assert(valueConverter != null);\r\n\r\n            return (JsonConverter)Activator.CreateInstance(\r\n                type: typeof(NullableConverter<>).MakeGenericType(valueTypeToConvert),\r\n                bindingAttr: BindingFlags.Instance | BindingFlags.Public,\r\n                binder: null,\r\n                args: new object[] { valueConverter },\r\n                culture: null);\r\n        }\r\n\r\n        private class NullableConverter<T> : JsonConverter<T?>\r\n            where T : struct\r\n        {\r\n            private readonly JsonConverter<T> _converter;\r\n\r\n            public NullableConverter(JsonConverter<T> converter)\r\n            {\r\n                _converter = converter;\r\n            }\r\n\r\n            public override T? Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)\r\n            {\r\n                if (reader.TokenType == JsonTokenType.Null)\r\n                {\r\n                    return null;\r\n                }\r\n                // DESERIALIZE AN EMPTY STRING TO A NULL VALUE\r\n                if (reader.TokenType == JsonTokenType.String)\r\n                {\r\n                    var s = reader.GetString();\r\n                    if (string.IsNullOrEmpty(s))\r\n                        return null;\r\n                }\r\n\r\n                if (_converter != null)\r\n                {\r\n                    return ReadValue(_converter, ref reader, typeof(T), options, options.NumberHandling);\r\n                }\r\n\r\n                // fallback\r\n                return JsonSerializer.Deserialize<T>(ref reader, options);\r\n            }\r\n\r\n            public override void Write(Utf8JsonWriter writer, T? value, JsonSerializerOptions options)\r\n            {\r\n                if (value == null)\r\n                {\r\n                    writer.WriteNullValue();\r\n                }\r\n                else if (_converter != null)\r\n                {\r\n                    WriteValue(_converter, writer, value.Value, options, options.NumberHandling);\r\n                }\r\n                else\r\n                {\r\n                    // fallback\r\n                    JsonSerializer.Serialize(writer, value.Value, options);\r\n                }\r\n            }\r\n\r\n            private static T ReadValue(JsonConverter<T> converter, ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options, JsonNumberHandling? handling)\r\n            {\r\n                return converter.Read(ref reader, typeToConvert, options);\r\n            }\r\n\r\n            private static void WriteValue(JsonConverter<T> converter, Utf8JsonWriter writer, T value, JsonSerializerOptions options, JsonNumberHandling? handling)\r\n            {\r\n                converter.Write(writer, value, options);\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nversion for .NET 5 supporting `JsonNumberHandling.AllowReadingFromString`\r\n``` diff\r\nusing System.Diagnostics;\r\nusing System.Linq.Expressions;\r\nusing System.Reflection;\r\nusing System.Runtime.CompilerServices;\r\n\r\nnamespace System.Text.Json.Serialization\r\n{\r\n    // https://stackoverflow.com/questions/65022834/how-to-deserialize-an-empty-string-to-a-null-value-for-all-nullablet-value-t\r\n    public class NullableConverterFactory : JsonConverterFactory\r\n    {\r\n        public override bool CanConvert(Type typeToConvert)\r\n        {\r\n            return Nullable.GetUnderlyingType(typeToConvert) != null;\r\n        }\r\n\r\n        public override JsonConverter CreateConverter(Type typeToConvert, JsonSerializerOptions options)\r\n        {\r\n            Debug.Assert(typeToConvert.GetGenericArguments().Length > 0);\r\n\r\n            var valueTypeToConvert = typeToConvert.GetGenericArguments()[0];\r\n\r\n            var valueConverter = options.GetConverter(valueTypeToConvert);\r\n            Debug.Assert(valueConverter != null);\r\n\r\n            return (JsonConverter)Activator.CreateInstance(\r\n                type: typeof(NullableConverter<>).MakeGenericType(valueTypeToConvert),\r\n                bindingAttr: BindingFlags.Instance | BindingFlags.Public,\r\n                binder: null,\r\n                args: new object[] { valueConverter },\r\n                culture: null);\r\n        }\r\n\r\n        private class NullableConverter<T> : JsonConverter<T?>\r\n            where T : struct\r\n        {\r\n            private readonly JsonConverter<T> _converter;\r\n\r\n            public NullableConverter(JsonConverter<T> converter)\r\n            {\r\n                _converter = converter;\r\n            }\r\n\r\n            public override T? Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)\r\n            {\r\n                if (reader.TokenType == JsonTokenType.Null)\r\n                {\r\n                    return null;\r\n                }\r\n                // DESERIALIZE AN EMPTY STRING TO A NULL VALUE\r\n                if (reader.TokenType == JsonTokenType.String)\r\n                {\r\n                    var s = reader.GetString();\r\n                    if (string.IsNullOrEmpty(s))\r\n                        return null;\r\n                }\r\n\r\n                if (_converter != null)\r\n                {\r\n                    return ReadValue(_converter, ref reader, typeof(T), options, options.NumberHandling);\r\n                }\r\n\r\n                // fallback\r\n                return JsonSerializer.Deserialize<T>(ref reader, options);\r\n            }\r\n\r\n            public override void Write(Utf8JsonWriter writer, T? value, JsonSerializerOptions options)\r\n            {\r\n                if (value == null)\r\n                {\r\n                    writer.WriteNullValue();\r\n                }\r\n                else if (_converter != null)\r\n                {\r\n                    WriteValue(_converter, writer, value.Value, options, options.NumberHandling);\r\n                }\r\n                else\r\n                {\r\n                    // fallback\r\n                    JsonSerializer.Serialize(writer, value.Value, options);\r\n                }\r\n            }\r\n\r\n            private static T ReadValue(JsonConverter<T> converter, ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options, JsonNumberHandling? handling)\r\n            {\r\n+               if (handling.HasValue && converter.IsInternalConverterForNumberType())\r\n+               {\r\n+                   return converter.ReadNumberWithCustomHandling(ref reader, handling.Value);\r\n+               }\r\n+               else\r\n+               {\r\n                    return converter.Read(ref reader, typeToConvert, options);\r\n+               }\r\n            }\r\n\r\n            private static void WriteValue(JsonConverter<T> converter, Utf8JsonWriter writer, T value, JsonSerializerOptions options, JsonNumberHandling? handling)\r\n            {\r\n+               if (handling.HasValue && converter.IsInternalConverterForNumberType())\r\n+               {\r\n+                   converter.WriteNumberWithCustomHandling(writer, value, handling.Value);\r\n+               }\r\n+               else\r\n+               {\r\n                    converter.Write(writer, value, options);\r\n+               }\r\n            }\r\n        }\r\n    }\r\n+\r\n+    // There is no interface to expose number handling for built-in converters:\r\n+    // https://github.com/dotnet/runtime/issues/47689\r\n+    // We have to use reflection to call:\r\n+    // JsonConverter.IsInternalConverterForNumberType, JsonConverter<T>.ReadNumberWithCustomHandling\r\n+    // and JsonConverter<T>.WriteNumberWithCustomHandling.\r\n+    internal static class JsonConverterNumberHandling\r\n+    {\r\n+        internal static readonly Func<JsonConverter, bool> IsInternalConverterForNumberTypeGetter = BuildIsInternalConverterForNumberTypeGetter();\r\n+\r\n+        private static Func<JsonConverter, bool> BuildIsInternalConverterForNumberTypeGetter()\r\n+        {\r\n+            var fieldInfo = typeof(JsonConverter).GetField(nameof(IsInternalConverterForNumberType), BindingFlags.NonPublic | BindingFlags.Instance);\r\n+\r\n+            var paramJsonConverter = Expression.Parameter(typeof(JsonConverter));\r\n+            var expr = Expression.Field(paramJsonConverter, fieldInfo);\r\n+            return Expression.Lambda<Func<JsonConverter, bool>>(expr, paramJsonConverter).Compile();\r\n+        }\r\n+\r\n+        [MethodImpl(MethodImplOptions.AggressiveInlining)]\r\n+        public static bool IsInternalConverterForNumberType(this JsonConverter converter)\r\n+        {\r\n+            return IsInternalConverterForNumberTypeGetter(converter);\r\n+        }\r\n+\r\n+        [MethodImpl(MethodImplOptions.AggressiveInlining)]\r\n+        public static T ReadNumberWithCustomHandling<T>(this JsonConverter<T> converter, ref Utf8JsonReader reader, JsonNumberHandling handling)\r\n+        {\r\n+            return JsonConverterNumberHandling<T>.ReadNumberWithCustomHandling(converter, ref reader, handling);\r\n+        }\r\n+\r\n+        [MethodImpl(MethodImplOptions.AggressiveInlining)]\r\n+        public static void WriteNumberWithCustomHandling<T>(this JsonConverter<T> converter, Utf8JsonWriter writer, T value, JsonNumberHandling handling)\r\n+        {\r\n+            JsonConverterNumberHandling<T>.WriteNumberWithCustomHandling(converter, writer, value, handling);\r\n+        }\r\n+    }\r\n+\r\n+    internal static class JsonConverterNumberHandling<T>\r\n+    {\r\n+        internal delegate T ReadNumberWithCustomHandlingDelegate(JsonConverter<T> converter, ref Utf8JsonReader reader, JsonNumberHandling numberHandling);\r\n+        internal delegate void WriteNumberWithCustomHandlingDelegate(JsonConverter<T> converter, Utf8JsonWriter writer, T value, JsonNumberHandling numberHandling);\r\n+\r\n+        internal static readonly ReadNumberWithCustomHandlingDelegate ReadNumberWithCustomHandling = BuildReadNumberWithCustomHandling();\r\n+        internal static readonly WriteNumberWithCustomHandlingDelegate WriteNumberWithCustomHandling = BuildWriteNumberWithCustomHandling();\r\n+\r\n+        private static ReadNumberWithCustomHandlingDelegate BuildReadNumberWithCustomHandling()\r\n+        {\r\n+            var methodInfo = typeof(JsonConverter<T>).GetMethod(nameof(ReadNumberWithCustomHandling), BindingFlags.Instance | BindingFlags.NonPublic);\r\n+            var paramConverter = Expression.Parameter(typeof(JsonConverter<T>));\r\n+            var paramReader = Expression.Parameter(typeof(Utf8JsonReader).MakeByRefType());\r\n+            var paramNumberHandling = Expression.Parameter(typeof(JsonNumberHandling));\r\n+            var expr = Expression.Call(paramConverter, methodInfo, paramReader, paramNumberHandling);\r\n+            return Expression.Lambda<ReadNumberWithCustomHandlingDelegate>(expr, paramConverter, paramReader, paramNumberHandling).Compile();\r\n+        }\r\n+\r\n+        private static WriteNumberWithCustomHandlingDelegate BuildWriteNumberWithCustomHandling()\r\n+        {\r\n+            var methodInfo = typeof(JsonConverter<T>).GetMethod(nameof(WriteNumberWithCustomHandling), BindingFlags.Instance | BindingFlags.NonPublic);\r\n+            var paramConverter = Expression.Parameter(typeof(JsonConverter<T>));\r\n+            var paramWriter = Expression.Parameter(typeof(Utf8JsonWriter));\r\n+            var paramValue = Expression.Parameter(typeof(T));\r\n+            var paramNumberHandling = Expression.Parameter(typeof(JsonNumberHandling));\r\n+            var expr = Expression.Call(paramConverter, methodInfo, paramWriter, paramValue, paramNumberHandling);\r\n+            return Expression.Lambda<WriteNumberWithCustomHandlingDelegate>(expr, paramConverter, paramWriter, paramValue, paramNumberHandling).Compile();\r\n+        }\r\n+    }\r\n}\r\n```\r\n\r\n",
          "createdAt": "2022-03-24T12:31:47Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-03-24T12:34:13Z",
          "id": "IC_kwDODI9FZc5AOoml"
        },
        {
          "author": "Neme12",
          "body": "Why not add a generic converter for anything that is `IUtf8Parsable` and `IUtf8Formattable`?",
          "createdAt": "2023-09-09T16:18:22Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-09-09T16:18:22Z",
          "id": "IC_kwDODI9FZc5mE2Ts"
        }
      ],
      "totalCount": 15,
      "endCursor": "Y3Vyc29yOnYyOpHOZhNk7A=="
    },
    "url": "https://github.com/dotnet/runtime/issues/47689",
    "title": "Add INumberConverter<T> interface into System.Text.Json"
  },
  {
    "author": "jmcginty",
    "labels": [
      "bug",
      "area-System.Text.Json"
    ],
    "createdAt": "2021-03-23T05:09:52Z",
    "body": "<!--This is just a template - feel free to delete any and all of it and replace as appropriate.-->\r\n\r\n### Description\r\n\r\nMarking a property in an abstract class as [JsonIgnore] does not get inherited when the property is overridden\r\n\r\n### Configuration\r\n\r\n* Which version of .NET is the code running on? .net Core 3.1\r\n\r\n### Other information\r\n\r\nExample test code to show the problem \r\n\r\n```c#\r\nusing System;\r\nusing System.Text.Json;\r\nusing System.Text.Json.Serialization;\r\nusing Xunit;\r\n\r\nnamespace Test.TallyIt.JsonLibTest\r\n{\r\n    internal abstract class Animal\r\n    {\r\n        public int Id { get; set; }\r\n        public string FirstName { get; set; }\r\n        public DateTime Dob { get; set; }\r\n        [JsonIgnore]\r\n        public abstract bool IsIgnored { get; set; }\r\n    }\r\n\r\n    internal class Cat : Animal\r\n    {\r\n        public override bool IsIgnored { get; set; }\r\n    }\r\n\r\n    public class JsonTests\r\n    {\r\n        [Fact]\r\n        public void TestSerialiseIntoCamelCase()\r\n        {\r\n            var cat = new Cat()\r\n            {\r\n                Id = 123782,\r\n                Dob = new DateTime(2000, 7, 14),\r\n                FirstName = \"Fluffy\",\r\n                IsIgnored = true\r\n            };\r\n\r\n            var json = JsonSerializer.Serialize(cat);\r\n\r\n            // This assert fails, I expected the JsonIgnore attribute to be derived\r\n            Assert.Equal(@\"{\"\"id\"\":123782,\"\"firstName\"\":\"\"Fluffy\"\",\"\"dob\"\":\"\"2000-07-14T00:00:00\"\"}\", json);\r\n        }\r\n    }\r\n}\r\n```\r\n",
    "number": 50078,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-01-06T14:11:46Z",
          "user": "akurone"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-06-07T20:00:43Z",
          "user": "andrewdbond"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-07-24T21:07:19Z",
          "user": "McNerdius"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-08-05T18:28:04Z",
          "user": "warriordog"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-08-26T02:59:12Z",
          "user": "EstherSY"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-05-03T15:37:32Z",
          "user": "PingTKP"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-01-17T16:10:04Z",
          "user": "Brokolis"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-05-06T21:15:12Z",
          "user": "xackus"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-07-08T07:16:12Z",
          "user": "adiletelf"
        }
      ],
      "totalCount": 9,
      "endCursor": "Y3Vyc29yOnYyOpHODGHdfg=="
    },
    "updatedAt": "2025-06-24T19:43:13Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @eiriktsarpalis, @layomia\nSee info in area-owners.md if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\n<!--This is just a template - feel free to delete any and all of it and replace as appropriate.-->\r\n\r\n### Description\r\n\r\nMarking a property in an abstract class as [JsonIgnore] does not get inherited when the property is overridden\r\n\r\n### Configuration\r\n\r\n* Which version of .NET is the code running on? .net Core 3.1\r\n\r\n### Other information\r\n\r\nExample test code to show the problem \r\n\r\n```\r\nusing System;\r\nusing System.Text.Json;\r\nusing System.Text.Json.Serialization;\r\nusing Xunit;\r\n\r\nnamespace Test.TallyIt.JsonLibTest\r\n{\r\n    internal abstract class Animal\r\n    {\r\n        public int Id { get; set; }\r\n        public string FirstName { get; set; }\r\n        public DateTime Dob { get; set; }\r\n        [JsonIgnore]\r\n        public abstract bool IsIgnored { get; set; }\r\n    }\r\n\r\n    internal class Cat : Animal\r\n    {\r\n        public override bool IsIgnored { get; set; }\r\n    }\r\n\r\n    public class JsonTests\r\n    {\r\n        [Fact]\r\n        public void TestSerialiseIntoCamelCase()\r\n        {\r\n            var cat = new Cat()\r\n            {\r\n                Id = 123782,\r\n                Dob = new DateTime(2000, 7, 14),\r\n                FirstName = \"Fluffy\",\r\n                IsIgnored = true\r\n            };\r\n\r\n            var json = JsonSerializer.Serialize(cat);\r\n\r\n            // This assert fails, I expected the JsonIgnore attribute to be derived\r\n            Assert.Equal(@\"{\"\"id\"\":123782,\"\"firstName\"\":\"\"Fluffy\"\",\"\"dob\"\":\"\"2000-07-14T00:00:00\"\"}\", json);\r\n        }\r\n    }\r\n}\r\n```\r\n\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>jmcginty</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`area-System.Text.Json`, `untriaged`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2021-03-23T05:09:56Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-03-23T05:09:56Z",
          "id": "MDEyOklzc3VlQ29tbWVudDgwNDYyMTE0Mg=="
        },
        {
          "author": "eiriktsarpalis",
          "body": "I can reproduce locally in .NET 5. Given that virtual properties already inherit attributes like `JsonPropertyName` it stands to reason that the same should be the case with `JsonIgnore`. @layomia thoughts?",
          "createdAt": "2021-03-24T12:38:00Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-03-24T16:36:33Z",
          "id": "MDEyOklzc3VlQ29tbWVudDgwNTc4NjIxOA=="
        },
        {
          "author": "eiriktsarpalis",
          "body": "Triage: assigning to future since not a regression and can be worked around by applying the same attribute in the derived classes.",
          "createdAt": "2021-03-24T16:37:43Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-03-24T16:37:50Z",
          "id": "MDEyOklzc3VlQ29tbWVudDgwNTk3ODQxMg=="
        },
        {
          "author": "Maximys",
          "body": "@layomia , I think this bug is linked with [51165](https://github.com/dotnet/runtime/issues/51165). Can you get me possibility to fix they on my free time (I hope, on Saturday or Sunday of current week)?",
          "createdAt": "2021-08-30T16:34:38Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-08-30T16:34:38Z",
          "id": "IC_kwDODI9FZc42JomP"
        },
        {
          "author": "Jetski5822",
          "body": "Just ran in to this - any idea when in 8.X this will be worked on?",
          "createdAt": "2024-05-28T06:18:09Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-05-28T06:18:09Z",
          "id": "IC_kwDODI9FZc5_OL-A"
        },
        {
          "author": "eiriktsarpalis",
          "body": ".NET 8 has already shipped - we don't backport bugfixes to shipped versions of .NET unless they are regressions or security related bugs. In terms when this will get fixed in general, I can say with certainty that a fix is not in the cards for .NET 9.",
          "createdAt": "2024-05-28T14:54:52Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-05-28T21:24:11Z",
                "user": "Jetski5822"
              },
              {
                "content": "THUMBS_DOWN",
                "createdAt": "2025-02-07T13:04:22Z",
                "user": "AlexeyTliss"
              }
            ],
            "totalCount": 2,
            "endCursor": "Y3Vyc29yOnYyOpHOEFoV-g=="
          },
          "updatedAt": "2024-05-28T14:55:02Z",
          "id": "IC_kwDODI9FZc5_SDO6"
        },
        {
          "author": "oddbear",
          "body": "Not a solution, but it is possible to use customization as a workaround.\r\nSomething like:\r\n```csharp\r\nvoid Main()\r\n{\r\n    var jsonSerializerOptions = new JsonSerializerOptions\r\n    {\r\n        TypeInfoResolver = new DefaultJsonTypeInfoResolver\r\n        {\r\n            Modifiers = { InheritJsonIgnore }\r\n        }\r\n    };\r\n\r\n    var cat = new Cat()\r\n    {\r\n        Id = 123782,\r\n        Dob = new DateTime(2000, 7, 14),\r\n        FirstName = \"Fluffy\",\r\n        IsIgnored = true\r\n    };\r\n\r\n    var json = JsonSerializer.Serialize(cat, jsonSerializerOptions);\r\n    json.Dump(); // {\"Id\":123782,\"FirstName\":\"Fluffy\",\"Dob\":\"2000-07-14T00:00:00\"}\r\n}\r\n\r\n// Modified example from: https://learn.microsoft.com/en-us/dotnet/standard/serialization/system-text-json/custom-contracts\r\nstatic void InheritJsonIgnore(JsonTypeInfo jsonTypeInfo)\r\n{\r\n    if (jsonTypeInfo.Kind is not JsonTypeInfoKind.Object)\r\n        return;\r\n    \r\n    for (int i = 0; i < jsonTypeInfo.Properties.Count; i++)\r\n    {\r\n        if (jsonTypeInfo.Properties[i].AttributeProvider is not PropertyInfo propertyInfo)\r\n            continue;\r\n\r\n        if (propertyInfo.GetCustomAttribute<JsonIgnoreAttribute>() is null)\r\n            continue;\r\n\r\n        jsonTypeInfo.Properties.RemoveAt(i--);\r\n    }\r\n}\r\n\r\ninternal abstract class Animal\r\n{\r\n    public int Id { get; set; }\r\n    public string FirstName { get; set; }\r\n    public DateTime Dob { get; set; }\r\n    [JsonIgnore]\r\n    public abstract bool IsIgnored { get; set; }\r\n}\r\n\r\ninternal class Cat : Animal\r\n{\r\n    public override bool IsIgnored { get; set; }\r\n}\r\n```",
          "createdAt": "2024-06-26T19:16:53Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-08-13T02:36:40Z",
                "user": "trtiger4520"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-08-15T12:45:49Z",
                "user": "bhaeussermann"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-09-23T12:27:54Z",
                "user": "miminno"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-02-07T13:05:19Z",
                "user": "AlexeyTliss"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-05-27T19:20:28Z",
                "user": "lukedukeus"
              }
            ],
            "totalCount": 5,
            "endCursor": "Y3Vyc29yOnYyOpHOET-7GA=="
          },
          "updatedAt": "2024-06-26T19:16:53Z",
          "id": "IC_kwDODI9FZc6Crkpz"
        },
        {
          "author": "rmannibucau",
          "body": "Same there, the API is flagged as inherited but the impl is not which is bothering cause it means you can leak a parent state whereas the child doesn't always have to care about it so hope .NET 9 gets it fixed since it doesn't look crazy as fix.",
          "createdAt": "2024-11-09T19:51:56Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-11-09T19:51:56Z",
          "id": "IC_kwDODI9FZc6TAs3d"
        },
        {
          "author": "lukedukeus",
          "body": "After switching from Newtonsoft.Json, I was supprized to find that this also doesn't work for interfaces:\n```\ninternal interface Animal\n{\n    public int Id { get; set; }\n    public string FirstName { get; set; }\n    public DateTime Dob { get; set; }\n    [JsonIgnore]\n    public abstract bool IsIgnored { get; set; }\n}\n\ninternal class Cat : Animal\n{\n    public override bool IsIgnored { get; set; }\n}\n\nCat cat = new Cat() {Id = 0; FirstName = \"Garfield\", Dob = DateTime.Parse(\"Jun 19, 1978\"), IsIgnored = false};\nstring json = JsonSerializer.Serialize(cat); // json still includes the IsIgnored prop!\n```\n\nHoping this can get fixed for .NET 10\n",
          "createdAt": "2025-05-27T19:25:36Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-05-27T19:25:36Z",
          "id": "IC_kwDODI9FZc6trFbj"
        },
        {
          "author": "Jusas",
          "body": "Amazing, how is this still open?\nComing from Newtonsoft.Json the amount of walls I seem to have to climb over just to get rid of one dependency is getting ridiculous.",
          "createdAt": "2025-06-24T19:43:13Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-06-24T19:43:13Z",
          "id": "IC_kwDODI9FZc6y6bZO"
        }
      ],
      "totalCount": 10,
      "endCursor": "Y3Vyc29yOnYyOpHOsum2Tg=="
    },
    "url": "https://github.com/dotnet/runtime/issues/50078",
    "title": "JsonIgnore attribute is not inherited in overridden properties"
  },
  {
    "author": "NinoFloris",
    "labels": [
      "bug",
      "area-System.Text.Json"
    ],
    "createdAt": "2021-03-24T20:39:31Z",
    "body": "Internal json collection converters for instance assume `JsonClassInfo.ElementInfo` is not null, however it can actually be null if the converter has been pre-aquired from another options instance. https://github.com/dotnet/runtime/blob/79ae74f5ca5c8a6fe3a48935e85bd7374959c570/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/Converters/Collection/IEnumerableDefaultConverter.cs#L42\r\n\r\n`ElementInfo` returns null if `ElementType` is null and `ElementType` will only be filled under specific circumstances.\r\n\r\nWhen we start at the point of our custom converter's Read() method (see below) we get the following steps to an NRE:\r\n- pre-aquired JsonConverter.Read will initialize its own state (readstack) with among others a call to `options.GetOrAddClassForRootType(type)` \r\n- This will then do a resolve for the type and its converter in the constructor of `JsonClassInfo(type)`.\r\n- Converter, which is resolved back again to the custom converter here will have `ClassType.None` because all custom converters do.\r\n- State is now initialized with `ElementType = null` because it didn't fall into the `ClassType.Collection` arm\r\n- Call to OnTryRead commences with state that will never return anything but null for `JsonClassInfo.ElementInfo`\r\n- NRE thrown\r\n\r\n```cs\r\nusing System;\r\nusing System.Collections.Immutable;\r\nusing System.Text.Json;\r\nusing System.Text.Json.Serialization;\r\n\r\nnamespace StjRepro\r\n{\r\n    public enum Cases\r\n    {\r\n        One,\r\n        Two,\r\n        Three,\r\n        Four\r\n    }\r\n\r\n    class JsonImmutableArrayConverter<T> : JsonConverter<ImmutableArray<T>>\r\n    {\r\n        JsonConverter<ImmutableArray<T>> _originalConverter;\r\n\r\n        public JsonImmutableArrayConverter()\r\n            => _originalConverter = (JsonConverter<ImmutableArray<T>>)new JsonSerializerOptions().GetConverter(typeof(ImmutableArray<T>));\r\n\r\n        public override ImmutableArray<T> Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)\r\n            // We're passing the current options and not the default options because we do want our value converters to work\r\n            // in this example, from strings to the enum 'Cases'.\r\n            => _originalConverter.Read(ref reader, typeToConvert, options);\r\n\r\n        public override void Write(Utf8JsonWriter writer, ImmutableArray<T> value, JsonSerializerOptions options)\r\n        {\r\n            throw new NotSupportedException();\r\n        }\r\n    }\r\n\r\n    class JsonImmutableArrayConverter : JsonConverterFactory\r\n    {\r\n        public override bool CanConvert(Type typeToConvert)\r\n            => typeToConvert.IsGenericType && typeToConvert.GetGenericTypeDefinition() == typeof(ImmutableArray<>);\r\n\r\n        public override JsonConverter CreateConverter(Type typeToConvert, JsonSerializerOptions options)\r\n            => (JsonConverter)Activator.CreateInstance(typeof(JsonImmutableArrayConverter<>).MakeGenericType(typeToConvert.GenericTypeArguments[0]));\r\n    }\r\n\r\n    class Program\r\n    {\r\n        static void Main(string[] args)\r\n        {\r\n            var options = new JsonSerializerOptions();\r\n            options.Converters.Add(new JsonImmutableArrayConverter());\r\n            options.Converters.Add(new JsonStringEnumConverter(JsonNamingPolicy.CamelCase));\r\n            JsonSerializer.Deserialize<ImmutableArray<Cases>>(@\"[\"\"one\"\",\"\"two\"\",\"\"three\"\",\"\"four\"\"]\", options);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n```\r\nUnhandled exception. System.NullReferenceException: Object reference not set to an instance of an object.\r\n   at System.Text.Json.Serialization.Converters.IEnumerableDefaultConverter`2.GetElementConverter(JsonClassInfo elementClassInfo)\r\n   at System.Text.Json.Serialization.Converters.IEnumerableDefaultConverter`2.OnTryRead(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options, ReadStack& state, TCollection& value)\r\n   at System.Text.Json.Serialization.JsonConverter`1.TryRead(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options, ReadStack& state, T& value)\r\n   at System.Text.Json.Serialization.JsonResumableConverter`1.Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options)\r\n   at StjRepro.JsonImmutableArrayConverter`1.Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options)\r\n   at System.Text.Json.Serialization.JsonConverter`1.TryRead(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options, ReadStack& state, T& value)\r\n   at System.Text.Json.Serialization.JsonConverter`1.ReadCore(Utf8JsonReader& reader, JsonSerializerOptions options, ReadStack& state)\r\n   at System.Text.Json.JsonSerializer.ReadCore[TValue](JsonConverter jsonConverter, Utf8JsonReader& reader, JsonSerializerOptions options, ReadStack& state)\r\n   at System.Text.Json.JsonSerializer.ReadCore[TValue](Utf8JsonReader& reader, Type returnType, JsonSerializerOptions options)\r\n   at System.Text.Json.JsonSerializer.Deserialize[TValue](ReadOnlySpan`1 json, Type returnType, JsonSerializerOptions options)\r\n   at System.Text.Json.JsonSerializer.Deserialize[TValue](String json, JsonSerializerOptions options)\r\n   at StjRepro.Program.Main(String[] args)\r\n```\r\n\r\nThe reason for pulling out an 'original' converter like this is because some code paths in a custom converter should just be able to default to existing converters, merely wrapping over them.\r\n\r\nThe only way I see to hack around this without a proper fix is passing a specially crafted options instance into the framework converter that has this custom converter removed, it will resolve the correct `JsonClassInfo` and includes the required custom value converters but in terms of perf (and usability) it seems far from ideal.\r\n\r\n```cs\r\n        public override ImmutableArray<T> Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)\r\n        {\r\n            var optionsDiff = new JsonSerializerOptions(options);\r\n            JsonConverter factory = null;\r\n            foreach (var converter in optionsDiff.Converters)\r\n            {\r\n                if (converter.GetType() == typeof(JsonImmutableArrayConverter))\r\n                    factory = converter;\r\n            }\r\n            if (factory != null)\r\n                optionsDiff.Converters.Remove(factory);\r\n\r\n            // We're passing the current options and not the default options because we do want our value converters to work\r\n            // in this case from strings to the enum 'Cases'.\r\n            return _originalConverter.Read(ref reader, typeToConvert, optionsDiff);\r\n        }\r\n\r\n```\r\n\r\nIf there is some other method by which to achieve what I want, I'd be glad to use it. In any case I think its good to add some documentation on how to call into the framework converters from a custom converter, this has been something I've wanted to do (and done to various degrees of success) multiple times now.\r\n\r\n/cc @layomia ",
    "number": 50205,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-07-02T15:08:54Z",
          "user": "warriordog"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-11-14T12:02:14Z",
          "user": "peterwurzinger"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-01-24T08:38:14Z",
          "user": "bartelink"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-01-20T11:03:03Z",
          "user": "Mad-Lynx"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-03-21T14:22:52Z",
          "user": "m0a0k0s"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-07-07T20:15:59Z",
          "user": "Methuselah96"
        }
      ],
      "totalCount": 6,
      "endCursor": "Y3Vyc29yOnYyOpHODGCzBA=="
    },
    "updatedAt": "2025-01-20T20:48:30Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @eiriktsarpalis, @layomia\nSee info in area-owners.md if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\nInternal json collection converters for instance assume `JsonClassInfo.ElementInfo` is not null, however it can actually be null if the converter has been pre-aquired from another options instance. https://github.com/dotnet/runtime/blob/79ae74f5ca5c8a6fe3a48935e85bd7374959c570/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/Converters/Collection/IEnumerableDefaultConverter.cs#L42\r\n\r\n`ElementInfo` returns null if `ElementType` is null and `ElementType` will only be filled under specific circumstances.\r\n\r\nWhen we start at the point of our custom converter's Read() method (see below) we get the following steps to an NRE:\r\n- pre-aquired JsonConverter.Read will initialize its own state (readstack) with among others a call to `options.GetOrAddClassForRootType(type)` \r\n- This will then do a resolve for the type and its converter in the constructor of `JsonClassInfo(type)`.\r\n- Converter, which is resolved back again to the custom converter here will have `ClassType.None` because all custom converters do.\r\n- State is now initialized with `ElementType = null` because it didn't fall into the `ClassType.Collection` arm\r\n- Call to OnTryRead commences with state that will never return anything but null for `JsonClassInfo.ElementInfo`\r\n- NRE thrown\r\n\r\n```cs\r\nusing System;\r\nusing System.Collections.Immutable;\r\nusing System.Text.Json;\r\nusing System.Text.Json.Serialization;\r\n\r\nnamespace StjRepro\r\n{\r\n    public enum Cases\r\n    {\r\n        One,\r\n        Two,\r\n        Three,\r\n        Four\r\n    }\r\n\r\n    class JsonImmutableArrayConverter<T> : JsonConverter<ImmutableArray<T>>\r\n    {\r\n        JsonConverter<ImmutableArray<T>> _originalConverter;\r\n\r\n        public JsonImmutableArrayConverter()\r\n            => _originalConverter = (JsonConverter<ImmutableArray<T>>)new JsonSerializerOptions().GetConverter(typeof(ImmutableArray<T>));\r\n\r\n        public override ImmutableArray<T> Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)\r\n            // We're passing the current options and not the default options because we do want our value converters to work\r\n            // in this example, from strings to the enum 'Cases'.\r\n            => _originalConverter.Read(ref reader, typeToConvert, options);\r\n\r\n        public override void Write(Utf8JsonWriter writer, ImmutableArray<T> value, JsonSerializerOptions options)\r\n        {\r\n            throw new NotSupportedException();\r\n        }\r\n    }\r\n\r\n    class JsonImmutableArrayConverter : JsonConverterFactory\r\n    {\r\n        public override bool CanConvert(Type typeToConvert)\r\n            => typeToConvert.IsGenericType && typeToConvert.GetGenericTypeDefinition() == typeof(ImmutableArray<>);\r\n\r\n        public override JsonConverter CreateConverter(Type typeToConvert, JsonSerializerOptions options)\r\n            => (JsonConverter)Activator.CreateInstance(typeof(JsonImmutableArrayConverter<>).MakeGenericType(typeToConvert.GenericTypeArguments[0]));\r\n    }\r\n\r\n    class Program\r\n    {\r\n        static void Main(string[] args)\r\n        {\r\n            var options = new JsonSerializerOptions();\r\n            options.Converters.Add(new JsonImmutableArrayConverter());\r\n            options.Converters.Add(new JsonStringEnumConverter(JsonNamingPolicy.CamelCase));\r\n            JsonSerializer.Deserialize<ImmutableArray<Cases>>(@\"[\"\"one\"\",\"\"two\"\",\"\"three\"\",\"\"four\"\"]\", options);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n```\r\nUnhandled exception. System.NullReferenceException: Object reference not set to an instance of an object.\r\n   at System.Text.Json.Serialization.Converters.IEnumerableDefaultConverter`2.GetElementConverter(JsonClassInfo elementClassInfo)\r\n   at System.Text.Json.Serialization.Converters.IEnumerableDefaultConverter`2.OnTryRead(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options, ReadStack& state, TCollection& value)\r\n   at System.Text.Json.Serialization.JsonConverter`1.TryRead(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options, ReadStack& state, T& value)\r\n   at System.Text.Json.Serialization.JsonResumableConverter`1.Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options)\r\n   at StjRepro.JsonImmutableArrayConverter`1.Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options)\r\n   at System.Text.Json.Serialization.JsonConverter`1.TryRead(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options, ReadStack& state, T& value)\r\n   at System.Text.Json.Serialization.JsonConverter`1.ReadCore(Utf8JsonReader& reader, JsonSerializerOptions options, ReadStack& state)\r\n   at System.Text.Json.JsonSerializer.ReadCore[TValue](JsonConverter jsonConverter, Utf8JsonReader& reader, JsonSerializerOptions options, ReadStack& state)\r\n   at System.Text.Json.JsonSerializer.ReadCore[TValue](Utf8JsonReader& reader, Type returnType, JsonSerializerOptions options)\r\n   at System.Text.Json.JsonSerializer.Deserialize[TValue](ReadOnlySpan`1 json, Type returnType, JsonSerializerOptions options)\r\n   at System.Text.Json.JsonSerializer.Deserialize[TValue](String json, JsonSerializerOptions options)\r\n   at StjRepro.Program.Main(String[] args)\r\n```\r\n\r\nThe reason for pulling out an 'original' converter like this is because some code paths in a custom converter should just be able to default to existing converters, merely wrapping over them.\r\n\r\nThe only way I see to hack around this without a proper fix is passing a specially crafted options instance into the framework converter that has this custom converter removed, it will resolve the correct `JsonClassInfo` and includes the required custom value converters but in terms of perf (and usability) it seems far from ideal.\r\n\r\n```cs\r\n        public override ImmutableArray<T> Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)\r\n        {\r\n            var optionsDiff = new JsonSerializerOptions(options);\r\n            JsonConverter factory = null;\r\n            foreach (var converter in optionsDiff.Converters)\r\n            {\r\n                if (converter.GetType() == typeof(JsonImmutableArrayConverter))\r\n                    factory = converter;\r\n            }\r\n            if (factory != null)\r\n                optionsDiff.Converters.Remove(factory);\r\n\r\n            // We're passing the current options and not the default options because we do want our value converters to work\r\n            // in this case from strings to the enum 'Cases'.\r\n            return _originalConverter.Read(ref reader, typeToConvert, optionsDiff);\r\n        }\r\n\r\n```\r\n\r\nIf there is some other method by which to achieve what I want, I'd be glad to use it. In any case I think its good to add some documentation on how to call into the framework converters from a custom converter, this has been something I've wanted to do (and done to various degrees of success) multiple times now.\r\n\r\n/cc @layomia \n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>NinoFloris</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`area-System.Text.Json`, `untriaged`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2021-03-24T20:39:37Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-03-24T20:39:37Z",
          "id": "MDEyOklzc3VlQ29tbWVudDgwNjE3MTc0Nw=="
        },
        {
          "author": "layomia",
          "body": "@NinoFloris thanks! I haven't fully grokked this yet but @eiriktsarpalis and I discussed potential issues related to this just yesterday. I'll take a look.",
          "createdAt": "2021-03-24T23:52:37Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-03-24T23:52:37Z",
          "id": "MDEyOklzc3VlQ29tbWVudDgwNjI1Njg1Nw=="
        },
        {
          "author": "eiriktsarpalis",
          "body": "@NinoFloris I bumped into the very same issue yesterday and agree with your analysis. I couldn't really work around it without making changes to System.Text.Json internals so we need to fix the issue in the general case. \r\n\r\nI don't think relying on a \"default\" options instance is a good solution, since while it may (in some cases) ensure that `JsonClassInfo.ElementClassInfo` is populated, that might not be compatible with the element converter being used by the active options instance.\r\n\r\nFundamentally this stems from weakness in the `JsonClassInfo` design, which is assumed to be converter-agnostic but whose shape depends on the current converter being used. I don't know what the best solution would be here, but it will probably require a bit of refactoring :-)",
          "createdAt": "2021-03-25T14:18:27Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-03-25T14:18:27Z",
          "id": "MDEyOklzc3VlQ29tbWVudDgwNjgzNjEzNw=="
        },
        {
          "author": "NinoFloris",
          "body": ">@NinoFloris I bumped into the very same issue yesterday and agree with your analysis\r\n\r\nThat's such an unlikely coincidence, amusing! ^_^\r\n\r\n>I don't think relying on a \"default\" options instance is a good solution\r\n\r\nEvidently it's a hack to get what I want, though I'm not sure what your suggested alternative is? The converter override and caching process won't suddenly give me the behavior I want — getting the converter that would have been resolved if not for the custom one overriding it and getting cached — without api additions.\r\n\r\nTo 'quickly' fix the `JsonClassInfo` issue, I've considered a few options:\r\n\r\n- `JsonClassInfo` gets augmented with an extra constructor taking a `JsonConverter`, the calling converter can then flow itself down all the way starting from stack.Initialize, fixing the incorrect ClassType determination. The problem I see is these JsonClassInfo's get cached as well as far as I understand, so this won't work reliably without another fix...\r\n- To fix the caching issue, would it make sense to cache on not just type but a composite key of `JsonClassInfo.ClassType` and type? With that in place the cache can slowly fill with permutations when these edge cases show up without having instances get in the way of one another.\r\n\r\nObviously when going down the composite key route the slower lookup will have some unknown effect on overall perf — I'm expecting tiny? — which still needs careful analysis.\r\n\r\nIf we expect it to be unfruitful it might make sense to keep most as-is and to push resolution of these differences into `JsonClassInfo` itself, have it function uniformly regardless of ClassType, say starting at a certain ClassType and synthesizing data for other ClassTypes on demand, not quite sure what this would mean for `JsonClassInfo.ClassType` and its uses though.\r\n\r\nAnything else seems like it would require a larger overhaul of the internals, do you have any suggestions?\r\n\r\nEither way thanks for the quick reply!",
          "createdAt": "2021-03-25T16:58:19Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-03-25T16:58:19Z",
          "id": "MDEyOklzc3VlQ29tbWVudDgwNzA5NjU4NQ=="
        },
        {
          "author": "layomia",
          "body": "A workaround here based your original approach is to create and cache a separate options instance, populated with the `JsonStringEnumConverter`, for the original/default `ImmutableArray<T>` converter to use (see https://dotnetfiddle.net/tbnB9f for full program):\r\n\r\n```cs\r\nclass JsonImmutableArrayConverter<T> : JsonConverter<ImmutableArray<T>>\r\n{\r\n    JsonSerializerOptions _originalOptions;\r\n    JsonConverter<ImmutableArray<T>> _originalConverter;\r\n\r\n    public JsonImmutableArrayConverter()\r\n    {\r\n\t_originalOptions = new JsonSerializerOptions()\r\n\t{\r\n            Converters = { new JsonStringEnumConverter(JsonNamingPolicy.CamelCase) }\r\n\t};\r\n\t_originalConverter = (JsonConverter<ImmutableArray<T>>)_originalOptions.GetConverter(typeof(ImmutableArray<T>));\r\n    }\r\n\r\n    public override ImmutableArray<T> Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)\r\n        => _originalConverter.Read(ref reader, typeToConvert, _originalOptions);\r\n\r\n    public override void Write(Utf8JsonWriter writer, ImmutableArray<T> value, JsonSerializerOptions options)\r\n    {\r\n        _originalConverter.Write(writer, value, _originalOptions);\r\n    }\r\n}\r\n```\r\nThen, the enum converter doesn't need to be specified at the root call to the serializer:\r\n\r\n```cs\r\nstatic void Main(string[] args)\r\n{\r\n    var options = new JsonSerializerOptions();\r\n    options.Converters.Add(new JsonImmutableArrayConverter());\r\n    //options.Converters.Add(new JsonStringEnumConverter(JsonNamingPolicy.CamelCase));\r\n            \r\n    ImmutableArray<Cases> deserialized = JsonSerializer.Deserialize<ImmutableArray<Cases>>(@\"[\"\"one\"\",\"\"two\"\",\"\"three\"\",\"\"four\"\"]\", options);\r\n\t\t\t\r\n    string serialized = JsonSerializer.Serialize(deserialized, options);\r\n    Console.WriteLine(serialized);\r\n}\r\n```\r\n\r\n---\r\n\r\nStill investigating the issue here, but generally, multiple options instances shouldn't be passed arbitrarily as inputs to converters or the serializer. The mitigation here might be for the serializer to detect and guard against unsupported options patterns, and throw meaningful exceptions.\r\n\r\n>  In any case I think its good to add some documentation on how to call into the framework converters from a custom converter, this has been something I've wanted to do (and done to various degrees of success) multiple times now.\r\n\r\nYes, we'll provide some documentation for this. We can add it to this page - https://docs.microsoft.com/dotnet/standard/serialization/system-text-json-converters-how-to?pivots=dotnet-5-0#error-handling. cc @tdykstra \r\n",
          "createdAt": "2021-03-25T17:24:37Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-03-25T17:24:37Z",
          "id": "MDEyOklzc3VlQ29tbWVudDgwNzEzNzMxNw=="
        },
        {
          "author": "layomia",
          "body": "> The reason for pulling out an 'original' converter like this is because some code paths in a custom converter should just be able to default to existing converters, merely wrapping over them.\r\n\r\nIn principle, I do agree that custom converters should be able to compose nicely with framework/STJ internal converters. I'm just curious about this specific scenario. What motivated the use of a custom converter here? Why not just:\r\n\r\n```cs\r\nstatic void Main(string[] args)\r\n{\r\n    var options = new JsonSerializerOptions();\r\n    options.Converters.Add(new JsonStringEnumConverter(JsonNamingPolicy.CamelCase));\r\n            \r\n    ImmutableArray<Cases> deserialized = JsonSerializer.Deserialize<ImmutableArray<Cases>>(@\"[\"\"one\"\",\"\"two\"\",\"\"three\"\",\"\"four\"\"]\", options);\r\n    Console.WriteLine(JsonSerializer.Serialize(deserialized, options));\r\n}\r\n```",
          "createdAt": "2021-03-25T17:30:06Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-03-25T17:30:06Z",
          "id": "MDEyOklzc3VlQ29tbWVudDgwNzE0NTg5MQ=="
        },
        {
          "author": "NinoFloris",
          "body": "@layomia obviously this is not a tenable solution, the ImmutableArrayConverter should not have to know about all Ts (and the right type of converter) for the entire application. It's also common enough to create converters that could get shipped as a package like this https://github.com/Tarmil/FSharp.SystemTextJson.\r\n\r\n>The mitigation here might be for the serializer to detect and guard against unsupported options patterns, and throw meaningful exceptions.\r\n\r\nProper compositionality is important, doing the easy thing here seems like it undermines the custom converter model of STJ a lot (and it's already — no doubt with good intentions — much more limited than the internal converters).\r\n\r\n>What motivated the use of a custom converter here? Why not just:\r\n\r\nImmutableArray is slow to serialize due to it falling into the IEnumerable path, yet as we like immutability we have many instances where we use it, so we have a converter that optimizes writes (via GetMemory and MemoryMarshal.TryGetArray which is entirely safe), but leaves reads as-is. I've also had cases around discriminated unions, custom collections or other functorial types where I just want to fall back to the framework converters when some pattern match or condition is hit, most of the times this is in the read path, as going from a reader to arbitrary .net objects is a pain I try to avoid (at least without the public metadata apis that were talked about).\r\n\r\nAnyway, I have at least somewhat optimized the 'hacky fix' I showed in my original comment by caching the diffed options on an instance field. We can then do an `Object.ReferenceEquals` on it against the options passed into Read. If they don't match we diff the passed in instance but otherwise we can move on straight away.",
          "createdAt": "2021-03-25T17:56:58Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-03-26T14:22:02Z",
                "user": "eiriktsarpalis"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOBlAYrQ=="
          },
          "updatedAt": "2021-03-25T17:57:15Z",
          "id": "MDEyOklzc3VlQ29tbWVudDgwNzE4OTE1OQ=="
        },
        {
          "author": "layomia",
          "body": "The value converter model based on directly deriving from `JsonConverter<T>` was really intended for simple/primitive types. The limitation with the `JsonConverter<T>.Read` method is that it doesn't have a `ReadStack` state parameter to properly flow type metadata (same issue with writing). We've talked a few times about a richer converter model for objects and collections which is based on passing state around (e.g. https://github.com/dotnet/runtime/pull/2259). This is the ideal direction for composability, and it would be great to get to this soon. \r\n\r\nA couple of workarounds have been mentioned so I hope for now your scenario is unblocked. In the meantime, we're evaluating adding a safe-guard in the code that bridges the  `JsonConverter<T>.Read` method call with the internal logic for objects/collections to ensure that the state metadata we initialized is correct:\r\n\r\nhttps://github.com/dotnet/runtime/blob/e503be0f9c37611bc03363751c67e660cd60b26a/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/JsonResumableConverterOfT.cs#L23-L24\r\n\r\nIt may look like this:\r\n\r\n```cs\r\nReadStack state = default;\r\nstate.Initialize(typeToConvert, options, supportContinuation: false);\r\nif (state.Current.JsonPropertyInfo.ConverterBase != this)\r\n{\r\n    throw new InvalidOperationException();\r\n}\r\nTryRead(ref reader, typeToConvert, options, ref state, out T? value);\r\n```\r\n\r\nThe original repro would fail with this exception. This exception may help uncover more interesting patterns/dependencies that our callers have.\r\n\r\ncc @steveharter \r\n\r\n---\r\n\r\nWe'll look into improving the performance of (de)serializing immutable collections. They are currently based on the `CreateRange` pattern which involves allocating a temporary collection. Using the builder pattern has better perf (https://dotnetfiddle.net/d5n55f).",
          "createdAt": "2021-03-26T17:37:38Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-03-26T17:37:38Z",
          "id": "MDEyOklzc3VlQ29tbWVudDgwODQwMTI0NQ=="
        },
        {
          "author": "NinoFloris",
          "body": "Thanks!\r\n\r\n>We've talked a few times about a richer converter model for objects and collections which is based on passing state around\r\n\r\nI'll be sure to subscribe to #36785 :)\r\n\r\n>We'll look into improving the performance of (de)serializing immutable collections. They are currently based on the CreateRange pattern which involves allocating a temporary collection. Using the builder pattern has better perf (https://dotnetfiddle.net/d5n55f).\r\n\r\nNice to see some love for deserializing into immutable collections! For us writing them fast is important as we have http read heavy workloads. Hopefully you could look into using MemoryMarshal as well for ImmutableArray. This is 100% binary compatible as long as you error out or fall back to IEnumerable when TryGetArray returns false. In the highly unlikely event ImmutableArray suddenly starts using native memory ;)",
          "createdAt": "2021-03-26T17:50:04Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-03-26T17:50:04Z",
          "id": "MDEyOklzc3VlQ29tbWVudDgwODQwODQ1MQ=="
        },
        {
          "author": "layomia",
          "body": "We don't have work planned to address this for .NET 6.0, we should consider in 7.",
          "createdAt": "2021-07-23T01:32:21Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-07-23T01:32:21Z",
          "id": "IC_kwDODI9FZc40xT8L"
        },
        {
          "author": "eiriktsarpalis",
          "body": "One possible fix is to have the internal converters encapsulate their corresponding `JsonTypeInfo` metadata. We don't do it currently since converters are meant to be decoupled from `JsonSerializerOptions` and any metadata it may carry. Our built-in converters however are special, since they are instantiated using internal converter factories. As such, every instance is tightly coupled to the `JsonSerializerOptions` instance that originated it, and this bug is a consequence of us not observing this invariant.\r\n\r\nTagging @krwq who might be interested in this topic.",
          "createdAt": "2022-04-18T15:10:59Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-04-18T15:10:59Z",
          "id": "IC_kwDODI9FZc5Bp02R"
        },
        {
          "author": "eiriktsarpalis",
          "body": "We won't have time to work on this for .NET 7, moving to Future.",
          "createdAt": "2022-05-10T16:59:51Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-05-10T16:59:51Z",
          "id": "IC_kwDODI9FZc5C6kGn"
        },
        {
          "author": "krwq",
          "body": "We should tackle this in conjunction with https://github.com/dotnet/runtime/issues/63791 and https://github.com/dotnet/runtime/issues/54189",
          "createdAt": "2022-09-28T16:06:07Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-09-28T16:06:07Z",
          "id": "IC_kwDODI9FZc5LK1kS"
        },
        {
          "author": "gregsdennis",
          "body": "As part of a recent AOT-compatibility update, [_Json.More.Net_](https://www.nuget.org/packages/Json.More.Net) now includes several `JsonSerializerOptions` extensions that help working around this issue.",
          "createdAt": "2024-02-04T20:53:14Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-02-04T20:53:14Z",
          "id": "IC_kwDODI9FZc5yyxHH"
        },
        {
          "author": "Mad-Lynx",
          "body": "I come across this issue when I was trying to write the complex object to a json using \"default converter\" (#111429).\nRight now had to abandoned the concept of using the default converter and write the code myself - which is not ideal.\n\nWould be great if that issue was pick up again and we could expect some proper solution to this.",
          "createdAt": "2025-01-20T11:08:59Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-01-20T11:08:59Z",
          "id": "IC_kwDODI9FZc6bGVM2"
        },
        {
          "author": "bkoelman",
          "body": "> The value converter model based on directly deriving from `JsonConverter<T>` was really intended for simple/primitive types. The limitation with the `JsonConverter<T>.Read` method is that it doesn't have a `ReadStack` state parameter to properly flow type metadata (same issue with writing). We've talked a few times about a richer converter model for objects and collections which is based on passing state around (e.g. [#2259](https://github.com/dotnet/runtime/pull/2259)). This is the ideal direction for composability, and it would be great to get to this soon.\n\nI believe this is the fundamental problem that needs to be addressed. Even today I keep running into various issues, such as incorrect error locations in JsonException, in both my own and third-party code. Whenever possible, I try to avoid using non-leaf custom converters, despite the advise in documentation. This is a pain.",
          "createdAt": "2025-01-20T20:48:28Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-03-20T19:47:21Z",
                "user": "m0a0k0s"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOEKxk-Q=="
          },
          "updatedAt": "2025-01-20T20:48:28Z",
          "id": "IC_kwDODI9FZc6bKdTD"
        }
      ],
      "totalCount": 16,
      "endCursor": "Y3Vyc29yOnYyOpHOmynUww=="
    },
    "url": "https://github.com/dotnet/runtime/issues/50205",
    "title": "Internal json converters cannot function independently of their original options"
  },
  {
    "author": "goyzhang",
    "labels": [
      "bug",
      "area-System.Text.Json"
    ],
    "createdAt": "2021-04-13T07:58:06Z",
    "body": "When JsonPropertyName is applied to a sub-class override member, the original name in the parent class is preserved in the output of JsonSerializer.Serialize, as a result, that's two JSON field. I don't think this is by design?\n\n### Description\n\n```csharp\nabstract class Person\n{\n    public abstract string Name { get; set; }\n}\nclass Student : Person\n{\n    [JsonPropertyName(\"StudentName\")]\n    public override string Name { get; set; }\n}\n\nvar json = JsonSerializer.Serialize(new Student() { Name = \"Alice\" });\n```\n\n* Expected:\n`{\"StudentName\":\"Alice\"}`\n* Actual:\n`{\"StudentName\":\"Alice\",\"Name\":\"Alice\"}`\n\n### Configuration\n\n\n* Which version of .NET is the code running on?\n.NET 5.0.2\n* What OS and version, and what distro if applicable?\nWindows 10 2004\n* What is the architecture (x64, x86, ARM, ARM64)?\nX64\n",
    "number": 51165,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-08-13T07:18:39Z",
          "user": "fudiwei"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-10-15T19:54:46Z",
          "user": "IGx89"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-04-18T21:58:30Z",
          "user": "leoshusar"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-02-18T20:37:38Z",
          "user": "tanveerbadar"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-04-29T13:15:07Z",
          "user": "superkartoffel"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-05-22T15:09:29Z",
          "user": "stevebumbaugh"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-10-16T10:21:42Z",
          "user": "sakitA"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-01-22T16:40:12Z",
          "user": "FrankNiemeyer"
        }
      ],
      "totalCount": 8,
      "endCursor": "Y3Vyc29yOnYyOpHOC-Xm0g=="
    },
    "updatedAt": "2025-09-16T02:16:07Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @eiriktsarpalis, @layomia\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\nWhen JsonPropertyName is applied to a sub-class override member, the original name in the parent class is preserved in the output of JsonSerializer.Serialize, as a result, that's two JSON field. I don't think this is by design?\r\n\r\n### Description\r\n\r\n```\r\n\tabstract class Person\r\n\t{\r\n\t\tpublic abstract string Name { get; set; }\r\n\t}\r\n\tclass Student : Person\r\n\t{\r\n\t\t[JsonPropertyName(\"StudentName\")]\r\n\t\tpublic override string Name { get; set; }\r\n\t}\r\n\r\nvar json = JsonSerializer.Serialize(new Student() { Name = \"Alice\" });\r\n```\r\n\r\n* Expected:\r\n`{\"StudentName\":\"Alice\"}`\r\n* Actual:\r\n`{\"StudentName\":\"Alice\",\"Name\":\"Alice\"}`\r\n\r\n### Configuration\r\n\r\n\r\n* Which version of .NET is the code running on?\r\n.NET 5.0.2\r\n* What OS and version, and what distro if applicable?\r\nWindows 10 2004\r\n* What is the architecture (x64, x86, ARM, ARM64)?\r\nX64\r\n\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>goyzhang</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`area-System.Text.Json`, `untriaged`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2021-04-13T07:58:10Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-04-13T07:58:10Z",
          "id": "MDEyOklzc3VlQ29tbWVudDgxODUzMDI3MA=="
        },
        {
          "author": "eiriktsarpalis",
          "body": "That seems like a bug to me. FWIW I can reproduce the same behaviour when I create this combination:\r\n```csharp\r\npublic abstract class Person\r\n{\r\n    [JsonPropertyName(\"StudentName\")]\r\n    public virtual string Name { get; }\r\n}\r\npublic class Student : Person\r\n{\r\n    public override string Name => \"Bob\";\r\n}\r\n```\r\nbut the issue goes away when I remove the `JsonPropertyName` attribute altogether. cc @layomia ",
          "createdAt": "2021-04-13T11:54:26Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-04-13T11:54:26Z",
          "id": "MDEyOklzc3VlQ29tbWVudDgxODY3NjI0MA=="
        },
        {
          "author": "devsko",
          "body": "@eiriktsarpalis I can have a look. Even if it's a bug - fixing this would be a breaking change.",
          "createdAt": "2021-04-24T07:14:29Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-04-24T07:14:29Z",
          "id": "MDEyOklzc3VlQ29tbWVudDgyNjA0ODM5OQ=="
        },
        {
          "author": "layomia",
          "body": "Triage - this isn't a regression from .NET 5.0 and I think it's a bit too late in the 6.0 wave to introduce a breaking change like this. We should consider in .NET 7.0.",
          "createdAt": "2021-07-23T03:02:51Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-07-23T03:02:51Z",
          "id": "IC_kwDODI9FZc40xZ3M"
        },
        {
          "author": "simon10says",
          "body": "Is there any workaround?",
          "createdAt": "2022-01-11T13:30:59Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-01-11T13:30:59Z",
          "id": "IC_kwDODI9FZc48Mt7q"
        },
        {
          "author": "rogerfar",
          "body": "Another bug related to this issue.\r\n\r\n```\r\n\tabstract class Person\r\n\t{\r\n\t\t[JsonPropertyName(\"StudentName\")]\r\n\t\tpublic abstract string Name { get; set; }\r\n\t}\r\n\tclass Student : Person\r\n\t{\r\n\t\tpublic override string Name { get; set; }\r\n\t}\r\n\r\nvar json = JsonSerializer.Serialize(new Student() { Name = \"Alice\" });\r\n```\r\n\r\nResults in 2 properties:\r\n```\r\n{\r\n    Name: 'Alice',\r\n    StudentName: 'Alice'\r\n}\r\n```",
          "createdAt": "2022-06-29T20:12:52Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-06-29T20:12:52Z",
          "id": "IC_kwDODI9FZc5Fw6Y1"
        },
        {
          "author": "krwq",
          "body": "Unfortunately we won't have time to address this in 7.0 but [contract customization](https://github.com/dotnet/runtime/issues/63686) can be used to workaround this. Moving to 8.0 in the meantime",
          "createdAt": "2022-07-07T13:30:30Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-07-07T13:30:30Z",
          "id": "IC_kwDODI9FZc5GMQes"
        },
        {
          "author": "kgbaum",
          "body": "For those who may be looking for a work around until this can be addressed.  You can make use of a dummy property:\r\n\r\n\tabstract class Person\r\n\t{\r\n\t\tpublic abstract string Name { get; set; }\r\n\t}\r\n\tclass Student : Person\r\n\t{\r\n\t\t[JsonIgnore]\r\n\t\tpublic override string Name { get => base.Name; set => base.Name = value; }\r\n\t\t\r\n\t\tpublic string StudentName { get => base.Name; set => base.Name = value; }\r\n\t}",
          "createdAt": "2023-02-28T18:35:14Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-05-22T15:10:10Z",
                "user": "stevebumbaugh"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHODixong=="
          },
          "updatedAt": "2023-02-28T18:35:14Z",
          "id": "IC_kwDODI9FZc5WWP7x"
        },
        {
          "author": "pinkfloydx33",
          "body": "Just ran into this as well. I was hoping to avoid contract customization as it feels a bit heavy for this; might try the workaround posted above instead. Would be nice if it worked out of the box though",
          "createdAt": "2023-03-13T13:42:55Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-05-22T15:10:01Z",
                "user": "stevebumbaugh"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-10-16T09:46:56Z",
                "user": "elgonzo"
              }
            ],
            "totalCount": 2,
            "endCursor": "Y3Vyc29yOnYyOpHOD2hcZw=="
          },
          "updatedAt": "2023-03-13T13:42:55Z",
          "id": "IC_kwDODI9FZc5XY_Te"
        },
        {
          "author": "tanveerbadar",
          "body": "This is causing source generation to generate invalid code when it interacts with `JsonIgnoreCondition.WhenWritingDefault` or `JsonIgnoreCondition.WhenWritingNull`.\r\n\r\n#98634 ",
          "createdAt": "2024-02-18T20:39:45Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-02-18T20:40:31Z",
          "id": "IC_kwDODI9FZc50UJlV"
        },
        {
          "author": "keystroke",
          "body": "This bug still exists in .net8... produces completely invalid json.",
          "createdAt": "2025-02-05T19:50:43Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-02-05T19:50:43Z",
          "id": "IC_kwDODI9FZc6dOva5"
        },
        {
          "author": "doug62",
          "body": "This bug still exists in .net9... produces completely invalid json.\n\nJeepers - this is serious",
          "createdAt": "2025-09-16T02:16:07Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-09-16T02:16:07Z",
          "id": "IC_kwDODI9FZc7EX6NX"
        }
      ],
      "totalCount": 12,
      "endCursor": "Y3Vyc29yOnYyOpHOxF-jVw=="
    },
    "url": "https://github.com/dotnet/runtime/issues/51165",
    "title": "JsonPropertyName inheritance perserve the parent member"
  },
  {
    "author": "steveharter",
    "labels": [
      "area-System.Text.Json",
      "size-reduction"
    ],
    "createdAt": "2021-04-23T19:55:32Z",
    "body": "A prototype showed a 35% reduction of a trimmed `System.Text.Json.dll` with `JsonDocument` and `JsonNode` classes linked out. This also includes ancillary classes like `JsonElement`, `JsonObject`, `JsonArray` and `JsonValue`.\r\n\r\nThere are two scenarios for trimming: one with the JSON source generator used, and one without.\r\n- `JsonValue` is already trimmed (or should be) if the source generator is used, but not for the non-source generator case.\r\n- `JsonDocument` is never currently trimmed.\r\n\r\nThese can be safely trimmed out if:\r\n- `[JsonExtensionData]` is not used\r\n- Polymorphic deserialization to `System.Object` members is not used\r\n- The new `JsonNode` classes are not used\r\n- The `JsonDocument` and `JsonElement` types are not used.\r\n\r\nTo allow the non-source generator to safely link out `JsonNode`:\r\n- Hard reference on `JsonExtensionDataAttribute` to `JsonElement` and `JsonNode` to root these types when that feature is used.\r\n- Add a root dependency to `JsonNode` on the setter to `JsonSerializerOptions.UnknownTypeHandling` (default is to use `JsonElement`, so the setter must be called to change to `JsonNode`) or add alternative API that enables polymorphic (de)serialization in general (see below for potential breaking change).\r\n\r\nTo allow the source generator to link out `JsonDocument` the serializer dependencies can be addressed by:\r\n- A loosely typed converter model for these types, perhaps using reflection to instantiate the converter.\r\n- Hard references to these types replaced with string-based type name comparisons (similar to how this is done with `JsonNode` today).\r\n- The extension property code reworked to support late binding (similar to how this is done with `JsonNode` today).\r\n- The reference handling code reworked to support late binding\r\n\r\nTo allow the non-source generator cases we could introduce a breaking change for polymorphic deserialization of `System.Object`-declared properties\\fields\\elements:\r\n  - Change the `JsonSerializerOptions.UnknownTypeHandling` to add a new default value of \"none\" (or similar new API).\r\n  - Note that today a user can also specify `JsonElement` or `JsonObject` as a property\\field\\element instead of `System.Object` in order to be explicit and avoid having to set `UnknownTypeHandling`.\r\n  - Note any API changes can be reconciled with the potential new support for true polymorphic deserialization being discussed for 6.0.\r\n ",
    "number": 51756,
    "reactions": {
      "hasNextPage": false,
      "nodes": [],
      "totalCount": 0,
      "endCursor": null
    },
    "updatedAt": "2022-07-09T07:33:33Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @eiriktsarpalis, @layomia\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\nA prototype showed a 35% reduction of a trimmed `System.Text.Json.dll` with `JsonDocument` and `JsonNode` classes linked out. This also includes ancillary classes like `JsonElement`, `JsonObject`, `JsonArray` and `JsonValue`.\r\n\r\nThese can be trimmed out if:\r\n- [JsonExtensionData] is not used\r\n- The new `JsonNode` classes are not used\r\n- The `JsonDocument` and `JsonElement` types are not used.\r\n\r\nThe reader\\writer do not have any dependencies on these types.\r\n\r\nThe serializer does have dependencies on these but these can be addressed by:\r\n- A loosely typed converter model for these types, perhaps using reflection to instantiate the converter.\r\n- Hard references to these types replaced with string-based type name comparisons.\r\n- The extension property code reworked to support late binding\r\n- The reference handling code reworked to support late binding\r\n- Hard reference on `JsonExtensionDataAttribute` to `JsonElement`\\`JsonNode` to keep these types to support that feature.- \r\n\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>steveharter</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`area-System.Text.Json`, `linkable-framework`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2021-04-23T19:55:35Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-04-23T19:55:35Z",
          "id": "MDEyOklzc3VlQ29tbWVudDgyNTg4NTY4NQ=="
        },
        {
          "author": null,
          "body": "Tagging subscribers to 'size-reduction': @eerhardt, @SamMonoRT, @marek-safar, @CoffeeFlux\nSee info in area-owners.md if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\nA prototype showed a 35% reduction of a trimmed `System.Text.Json.dll` with `JsonDocument` and `JsonNode` classes linked out. This also includes ancillary classes like `JsonElement`, `JsonObject`, `JsonArray` and `JsonValue`.\r\n\r\nThese can be trimmed out if:\r\n- [JsonExtensionData] is not used\r\n- Polymorphic deserialization to `System.Object` members is not used\r\n- The new `JsonNode` classes are not used\r\n- The `JsonDocument` and `JsonElement` types are not used.\r\n\r\nThe reader\\writer do not have any dependencies on these types.\r\n\r\nThe serializer does have dependencies on these but these can be addressed by:\r\n- A loosely typed converter model for these types, perhaps using reflection to instantiate the converter.\r\n- Opt-in to polymorphic deserialization of `System.Object`-declared properties\\fields\\elements.\r\n  - Today a `JsonElement` is created to hold the values but that can be changed to `JsonObject` via the new `JsonSerializerOptions.UnknownTypeHandling`. We could add a new default value of \"none\".\r\n  - Today a user can also specify `JsonElement` or `JsonObject` as a property\\field\\element instead of `System.Object` in order to be explicit and avoid having to set `UnknownTypeHandling`.\r\n  - Also any API changes can be reconciled with the potential new support for true polymorphic deserialization being discussed for 6.0.\r\n- Hard references to these types replaced with string-based type name comparisons.\r\n- The extension property code reworked to support late binding\r\n- The reference handling code reworked to support late binding\r\n- Hard reference on `JsonExtensionDataAttribute` to `JsonElement`\\`JsonNode` to keep these types to support that feature.- \r\n\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>steveharter</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`area-System.Text.Json`, `size-reduction`, `untriaged`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2021-04-23T22:19:25Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-04-23T22:19:25Z",
          "id": "MDEyOklzc3VlQ29tbWVudDgyNTk1MjU0NA=="
        },
        {
          "author": "steveharter",
          "body": "Since the main scenario for trimming is Blazor client, this suggestion will not help much since the `JsonElement` is used by Blazor. The bulk of `JsonNode` should already be trimmed for Blazor since it is not used.\r\n\r\nMoving to 7.0 if we want to refactor Blazor to use `Utf8JsonReader` instead of `JsonElement`, so that `JsonElement` can be trimmed.",
          "createdAt": "2021-08-03T20:48:35Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-08-03T20:48:35Z",
          "id": "IC_kwDODI9FZc41LTal"
        }
      ],
      "totalCount": 3,
      "endCursor": "Y3Vyc29yOnYyOpHONS02pQ=="
    },
    "url": "https://github.com/dotnet/runtime/issues/51756",
    "title": "Possible linker removal of JsonDocument and JsonNode (+ ancillary classes) to save 35% of STJ.dll size"
  },
  {
    "author": "eerhardt",
    "labels": [
      "area-System.Text.Json",
      "test-enhancement",
      "linkable-framework",
      "source-generator"
    ],
    "createdAt": "2021-05-28T16:56:25Z",
    "body": "The JsonSerializer is not trim-compatible when not using the JSON source generator (see #51886). However, we have a bunch of \"trimming tests\" that used it in a trimmed app, but only for one level of objects (like just one `Hashtable` or `Queue<T>`).\r\n\r\nI am removing a bunch of these tests while working on #52268 and #53256 because they no longer pass after these issues are resolved.\r\n\r\nHowever, supporting these scenarios in a trimmed app is important. The trim-compatible way to use JsonSerializer is to use the JSON source generator, and pass in the generated `JsonTypeInfo<T>` to the JsonSerializer.\r\n\r\nWe should re-do these trimming tests to use the JSON source generator and add them back. However, this can't happen until the JSON source generator supports all the collection types that the JsonSerializer supports (#53393).\r\n\r\nThis issue is to track bringing all these trimming tests using the JSON source generator.\r\n\r\ncc @layomia ",
    "number": 53437,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-05-28T21:33:30Z",
          "user": "layomia"
        }
      ],
      "totalCount": 1,
      "endCursor": "Y3Vyc29yOnYyOpHOBsrE5w=="
    },
    "updatedAt": "2024-04-24T18:48:00Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @eiriktsarpalis, @layomia\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\nThe JsonSerializer is not trim-compatible when not using the JSON source generator (see #51886). However, we have a bunch of \"trimming tests\" that used it in a trimmed app, but only for one level of objects (like just one `Hashtable` or `Queue<T>`).\r\n\r\nI am removing a bunch of these tests while working on #52268 and #53256 because they no longer pass after these issues are resolved.\r\n\r\nHowever, supporting these scenarios in a trimmed app is important. The trim-compatible way to use JsonSerializer is to use the JSON source generator, and pass in the generated `JsonTypeInfo<T>` to the JsonSerializer.\r\n\r\nWe should re-do these trimming tests to use the JSON source generator and add them back. However, this can't happen until the JSON source generator supports all the collection types that the JsonSerializer supports (#53393).\r\n\r\nThis issue is to track bringing all these trimming tests using the JSON source generator.\r\n\r\ncc @layomia \n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>eerhardt</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`area-System.Text.Json`, `linkable-framework`, `test enhancement`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2021-05-28T16:56:27Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-05-28T16:56:27Z",
          "id": "MDEyOklzc3VlQ29tbWVudDg1MDU0ODEyNA=="
        },
        {
          "author": "eiriktsarpalis",
          "body": "Test enhancement, moving to 7.0.0.",
          "createdAt": "2021-08-09T18:06:31Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-08-09T18:06:31Z",
          "id": "IC_kwDODI9FZc41XyfT"
        },
        {
          "author": "eiriktsarpalis",
          "body": "I believe this has been superseded by recent work.",
          "createdAt": "2023-06-07T23:10:28Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-06-07T23:10:28Z",
          "id": "IC_kwDODI9FZc5eRbnt"
        },
        {
          "author": "MichalStrehovsky",
          "body": "> I believe this has been superseded by recent work.\r\n\r\nThe trimming tests are not using the source generator.",
          "createdAt": "2024-04-24T18:47:50Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-04-24T18:47:50Z",
          "id": "IC_kwDODI9FZc57t0Qs"
        }
      ],
      "totalCount": 4,
      "endCursor": "Y3Vyc29yOnYyOpHOe7dELA=="
    },
    "url": "https://github.com/dotnet/runtime/issues/53437",
    "title": "JsonSerializer trimming tests should be re-written to use the source generator"
  },
  {
    "author": "layomia",
    "labels": [
      "area-System.Text.Json",
      "source-generator"
    ],
    "createdAt": "2021-06-10T16:02:14Z",
    "body": "https://github.com/dotnet/runtime/issues/1784 discusses writing raw JSON values when using `Utf8JsonWriter`. We can build on top that to support writing raw property names. This could be useful when pre-generating JSON serialization logic and we know the runtime property names ahead of time.\r\n\r\nFrom @Tornhoof in https://github.com/dotnet/runtime/issues/1784#issuecomment-849451188:\r\n\r\n> As linked by @layomia for the source-gen code (https://github.com/dotnet/runtime/pull/53212#issuecomment-848652045) having a Raw Write functionality could be useful to replace the `JsonEncodedText` members with `ReadOnlySpan<byte>` and preencoded utf8 member names. At the moment, Benchmarks show that `JsonEncodedText` is faster (10-15%) for writing known property names in json as there is a fastpath for it. For the ROS overload it needs to check the validity of the bytes and possibly escaping. Having a Raw API to bypass the encoding check the performance, should be similar and would allow the source-gen to use ROS.\r\n\r\n<details>\r\n<summary>\r\n\r\nBenchmarks  (also from https://github.com/dotnet/runtime/issues/1784#issuecomment-849451188)\r\n\r\n</summary>\r\n\r\n```csharp\r\n\r\n\tpublic class JsonWriteBenchmark\r\n\t{\r\n\t\tprivate static readonly JsonEncodedText JetPropertyName = JsonEncodedText.Encode(\"message\");\r\n\r\n\t\tprivate static ReadOnlySpan<byte> ROSPropertyName =>\r\n\t\t\tnew byte[] {0x6D, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65};\r\n\r\n\r\n\t\t[Benchmark]\r\n\t\tpublic void WriteReadOnlySpanPropertyName()\r\n\t\t{\r\n\t\t\tusing var ms = new MemoryStream();\r\n\t\t\tUtf8JsonWriter writer = new Utf8JsonWriter(ms);\r\n\t\t\twriter.WriteStartObject();\r\n\t\t\twriter.WriteString(ROSPropertyName, \"Hello World\");\r\n\t\t\twriter.WriteEndObject();\r\n\t\t\twriter.Flush();\r\n\t\t}\r\n\r\n\t\t[Benchmark]\r\n\t\tpublic void WriteJsonEncodedTextPropertyName()\r\n\t\t{\r\n\t\t\tusing var ms = new MemoryStream();\r\n\t\t\tUtf8JsonWriter writer = new Utf8JsonWriter(ms);\r\n\t\t\twriter.WriteStartObject();\r\n\t\t\twriter.WriteString(JetPropertyName, \"Hello World\");\r\n\t\t\twriter.WriteEndObject();\r\n\t\t\twriter.Flush();\r\n\t\t}\r\n\t}\r\n```\r\n</details>",
    "number": 54005,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-01-13T22:13:11Z",
          "user": "grbell-ms"
        }
      ],
      "totalCount": 1,
      "endCursor": "Y3Vyc29yOnYyOpHOCJ3MIQ=="
    },
    "updatedAt": "2022-10-14T16:15:21Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @eiriktsarpalis, @layomia\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\nhttps://github.com/dotnet/runtime/issues/1784 discusses writing raw property values when using `Utf8JsonWriter`. We can build on top that to support writing raw property names. This could be useful when pre-generating JSON serialization logic and we know the runtime property names ahead of time.\r\n\r\nFrom @Tornhoof in https://github.com/dotnet/runtime/issues/1784#issuecomment-849451188:\r\n\r\n> As linked by @layomia for the source-gen code (https://github.com/dotnet/runtime/pull/53212#issuecomment-848652045) having a Raw Write functionality could be useful to replace the `JsonEncodedText` members with `ReadOnlySpan<byte>` and preencoded utf8 member names. At the moment, Benchmarks show that `JsonEncodedText` is faster (10-15%) for writing known property names in json as there is a fastpath for it. For the ROS overload it needs to check the validity of the bytes and possibly escaping. Having a Raw API to bypass the encoding check the performance, should be similar and would allow the source-gen to use ROS.\r\n\r\n<details>\r\n<summary>\r\n\r\nBenchmarks  (also from https://github.com/dotnet/runtime/issues/1784#issuecomment-849451188)\r\n\r\n</summary>\r\n\r\n```csharp\r\n\r\n\tpublic class JsonWriteBenchmark\r\n\t{\r\n\t\tprivate static readonly JsonEncodedText JetPropertyName = JsonEncodedText.Encode(\"message\");\r\n\r\n\t\tprivate static ReadOnlySpan<byte> ROSPropertyName =>\r\n\t\t\tnew byte[] {0x6D, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65};\r\n\r\n\r\n\t\t[Benchmark]\r\n\t\tpublic void WriteReadOnlySpanPropertyName()\r\n\t\t{\r\n\t\t\tusing var ms = new MemoryStream();\r\n\t\t\tUtf8JsonWriter writer = new Utf8JsonWriter(ms);\r\n\t\t\twriter.WriteStartObject();\r\n\t\t\twriter.WriteString(ROSPropertyName, \"Hello World\");\r\n\t\t\twriter.WriteEndObject();\r\n\t\t\twriter.Flush();\r\n\t\t}\r\n\r\n\t\t[Benchmark]\r\n\t\tpublic void WriteJsonEncodedTextPropertyName()\r\n\t\t{\r\n\t\t\tusing var ms = new MemoryStream();\r\n\t\t\tUtf8JsonWriter writer = new Utf8JsonWriter(ms);\r\n\t\t\twriter.WriteStartObject();\r\n\t\t\twriter.WriteString(JetPropertyName, \"Hello World\");\r\n\t\t\twriter.WriteEndObject();\r\n\t\t\twriter.Flush();\r\n\t\t}\r\n\t}\r\n```\r\n</details>\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>layomia</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`area-System.Text.Json`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>6.0.0</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2021-06-10T16:02:18Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-06-10T16:02:18Z",
          "id": "MDEyOklzc3VlQ29tbWVudDg1ODc0NzcxOA=="
        },
        {
          "author": "ahazelwood",
          "body": "This is currently a blocker for us as we rely heavily in places on the JSON.Net JsonTextWriter QuoteName property, where we set the value to false to output serialized objects directly for usage within javascript on a page.",
          "createdAt": "2022-10-14T16:15:20Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-10-14T16:15:20Z",
          "id": "IC_kwDODI9FZc5MPyYP"
        }
      ],
      "totalCount": 2,
      "endCursor": "Y3Vyc29yOnYyOpHOTD8mDw=="
    },
    "url": "https://github.com/dotnet/runtime/issues/54005",
    "title": "Consider adding Utf8JsonWriter support for writing raw property names"
  },
  {
    "author": "RamjotSingh",
    "labels": [
      "api-needs-work",
      "area-System.Text.Json",
      "User Story",
      "Team:Libraries",
      "partner-impact"
    ],
    "createdAt": "2021-06-14T23:34:06Z",
    "body": "JsonConverter allows specifying the conveter to be used for a specific property, however if a collection is in use and you want to use the converter to serialize a items in collection it doesn't work.\r\n\r\nExample\r\n```cs\r\npublic enum Day\r\n{\r\n   Sunday,\r\n   Monday,\r\n}\r\n\r\npublic class Model\r\n{\r\n    [JsonConverter(typeof(JsonStringEnumConverter))]\r\n    public IEnumerable<Day> Days { get; set; }\r\n}\r\n```\r\n\r\nThe above code will throw. The only way to work around is to write a custom converter which understands collections and uses a different converter for each item in collection.\r\n\r\nI propose a new attribute which allows the caller to specify converter to use for items in collection should be added. Something like\r\n\r\n```\r\n[JsonCollectionItemConverter(typeof(JsonStringEnumConverter))]\r\n```\r\n\r\nNewtonsoft.Json allows this by allowing specifying the type in JsonProperty attribute. That option has it's own shortcomings as well. I believe the above option will solve that too.",
    "number": 54189,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-02-13T20:39:32Z",
          "user": "Akarinnnnn"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-12-26T22:46:40Z",
          "user": "HeroMaxPower"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-01-15T09:08:40Z",
          "user": "N0D4N"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-01-26T21:12:01Z",
          "user": "anreton"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-02-01T20:35:53Z",
          "user": "virzak"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-02-24T19:10:23Z",
          "user": "sfmskywalker"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-03-14T16:12:27Z",
          "user": "Mrxx99"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-05-26T09:56:17Z",
          "user": "gigi81"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-06-29T14:31:52Z",
          "user": "Sibusten"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-08-29T23:28:08Z",
          "user": "AndrewBoklashko"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-09-19T02:29:04Z",
          "user": "rcdailey"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-09-22T09:08:54Z",
          "user": "fowl2"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-03-15T15:31:33Z",
          "user": "RenderMichael"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-03-25T09:55:48Z",
          "user": "gpuchtel"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-03-25T11:50:01Z",
          "user": "gpuchtel-grubbrr"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-08-30T06:06:59Z",
          "user": "rjfa"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-10-21T21:07:10Z",
          "user": "tzographos"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-11-29T22:27:20Z",
          "user": "pozy"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-03-29T02:25:21Z",
          "user": "YohanSciubukgian"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-03-29T11:24:03Z",
          "user": "fitdev"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-03-31T14:11:30Z",
          "user": "dmack-blackford"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-07-18T21:24:13Z",
          "user": "Athari"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-09-07T09:59:56Z",
          "user": "badandbest"
        }
      ],
      "totalCount": 23,
      "endCursor": "Y3Vyc29yOnYyOpHODO5UIA=="
    },
    "updatedAt": "2025-05-05T23:20:01Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @eiriktsarpalis, @layomia\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\nJsonConverter allows specifying the conveter to be used for a specific property, however if a collection is in use and you want to use the converter to serialize a items in collection it doesn't work.\r\n\r\nExample\r\n```cs\r\npublic enum Day\r\n{\r\n   Sunday,\r\n   Monday,\r\n}\r\n\r\npublic class Model\r\n{\r\n    [JsonConverter(typeof(JsonStringEnumConverter))]\r\n    public IEnumerable<Day> Days { get; set; }\r\n}\r\n```\r\n\r\nThe above code will throw. The only way to work around is to write a custom converter which understands collections and uses a different converter for each item in collection.\r\n\r\nI propose a new attribute which allows the caller to specify converter to use for items in collection should be added. Something like\r\n\r\n```\r\n[JsonCollectionItemConverter(typeof(JsonStringEnumConverter))]\r\n```\r\n\r\nNewtonsoft.Json allows this by allowing specifying the type in JsonProperty attribute. That option has it's own shortcomings as well. I believe the above option will solve that too.\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>RamjotSingh</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`area-System.Text.Json`, `untriaged`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2021-06-14T23:34:09Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-06-14T23:34:09Z",
          "id": "MDEyOklzc3VlQ29tbWVudDg2MTA2MDA0NQ=="
        },
        {
          "author": "eiriktsarpalis",
          "body": "Playing devil's advocate, is there anything in your scenario that prevents you from doing\r\n```csharp\r\n[JsonConverter(typeof(JsonStringEnumConverter))]\r\npublic enum Day\r\n{\r\n   Sunday,\r\n   Monday,\r\n}\r\n```\r\nor registering the converter for the enum via `JsonSerializerOptions`?",
          "createdAt": "2021-06-15T09:52:57Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-08-02T14:27:38Z",
                "user": "Namoshek"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-10-06T16:07:10Z",
                "user": "steve16351"
              }
            ],
            "totalCount": 2,
            "endCursor": "Y3Vyc29yOnYyOpHODI4Lsg=="
          },
          "updatedAt": "2021-06-15T09:52:57Z",
          "id": "MDEyOklzc3VlQ29tbWVudDg2MTM1OTI0Mw=="
        },
        {
          "author": "RamjotSingh",
          "body": "There are a lot of reasons to not do this\r\n\r\n1. You want per reference or per enum serialization behavior\r\n2. From reading code perspective, it is easier to understand things if the converter is directly on the property itself since rest of the info (JsonPropertyName).\r\n\r\nI don't think 3 ways of specifying converter are not replacement for each other.",
          "createdAt": "2021-06-15T16:00:24Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-03-14T16:12:54Z",
                "user": "Mrxx99"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-01-10T10:16:57Z",
                "user": "xshaheen"
              }
            ],
            "totalCount": 2,
            "endCursor": "Y3Vyc29yOnYyOpHODR3zBg=="
          },
          "updatedAt": "2021-06-15T16:00:24Z",
          "id": "MDEyOklzc3VlQ29tbWVudDg2MTYyNDA1NA=="
        },
        {
          "author": "RamjotSingh",
          "body": "If someone else hits this same problem. Here is a workaround. Its not the sanest solution hence I would like the library to support it out of the box.\r\n\r\n```cs\r\n     /// <summary>\r\n    /// Json collection converter.\r\n    /// </summary>\r\n    /// <typeparam name=\"TDatatype\">Type of item to convert.</typeparam>\r\n    /// <typeparam name=\"TConverterType\">Converter to use for individual items.</typeparam>\r\n    public class JsonCollectionItemConverter<TDatatype, TConverterType> : JsonConverter<IEnumerable<TDatatype>>\r\n        where TConverterType : JsonConverter\r\n    {\r\n        /// <summary>\r\n        /// Reads a json string and deserializes it into an object.\r\n        /// </summary>\r\n        /// <param name=\"reader\">Json reader.</param>\r\n        /// <param name=\"typeToConvert\">Type to convert.</param>\r\n        /// <param name=\"options\">Serializer options.</param>\r\n        /// <returns>Created object.</returns>\r\n        public override IEnumerable<TDatatype> Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)\r\n        {\r\n            if (reader.TokenType == JsonTokenType.Null)\r\n            {\r\n                return default(IEnumerable<TDatatype>);\r\n            }\r\n\r\n            JsonSerializerOptions jsonSerializerOptions = new JsonSerializerOptions(options);\r\n            jsonSerializerOptions.Converters.Clear();\r\n            jsonSerializerOptions.Converters.Add(Activator.CreateInstance<TConverterType>());\r\n\r\n            List<TDatatype> returnValue = new List<TDatatype>();\r\n\r\n            while (reader.TokenType != JsonTokenType.EndArray)\r\n            {\r\n                if (reader.TokenType != JsonTokenType.StartArray)\r\n                {\r\n                    returnValue.Add((TDatatype)JsonSerializer.Deserialize(ref reader, typeof(TDatatype), jsonSerializerOptions));\r\n                }\r\n\r\n                reader.Read();\r\n            }\r\n\r\n            return returnValue;\r\n        }\r\n\r\n        /// <summary>\r\n        /// Writes a json string.\r\n        /// </summary>\r\n        /// <param name=\"writer\">Json writer.</param>\r\n        /// <param name=\"value\">Value to write.</param>\r\n        /// <param name=\"options\">Serializer options.</param>\r\n        public override void Write(Utf8JsonWriter writer, IEnumerable<TDatatype> value, JsonSerializerOptions options)\r\n        {\r\n            if (value == null)\r\n            {\r\n                writer.WriteNullValue();\r\n                return;\r\n            }\r\n\r\n            JsonSerializerOptions jsonSerializerOptions = new JsonSerializerOptions(options);\r\n            jsonSerializerOptions.Converters.Clear();\r\n            jsonSerializerOptions.Converters.Add(Activator.CreateInstance<TConverterType>());\r\n\r\n            writer.WriteStartArray();\r\n\r\n            foreach (TDatatype data in value)\r\n            {\r\n                JsonSerializer.Serialize(writer, data, jsonSerializerOptions);\r\n            }\r\n\r\n            writer.WriteEndArray();\r\n        }\r\n    }\r\n```",
          "createdAt": "2021-06-15T16:05:51Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-06-27T10:22:29Z",
                "user": "Ultrafeel"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-09-12T22:28:30Z",
                "user": "senioroman4uk"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-05-02T13:36:49Z",
                "user": "BrandonDusseau"
              }
            ],
            "totalCount": 3,
            "endCursor": "Y3Vyc29yOnYyOpHOEQlNtA=="
          },
          "updatedAt": "2021-06-15T16:05:51Z",
          "id": "MDEyOklzc3VlQ29tbWVudDg2MTYyODUzMg=="
        },
        {
          "author": "ericstj",
          "body": "@steveharter does this get any easier with https://github.com/dotnet/runtime/issues/36785?",
          "createdAt": "2021-06-18T16:56:18Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-06-18T16:56:18Z",
          "id": "MDEyOklzc3VlQ29tbWVudDg2NDE2NTEzOQ=="
        },
        {
          "author": "eiriktsarpalis",
          "body": "@RamjotSingh would the solution proposed in https://github.com/dotnet/runtime/issues/63791 address your use case? I was thinking it might be possible to do something like this:\r\n```C#\r\npublic class Model\r\n{\r\n    [JsonConverter(typeof(JsonCollectionConverter), typeof(JsonStringEnumConverter))]\r\n    public IEnumerable<Day> Days { get; set; }\r\n}\r\n```\r\nIt would use the collection converter that accepts the type of the element converter used.",
          "createdAt": "2022-03-08T17:27:31Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-03-08T17:27:31Z",
          "id": "IC_kwDODI9FZc4_TS-6"
        },
        {
          "author": "eiriktsarpalis",
          "body": "FWIW it might be a breaking change if we do decide to have `JsonConverterAttribute` map to element converters. Consider the following example:\r\n```C#\r\npublic class MyClass : IEnumerable<MyClass>\r\n{\r\n     public MyClass Current => this;\r\n     public bool MoveNext() => true;\r\n}\r\n\r\npublic class Model\r\n{\r\n    [JsonConverter(typeof(MyClassConverter))] // Not clear whether it should map to the IEnumerable \r\n                                              // converter or use the converter for the property value directly.\r\n    public IEnumerable<MyClass> MyClass { get; set; }\r\n}\r\n```",
          "createdAt": "2022-03-08T17:32:30Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-03-08T17:32:30Z",
          "id": "IC_kwDODI9FZc4_TUEv"
        },
        {
          "author": "steveharter",
          "body": "This was [previously discussed](https://github.com/dotnet/runtime/issues/1562#issuecomment-579385889) and supported by Newtsonsoft's `JsonPropertyAttribute.ItemConverterType`.\r\n\r\nThe element converter is there today of course, just not exposed.\r\n\r\nAlthough adding an `ItemConverter` mechanism will probably work for all resonable scenarios, consider the encapsulation done today by something like a property ` public List<List<MyClass>> {get;}` - we'd need 2 levels of indirection to specify a converter for `MyClass`. Also consider indirection with generic parameters like `public Dictionary<string, MyClass> {get;}` as well.\r\n",
          "createdAt": "2022-03-08T19:51:47Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-03-09T08:03:39Z",
                "user": "eiriktsarpalis"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-01-26T21:11:58Z",
                "user": "anreton"
              }
            ],
            "totalCount": 2,
            "endCursor": "Y3Vyc29yOnYyOpHOC05a3w=="
          },
          "updatedAt": "2022-03-08T19:56:38Z",
          "id": "IC_kwDODI9FZc4_TwrU"
        },
        {
          "author": "eiriktsarpalis",
          "body": "> This was previously discussed and supported by Newtsonsoft's JsonPropertyAttribute.ItemConverterType.\r\n\r\nHaving a dedicated property for the element type is something that would resolve the ambiguity in https://github.com/dotnet/runtime/issues/54189#issuecomment-1062027567. I think it's reasonable that such a feature should only support basic generics patterns, and not concern itself with nested collections.",
          "createdAt": "2022-03-09T08:07:55Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-05-20T17:55:18Z",
                "user": "saul"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOCd818A=="
          },
          "updatedAt": "2022-03-09T08:07:55Z",
          "id": "IC_kwDODI9FZc4_VteF"
        },
        {
          "author": "danmoseley",
          "body": "matching partner request tracked here: https://dev.azure.com/devdiv/DevDiv/_workitems/edit/1486854",
          "createdAt": "2022-03-11T22:52:18Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-03-11T22:52:18Z",
          "id": "IC_kwDODI9FZc4_g_yH"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Given that convention already lets users specify custom converter types for element types in nullable properties:\r\n\r\nhttps://github.com/dotnet/runtime/blob/008f128b15a562cffd27cb10f78337be378b4f1a/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/JsonSerializerOptions.Converters.cs#L359-L374\r\n\r\nI'm thinking we could extend this convention to collection types without exposing a dedicated property for that purpose.",
          "createdAt": "2022-05-26T14:20:08Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-05-26T14:20:08Z",
          "id": "IC_kwDODI9FZc5D3h_C"
        },
        {
          "author": "eiriktsarpalis",
          "body": "As with the related #63791, we won't be able to look at this in time for .NET 7, moving to 8.0.0",
          "createdAt": "2022-06-17T08:38:54Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-06-17T08:38:54Z",
          "id": "IC_kwDODI9FZc5FD3EJ"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Moving to Future as we won't be able to work on this for 8.0",
          "createdAt": "2023-01-23T17:43:49Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-01-23T17:43:49Z",
          "id": "IC_kwDODI9FZc5TfYgd"
        },
        {
          "author": "softlion",
          "body": "You should work on making usage easier. Not on delaying basic things like that for 10 years.",
          "createdAt": "2023-09-22T06:36:03Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-09-22T13:00:01Z",
                "user": "anreton"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-09-22T14:06:44Z",
                "user": "rcdailey"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-10-24T09:58:43Z",
                "user": "danpaul88"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-01-10T10:20:21Z",
                "user": "xshaheen"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-01-20T11:57:35Z",
                "user": "enchart"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-02-10T08:55:50Z",
                "user": "aspmaker"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-03-15T15:43:56Z",
                "user": "elgonzo"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-03-25T11:44:55Z",
                "user": "gpuchtel-grubbrr"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-09-11T12:53:51Z",
                "user": "richsage"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-03-12T16:22:43Z",
                "user": "Suchiman"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-07-18T21:49:56Z",
                "user": "Athari"
              }
            ],
            "totalCount": 11,
            "endCursor": "Y3Vyc29yOnYyOpHOEbJ5pA=="
          },
          "updatedAt": "2023-09-22T06:36:03Z",
          "id": "IC_kwDODI9FZc5nKyE7"
        },
        {
          "author": "gpuchtel",
          "body": "Bump. Any movement on this? Gotta say, I'm surprised this (usage) feature has not been addressed.",
          "createdAt": "2024-03-25T09:51:35Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-03-25T09:57:24Z",
                "user": "anreton"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHODbv3gQ=="
          },
          "updatedAt": "2024-03-25T09:51:35Z",
          "id": "IC_kwDODI9FZc54Qkk7"
        },
        {
          "author": "gpuchtel-grubbrr",
          "body": "@eiriktsarpalis I don't see what the debate is about, NewtonSoft has clearly demonstrated the definition and use of the JsonPropertyAttribute: ItemConverterType. It is clearly needed, so I don't understand the confusion and resistance.",
          "createdAt": "2024-03-25T11:56:18Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-03-25T11:57:19Z",
          "id": "IC_kwDODI9FZc54RcR7"
        },
        {
          "author": "eiriktsarpalis",
          "body": "@gpuchtel it's not an issue of debate, we acknowledge that this is an issue that needs to be addressed eventually but we just haven't been able to prioritize work for it so far.",
          "createdAt": "2024-03-25T14:08:12Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-03-25T14:08:12Z",
          "id": "IC_kwDODI9FZc54SZoo"
        },
        {
          "author": "gpuchtel-grubbrr",
          "body": "Okay, thanks for the reply, but this seems so fundamental. Eventually means never. Can you give us a workaround? Anything I can get from  'DictionaryOfTKeyTValueConverter'? ",
          "createdAt": "2024-03-25T14:11:54Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-03-25T14:15:49Z",
          "id": "IC_kwDODI9FZc54Sbhb"
        },
        {
          "author": "eiriktsarpalis",
          "body": "The only workaround available today is applying the custom converter directly on the element type definition itself.",
          "createdAt": "2024-03-25T14:50:36Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-03-25T14:50:36Z",
          "id": "IC_kwDODI9FZc54SwhT"
        },
        {
          "author": "gpuchtel-grubbrr",
          "body": "I did that, it does not work. Also, it's the Cosmos client that is doing the (de)serialization. I will provide the code-snippet (later) tonight",
          "createdAt": "2024-03-25T15:33:05Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-03-25T15:47:08Z",
          "id": "IC_kwDODI9FZc54TKnP"
        },
        {
          "author": "gpuchtel",
          "body": "@eiriktsarpalis after some discussion on  'stackoverflow' [https://stackoverflow.com/questions/78216715/how-can-i-apply-a-custom-system-text-json-jsonconverter-to-the-values-of-a-concu] I've concluded that the (proposed) solutions are not worth the effort and I am fortunate that my custom class is easily convertible to a 'double'. So, I was able to define my value type as a 'double' and with conversion operators. But, I guess I will have to wait if I need to serialize a complex type with System.Text.Json. As a developer, I fully understand priorities, but I urge you to reconsider the importance of this feature. Thanks again, for your time and consideration.",
          "createdAt": "2024-03-25T23:11:50Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-03-25T23:11:50Z",
          "id": "IC_kwDODI9FZc54WMZd"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Have you tried either 1) registering your custom Saturation converter with JsonSerializerOptions.Converters or 2) adding a JsonCoverterAttribute annotation to your Saturation class?",
          "createdAt": "2024-03-25T23:46:32Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-03-25T23:46:32Z",
          "id": "IC_kwDODI9FZc54WUIR"
        },
        {
          "author": "RamjotSingh",
          "body": "Here is the code that works for us (we built it as a workaround). Can you check if this is working for you?\r\n\r\n```cs\r\nnamespace Microsoft.Json.CustomJsonConverters\r\n{\r\n    using System;\r\n    using System.Collections.Generic;\r\n    using System.Text.Json;\r\n    using System.Text.Json.Serialization;\r\n\r\n    /// <summary>\r\n    /// Json collection converter.\r\n    /// </summary>\r\n    /// <typeparam name=\"TDatatype\">Type of item to convert.</typeparam>\r\n    /// <typeparam name=\"TConverterType\">Converter to use for individual items.</typeparam>\r\n    public class JsonCollectionItemConverter<TDatatype, TConverterType> : JsonConverter<IEnumerable<TDatatype>>\r\n        where TConverterType : JsonConverter\r\n    {\r\n        /// <summary>\r\n        /// Reads a json string and deserializes it into an object.\r\n        /// </summary>\r\n        /// <param name=\"reader\">Json reader.</param>\r\n        /// <param name=\"typeToConvert\">Type to convert.</param>\r\n        /// <param name=\"options\">Serializer options.</param>\r\n        /// <returns>Created object.</returns>\r\n        public override IEnumerable<TDatatype> Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)\r\n        {\r\n            if (reader.TokenType == JsonTokenType.Null)\r\n            {\r\n                return default(IEnumerable<TDatatype>);\r\n            }\r\n\r\n            JsonSerializerOptions jsonSerializerOptions = new JsonSerializerOptions(options);\r\n            jsonSerializerOptions.Converters.Clear();\r\n            jsonSerializerOptions.Converters.Add(Activator.CreateInstance<TConverterType>());\r\n\r\n            List<TDatatype> returnValue = new List<TDatatype>();\r\n\r\n            while (reader.TokenType != JsonTokenType.EndArray)\r\n            {\r\n                if (reader.TokenType != JsonTokenType.StartArray)\r\n                {\r\n                    returnValue.Add((TDatatype)JsonSerializer.Deserialize(ref reader, typeof(TDatatype), jsonSerializerOptions));\r\n                }\r\n\r\n                reader.Read();\r\n            }\r\n\r\n            return returnValue;\r\n        }\r\n\r\n        /// <summary>\r\n        /// Writes a json string.\r\n        /// </summary>\r\n        /// <param name=\"writer\">Json writer.</param>\r\n        /// <param name=\"value\">Value to write.</param>\r\n        /// <param name=\"options\">Serializer options.</param>\r\n        public override void Write(Utf8JsonWriter writer, IEnumerable<TDatatype> value, JsonSerializerOptions options)\r\n        {\r\n            if (value == null)\r\n            {\r\n                writer.WriteNullValue();\r\n                return;\r\n            }\r\n\r\n            JsonSerializerOptions jsonSerializerOptions = new JsonSerializerOptions(options);\r\n            jsonSerializerOptions.Converters.Clear();\r\n            jsonSerializerOptions.Converters.Add(Activator.CreateInstance<TConverterType>());\r\n\r\n            writer.WriteStartArray();\r\n\r\n            foreach (TDatatype data in value)\r\n            {\r\n                JsonSerializer.Serialize(writer, data, jsonSerializerOptions);\r\n            }\r\n\r\n            writer.WriteEndArray();\r\n        }\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\nHow to use?\r\n\r\n```cs\r\n[JsonPropertyName(\"changeTypes\")]\r\n[System.Text.Json.Serialization.JsonConverter(typeof(JsonCollectionItemConverter<ResourceChangeType, JsonStringEnumConverter>))]\r\npublic IEnumerable<ResourceChangeType> ChangeTypes { get; set; }\r\n```\r\n\r\nFirst is the data type, second is the Converter to use for each item.",
          "createdAt": "2024-03-26T00:06:15Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-05-07T19:20:04Z",
                "user": "natelowry"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHODhAeZw=="
          },
          "updatedAt": "2024-03-26T00:06:15Z",
          "id": "IC_kwDODI9FZc54WY1s"
        },
        {
          "author": "gpuchtel",
          "body": "@eiriktsarpalis \"Have you tried either 1) registering your custom Saturation converter with JsonSerializerOptions.Converters or 2) adding a JsonCoverterAttribute annotation to your Saturation class?\"\r\n\r\nAnswer(s), yes to #2 (did not work), no to #1 as I don't have control over the options, as its the Cosmos Client doing the (de)serialization\r\n\r\n\r\n**** UPDATE ****\r\n\r\nYes, adding a JsonConverterAttribute to the class annotation worked! Sorry, I misread it at first, as I was thinking of the Dictionary annotation.",
          "createdAt": "2024-03-26T00:14:19Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-03-26T00:36:26Z",
          "id": "IC_kwDODI9FZc54WahV"
        },
        {
          "author": "gpuchtel",
          "body": "@RamjotSingh  Thanks, I'll give a try...",
          "createdAt": "2024-03-26T00:15:13Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-03-26T00:15:13Z",
          "id": "IC_kwDODI9FZc54WatF"
        },
        {
          "author": "eiriktsarpalis",
          "body": "> yes to #2 (did not work)\r\n\r\nCan you share a repro?",
          "createdAt": "2024-03-26T00:50:38Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-03-26T00:50:38Z",
          "id": "IC_kwDODI9FZc54WnEg"
        },
        {
          "author": "gpuchtel",
          "body": "@eiriktsarpalis Yes, it did work! I gave an 'update' above. Thanks for sticking with this. I think I'm good. Actually, this works better than the NewtonSoft solution, because it places the conversion (attribute) declaration where the Type is declared, rather than where it is used.",
          "createdAt": "2024-03-26T00:53:33Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-03-26T07:59:09Z",
                "user": "eiriktsarpalis"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHODb4S3A=="
          },
          "updatedAt": "2024-03-26T00:53:33Z",
          "id": "IC_kwDODI9FZc54WnmO"
        },
        {
          "author": "gpuchtel",
          "body": "After much ado, Eirik Tsarpalis (Microsoft) had the answer all along; I wasn't reading it right. Adding a JsonCoverterAttribute annotation to my custom class (Saturation) works! This is better than annotating the point of usage via Newtsonsoft's JsonPropertyAttribute.ItemConverterType—it places the declaration with the class. Thank you, Eirik!",
          "createdAt": "2024-03-27T12:18:54Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-03-27T12:18:54Z",
          "id": "IC_kwDODI9FZc54juUE"
        },
        {
          "author": "rcdailey",
          "body": "Is there information I can read to understand more about what \"Saturation\" classes are?",
          "createdAt": "2024-03-27T21:40:22Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-03-27T21:40:22Z",
          "id": "IC_kwDODI9FZc54pGGu"
        },
        {
          "author": "gpuchtel",
          "body": "@rcdailey The 'Saturation' class is a custom class in my solution. I copied the code verbatim as the type of class is irrelevant to the discussion.  ",
          "createdAt": "2024-03-28T09:38:47Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-03-28T09:38:47Z",
          "id": "IC_kwDODI9FZc54r6YE"
        },
        {
          "author": "rcdailey",
          "body": "It's relevant insofar as it is part of a proposed solution or workaround, so again I'd appreciate an answer to my question as I feel it is important information for the complete understanding of the solutions discussed here.",
          "createdAt": "2024-03-28T12:14:31Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-03-28T12:17:04Z",
          "id": "IC_kwDODI9FZc54s7MI"
        },
        {
          "author": "eiriktsarpalis",
          "body": "@rcdailey the workaround should look something like this:\r\n\r\n```C#\r\n[JsonConverter(typeof(MyCustomConverter))]\r\npublic class MyPoco { }\r\n```\r\n\r\nThen serializing instances of, say, `List<MyPoco>` will use `MyCustomConverter` for the element types.",
          "createdAt": "2024-03-28T12:24:07Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-03-28T12:28:16Z",
                "user": "gpuchtel"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHODcPQvQ=="
          },
          "updatedAt": "2024-03-28T12:24:07Z",
          "id": "IC_kwDODI9FZc54tATR"
        },
        {
          "author": "rcdailey",
          "body": "Thanks Eirik. So the term \"Saturation\" was actually referring to a custom JSON converter class? If not, what is that referring to? It's not a term I've heard of in the context of System.Text.Json.",
          "createdAt": "2024-03-28T13:03:05Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-03-28T13:03:05Z",
          "id": "IC_kwDODI9FZc54tRJN"
        },
        {
          "author": "eiriktsarpalis",
          "body": "That's right, it's the sample class referenced in the linked [SO discussion](https://stackoverflow.com/questions/78216715/how-can-i-apply-a-custom-system-text-json-jsonconverter-to-the-values-of-a-concu).",
          "createdAt": "2024-03-28T13:11:35Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-03-28T13:46:44Z",
                "user": "rcdailey"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHODcP2Sw=="
          },
          "updatedAt": "2024-03-28T13:12:06Z",
          "id": "IC_kwDODI9FZc54tVxY"
        },
        {
          "author": "nhuizenga",
          "body": "**Update**: Argh. My bad, this behavior seems to be isolated to responses in ASP.NET Core. When I wrote tests in hopes of providing a full copy/paste-able repro, the \"bad\" behavior went away. I'm not totally sure what's going on, but the problem seems to be outside the `System.Text.Json` library. Ignore me!\n\n> [JsonConverter(typeof(MyCustomConverter))]\n> public class MyPoco { }\n> Then serializing instances of, say, `List<MyPoco>` will use `MyCustomConverter` for the element types.\n\nUnfortunately, this doesn't appear to work if you are trying to apply the `[JsonConverter]` to an `Enum` type, then have that type used in a collection that is a member of another class. At least not using `System.Text.Json` version `9.0.3`. Here's the basic setup:\n\n```csharp\n[JsonConverter(typeof(MyEnumConverter))]\npublic enum MyEnum {\n  [Display(Name = \"a\")]\n  Value1,\n  [Display(Name = \"b\")]\n  Value2,\n  [Display(Name = \"c\")]\n  Value3\n}\npublic record MyDto(\n  IEnumerable<MyEnum> Options,\n  MyEnum DefaultOption\n);\n```\n\nIf I have a custom converter that uses the `[Display]` attributes to determine the string representation of the enum values, an instance of `MyDto` constructed as `new MyDto([MyEnum.Value1,MyEnum.Value2], MyEnum.Value1)` will, in the absence of any other configuration, serialize to `{\"Options\":[1,2],\"DefaultOption\":1}` even though it should be `{\"Options\":[\"a\",\"b\"],\"DefaultOption\":\"a\"}` (implementation below). The behavior does not change whether the converter is added to the `JsonSerializerOptions.Converters`, set using the attribute, or both.\n\nInterestingly enough, this all works much better on the deserialization side of things, though not perfectly. If you have `{\"Options\":[\"a\",\"b\"],\"DefaultOption\":\"a\"}` and add the custom converter to `JsonSerializerOptions.Converters`, this deserializes just fine. Using the attribute in this scenario seems to have no effect whatsoever.\n\nHere is the converter code:\n\n```csharp\npublic class JsonNameEnumConverter : JsonConverter<MyEnum> {\n\n    private static Dictionary<string, MyEnum> NameValueMap { get; } = typeof(MyEnum)\n        .GetFields(BindingFlags.Public | BindingFlags.Static)\n        .Select(m => KeyValuePair.Create(m.GetCustomAttribute<DisplayAttribute>()?.Name ?? m.Name, Enum.Parse<MyEnum>(m.Name)))\n        .ToDictionary();\n\n    private static Dictionary<MyEnum, string> ValueNameMap { get; } = typeof(MyEnum)\n        .GetFields(BindingFlags.Public | BindingFlags.Static)\n        .Select(m => KeyValuePair.Create(Enum.Parse<MyEnum>(m.Name), m.GetCustomAttribute<DisplayAttribute>()?.Name ?? m.Name))\n        .ToDictionary();\n\n    public override MyEnum Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) =>\n        NameValueMap[reader.GetString() ?? string.Empty];\n\n    public override void Write(Utf8JsonWriter writer, MyEnum value, JsonSerializerOptions options) =>\n        writer.WriteStringValue(ValueNameMap[value]);\n}\n```",
          "createdAt": "2025-03-28T22:54:15Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-03-28T23:10:16Z",
          "id": "IC_kwDODI9FZc6krJx1"
        },
        {
          "author": "aromaa",
          "body": "Could this be solved by adding a `TargetType` to the `JsonConverterAttribute`? That way you can target multiple different types too. Now the example would look like:\n\n```csharp\npublic class Model\n{\n    [JsonConverter(typeof(JsonStringEnumConverter), TargetType = typeof(Day))]\n    public IEnumerable<Day> Days { get; set; }\n}\n```",
          "createdAt": "2025-05-05T23:20:00Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-05-06T07:02:00Z",
                "user": "fitdev"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-05-06T09:07:12Z",
                "user": "anreton"
              }
            ],
            "totalCount": 2,
            "endCursor": "Y3Vyc29yOnYyOpHOEQ8lzw=="
          },
          "updatedAt": "2025-05-05T23:20:00Z",
          "id": "IC_kwDODI9FZc6qB8Yt"
        }
      ],
      "totalCount": 36,
      "endCursor": "Y3Vyc29yOnYyOpHOqgfGLQ=="
    },
    "url": "https://github.com/dotnet/runtime/issues/54189",
    "title": "[System.Text.Json] JsonConverter lacks ability to specify converter for items in a collection"
  },
  {
    "author": "malisancube",
    "labels": [
      "api-needs-work",
      "area-System.Text.Json",
      "wishlist"
    ],
    "createdAt": "2021-06-17T18:35:21Z",
    "body": "<!-- What problem are you trying to solve? -->\r\n\r\nIn Python you can do this\r\n\r\n```python\r\nimport pandas as pd\r\ndata= pd.read_json('employees.jl', lines=True, orient='records')\r\n```\r\n<!-- Describe the solution you'd like -->\r\n\r\nInclude `JsonSerializerOptions` property `Lines` of the `System.Text.Json`\r\n",
    "number": 54353,
    "reactions": {
      "hasNextPage": false,
      "nodes": [],
      "totalCount": 0,
      "endCursor": null
    },
    "updatedAt": "2022-07-26T09:56:44Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @eiriktsarpalis, @layomia\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\n<!-- What problem are you trying to solve? -->\r\n\r\nIn Python you can do this\r\n\r\n```python\r\nimport pandas as pd\r\ndata= pd.read_json('employees.jl', lines=True, orient='records')\r\n```\r\n<!-- Describe the solution you'd like -->\r\n\r\nInclude `JsonSerializerOptions` property `Lines` of the `System.Text.Json`\r\n\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>malisancube</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`area-System.Text.Json`, `untriaged`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2021-06-17T18:56:26Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-06-17T18:56:26Z",
          "id": "MDEyOklzc3VlQ29tbWVudDg2MzQ4NzE3MA=="
        },
        {
          "author": "eiriktsarpalis",
          "body": "Because .NET is statically typed, there would need to be a separate method in order to support this type of scenario, for example:\r\n```csharp\r\npublic JsonSerializer\r\n{\r\n     public static IEnumerable<TValue?> DeserializeMany<TValue>(string inputs, string separator, JsonSerializerOptions options); \r\n}\r\n```\r\nA naïve implementation might attempt to implement this over the existing `Deserialize` methods using something like `String.Split`, however this would not work if line breaks are contained within individual root-level value encodings.",
          "createdAt": "2021-06-18T08:24:43Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-06-18T08:24:43Z",
          "id": "MDEyOklzc3VlQ29tbWVudDg2Mzg1ODEzNA=="
        },
        {
          "author": "czd890",
          "body": "We desperately need it. we use for serialization Now achieved by customizing ContractResolver of JSON.NET. This prevented us from migrating from JSON.NET to STJ.\r\n\r\n```\r\nvar obj=new {f1=1, f2=2, obj1= new {f3=3} };\r\nJSON.Serialize(stream, obj, \"f1,obj1.f3\") ==> '{\"f1\":1, \"obj1\":{\"f3\":3}}'\r\n```\r\n\r\nIt seems that achieve it.\r\nhttps://github.com/dotnet/runtime/blob/19588127b93f056eb26616d9d31936df94a9e6d8/src/libraries/System.Text.Json/tests/System.Text.Json.Tests/Serialization/TypeInfoResolverFunctionalTests.cs#L746 can ",
          "createdAt": "2022-07-26T09:30:27Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-07-26T09:56:44Z",
          "id": "IC_kwDODI9FZc5HPf0t"
        }
      ],
      "totalCount": 3,
      "endCursor": "Y3Vyc29yOnYyOpHORz39LQ=="
    },
    "url": "https://github.com/dotnet/runtime/issues/54353",
    "title": "Support deserializing multiple root-level values split by separator"
  },
  {
    "author": "SteveKCheng",
    "labels": [
      "api-needs-work",
      "area-System.Text.Json"
    ],
    "createdAt": "2021-06-25T02:47:23Z",
    "body": "## Background and Motivation\r\n\r\nCurrently the newline sequence used by ``Utf8JsonWriter`` depends on the running platform, obtained from ``Environment.NewLine``.\r\n\r\nIt would be useful to be able to set it explicitly so that JSON output can be reproduced exactly no matter what platform the .NET program is running under. It is essential when the JSON output bytes are to be compared directly or through a hash, e.g. as a digital signature or for regression-testing expected outputs.\r\n\r\n## Proposed API\r\n\r\n```diff\r\nnamespace System.Text.Json\r\n{\r\n    public struct JsonWriterOptions\r\n    {\r\n+        public string? NewLine { get; set; }\r\n    }\r\n}\r\n```\r\n\r\nThe default value is ``null`` (backwards compatible), which means to take the value from ``Environment.NewLine``. \r\nOtherwise the specified string is used as the newline sequence, as in the ``TextWriter.NewLine`` property.\r\n\r\n## Usage Examples\r\n\r\n``` C#\r\n\r\nusing var writer = new Utf8JsonWriter(outputStream, new JsonWriterOptions\r\n{\r\n    Indented = true,\r\n    NewLine = \"\\n\"\r\n};\r\n```\r\n\r\n## Alternatives\r\n\r\nCurrently as ``Utf8JsonWriter`` does not offer this functionality, I have to use Newtonsoft's JSON writer instead --- which relies on ``TextWriter`` that has a customizable ``NewLine`` property. It seems fairly difficult, and obviously inefficient, to write a \"filter\" on a ``Stream`` to convert the platform-specific newline byte sequence.\r\n\r\n## Risks\r\n\r\nI think it is low risk for the most common cases. There is no change to behavior of existing code that does not set the ``JsonWriterOptions.NewLine`` property. ``Utf8JsonWriter``'s code is already parameterized on ``Environment.NewLine`` and this proposal is just asking we stop hard-coding the use of a global property.\r\n\r\nWhat if the arbitrary newline sequence contains non-ASCII characters? Or it results in invalid JSON?\r\n\r\nMy first thought is that such characters should still be supported for completeness (otherwise we'd have to define what the behavior would be) even they might cause slightly slower execution. And it would be consistent with ``TextWriter``'s API with no friction for the user.\r\n\r\nBut perhaps an enumeration (or boolean?) allowing only for the standard choices of newline sequences would work too.\r\nCurrently, ``Utf8JsonWriter``'s code assumes ``Environment.NewLine`` is either ``\"\\r\\n\"`` or ``\"\\n\"``. Supporting the choice between these two would be good enough to satisfy the motivation above.\r\n",
    "number": 54715,
    "reactions": {
      "hasNextPage": false,
      "nodes": [],
      "totalCount": 0,
      "endCursor": null
    },
    "updatedAt": "2022-09-04T21:51:21Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @eiriktsarpalis, @layomia\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\n## Background and Motivation\r\n\r\nCurrently the newline sequence used by ``Utf8JsonWriter`` depends on the running platform, obtained from ``Environment.NewLine``.\r\n\r\nIt would be useful to be able to set it explicitly so that JSON output can be reproduced exactly no matter what platform the .NET program is running under. It is essential when the JSON output bytes are to be compared directly or through a hash, e.g. as a digital signature or for regression-testing expected outputs.\r\n\r\n## Proposed API\r\n\r\n```diff\r\nnamespace System.Text.Json\r\n{\r\n    public struct JsonWriterOptions\r\n    {\r\n+        public string? NewLine { get; set; }\r\n    }\r\n}\r\n```\r\n\r\nThe default value is ``null`` (backwards compatible), which means to take the value from ``Environment.NewLine``. \r\nOtherwise the specified string is used as the newline sequence, as in the ``TextWriter.NewLine`` property.\r\n\r\n## Usage Examples\r\n\r\n``` C#\r\n\r\nusing var writer = new Utf8JsonWriter(outputStream, new JsonWriterOptions\r\n{\r\n    Indented = true,\r\n    NewLine = \"\\n\"\r\n};\r\n```\r\n\r\n## Alternatives\r\n\r\nCurrently as ``Utf8JsonWriter`` does not offer this functionality, I have to use Newtonsoft's JSON writer instead --- which relies on ``TextWriter`` which has a customizable ``NewLine`` property. It seems fairly difficult, and obviously inefficient, to try to write a \"filter\" on a ``Stream`` to convert the platform-specific newline byte sequence.\r\n\r\n## Risks\r\n\r\nI think it is low risk for the most common cases. There is no change to behavior of existing code that does not set the ``JsonWriterOptions.NewLine`` property. ``Utf8JsonWriter``'s code is already parameterized on ``Environment.NewLine`` and this proposal is just asking we stop hard-coding the use of a global property.\r\n\r\nWhat if the newline sequence contains non-ASCII characters? I think such characters should still be supported for completeness (otherwise we'd have to define what the behavior would be) even they might cause slightly slower execution. An enumeration could be used instead, allowing only for the standard choices of newline sequences, but an enumeration is rather noisy (I think in this case) and it would not be consistent with the existing API on ``TextWriter``.\r\n\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>SteveKCheng</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`api-suggestion`, `area-System.Text.Json`, `untriaged`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2021-06-25T02:47:34Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-06-25T02:47:34Z",
          "id": "MDEyOklzc3VlQ29tbWVudDg2ODE2MTExNw=="
        },
        {
          "author": "GrabYourPitchforks",
          "body": "I don't have any feedback on the customizing newline scenario - will leave that for the JSON team. But I wanted to focus on this comment:\r\n\r\n> It is essential when the JSON output bytes are to be compared directly or through a hash, e.g. as a digital signature or for regression-testing expected outputs.\r\n\r\nPlease be advised that different major versions of _System.Text.Json_ __are not__ guaranteed to have byte-for-byte identical output with one another. This could be because the .NET runtime itself changes how some values are encoded (like how .NET Framework and .NET 5 have different string representations for _double_), it could be because characters like '€' may or may not be escaped by default, or it could be some other factor.\r\n\r\nIf you rely on the contents having a very specific byte-for-byte representation, please always test each new version of _System.Text.Json_ (or its dependencies) or each new version of the .NET runtime in an integration environment before deploying to production. This will allow you to catch such discrepancies early.\r\n\r\nHope this helps!",
          "createdAt": "2021-06-25T03:06:30Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-07-03T22:45:34Z",
                "user": "fydar"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOBxJusw=="
          },
          "updatedAt": "2021-06-25T03:06:30Z",
          "id": "MDEyOklzc3VlQ29tbWVudDg2ODE2ODU2MA=="
        },
        {
          "author": "SteveKCheng",
          "body": "@GrabYourPitchforks \r\nJust want to comment: I am fine with the caveat that byte-for-byte comparison only works with the same version of the run-time & libraries. The use case I have right now is regression-testing by comparing expected outputs where some developers might run the program on Windows while the automated periodic process is running on Linux.\r\n",
          "createdAt": "2021-06-25T03:09:25Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-06-25T03:25:11Z",
                "user": "GrabYourPitchforks"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOBwHuug=="
          },
          "updatedAt": "2021-06-25T03:09:25Z",
          "id": "MDEyOklzc3VlQ29tbWVudDg2ODE2OTY1MQ=="
        },
        {
          "author": "jeffhandley",
          "body": "@SteveKCheng We know that we aren't going to get to this feature during .NET 7, and compared to many of the other issues/features in our System.Text.Json backlog, I don't expect we'll get to this for the foreseeable future. To reflect this, I'm going to close the issue.\r\n\r\nFor the regression testing scenario you described, I recommend normalizing the newlines before comparison. As was previously called out, other direct comparisons or consumption for a hash, a digital signature, or other purpose would not be reliable without normalization either.\r\n",
          "createdAt": "2022-04-06T01:39:05Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-04-06T01:39:05Z",
          "id": "IC_kwDODI9FZc5A8ob7"
        },
        {
          "author": "jeffhandley",
          "body": "Reopening based on additional feedback from @damieng that there are scenarios where additional control of the written content is valuable.\r\n\r\n@damieng if you could, please add a comment citing your scenarios so that we can consider them and if we proceed on this use them as acceptance criteria.",
          "createdAt": "2022-09-04T20:54:27Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-09-04T20:54:27Z",
          "id": "IC_kwDODI9FZc5Jsiyp"
        }
      ],
      "totalCount": 5,
      "endCursor": "Y3Vyc29yOnYyOpHOSbIsqQ=="
    },
    "url": "https://github.com/dotnet/runtime/issues/54715",
    "title": "Allow changing the newline sequence for indenting using Utf8JsonWriter"
  },
  {
    "author": "layomia",
    "labels": [
      "area-System.Text.Json",
      "tenet-performance",
      "source-generator"
    ],
    "createdAt": "2021-07-01T21:55:42Z",
    "body": "In https://github.com/dotnet/runtime/issues/51945, we addressed a mode in the JSON source generator that generates optimized serialization logic using `Utf8JsonWriter` directly. We should consider a similar mode for deserialization using `Utf8JsonReader` directly.",
    "number": 55043,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-08-03T15:45:09Z",
          "user": "jasper-d"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-11-12T18:59:32Z",
          "user": "steveharter"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-01-11T17:29:19Z",
          "user": "antoniofreire"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-07-28T14:36:56Z",
          "user": "N0D4N"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-08-16T08:22:05Z",
          "user": "Jure-BB"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-11-22T12:55:06Z",
          "user": "Alois-xx"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-11-23T10:54:21Z",
          "user": "ao57772"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-11-23T14:06:23Z",
          "user": "lbargaoanu"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-12-21T11:11:10Z",
          "user": "hmqgg"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-03-03T03:12:27Z",
          "user": "joelverhagen"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-03-09T11:03:55Z",
          "user": "kcrg"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-04-28T15:45:24Z",
          "user": "neeraj9"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-09-22T07:37:35Z",
          "user": "mariusz96"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-11-13T15:16:34Z",
          "user": "HungryDoctor"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-01-07T12:41:44Z",
          "user": "jesperkristensen"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-02-11T09:37:10Z",
          "user": "tpaananen"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-03-09T18:16:32Z",
          "user": "gjbell"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-03-18T19:59:02Z",
          "user": "ericmutta"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-04-12T20:13:22Z",
          "user": "timschneeb"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-04-21T08:10:24Z",
          "user": "cirrusone"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-04-26T00:04:45Z",
          "user": "Tornhoof"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-05-10T23:06:10Z",
          "user": "kz-gonzalo-curbelo"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-05-25T18:32:23Z",
          "user": "mhenry07"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-07-12T17:00:51Z",
          "user": "will14smith"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-07-30T10:18:25Z",
          "user": "rgroenewoudt"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-08-16T12:05:53Z",
          "user": "yuyoyuppe"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-08-29T23:27:19Z",
          "user": "Dan-Albrecht"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-09-20T16:38:54Z",
          "user": "v3xro"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-09-23T07:13:54Z",
          "user": "issue-dispenser"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-09-25T14:58:36Z",
          "user": "vladimir-lu"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-11-13T12:35:35Z",
          "user": "scrappyCoco"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-12-11T07:33:50Z",
          "user": "petterton"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-12-13T22:20:02Z",
          "user": "Sella-GH"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-01-27T19:51:30Z",
          "user": "RenderMichael"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-02-02T20:12:16Z",
          "user": "Athari"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-03-09T15:11:33Z",
          "user": "pablocom"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-03-13T03:14:11Z",
          "user": "hexawyz"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-03-31T10:06:47Z",
          "user": "0xfeeddeadbeef"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-04-28T18:31:27Z",
          "user": "voroninp"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-05-23T16:37:02Z",
          "user": "Peter-Juhasz"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-07-08T09:09:43Z",
          "user": "lindexi"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-07-22T16:51:07Z",
          "user": "znakeeye"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-07-30T07:12:42Z",
          "user": "ldalonzo"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-08-21T09:19:00Z",
          "user": "abulkasim007"
        }
      ],
      "totalCount": 44,
      "endCursor": "Y3Vyc29yOnYyOpHODMFr-A=="
    },
    "updatedAt": "2025-08-24T01:50:07Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @eiriktsarpalis, @layomia\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\nIn https://github.com/dotnet/runtime/issues/51945, we addressed a mode in the JSON source generator that generates optimized serialization logic using `Utf8JsonWriter` directly. We should consider a similar mode for deserialization using `Utf8JsonReader` directly.\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>layomia</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>layomia</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`area-System.Text.Json`, `tenet-performance`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>7.0.0</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2021-07-01T21:55:47Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-07-01T21:55:47Z",
          "id": "MDEyOklzc3VlQ29tbWVudDg3MjU3NDE0Mw=="
        },
        {
          "author": "layomia",
          "body": "From @mrange in https://github.com/dotnet/runtime/issues/57117:\r\n\r\n> Hi.\r\n> I was asked if I had any further feedback on the JSON Serializer in ticket: #56995\r\n> \r\n> One thing that came to mind is that in my experiments generating a deserialize method can lead to performance improvements.\r\n> \r\n> I suspect you considered it and for some reason not implemented it but in case you are interested my testing shows an increase in performance with ~30% for a simple object when using generated code rather than metadata driven deserializer. In addition it seems to have positive impact on the memory aspect.\r\n> \r\n> In case you are interested here is my experiment: https://github.com/mrange/T4JsonSerializer\r\n\r\n",
          "createdAt": "2021-08-10T17:10:12Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-08-10T17:10:12Z",
          "id": "IC_kwDODI9FZc41alew"
        },
        {
          "author": "mrange",
          "body": "Could be worth investigating IMHO but I am sure there subtleties to the deserialization problem that makes it hard to create a one size fits all generated version. Perhaps there is value to generate a version that works in many use cases but also allow the metadata driven version when flexibility is required.\r\n\r\nFrom my testing the overhead when using a static deserializer fell significantly but as the JSON parsing process itself takes sometime the overall performance gain is not as good.",
          "createdAt": "2021-08-11T13:43:13Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-08-11T13:43:13Z",
          "id": "IC_kwDODI9FZc41dK0O"
        },
        {
          "author": "layomia",
          "body": "Consider honoring `ReadCommentHandling` option - https://github.com/dotnet/runtime/issues/81131.",
          "createdAt": "2023-02-07T18:52:28Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-02-07T18:54:43Z",
                "user": "Shane32"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOC1nYHQ=="
          },
          "updatedAt": "2023-02-07T18:52:28Z",
          "id": "IC_kwDODI9FZc5UtxgB"
        },
        {
          "author": "cirrusone",
          "body": "Quite often we have project requirements of consuming external API's where data is provided as JSON strings, so we don't have the luxury of serializing our own data for better downstream performance. Some community driven projects seem to indicate that there are further possibilities of improving deserialization performance from JSON string data. \r\n\r\nBelow are some benchmarks using very simple data. Some of these community driven projects have since been abandoned or don't handle new types so SystemTextJson is always the safest option but it would be nice to have improved performance.\r\n\r\nBenchmarkDotNet=v0.13.5, OS=Windows 11 (10.0.22621.1265/22H2/2022Update/SunValley2)\r\n12th Gen Intel Core i9-12900H, 1 CPU, 20 logical and 14 physical cores\r\n.NET SDK=7.0.103\r\n  [Host]     : .NET 7.0.3 (7.0.323.6910), X64 RyuJIT AVX2\r\n  DefaultJob : .NET 7.0.3 (7.0.323.6910), X64 RyuJIT AVX2\r\n\r\n\r\n| Method                        | Mean          | Error         | StdDev        | StdDev        |\r\n| ----------------------------- | ------------- | ------------- | ------------- | ------------- |\r\n| SystemTextJson                | 255.84 ns     | 0.820 ns      | 0.767 ns      | 1.00          |\r\n| SystemTextJsonMetadataSrcGen  | 258.11 ns     | 0.389 ns      | 0.325 ns      | 1.01          |\r\n| SystemTextJsonDefaultSrcGen   | 254.68 ns     | 1.659 ns      | 1.552 ns      | 1.00          |\r\n| UTF8JSon                      | 131.54 ns     | 0.800 ns      | 0.748 ns      | 0.51          |\r\n| UTF8JSon_Bytes                | 116.64 ns     | 0.277 ns      | 0.246 ns      | 0.46          |\r\n| SpanJSONUtf16                 |  70.25 ns     | 0.394 ns      | 0.368 ns      | 0.27          |\r\n| SpanJSONUtf8                  |  94.89 ns     | 0.641 ns      | 0.599 ns      | 0.37          |\r\n| SpanJSONUtf8_Bytes            |  76.01 ns     | 0.595 ns      | 0.557 ns      | 0.30          |\r\n| JsonSrcGen                    |  65.51 ns     | 0.388 ns      | 0.344 ns      | 0.26          |\r\n\r\n\r\n**SourceGenTest.csproj:**\r\n\r\n```\r\n<Project Sdk=\"Microsoft.NET.Sdk\">\r\n\r\n  <PropertyGroup>\r\n    <OutputType>Exe</OutputType>\r\n    <TargetFramework>net7.0</TargetFramework>\r\n    <ImplicitUsings>disable</ImplicitUsings>\r\n    <Nullable>disable</Nullable>\r\n  </PropertyGroup>\r\n\r\n  <ItemGroup>\r\n    <PackageReference Include=\"BenchmarkDotNet\" Version=\"0.13.5\" />\r\n    <PackageReference Include=\"JsonSrcGen\" Version=\"1.1.1\" />\r\n    <PackageReference Include=\"SpanJson\" Version=\"4.0.0\" />\r\n    <PackageReference Include=\"Utf8Json\" Version=\"1.3.7\" />\r\n  </ItemGroup>\r\n\r\n</Project>\r\n```\r\n\r\n**Program.cs:**\r\n\r\n```\r\nusing BenchmarkDotNet.Attributes;\r\nusing BenchmarkDotNet.Running;\r\nusing System.Text;\r\nusing System.Text.Json;\r\nusing System.Text.Json.Serialization;\r\nusing JsonSrcGen;\r\n\r\nnamespace SourceGenTest;\r\n\r\ninternal static class Program\r\n{\r\n    static void Main(string[] args)\r\n    {\r\n\r\n#if DEBUG\r\n        new JsonDeserializeCompare().DebugTest();\r\n#else\r\n        var summary = BenchmarkRunner.Run<JsonDeserializeCompare>();\r\n#endif\r\n\r\n    }\r\n}\r\n\r\npublic class JsonDeserializeCompare\r\n{\r\n    private string _jsonToDeserializeFromString;\r\n    private byte[] _jsonToDeserializeFromBytesUtf8;\r\n    private MetadataJsonClassContext _metadataJsonClassContext;\r\n    private DefaultJsonClassContext _defaultJsonClassContext;\r\n\r\n    private JsonSrcGenClass _jsonSrcGenClass;\r\n    private JsonSrcGen.JsonConverter _jsonSrcGenConverter;\r\n    public JsonDeserializeCompare()\r\n    {\r\n        _jsonToDeserializeFromString = \"{\\\"Forename\\\":\\\"John\\\",\\\"Surname\\\":\\\"Smith\\\",\\\"Age\\\":42,\\\"Active\\\":true}\";\r\n        _jsonToDeserializeFromBytesUtf8 = Encoding.UTF8.GetBytes(_jsonToDeserializeFromString);\r\n\r\n        _metadataJsonClassContext = new(new JsonSerializerOptions() { TypeInfoResolver = MetadataJsonClassContext.Default });\r\n        _defaultJsonClassContext = new(new JsonSerializerOptions() { TypeInfoResolver = DefaultJsonClassContext.Default });\r\n\r\n        _jsonSrcGenClass = new JsonSrcGenClass();\r\n        _jsonSrcGenConverter = new JsonSrcGen.JsonConverter();\r\n\r\n    }\r\n\r\n    public void DebugTest()\r\n    {\r\n        JsonClass jsonClass1 = SystemTextJson();\r\n        JsonClass jsonClass2 = SystemTextJsonMetadataSrcGen();\r\n        JsonClass jsonClass3 = SystemTextJsonDefaultSrcGen();\r\n        JsonClass jsonClass4 = UTF8JSon();\r\n        JsonClass jsonClass5 = UTF8JSon_Bytes();\r\n        JsonClass jsonClass6 = SpanJSONUtf16();\r\n        JsonClass jsonClass7 = SpanJSONUtf8();\r\n        JsonClass jsonClass8 = SpanJSONUtf8_Bytes();\r\n        JsonSrcGenClass jsonClass9 = JsonSrcGen();\r\n\r\n        //var reader = new Utf8JsonReader(_jsonToDeserializeUtf8, true, default);\r\n        //reader.Read();\r\n\r\n    }\r\n\r\n    [Benchmark(Baseline = true)]\r\n    public JsonClass SystemTextJson()\r\n    {\r\n        return System.Text.Json.JsonSerializer.Deserialize<JsonClass>(_jsonToDeserializeFromString);\r\n    }\r\n\r\n    [Benchmark]\r\n    public JsonClass SystemTextJsonMetadataSrcGen()\r\n    {\r\n        return System.Text.Json.JsonSerializer.Deserialize(_jsonToDeserializeFromString, _metadataJsonClassContext.JsonClass);\r\n    }\r\n\r\n    [Benchmark]\r\n    public JsonClass SystemTextJsonDefaultSrcGen()\r\n    {\r\n        return System.Text.Json.JsonSerializer.Deserialize(_jsonToDeserializeFromString, _defaultJsonClassContext.JsonClass);\r\n    }\r\n\r\n    [Benchmark]\r\n    public JsonClass UTF8JSon()\r\n    {\r\n        return Utf8Json.JsonSerializer.Deserialize<JsonClass>(Encoding.UTF8.GetBytes(_jsonToDeserializeFromString));\r\n    }\r\n\r\n    [Benchmark]\r\n    public JsonClass UTF8JSon_Bytes()\r\n    {\r\n        return Utf8Json.JsonSerializer.Deserialize<JsonClass>(_jsonToDeserializeFromBytesUtf8);\r\n    }\r\n\r\n    [Benchmark]\r\n    public JsonClass SpanJSONUtf16()\r\n    {\r\n        return SpanJson.JsonSerializer.Generic.Utf16.Deserialize<JsonClass>(_jsonToDeserializeFromString);\r\n    }\r\n\r\n    [Benchmark]\r\n    public JsonClass SpanJSONUtf8()\r\n    {\r\n        return SpanJson.JsonSerializer.Generic.Utf8.Deserialize<JsonClass>(Encoding.UTF8.GetBytes(_jsonToDeserializeFromString));\r\n    }\r\n\r\n    [Benchmark]\r\n    public JsonClass SpanJSONUtf8_Bytes()\r\n    {\r\n        return SpanJson.JsonSerializer.Generic.Utf8.Deserialize<JsonClass>(_jsonToDeserializeFromBytesUtf8);\r\n    }\r\n\r\n    [Benchmark]\r\n    public JsonSrcGenClass JsonSrcGen()\r\n    {\r\n        _jsonSrcGenConverter.FromJson(_jsonSrcGenClass, _jsonToDeserializeFromString);\r\n        return _jsonSrcGenClass;\r\n    }\r\n\r\n}\r\n\r\npublic class JsonClass\r\n{\r\n    public string Forename { get; set; }\r\n\r\n    public string Surname { get; set; }\r\n\r\n    public int Age { get; set; }\r\n\r\n    public bool Active { get; set; }\r\n}\r\n\r\n[JsonSrcGen.Json]\r\npublic class JsonSrcGenClass\r\n{\r\n    public string Forename { get; set; }\r\n\r\n    public string Surname { get; set; }\r\n\r\n    public int Age { get; set; }\r\n\r\n    public bool Active { get; set; }\r\n}\r\n\r\n[JsonSourceGenerationOptions(PropertyNamingPolicy = JsonKnownNamingPolicy.Unspecified, GenerationMode = JsonSourceGenerationMode.Metadata)]\r\n[JsonSerializable(typeof(JsonClass))]\r\ninternal partial class MetadataJsonClassContext : JsonSerializerContext\r\n{\r\n}\r\n\r\n[JsonSourceGenerationOptions(PropertyNamingPolicy = JsonKnownNamingPolicy.Unspecified, GenerationMode = JsonSourceGenerationMode.Default)]\r\n[JsonSerializable(typeof(JsonClass))]\r\ninternal partial class DefaultJsonClassContext : JsonSerializerContext\r\n{\r\n}\r\n\r\n[JsonSourceGenerationOptions(PropertyNamingPolicy = JsonKnownNamingPolicy.Unspecified, GenerationMode = JsonSourceGenerationMode.Serialization)]\r\n[JsonSerializable(typeof(JsonClass))]\r\ninternal partial class SerializationJsonClassContext : JsonSerializerContext\r\n{\r\n}\r\n```",
          "createdAt": "2023-02-26T10:12:12Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-02-26T13:54:10Z",
                "user": "Jure-BB"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-08-02T07:24:08Z",
                "user": "KrzysztofBranicki"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-11-06T12:29:38Z",
                "user": "saul"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-03-09T15:12:56Z",
                "user": "pablocom"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-04-04T20:49:25Z",
                "user": "elringus"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-05-23T14:40:35Z",
                "user": "atteneder"
              }
            ],
            "totalCount": 6,
            "endCursor": "Y3Vyc29yOnYyOpHOETYj7A=="
          },
          "updatedAt": "2023-02-26T10:12:12Z",
          "id": "IC_kwDODI9FZc5WJcgL"
        },
        {
          "author": "TheMasterofBlubb",
          "body": "Any news on this?",
          "createdAt": "2025-08-24T01:50:07Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-08-24T01:50:07Z",
          "id": "IC_kwDODI9FZc6_yGHn"
        }
      ],
      "totalCount": 6,
      "endCursor": "Y3Vyc29yOnYyOpHOv8hh5w=="
    },
    "url": "https://github.com/dotnet/runtime/issues/55043",
    "title": "Consider fast-path deserialization logic in JSON source generator"
  },
  {
    "author": "bugproof",
    "labels": [
      "api-needs-work",
      "area-System.Text.Json"
    ],
    "createdAt": "2021-07-03T08:31:33Z",
    "body": "I propose `[JsonPropertyFlatten]` attribute that can be used to flatten property. [Similar to `#[serde(flatten)]` in Rust's Serde.](https://serde.rs/attr-flatten.html)\r\n\r\nhttps://stackoverflow.com/questions/65323277/flatten-an-object-with-system-text-json\r\n\r\nImagine I have a class like this:\r\n\r\n```cs\r\npublic class ResponseBase\r\n{\r\n    [JsonPropertyName(\"status\")]\r\n    [JsonConverter(typeof(StatusConverter))]\r\n    public bool IsSuccessStatus { get; set; }\r\n    \r\n    [JsonPropertyName(\"error_message\")] \r\n    public string? ErrorMessage { get; set; }\r\n    \r\n    [JsonPropertyName(\"error_code\")] \r\n    public string? ErrorCode { get; set; }\r\n}\r\n```\r\n\r\nIf flattening was supported I could refactor it to something like this:\r\n\r\n```cs\r\npublic class Error\r\n{\r\n    [JsonPropertyName(\"error_code\")] \r\n    public string Code { get; set; }\r\n\r\n\t[JsonPropertyName(\"error_message\")] \r\n    public string Message { get; set; }\r\n}\r\n\r\npublic class ResponseBase\r\n{\r\n    [JsonPropertyName(\"status\")]\r\n    [JsonConverter(typeof(StatusConverter))]\r\n    public bool IsSuccessStatus { get; set; }\r\n    \r\n    [JsonPropertyFlatten] \r\n    public Error? Error { get; set; }\r\n}\r\n```\r\n\r\nBut it would still serialize and deserialize like `Error` properties were part of the `ResponseBase` class instead of `\"error\": {...}` because I'm writing a client for third party api...\r\n\r\nPossibly blocking? https://github.com/dotnet/runtime/issues/31257",
    "number": 55120,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-07-14T16:24:32Z",
          "user": "fkamp"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-10-20T04:39:31Z",
          "user": "hmqgg"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-11-15T00:55:25Z",
          "user": "hennys"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-06-27T11:17:26Z",
          "user": "phorks"
        },
        {
          "content": "ROCKET",
          "createdAt": "2022-06-27T13:33:43Z",
          "user": "phorks"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-07-10T16:06:54Z",
          "user": "Hyperyx"
        },
        {
          "content": "ROCKET",
          "createdAt": "2022-11-05T11:43:50Z",
          "user": "juho-hanhimaki"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-11-05T11:43:51Z",
          "user": "juho-hanhimaki"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-11-11T13:09:21Z",
          "user": "Reenuay"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-01-19T14:13:40Z",
          "user": "proudust"
        },
        {
          "content": "ROCKET",
          "createdAt": "2023-03-03T01:50:54Z",
          "user": "guimabdo"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-03-03T01:50:58Z",
          "user": "guimabdo"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-03-11T15:47:33Z",
          "user": "wertzui"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-03-17T08:20:36Z",
          "user": "StMarian"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-04-27T08:38:26Z",
          "user": "ecymerman"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-08-22T16:27:29Z",
          "user": "Tim-Phifer-Emerson"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-09-07T18:45:07Z",
          "user": "dpjha84"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-09-18T09:09:23Z",
          "user": "KettuJKL"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-10-23T14:43:56Z",
          "user": "Mart-Bogdan"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-11-18T11:20:28Z",
          "user": "DjArt"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-12-17T17:42:51Z",
          "user": "KubaZ2"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-12-29T18:58:10Z",
          "user": "inikulshin"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-01-19T21:25:26Z",
          "user": "ofitzek"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-01-20T23:54:12Z",
          "user": "AoshiW"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-01-29T07:14:40Z",
          "user": "cremor"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-02-20T18:07:47Z",
          "user": "jetersen"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-03-21T07:18:47Z",
          "user": "Chakrygin"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-04-09T19:46:36Z",
          "user": "EjPlatzer"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-04-16T09:12:02Z",
          "user": "johanbenschop"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-04-19T20:39:53Z",
          "user": "WorkingRobot"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-09-14T15:38:24Z",
          "user": "activtrak-dsalemizadeh"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-09-23T20:03:58Z",
          "user": "ErnSur"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-10-25T06:51:58Z",
          "user": "alexandre-ava"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-11-14T11:11:33Z",
          "user": "dil-zgaal"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-01-21T22:35:15Z",
          "user": "sharshi"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-04-19T06:08:12Z",
          "user": "Lynnesbian"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-05-23T14:55:01Z",
          "user": "mogggen"
        },
        {
          "content": "ROCKET",
          "createdAt": "2025-05-23T14:55:03Z",
          "user": "mogggen"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-07-13T12:55:14Z",
          "user": "michaelhthomas"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-07-28T11:37:33Z",
          "user": "olvrb"
        }
      ],
      "totalCount": 40,
      "endCursor": "Y3Vyc29yOnYyOpHODIv_Lg=="
    },
    "updatedAt": "2023-11-18T11:33:54Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @eiriktsarpalis, @layomia\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\nI propose `[JsonPropertyFlatten]` attribute that can be used to flatten property. Similar to `#[serde(flatten)]` in Rust's Serde.\r\n\r\nhttps://stackoverflow.com/questions/65323277/flatten-an-object-with-system-text-json\r\n\r\nImagine I have a class like this:\r\n\r\n```cs\r\npublic class ResponseBase\r\n{\r\n    [JsonPropertyName(\"status\")]\r\n    [JsonConverter(typeof(StatusConverter))]\r\n    public bool IsSuccessStatus { get; set; }\r\n    \r\n    [JsonPropertyName(\"error_message\")] \r\n    public string? ErrorMessage { get; set; }\r\n    \r\n    [JsonPropertyName(\"error_code\")] \r\n    public string? ErrorCode { get; set; }\r\n}\r\n```\r\n\r\nIf flattening was supported I could refactor it to something like this:\r\n\r\n```cs\r\npublic class Error\r\n{\r\n    [JsonPropertyName(\"error_code\")] \r\n    public string Code { get; set; }\r\n\r\n\t[JsonPropertyName(\"error_message\")] \r\n    public string Message { get; set; }\r\n}\r\n\r\npublic class ResponseBase\r\n{\r\n    [JsonPropertyName(\"status\")]\r\n    [JsonConverter(typeof(StatusConverter))]\r\n    public bool IsSuccessStatus { get; set; }\r\n    \r\n    [JsonPropertyFlatten] \r\n    public Error Error { get; set; }\r\n}\r\n```\r\n\r\nBut it would still serialize and deserialize like `Error` properties were part of the `ResponseBase` class.\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>bugproof</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`api-suggestion`, `area-System.Text.Json`, `untriaged`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2021-07-03T08:31:39Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-07-03T08:31:39Z",
          "id": "MDEyOklzc3VlQ29tbWVudDg3MzM2OTYwOA=="
        },
        {
          "author": "fydar",
          "body": "This could be implemented using source generators.\r\n\r\nA source generator would have to:\r\n\r\n- Add a `[JsonIgnore]` attribute to the member with the `[JsonPropertyFlatten]` attribute.\r\n- Add `private` properties that get and set the member properties on the object.\r\n\r\nUsing a source generator, the following code:\r\n\r\n```csharp\r\npublic class ResponseBase\r\n{\r\n    [JsonPropertyName(\"status\")]\r\n    [JsonConverter(typeof(StatusConverter))]\r\n    public bool IsSuccessStatus { get; set; }\r\n    \r\n    [JsonPropertyFlatten] \r\n    public Error? Error { get; set; }\r\n}\r\n```\r\n\r\nCould be converted to:\r\n\r\n```csharp\r\npublic class ResponseBase\r\n{\r\n    [JsonPropertyName(\"status\")]\r\n    [JsonConverter(typeof(StatusConverter))]\r\n    public bool IsSuccessStatus { get; set; }\r\n    \r\n    [JsonPropertyFlatten] \r\n    [JsonIgnore]\r\n    public Error? Error { get; set; }\r\n    \r\n    [JsonPropertyName(\"error_code\")] \r\n    private string Code\r\n    {\r\n        get => Error.ErrorCode;\r\n        set => Error.ErrorCode = value;\r\n    }\r\n    \r\n    [JsonPropertyName(\"error_message\")] \r\n    private string Message \r\n    {\r\n        get => Error.Message;\r\n        set => Error.Message = value;\r\n    }\r\n}\r\n```",
          "createdAt": "2021-07-03T22:43:05Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-07-04T07:57:32Z",
                "user": "pinkfloydx33"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-01-15T09:49:48Z",
                "user": "Zazik"
              }
            ],
            "totalCount": 2,
            "endCursor": "Y3Vyc29yOnYyOpHODSl4mQ=="
          },
          "updatedAt": "2021-07-03T22:43:05Z",
          "id": "MDEyOklzc3VlQ29tbWVudDg3MzQ4MDE3NQ=="
        },
        {
          "author": "eiriktsarpalis",
          "body": "How would such a mechanism deal with potentially conflicting property names (same key occurring in both parent and child objects)? How does serde deal with flattened types whose serialization is a number or array?\r\n\r\nIt's unlikely we would consider such a feature for 7.0.0. My recommendation is to use a custom converter (should be easier to achieve using the new `JsonNode` to construct an intermediate representation). We can revisit for future releases if sufficient demand for this feature arises.",
          "createdAt": "2021-10-15T13:48:03Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-10-15T13:48:03Z",
          "id": "IC_kwDODI9FZc44SSBY"
        },
        {
          "author": null,
          "body": "This issue has been marked with the `api-needs-work` label. This may suggest that the proposal requires further refinement before it can be considered for API review. Please refer to our [API review guidelines](https://github.com/dotnet/runtime/blob/main/docs/project/api-review-process.md) for a detailed description of the process. \n\nWhen ready to submit an amended proposal, please ensure that the original post in this issue has been updated, following the API proposal template and examples as provided in the guidelines.",
          "createdAt": "2021-10-15T13:48:18Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-10-15T13:48:18Z",
          "id": "IC_kwDODI9FZc44SSEg"
        },
        {
          "author": "bugproof",
          "body": "> How would such a mechanism deal with potentially conflicting property names (same key occurring in both parent and child objects)?\r\n\r\nThe same way as it deals with this. It would just treat all the properties of the flattened property as they were part of the same object. I think it should just throw an exception.\r\n\r\n```cs\r\n[JsonPropertyName(\"name\")]\r\npublic string Name { get; set; }\r\n\r\n[JsonPropertyName(\"name\")]\r\npublic string Name2 { get; set; }\r\n```\r\n\r\n> How does serde deal with flattened types whose serialization is a number or array?\r\n\r\nNot sure about that. But it should just support `class`/`struct` as I see no reason to flatten number or array. If you try to flatten number or array it should ignore it or throw an exception. I see no reason why would anyone  do this.",
          "createdAt": "2021-10-20T15:45:45Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-10-20T15:47:02Z",
          "id": "IC_kwDODI9FZc44fkDA"
        },
        {
          "author": "DjArt",
          "body": "> Not sure about that. But it should just support class/struct as I see no reason to flatten number or array. If you try to flatten number or array it should ignore it or throw an exception. I see no reason why would anyone do this.\r\n\r\nofc we should able to flat array or any class with indexer. Just introduce new attribute (or constructor overload for `JsonPropertyName`), where one of parameter will be a text representation of index value, second for original property name and third for JSON name.\r\n\r\nAnd we get something like that:\r\n```\r\npublic class ResponseBase\r\n{\r\n    [JsonPropertyName(\"status\")]\r\n    [JsonConverter(typeof(StatusConverter))]\r\n    public bool IsSuccessStatus { get; set; }\r\n    \r\n    [JsonPropertyFlatten]\r\n    [JsonPropertyName(nameof(Error.Status), \"status\")]\r\n    [JsonPropertyName(nameof(Error.Message), \"message\")]\r\n    [JsonPropertyName(nameof(Error.Lines), \"0\", \"first_line\")]\r\n    public Error? Error { get; set; }\r\n\r\n    [JsonPropertyFlatten]\r\n    [JsonPropertyName(\"\", \"0\", \"C0\")]\r\n    [JsonPropertyName(\"\", \"1\", \"C1\")]\r\n    [JsonPropertyName(\"\", \"2\", \"C2\")]\r\n    public int[] Codes { get; set; }\r\n}\r\n```",
          "createdAt": "2023-11-18T11:26:24Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-11-18T11:33:54Z",
          "id": "IC_kwDODI9FZc5sVJZC"
        }
      ],
      "totalCount": 6,
      "endCursor": "Y3Vyc29yOnYyOpHObFSWQg=="
    },
    "url": "https://github.com/dotnet/runtime/issues/55120",
    "title": "System.Text.Json - Support property flattening - [JsonPropertyFlatten]"
  },
  {
    "author": "eiriktsarpalis",
    "labels": [
      "api-needs-work",
      "area-System.Text.Json",
      "User Story",
      "Priority:3",
      "Cost:M",
      "Team:Libraries"
    ],
    "createdAt": "2021-07-15T14:48:37Z",
    "body": "Concerning support for discriminated unions, it might be worth pointing out that there is no one canonical way to encode DUs in JSON. DUs are used in many different ways in F# code, including the following:\r\n\r\n- Single case DUs, e.g. `type Email = Email of string`, used to provide a type-safe wrapper for common values. A user might expect that `Email(\"email\")` should serialize as its payload, `\"email\"`.\r\n- Type-safe enums, e.g. `type Suit = Heart | Spade | Diamond | Club`. Users might reasonably expect that `Spade` should serialize as the union case identifier, `\"Spade\"`.\r\n- Unions with arbitrary combinations of union cases and arities, e.g. `type Shape = Point | Circle of radius:float | Rectangle of width:float * length:float`. A value like `Circle(42.)` would require an encoding similar to `{ \"shape\" : \"circle\", \"radius\" : 42 }`. Users should be able to specify the case discriminator property name (`\"shape\"`) as well as the identifier for the union case (`Circle` mapping to `\"circle\"`).\r\n\r\nIn light of the above, I'm increasingly starting to think that System.Text.Json should not be providing a default mechanism for serializing DUs. Users would still be able to use [available custom converters](https://github.com/Tarmil/FSharp.SystemTextJson/) that provide the union encoding that suits their use case or perhaps use unions in their data contracts in a way that [bypasses the serialization layer altogether](https://eiriktsarpalis.wordpress.com/2018/10/30/a-contract-pattern-for-schemaless-datastores/).\r\n\r\n_Originally posted by @eiriktsarpalis in https://github.com/dotnet/runtime/issues/29812#issuecomment-878303600_\r\n\r\nIf we do decide to support F# DUs in the future, it would likely be in the form of a publicly available converter factory à la [JsonStringEnumConverter](https://docs.microsoft.com/en-us/dotnet/api/system.text.json.serialization.jsonstringenumconverter?view=net-5.0) that configures one or more of the above alternative serialization formats.",
    "number": 55744,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-07-15T15:08:46Z",
          "user": "adelarsq"
        },
        {
          "content": "EYES",
          "createdAt": "2021-07-15T15:08:48Z",
          "user": "adelarsq"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-10-21T10:32:17Z",
          "user": "shupoval"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-12-01T18:18:50Z",
          "user": "ed-ilyin"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-01-15T15:53:37Z",
          "user": "AngelMunoz"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-01-15T17:12:42Z",
          "user": "dominikus1993"
        },
        {
          "content": "EYES",
          "createdAt": "2022-01-15T17:12:43Z",
          "user": "dominikus1993"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-01-15T17:25:24Z",
          "user": "CaptnCodr"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-01-15T17:25:53Z",
          "user": "peterzeller"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-01-15T18:14:09Z",
          "user": "GennadyGS"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-01-15T19:38:37Z",
          "user": "DaveJohnson8080"
        },
        {
          "content": "HEART",
          "createdAt": "2022-01-15T21:10:26Z",
          "user": "adelarsq"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-01-15T22:47:03Z",
          "user": "weslenng"
        },
        {
          "content": "HEART",
          "createdAt": "2022-01-15T22:47:03Z",
          "user": "weslenng"
        },
        {
          "content": "EYES",
          "createdAt": "2022-01-15T22:47:03Z",
          "user": "weslenng"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-01-16T12:55:17Z",
          "user": "omariom"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-01-18T09:26:30Z",
          "user": "rungwiroon"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-01-28T00:00:45Z",
          "user": "rgwood"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-02-20T13:11:29Z",
          "user": "sentai77"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-05-15T14:49:39Z",
          "user": "vzarytovskii"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-05-18T12:17:54Z",
          "user": "grab-a-byte"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-05-22T04:50:02Z",
          "user": "hrrrrustic"
        },
        {
          "content": "CONFUSED",
          "createdAt": "2022-06-18T18:25:34Z",
          "user": "oleksandr-bilyk"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-07-15T13:14:56Z",
          "user": "jannikbuschke"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-11-15T18:22:20Z",
          "user": "musicm122"
        },
        {
          "content": "HEART",
          "createdAt": "2022-11-15T18:22:30Z",
          "user": "musicm122"
        },
        {
          "content": "EYES",
          "createdAt": "2022-11-15T18:22:32Z",
          "user": "musicm122"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-03-14T14:00:35Z",
          "user": "MaybeSacred"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-04-01T12:59:47Z",
          "user": "BrunoZell"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-04-02T21:16:25Z",
          "user": "gdar91"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-04-21T20:26:45Z",
          "user": "parched"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-07-04T21:15:24Z",
          "user": "ardave"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-07-24T06:13:09Z",
          "user": "UnstoppableMango"
        },
        {
          "content": "HEART",
          "createdAt": "2023-07-24T06:13:11Z",
          "user": "UnstoppableMango"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-08-19T15:41:08Z",
          "user": "CSharpFiasco"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-10-27T20:29:10Z",
          "user": "prenaissance"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-01-10T21:46:27Z",
          "user": "mariomeyrelles"
        },
        {
          "content": "EYES",
          "createdAt": "2024-01-10T21:46:30Z",
          "user": "mariomeyrelles"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-02-14T08:05:57Z",
          "user": "KenBonny"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-02-27T13:29:48Z",
          "user": "suside"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-03-25T17:27:01Z",
          "user": "galassie"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-03-25T18:03:51Z",
          "user": "kpietraszko"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-04-17T14:14:29Z",
          "user": "anghelnicolae"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-04-29T22:23:48Z",
          "user": "sheepla"
        },
        {
          "content": "EYES",
          "createdAt": "2024-04-29T22:24:30Z",
          "user": "sheepla"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-05-12T17:33:04Z",
          "user": "NoahStolk"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-05-24T16:45:17Z",
          "user": "iSeiryu"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-06-06T06:01:04Z",
          "user": "Tyrrx"
        },
        {
          "content": "EYES",
          "createdAt": "2024-11-10T14:56:47Z",
          "user": "dysfungi"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-11-22T20:39:47Z",
          "user": "ethan-fie"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-12-20T04:11:26Z",
          "user": "fajpunk"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-01-30T02:54:48Z",
          "user": "AlgorithmsAreCool"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-04-09T20:01:50Z",
          "user": "rynoV"
        },
        {
          "content": "EYES",
          "createdAt": "2025-04-09T20:01:51Z",
          "user": "rynoV"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-05-09T11:10:56Z",
          "user": "neon-sunset"
        }
      ],
      "totalCount": 55,
      "endCursor": "Y3Vyc29yOnYyOpHOC85Q5A=="
    },
    "updatedAt": "2025-05-10T13:37:34Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @eiriktsarpalis, @layomia\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\nConcerning support for discriminated unions, it might be worth pointing out that there is no one canonical way to encode DUs in JSON. DUs are used in many different ways in F# code, including the following:\r\n\r\n- Single case DUs, e.g. `type Email = Email of string`, used to provide a type-safe wrapper for common values. A user might expect that `Email(\"email\")` should serialize as its payload, `\"email\"`.\r\n- Type-safe enums, e.g. `type Suit = Heart | Spade | Diamond | Club`. Users might reasonably expect that `Spade` should serialize as the union case identifier, `\"Spade\"`.\r\n- Unions with arbitrary combinations of union cases and arities, e.g. `type Shape = Point | Circle of radius:float | Rectangle of width:float * length:float`. A value like `Circle(42.)` would require an encoding similar to `{ \"shape\" : \"circle\", \"radius\" : 42 }`. Users should be able to specify the case discriminator property name (`\"shape\"`) as well as the identifier for the union case (`Circle` mapping to `\"circle\"`).\r\n\r\nIn light of the above, I'm increasingly starting to think that System.Text.Json should not be providing a default mechanism for serializing DUs. Users would still be able to use [available custom converters](https://github.com/Tarmil/FSharp.SystemTextJson/) that provide the union encoding that suits their use case or perhaps use unions in their data contracts in a way that [bypasses the serialization layer altogether](https://eiriktsarpalis.wordpress.com/2018/10/30/a-contract-pattern-for-schemaless-datastores/).\r\n\r\n_Originally posted by @eiriktsarpalis in https://github.com/dotnet/runtime/issues/29812#issuecomment-878303600_\r\n\r\nIf we do decide to support F# DUs in the future, it would likely be in the form of a publicly available converter factory à la [JsonStringEnumConverter](https://docs.microsoft.com/en-us/dotnet/api/system.text.json.serialization.jsonstringenumconverter?view=net-5.0) that configures one or more of the above alternative serialization formats.\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>eiriktsarpalis</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`area-System.Text.Json`, `untriaged`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2021-07-15T14:48:42Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-07-15T14:48:42Z",
          "id": "MDEyOklzc3VlQ29tbWVudDg4MDc1NzIzMQ=="
        },
        {
          "author": "eiriktsarpalis",
          "body": "Tagging @bartelink @zaid-ajaj @ninofloris who might have opinions on the matter.",
          "createdAt": "2021-07-15T14:50:28Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-07-15T14:50:28Z",
          "id": "MDEyOklzc3VlQ29tbWVudDg4MDc1ODY1Ng=="
        },
        {
          "author": "Zaid-Ajaj",
          "body": "> it might be worth pointing out that there is no one canonical way to encode DUs in JSON.\r\n\r\nIMO just because there are multiple ways to represent DUs in JSON doesn't imply that a library shouldn't pick a default. I _think_ many F# devs would appreciate a choice that works out of the box with the possibility of customization where required, not having to customize or having to understand library internals to get started with it. \r\n\r\nThis is the approach I implemented in `Fable.Remoting.Json` which is a Newtonsoft.Json converter for F# types without loss of information (possible to round trip). Given a `Shape` type like\r\n```fs\r\ntype Shape = \r\n  | Point \r\n  | Circle of radius:float \r\n  | Rectangle of width:float * length:float\r\n```\r\nThe following JSON is generated\r\n```\r\nPoint => { \"Point\": [] } | \"Point\"\r\nCircle(20.0) => { \"Circle\": [20.0] }\r\nRectangle(12.0, 10.0) => { \"Rectangle\": [12.0, 10.0] }  \r\n```\r\nof course there could be a setting to choose to write out the property names when provided\r\n```\r\nCircle(20.0) => { \"Circle\": { \"radius\": 20.0 } }\r\nRectangle(12.0, 10.0) => { \"Rectangle\": { \"width\": 12.0, \"height\": 10.0 } }\r\n```\r\n",
          "createdAt": "2021-07-15T15:05:31Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-01-15T19:39:27Z",
                "user": "DaveJohnson8080"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-01-15T21:10:54Z",
                "user": "adelarsq"
              },
              {
                "content": "HEART",
                "createdAt": "2022-01-15T21:10:56Z",
                "user": "adelarsq"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-05-21T17:39:36Z",
                "user": "LiteracyFanatic"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-06-18T18:27:55Z",
                "user": "oleksandr-bilyk"
              },
              {
                "content": "HEART",
                "createdAt": "2022-06-18T18:28:07Z",
                "user": "oleksandr-bilyk"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-07-15T13:16:02Z",
                "user": "jannikbuschke"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-04-02T21:18:18Z",
                "user": "gdar91"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-07-04T21:26:43Z",
                "user": "ardave"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-12-05T09:06:39Z",
                "user": "Aegonek"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-12-06T15:31:19Z",
                "user": "ImaginaryDevelopment"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-01-10T21:47:27Z",
                "user": "mariomeyrelles"
              },
              {
                "content": "HEART",
                "createdAt": "2024-01-10T21:47:28Z",
                "user": "mariomeyrelles"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-03-25T18:04:19Z",
                "user": "kpietraszko"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-04-03T23:50:06Z",
                "user": "auslavs"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-04-29T22:25:45Z",
                "user": "sheepla"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-11-22T20:41:12Z",
                "user": "ethan-fie"
              },
              {
                "content": "HEART",
                "createdAt": "2024-11-22T20:45:39Z",
                "user": "ethan-fie"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-12-11T22:47:58Z",
                "user": "OlegZee"
              }
            ],
            "totalCount": 19,
            "endCursor": "Y3Vyc29yOnYyOpHOD-pfHA=="
          },
          "updatedAt": "2021-07-15T15:05:31Z",
          "id": "MDEyOklzc3VlQ29tbWVudDg4MDc3MDcxNg=="
        },
        {
          "author": "bartelink",
          "body": "I agree [with the OP] that there cannot and should not be a default canonical implementation; As `FSharp.SystemTextJson` and the default encoding provided by `Newtonsoft.Json` >=6 illustrate, there are many choices for how to represent things, and there is no reasonable default IMO.\r\n\r\nI tend to take view that individual converters that do easy to describe things are the way to go. Thus I would ideally like to see the following in the box:\r\n\r\n1. `TypeSafeEnumConverter`: [example unoptimized impl](https://github.com/jet/FsCodec/blob/master/src/FsCodec.SystemTextJson/TypeSafeEnumConverter.fs)\r\n2. `UnionConverter`: IME the format you proposed in the OP (`{ \"discriminator\": \"value\", <named fields from case as for a class/record, same for cases in tupled form> }`) is common in the wild, and IME there are established implementations on the JVM, Swift and JS which work with that rendering format). See [FsCodec `UnionConverter` impl](https://github.com/jet/FsCodec/blob/master/src/FsCodec.SystemTextJson/UnionConverter.fs). (There's also an [OSS equivalent of this converter for `Newtonsoft.Json` that implements this scheme]( https://github.com/jet/FsCodec/blob/master/src/FsCodec.NewtonsoftJson/UnionConverter.fs))\r\n3. [I don't believe special case handling of single-case unions is something that should be supported](https://github.com/dotnet/runtime/issues/29812#issuecomment-880827391)",
          "createdAt": "2021-07-15T15:07:18Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-02-14T08:38:32Z",
          "id": "MDEyOklzc3VlQ29tbWVudDg4MDc3MjA4Mg=="
        },
        {
          "author": "bartelink",
          "body": "> `Rectangle(12.0, 10.0)` => `{ \"Rectangle\": [12.0, 10.0]}`\r\n\r\nWhile `Newtonsoft.Json` does this out of the box, I'd be very much against having this representation be a default. Furthermore, I think its a harmful thing to even put in the box in the first place; let me try to justify this:\r\n\r\n- It's not just a private roundtrippable rendering format - its best assumed to be going into a database that will a) outlive my code b) will need to be parsed by other systems in other languages\r\n- because JSON does not define a tuple concept, it's less likely to be covered in any given library on the other side.\r\n- Arrays with mixed types is not something that should be introduced lightly into a rendering format\r\n- In general, if I'm looking to render or parse as JSON, there needs to be a good story wrt versioning of type being serialized/deserialized\r\n- versioning concerns in my code:\r\n   - reordering fields in a tuple opens up a troubleshooting nightmare.\r\n   - if I want to move from a 2-tuple to a record with three fields, there is no smooth transition possible\r\n   - if I want to introduce a new optional, field, it has to go at the end\r\n   - etc. There's likely plenty best practice in this area; [this ebook](https://leanpub.com/esversioning) covers many real world cases in depth\r\n\r\nIn order to guard against things that IME happen in the wild, I'd propose the following rules:\r\n- unnamed tuple case body fields should be rejected (i.e. no `Item` fields)\r\n- by default, unions should not convert without opting in by either registering a converter or tagging the type with a converter configuration\r\n\r\n>`Point` => `{ \"Point\": [] } | \"Point\"`\r\n\r\nAgain, IME, maintaining symmetry is valuable for nullary cases too. The main reason for this being that any consumer will be able to adapt to me adding a field to the case payload if it's rendered as `{ \"shape\": \"point\"}`; one is simply adding a field to an object, versus transitioning from a `string` to an `object`.\r\n\r\nI'd also mention another reason a canonical default handing is likely to run aground even if it was to be defined:\r\n\r\n- *Unmappable Cases*: I've encountered at least the following needs when case names don't map to a case in the union \r\n  1. Fail fast - throw an exception\r\n  2. Have a catch-all case that hands you the body as a `JObject` or equivalent (see UnionConverter Unknown case support)\r\n  3. Silently ignore\r\n",
          "createdAt": "2021-07-15T15:46:30Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-06-06T06:03:07Z",
                "user": "Tyrrx"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHODkvc1g=="
          },
          "updatedAt": "2021-07-15T15:46:30Z",
          "id": "MDEyOklzc3VlQ29tbWVudDg4MDgwNTcxMg=="
        },
        {
          "author": "jhf",
          "body": "I agree with @bartelink that the compatibility of json encoded data can be a minefield, that requires attention when writing migrations, and when making API changes.\r\n\r\nI still think that having a default canonical implementation provides a good user experience. I think it is too early to force the programmer understand and choose between serialisation strategies just because they wish to turn information into JSON.\r\n\r\nRather, when somebody has durable data, or needs to concern themselves with wire compatibility, then the way things are serialised may get important. In my case, when I upgrade durable data  migrations, I  transform the data, using the default canonical implementation, but I map from one type to another type, and write again using the default canonical implementation.\r\nFor exposed API REST/json endpoints I either make sure it is a wire compatible change, or I make a new endpoint (probably with a version number).\r\n\r\nIf there is a large number of types involved, then the burden of having to specify a per type serialisation strategy, as a lot of extra work. Surely, yes, it will be more optimised, and possible upgrade proof, but since I'm writing migrations and making new endpoints, that point is moot, for me. Thus I'm forced to do more work, without any apparent benefit.\r\n\r\nBy having a default canonical implementation, and allowing overrides, it is possible to use json with a minimum amount of effort, and allow freedom when it has benefit.\r\n\r\nBy the way, what would be the developer experience when using Type Providers, such as https://fsprojects.github.io/SQLProvider/ when there is no default canonical implementation?\r\n\r\nFrom my perspective, having a default canonical implementation, allows usage without con\r\n@bartelink ",
          "createdAt": "2021-07-23T09:55:11Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-07-23T19:21:59Z",
                "user": "adelarsq"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-08-19T15:15:52Z",
                "user": "hvester"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-06-18T18:34:59Z",
                "user": "oleksandr-bilyk"
              }
            ],
            "totalCount": 3,
            "endCursor": "Y3Vyc29yOnYyOpHOCijPOQ=="
          },
          "updatedAt": "2021-07-23T09:55:11Z",
          "id": "IC_kwDODI9FZc40yBdZ"
        },
        {
          "author": "bartelink",
          "body": "@jhf @Zaid-Ajaj While I protested a lot, being able to have Unions convert without having to litter the code with Attributes is definitely something that's hard to give up once you've experienced it ;)\r\n\r\nI implemented opt-in selection of such a policy https://github.com/jet/FsCodec/pull/69 - would appreciate any thoughts you might have and/or whether the fact that one can define an explicit encoding policy in ~200 LOC without the risk of forcing a necessarily opinionated encoding without people being aware",
          "createdAt": "2022-01-05T14:56:54Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-01-05T14:56:54Z",
          "id": "IC_kwDODI9FZc478qM8"
        },
        {
          "author": "deyanp",
          "body": "What is the best (performance-wise) way currently (Jan 2022) to serialize/deserialize F# DUs which are \"Type-safe enums\" as per the initial post (not Single case DUs, no fields attached to the cases)? We use currently .NET Enums in our Api Dto layer because we had severe performance issues with DU serialization/deserialization performance in the past ... however we are missing the exhaustive match (at compilation) of the DUs ...",
          "createdAt": "2022-01-26T17:35:41Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-01-26T17:35:41Z",
          "id": "IC_kwDODI9FZc488Q9K"
        },
        {
          "author": "bartelink",
          "body": "@deyanp I've never benchmarked, but putting `[<JsonConverter(TypeSafeEnumConverter<Type>)` shoudl work and work well. The [key lookup of the F# type info](https://github.com/jet/FsCodec/blob/master/src/FsCodec.SystemTextJson/TypeSafeEnumConverter.fs#L15) is cached, and I'd expect the determination of whether to apply the converter to be managed efficiently in STJ, i.e. only call [`CanConvert`](https://github.com/jet/FsCodec/blob/master/src/FsCodec.SystemTextJson/TypeSafeEnumConverter.fs#L40) once\r\n\r\nSo I'd say its worth a benchmark - I'd be surprised if its in the same realm of perf as enums but can't imagine it being a disaster.\r\n\r\n(would accept the benchmark as a PR if you see fit)",
          "createdAt": "2022-01-26T17:47:58Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-01-26T17:47:58Z",
          "id": "IC_kwDODI9FZc488TUx"
        },
        {
          "author": "deyanp",
          "body": "@bartelink , hmm, I think I am doing something wrong, because the benchmark Enum <> DU brings very similar results (even though the code I saw in FsCodec.SystemTextJson is full of reflection and stuff): \r\n\r\n**Serialization:** \r\n```\r\n// * Summary *\r\n\r\nBenchmarkDotNet=v0.13.1, OS=ubuntu 21.10\r\nIntel Core i9-10885H CPU 2.40GHz, 1 CPU, 16 logical and 8 physical cores\r\n.NET SDK=6.0.101\r\n  [Host]   : .NET 6.0.1 (6.0.121.56705), X64 RyuJIT DEBUG\r\n  .NET 6.0 : .NET 6.0.1 (6.0.121.56705), X64 RyuJIT\r\n\r\nJob=.NET 6.0  Runtime=.NET 6.0  \r\n\r\n| Method | size |     Mean |   Error |  StdDev |\r\n|------- |----- |---------:|--------:|--------:|\r\n|  Enum1 | 1000 | 261.0 ns | 1.03 ns | 0.91 ns |\r\n|    DU1 | 1000 | 267.7 ns | 1.11 ns | 1.03 ns |\r\n|  Enum5 | 1000 | 446.6 ns | 6.80 ns | 6.36 ns |\r\n|    DU5 | 1000 | 442.6 ns | 1.84 ns | 1.72 ns |\r\n| Enum10 | 1000 | 439.9 ns | 1.40 ns | 1.24 ns |\r\n|   DU10 | 1000 | 462.6 ns | 1.35 ns | 1.13 ns |\r\n\r\n// * Hints *\r\nOutliers\r\n  SerBenchmarks.Enum1: .NET 6.0  -> 1 outlier  was  removed (270.00 ns)\r\n  SerBenchmarks.Enum10: .NET 6.0 -> 1 outlier  was  removed (444.64 ns)\r\n  SerBenchmarks.DU10: .NET 6.0   -> 2 outliers were removed (466.17 ns, 466.62 ns)\r\n\r\n// * Legends *\r\n  size   : Value of the 'size' parameter\r\n  Mean   : Arithmetic mean of all measurements\r\n  Error  : Half of 99.9% confidence interval\r\n  StdDev : Standard deviation of all measurements\r\n  1 ns   : 1 Nanosecond (0.000000001 sec)\r\n```\r\n\r\n**Deserialization:**\r\n```\r\n// * Summary *\r\n\r\nBenchmarkDotNet=v0.13.1, OS=ubuntu 21.10\r\nIntel Core i9-10885H CPU 2.40GHz, 1 CPU, 16 logical and 8 physical cores\r\n.NET SDK=6.0.101\r\n  [Host]   : .NET 6.0.1 (6.0.121.56705), X64 RyuJIT DEBUG\r\n  .NET 6.0 : .NET 6.0.1 (6.0.121.56705), X64 RyuJIT\r\n\r\nJob=.NET 6.0  Runtime=.NET 6.0  \r\n\r\n| Method | size |       Mean |   Error |  StdDev |\r\n|------- |----- |-----------:|--------:|--------:|\r\n|  Enum1 | 1000 |   471.6 ns | 2.31 ns | 2.05 ns |\r\n|    DU1 | 1000 |   477.6 ns | 1.56 ns | 1.38 ns |\r\n|  Enum5 | 1000 |   922.0 ns | 3.76 ns | 3.33 ns |\r\n|    DU5 | 1000 |   953.3 ns | 6.58 ns | 5.83 ns |\r\n| Enum10 | 1000 | 1,432.8 ns | 5.06 ns | 4.74 ns |\r\n|   DU10 | 1000 | 1,429.0 ns | 7.43 ns | 6.95 ns |\r\n\r\n// * Hints *\r\nOutliers\r\n  DeserBenchmarks.Enum1: .NET 6.0 -> 1 outlier  was  removed (488.89 ns)\r\n  DeserBenchmarks.DU1: .NET 6.0   -> 1 outlier  was  removed (484.40 ns)\r\n  DeserBenchmarks.Enum5: .NET 6.0 -> 1 outlier  was  removed (929.99 ns)\r\n  DeserBenchmarks.DU5: .NET 6.0   -> 1 outlier  was  removed (995.93 ns)\r\n\r\n// * Legends *\r\n  size   : Value of the 'size' parameter\r\n  Mean   : Arithmetic mean of all measurements\r\n  Error  : Half of 99.9% confidence interval\r\n  StdDev : Standard deviation of all measurements\r\n  1 ns   : 1 Nanosecond (0.000000001 sec\r\n```\r\n\r\nCode (as F# Console app, as FSX give error [^1]\r\n\r\n```\r\n// #r \"nuget: FsCodec.SystemTextJson, 2.3.0\"\r\n// #r \"nuget: BenchmarkDotNet, 0.13.1\"\r\n\r\nopen System\r\nopen System.Globalization\r\nopen System.Text.Json\r\nopen System.Text.Json.Serialization\r\nopen FsCodec.SystemTextJson\r\nopen BenchmarkDotNet.Attributes\r\nopen BenchmarkDotNet.Running\r\nopen BenchmarkDotNet.Jobs\r\n\r\ntype AccountingEntryTypeEnum = \r\n| Debit = 0\r\n| Credit = 1\r\ntype AccountingEntryTypeEnum2 = \r\n| Debit = 0\r\n| Credit = 1\r\ntype AccountingEntryTypeEnum3 = \r\n| Debit = 0\r\n| Credit = 1\r\ntype AccountingEntryTypeEnum4 = \r\n| Debit = 0\r\n| Credit = 1\r\ntype AccountingEntryTypeEnum5 = \r\n| Debit = 0\r\n| Credit = 1\r\ntype AccountingEntryTypeEnum6 = \r\n| Debit = 0\r\n| Credit = 1\r\ntype AccountingEntryTypeEnum7 = \r\n| Debit = 0\r\n| Credit = 1\r\ntype AccountingEntryTypeEnum8 = \r\n| Debit = 0\r\n| Credit = 1\r\ntype AccountingEntryTypeEnum9 = \r\n| Debit = 0\r\n| Credit = 1\r\ntype AccountingEntryTypeEnum10 = \r\n| Debit = 0\r\n| Credit = 1\r\n\r\ntype AccountingEntryEnum1 = {\r\n    Id : string\r\n    Type : AccountingEntryTypeEnum\r\n}\r\n\r\ntype AccountingEntryEnum5 = {\r\n    Id : string\r\n    Type : AccountingEntryTypeEnum\r\n    Type2 : AccountingEntryTypeEnum2\r\n    Type3 : AccountingEntryTypeEnum3\r\n    Type4 : AccountingEntryTypeEnum4\r\n    Type5 : AccountingEntryTypeEnum5\r\n}\r\n\r\ntype AccountingEntryEnum10 = {\r\n    Id : string\r\n    Type : AccountingEntryTypeEnum\r\n    Type2 : AccountingEntryTypeEnum2\r\n    Type3 : AccountingEntryTypeEnum3\r\n    Type4 : AccountingEntryTypeEnum4\r\n    Type5 : AccountingEntryTypeEnum5\r\n    Type6 : AccountingEntryTypeEnum6\r\n    Type7 : AccountingEntryTypeEnum7\r\n    Type8 : AccountingEntryTypeEnum8\r\n    Type9 : AccountingEntryTypeEnum9\r\n    Type10 : AccountingEntryTypeEnum10\r\n}\r\n\r\n[<JsonConverter(typeof<TypeSafeEnumConverter<AccountingEntryTypeDU>>)>]\r\ntype AccountingEntryTypeDU = \r\n| Debit\r\n| Credit\r\n[<JsonConverter(typeof<TypeSafeEnumConverter<AccountingEntryTypeDU2>>)>]\r\ntype AccountingEntryTypeDU2 = \r\n| Debit\r\n| Credit\r\n[<JsonConverter(typeof<TypeSafeEnumConverter<AccountingEntryTypeDU3>>)>]\r\ntype AccountingEntryTypeDU3 = \r\n| Debit\r\n| Credit\r\n[<JsonConverter(typeof<TypeSafeEnumConverter<AccountingEntryTypeDU4>>)>]\r\ntype AccountingEntryTypeDU4 = \r\n| Debit\r\n| Credit\r\n[<JsonConverter(typeof<TypeSafeEnumConverter<AccountingEntryTypeDU5>>)>]\r\ntype AccountingEntryTypeDU5 = \r\n| Debit\r\n| Credit\r\n[<JsonConverter(typeof<TypeSafeEnumConverter<AccountingEntryTypeDU6>>)>]\r\ntype AccountingEntryTypeDU6= \r\n| Debit\r\n| Credit\r\n[<JsonConverter(typeof<TypeSafeEnumConverter<AccountingEntryTypeDU7>>)>]\r\ntype AccountingEntryTypeDU7 = \r\n| Debit\r\n| Credit\r\n[<JsonConverter(typeof<TypeSafeEnumConverter<AccountingEntryTypeDU8>>)>]\r\ntype AccountingEntryTypeDU8 = \r\n| Debit\r\n| Credit\r\n[<JsonConverter(typeof<TypeSafeEnumConverter<AccountingEntryTypeDU9>>)>]\r\ntype AccountingEntryTypeDU9 = \r\n| Debit\r\n| Credit\r\n[<JsonConverter(typeof<TypeSafeEnumConverter<AccountingEntryTypeDU10>>)>]\r\ntype AccountingEntryTypeDU10 = \r\n| Debit\r\n| Credit\r\n\r\ntype AccountingEntryDU1 = {\r\n    Id : string\r\n    Type : AccountingEntryTypeDU\r\n}\r\n\r\ntype AccountingEntryDU5 = {\r\n    Id : string\r\n    Type : AccountingEntryTypeDU\r\n    Type2 : AccountingEntryTypeDU2\r\n    Type3 : AccountingEntryTypeDU3\r\n    Type4 : AccountingEntryTypeDU4\r\n    Type5 : AccountingEntryTypeDU5\r\n}\r\n\r\ntype AccountingEntryDU10 = {\r\n    Id : string\r\n    Type : AccountingEntryTypeDU\r\n    Type2 : AccountingEntryTypeDU2\r\n    Type3 : AccountingEntryTypeDU3\r\n    Type4 : AccountingEntryTypeDU4\r\n    Type5 : AccountingEntryTypeDU5\r\n    Type6 : AccountingEntryTypeDU6\r\n    Type7 : AccountingEntryTypeDU7\r\n    Type8 : AccountingEntryTypeDU8\r\n    Type9 : AccountingEntryTypeDU9\r\n    Type10 : AccountingEntryTypeDU10\r\n}\r\n\r\nlet serOptions = JsonSerializerOptions()\r\nserOptions.DefaultIgnoreCondition <- JsonIgnoreCondition.WhenWritingNull\r\nserOptions.PropertyNamingPolicy <- JsonNamingPolicy.CamelCase\r\nserOptions.WriteIndented <- true // not for prod maybe!?\r\nserOptions.Converters.Add(JsonStringEnumConverter())\r\n\r\nlet deserOptions = JsonSerializerOptions()\r\ndeserOptions.PropertyNamingPolicy <- JsonNamingPolicy.CamelCase\r\ndeserOptions.Converters.Add(JsonStringEnumConverter())\r\n\r\n[<SimpleJob (RuntimeMoniker.Net60)>]\r\ntype SerBenchmarks() =\r\n    // [<Params(100, 1000, 10000, 100000, 1000000)>]\r\n    [<Params(1000)>]\r\n    member val size = 0 with get, set\r\n    member val x1: AccountingEntryEnum1 = { \r\n            Id = \"aa\"\r\n            Type = AccountingEntryTypeEnum.Credit \r\n        }    \r\n    member val x5: AccountingEntryEnum5 = { \r\n            Id = \"aa\"\r\n            Type = AccountingEntryTypeEnum.Credit \r\n            Type2 = AccountingEntryTypeEnum2.Credit \r\n            Type3 = AccountingEntryTypeEnum3.Credit \r\n            Type4 = AccountingEntryTypeEnum4.Credit \r\n            Type5 = AccountingEntryTypeEnum5.Credit \r\n        }    \r\n    member val x10 : AccountingEntryEnum10 = { \r\n            Id = \"aa\"\r\n            Type = AccountingEntryTypeEnum.Credit \r\n            Type2 = AccountingEntryTypeEnum2.Credit \r\n            Type3 = AccountingEntryTypeEnum3.Credit \r\n            Type4 = AccountingEntryTypeEnum4.Credit \r\n            Type5 = AccountingEntryTypeEnum5.Credit \r\n            Type6 = AccountingEntryTypeEnum6.Credit \r\n            Type7 = AccountingEntryTypeEnum7.Credit \r\n            Type8 = AccountingEntryTypeEnum8.Credit \r\n            Type9 = AccountingEntryTypeEnum9.Credit \r\n            Type10 = AccountingEntryTypeEnum10.Credit \r\n        }   \r\n\r\n    [<Benchmark>]\r\n    member this.Enum1 () = \r\n        JsonSerializer.Serialize(this.x1, serOptions)\r\n\r\n    [<Benchmark>]\r\n    member this.DU1 () = \r\n        JsonSerializer.Serialize(this.x1, serOptions)\r\n\r\n    [<Benchmark>]\r\n    member this.Enum5 () = \r\n        JsonSerializer.Serialize(this.x5, serOptions)\r\n\r\n    [<Benchmark>]\r\n    member this.DU5 () = \r\n        JsonSerializer.Serialize(this.x5, serOptions)\r\n\r\n    [<Benchmark>]\r\n    member this.Enum10 () = \r\n        JsonSerializer.Serialize(this.x5, serOptions)\r\n\r\n    [<Benchmark>]\r\n    member this.DU10 () = \r\n        JsonSerializer.Serialize(this.x5, serOptions)\r\n\r\nBenchmarkRunner.Run<SerBenchmarks>() |> ignore\r\n\r\n\r\n[<SimpleJob (RuntimeMoniker.Net60)>]\r\ntype DeserBenchmarks() =\r\n    // [<Params(100, 1000, 10000, 100000, 1000000)>]\r\n    [<Params(1000)>]\r\n    member val size = 0 with get, set\r\n\r\n    member val xs1 : string = \"\"\"{\r\n    \"id\": \"aa\",\r\n    \"type\": \"Credit\"\r\n}\"\"\"\r\n    member val xs5 : string = \"\"\"{\r\n    \"id\": \"aa\",\r\n    \"type\": \"Credit\",\r\n    \"type2\": \"Credit\",\r\n    \"type3\": \"Credit\",\r\n    \"type4\": \"Credit\",\r\n    \"type5\": \"Credit\"\r\n}\"\"\"\r\n    member val xs10 : string = \"\"\"{\r\n    \"id\": \"aa\",\r\n    \"type\": \"Credit\",\r\n    \"type2\": \"Credit\",\r\n    \"type3\": \"Credit\",\r\n    \"type4\": \"Credit\",\r\n    \"type5\": \"Credit\",\r\n    \"type6\": \"Credit\",\r\n    \"type7\": \"Credit\",\r\n    \"type8\": \"Credit\",\r\n    \"type9\": \"Credit\",\r\n    \"type10\": \"Credit\"\r\n}\"\"\"\r\n\r\n    [<Benchmark>]\r\n    member this.Enum1 () = \r\n        JsonSerializer.Deserialize<AccountingEntryEnum1>(this.xs1, deserOptions)\r\n\r\n    [<Benchmark>]\r\n    member this.DU1 () = \r\n        JsonSerializer.Deserialize<AccountingEntryDU1>(this.xs1, deserOptions)\r\n\r\n    [<Benchmark>]\r\n    member this.Enum5 () = \r\n        JsonSerializer.Deserialize<AccountingEntryEnum5>(this.xs5, deserOptions)\r\n\r\n    [<Benchmark>]\r\n    member this.DU5 () = \r\n        JsonSerializer.Deserialize<AccountingEntryDU5>(this.xs5, deserOptions)\r\n\r\n    [<Benchmark>]\r\n    member this.Enum10 () = \r\n        JsonSerializer.Deserialize<AccountingEntryEnum10>(this.xs10, deserOptions)\r\n\r\n    [<Benchmark>]\r\n    member this.DU10 () = \r\n        JsonSerializer.Deserialize<AccountingEntryDU10>(this.xs10, deserOptions)\r\n\r\n\r\nBenchmarkRunner.Run<DeserBenchmarks>() |> ignore\r\n\r\n\r\n```\r\n\r\n\r\n[^1] Error\r\n```\r\nSystem.IO.FileLoadException: Could not load file or assembly 'FsCodec.SystemTextJson, Version=2.0.0.0, Culture=neutral, PublicKeyToken=null'. Operation is not supported. (0x80131515)\r\nFile name: 'FsCodec.SystemTextJson, Version=2.0.0.0, Culture=neutral, PublicKeyToken=null'\r\n ---> System.NotSupportedException: The invoked member is not supported in a dynamic assembly.\r\n   at System.Reflection.Emit.InternalAssemblyBuilder.get_Location()\r\n   at System.Reflection.Assembly.LoadFromResolveHandler(Object sender, ResolveEventArgs args)\r\n   at System.Runtime.Loader.AssemblyLoadContext.InvokeResolveEvent(ResolveEventHandler eventHandler, RuntimeAssembly assembly, String name)\r\n   at System.Runtime.Loader.AssemblyLoadContext.OnAssemblyResolve(RuntimeAssembly assembly, String assemblyFullName)\r\n   at System.Reflection.CustomAttribute._CreateCaObject(RuntimeModule pModule, RuntimeType type, IRuntimeMethodInfo pCtor, Byte** ppBlob, Byte* pEndBlob, Int32* pcNamedArgs)\r\n   at System.Reflection.CustomAttribute.CreateCaObject(RuntimeModule module, RuntimeType type, IRuntimeMethodInfo ctor, IntPtr& blob, IntPtr blobEnd, Int32& namedArgs)\r\n   at System.Reflection.CustomAttribute.AddCustomAttributes(ListBuilder`1& attributes, RuntimeModule decoratedModule, Int32 decoratedMetadataToken, RuntimeType attributeFilterType, Boolean mustBeInheritable, ListBuilder`1 derivedAttributes)\r\n   at System.Reflection.CustomAttribute.GetCustomAttributes(RuntimeModule decoratedModule, Int32 decoratedMetadataToken, Int32 pcaCount, RuntimeType attributeFilterType)\r\n   at System.Reflection.CustomAttribute.GetCustomAttributes(RuntimeType type, RuntimeType caType, Boolean inherit)\r\n   at System.RuntimeType.GetCustomAttributes(Type attributeType, Boolean inherit)\r\n   at System.Text.Json.JsonSerializerOptions.GetConverterInternal(Type typeToConvert)\r\n   at System.Text.Json.JsonSerializerOptions.DetermineConverter(Type parentClassType, Type runtimePropertyType, MemberInfo memberInfo)\r\n   at System.Text.Json.Serialization.Metadata.JsonTypeInfo.GetConverter(Type type, Type parentClassType, MemberInfo memberInfo, Type& runtimeType, JsonSerializerOptions options)\r\n   at System.Text.Json.Serialization.Metadata.JsonTypeInfo.AddProperty(MemberInfo memberInfo, Type memberType, Type parentClassType, Boolean isVirtual, Nullable`1 parentTypeNumberHandling, JsonSerializerOptions options)\r\n   at System.Text.Json.Serialization.Metadata.JsonTypeInfo.CacheMember(Type declaringType, Type memberType, MemberInfo memberInfo, Boolean isVirtual, Nullable`1 typeNumberHandling, Boolean& propertyOrderSpecified, Dictionary`2& ignoredMembers)\r\n   at System.Text.Json.Serialization.Metadata.JsonTypeInfo..ctor(Type type, JsonConverter converter, Type runtimeType, JsonSerializerOptions options)\r\n   at System.Text.Json.JsonSerializerOptions.<InitializeForReflectionSerializer>g__CreateJsonTypeInfo|112_0(Type type, JsonSerializerOptions options)\r\n   at System.Text.Json.JsonSerializerOptions.GetClassFromContextOrCreate(Type type)\r\n   at System.Text.Json.JsonSerializerOptions.GetOrAddClass(Type type)\r\n   at System.Text.Json.JsonSerializer.GetTypeInfo(JsonSerializerOptions options, Type runtimeType)\r\n   at System.Text.Json.JsonSerializer.Serialize[TValue](TValue value, JsonSerializerOptions options)\r\n   at <StartupCode$FSI_0003>.$FSI_0003.main@()\r\nStopped due to error\r\n```",
          "createdAt": "2022-01-27T12:22:23Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-01-27T12:22:23Z",
          "id": "IC_kwDODI9FZc48_A2A"
        },
        {
          "author": "bartelink",
          "body": "I can't see anything blatantly wrong; note the `memoize` in the code I linked does mean that the reflection will only happen once per type.\r\n\r\nOne thing though: doing `-c Release` and/or otherwise turning on all optimizations is important for microbenchmarking\r\n\r\nOne other thing to look at might be `[<Struct>]` DUs - that'll remove some allocations as it will allow the values to be embedded in the object as `enum` values would be\r\n\r\nThe other thing is that for the DU cases, you could use Options without the `JsonStringEnumConverter` in the mix (but that won't win much as these sorts of things are cached in STJ)",
          "createdAt": "2022-01-27T12:36:53Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-01-27T12:36:53Z",
          "id": "IC_kwDODI9FZc48_D8w"
        },
        {
          "author": "deyanp",
          "body": "@bartelink, I did run with the stuff with `sudo dotnet run -c Release` (without sudo BencharkDotNet was complaing about sth). \r\n\r\nI will re-run with `[<Struct>]` slapped on top of all DUs, thanks!\r\n\r\nOne question - I assume there is no other (centralized) way but having this attribute on all DUs, right? \r\n\r\n`[<JsonConverter(typeof<TypeSafeEnumConverter<AccountingEntryTypeDU10>>)>]`\r\n\r\n\r\nEven the type must be specified (it seems that is in contrast to NewtonSoft.Json) ...\r\nI was hoping for something like this and without all these attributes:\r\n\r\n`serOptions.Converters.Add(JsonConverter(typeof<TypeSafeEnumConverter<_>>))`\r\n\r\nbut I guess that is not possible?\r\n",
          "createdAt": "2022-01-27T12:45:01Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-01-27T12:45:20Z",
          "id": "IC_kwDODI9FZc48_FND"
        },
        {
          "author": "bartelink",
          "body": "Re Debug stuff, I see \r\n\r\n`[Host]   : .NET 6.0.1 (6.0.121.56705), X64 RyuJIT DEBUG`\r\n\r\n>One question - I assume there is no other (centralized) way but having this attribute on all DUs, right?\r\n\r\nThere's a [factory in FsCodec](https://github.com/jet/FsCodec/blob/master/src/FsCodec.SystemTextJson/UnionOrTypeSafeEnumConverterFactory.fs#L9) that enables this via the `FsCodec.SystemTextJson.Options` ctor: https://github.com/jet/FsCodec/blob/master/src/FsCodec.SystemTextJson/Options.fs#L53-L60\r\n\r\nNote that this also switches on the automatic application of `UnionConverter` too, which may not be to your taste - would accept a PR to have separate autoUnion and autoTypeSafeEnum options, with the latter only opting into Tye Safe Enums with no values",
          "createdAt": "2022-01-27T13:07:16Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-01-27T13:07:16Z",
          "id": "IC_kwDODI9FZc48_JiJ"
        },
        {
          "author": "deyanp",
          "body": "@bartelink , there was actually an error in my benchmarks, I was comparing Enum Serilization to Enum Serialization ;)\r\n\r\n\"Correct\" results (until proven otherwise):\r\n\r\n**Serialization** - I see **10-50%** overhead of DUs compared to Enums ...\r\n![image](https://user-images.githubusercontent.com/25847560/151582714-220c5d16-6906-4756-870d-e147c5136aa5.png)\r\n\r\n**Deserialization** - I see 5-10% overhead of DUs compared to Enums ... \r\n![image](https://user-images.githubusercontent.com/25847560/151581161-280ff3f2-c564-4d9b-8e52-c37e035b545c.png)\r\n\r\nThis `[Host] : .NET 6.0.1 (6.0.121.56705), X64 RyuJIT DEBUG` I do not know how to eliminate, I am running `sudo dotnet run -c Release` ... I even put `<Optimize>true</Optimize>` tag in fsproj, but I don't know of anything else causing this Debug Host ...\r\n\r\nFor `autoTypeSafeEnum` I would need to split/duplicate the `UnionOrTypeSafeEnumConverterFactory` as well though - is this what you suggested?\r\n",
          "createdAt": "2022-01-28T16:17:47Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-01-28T18:20:18Z",
                "user": "adelarsq"
              },
              {
                "content": "HEART",
                "createdAt": "2022-01-28T18:20:49Z",
                "user": "adelarsq"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-02-03T11:04:55Z",
                "user": "bartelink"
              }
            ],
            "totalCount": 3,
            "endCursor": "Y3Vyc29yOnYyOpHOCM5V8Q=="
          },
          "updatedAt": "2022-01-28T16:17:47Z",
          "id": "IC_kwDODI9FZc49Dq7C"
        },
        {
          "author": "bartelink",
          "body": "Ah; cool you found the discrepancy ;) I'm sure the perf can be improved, but I guess its not bad as it is.\r\n\r\n>or autoTypeSafeEnum I would need to split/duplicate the UnionOrTypeSafeEnumConverterFactory as well though - is this what you suggested?\r\n\r\nSee [the issue I wrote about this](https://github.com/jet/FsCodec/issues/71) (I originally assumed this issue was in the FsCodec repo when I responded to your first question; best to take this off to the side!)\r\n\r\n(ASIDE: I'd love to know if there are any outline plans/designs for how any prospective support in .NET 7 might work out - I'd like to align with that if at all possible)",
          "createdAt": "2022-01-28T16:35:21Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "EYES",
                "createdAt": "2022-01-28T18:20:03Z",
                "user": "adelarsq"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOCMGy0w=="
          },
          "updatedAt": "2022-01-28T16:58:31Z",
          "id": "IC_kwDODI9FZc49DwTS"
        },
        {
          "author": "eiriktsarpalis",
          "body": ">  I'd love to know if there are any outline plans/designs for how any prospective support in .NET 7 might work out\r\n\r\nNo concrete plans for the moment (it's not clear we'll have the bandwidth to pull it off in time for 7). Ideally though it should be possible to build it on top of the infrastructure to be introduced by #63747.",
          "createdAt": "2022-02-03T10:57:33Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-02-03T11:04:22Z",
                "user": "bartelink"
              },
              {
                "content": "CONFUSED",
                "createdAt": "2022-02-04T12:13:34Z",
                "user": "deyanp"
              },
              {
                "content": "CONFUSED",
                "createdAt": "2022-02-08T17:03:32Z",
                "user": "adelarsq"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-02-08T17:03:33Z",
                "user": "adelarsq"
              },
              {
                "content": "EYES",
                "createdAt": "2022-02-08T17:03:36Z",
                "user": "adelarsq"
              }
            ],
            "totalCount": 5,
            "endCursor": "Y3Vyc29yOnYyOpHOCNpj2g=="
          },
          "updatedAt": "2022-02-03T10:57:33Z",
          "id": "IC_kwDODI9FZc49Uztn"
        },
        {
          "author": "eiriktsarpalis",
          "body": "I had initially hoped that it would be possible to implement support for unions using the infrastructure from polymorphism (#63747), however on closer inspection of F# union codegen, it turns out that this is not as simple as I had originally thought for a number of reasons:\r\n\r\n* Derived union case types do not expose public constructors but use static factory methods or singletons in the base union type declaration instead. These cannot be recognized automatically by the STJ contract model.\r\n* Enum-like unions don't use derived types at all, instead relying on the value of the `Tag` property solely.\r\n* An approach based on .NET type polymorphism necessarily leaves struct unions without support.\r\n\r\nBased on the above, there appear to be two possible approaches we could follow if we decide to implement support for unions in the future:\r\n\r\n1. Implement union serialization using a custom converter. This is how Json.NET does it, but notably this is expensive to implement in STJ if we want to support all STJ features like async serialization (a functionally correct implementation would need to replicate the implementation of the [internal object converter](https://github.com/dotnet/runtime/blob/main/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/Converters/Object/ObjectDefaultConverter.cs)). I don't think we should follow this approach, since it wouldn't be feasible to keep features in sync and fully tested.\r\n2. Use the contract customization model (proposed in #63686). It might be possible support union deserialization using a [customized parameterized constructor delegate](https://github.com/dotnet/runtime/issues/63686#issuecomment-1110990139) that instantiates the correct union case based on tag metadata. Prototyping is necessary to evaluate feasibility.",
          "createdAt": "2022-05-05T15:42:15Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-05-05T20:05:13Z",
                "user": "bartelink"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-05-06T01:46:35Z",
                "user": "adelarsq"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-02-19T03:49:49Z",
                "user": "brianrourkeboll"
              }
            ],
            "totalCount": 3,
            "endCursor": "Y3Vyc29yOnYyOpHOC2Vlrg=="
          },
          "updatedAt": "2022-05-05T15:43:23Z",
          "id": "IC_kwDODI9FZc5Crkvg"
        },
        {
          "author": "KenBonny",
          "body": "Is this still being investigated and worked on? As I'm quite interested in seeing STJ support F# DU's.",
          "createdAt": "2024-02-14T08:06:54Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-04-02T19:56:49Z",
                "user": "YkTru"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHODcwHhw=="
          },
          "updatedAt": "2024-02-14T08:06:54Z",
          "id": "IC_kwDODI9FZc5z07x2"
        },
        {
          "author": "eiriktsarpalis",
          "body": "It is not being worked on currently. We will update this issue as soon as something changes.",
          "createdAt": "2024-02-14T09:55:39Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "CONFUSED",
                "createdAt": "2024-02-14T10:45:25Z",
                "user": "KenBonny"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-02-14T18:33:24Z",
                "user": "adelarsq"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-02-16T03:05:09Z",
                "user": "UnstoppableMango"
              }
            ],
            "totalCount": 3,
            "endCursor": "Y3Vyc29yOnYyOpHODW-m1A=="
          },
          "updatedAt": "2024-02-14T09:55:39Z",
          "id": "IC_kwDODI9FZc5z1kHi"
        },
        {
          "author": "YkTru",
          "body": "@eiriktsarpalis \r\n\r\n1- Do you think it will ever be possible? I mean, should we keep hope or do all by hand?\r\n\r\n2- While waiting: Would you recommend Wlaschin DTO approach?\r\n\r\n2a- Else what would be your recommend, preferred approach in most cases?\r\n\r\nThank you",
          "createdAt": "2024-04-02T20:00:09Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-04-02T20:00:09Z",
          "id": "IC_kwDODI9FZc55LQ_o"
        },
        {
          "author": "bartelink",
          "body": "@YkTru why do it by hand when there are two perfectly viable answers to 2a:\r\n- https://github.com/jet/FsCodec/blob/master/src/FsCodec.SystemTextJson/UnionConverter.fs[ is on nuget (recently turned v3).](https://www.nuget.org/packages/FsCodec.SystemTextJson/) (I maintain it, though I'm not the original author - it has thorough tests etc and just works)\r\n- it relies on some pieces in https://github.com/jet/FsCodec/blob/master/src/FsCodec/Union.fs) and should have reasonable perf; those two files together could be taken and just work if you don't want to take a dependency on a package.\r\n- [`FSharp.SystemTextJson`](https://github.com/Tarmil/FSharp.SystemTextJson) has a dramatically more complete implementation that has every conceivable rendition format (its a much larger project though)",
          "createdAt": "2024-04-02T20:31:17Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-04-02T21:15:04Z",
                "user": "eiriktsarpalis"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-04-23T17:27:17Z",
                "user": "YkTru"
              }
            ],
            "totalCount": 2,
            "endCursor": "Y3Vyc29yOnYyOpHODfRAxw=="
          },
          "updatedAt": "2024-04-02T20:31:17Z",
          "id": "IC_kwDODI9FZc55Lbd0"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Using a third-party option is perfectly fine. One thing to note about any custom converter is that it necessarily loses the ability to do streaming serialization (only because streaming converters are internal for now). \r\n\r\nIn other words, attempting to serialize something large like\r\n```F#\r\ntype MyUnion = | Values of int []\r\n\r\nJsonSerializer.SerializeAsync(stream, Values [1 .. 1_000_000])\r\n```\r\nwould necessarily result in the entire payload being buffered by the serializer. That shouldn't matter much as long as you're restricted to small-ish values.",
          "createdAt": "2024-04-02T21:18:34Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-04-02T21:18:34Z",
          "id": "IC_kwDODI9FZc55LuiT"
        },
        {
          "author": "rynoV",
          "body": "It seems like using a third-party option is the current recommendation for F# discriminated unions with STJ, so I wanted to bring up a potential area for improvement on the first-party side to make that work better:\n\n### Problem\n\nWhen passing a discriminated union value **with `object` type** to `JsonSerializer.Serialize`, `JsonConverter` attributes (e.g. `UnionConverter` from `FsCodec`) on F# discriminated unions won't be resolved, and it will fail with `System.NotSupportedException: F# discriminated union serialization is not supported.`\n \n### Affected areas\n\nThis situation occurs unavoidably in ASP.NET (see https://github.com/dotnet/aspnetcore/issues/51481 which was closed deferring to this issue) and [SignalR](https://github.com/dotnet/aspnetcore/blob/c946659badd12f1a632bce7d7309b3dc4dc1275f/src/SignalR/common/Protocols.Json/src/Protocol/JsonHubProtocol.cs#L917).\n\n### Cause\n\nThe issue seems to be that [`GetType` is used](https://github.com/dotnet/runtime/blob/696c8b07e3dd5a37096d0c7e8104352f85f0cc0e/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/JsonSerializerOptions.Caching.cs#L169) to resolve the converter for the DU value, and for a DU instantiation, `GetType` returns the internal generated subclass for that case, and so the `JsonConverter` attribute registered on the base class is not picked up.\n\n### Potential fix\n\nIt seems like it would be possible to fix this in STJ by adding a special case for F# discriminated union instances to resolve their type info using the base class. It doesn't seem like resolving type info for the generated subclasses makes sense because the user has no control over these (also meaning it shouldn't be a breaking change?).\n\nRelated issue in FsCodec which discusses a workaround: https://github.com/jet/FsCodec/issues/128",
          "createdAt": "2025-04-11T20:57:29Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-04-14T15:09:51Z",
          "id": "IC_kwDODI9FZc6mxhBJ"
        },
        {
          "author": "kerams",
          "body": "> Users would still be able to use [available custom converters](https://github.com/Tarmil/FSharp.SystemTextJson/)\n\nThe problem with this is that while FSTJ `JsonSerializerOptions` with the source generated serialization context assigned to the `TypeInfoResolver` property appears to work with `JsonSerializerIsReflectionEnabledByDefault` disabled, reflection is still used under the hood and there's no AOT-compatiblity, no?\n\n```\nerror IL2026: Using member 'System.Text.Json.JsonSerializer.Serialize<TValue>(TValue, JsonSerializerOptions)' which has 'RequiresUnreferencedCodeAttribute' can break functionality when trimming application code. JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.\n```\n\nwould suggest that.",
          "createdAt": "2025-05-09T11:10:33Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-05-19T07:54:36Z",
                "user": "JoostVanVelthoven"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOESmFkg=="
          },
          "updatedAt": "2025-05-10T13:37:33Z",
          "id": "IC_kwDODI9FZc6q1fx9"
        }
      ],
      "totalCount": 24,
      "endCursor": "Y3Vyc29yOnYyOpHOqtX8fQ=="
    },
    "url": "https://github.com/dotnet/runtime/issues/55744",
    "title": "System.Text.Json : Consider supporting F# discriminated unions"
  },
  {
    "author": "Georgiks",
    "labels": [
      "bug",
      "area-System.Text.Json",
      "Priority:3"
    ],
    "createdAt": "2021-07-23T13:22:47Z",
    "body": "### Description\r\nWith given code\r\n```cs\r\npublic class PrivateGetter<T>\r\n{\r\n    public T Property { private get; set; }\r\n\r\n    public override string ToString()\r\n    {\r\n        return Property is null ? \"null\" : Property.ToString();\r\n    }\r\n}\r\n\r\npublic class PublicGetter<T>\r\n{\r\n    public T Property { get; set; }\r\n\r\n    public override string ToString()\r\n    {\r\n        return Property is null ? \"null\" : Property.ToString();\r\n    }\r\n}\r\n```\r\n```cs\r\nvar jsonListOfInts = @\"\r\n{\r\n    \"\"Property\"\": [ 1 ]\r\n}\r\n\";\r\n\r\nvar jsonInt = @\"\r\n{\r\n    \"\"Property\"\": 1\r\n}\r\n\";\r\nConsole.WriteLine(JsonSerializer.Deserialize<PrivateGetter<List<int>>>(jsonListOfInts));\r\nConsole.WriteLine(JsonSerializer.Deserialize<PublicGetter<List<int>>>(jsonListOfInts));\r\n\r\nConsole.WriteLine(JsonSerializer.Deserialize<PrivateGetter<int>>(jsonInt));\r\nConsole.WriteLine(JsonSerializer.Deserialize<PublicGetter<int>>(jsonInt));\r\n```\r\nOutput:\r\n```\r\nnull\r\nSystem.Collections.Generic.List`1[System.Int32]\r\n1\r\n1\r\n```\r\nWhen deserializing a JSON with a `List<>` property with a non-public getter, the value is not deserialized and property is `null`.\r\nHowever when serializing and `int` the same way, a value of `1` is (correctly) assigned.\r\nI expect that the behaviour of deserializing into property with non-public getter is independent of the property type.\r\n\r\nUnfortunatelly the documentation site [https://docs.microsoft.com/en-us/dotnet/standard/serialization/system-text-json-immutability](url) does not specify whether the behaviour is to allow deserializing into property without public getter or not, therefore it is hard to guess whether the case with `int` is wrong or the `List<>` one.\r\n\r\n\r\n### Configuration\r\n\r\n.NET Core 3.1\r\n\r\n### Regression?\r\n\r\n### Other information\r\n\r\n",
    "number": 56212,
    "reactions": {
      "hasNextPage": false,
      "nodes": [],
      "totalCount": 0,
      "endCursor": null
    },
    "updatedAt": "2025-01-17T12:11:05Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @eiriktsarpalis, @layomia\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\n### Description\r\nWith given code\r\n```cs\r\npublic class PrivateGetter<T>\r\n{\r\n    public T Property { private get; set; }\r\n\r\n    public override string ToString()\r\n    {\r\n        return Property is null ? \"null\" : Property.ToString();\r\n    }\r\n}\r\n\r\npublic class PublicGetter<T>\r\n{\r\n    public T Property { get; set; }\r\n\r\n    public override string ToString()\r\n    {\r\n        return Property is null ? \"null\" : Property.ToString();\r\n    }\r\n}\r\n```\r\n```cs\r\nvar jsonListOfInts = @\"\r\n{\r\n    \"\"Property\"\": [ 1 ]\r\n}\r\n\";\r\n\r\nvar jsonInt = @\"\r\n{\r\n    \"\"Property\"\": 1\r\n}\r\n\";\r\nConsole.WriteLine(JsonSerializer.Deserialize<PrivateGetter<List<int>>>(jsonListOfInts));\r\nConsole.WriteLine(JsonSerializer.Deserialize<PublicGetter<List<int>>>(jsonListOfInts));\r\n\r\nConsole.WriteLine(JsonSerializer.Deserialize<PrivateGetter<int>>(jsonInt));\r\nConsole.WriteLine(JsonSerializer.Deserialize<PublicGetter<int>>(jsonInt));\r\n```\r\nOutput:\r\n```\r\nnull\r\nSystem.Collections.Generic.List`1[System.Int32]\r\n1\r\n1\r\n```\r\nWhen deserializing a JSON with a `List<>` property with private getter, the value is not deserialized and property is `null`.\r\nHowever when serializing and `int` the same way, a value of `1` is correctly assigned.\r\nI expect that the behaviour of deserializing into property with non-public getter is independent on the property type.\r\n\r\nUnfortunatelly the documentation site [https://docs.microsoft.com/en-us/dotnet/standard/serialization/system-text-json-immutability](url) does not specify whether the behaviour is to allow deserializing into property without public getter or not, therefore it is hard to guess whether the case with `int` is wrong or the `List<>` one.\r\n\r\n\r\n### Configuration\r\n\r\n.NET Core 3.1\r\n\r\n### Regression?\r\n\r\n### Other information\r\n\r\n\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>Georgiks</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`area-System.Text.Json`, `untriaged`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2021-07-23T13:22:53Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-07-23T13:22:53Z",
          "id": "IC_kwDODI9FZc40ybrx"
        },
        {
          "author": "eiriktsarpalis",
          "body": "I can reproduce -- the issue is certainly surprising although I was able to force deserialization for the List case by attaching a [`JsonInclude` attribute](https://docs.microsoft.com/en-us/dotnet/api/system.text.json.serialization.jsonincludeattribute?view=net-5.0) to the property.\r\n\r\nThat being said, the private getter/public setter combination is unusual, and we generally recommend against using it. We should still fix this and ensure relevant test coverage is added for that particular combination.",
          "createdAt": "2021-07-23T19:54:20Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-07-23T19:54:45Z",
          "id": "IC_kwDODI9FZc40zXVw"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Doing a bit more digging -- the root cause appears to be [this method](https://github.com/dotnet/runtime/blob/141bd34eaf70518a7b6a4520e68624e8703529f6/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/Metadata/JsonPropertyInfo.cs#L130) which seems to applying different logic depending on whether the property type is a collection or not.  Not sure why though, I couldn't find any comments justifying the split.\r\n\r\n@layomia is this by design? should we be making the change to support setter-only deserialization?",
          "createdAt": "2021-07-28T16:29:47Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-07-28T16:29:47Z",
          "id": "IC_kwDODI9FZc409KpK"
        },
        {
          "author": "eiriktsarpalis",
          "body": "We seem to have a test that validates the behavior as reported: https://github.com/dotnet/runtime/blob/ec2d25c03fb91d8897277f2b732b71f903b87b1a/src/libraries/System.Text.Json/tests/Common/PropertyVisibilityTests.cs#L1003-L1013\r\nand for value types:\r\nhttps://github.com/dotnet/runtime/blob/ec2d25c03fb91d8897277f2b732b71f903b87b1a/src/libraries/System.Text.Json/tests/Common/PropertyVisibilityTests.NonPublicAccessors.cs#L25-L26\r\nAgain, I don't have context as to why we're doing this, but likely we're closing this as by-design behavior.",
          "createdAt": "2021-07-28T16:46:28Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-07-28T18:16:32Z",
          "id": "IC_kwDODI9FZc409NWb"
        },
        {
          "author": "Georgiks",
          "body": "Understood, thanks anyway.",
          "createdAt": "2021-07-28T17:00:00Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-07-28T17:00:00Z",
          "id": "IC_kwDODI9FZc409Pob"
        },
        {
          "author": "eiriktsarpalis",
          "body": "After private discussion with @layomia we have concluded that we should change the [`DetermineSerializationCapabilities`](https://github.com/dotnet/runtime/blob/141bd34eaf70518a7b6a4520e68624e8703529f6/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/Metadata/JsonPropertyInfo.cs#L130) method to not distinguish between collection and object/value converters. \r\n\r\nThat being said, it is a fix that probably doesn't meet the bug bar for RC1 since a) it affects a relatively rare corner case and b) it can be easily worked around by adding a `JsonInclude` attribute to the property. Making changes here carries a nonzero probability of introducing unanticipated breaks, so I'm moving this to `7.0.0`.",
          "createdAt": "2021-07-28T18:14:47Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-07-28T18:14:47Z",
          "id": "IC_kwDODI9FZc409bYS"
        },
        {
          "author": "dvdvorle",
          "body": "Just documenting a real-life use case here to make sure this makes it into `7.0.0`\r\n\r\nI'm using a write-only property for refactoring purposes such as property renames and the like, where the object is persisted as json.\r\n\r\n``` C#\r\n[Obsolete(\"Don't use this, only for data-migration purposes.\")]\r\npublic List<EnvironmentHistoryItem> EnvironmentHistory\r\n{\r\n  set => EnvironmentHistoryV2 = new EnvironmentHistory { Items = value };\r\n}\r\n\r\npublic EnvironmentHistory EnvironmentHistoryV2 { get; set; } = new EnvironmentHistory();\r\n```\r\n\r\nI didn't expect this bug, took me a couple of hours to find it (and this github issue), and Newtonsoft also deserializes this correctly.\r\n\r\nThe `JsonInclude` workaround only applies if you have a private getter btw, if you have no getter at all it won't work, even with the `JsonInclude` attribute.",
          "createdAt": "2021-12-08T19:10:27Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-12-08T19:14:20Z",
          "id": "IC_kwDODI9FZc469Lsy"
        },
        {
          "author": "eiriktsarpalis",
          "body": "We won't have time to work on this for .NET 7, moving to Future.",
          "createdAt": "2022-05-10T16:57:54Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "CONFUSED",
                "createdAt": "2022-05-10T22:38:10Z",
                "user": "dvdvorle"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOCcKKLQ=="
          },
          "updatedAt": "2022-05-10T16:58:07Z",
          "id": "IC_kwDODI9FZc5C6jro"
        },
        {
          "author": "eiriktsarpalis",
          "body": "FWIW we passed an opportunity to fix [this behavior](https://github.com/dotnet/runtime/issues/56212#issuecomment-888518162) when refactoring for .NET 7 work. Even though the current behavior is inconsistent, we felt it would be too much of breaking change to justify fixing. We might revisit in the future assuming there is demand.",
          "createdAt": "2022-09-02T15:01:41Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-09-02T15:01:41Z",
          "id": "IC_kwDODI9FZc5Jpd29"
        },
        {
          "author": "layomia",
          "body": "This overlaps with feature https://github.com/dotnet/runtime/issues/78556. The major scenario for modifying/populating properties (rather than replacing them with new instances) is for collections. FYI @krwq.",
          "createdAt": "2022-12-02T18:24:05Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-12-02T18:24:05Z",
          "id": "IC_kwDODI9FZc5PnGdR"
        }
      ],
      "totalCount": 10,
      "endCursor": "Y3Vyc29yOnYyOpHOT5xnUQ=="
    },
    "url": "https://github.com/dotnet/runtime/issues/56212",
    "title": "JsonConverter inconsistency when deserializing into property without public getter"
  },
  {
    "author": "kimbell",
    "labels": [
      "api-needs-work",
      "area-System.Text.Json",
      "wishlist"
    ],
    "createdAt": "2021-08-07T14:57:35Z",
    "body": "Over the last couple of years I've been involved in building infrastructure code for a number of internal services; make it easier and consistent to set things up. One of the areas we configure is Json serialization; indentation, customer converts, enums as strings, etc. We also use Swashbuckle on the server to generate Open API contracts, and NSwag to generate strongly typed clients. \r\n\r\nOne of the trickier challenges is how to handle enums; they are great in code, but not so great in API contracts. What happens when you add another possible value? Unless the client has been updated, it will crash since it doesn't recognize the value; this seems to be the approach taken by Newtonsoft and STJ. \r\n\r\nThe way we have worked around this is by implementing a Swashbuckle DocumentFilter that looks for enum information. When we find it, we remove it and update the comment with the possible range of values. Clients then work with magical strings, and they can see in the documentation what values are possible. How to deal with unknowns becomes a case-by-case issue. \r\n\r\nThis solution works, but is not very elegant; easy to misspell these magical strings. \r\n\r\nLately I've been digging into the converter infrastructure for both Newtonsoft and STJ to see if there is a way to improve things. I could write custom converters, but that would end up duplicating a lot of the code that is already in the existing JsonStringEnumConverter. Not something I would like to do. \r\n\r\nI can envision a number or possible options for handling unknown enum values\r\n- Crash as things do today\r\n- If it's a nullable property, assign null\r\n- Assign a predetermined value selected by the developer; this could be something like NotSet or Unknown\r\n\r\nThe two last options allows the application to detect missing information rather than responding to a Json serialization exception. What the application actually does will depend on the scenario. It could ignore it, set a default value, or tell the user to upgrade their client to use this functionality.\r\n\r\nMy preferred option would be to specify this type of information using attributes or via the general serialization options object. This will probably have some impact on performance, so it should be opt-in. If this is not possible, it would be nice to have the building blocks to feasibly handle it ourselves. I gather there are some changes coming in the converter infrastructure, but looking at the STJ code, most things are internal. The EnumConverter is currently over 400 lines; if we decided to roll our own, it would be nice if we could end up with something a lot less.",
    "number": 57031,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-08-15T08:47:15Z",
          "user": "Varorbc"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-05-25T02:17:18Z",
          "user": "austinw-fineart"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-09-28T07:42:36Z",
          "user": "Vlad-Zaytsev"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-01-12T14:21:21Z",
          "user": "AoshiW"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-08-11T12:12:10Z",
          "user": "timaiv"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-08-12T11:17:30Z",
          "user": "yaroslavlsd"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-12-20T13:14:01Z",
          "user": "gagabu"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-02-26T07:56:07Z",
          "user": "nicolasdarras"
        }
      ],
      "totalCount": 8,
      "endCursor": "Y3Vyc29yOnYyOpHOC_e0jQ=="
    },
    "updatedAt": "2025-06-18T09:30:19Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "I couldn't figure out the best area label to add to this issue. If you have write-permissions please help me learn by adding exactly one [area label](https://github.com/dotnet/runtime/blob/master/docs/area-owners.md).",
          "createdAt": "2021-08-07T14:57:37Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-08-07T14:57:37Z",
          "id": "IC_kwDODI9FZc41U4GO"
        },
        {
          "author": null,
          "body": "Tagging subscribers to this area: @eiriktsarpalis, @layomia\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\nOver the last couple of years I've been involved in building infrastructure code for a number of internal services; make it easier and consistent to set things up. One of the areas we configure is Json serialization; indentation, customer converts, enums as strings, etc. We also use Swashbuckle on the server to generate Open API contracts, and NSwag to generate strongly typed clients. \r\n\r\nOne of the trickier challenges is how to handle enums; they are great in code, but not so great in API contracts. What happens when you add another possible value? Unless the client has been updated, it will crash since it doesn't recognize the value; this seems to be the approach taken by Newtonsoft and STJ. \r\n\r\nThe way we have worked around this is by implementing a Swashbuckle DocumentFilter that looks for enum information. When we find it, we remove it and update the comment with the possible range of values. Clients then work with magical strings, and they can see in the documentation what values are possible. How to deal with unknowns becomes a case-by-case issue. \r\n\r\nThis solution works, but is not very elegant; easy to misspell these magical strings. \r\n\r\nLately I've been digging into the converter infrastructure for both Newtonsoft and STJ to see if there is a way to improve things. I could write custom converters, but that would end up duplicating a lot of the code that is already in the existing JsonStringEnumConverter. Not something I would like to do. \r\n\r\nI can envision a number or possible options for handling unknown enum values\r\n- Crash as things do today\r\n- If it's a nullable property, assign null\r\n- Assign a predetermined value selected by the developer; this could be something like NotSet or Unknown\r\n\r\nThe two last options allows the application to detect missing information rather than responding to a Json serialization exception. What the application actually does will depend on the scenario. It could ignore it, set a default value, or tell the user to upgrade their client to use this functionality.\r\n\r\nMy preferred option would be to specify this type of information using attributes or via the general serialization options object. This will probably have some impact on performance, so it should be opt-in. If this is not possible, it would be nice to have the building blocks to feasibly handle it ourselves. I gather there are some changes coming in the converter infrastructure, but looking at the STJ code, most things are internal. The EnumConverter is currently over 400 lines; if we decided to roll our own, it would be nice if we could end up with something a lot less.\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>kimbell</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`area-System.Text.Json`, `untriaged`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2021-08-07T16:20:41Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-08-07T16:20:41Z",
          "id": "IC_kwDODI9FZc41U6fe"
        },
        {
          "author": "Symbai",
          "body": "#42093 #29167",
          "createdAt": "2021-08-08T00:40:31Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-08-08T00:40:31Z",
          "id": "IC_kwDODI9FZc41VGbG"
        },
        {
          "author": "eiriktsarpalis",
          "body": "> If it's a nullable property, assign null\r\n\r\nUnder the STJ converter model this would not be possible unless specifically authoring a `JsonConverter<TEnum?>` implementation. \r\n\r\n> Assign a predetermined value selected by the developer; this could be something like NotSet or Unknown\r\n\r\nThis would be possible to implement in principle, however the fact that one needs to specify the fallback value means that using a converter factory approach (like `JsonStringEnumConverter` does) would not feasible and we would need to expose a completely separate type instead. In any case, this would require an API proposal.",
          "createdAt": "2021-08-09T12:45:39Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-08-09T12:45:39Z",
          "id": "IC_kwDODI9FZc41W421"
        },
        {
          "author": "klinki",
          "body": "This would be really great, I'm adding one more request for error handling - better exception messages. For classical Model Binding it is handled quite well, but for JSON it is not :(\r\n\r\nLet's compare how these 2 behave when ProblemDetails is used:\r\n\r\nLet's say I have following enum:\r\n\r\n```csharp\r\npublic enum UpdateModeEnum\r\n{\r\n\tNormal = 1,\r\n\tManual = 2,\r\n\tNever = 3,\r\n\tTesting = 4,\r\n}\r\n```\r\n\r\n### JsonConverter\r\nNow, if you use `[FromBody]` with JSON\r\n\r\nMethod:\r\n```csharp\r\n\t[HttpPut(\"{userId}/update-mode\", Name = nameof(SetUpdateModeForUser))]\r\n\tpublic async Task<ActionResult> SetUpdateModeForUser(\r\n\t\t[FromRoute] int userId,\r\n\t\t[FromBody]\r\n\t\tUpdateModeEnum? updateMode\r\n\t)\r\n```\r\n\r\nRequest:\r\n\r\n```json\r\n\"invalid value\"\r\n```\r\n\r\nResponse:\r\n```json\r\n{\r\n  \"type\": \"https://tools.ietf.org/html/rfc9110#section-15.5.1\",\r\n  \"title\": \"One or more validation errors occurred.\",\r\n  \"status\": 400,\r\n  \"errors\": {\r\n    \"$\": [\r\n      \"The JSON value could not be converted to System.Nullable`1[TurkCellLicenseManager.BusinessLogic.Entities.UpdateModeEnum]. Path: $ | LineNumber: 0 | BytePositionInLine: 9.\"\r\n    ]\r\n  },\r\n  \"traceId\": \"00-5c42073ef7601eb72f37b6f5839f2ad1-a9e1762f6c88f5a2-00\"\r\n}\r\n```\r\n\r\n\r\n### And now let's try with Model Binding:\r\n\r\nQuery param: `updateMode=Invalid Value`\r\n\r\nResponse:\r\n```json\r\n{\r\n    \"type\": \"https://tools.ietf.org/html/rfc9110#section-15.5.1\",\r\n    \"title\": \"One or more validation errors occurred.\",\r\n    \"status\": 400,\r\n    \"errors\": {\r\n        \"updateMode\": [\r\n            \"The value 'Invalid Value' is not valid.\"\r\n        ]\r\n    },\r\n    \"traceId\": \"00-9144bc356979323f7dcbba47e2868c94-085b9289516887fb-00\"\r\n}\r\n```\r\n\r\nAs you can see, model binding provides so much nicer error value - it clearly shows invalid parameter name and invalid value. For any consumer this is pretty clear.\r\n\r\nBut for JSON case, it is very consumer unfriendly + it exposes internals (class names).\r\n",
          "createdAt": "2024-01-12T14:13:38Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-01-12T14:13:38Z",
          "id": "IC_kwDODI9FZc5wnLP7"
        },
        {
          "author": "SteveSandersonMS",
          "body": "AI-related use case:\r\n\r\nWhen asking an LLM to return a JSON response in which some of the values will be parsed as an enum, there's no way to guarantee it really restricts itself to the enum values you've told it about. Sometimes it will hallucinate other enum values it thinks might exist. As things stand, that's a fatal error in JSON parsing, so the developer can't access the rest of the output which would otherwise parse correctly.\r\n\r\nOne possible API to handle this: https://github.com/dotnet/eShopSupport/blob/0c1630e06a8467e4cc925239373069138cb2d73d/seeddata/DataGenerator/Generators/TicketSummaryGenerator.cs#L105-L109",
          "createdAt": "2024-06-28T11:05:41Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-09-14T13:09:58Z",
                "user": "taurit"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHODyPYUQ=="
          },
          "updatedAt": "2024-06-28T11:05:41Z",
          "id": "IC_kwDODI9FZc6C7iy6"
        },
        {
          "author": "nfzv",
          "body": "> AI-related use case:\r\n> \r\n> When asking an LLM to return a JSON response in which some of the values will be parsed as an enum, there's no way to guarantee it really restricts itself to the enum values you've told it about. Sometimes it will hallucinate other enum values it thinks might exist. As things stand, that's a fatal error in JSON parsing, so the developer can't access the rest of the output which would otherwise parse correctly.\r\n> \r\n> One possible API to handle this: https://github.com/dotnet/eShopSupport/blob/0c1630e06a8467e4cc925239373069138cb2d73d/seeddata/DataGenerator/Generators/TicketSummaryGenerator.cs#L105-L109\r\n\r\nThe url is obsolete",
          "createdAt": "2024-06-28T12:08:45Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-06-28T12:08:45Z",
          "id": "IC_kwDODI9FZc6C7_gQ"
        },
        {
          "author": "steveharter",
          "body": "Per the [comment above](https://github.com/dotnet/runtime/issues/57031#issuecomment-1889317883), the STJ error is:\r\n> \"The JSON value could not be converted to System.Nullable`1[TurkCellLicenseManager.BusinessLogic.Entities.UpdateModeEnum]. Path: $ | LineNumber: 0 | BytePositionInLine: 9.\"\r\n\r\nand for model binding the error is:\r\n>  \"The value 'Invalid Value' is not valid.\"\r\n\r\nwith the analysis:\r\n> As you can see, model binding provides so much nicer error value - it clearly shows invalid parameter name and invalid value. For any consumer this is pretty clear.\r\n\r\n> But for JSON case, it is very consumer unfriendly + it exposes internals (class names).\r\n\r\nHowever, the analysis is subjective:\r\n- Having an error message with the literal value is not desired - it may contain secrets or other information not meant to be logged. If the value is shown to the end user it could also lead to an injection attack if the value is not properly escaped.\r\n- Exposing the property type name in the error message, in this case `TurkCellLicenseManager.BusinessLogic.Entities.UpdateModeEnum`, is super useful for developers but probably shouldn't be shown to the end user.\r\n- The \"Path:\" part of the STJ error message will identify the property name and any parent property names. In the example there aren't any properties; if there were then the type name can also be determined by inspecting the properties on the class.",
          "createdAt": "2024-07-10T23:27:25Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-07-22T17:47:52Z",
          "id": "IC_kwDODI9FZc6EbG7f"
        },
        {
          "author": "steveharter",
          "body": "> One possible API to handle this: https://github.com/dotnet/eShopSupport/blob/0c1630e06a8467e4cc925239373069138cb2d73d/seeddata/DataGenerator/Generators/TicketSummaryGenerator.cs#L105-L109\r\n\r\n@SteveSandersonMS is this custom converter approach is a valid workaround for V9?\r\n\r\nFor a full solution that includes addressing the features suggested in the original ask of \"It could ignore it, set a default value, or tell the user to upgrade their client to use this functionality.\" consider these strawman requirements:\r\n- Ability to select a value for the default (e.g. zero, null, or specific for each enum type). I think this should be applied to a given enum type and not forced on each property of that type. It could be done via new converter attribute and\\or a new run-time options API of some sort.\r\n- Allow a callback, perhaps by just deriving from the new converter (or the existing string-based one which would have to be unsealed) and overriding a method, to support cases of throwing a custom exception or for logging.\r\n- Consider a general \"defaulting\" feature that would address types other than enums (e.g. for strings).",
          "createdAt": "2024-07-23T18:26:51Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-07-23T21:33:52Z",
          "id": "IC_kwDODI9FZc6F3oyu"
        },
        {
          "author": "Matthew-Davey",
          "body": "> Assign a predetermined value selected by the developer; this could be something like NotSet or Unknown\n\nThis strikes me as being somewhat similar to `NaN` as it relates to float/double. Defining an explicit 'Unknown' value in an enum is not dissimilar to how NaN is represented with reserved bit patterns in System.Single/Double. The serializer already returns NaN/Infinity for values which fall outside the allowable range of floats, returning _'Unknown'_ for values which fall outside the allowable set of enum values would be consistent imo. The tricky part is letting the serializer know that, for this particular enum, there exists a reserved 'Unknown' [sentinel value](https://en.wikipedia.org/wiki/Sentinel_value).\n\nThe major difference is that the reserved patterns which represent NaN/Infinity are [standardized](https://en.wikipedia.org/wiki/IEEE_754) and universally understood - right down to the hardware, whereas `Unknown = 0` is merely a convention.",
          "createdAt": "2025-06-17T12:56:58Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-06-18T09:30:19Z",
          "id": "IC_kwDODI9FZc6xo4SF"
        }
      ],
      "totalCount": 10,
      "endCursor": "Y3Vyc29yOnYyOpHOsaOEhQ=="
    },
    "url": "https://github.com/dotnet/runtime/issues/57031",
    "title": "System.Text.Json: customize handling of unknown enum values in JsonStringEnumConverter"
  },
  {
    "author": "eiriktsarpalis",
    "labels": [
      "bug",
      "area-System.Text.Json"
    ],
    "createdAt": "2021-08-12T12:36:04Z",
    "body": "Running the console app\r\n```csharp\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing System.Text.Json;\r\nusing System.Text.Json.Serialization;\r\n\r\nnamespace Repro\r\n{\r\n    public class Program\r\n    {\r\n        public static void Main()\r\n        {\r\n            var options = new JsonSerializerOptions { Converters = { new MyCustomConverter() } };\r\n            var value = new Dictionary<int, string>();\r\n            JsonSerializer.Serialize(value, options);\r\n        }\r\n\r\n        public class MyCustomConverter : JsonConverter<Dictionary<int, string>>\r\n        {\r\n            // Need to customize deserialization only; delegating serialization to the default converter of the same type.\r\n            private readonly JsonConverter<Dictionary<int, string>> _defaultConverter = \r\n                (JsonConverter<Dictionary<int, string>>)new JsonSerializerOptions().GetConverter(typeof(Dictionary<int, string>));\r\n\r\n            public override void Write(Utf8JsonWriter writer, Dictionary<int, string> value, JsonSerializerOptions options)\r\n                => _defaultConverter.Write(writer, value, options);\r\n\r\n            public override Dictionary<int, string>? Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)\r\n                => throw new NotImplementedException(\"custom converter logic goes here\");\r\n        }\r\n    }\r\n}\r\n```\r\nResults in the following exception:\r\n```\r\nUnhandled exception. System.NullReferenceException: Object reference not set to an instance of an object.\r\n   at System.Text.Json.Serialization.Converters.DictionaryDefaultConverter`3.OnTryWrite(Utf8JsonWriter writer, TCollection dictionary, JsonSerializerOptions options, WriteStack& state) in System.Text.Json.dll:token 0x6000964+0x4e\r\n   at System.Text.Json.Serialization.JsonConverter`1.TryWrite(Utf8JsonWriter writer, T& value, JsonSerializerOptions options, WriteStack& state) in System.Text.Json.dll:token 0x6000790+0x1f4\r\n   at System.Text.Json.Serialization.JsonResumableConverter`1.Write(Utf8JsonWriter writer, T value, JsonSerializerOptions options) in System.Text.Json.dll:token 0x600079c+0x2a\r\n   at Repro.Program.MyCustomConverter.Write(Utf8JsonWriter writer, Dictionary`2 value, JsonSerializerOptions options) in C:\\Users\\eitsarpa\\source\\repos\\ConsoleApp1\\ConsoleApp1\\Program.cs:line 23\r\n   at System.Text.Json.Serialization.JsonConverter`1.TryWrite(Utf8JsonWriter writer, T& value, JsonSerializerOptions options, WriteStack& state) in System.Text.Json.dll:token 0x6000790+0x195\r\n   at System.Text.Json.Serialization.JsonConverter`1.WriteCore(Utf8JsonWriter writer, T& value, JsonSerializerOptions options, WriteStack& state) in System.Text.Json.dll:token 0x600077b+0x0\r\n   at System.Text.Json.JsonSerializer.WriteCore[TValue](JsonConverter jsonConverter, Utf8JsonWriter writer, TValue& value, JsonSerializerOptions options, WriteStack& state) in System.Text.Json.dll:token 0x60003c6+0xa\r\n   at System.Text.Json.JsonSerializer.WriteUsingMetadata[TValue](Utf8JsonWriter writer, TValue& value, JsonTypeInfo jsonTypeInfo) in System.Text.Json.dll:token 0x60003c7+0x4c\r\n   at System.Text.Json.JsonSerializer.WriteUsingMetadata[TValue](TValue& value, JsonTypeInfo jsonTypeInfo) in System.Text.Json.dll:token 0x60003db+0x2e\r\n   at System.Text.Json.JsonSerializer.Write[TValue](TValue& value, Type runtimeType, JsonSerializerOptions options) in System.Text.Json.dll:token 0x60003da+0x8\r\n   at System.Text.Json.JsonSerializer.Serialize[TValue](TValue value, JsonSerializerOptions options) in System.Text.Json.dll:token 0x60003d6+0x0\r\n```\r\nException is thrown from [this location](https://github.com/dotnet/runtime/blob/2ce426a7b38eb283689fdaaa0bdf299f952886a2/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/Converters/Collection/JsonDictionaryConverter.cs#L298). Root cause is the [bridging logic for resumable converters](https://github.com/dotnet/runtime/blob/2ce426a7b38eb283689fdaaa0bdf299f952886a2/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/JsonResumableConverterOfT.cs#L36), which populates the root stackframe using metadata from the converter resolved via the ambient `JsonSerializerOptions`  instance, rather than the one being currently called.\r\n\r\nComposing with converters that are not part of the current `JsonSerializerOptions` instance should be a supported scenario (I anticipate this might become a more frequent scenario as users start availing of the new `JsonMetadataServices` APIs). I could not come up with a good workaround for the above.\r\n\r\nThis is not a regression from .NET 5.\r\n\r\n@steveharter @layomia is this something we should attempt to address in .NET 6?",
    "number": 57280,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "EYES",
          "createdAt": "2022-11-13T14:49:49Z",
          "user": "corstian"
        },
        {
          "content": "EYES",
          "createdAt": "2023-03-12T11:16:18Z",
          "user": "PauloHMattos"
        }
      ],
      "totalCount": 2,
      "endCursor": "Y3Vyc29yOnYyOpHOCu05CA=="
    },
    "updatedAt": "2025-01-17T12:11:05Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @eiriktsarpalis, @layomia\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\nRunning the console app\r\n```csharp\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing System.Text.Json;\r\nusing System.Text.Json.Serialization;\r\n\r\nnamespace Repro\r\n{\r\n    public class Program\r\n    {\r\n        public static void Main()\r\n        {\r\n            var options = new JsonSerializerOptions { Converters = { new MyCustomConverter() } };\r\n            var value = new Dictionary<int, string>();\r\n            JsonSerializer.Serialize(value, options);\r\n        }\r\n\r\n        public class MyCustomConverter : JsonConverter<Dictionary<int, string>>\r\n        {\r\n            // Need to customize deserialization only; delegating serialization to the default converter of the same type.\r\n            private readonly JsonConverter<Dictionary<int, string>> _defaultConverter = \r\n                (JsonConverter<Dictionary<int, string>>)new JsonSerializerOptions().GetConverter(typeof(Dictionary<int, string>));\r\n\r\n            public override void Write(Utf8JsonWriter writer, Dictionary<int, string> value, JsonSerializerOptions options)\r\n                => _defaultConverter.Write(writer, value, options);\r\n\r\n            public override Dictionary<int, string>? Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)\r\n                => throw new NotImplementedException(\"custom converter logic goes here\");\r\n        }\r\n    }\r\n}\r\n```\r\nResults in the following exception:\r\n```\r\nUnhandled exception. System.NullReferenceException: Object reference not set to an instance of an object.\r\n   at System.Text.Json.Serialization.Converters.DictionaryDefaultConverter`3.OnTryWrite(Utf8JsonWriter writer, TCollection dictionary, JsonSerializerOptions options, WriteStack& state) in System.Text.Json.dll:token 0x6000964+0x4e\r\n   at System.Text.Json.Serialization.JsonConverter`1.TryWrite(Utf8JsonWriter writer, T& value, JsonSerializerOptions options, WriteStack& state) in System.Text.Json.dll:token 0x6000790+0x1f4\r\n   at System.Text.Json.Serialization.JsonResumableConverter`1.Write(Utf8JsonWriter writer, T value, JsonSerializerOptions options) in System.Text.Json.dll:token 0x600079c+0x2a\r\n   at Repro.Program.MyCustomConverter.Write(Utf8JsonWriter writer, Dictionary`2 value, JsonSerializerOptions options) in C:\\Users\\eitsarpa\\source\\repos\\ConsoleApp1\\ConsoleApp1\\Program.cs:line 23\r\n   at System.Text.Json.Serialization.JsonConverter`1.TryWrite(Utf8JsonWriter writer, T& value, JsonSerializerOptions options, WriteStack& state) in System.Text.Json.dll:token 0x6000790+0x195\r\n   at System.Text.Json.Serialization.JsonConverter`1.WriteCore(Utf8JsonWriter writer, T& value, JsonSerializerOptions options, WriteStack& state) in System.Text.Json.dll:token 0x600077b+0x0\r\n   at System.Text.Json.JsonSerializer.WriteCore[TValue](JsonConverter jsonConverter, Utf8JsonWriter writer, TValue& value, JsonSerializerOptions options, WriteStack& state) in System.Text.Json.dll:token 0x60003c6+0xa\r\n   at System.Text.Json.JsonSerializer.WriteUsingMetadata[TValue](Utf8JsonWriter writer, TValue& value, JsonTypeInfo jsonTypeInfo) in System.Text.Json.dll:token 0x60003c7+0x4c\r\n   at System.Text.Json.JsonSerializer.WriteUsingMetadata[TValue](TValue& value, JsonTypeInfo jsonTypeInfo) in System.Text.Json.dll:token 0x60003db+0x2e\r\n   at System.Text.Json.JsonSerializer.Write[TValue](TValue& value, Type runtimeType, JsonSerializerOptions options) in System.Text.Json.dll:token 0x60003da+0x8\r\n   at System.Text.Json.JsonSerializer.Serialize[TValue](TValue value, JsonSerializerOptions options) in System.Text.Json.dll:token 0x60003d6+0x0\r\n```\r\nRoot cause is the [bridging logic for resumable converters](https://github.com/dotnet/runtime/blob/2ce426a7b38eb283689fdaaa0bdf299f952886a2/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/JsonResumableConverterOfT.cs#L36), which populates the root stackframe using metadata from the converter resolved via the ambient `JsonSerializerOptions`  instance, rather than the one being currently called.\r\n\r\nComposing with converters that are not part of the current `JsonSerializerOptions` instance should be a supported scenario (I anticipate this might become a more frequent scenario as users start availing of the new `JsonMetadataServices` APIs). I could not come up with a good workaround for the above.\r\n\r\nThis is not a regression from .NET 5.\r\n\r\n@steveharter @layomia is this something we should attempt to address in .NET 6?\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>eiriktsarpalis</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>eiriktsarpalis</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`area-System.Text.Json`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2021-08-12T12:36:08Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-08-12T12:36:08Z",
          "id": "IC_kwDODI9FZc41gFao"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Should likely be addressed in conjunction with #63791.",
          "createdAt": "2021-10-14T17:41:29Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-04-18T15:13:37Z",
          "id": "IC_kwDODI9FZc44Pdu8"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Moving to future, as this will likely be addressed via https://github.com/dotnet/runtime/issues/63795",
          "createdAt": "2022-04-18T15:11:52Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-04-18T15:11:52Z",
          "id": "IC_kwDODI9FZc5Bp1DV"
        }
      ],
      "totalCount": 3,
      "endCursor": "Y3Vyc29yOnYyOpHOQadQ1Q=="
    },
    "url": "https://github.com/dotnet/runtime/issues/57280",
    "title": "NullReferenceException when composing a custom converter with a default converter"
  },
  {
    "author": "Jericho",
    "labels": [
      "enhancement",
      "area-System.Text.Json",
      "help wanted",
      "source-generator"
    ],
    "createdAt": "2021-09-05T20:18:11Z",
    "body": "When my custom serialiazer context class has zero JsonSerializable attributes, I get an error message which does not help me understand what the problem is.\r\n\r\nI simply get the dreaded:\r\n```\r\nCS0534\t'MyJsonSerializerContext' does not implement inherited abstract member 'JsonSerializerContext.GetTypeInfo(Type)'\r\n```\r\n\r\nI do not get any additional information to help me realize that I forgot to add JsonSerializable attributes to my custom class. It would be extremely helpful to get an error message similar to `Your custom serializer context class must have at least one JsonSerializable attribute`.\r\n\r\nRepro:\r\n\r\n```csharp\r\npublic static class Program\r\n{\r\n    public static void Main()\r\n    {\r\n        Console.WriteLine(\"Hello World!\");\r\n    }\r\n}\r\n\r\n// Notice there are no JsonSerializable attributes here.\r\ninternal partial class MyJsonSerializerContext : JsonSerializerContext\r\n{\r\n}\r\n```\r\n\r\nAs an aside: Is there a way to get more detailed information when something goes wrong with the code generator? Does it generate a log somewhere?",
    "number": 58698,
    "reactions": {
      "hasNextPage": false,
      "nodes": [],
      "totalCount": 0,
      "endCursor": null
    },
    "updatedAt": "2023-07-05T15:16:16Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": "Jericho",
          "body": "By the way, I want to be completely clear that I fully understand that a custom serializer context without any JsonSerializable is not a valid scenario. I am not saying that the code generator should accept this situation. However, I think that a better/more descriptive error message would be helpful and would allow developers to resolve the situation easily.",
          "createdAt": "2021-09-05T20:21:06Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-09-05T20:21:06Z",
          "id": "IC_kwDODI9FZc42bqf4"
        },
        {
          "author": "layomia",
          "body": "Yes we can log a diagnostic error for this scenario.\r\n\r\n> As an aside: Is there a way to get more detailed information when something goes wrong with the code generator? Does it generate a log somewhere?\r\n\r\nYes we log diagnostic errors for other scenarios, e.g. when a custom context class or one of its enclosing types is not `partial`.",
          "createdAt": "2021-09-07T14:48:14Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-09-07T14:48:14Z",
          "id": "IC_kwDODI9FZc42gCw3"
        },
        {
          "author": "Jericho",
          "body": "> Yes we log diagnostic errors for other scenarios\r\n\r\nHow do I access this log?\r\n",
          "createdAt": "2021-09-07T15:33:59Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-09-07T15:33:59Z",
          "id": "IC_kwDODI9FZc42gM9E"
        },
        {
          "author": "layomia",
          "body": "It's part of the error log shown during the build (visible both in command line & VS), just like the `CS0534` error you're seeing above.",
          "createdAt": "2021-09-07T18:41:40Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-09-07T18:41:40Z",
          "id": "IC_kwDODI9FZc42gr6E"
        },
        {
          "author": "Jericho",
          "body": "@layomia The reason I asked about a more detailed log is because `CS0534` is a very generic message that, unfortunately, does not give us any clue about what caused the problem. Consider this: let's say I was to raise an issue and said \"I'm getting CS0534, help me figure out what's going on\", I'm sure you would tell me that I haven't provided enough information. \r\n\r\nSo, let me rephrase my question: how can we find more detailed information when we get generic errors like CS0534?",
          "createdAt": "2021-09-09T15:28:04Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-09-09T15:28:04Z",
          "id": "IC_kwDODI9FZc42nClL"
        },
        {
          "author": "layomia",
          "body": "When you get `CS0534` when using the source generator, it means that there's another underlying issue that caused the generator not to emit the expected code. The generator emits various diagnostics which explain failure reasons, but it doesn't do it in all cases as this issue shows. We just need to emit a diagnostic for this scenario like proposed in https://github.com/dotnet/runtime/pull/58768.\r\n\r\nA fix for this doesn't meet the bar to be ported to 6.0, so I'll move this issue to future.",
          "createdAt": "2021-09-10T13:27:17Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-09-10T13:27:17Z",
          "id": "IC_kwDODI9FZc42pth5"
        },
        {
          "author": "layomia",
          "body": "Up for grabs. https://github.com/dotnet/runtime/pull/58768 attempted to fix this for 6.0 but we ran out of time. Note there'll be some [perf testing](https://github.com/dotnet/runtime/pull/58768#discussion_r704474361) to make sure we don't regress typing performance for large VS solutions.",
          "createdAt": "2022-12-02T17:11:53Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-06-15T19:20:45Z",
                "user": "eiriktsarpalis"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOC-EU3w=="
          },
          "updatedAt": "2022-12-02T17:11:53Z",
          "id": "IC_kwDODI9FZc5Pmuno"
        },
        {
          "author": "eiriktsarpalis",
          "body": "We also need to make sure this diagnostic doesn't trigger for classes that provide an explicit override for the `GetTypeInfo` method. No doubt many users do this so this could trigger a source breaking change if we don't account for that case.",
          "createdAt": "2023-06-15T19:22:11Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-06-15T19:22:11Z",
          "id": "IC_kwDODI9FZc5e_G_p"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Moving to future for now as we figure out a way to do this without compromising editor performance or triggering false positive diagnostics.",
          "createdAt": "2023-07-05T15:15:47Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-07-05T15:16:15Z",
          "id": "IC_kwDODI9FZc5grU8i"
        }
      ],
      "totalCount": 9,
      "endCursor": "Y3Vyc29yOnYyOpHOYK1PIg=="
    },
    "url": "https://github.com/dotnet/runtime/issues/58698",
    "title": "Issue diagnostic warnings when custom JsonSerializerContext types don't indicate serializable types"
  },
  {
    "author": "bartonjs",
    "labels": [
      "area-System.Text.Json",
      "test-enhancement"
    ],
    "createdAt": "2021-09-07T22:34:16Z",
    "body": "`Utf8JsonReader` has a `BitStack` value that is a value type right up until it exceeds depth 64.\r\n\r\nSince https://github.com/dotnet/runtime/blob/b7e10374429b5af32debc4660aa9bce41cfb903e/src/libraries/System.Text.Json/src/System/Text/Json/Document/JsonDocument.cs#L1126-L1137 does not check the MaxDepth value, the \"restore on exception\" logic in https://github.com/dotnet/runtime/blob/b7e10374429b5af32debc4660aa9bce41cfb903e/src/libraries/System.Text.Json/src/System/Text/Json/Document/JsonDocument.Parse.cs#L411-L424 might not be correct if `reader._bitStack._array` is non-null, resulting in a torn state.\r\n\r\nSince the array probably doesn't get nulled out, it's probably also there when the reader has already surpassed a depth 64 position.",
    "number": 58772,
    "reactions": {
      "hasNextPage": false,
      "nodes": [],
      "totalCount": 0,
      "endCursor": null
    },
    "updatedAt": "2022-07-09T07:26:52Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @eiriktsarpalis, @layomia\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\n`Utf8JsonReader` has a `BitStack` value that is a value type right up until it exceeds depth 64.\r\n\r\nSince https://github.com/dotnet/runtime/blob/b7e10374429b5af32debc4660aa9bce41cfb903e/src/libraries/System.Text.Json/src/System/Text/Json/Document/JsonDocument.cs#L1126-L1137 does not check the MaxDepth value, the \"restore on exception\" logic in https://github.com/dotnet/runtime/blob/b7e10374429b5af32debc4660aa9bce41cfb903e/src/libraries/System.Text.Json/src/System/Text/Json/Document/JsonDocument.Parse.cs#L411-L424 might not be correct if `reader._bitStack._array` is non-null, resulting in a torn state.\r\n\r\nSince the array probably doesn't get nulled out, it's probably also there when the reader has already surpassed a depth 64 position.\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>bartonjs</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`area-System.Text.Json`, `test enhancement`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2021-09-07T22:34:19Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-09-07T22:34:19Z",
          "id": "IC_kwDODI9FZc42hMPh"
        }
      ],
      "totalCount": 1,
      "endCursor": "Y3Vyc29yOnYyOpHONoTD4Q=="
    },
    "url": "https://github.com/dotnet/runtime/issues/58772",
    "title": "Add a test for verifying non-modified reader state in JsonDocument.ParseValue on deep values"
  },
  {
    "author": "layomia",
    "labels": [
      "area-System.Text.Json",
      "Priority:3",
      "Cost:S",
      "source-generator"
    ],
    "createdAt": "2021-09-10T14:17:10Z",
    "body": "Per https://github.com/dotnet/runtime/issues/51945#issuecomment-827795787 and https://github.com/dotnet/runtime/pull/58912#discussion_r705746221, the feature is currently not supported in fast-path serialization and the serializer falls back to a metadata-based implementation if provided/configured by the source generator.\r\n\r\nWe should target 7.0 - it is technically feasible to do this now, just a bit complex & a large diff at this stage in 6.0. Concretely, extension data properties (dictionaries) can have typeof(object) values which is a polymorphic scenario currently not supported in fast-path.\r\n\r\nWe should also consider deserialization support for this feature, alongside https://github.com/dotnet/runtime/issues/55043 (\"Consider fast-path deserialization logic in JSON source generator\").",
    "number": 58943,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-02-13T20:37:35Z",
          "user": "Akarinnnnn"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-07-01T05:20:09Z",
          "user": "austindrenski"
        }
      ],
      "totalCount": 2,
      "endCursor": "Y3Vyc29yOnYyOpHOCktmbQ=="
    },
    "updatedAt": "2023-03-29T16:04:35Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @eiriktsarpalis, @layomia\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\nPer https://github.com/dotnet/runtime/issues/51945#issuecomment-827795787 and https://github.com/dotnet/runtime/pull/58912#discussion_r705746221, the feature is currently not supported and the serializer falls back to a metadata-based implementation if provided/configured by the source generator.\r\n\r\nWe should target 7.0 - it is technically feasible to do this now, just a bit complex & a large diff at this stage in 6.0. Concretely, extension data properties (dictionaries) can have typeof(object) values which is a polymorphic scenario currently not supported in fast-path.\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>layomia</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`area-System.Text.Json`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>7.0.0</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2021-09-10T14:17:13Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-09-10T14:17:13Z",
          "id": "IC_kwDODI9FZc42p2Pp"
        },
        {
          "author": "eiriktsarpalis",
          "body": "@layomia should his be included in the planned work epic?",
          "createdAt": "2022-01-20T15:35:49Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-01-20T15:35:49Z",
          "id": "IC_kwDODI9FZc48p9Oi"
        }
      ],
      "totalCount": 2,
      "endCursor": "Y3Vyc29yOnYyOpHOPKfTog=="
    },
    "url": "https://github.com/dotnet/runtime/issues/58943",
    "title": "Support JsonExtensionData in source generator fast path"
  },
  {
    "author": "layomia",
    "labels": [
      "area-System.Text.Json",
      "test-enhancement",
      "source-generator"
    ],
    "createdAt": "2021-09-10T14:34:47Z",
    "body": "Some of the serializer tests intentionally define invalid `JsonExtensionData` properties which would cause `InvalidOperationException` to be thrown at runtime, e.g.\r\n\r\nhttps://github.com/dotnet/runtime/blob/b683032718a1e76ca93147fc4a273e250ef65525/src/libraries/System.Text.Json/tests/System.Text.Json.Tests/Serialization/ExtensionDataTests.cs#L300-L304\r\n\r\nWhen source generation is used, compile-time errors are logged rather than deferred to runtime. The PR adding support for `JsonExtensionData` (https://github.com/dotnet/runtime/pull/58912) thus disables these tests so that the source generator test project (`System.Text.Json.SourceGeneration.Tests`) can compile. We should add unit test variants for coverage in `System.Text.Json.SourceGeneration.Unit.Tests`.",
    "number": 58945,
    "reactions": {
      "hasNextPage": false,
      "nodes": [],
      "totalCount": 0,
      "endCursor": null
    },
    "updatedAt": "2022-07-10T01:01:23Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @eiriktsarpalis, @layomia\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\nSome of the serializer tests intentionally define invalid `JsonExtensionData` properties which would cause `InvalidOperationException` to be thrown at runtime, e.g.\r\n\r\nhttps://github.com/dotnet/runtime/blob/b683032718a1e76ca93147fc4a273e250ef65525/src/libraries/System.Text.Json/tests/System.Text.Json.Tests/Serialization/ExtensionDataTests.cs#L300-L304\r\n\r\nWhen source generation is used, compile-time errors are logged rather than deferred to runtime. The PR adding support for `JsonExtensionData` (https://github.com/dotnet/runtime/pull/58912) thus disables these tests so that the source generator test project (`System.Text.Json.SourceGeneration.Tests`) can compile. We should add unit test variants for coverage in `System.Text.Json.SourceGeneration.Unit.Tests`.\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>layomia</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`area-System.Text.Json`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>7.0.0</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2021-09-10T14:34:49Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-09-10T14:34:49Z",
          "id": "IC_kwDODI9FZc42p5Uw"
        }
      ],
      "totalCount": 1,
      "endCursor": "Y3Vyc29yOnYyOpHONqeVMA=="
    },
    "url": "https://github.com/dotnet/runtime/issues/58945",
    "title": "Add source generator unit tests for invalid JsonExtensionData cases"
  },
  {
    "author": "eiriktsarpalis",
    "labels": [
      "enhancement",
      "area-System.Text.Json",
      "Priority:3"
    ],
    "createdAt": "2021-09-20T18:36:00Z",
    "body": "The `JsonIgnoreAttribute` is a mechanism intended to prevent serialization or deserialization of a given property. However, users might sometimes apply the attribute with the expectation that it can be used to suppress serializer errors if the property in question has been misconfigured. This is not the case, and the handling of such scenaria in System.Text.Json is largely undefined behavior. \r\n\r\nThat behavior can be inconsistent depending on the combination of attributes, and changes can result in broken applications like the one reported in https://github.com/dotnet/runtime/issues/58469#issuecomment-919830246. In future releases we should try to ensure consistent semantics of the `JsonIgnoreAttribute` (e.g. by making that attribute suppress every other attribute) in both the reflection-based serializer and the source generator.",
    "number": 59364,
    "reactions": {
      "hasNextPage": false,
      "nodes": [],
      "totalCount": 0,
      "endCursor": null
    },
    "updatedAt": "2022-07-09T07:29:37Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @ajcvickers, @bricelam, @roji\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\nThe `JsonIgnoreAttribute` is a mechanism intended to prevent serialization or deserialization of a given property. However, users might sometimes apply the attribute with the expectation that it can be used to suppress serializer errors if the property in question has been misconfigured. This is not the case, and the handling of such scenaria in System.Text.Json is largely undefined behavior. \r\n\r\nThat behavior can be inconsistent depending on the combination of attributes, and changes can result in broken applications like the one reported in https://github.com/dotnet/runtime/issues/58469#issuecomment-919830246. In future releases we should try to ensure consistent semantics of the `JsonIgnoreAttribute` (e.g. by making that attribute suppress every other attribute) in both the reflection-based serializer and the source generator.\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>eiriktsarpalis</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`area-System.ComponentModel.DataAnnotations`, `untriaged`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2021-09-20T18:36:06Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-09-20T18:36:06Z",
          "id": "IC_kwDODI9FZc43BphT"
        }
      ],
      "totalCount": 1,
      "endCursor": "Y3Vyc29yOnYyOpHONwaYUw=="
    },
    "url": "https://github.com/dotnet/runtime/issues/59364",
    "title": "Refine JsonIgnoreAttribute semantics when used in conjunction with other attributes."
  },
  {
    "author": "layomia",
    "labels": [
      "enhancement",
      "area-System.Text.Json",
      "Priority:2",
      "source-generator"
    ],
    "createdAt": "2021-09-21T18:41:46Z",
    "body": "When writing via the serializer e.g. `JsonSerializer.Serialize(foo, context.Foo)`, fast-path logic does not consider the encoder on the writer (via `Utf8JsonWriter.Options.Encoder`). This means property names would be written with default encoding and values could be written with a custom encoder. This mismatch can be considered invalid - we should disallow the use of a custom encoder on the writer to align with [supported features](https://docs.microsoft.com/dotnet/standard/serialization/system-text-json-source-generation?pivots=dotnet-6-0#serialization-optimization-mode) for fast-path.\r\n\r\nWe should also verify the behavior of both metadata and reflection-based serializers if/when `JsonSerializerOptions.Encoder` and `Utf8JsonWriter.Options.Encoder` differ.\r\n\r\nCalling fast-path logic directly e.g. `context.Foo.SerializeHandler(writer, foo)` with writer encoder info that differs from options specified ahead of time via `[JsonSourceGenerationOptions]` is considered a user error. The raw serialize logic will not perform any options validation.\r\n\r\ncc @eiriktsarpalis @steveharter for any thoughts.",
    "number": 59424,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-11-20T22:24:52Z",
          "user": "DrEsteban"
        }
      ],
      "totalCount": 1,
      "endCursor": "Y3Vyc29yOnYyOpHOC81VEA=="
    },
    "updatedAt": "2023-10-05T22:11:15Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @eiriktsarpalis, @layomia\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\nWhen writing via the serializer e.g. `JsonSerializer.Serialize(foo, context.Foo)`, fast-path logic does not consider the encoder on the writer (via `Utf8JsonWriter.Options.Encoder`). This means property names would be written with default encoding and values could be written with a custom encoder. This mismatch can be considered invalid - we should disallow the use of a custom encoder on the writer to align with [supported features](https://docs.microsoft.com/dotnet/standard/serialization/system-text-json-source-generation?pivots=dotnet-6-0#serialization-optimization-mode) for fast-path.\r\n\r\nWe should also verify the behavior of both metadata and reflection-based serializers if/when `JsonSerializerOptions.Encoder` and `Utf8JsonWriter.Options.Encoder` differ.\r\n\r\nCalling fast-path logic directly e.g. `context.Foo.SerializeHandler(writer, foo)` with writer encoder info that differs from options specified ahead of time via `[JsonSourceGenerationOptions]` is considered a user error. The raw serialize logic will not perform any options validation.\r\n\r\ncc @eiriktsarpalis @steveharter for any thoughts.\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>layomia</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>layomia</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`area-System.Text.Json`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>7.0.0</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2021-09-21T18:41:49Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-09-21T18:41:49Z",
          "id": "IC_kwDODI9FZc43Fzis"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Moving to Future, as we won't have time to work on this in the .NET 7 timeframe.",
          "createdAt": "2022-04-18T15:47:52Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-04-18T15:49:05Z",
          "id": "IC_kwDODI9FZc5Bp8QS"
        }
      ],
      "totalCount": 2,
      "endCursor": "Y3Vyc29yOnYyOpHOQafEEg=="
    },
    "url": "https://github.com/dotnet/runtime/issues/59424",
    "title": "JSON src-gen fast-path does not consider writer Encoder option"
  },
  {
    "author": "VincentBu",
    "labels": [
      "test-failure",
      "arch-x86",
      "area-System.Text.Json",
      "os-windows"
    ],
    "createdAt": "2021-09-22T03:04:39Z",
    "body": "Run: [runtime-coreclr libraries-jitstress 20210921.1](https://dev.azure.com/dnceng/public/_build/results?buildId=1374686&view=ms.vss-test-web.build-test-results-tab&runId=40099778&resultId=190408&paneView=debug)\r\n\r\nFailed test:\r\n```\r\nnet7.0-windows-Release-x86-CoreCLR_checked-jitstress1-Windows.10.Amd64.Open\r\n\r\n- System.Text.Json.Tests.JsonElementWriteTests.WriteIncredibleDepth\r\n- System.Text.Json.Tests.JsonDocumentWriteTests.WriteIncredibleDepth\r\n\r\nnet7.0-windows-Release-x86-CoreCLR_checked-no_tiered_compilation-Windows.10.Amd64.Open\r\n\r\n- System.Text.Json.Tests.JsonElementWriteTests.WriteIncredibleDepth\r\n- System.Text.Json.Tests.JsonDocumentWriteTests.WriteIncredibleDepth\r\n\r\nnet7.0-windows-Release-x86-CoreCLR_checked-jitstress2-Windows.10.Amd64.Open\r\n\r\n- System.Text.Json.Tests.JsonElementWriteTests.WriteIncredibleDepth\r\n- System.Text.Json.Tests.JsonDocumentWriteTests.WriteIncredibleDepth\r\n\r\nnet7.0-windows-Release-x86-CoreCLR_checked-zapdisable-Windows.10.Amd64.Open\r\n\r\n- System.Text.Json.Tests.JsonElementWriteTests.WriteIncredibleDepth\r\n- System.Text.Json.Tests.JsonDocumentWriteTests.WriteIncredibleDepth\r\n\r\nnet7.0-windows-Release-x86-CoreCLR_checked-tailcallstress-Windows.10.Amd64.Open\r\n\r\n- System.Text.Json.Tests.JsonDocumentWriteTests.WriteIncredibleDepth\r\n- System.Text.Json.Tests.JsonElementWriteTests.WriteIncredibleDepth\r\n\r\n\r\n```\r\n**Error message:**\r\n```\r\nSystem.Text.Json.JsonReaderException : '0x00' is an invalid start of a value. LineNumber: 0 | BytePositionInLine: 528.\r\n\r\n\r\nStack trace\r\n   at System.Text.Json.ThrowHelper.ThrowJsonReaderException(Utf8JsonReader& json, ExceptionResource resource, Byte nextByte, ReadOnlySpan`1 bytes) in /_/src/libraries/System.Text.Json/src/System/Text/Json/ThrowHelper.cs:line 290\r\n   at System.Text.Json.Utf8JsonReader.ConsumeValue(Byte marker) in /_/src/libraries/System.Text.Json/src/System/Text/Json/Reader/Utf8JsonReader.cs:line 1110\r\n   at System.Text.Json.Utf8JsonReader.ReadSingleSegment() in /_/src/libraries/System.Text.Json/src/System/Text/Json/Reader/Utf8JsonReader.cs:line 868\r\n   at System.Text.Json.JsonDocument.Parse(ReadOnlySpan`1 utf8JsonSpan, JsonReaderOptions readerOptions, MetadataDb& database, StackRowStack& stack) in /_/src/libraries/System.Text.Json/src/System/Text/Json/Document/JsonDocument.cs:line 973\r\n   at System.Text.Json.JsonDocument.Parse(ReadOnlyMemory`1 utf8Json, JsonReaderOptions readerOptions, Byte[] extraRentedArrayPoolBytes, PooledByteBufferWriter extraPooledByteBufferWriter) in /_/src/libraries/System.Text.Json/src/System/Text/Json/Document/JsonDocument.Parse.cs:line 692\r\n   at System.Text.Json.Tests.JsonDomWriteTests.WriteIncredibleDepth() in /_/src/libraries/System.Text.Json/tests/System.Text.Json.Tests/JsonElementWriteTests.cs:line 1134\r\n```",
    "number": 59456,
    "reactions": {
      "hasNextPage": false,
      "nodes": [],
      "totalCount": 0,
      "endCursor": null
    },
    "updatedAt": "2022-09-02T14:19:01Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @eiriktsarpalis, @layomia\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\nRun: [runtime-coreclr libraries-jitstress 20210921.1](https://dev.azure.com/dnceng/public/_build/results?buildId=1374686&view=ms.vss-test-web.build-test-results-tab&runId=40099778&resultId=190408&paneView=debug)\r\n\r\nFailed test:\r\n```\r\nnet7.0-windows-Release-x86-CoreCLR_checked-jitstress1-Windows.10.Amd64.Open\r\n\r\n- System.Text.Json.Tests.JsonElementWriteTests.WriteIncredibleDepth\r\n- System.Text.Json.Tests.JsonDocumentWriteTests.WriteIncredibleDepth\r\n\r\nnet7.0-windows-Release-x86-CoreCLR_checked-no_tiered_compilation-Windows.10.Amd64.Open\r\n\r\n- System.Text.Json.Tests.JsonElementWriteTests.WriteIncredibleDepth\r\n- System.Text.Json.Tests.JsonDocumentWriteTests.WriteIncredibleDepth\r\n\r\nnet7.0-windows-Release-x86-CoreCLR_checked-jitstress2-Windows.10.Amd64.Open\r\n\r\n- System.Text.Json.Tests.JsonElementWriteTests.WriteIncredibleDepth\r\n- System.Text.Json.Tests.JsonDocumentWriteTests.WriteIncredibleDepth\r\n\r\nnet7.0-windows-Release-x86-CoreCLR_checked-zapdisable-Windows.10.Amd64.Open\r\n\r\n- System.Text.Json.Tests.JsonElementWriteTests.WriteIncredibleDepth\r\n- System.Text.Json.Tests.JsonDocumentWriteTests.WriteIncredibleDepth\r\n\r\nnet7.0-windows-Release-x86-CoreCLR_checked-tailcallstress-Windows.10.Amd64.Open\r\n\r\n- System.Text.Json.Tests.JsonDocumentWriteTests.WriteIncredibleDepth\r\n- System.Text.Json.Tests.JsonElementWriteTests.WriteIncredibleDepth\r\n\r\n\r\n```\r\n**Error message:**\r\n```\r\nSystem.Text.Json.JsonReaderException : '0x00' is an invalid start of a value. LineNumber: 0 | BytePositionInLine: 528.\r\n\r\n\r\nStack trace\r\n   at System.Text.Json.ThrowHelper.ThrowJsonReaderException(Utf8JsonReader& json, ExceptionResource resource, Byte nextByte, ReadOnlySpan`1 bytes) in /_/src/libraries/System.Text.Json/src/System/Text/Json/ThrowHelper.cs:line 290\r\n   at System.Text.Json.Utf8JsonReader.ConsumeValue(Byte marker) in /_/src/libraries/System.Text.Json/src/System/Text/Json/Reader/Utf8JsonReader.cs:line 1110\r\n   at System.Text.Json.Utf8JsonReader.ReadSingleSegment() in /_/src/libraries/System.Text.Json/src/System/Text/Json/Reader/Utf8JsonReader.cs:line 868\r\n   at System.Text.Json.JsonDocument.Parse(ReadOnlySpan`1 utf8JsonSpan, JsonReaderOptions readerOptions, MetadataDb& database, StackRowStack& stack) in /_/src/libraries/System.Text.Json/src/System/Text/Json/Document/JsonDocument.cs:line 973\r\n   at System.Text.Json.JsonDocument.Parse(ReadOnlyMemory`1 utf8Json, JsonReaderOptions readerOptions, Byte[] extraRentedArrayPoolBytes, PooledByteBufferWriter extraPooledByteBufferWriter) in /_/src/libraries/System.Text.Json/src/System/Text/Json/Document/JsonDocument.Parse.cs:line 692\r\n   at System.Text.Json.Tests.JsonDomWriteTests.WriteIncredibleDepth() in /_/src/libraries/System.Text.Json/tests/System.Text.Json.Tests/JsonElementWriteTests.cs:line 1134\r\n```\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>VincentBu</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`arch-x86`, `area-System.Text.Json`, `os-windows`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2021-09-22T03:04:42Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-09-22T03:04:42Z",
          "id": "IC_kwDODI9FZc43G2gm"
        },
        {
          "author": "layomia",
          "body": "cc @steveharter\r\n\r\nLikely not a 6.0 bug. We should observe if there are more hits.",
          "createdAt": "2021-09-24T20:21:26Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-09-24T20:21:26Z",
          "id": "IC_kwDODI9FZc43P1XI"
        },
        {
          "author": "VincentBu",
          "body": "Failed again in: [runtime-coreclr libraries-jitstress 20210929.1](https://dev.azure.com/dnceng/public/_build/results?buildId=1392386&view=ms.vss-test-web.build-test-results-tab&runId=40490428&paneView=debug&resultId=190115)\r\n\r\nFailed test:\r\n```\r\nnet7.0-windows-Release-x86-CoreCLR_checked-no_tiered_compilation-Windows.10.Amd64.Open\r\n\r\n- System.Text.Json.Tests.JsonDocumentWriteTests.WriteIncredibleDepth\r\n- System.Text.Json.Tests.JsonElementWriteTests.WriteIncredibleDepth\r\n\r\nnet7.0-windows-Release-x86-CoreCLR_checked-jitstress1-Windows.10.Amd64.Open\r\n\r\n- System.Text.Json.Tests.JsonDocumentWriteTests.WriteIncredibleDepth\r\n- System.Text.Json.Tests.JsonElementWriteTests.WriteIncredibleDepth\r\n\r\nnet7.0-windows-Release-x86-CoreCLR_checked-tailcallstress-Windows.10.Amd64.Open\r\n\r\n- System.Text.Json.Tests.JsonDocumentWriteTests.WriteIncredibleDepth\r\n- System.Text.Json.Tests.JsonElementWriteTests.WriteIncredibleDepth\r\n\r\n```\r\n**Error message:**\r\n```\r\nSystem.Text.Json.JsonReaderException : '0x00' is an invalid start of a value. LineNumber: 0 | BytePositionInLine: 528.\r\n\r\n\r\nStack trace\r\n   at System.Text.Json.ThrowHelper.ThrowJsonReaderException(Utf8JsonReader& json, ExceptionResource resource, Byte nextByte, ReadOnlySpan`1 bytes) in /_/src/libraries/System.Text.Json/src/System/Text/Json/ThrowHelper.cs:line 290\r\n   at System.Text.Json.Utf8JsonReader.ConsumeValue(Byte marker) in /_/src/libraries/System.Text.Json/src/System/Text/Json/Reader/Utf8JsonReader.cs:line 1110\r\n   at System.Text.Json.Utf8JsonReader.ReadSingleSegment() in /_/src/libraries/System.Text.Json/src/System/Text/Json/Reader/Utf8JsonReader.cs:line 872\r\n   at System.Text.Json.Utf8JsonReader.Read() in /_/src/libraries/System.Text.Json/src/System/Text/Json/Reader/Utf8JsonReader.cs:line 272\r\n   at System.Text.Json.JsonDocument.Parse(ReadOnlySpan`1 utf8JsonSpan, JsonReaderOptions readerOptions, MetadataDb& database, StackRowStack& stack) in /_/src/libraries/System.Text.Json/src/System/Text/Json/Document/JsonDocument.cs:line 951\r\n   at System.Text.Json.JsonDocument.Parse(ReadOnlyMemory`1 utf8Json, JsonReaderOptions readerOptions, Byte[] extraRentedArrayPoolBytes, PooledByteBufferWriter extraPooledByteBufferWriter) in /_/src/libraries/System.Text.Json/src/System/Text/Json/Document/JsonDocument.Parse.cs:line 692\r\n   at System.Text.Json.Tests.JsonDomWriteTests.WriteIncredibleDepth() in /_/src/libraries/System.Text.Json/tests/System.Text.Json.Tests/JsonElementWriteTests.cs:line 1135\r\n```",
          "createdAt": "2021-09-30T01:24:43Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-09-30T01:24:43Z",
          "id": "IC_kwDODI9FZc43eOIZ"
        },
        {
          "author": "BruceForstall",
          "body": "Maybe related to https://github.com/dotnet/runtime/issues/59444?",
          "createdAt": "2021-10-01T18:30:51Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-10-01T18:30:51Z",
          "id": "IC_kwDODI9FZc43lDtf"
        },
        {
          "author": "VincentBu",
          "body": "Failed again in: [runtime-coreclr libraries-jitstressregs 20211003.1](https://dev.azure.com/dnceng/public/_build/results?buildId=1400246&view=ms.vss-test-web.build-test-results-tab&runId=40666302&paneView=debug&resultId=190116)\r\n\r\nFailed test:\r\n```\r\nnet7.0-windows-Release-x86-CoreCLR_checked-jitstressregs3-Windows.10.Amd64.Open\r\n\r\n- System.Text.Json.Tests.JsonElementWriteTests.WriteIncredibleDepth\r\n\r\n```\r\n**Error message:**\r\n```\r\nSystem.Text.Json.JsonReaderException : '0x00' is an invalid start of a value. LineNumber: 0 | BytePositionInLine: 528.\r\n\r\n\r\nStack trace\r\n   at System.Text.Json.ThrowHelper.ThrowJsonReaderException(Utf8JsonReader& json, ExceptionResource resource, Byte nextByte, ReadOnlySpan`1 bytes) in /_/src/libraries/System.Text.Json/src/System/Text/Json/ThrowHelper.cs:line 290\r\n   at System.Text.Json.Utf8JsonReader.ConsumeValue(Byte marker) in /_/src/libraries/System.Text.Json/src/System/Text/Json/Reader/Utf8JsonReader.cs:line 1110\r\n   at System.Text.Json.Utf8JsonReader.ReadSingleSegment() in /_/src/libraries/System.Text.Json/src/System/Text/Json/Reader/Utf8JsonReader.cs:line 872\r\n   at System.Text.Json.Utf8JsonReader.Read() in /_/src/libraries/System.Text.Json/src/System/Text/Json/Reader/Utf8JsonReader.cs:line 272\r\n   at System.Text.Json.JsonDocument.Parse(ReadOnlySpan`1 utf8JsonSpan, JsonReaderOptions readerOptions, MetadataDb& database, StackRowStack& stack) in /_/src/libraries/System.Text.Json/src/System/Text/Json/Document/JsonDocument.cs:line 951\r\n   at System.Text.Json.JsonDocument.Parse(ReadOnlyMemory`1 utf8Json, JsonReaderOptions readerOptions, Byte[] extraRentedArrayPoolBytes, PooledByteBufferWriter extraPooledByteBufferWriter) in /_/src/libraries/System.Text.Json/src/System/Text/Json/Document/JsonDocument.Parse.cs:line 692\r\n   at System.Text.Json.Tests.JsonDomWriteTests.WriteIncredibleDepth() in /_/src/libraries/System.Text.Json/tests/System.Text.Json.Tests/JsonElementWriteTests.cs:line 1135\r\n```",
          "createdAt": "2021-10-08T02:42:56Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-10-08T02:42:56Z",
          "id": "IC_kwDODI9FZc437TrS"
        }
      ],
      "totalCount": 5,
      "endCursor": "Y3Vyc29yOnYyOpHON-060g=="
    },
    "url": "https://github.com/dotnet/runtime/issues/59456",
    "title": "Test failure System.Text.Json.Tests.JsonElementWriteTests.WriteIncredibleDepth"
  },
  {
    "author": "steveharter",
    "labels": [
      "bug",
      "area-System.Text.Json"
    ],
    "createdAt": "2021-09-27T21:47:22Z",
    "body": "For polymorphic scenarios, the `new` modifier does not always work with `JsonIgnore`. This affects both the reflection-based serializer and the source-gen serializer. See also https://github.com/dotnet/runtime/issues/58985#issuecomment-917582153\r\n\r\nThe semantics of the `new` modifier need to be documented and deterministic. For example, when `[JsonIgnore]` is applied to a derived type's property that has `new` and `[JsonIgnore]`, does the base class property (which is a different property / has its own vtable slot) get serialized and deserialized?\r\n\r\nAlso verification is need when `[JsonIgnore]` and `new` are used along other attributes including `[JsonPropertyOrder]` on a derived type's property. The serializer should used the `[JsonPropertyOrder]` on the property that is actually serialized, and not the one that is ignored.\r\n\r\n### Test case failure\r\n``` cs\r\n  string json = JsonSerializer.Serialize(new ConcreteDerivedClass());\r\n  // Throws System.ArgumentException: 'An item with the same key has already been added. Key: Ignored_New_Property'  \r\n\r\n  public class ConcreteDerivedClass : AbstractBaseClass\r\n  {\r\n      [JsonIgnore]\r\n      public new int Ignored_New_Property { get; set; } = 1; // Also test with making this new slot method virtual\r\n  }\r\n\r\n  public abstract class AbstractBaseClass\r\n  {\r\n      [JsonIgnore]\r\n      public int Ignored_New_Property { get; set; } = 2;\r\n  }\r\n```\r\n\r\n### Test case success 1 (serialize)\r\n```cs\r\n  string json = JsonSerializer.Serialize(new ConcreteDerivedClass());\r\n  // Correctly returns \"{\\\"Ignored_New_Property\\\":1}\"\r\n  \r\n  public class ConcreteDerivedClass : AbstractBaseClass\r\n  {\r\n      public new int Ignored_New_Property { get; set; } = 1;\r\n  }\r\n  \r\n  public abstract class AbstractBaseClass\r\n  {\r\n      [JsonIgnore]\r\n      public int Ignored_New_Property { get; set; } = 2;\r\n  }\r\n```\r\n\r\n### Test case success 2 (serialize)\r\n```cs\r\n  string json = JsonSerializer.Serialize(new ConcreteDerivedClass());\r\n  // Correctly returns \"{\\\"Ignored_New_Property\\\":2}\"\r\n  \r\n  public class ConcreteDerivedClass : AbstractBaseClass\r\n  {\r\n      [JsonIgnore]\r\n      public new int Ignored_New_Property { get; set; } = 1;\r\n  }\r\n  \r\n  public abstract class AbstractBaseClass\r\n  {\r\n      public int Ignored_New_Property { get; set; } = 2;\r\n  }\r\n```\r\n\r\n### Test case success 3 (deserialize)\r\n```cs\r\n  ConcreteDerivedClass obj = JsonSerializer.Deserialize<ConcreteDerivedClass>(\"{\\\"Ignored_New_Property\\\":42}\");\r\n  Debug.Assert(obj.Ignored_New_Property == 1);\r\n  Debug.Assert(((AbstractBaseClass)obj).Ignored_New_Property == 42);\r\n\r\n  public abstract class AbstractBaseClass\r\n  {\r\n      public int Ignored_New_Property { get; set; } = 2;\r\n  }\r\n\r\n  public class ConcreteDerivedClass : AbstractBaseClass\r\n  {\r\n      [JsonIgnore]\r\n      public new virtual int Ignored_New_Property { get; set; } = 1;\r\n  }\r\n```\r\n\r\n### Test case success 4 (deserialize)\r\n```cs\r\n  ConcreteDerivedClass obj = JsonSerializer.Deserialize<ConcreteDerivedClass>(\"{\\\"Ignored_New_Property\\\":42}\");\r\n  Debug.Assert(obj.Ignored_New_Property == 42);\r\n  Debug.Assert(((AbstractBaseClass)obj).Ignored_New_Property == 2);\r\n\r\n  public abstract class AbstractBaseClass\r\n  {\r\n      [JsonIgnore]\r\n      public int Ignored_New_Property { get; set; } = 2;\r\n  }\r\n\r\n  public class ConcreteDerivedClass : AbstractBaseClass\r\n  {\r\n      public new virtual int Ignored_New_Property { get; set; } = 1;\r\n  }\r\n```\r\n",
    "number": 59675,
    "reactions": {
      "hasNextPage": false,
      "nodes": [],
      "totalCount": 0,
      "endCursor": null
    },
    "updatedAt": "2022-07-09T07:34:17Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @eiriktsarpalis, @layomia\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\n### Description\r\n\r\nFor polymorphic scenarios, the `new` modifier does not always work with `JsonIgnore`. This affects both the reflection-based serializer and the source-gen serializer.\r\n\r\nSee also https://github.com/dotnet/runtime/issues/58985#issuecomment-917582153\r\n\r\n### Test case failure\r\n``` cs\r\n  string json = JsonSerializer.Serialize(new ConcreteDerivedClass());\r\n  // Throws System.ArgumentException: 'An item with the same key has already been added. Key: Ignored_New_Property'  \r\n\r\n  public class ConcreteDerivedClass : AbstractBaseClass\r\n  {\r\n      [JsonIgnore]\r\n      public new int Ignored_New_Property { get; set; } = 1;\r\n  }\r\n\r\n  public abstract class AbstractBaseClass\r\n  {\r\n      [JsonIgnore]\r\n      public int Ignored_New_Property { get; set; } = 2;\r\n  }\r\n```\r\n\r\n### Test case success 1\r\n```cs\r\n  string json = JsonSerializer.Serialize(new ConcreteDerivedClass());\r\n  // Correctly returns \"{\\\"Ignored_New_Property\\\":1}\"\r\n  \r\n  public class ConcreteDerivedClass : AbstractBaseClass\r\n  {\r\n      public new int Ignored_New_Property { get; set; } = 1;\r\n  }\r\n  \r\n  public abstract class AbstractBaseClass\r\n  {\r\n      [JsonIgnore]\r\n      public int Ignored_New_Property { get; set; } = 2;\r\n  }\r\n```\r\n\r\n### Test case success 2\r\n```cs\r\n  string json = JsonSerializer.Serialize(new ConcreteDerivedClass());\r\n  // Correctly returns \"{\\\"Ignored_New_Property\\\":2}\"\r\n  \r\n  public class ConcreteDerivedClass : AbstractBaseClass\r\n  {\r\n      [JsonIgnore]\r\n      public new int Ignored_New_Property { get; set; } = 1;\r\n  }\r\n  \r\n  public abstract class AbstractBaseClass\r\n  {\r\n      public int Ignored_New_Property { get; set; } = 2;\r\n  }\r\n```\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>steveharter</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`area-System.Text.Json`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2021-09-27T21:47:25Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-09-27T21:47:25Z",
          "id": "IC_kwDODI9FZc43VQYK"
        }
      ],
      "totalCount": 1,
      "endCursor": "Y3Vyc29yOnYyOpHON1UGCg=="
    },
    "url": "https://github.com/dotnet/runtime/issues/59675",
    "title": "The 'new' modifier doesn't always work with [JsonIgnore]"
  },
  {
    "author": "florianbader",
    "labels": [
      "bug",
      "area-System.Text.Json",
      "breaking-change"
    ],
    "createdAt": "2021-10-18T15:49:19Z",
    "body": "### Description\n\nImplementing a custom converter for a Dictionary<string, object> is used to serialize JsonExtensionData properties but there is no way for the converter to know if it is serializing an extension property or a dictionary property. Because of that invalid JSON is generated.\r\n\n\n### Reproduction Steps\n\nSee fiddle: https://dotnetfiddle.net/VIrtyu\n\n### Expected behavior\n\nThe custom converter should have a way to check if the current write operation value is json extension data. \r\n`{\"RegularData\":{\"World\":\"Hello\"},\"Hello\":\"World\"}`\n\n### Actual behavior\n\nThe custom converter does not know if it json extension data and therefore writes an object instead of weaving the properties into the parent.\r\n`{\"RegularData\":{\"World\":\"Hello\"},{\"Hello\":\"World\"}}`\n\n### Regression?\n\n_No response_\n\n### Known Workarounds\n\n_No response_\n\n### Configuration\n\n.NET 5, System.Text.Json 5.0.2\n\n### Other information\n\nMight be related to https://github.com/dotnet/runtime/issues/32903",
    "number": 60560,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-10-25T10:08:16Z",
          "user": "eiriktsarpalis"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-10-25T18:42:32Z",
          "user": "nextdracool"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-11-02T10:58:24Z",
          "user": "WeihanLi"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-11-19T07:49:03Z",
          "user": "NUlliiON"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-01-10T16:34:13Z",
          "user": "AndreaCuneo"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-05-25T14:07:17Z",
          "user": "soargon"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-07-12T07:42:58Z",
          "user": "xsoheilalizadeh"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-07-29T07:42:35Z",
          "user": "amis92"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-04-14T09:46:09Z",
          "user": "dlyz"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-08-23T03:55:52Z",
          "user": "IvanJosipovic"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-11-22T15:45:33Z",
          "user": "bachratyg"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-12-05T12:10:54Z",
          "user": "miroljub1995"
        },
        {
          "content": "EYES",
          "createdAt": "2024-07-17T20:55:12Z",
          "user": "Gladskih"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-09-13T17:43:04Z",
          "user": "mircogericke"
        }
      ],
      "totalCount": 14,
      "endCursor": "Y3Vyc29yOnYyOpHOC7Aa-Q=="
    },
    "updatedAt": "2024-01-12T15:08:03Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": "jeffhandley",
          "body": "Tagging @dotnet/area-system-text-json since the bot didn't.",
          "createdAt": "2021-10-18T20:52:14Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-10-18T20:52:14Z",
          "id": "IC_kwDODI9FZc44ZTAj"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Can reproduce, minimal repro:\r\n```csharp\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing System.Text.Json;\r\nusing System.Text.Json.Serialization;\r\n\r\nvar value = new MyClass { ExtData = { [\"Hello\"] = \"World\" } };\r\nvar settings = new JsonSerializerOptions { Converters = { new CustomDictionaryConverter() } };\r\nstring json = JsonSerializer.Serialize(value, settings);\r\nConsole.WriteLine(json); // {42}\r\n\r\npublic class MyClass\r\n{\r\n    [JsonExtensionData]\r\n    public Dictionary<string, object> ExtData { get; set; } = new Dictionary<string, object>();\r\n}\r\n\r\npublic class CustomDictionaryConverter : JsonConverter<Dictionary<string, object?>>\r\n{\r\n    public override Dictionary<string, object?> Read(ref Utf8JsonReader reader, Type? typeToConvert, JsonSerializerOptions options)\r\n        => throw new NotSupportedException();\r\n\r\n    public override void Write(Utf8JsonWriter writer, Dictionary<string, object?> values, JsonSerializerOptions options)\r\n        => writer.WriteNumberValue(42);\r\n}\r\n```\r\n\r\nThis is a bug, I think we need to make `JsonExtensionData` properties ignore custom converters, since it is bound to generate invalid JSON.",
          "createdAt": "2021-10-19T13:32:19Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-10-19T13:32:19Z",
          "id": "IC_kwDODI9FZc44bevM"
        },
        {
          "author": "nextdracool",
          "body": "As shown in #60806 this also happens when using `JsonObject`. As a workaround you can define a converter, that writes the `JsonObject`'s properties directly without writing the start and end of an object. You can then successfully serialize the object, but deserialization causes an exception: `System.InvalidOperationException: 'A custom converter for JsonObject is not allowed on an extension property.'`.\r\n\r\nGiven that it is apparently not allowed to add a custom converter to the `JsonObject` extension property during deserialization it would make sense to ignore present custom converters during serialization as well. Any explicitly added custom converter should probably throw the same exception when serializing as it does when deserializng.",
          "createdAt": "2021-10-25T18:49:22Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-10-25T18:49:22Z",
          "id": "IC_kwDODI9FZc44skvV"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Minimal reproduction using `JsonObject` without a custom converter:\r\n```csharp\r\nusing System;\r\nusing System.Text.Json;\r\nusing System.Text.Json.Nodes;\r\nusing System.Text.Json.Serialization;\r\n\r\nPerson value = new() { Extensions = new() { [\"Key\"] = 42 } };\r\nConsole.WriteLine(JsonSerializer.Serialize(value));\r\n\r\npublic class Person\r\n{\r\n    [JsonExtensionData]\r\n    public JsonObject? Extensions { get; set; }\r\n}\r\n```",
          "createdAt": "2021-11-02T10:44:18Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-11-02T10:44:18Z",
          "id": "IC_kwDODI9FZc45D5TN"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Upon closer inspection, it appears that this is by-design behavior. Registering custom converters for extension data properties is a supported scenario, but converters need to be written in a way that accounts for the fact that the types are being used as extension data:\r\n\r\nhttps://github.com/dotnet/runtime/blob/cd75ae127698b66821b5a2d364aa5ff7aa1a4a2a/src/libraries/System.Text.Json/tests/Common/ExtensionDataTests.cs#L366-L403\r\n\r\nWriting converters in this way violates the invariants of `JsonConverter`, and almost certainly renders the types non-serializable for any usage beyond extension data. Conversely, using a custom `JsonConverter` that honors the serialization invariants for the type will result in invalid JSON being produced by the serializer (this is because `JsonSerializerOptions` is [skipping validation for `Utf8JsonWriter` by default](https://github.com/dotnet/runtime/blob/cd75ae127698b66821b5a2d364aa5ff7aa1a4a2a/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/JsonSerializerOptions.cs#L699-L701)).\r\n\r\nMy recommendation would be to introduce a breaking change here, I don't see real value in customizing extension data serialization and the current behavior sets up users for emitting invalid JSON, even though they might have never intended to customize extension data serialization.\r\n\r\n@krwq @steveharter thoughts?",
          "createdAt": "2022-07-19T17:35:06Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-07-19T17:35:06Z",
          "id": "IC_kwDODI9FZc5G5FfS"
        },
        {
          "author": "krwq",
          "body": "@eiriktsarpalis I agree extension data properties should not use global converters (whatever is set on options or type) but it should still respect any `JsonConverter` attribute on the property and `CustomConverter` on `JsonPropertyInfo`",
          "createdAt": "2022-07-20T08:22:08Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-07-20T08:22:08Z",
          "id": "IC_kwDODI9FZc5G7Zf2"
        },
        {
          "author": "eiriktsarpalis",
          "body": "> it should still respect any JsonConverter attribute on the property and CustomConverter on JsonPropertyInfo\r\n\r\nThe problem is that it cannot do that unless the converter has been written in way such that properties are emitted without any curly braces (see example above). It's a pit of failure that breaks the composition model for converters (hence the invalid JSON being reported in this issue). I think we should consider making a breaking change in the future.",
          "createdAt": "2022-07-20T11:01:02Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-07-20T11:01:02Z",
          "id": "IC_kwDODI9FZc5G8AFZ"
        },
        {
          "author": "amis92",
          "body": "Just wanted to say, using `JsonNode` for `JsonExtensionData` underlying type is very convenient in terms of usage, and works today for deserialization (it's not documented, but there's a unit test supporting it). Also arrived here from #60806 . Making it work for serialization correctly would be appreciated. It's also very problematic because, as mentioned, fixing it is virtually impossible (adding converter to make serialization work disables deserialization).\r\n\r\nSupporting unit test:\r\n\r\nhttps://github.com/dotnet/runtime/blob/b6115b0041222802a5693ed412efcdac1ab091f7/src/libraries/System.Text.Json/tests/Common/ExtensionDataTests.cs#L786-L795",
          "createdAt": "2022-07-29T07:50:54Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-07-29T07:50:54Z",
          "id": "IC_kwDODI9FZc5Hdw4x"
        },
        {
          "author": "layomia",
          "body": "> Just wanted to say, using `JsonNode` for `JsonExtensionData` underlying type is very convenient in terms of usage, and works today for deserialization (it's not documented, but there's a unit test supporting it). Also arrived here from #60806 . Making it work for serialization correctly would be appreciated. It's also very problematic because, as mentioned, fixing it is virtually impossible (adding converter to make serialization work disables deserialization).\r\n> \r\n> Supporting unit test:\r\n> \r\n> https://github.com/dotnet/runtime/blob/b6115b0041222802a5693ed412efcdac1ab091f7/src/libraries/System.Text.Json/tests/Common/ExtensionDataTests.cs#L786-L795\r\n\r\n@amis92 this strikes me as a separate issue. Can you please open a new one with this info, also describing the issues you're having with serialization?",
          "createdAt": "2022-12-02T18:21:09Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-12-02T18:21:09Z",
          "id": "IC_kwDODI9FZc5PnF20"
        },
        {
          "author": "springy76",
          "body": "Just having written code on net7 which overwrote some json files on which the reading app now crashes because they are invalid now due to this problem - now I remember having tried the same on net6 and got weird results, too; by the time thought I was using something in beta stage.\r\n\r\nOk, what exactly tells me here that JsonObject cannot be used for serialization but only deserialization?\r\n```c#\r\n// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\n\r\nnamespace System.Text.Json.Serialization\r\n{\r\n    /// <summary>\r\n    /// When placed on a property or field of type <see cref=\"System.Text.Json.Nodes.JsonObject\"/> or\r\n    /// <see cref=\"System.Collections.Generic.IDictionary{TKey, TValue}\"/>, any properties that do not have a\r\n    /// matching property or field are added during deserialization and written during serialization.\r\n    /// </summary>\r\n    /// <remarks>\r\n    /// When using <see cref=\"System.Collections.Generic.IDictionary{TKey, TValue}\"/>, the TKey value must be <see cref=\"string\"/>\r\n    /// and TValue must be <see cref=\"JsonElement\"/> or <see cref=\"object\"/>.\r\n    ///\r\n    /// During deserializing with a <see cref=\"System.Collections.Generic.IDictionary{TKey, TValue}\"/> extension property with TValue as\r\n    /// <see cref=\"object\"/>, the type of object created will either be a <see cref=\"System.Text.Json.Nodes.JsonNode\"/> or a\r\n    /// <see cref=\"JsonElement\"/> depending on the value of <see cref=\"System.Text.Json.JsonSerializerOptions.UnknownTypeHandling\"/>.\r\n    ///\r\n    /// If a <see cref=\"JsonElement\"/> is created, a \"null\" JSON value is treated as a JsonElement with <see cref=\"JsonElement.ValueKind\"/>\r\n    /// set to <see cref=\"JsonValueKind.Null\"/>, otherwise a \"null\" JSON value is treated as a <c>null</c> object reference.\r\n    ///\r\n    /// During serializing, the name of the extension data member is not included in the JSON;\r\n    /// the data contained within the extension data is serialized as properties of the JSON object.\r\n    ///\r\n    /// If there is more than one extension member on a type, or the member is not of the correct type,\r\n    /// an <see cref=\"InvalidOperationException\"/> is thrown during the first serialization or deserialization of that type.\r\n    /// </remarks>\r\n    [AttributeUsage(AttributeTargets.Property | AttributeTargets.Field, AllowMultiple = false)]\r\n    public sealed class JsonExtensionDataAttribute : JsonAttribute\r\n    {\r\n    }\r\n}\r\n```\r\n\r\nDoesn't look like \"not documented\" to me.",
          "createdAt": "2022-12-05T16:25:42Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-12-05T16:32:33Z",
          "id": "IC_kwDODI9FZc5Puxj6"
        },
        {
          "author": "layomia",
          "body": "> Ok, what exactly tells me here that JsonObject cannot be used for serialization but only deserialization?\r\n\r\nIt appears to be supported for serialization. What do you expect for the following?\r\n\r\n```cs\r\nusing System;\r\nusing System.Text.Json;\r\nusing System.Text.Json.Nodes;\r\nusing System.Text.Json.Serialization;\r\n\t\t\t\t\t\r\npublic class Program\r\n{\r\n    public static void Main()\r\n    {\r\n\tJsonObject overflow = new JsonObject() { [\"Hello\"] = \"World\" };\r\n\tClassWithExtensionPropertyAsJsonObject obj = new() { MyOverflow = overflow  };\r\n        string json = JsonSerializer.Serialize(overflow);\r\n        Console.WriteLine(json);\r\n    }\r\n\t\r\n    public class ClassWithExtensionPropertyAsJsonObject\r\n    {\r\n\t[JsonExtensionData]\r\n        public JsonObject MyOverflow { get; set; }\r\n    }\r\n}\r\n```\r\n\r\nI expect `{\"Hello\":\"World\"}`.",
          "createdAt": "2022-12-20T18:06:07Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-12-20T18:06:07Z",
          "id": "IC_kwDODI9FZc5RDthH"
        },
        {
          "author": "springy76",
          "body": "I expect a Json serializer to generate json - and not something which looks like json but cannot be parsed by any json parser out in the world. But the latter is what happens.",
          "createdAt": "2022-12-21T08:16:55Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-12-23T11:47:44Z",
          "id": "IC_kwDODI9FZc5RHw78"
        },
        {
          "author": "amis92",
          "body": "> > Just wanted to say, using `JsonNode` for `JsonExtensionData` underlying type is very convenient in terms of usage, and works today for deserialization (it's not documented, but there's a unit test supporting it). Also arrived here from #60806 . Making it work for serialization correctly would be appreciated. It's also very problematic because, as mentioned, fixing it is virtually impossible (adding converter to make serialization work disables deserialization).\r\n> > Supporting unit test:\r\n> > https://github.com/dotnet/runtime/blob/b6115b0041222802a5693ed412efcdac1ab091f7/src/libraries/System.Text.Json/tests/Common/ExtensionDataTests.cs#L786-L795\r\n> \r\n> @amis92 this strikes me as a separate issue. Can you please open a new one with this info, also describing the issues you're having with serialization?\r\n\r\n@layomia I believe it's the same issue. This one was opened specifically for custom converters for `[JsonExtensionData] Dictionary<string, object>`, but quickly was widened to include JsonExtensionData on JsonObject (as it is also caused by a converter, although built-in - original issue #60806 was closed in favor of this one), and I believe the same issue is with JsonNode (issue being built-in converter used for extension data property).",
          "createdAt": "2022-12-23T10:44:36Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-12-23T10:46:36Z",
          "id": "IC_kwDODI9FZc5RSojB"
        },
        {
          "author": "layomia",
          "body": "In general I think a separate, internal converter should be used to handle extension data. We could support a custom converter applied with [`JsonConverter]` attribute. Taking a breaking change early in the release to get more sensible semantics might be worth it.",
          "createdAt": "2023-01-12T21:01:25Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "HOORAY",
                "createdAt": "2023-01-13T09:46:32Z",
                "user": "amis92"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOCymK5A=="
          },
          "updatedAt": "2023-01-12T21:01:25Z",
          "id": "IC_kwDODI9FZc5SUDlT"
        },
        {
          "author": "fknshwow",
          "body": "Has there been any progress on this issue? Or even a work around for the time being?\r\n\r\nThis has been open for a while, I hope there is still appetite to get this resolved.",
          "createdAt": "2023-07-13T06:10:33Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-07-13T06:10:33Z",
          "id": "IC_kwDODI9FZc5hXufa"
        },
        {
          "author": "eiriktsarpalis",
          "body": "@lukecusolito it's been parked for a while since upon closer inspection this is by design, see https://github.com/dotnet/runtime/issues/60560#issuecomment-1189369810. I still think it needs to be fixed, but that would need to be flagged as a breaking change and we should be providing a workaround for users that do depend on the current behavior. It certainly won't be changed for .NET 8.",
          "createdAt": "2023-07-13T09:34:25Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "CONFUSED",
                "createdAt": "2023-07-13T10:09:42Z",
                "user": "amis92"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHODAlKCA=="
          },
          "updatedAt": "2023-07-13T11:00:05Z",
          "id": "IC_kwDODI9FZc5hY1Xq"
        },
        {
          "author": "wzchua",
          "body": "The documentation should be updated to not say you can use JsonObject",
          "createdAt": "2023-07-13T10:24:04Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-07-13T10:24:04Z",
          "id": "IC_kwDODI9FZc5hZHO_"
        },
        {
          "author": "fknshwow",
          "body": "@eiriktsarpalis Look a good workaround would be fantastic if one can be provided. The system I am building is dependent on on dynamic data, this is the only piece of the puzzle that does not work.\r\n\r\nThe current workaround I have in place is to serialize my JsonObject into a string and then deserialize to a Dictionary<string, JsonElement> then assigning to a JsonExtensionData property on my response class. It sucks, but it is 'temporary' until I come up with something better.\r\n\r\nThe problem is from what I can see, I doesn't look like there is anyway to convert a JsonObject into either a JsonDocument or a JsonElement without first converting to and from a string due to their immutable nature.\r\n\r\nI am going to explore a JsonConverter next, if you have a good workaround I would be greatly appreciative. I will post what I have if I can get it to work.\r\n\r\nIf support for this is dropped, then there needs to be an efficient way to convert to a JsonDocument or JsonElement, maybe some way to parse from a JsonObject",
          "createdAt": "2023-07-14T00:07:15Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-07-14T00:18:37Z",
          "id": "IC_kwDODI9FZc5hdUN_"
        },
        {
          "author": "fknshwow",
          "body": "Okay, I have 2 potential workarounds for anyone interested. Keeping in mind that my requirements only need me to write to an API response object so my samples are only going one way.\r\n\r\n**Option 1 - Custom Converter**\r\nThis is a very basic implementation, I think there could be some modifications to consider null values. It basically loops through the root elements of the JsonObject and writes their property name and value using the JsonNode.WriteTo() method. Note that the JsonExtensionData attribute is still required on the response class\r\n```csharp\r\npublic class CustomJsonObjectOverflowConverter : JsonConverter<JsonObject>\r\n{\r\n    public override JsonObject Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)\r\n    {\r\n        throw new NotImplementedException();\r\n    }\r\n\r\n    public override void Write(Utf8JsonWriter writer, JsonObject value, JsonSerializerOptions options)\r\n    {\r\n        foreach (var item in value)\r\n        {\r\n            writer.WritePropertyName(item.Key);\r\n\r\n            item.Value.WriteTo(writer, options);\r\n        }\r\n    }\r\n}\r\n\r\npublic class JsonObjectResponse\r\n{\r\n    // JsonExtensionData attribute is still required. If not supplied the property name (\"Value\") still gets written to the response body\r\n    [JsonExtensionData]\r\n    [JsonConverter(typeof(CustomJsonObjectOverflowConverter))]\r\n    public JsonObject Value { get; set; }\r\n\r\n    ...\r\n}\r\n```\r\n\r\n\r\n**Option 2 - Convert type**\r\nThis will take a JsonObject and convert it to a Dictionary<string, JsonElement>. This is clean but means the data will be written twice, once in the constructor when we deserialize to a dictionary and again when the API writes the response. From what I understand, JsonNode.Deserialize() internally works much like custom converter from option 1, it too will write using a Utf8JsonWriter and does not need to go to and from a string\r\n```csharp\r\npublic class JsonObjectResponse\r\n{\r\n    public JsonObjectResponse(JsonObject jsonObject)\r\n    {\r\n        Value = jsonObject.Deserialize<Dictionary<string, JsonElement>>();\r\n    }\r\n    \r\n    [JsonExtensionData]\r\n    public Dictionary<string, JsonElement> Value { get; set; }\r\n    \r\n    ...\r\n}\r\n```\r\n\r\nI am interested in your thoughts on these workarounds. I feel option 2 is safer as it uses first party mechanisms but double handling the data might have an impact on performance",
          "createdAt": "2023-07-14T01:59:48Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-07-14T02:05:32Z",
          "id": "IC_kwDODI9FZc5hdno4"
        },
        {
          "author": "bachratyg",
          "body": "> **Option 1 - Custom Converter** \r\n\r\nUnfortunately this does not work for deserialization. `JsonConverter.ReadElementAndSetProperty` throws and should be overriden just like in JsonObjectConverter, but it's internal.",
          "createdAt": "2023-11-22T16:07:19Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-11-22T16:07:19Z",
          "id": "IC_kwDODI9FZc5sqaN7"
        },
        {
          "author": "JanEggers",
          "body": "same issue here with ProblemDetails retuned by asp.net ",
          "createdAt": "2024-01-12T15:08:02Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-01-12T15:08:02Z",
          "id": "IC_kwDODI9FZc5wnu1k"
        }
      ],
      "totalCount": 21,
      "endCursor": "Y3Vyc29yOnYyOpHOcJ7tZA=="
    },
    "url": "https://github.com/dotnet/runtime/issues/60560",
    "title": "System.Text.Json custom converter for Dictionary<string, object> collides with JsonExtensionData"
  },
  {
    "author": "eiriktsarpalis",
    "labels": [
      "api-suggestion",
      "area-System.Text.Json",
      "wishlist"
    ],
    "createdAt": "2021-10-22T19:34:17Z",
    "body": "### Background and motivation\r\n\r\nCurrently System.Text.Json has no support for serializing `BigInteger` values. This is a proposal for serializing `BigInteger` values as arbitrarily sized JSON numbers.\r\n\r\n### API Proposal\r\n\r\n```C#\r\nnamespace System.Text.Json\r\n{\r\n    public ref partial struct Utf8JsonReader\r\n    {\r\n+        public BigInteger GetBigInteger();\r\n+        public bool TryGetBigInteger(out BigInteger value);\r\n    }\r\n\r\n    public sealed partial class Utf8JsonWriter\r\n    {\r\n+        public void WriteNumber(JsonEncodedText propertyName, BigInteger value);\r\n+        public void WriteNumber(string propertyName, BigInteger value);\r\n+        public void WriteNumber(ReadOnlySpan<char> propertyName, BigInteger value);\r\n+        public void WriteNumber(ReadOnlySpan<byte> utf8PropertyName, BigInteger value);\r\n+        public void WriteNumberValue(BigInteger value);\r\n    }\r\n\r\n    public readonly partial struct JsonElement\r\n    {\r\n+        public BigInteger GetBigInteger();\r\n+        public bool TryGetBigInteger(out BigInteger value)\r\n    }\r\n}\r\n\r\nnamespace System.Text.Json.Node\r\n{\r\n    public abstract partial class JsonNode\r\n    {\r\n+        public static explicit operator BigInteger(JsonNode value);\r\n+        public static explicit operator BigInteger?(JsonNode? value);\r\n+        public static implicit operator JsonNode(BigInteger value);\r\n+        public static implicit operator JsonNode?(BigInteger? value);\r\n    }\r\n}\r\n\r\nnamespace System.Text.Json.Serialization.Metadata\r\n{\r\n    public static partial class JsonMetadataServices\r\n    {\r\n+        public static JsonConverter<BigInteger> BigIntegerConverter { get; }\r\n    }\r\n}\r\n```     \r\n\r\n\r\n### API Usage\r\n\r\n```C#\r\nJsonSerializer.Serialize((BigInteger)42);\r\n\r\n// Current JSON: {\"IsPowerOfTwo\":false,\"IsZero\":false,\"IsOne\":false,\"IsEven\":true,\"Sign\":1}\r\n// New JSON: 42\r\n```\r\n\r\n### Alternative Designs\r\n\r\n_No response_\r\n\r\n### Risks\r\n\r\n_No response_",
    "number": 60780,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-10-22T19:36:03Z",
          "user": "Tornhoof"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-10-24T21:44:46Z",
          "user": "martincostello"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2021-10-31T17:53:56Z",
          "user": "dmpe"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-02-09T06:06:52Z",
          "user": "bmeredith"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-08-27T18:46:14Z",
          "user": "akintos"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-01-14T10:51:46Z",
          "user": "elgonzo"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-04-06T07:46:36Z",
          "user": "PaulusParssinen"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-05-17T10:56:30Z",
          "user": "timaiv"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-06-08T17:47:31Z",
          "user": "BoutemineOualid"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-07-18T01:26:01Z",
          "user": "aradalvand"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-02-07T01:14:09Z",
          "user": "shonk-msft"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-02-24T19:16:23Z",
          "user": "tpaananen"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-06-08T16:40:03Z",
          "user": "IlyaBelitser"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-06-20T15:48:30Z",
          "user": "DoctorKrolic"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-08-27T21:02:39Z",
          "user": "ItsDaveB"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-03-11T00:47:18Z",
          "user": "lipchev"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-04-28T09:26:35Z",
          "user": "Hawxy"
        }
      ],
      "totalCount": 17,
      "endCursor": "Y3Vyc29yOnYyOpHODBynzQ=="
    },
    "updatedAt": "2025-01-17T12:11:04Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\n### Background and motivation\n\nCurrently System.Text.Json has no support for serializing `BigInteger` values. This is a proposal for serializing `BigInteger` values as arbitrarily sized JSON numbers.\n\n### API Proposal\n\n```C#\r\nnamespace System.Text.Json\r\n{\r\n    public ref partial struct Utf8JsonReader\r\n    {\r\n+        public BigInteger GetBigInteger();\r\n+        public bool TryGetBigInteger(out BigInteger value);\r\n    }\r\n\r\n    public sealed partial class Utf8JsonWriter\r\n    {\r\n+        public void WriteNumber(JsonEncodedText propertyName, BigInteger value);\r\n+        public void WriteNumber(string propertyName, BigInteger value);\r\n+        public void WriteNumber(ReadOnlySpan<char> propertyName, BigInteger value);\r\n+        public void WriteNumber(ReadOnlySpan<byte> utf8PropertyName, BigInteger value);\r\n+        public void WriteNumberValue(BigInteger value);\r\n    }\r\n\r\n    public readonly partial struct JsonElement\r\n    {\r\n+        public BigInteger GetBigInteger();\r\n+        public bool TryGetBigInteger(out BigInteger value)\r\n    }\r\n}\r\n\r\nnamespace System.Text.Json.Node\r\n{\r\n    public abstract partial class JsonNode\r\n    {\r\n+        public static explicit operator BigInteger(JsonNode value);\r\n+        public static explicit operator BigInteger?(JsonNode? value);\r\n+        public static implicit operator JsonNode(BigInteger value);\r\n+        public static implicit operator JsonNode?(BigInteger? value);\r\n    }\r\n}\r\n\r\nnamespace System.Text.Json.Serialization.Metadata\r\n{\r\n    public static partial class JsonMetadataServices\r\n    {\r\n+        public static JsonConverter<BigInteger> BigIntegerConverter { get; }\r\n    }\r\n}\r\n```     \r\n\n\n### API Usage\n\nJsonSerializer.Serialize((BigInteger)42);\r\n\r\n// Current JSON: {\"IsPowerOfTwo\":false,\"IsZero\":false,\"IsOne\":false,\"IsEven\":true,\"Sign\":1}\r\n// New JSON: 42\n\n### Alternative Designs\n\n_No response_\n\n### Risks\n\n_No response_\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>eiriktsarpalis</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`api-suggestion`, `area-System.Text.Json`, `untriaged`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2021-10-22T19:34:21Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-10-22T19:34:21Z",
          "id": "IC_kwDODI9FZc44nnw8"
        },
        {
          "author": "eiriktsarpalis",
          "body": "From @Tornhoof in https://github.com/dotnet/runtime/issues/60763#issuecomment-949648322\r\n\r\n> Fwiw, the recommendation for Numbers in JSON is usually ~ 54 bit. See https://datatracker.ietf.org/doc/html/rfc8259#section-6 Most Implementations work fine with 64bit, everything above is lottery.\r\n> \r\n> That being said, Biginteger implements ISpanFormattable, which might be the better target for Implementation.",
          "createdAt": "2021-10-22T19:36:06Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-02-24T19:16:31Z",
                "user": "tpaananen"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHODYFf5w=="
          },
          "updatedAt": "2021-10-22T19:36:06Z",
          "id": "IC_kwDODI9FZc44nn_V"
        },
        {
          "author": "eiriktsarpalis",
          "body": "From @tannergooding in https://github.com/dotnet/runtime/issues/60763#issuecomment-949849458\r\n\r\n\r\n\r\n\r\n> > Fwiw, the recommendation for Numbers in JSON is usually ~ 54 bit.\r\n> \r\n> Just noting that its 53-bits. Whole integers up to 2^53 (`9007199254740992`) can be accurately represented by a double-precision floating-point value. After that, you can only represent multiples of 2 (even numbers), up until the next power of two. This means that for values between 2^53 (`9007199254740992`) and 2^54 (`18014398509481984`) you cannot represent `odd` numbers and so you cannot represent `9,007,199,254,740,993` for example (it rounds down). This continues doubling every power of 2, so at `2^54` you can only represent multiples of `4`, then `8` at 2^55, etc; all the way up to multiples of `2048` at 2^63; and then continuing up to `double.MaxValue` in the same pattern.\r\n> \r\n> > Sure, but I would interpret the wording in that section as a recommendation for improved interoperability rather than something mandated by the spec\r\n> \r\n> I'd agree. While this is best for interoperability, its not required and as far as the spec is concerned larger numbers are valid, so there should be no \"issue\" in printing larger values from BigInteger. Handling \"portability\" recommendations would likely involve telling users to actually track a type and exclusively use strings for representing numbers (which also covers things like nan, infinity, negative zero, etc).\r\n\r\n",
          "createdAt": "2021-10-22T19:36:44Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-10-22T19:36:44Z",
          "id": "IC_kwDODI9FZc44noEf"
        },
        {
          "author": "Tornhoof",
          "body": "I looked at other JSON implementations, apparently most simply write it as a number.\r\nThere is even https://www.npmjs.com/package/json-bigint, which bypasses the bigint in javascript problem.\r\nSo i withdraw my objections.",
          "createdAt": "2021-10-22T19:40:42Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-10-22T19:41:41Z",
                "user": "eiriktsarpalis"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-10-22T19:45:45Z",
                "user": "ststeiger"
              }
            ],
            "totalCount": 2,
            "endCursor": "Y3Vyc29yOnYyOpHOB_hARQ=="
          },
          "updatedAt": "2021-10-22T19:40:42Z",
          "id": "IC_kwDODI9FZc44nolS"
        },
        {
          "author": "jkotas",
          "body": "Is this going to make BigInteger rooted for trimming in any use of `System.Text.Json`?",
          "createdAt": "2021-10-22T19:57:04Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-10-22T19:57:18Z",
          "id": "IC_kwDODI9FZc44nqqm"
        },
        {
          "author": "eiriktsarpalis",
          "body": "> Is this going to make BigInteger rooted for trimming in any use of System.Text.Json?\r\n\r\nYes.",
          "createdAt": "2021-10-23T09:53:45Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-10-23T09:53:45Z",
          "id": "IC_kwDODI9FZc44oceQ"
        },
        {
          "author": "jkotas",
          "body": "It means that this feature would introduce noticeable size regression for minimal Blazor apps where we care about size a lot. I doubt it would be acceptable. Features like this one have to be designed as opt-in.\r\n\r\ncc @marek-safar  ",
          "createdAt": "2021-10-23T13:17:01Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-10-23T13:17:01Z",
          "id": "IC_kwDODI9FZc44oil-"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Definitely, and this is really a concern with any type we propose to support OOTB (e.g. #53539). I don't think this should be preventing us from adding OOTB support for new types altogether, but we should definitely be weighing in the value of each proposal on a case-by-case basis.\r\n\r\n> Features like this one have to be designed as opt-in.\r\n\r\nI'm slightly concerned about the UX of needing to opt in to a valid serialization of a type we claim to support OOTB. Not supporting it at all is likely preferable (though I would need to check if a custom converter workaround is currently possible: it's not clear to me if `Utf8JsonReader` currently supports reading arbitrarily large JSON numbers).",
          "createdAt": "2021-10-25T09:56:18Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-10-25T10:06:26Z",
          "id": "IC_kwDODI9FZc44qy0m"
        },
        {
          "author": "stephentoub",
          "body": "> I don't think this should be preventing us from adding OOTB support for new types altogether, but we should definitely be weighing in the value of each proposal on a case-by-case basis.\r\n\r\nI agree we need to come up with an alternate approach that enables us to add in such support without rooting everything.  The current path isn't sustainable.",
          "createdAt": "2021-10-25T12:17:11Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-10-25T12:17:11Z",
          "id": "IC_kwDODI9FZc44rRFA"
        },
        {
          "author": "jkotas",
          "body": "Another point to consider is that supporting new types like BigInteger is behavior breaking change. You can argue that nobody should be depending on the current non-sensical behavior and I accept that, but it just makes it more acceptable breaking change.\r\n\r\n>  alternate approach that enables us to add in such support without rooting everything\r\n\r\nAdd support for new types for source generators only?",
          "createdAt": "2021-10-25T12:55:08Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-10-25T12:55:08Z",
          "id": "IC_kwDODI9FZc44rYJ1"
        },
        {
          "author": "layomia",
          "body": "> Add support for new types for source generators only?\r\n\r\nSeems like a hard stance to take for right now as the feature stabilizes. However, this is the latest thinking based on 6.0 discussions: that the reflection serializer would be characterized as unfriendly for trimming by-design, and that folks that care about size should use the generator. cc @eerhardt\r\n\r\n--- \r\n\r\nWhat's the motivation for the API proposal for .NET 7.0? Custom user converters can handle `BigInteger`. If best perf is required, we  could pursue https://github.com/dotnet/runtime/issues/54410 (non-allocating view on string props when reading) and leverage the new [Utf8JsonWriter.WriteRawValue](https://docs.microsoft.com/dotnet/api/system.text.json.utf8jsonwriter.writerawvalue?view=net-6.0) methods.",
          "createdAt": "2021-10-25T19:00:14Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-10-25T19:06:58Z",
          "id": "IC_kwDODI9FZc44smor"
        },
        {
          "author": "eiriktsarpalis",
          "body": "> What's the motivation for the API proposal for .NET 7.0?\r\n\r\nNo particular motivation. I added it to the 7.0.0 milestone so that it can be considered during our planning. I should add this is merely transcribing the ask in #60763 into an API proposal.",
          "createdAt": "2021-10-25T19:02:14Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-10-25T19:03:39Z",
          "id": "IC_kwDODI9FZc44snCA"
        },
        {
          "author": "eiriktsarpalis",
          "body": "> If best perf is required, we could pursue #54410 (non-allocating view on string props when reading)\r\n\r\nNote that the particular use case would require extending the feature to also include JSON numbers.",
          "createdAt": "2021-10-25T19:04:32Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2021-10-25T19:07:09Z",
                "user": "layomia"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOB_waCQ=="
          },
          "updatedAt": "2021-10-25T19:04:32Z",
          "id": "IC_kwDODI9FZc44snid"
        },
        {
          "author": "jkotas",
          "body": "> > Add support for new types for source generators only?\r\n\r\n> Seems like a hard stance to take for right now as the feature stabilizes\r\n\r\nI do not think that the reflection-based serializers are a sustainable choice for the core platform. Reflection-based serializers come with too many issues (compatibility and performance in particular). Case in point: All older reflection-based serializers in the core platform are in sustained engineering mode, they are impossible to evolve.",
          "createdAt": "2021-10-25T19:16:00Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-10-25T19:16:00Z",
          "id": "IC_kwDODI9FZc44sp6J"
        },
        {
          "author": "eiriktsarpalis",
          "body": "> It means that this feature would introduce noticeable size regression for minimal Blazor apps where we care about size a lot. I doubt it would be acceptable. Features like this one have to be designed as opt-in.\r\n> \r\n> cc @marek-safar\r\n\r\nI'd like to revisit this concern. Nowadays, any trimmed application using the source generator sees the bulk of built-in converters being trimmed and components are kept on a pay-for-play basis. I don't think this should be a blocker for us introducing built-in support for types, asssuming they are sufficiently popular.\r\n\r\ncc @eerhardt ",
          "createdAt": "2023-02-10T23:58:53Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-02-10T23:58:53Z",
          "id": "IC_kwDODI9FZc5VBsaB"
        },
        {
          "author": "eerhardt",
          "body": "> any trimmed application using the source generator sees the bulk of built-in converters being trimmed and components are kept on a pay-for-play basis\r\n\r\nNote this is true for apps the only support the source generator and disable/disallow reflection fallback for Json serialization. However, Blazor WASM and Maui apps don't fall into that category. Those apps only trim the base libraries, but not the user code. Both app models still use reflection based serialization.",
          "createdAt": "2023-02-13T16:41:49Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-02-13T16:41:49Z",
          "id": "IC_kwDODI9FZc5VIZvF"
        },
        {
          "author": "eiriktsarpalis",
          "body": "> Both app models still use reflection based serialization.\r\n\r\nInteresting, thanks.",
          "createdAt": "2023-02-13T17:56:03Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-02-13T17:56:03Z",
          "id": "IC_kwDODI9FZc5VI7Gy"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Closing in favor of https://github.com/dotnet/runtime/issues/87994",
          "createdAt": "2023-06-24T10:37:16Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-06-24T10:37:16Z",
          "id": "IC_kwDODI9FZc5fsBum"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Reopening since `BigInteger` was cut from #87994. When implementing we might want to consider implementing a max digit threshold when deserializing. Related to https://github.com/dotnet/runtime/pull/55121, which however only applies to `BigInteger` implementations post .NET 7.",
          "createdAt": "2023-06-27T18:52:36Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-06-27T18:52:36Z",
          "id": "IC_kwDODI9FZc5f92rw"
        }
      ],
      "totalCount": 19,
      "endCursor": "Y3Vyc29yOnYyOpHOX_dq8A=="
    },
    "url": "https://github.com/dotnet/runtime/issues/60780",
    "title": "[API Proposal]: Add BigInteger support to System.Text.Json"
  },
  {
    "author": "BRLN1",
    "labels": [
      "enhancement",
      "area-System.Text.Json",
      "wishlist"
    ],
    "createdAt": "2021-11-02T10:42:04Z",
    "body": "### Background and motivation\r\n\r\nI'm trying to serialize a big pdf of around 200MB, while trying to do so I'm getting following error:\r\n\r\n```\r\n---> System.ArgumentException: The JSON value of length 304063897 is too large and not supported.\\r\\n\r\n   at System.Text.Json.ThrowHelper.ThrowArgumentException_ValueTooLarge(Int32 tokenLength)\\r\\n\r\n   at System.Text.Json.Utf8JsonWriter.WriteStringValue(ReadOnlySpan`1 value)\\r\\n\r\n   at System.Text.Json.Serialization.Converters.StringConverter.Write(Utf8JsonWriter writer, String value, JsonSerializerOptions options)\\r\\n\r\n   at System.Text.Json.Serialization.JsonConverter`1.TryWrite(Utf8JsonWriter writer, T& value, JsonSerializerOptions options, WriteStack& state)\\r\\n\r\n   at System.Text.Json.Serialization.JsonConverter`1.WriteCore(Utf8JsonWriter writer, T& value, JsonSerializerOptions options, WriteStack& state)\\r\\n\r\n   at System.Text.Json.Serialization.JsonConverter`1.WriteCoreAsObject(Utf8JsonWriter writer, Object value, JsonSerializerOptions options, WriteStack& state)\\r\\n\r\n   at System.Text.Json.JsonSerializer.WriteCore[TValue](JsonConverter jsonConverter, Utf8JsonWriter writer, TValue& value, JsonSerializerOptions options, WriteStack& state)\\r\\n\r\n   at System.Text.Json.JsonSerializer.WriteAsyncCore[TValue](Stream utf8Json, TValue value, Type inputType, JsonSerializerOptions options, CancellationToken cancellationToken)\\r\\n\r\n   at System.Net.Http.Json.JsonContent.SerializeToStreamAsyncCore(Stream targetStream, Boolean async, CancellationToken cancellationToken)\\r\\n\r\n   at System.Net.Http.HttpContent.<CopyToAsync>g__WaitAsync|56_0(ValueTask copyTask)\\r\\n\r\n   at System.Net.Http.HttpConnection.SendRequestContentAsync(HttpRequestMessage request, HttpContentWriteStream stream, Boolean async, CancellationToken cancellationToken)\\r\\n\r\n   at System.Net.Http.HttpConnection.SendAsyncCore(HttpRequestMessage request, Boolean async, CancellationToken cancellationToken)\\r\\n\r\n   at System.Net.Http.HttpConnection.SendAsyncCore(HttpRequestMessage request, Boolean async, CancellationToken cancellationToken)\\r\\n\r\n   at System.Net.Http.HttpConnectionPool.SendWithRetryAsync(HttpRequestMessage request, Boolean async, Boolean doRequestAuth, CancellationToken cancellationToken)\\r\\n\r\n   at System.Net.Http.RedirectHandler.SendAsync(HttpRequestMessage request, Boolean async, CancellationToken cancellationToken)\\r\\n\r\n   at System.Net.Http.HttpClient.SendAsyncCore(HttpRequestMessage request, HttpCompletionOption completionOption, Boolean async, Boolean emitTelemetryStartStop, CancellationToken cancellationToken)\\r\\n\r\n```\r\n\r\nI found out that current size limitation for that is 125MB. That is definitely too little. I'd make sense to inscrease the cap, possibly to 2GB(like string that contains base64 of pdf or post request) or simply make that user defined. \r\n\r\nIf I'm missing any solution to that problem, I'd appreciate some tips, \r\nThanks!\r\n\r\n",
    "number": 61089,
    "reactions": {
      "hasNextPage": false,
      "nodes": [],
      "totalCount": 0,
      "endCursor": null
    },
    "updatedAt": "2023-10-25T16:55:13Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\n### Background and motivation\n\nI'm trying to serialize a big pdf of around 200MB, while trying to do so I'm getting following error:\r\n---> System.ArgumentException: The JSON value of length 304063897 is too large and not supported.\\r\\n\r\n   at System.Text.Json.ThrowHelper.ThrowArgumentException_ValueTooLarge(Int32 tokenLength)\\r\\n\r\n   at System.Text.Json.Utf8JsonWriter.WriteStringValue(ReadOnlySpan`1 value)\\r\\n\r\n   at System.Text.Json.Serialization.Converters.StringConverter.Write(Utf8JsonWriter writer, String value, JsonSerializerOptions options)\\r\\n\r\n   at System.Text.Json.Serialization.JsonConverter`1.TryWrite(Utf8JsonWriter writer, T& value, JsonSerializerOptions options, WriteStack& state)\\r\\n\r\n   at System.Text.Json.Serialization.JsonConverter`1.WriteCore(Utf8JsonWriter writer, T& value, JsonSerializerOptions options, WriteStack& state)\\r\\n\r\n   at System.Text.Json.Serialization.JsonConverter`1.WriteCoreAsObject(Utf8JsonWriter writer, Object value, JsonSerializerOptions options, WriteStack& state)\\r\\n\r\n   at System.Text.Json.JsonSerializer.WriteCore[TValue](JsonConverter jsonConverter, Utf8JsonWriter writer, TValue& value, JsonSerializerOptions options, WriteStack& state)\\r\\n\r\n   at System.Text.Json.JsonSerializer.WriteAsyncCore[TValue](Stream utf8Json, TValue value, Type inputType, JsonSerializerOptions options, CancellationToken cancellationToken)\\r\\n\r\n   at System.Net.Http.Json.JsonContent.SerializeToStreamAsyncCore(Stream targetStream, Boolean async, CancellationToken cancellationToken)\\r\\n\r\n   at System.Net.Http.HttpContent.<CopyToAsync>g__WaitAsync|56_0(ValueTask copyTask)\\r\\n\r\n   at System.Net.Http.HttpConnection.SendRequestContentAsync(HttpRequestMessage request, HttpContentWriteStream stream, Boolean async, CancellationToken cancellationToken)\\r\\n\r\n   at System.Net.Http.HttpConnection.SendAsyncCore(HttpRequestMessage request, Boolean async, CancellationToken cancellationToken)\\r\\n\r\n   at System.Net.Http.HttpConnection.SendAsyncCore(HttpRequestMessage request, Boolean async, CancellationToken cancellationToken)\\r\\n\r\n   at System.Net.Http.HttpConnectionPool.SendWithRetryAsync(HttpRequestMessage request, Boolean async, Boolean doRequestAuth, CancellationToken cancellationToken)\\r\\n\r\n   at System.Net.Http.RedirectHandler.SendAsync(HttpRequestMessage request, Boolean async, CancellationToken cancellationToken)\\r\\n\r\n   at System.Net.Http.HttpClient.SendAsyncCore(HttpRequestMessage request, HttpCompletionOption completionOption, Boolean async, Boolean emitTelemetryStartStop, CancellationToken cancellationToken)\\r\\n\r\n\r\nI found out that current size limitation for that is 125MB. That is definitely too little. I'd make sense to inscrease the cap, possibly to 2GB(like string that contains base64 of pdf or post request) or simply make that user defined. \r\n\r\nIf I'm missing any solution to that problem, I'd appreciate some tips, \r\nThanks!\n\n### API Proposal\n\n```C#\r\nnamespace System.Collections.Generic\r\n{\r\n    public class MyFancyCollection<T> : IEnumerable<T>\r\n    {\r\n        public void Fancy(T item);\r\n    }\r\n}\r\n```     \r\n\n\n### API Usage\n\n```C#\r\n// Fancy the value\r\nvar c = new MyFancyCollection<int>();\r\nc.Fancy(42);\r\n\r\n// Getting the values out\r\nforeach (var v in c)\r\n    Console.WriteLine(v);\r\n```     \r\n\n\n### Alternative Designs\n\n_No response_\n\n### Risks\n\n_No response_\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>BRLN1</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`api-suggestion`, `area-System.Text.Json`, `untriaged`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2021-11-02T10:42:08Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-11-02T10:42:08Z",
          "id": "IC_kwDODI9FZc45D47D"
        },
        {
          "author": "eiriktsarpalis",
          "body": "This appears to be by design: \r\nhttps://github.com/dotnet/runtime/blob/c690d2731db85933e8b4ab936fa71cd190471194/src/libraries/System.Text.Json/src/System/Text/Json/JsonConstants.cs#L71-L78\r\nBasically the restriction is in place in order to guarantee that the escaped token does fit in a single span segment. That being said, the constant seems to be derived from the rather pessimistic assumption that every single character in the input string needs escaping, in the worst expansion possible.\r\n\r\nI wonder if delaying the check until after we have detected that the string needs escaping might make sense here:\r\nhttps://github.com/dotnet/runtime/blob/4e7cf804c0c89d4316bbe3327ff4fe4441ee953d/src/libraries/System.Text.Json/src/System/Text/Json/Writer/Utf8JsonWriter.WriteValues.String.cs#L82-L96\r\n\r\ncc @ahsonkhan @bartonjs @krwq",
          "createdAt": "2021-11-02T11:20:53Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-11-02T11:20:53Z",
          "id": "IC_kwDODI9FZc45D_iO"
        },
        {
          "author": "Tornhoof",
          "body": "Not a solution, but maybe a workaround, if you need to serialize the pdf for Elasticsearch ingest pipelines, you can also use CBOR to send the data, instead of json.",
          "createdAt": "2021-11-02T19:36:30Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-11-02T19:36:30Z",
          "id": "IC_kwDODI9FZc45G41e"
        }
      ],
      "totalCount": 3,
      "endCursor": "Y3Vyc29yOnYyOpHOORuNXg=="
    },
    "url": "https://github.com/dotnet/runtime/issues/61089",
    "title": "Increase serialization max size or make it user driven for SystemTextJson"
  },
  {
    "author": "layomia",
    "labels": [
      "enhancement",
      "area-System.Text.Json",
      "source-generator"
    ],
    "createdAt": "2021-11-05T19:56:18Z",
    "body": "Many of the [diagnostics](https://github.com/dotnet/runtime/blob/1c7100b0c21a2af147362c7b5c61408611743ded/src/libraries/System.Text.Json/gen/JsonSourceGenerator.Parser.cs#L121-L167) issued by the JSON source generator are also applicable to the reflection-based serializer. For example, a type cannot contain multiple `[JsonConstructor]` applications. When the source generator is used, it logs a compile error when a type violates this expectation. A runtime exception is thrown in the reflection-based serializer instead.\r\n\r\nRather than having different behavior, we could package these diagnostic examinations into an analyzer that could be shared between the source generator and the reflection serializer, potentially giving the reflection serializer less validation work to do at runtime. We'd have to consider where this analyzer would live. There are a couple options\r\n\r\n- it could ship in the same assembly as the source generator ~~(becoming the first analyzer to be shipped in the dotnet/runtime repo)~~\r\n- it could ship with the rest of the analyzers in https://github.com/dotnet/roslyn-analyzers\r\n\r\nThe source generator would be dependent on the analyzer, so we'd need to ship the analyzer in a manner that guarantees its visibility to the source generator.\r\n\r\ncc @dotnet/area-system-text-json @jeffhandley ",
    "number": 61262,
    "reactions": {
      "hasNextPage": false,
      "nodes": [],
      "totalCount": 0,
      "endCursor": null
    },
    "updatedAt": "2022-04-18T15:49:01Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\nMany of the [diagnostics](https://github.com/dotnet/runtime/blob/1c7100b0c21a2af147362c7b5c61408611743ded/src/libraries/System.Text.Json/gen/JsonSourceGenerator.Parser.cs#L121-L167) issued by the JSON source generator are also applicable to the reflection-based serializer. For example, a type cannot contain multiple `[JsonConstructor]` applications. When the source generator is used, it logs a compile error when a type violates this expectation. A runtime exception is thrown in the reflection-based serializer instead.\r\n\r\nRather than having different behavior, we could package these diagnostic examinations into an analyzer that could be shared between the source generator and the reflection serializer, potentially giving the reflection serializer less validation work to do at runtime. We'd have to consider where this analyzer would live. There are a couple options\r\n\r\n- it could ship in the same assembly as the source generator (becoming the first analyzer to be shipped in the dotnet/runtime repo)\r\n- it could ship with the rest of the analyzers in https://github.com/dotnet/roslyn-analyzers\r\n\r\nThe source generator would be dependent on the analyzer, so we'd need to ship the analyzer in a manner that guarantees its visibility to the source generator.\r\n\r\ncc @dotnet/area-system-text-json @jeffhandley \n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>layomia</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`enhancement`, `area-System.Text.Json`, `untriaged`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>7.0.0</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2021-11-05T19:56:24Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-11-05T19:56:24Z",
          "id": "IC_kwDODI9FZc45Wa1n"
        },
        {
          "author": "jkotas",
          "body": "> it could ship in the same assembly as the source generator (becoming the first analyzer to be shipped in the dotnet/runtime repo)\r\n\r\nThe new [DllImportImportGenerator](https://github.com/dotnet/runtime/tree/main/src/libraries/System.Runtime.InteropServices/gen/DllImportGenerator) is same analyzer + source generator bundle. @jkoritzinsky Is that right?",
          "createdAt": "2021-11-05T21:26:38Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-11-05T21:26:38Z",
          "id": "IC_kwDODI9FZc45WnwV"
        },
        {
          "author": "jkoritzinsky",
          "body": "Yes that is correct. We have both analyzers and generators in the DllImportGenerator assembly in dotnet/runtime.",
          "createdAt": "2021-11-05T21:41:42Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-11-05T21:41:42Z",
          "id": "IC_kwDODI9FZc45Wpkv"
        },
        {
          "author": "layomia",
          "body": "Great, will look into how this is wired up.",
          "createdAt": "2021-11-05T22:53:29Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2021-11-05T22:53:29Z",
          "id": "IC_kwDODI9FZc45WwNs"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Moving to Future, as we won't have time to work on this in the .NET 7 timeframe.",
          "createdAt": "2022-04-18T15:47:40Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-04-18T15:49:01Z",
          "id": "IC_kwDODI9FZc5Bp8N9"
        }
      ],
      "totalCount": 5,
      "endCursor": "Y3Vyc29yOnYyOpHOQafDfQ=="
    },
    "url": "https://github.com/dotnet/runtime/issues/61262",
    "title": "Consider sharing diagnostics issued by JSON source generator with reflection-based serializer"
  },
  {
    "author": "eiriktsarpalis",
    "labels": [
      "area-System.Text.Json",
      "User Story",
      "Team:Libraries"
    ],
    "createdAt": "2022-01-14T14:03:04Z",
    "body": "## Background and Motivation\r\n\r\nCurrently, the default json converters used for objects and collection types are internal to System.Text.Json. The library uses [hardcoded conventions](https://github.com/dotnet/runtime/blob/0b527a201f4c286f13ef8b829bbd1651bdad7a52/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/JsonSerializerOptions.Converters.cs#L43-L48) to decide what default converters to apply to each type: for instance classes that implement `IEnumerable<T>` are automatically treated as collections, and classes that implement `IAsyncEnumerable<T>` can only be handled by the async-only IAsyncEnumerable converter. As of today, System.Text.Json offers no mechanism for users to override this convention, and we have received a number of questions from the community about this issue:\r\n\r\n* https://github.com/dotnet/runtime/issues/1808\r\n* https://github.com/dotnet/runtime/issues/61044\r\n* https://github.com/dotnet/runtime/issues/81084\r\n\r\nCurrently the best available workaround is for users to either reimplement the default converters, or wrap/cast the values into a type that produces the desired serialization contract. At the same time, we offer no mechanism for users to tweak the serialization behaviour of the default converters other than using attribute annotations (to be ameliorated once #63686 has been implemented). Related issues:\r\n\r\n* https://github.com/dotnet/runtime/issues/38514\r\n* https://github.com/dotnet/runtime/issues/54189\r\n* https://github.com/dotnet/runtime/issues/57280\r\n\r\n## Proposal\r\n\r\nThis story proposes making the default internal converters public, so that users are free to opt in to specific converter strategies for their types. Consider the following example:\r\n\r\n```C#\r\npublic class MyClass : IEnumerable<int>, IAsyncEnumerable<int>\r\n{\r\n}\r\n```\r\n\r\nBy default, members of type `MyClass` are serialized as IAsyncEnumerables. Users can still force IEnumerable semantics if they cast the instance to `IEnumerable<int>`, however there is currently no way to serialize the type as an object. By exposing the default converter types, we can decorate our type definition with attributes:\r\n\r\n```C#\r\n[JsonConverter(typeof(JsonObjectConverter))] // serialize as object\r\n// [JsonConverter(typeof(JsonCollectionConverter))] // serialize as collection\r\n// [JsonConverter(typeof(JsonAsyncEnumerableConverter)] // serialize as IAsyncEnumerable\r\npublic class MyClass : IEnumerable<int>, IAsyncEnumerable<int>\r\n{\r\n}\r\n```\r\n\r\nMoreover, we should consider exposing parameterization on the converters so that users can configure the contract (for example what https://github.com/dotnet/runtime/issues/38514 is asking for).\r\n\r\nNB we should update the source generator so that relevant `JsonPropertyAttribute` annotations are recognized and trigger relevant metadata generation, cf. https://github.com/dotnet/runtime/issues/82001#issuecomment-1428168998\r\n\r\n## Progress\r\n\r\n- [ ] Prototyping work\r\n- [ ] API proposal\r\n- [ ] Implementation & tests\r\n- [ ] Documentation",
    "number": 63791,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "HEART",
          "createdAt": "2022-01-14T21:45:18Z",
          "user": "jeffhandley"
        },
        {
          "content": "HEART",
          "createdAt": "2022-01-16T17:23:42Z",
          "user": "D3-LucaPiombino"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-05-19T09:30:07Z",
          "user": "bachratyg"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-06-06T11:52:29Z",
          "user": "laprus"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-06-25T19:56:21Z",
          "user": "xsoheilalizadeh"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-08-01T10:47:41Z",
          "user": "Hawxy"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-08-22T02:23:28Z",
          "user": "Blue4x4Rebel"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-09-18T10:38:16Z",
          "user": "cschulzsuper"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-11-28T09:50:52Z",
          "user": "LJFloor"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-11-28T15:15:13Z",
          "user": "gthvmt"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-12-23T21:41:38Z",
          "user": "R4BN"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-01-16T15:00:55Z",
          "user": "enioluwas"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-01-25T09:24:31Z",
          "user": "RyanGaudion"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-01-29T04:12:08Z",
          "user": "warriordog"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-03-14T11:40:36Z",
          "user": "PMExtra"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-03-25T03:10:26Z",
          "user": "rapuyrav"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-06-30T17:07:12Z",
          "user": "svengeance"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-08-14T14:57:54Z",
          "user": "Mitchman215"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-09-07T07:39:12Z",
          "user": "scharnyw"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-10-10T18:52:03Z",
          "user": "alrz"
        },
        {
          "content": "HEART",
          "createdAt": "2023-11-03T07:05:03Z",
          "user": "crozone"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-11-03T07:05:06Z",
          "user": "crozone"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-01-20T21:59:36Z",
          "user": "mungojam"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-03-27T02:54:30Z",
          "user": "austinw-fineart"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-03-29T00:44:30Z",
          "user": "hheexx"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-04-01T14:25:12Z",
          "user": "drusellers"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-04-05T21:57:34Z",
          "user": "MrAliSalehi"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-05-23T15:15:19Z",
          "user": "sereneowl"
        },
        {
          "content": "HEART",
          "createdAt": "2024-05-23T15:15:22Z",
          "user": "sereneowl"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-05-30T14:56:58Z",
          "user": "Morilli"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-07-05T09:59:38Z",
          "user": "kirsan31"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-07-05T14:19:35Z",
          "user": "MrAntix"
        },
        {
          "content": "HEART",
          "createdAt": "2024-07-05T14:19:41Z",
          "user": "MrAntix"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-07-14T19:09:54Z",
          "user": "rebecacalazans"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-07-25T10:55:28Z",
          "user": "Doidel"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-07-25T10:55:31Z",
          "user": "magmablinker"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-08-26T12:50:27Z",
          "user": "toni-metacore"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-10-16T02:37:15Z",
          "user": "issue-dispenser"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-10-29T18:31:52Z",
          "user": "joem-msft"
        },
        {
          "content": "HEART",
          "createdAt": "2024-10-29T18:31:55Z",
          "user": "joem-msft"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-10-30T22:21:19Z",
          "user": "johnc-ftl"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-10-30T22:30:27Z",
          "user": "johncrim"
        },
        {
          "content": "HEART",
          "createdAt": "2024-11-02T23:48:40Z",
          "user": "dgkanatsios"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-11-26T05:53:41Z",
          "user": "beingful"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-12-19T23:25:16Z",
          "user": "AbakumovAlexandr"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-12-19T23:53:38Z",
          "user": "julealgon"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-12-20T09:53:46Z",
          "user": "marcominerva"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-12-20T09:53:54Z",
          "user": "MooVC"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-12-20T09:58:11Z",
          "user": "atmoos"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-12-20T14:06:21Z",
          "user": "nanney54"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-12-20T19:49:25Z",
          "user": "Alxandr"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-12-21T10:24:11Z",
          "user": "fitdev"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-12-23T08:56:55Z",
          "user": "anreton"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-12-23T09:37:33Z",
          "user": "asik"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-12-23T11:48:45Z",
          "user": "D3-LucaPiombino"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-01-01T07:04:08Z",
          "user": "mitaken"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-01-02T22:11:46Z",
          "user": "mirekkukla"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-01-03T18:51:42Z",
          "user": "sn4k3"
        },
        {
          "content": "HEART",
          "createdAt": "2025-01-03T18:51:43Z",
          "user": "sn4k3"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-01-07T21:04:15Z",
          "user": "morgan-s-young"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-01-13T10:39:07Z",
          "user": "alexey-leonovich"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-01-13T14:36:34Z",
          "user": "ohmios"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-01-15T22:14:27Z",
          "user": "inoa-pmattos"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-01-17T19:56:09Z",
          "user": "Jure-BB"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-01-21T10:19:22Z",
          "user": "KernelLeak"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-01-21T13:40:51Z",
          "user": "joelweiss"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-01-21T17:19:03Z",
          "user": "Brokolis"
        },
        {
          "content": "HEART",
          "createdAt": "2025-01-21T17:19:05Z",
          "user": "Brokolis"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-02-05T15:00:50Z",
          "user": "jukkahyv"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-02-10T13:10:39Z",
          "user": "Dreamescaper"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-02-19T20:12:13Z",
          "user": "jjonescz"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-02-21T14:38:11Z",
          "user": "dartasen"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-02-24T11:54:04Z",
          "user": "mdmontesinos"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-03-08T17:38:23Z",
          "user": "Redninja106"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-03-20T17:47:09Z",
          "user": "m0a0k0s"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-03-21T04:16:52Z",
          "user": "erichiller"
        },
        {
          "content": "HEART",
          "createdAt": "2025-03-21T04:16:58Z",
          "user": "erichiller"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-04-04T20:00:05Z",
          "user": "dimarobert"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-04-06T04:58:49Z",
          "user": "jafin"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-04-08T13:35:58Z",
          "user": "adraut"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-04-10T15:47:47Z",
          "user": "datvm"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-04-14T16:53:48Z",
          "user": "chriscameron-vertexinc"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-04-14T17:20:45Z",
          "user": "johnwright-vertexinc"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-04-14T17:37:16Z",
          "user": "atrishin"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-04-14T20:59:03Z",
          "user": "garrettpauls"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-04-18T22:06:58Z",
          "user": "elgonzo"
        },
        {
          "content": "HEART",
          "createdAt": "2025-04-18T22:06:59Z",
          "user": "elgonzo"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-04-19T18:25:00Z",
          "user": "adams85"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-05-05T05:33:17Z",
          "user": "pinkfloydx33"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-05-05T06:57:45Z",
          "user": "Trivivium"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-05-05T11:27:07Z",
          "user": "neon-sunset"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-05-05T17:03:48Z",
          "user": "zms9110750"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-05-07T12:05:48Z",
          "user": "poizan42"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-05-08T12:45:16Z",
          "user": "Trafn"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-05-08T16:15:00Z",
          "user": "d-barker"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-05-11T11:15:30Z",
          "user": "BreyerW"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-05-13T23:37:34Z",
          "user": "eduardobragaxz"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-05-14T18:54:40Z",
          "user": "PauloHMattos"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-05-21T13:00:32Z",
          "user": "JakobAV"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-05-22T05:39:18Z",
          "user": "lilinus"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-05-22T20:26:55Z",
          "user": "HaraldMuehlhoffCC"
        },
        {
          "content": "HEART",
          "createdAt": "2025-05-22T20:27:06Z",
          "user": "HaraldMuehlhoffCC"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-06-13T19:56:22Z",
          "user": "coltonk9043"
        },
        {
          "content": "HEART",
          "createdAt": "2025-06-13T19:56:23Z",
          "user": "coltonk9043"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-06-17T12:46:32Z",
          "user": "TobbenTM"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-06-26T19:28:20Z",
          "user": "dgkanatsios"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-07-02T18:06:40Z",
          "user": "TimWoerner"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-08-19T07:40:41Z",
          "user": "emil-eklund"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-09-02T22:38:29Z",
          "user": "Reprevise"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-09-07T10:01:45Z",
          "user": "badandbest"
        }
      ],
      "totalCount": 110,
      "endCursor": "Y3Vyc29yOnYyOpHOC9ovOQ=="
    },
    "updatedAt": "2025-07-02T18:04:48Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\n## Background and Motivation\r\n\r\nCurrently, the default json converters used for objects and collection types are internal to System.Text.Json. The library uses [hardcoded conventions](https://github.com/dotnet/runtime/blob/0b527a201f4c286f13ef8b829bbd1651bdad7a52/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/JsonSerializerOptions.Converters.cs#L43-L48) to decide what default converters to apply to each type: for instance classes that implement `IEnumerable<T>` are automatically treated as collections, and classes that implement `IAsyncEnumerable<T>` can only be handled by the async-only IAsyncEnumerable converter. As of today, System.Text.Json offers no mechanism for users to override this convention, and we have received a number of questions from the community about this issue:\r\n\r\n* https://github.com/dotnet/runtime/issues/1808\r\n* https://github.com/dotnet/runtime/issues/61044\r\n\r\nCurrently the best available workaround is for users to either reimplement the default converters, or wrap/cast the values into a type that produces the desired serialization contract. At the same time, we offer no mechanism for users to tweak the serialization behaviour of the default converters other than using attribute annotations (to be ameliorated once #63686 has been implemented). Related issues:\r\n\r\n* https://github.com/dotnet/runtime/issues/38514\r\n\r\n## Proposal\r\n\r\nThis story proposes making the default internal converters public, so that users are free to opt in to specific converter strategies for their types. Consider the following example:\r\n\r\n```C#\r\npublic class MyClass : IEnumerable<int>, IAsyncEnumerable<int>\r\n{\r\n}\r\n```\r\n\r\nBy default, members of type `MyClass` are serialized as IAsyncEnumerables. Users can still force IEnumerable semantics if they cast the instance to `IEnumerable<int>`, however there is currently no way to serialize the type as an object. By exposing the default converter types, we can decorate our type definition with attributes:\r\n\r\n```C#\r\n[JsonConverter(typeof(JsonObjectConverter))] // serialize as object\r\n// [JsonConverter(typeof(JsonCollectionConverter))] // serialize as collection\r\n// [JsonConverter(typeof(JsonAsyncEnumerableConverter)] // serialize as IAsyncEnumerable\r\npublic class MyClass : IEnumerable<int>, IAsyncEnumerable<int>\r\n{\r\n}\r\n```\r\n\r\nMoreover, we should consider exposing parameterization on the converters so that users can configure the contract (for example what https://github.com/dotnet/runtime/issues/38514 is asking for).\r\n\r\n## Progress\r\n\r\n- [ ] Prototyping work\r\n- [ ] API proposal\r\n- [ ] Implementation & tests\r\n- [ ] Documentation\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>eiriktsarpalis</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`area-System.Text.Json`, `User Story`, `Priority:2`, `Cost:S`, `Team:Libraries`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>7.0.0</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2022-01-14T14:03:07Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-01-14T14:03:07Z",
          "id": "IC_kwDODI9FZc48Y1kg"
        },
        {
          "author": "asik",
          "body": "Related to #67361 , for me the ideal scenario would be that JsonConverter sees that it's an `IEnumerable<T>`, sees that it has a constructor that takes in an `IEnumerable<T>`, and uses that constructor.",
          "createdAt": "2022-03-31T14:33:00Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-03-31T14:33:00Z",
          "id": "IC_kwDODI9FZc5Aprs1"
        },
        {
          "author": "eiriktsarpalis",
          "body": "> Related to #67361 , for me the ideal scenario would be that JsonConverter sees that it's an `IEnumerable<T>`, sees that it has a constructor that takes in an `IEnumerable<T>`, and uses that constructor.\r\n\r\nYes, that might be a good convention to honor. Similarly for dictionary types that accept `IEnumerable<KeyValuePair<TKey, TValue>>` parameters.",
          "createdAt": "2022-03-31T15:59:51Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-03-31T15:59:51Z",
          "id": "IC_kwDODI9FZc5AqH84"
        },
        {
          "author": "eiriktsarpalis",
          "body": "We likely won't have time to work on this before .NET 7 is done, moving to 8.0.0",
          "createdAt": "2022-06-17T08:37:32Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "CONFUSED",
                "createdAt": "2023-01-11T11:31:54Z",
                "user": "MooVC"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOCyc9Cw=="
          },
          "updatedAt": "2022-06-17T08:37:32Z",
          "id": "IC_kwDODI9FZc5FD2yf"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Moving to Future as we won't be able to work on this for 8.0",
          "createdAt": "2023-01-23T17:40:49Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "CONFUSED",
                "createdAt": "2023-07-02T15:18:33Z",
                "user": "warriordog"
              },
              {
                "content": "CONFUSED",
                "createdAt": "2023-11-03T07:03:58Z",
                "user": "crozone"
              },
              {
                "content": "CONFUSED",
                "createdAt": "2024-09-08T13:55:37Z",
                "user": "altexsoft-vladyslav-chabanenko"
              },
              {
                "content": "CONFUSED",
                "createdAt": "2024-10-22T19:06:52Z",
                "user": "DanielFruerlund"
              },
              {
                "content": "CONFUSED",
                "createdAt": "2024-10-30T22:22:43Z",
                "user": "johnc-ftl"
              },
              {
                "content": "CONFUSED",
                "createdAt": "2024-10-30T22:30:32Z",
                "user": "johncrim"
              },
              {
                "content": "CONFUSED",
                "createdAt": "2024-11-06T20:07:31Z",
                "user": "leonardohigatotvs"
              }
            ],
            "totalCount": 7,
            "endCursor": "Y3Vyc29yOnYyOpHOD5uk5A=="
          },
          "updatedAt": "2023-01-23T17:41:07Z",
          "id": "IC_kwDODI9FZc5TfXp6"
        },
        {
          "author": "MooVC",
          "body": "What is the suggested workaround in this case? I've a type that wraps an array (private field) that implements IEnumerable of that type. I would like it to be serialised as an object, using a public constructor that accepts an array. The type is intended to be immutable, so it would be counterintuitive to allow for collection overrides e.g. Add.",
          "createdAt": "2023-01-25T13:24:21Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-01-25T13:24:21Z",
          "id": "IC_kwDODI9FZc5TqUpd"
        },
        {
          "author": "eiriktsarpalis",
          "body": "The only workaround for now is authoring a custom converter for the type, unfortunately.",
          "createdAt": "2023-01-25T13:32:58Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "CONFUSED",
                "createdAt": "2023-01-26T14:01:12Z",
                "user": "vernou"
              },
              {
                "content": "CONFUSED",
                "createdAt": "2023-03-10T14:54:58Z",
                "user": "MooVC"
              },
              {
                "content": "CONFUSED",
                "createdAt": "2024-05-30T14:45:48Z",
                "user": "Morilli"
              },
              {
                "content": "CONFUSED",
                "createdAt": "2024-10-30T22:22:49Z",
                "user": "johnc-ftl"
              },
              {
                "content": "CONFUSED",
                "createdAt": "2024-10-30T22:30:36Z",
                "user": "johncrim"
              },
              {
                "content": "CONFUSED",
                "createdAt": "2024-11-02T23:48:56Z",
                "user": "dgkanatsios"
              },
              {
                "content": "CONFUSED",
                "createdAt": "2024-11-06T20:05:39Z",
                "user": "leonardohigatotvs"
              },
              {
                "content": "CONFUSED",
                "createdAt": "2025-02-21T14:37:17Z",
                "user": "dartasen"
              }
            ],
            "totalCount": 8,
            "endCursor": "Y3Vyc29yOnYyOpHOEHL9qQ=="
          },
          "updatedAt": "2023-01-25T13:32:58Z",
          "id": "IC_kwDODI9FZc5TqZPo"
        },
        {
          "author": "paul-michalik",
          "body": "> What is the suggested workaround in this case? I've a type that wraps an array (private field) that implements IEnumerable of that type. I would like it to be serialised as an object, using a public constructor that accepts an array. The type is intended to be immutable, so it would be counterintuitive to allow for collection overrides e.g. Add.\r\n\r\nI am currently solving this by deriving such types from `List<T>`. This provides the expected behavior (transparent serialization and deserialization as collection of `T`) but of course adds some risk if the collection should not be manipulated as, well `List<T>`. I use this for internal types only, so it is mostly harmless. \r\n\r\nI still do not understand what the problem is with implementing a default deserialization converter for types implementing e.g. `ICollection<T>`: the documentation says it all, this is exactly how it should behave:\r\n\r\n<img width=\"541\" alt=\"image\" src=\"https://user-images.githubusercontent.com/10583150/221903867-5125e389-19aa-4158-9ab4-9fb7cea0f5fe.png\">\r\n",
          "createdAt": "2023-02-28T15:44:45Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-03-01T13:01:15Z",
                "user": "anreton"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-03-10T14:54:49Z",
                "user": "MooVC"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-03-15T16:03:08Z",
                "user": "elgonzo"
              },
              {
                "content": "THUMBS_DOWN",
                "createdAt": "2024-07-05T10:06:54Z",
                "user": "kirsan31"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-01-03T18:59:09Z",
                "user": "sn4k3"
              }
            ],
            "totalCount": 5,
            "endCursor": "Y3Vyc29yOnYyOpHOEA9nAA=="
          },
          "updatedAt": "2023-02-28T15:45:57Z",
          "id": "IC_kwDODI9FZc5WVPzM"
        },
        {
          "author": "AbakumovAlexandr",
          "body": "It will have been 3 years soon since this major limitation being in place. Is there any updates with this?\n\nWithout resolving this one, it's really a non-trivial task to implement even pretty basic requirements, for example, 'Deserialize all empty JSON arrays into `null`s instead of empty collections supporting all target .NET collection types'.",
          "createdAt": "2024-12-19T23:31:47Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-12-20T03:04:15Z",
                "user": "crozone"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-12-20T06:12:08Z",
                "user": "kirsan31"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-12-20T08:25:19Z",
                "user": "anreton"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-12-20T09:36:57Z",
                "user": "fitdev"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-12-20T09:54:27Z",
                "user": "MooVC"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-12-20T09:58:17Z",
                "user": "atmoos"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-01-02T22:13:03Z",
                "user": "mirekkukla"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-02-21T14:37:35Z",
                "user": "dartasen"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-05-04T23:05:19Z",
                "user": "elgonzo"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-06-13T19:56:52Z",
                "user": "coltonk9043"
              }
            ],
            "totalCount": 10,
            "endCursor": "Y3Vyc29yOnYyOpHOEWkQ3Q=="
          },
          "updatedAt": "2024-12-19T23:31:47Z",
          "id": "IC_kwDODI9FZc6YWMC_"
        },
        {
          "author": "eiriktsarpalis",
          "body": "If there are any updates, they will be first posted on this issue. In the meantime, please continue upvoting the OP so that it can be prioritized in the future.",
          "createdAt": "2024-12-20T09:52:42Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-12-23T08:56:52Z",
                "user": "anreton"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOD__ipw=="
          },
          "updatedAt": "2024-12-20T09:52:42Z",
          "id": "IC_kwDODI9FZc6YY2-y"
        },
        {
          "author": "mirek-rynly",
          "body": "Really looking forward to this. We currently have to resort to fragile reflection to work around this limitation.",
          "createdAt": "2025-05-14T18:27:41Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-05-14T18:27:41Z",
          "id": "IC_kwDODI9FZc6ruuJw"
        },
        {
          "author": "TimWoerner",
          "body": "The `System.Text.Json.Serialization.Converters.ObjectDefaultConverter` should be for public usage, there is currently no way to for the `JsonConverterFactory` to return null, as it throws an exception when returning null\n\n\n``` csharp\npublic override JsonConverter? CreateConverter(Type typeToConvert, JsonSerializerOptions options)\n{\n    //returning null throws exception in GetConverterInternal, even tho the method states that returning null is allowed\n    return null;\n}\n```\n\nWorkaround is getting the Internal Converter through reflection\n\n``` csharp\nprivate static readonly Lazy<Type> _internalMicrosoftDefaultObjectConverterType = new(() => typeof(JsonConverter<>).Assembly.GetType(\"System.Text.Json.Serialization.Converters.ObjectDefaultConverter`1\")!.MakeGenericType(typeof(myTypeToConvert))!);\n\n...\n\nJsonConverter internalobjConverter = (JsonConverter)Activator.CreateInstance(_internalMicrosoftDefaultObjectConverterType.Value)!;\n\n```\n\nThe reason why we need it, is because we have depending on different condition, different converter for this one object, and sometimes we must return the defauilt converter\n\n",
          "createdAt": "2025-07-02T18:04:48Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-07-02T18:04:48Z",
          "id": "IC_kwDODI9FZc60iHYr"
        }
      ],
      "totalCount": 12,
      "endCursor": "Y3Vyc29yOnYyOpHOtIh2Kw=="
    },
    "url": "https://github.com/dotnet/runtime/issues/63791",
    "title": "Developers should have access to System.Text.Json's default internal converters"
  },
  {
    "author": "eiriktsarpalis",
    "labels": [
      "area-System.Text.Json",
      "User Story",
      "Priority:2",
      "Cost:L",
      "Team:Libraries"
    ],
    "createdAt": "2022-01-14T15:14:16Z",
    "body": "## Background and Motivation\r\n\r\nThe current model for [authoring custom converters](https://learn.microsoft.com/en-us/dotnet/standard/serialization/system-text-json/converters-how-to?pivots=dotnet-7-0) in System.Text.Json is general-purpose and powerful enough to address most serialization customization requirements. Where it falls short currently is in the ability to accept user-provided state scoped to the current serialization operation; this effectively blocks a few relatively common scenaria:\r\n\r\n1. Custom converters requiring dependency injection scoped to the current serialization. A lack of a reliable state passing mechanism can [prompt users to rebuild the converter cache](https://github.com/dotnet/runtime/issues/76548) every time a serialization operation is performed.\r\n\r\n2. Custom converters do not currently support streaming serialization. Built-in converters avail of the internal \"resumable converter\" abstraction, a pattern which allows partial serialization and deserialization by marshalling the serialization state/stack into a state object that gets passed along converters. It lets converters suspend and resume serialization as soon as the need to flush the buffer or read more data arises. This pattern is implemented using the internal [`JsonConveter<T>.TryWrite`](https://github.com/dotnet/runtime/blob/3b1df9396e2a7cc6797e76793e8547f8a7771953/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/JsonConverterOfT.cs#L325) and [`JsonConverter<T>.TryRead`](https://github.com/dotnet/runtime/blob/3b1df9396e2a7cc6797e76793e8547f8a7771953/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/JsonConverterOfT.cs#L163) methods.\r\n\r\n    Since resumable converters are an internal implementation detail, custom converters cannot support resumable serialization. This can create performance problems in both serialization and deserialization:\r\n\r\n     * In async serialization, System.Text.Json will delay flushing the buffer until the custom converter (and any child converters) have completed writing.\r\n    * In async deserialization, System.Text.Json will need to read ahead all JSON data at the current depth to ensure that the custom converter has access to all required data at the first read attempt.\r\n\r\n   We should consider exposing a variant of that abstraction to advanced custom converter authors.\r\n\r\n3. Custom converters are not capable of passing internal serialization state, often resulting in functional bugs when custom converters are encountered in an object graph (cf. https://github.com/dotnet/runtime/issues/51715, #67403, https://github.com/dotnet/runtime/issues/77345)\r\n\r\n## Proposal\r\n\r\nHere is a rough sketch of how this API could look like:\r\n\r\n```C#\r\nnamespace System.Text.Json.Serialization;\r\n\r\npublic struct JsonWriteState\r\n{\r\n    public CancellationToken { get; }\r\n    public Dictionary<string, object> UserState { get; }\r\n}\r\n\r\npublic struct JsonReadState\r\n{\r\n    public CancellationToken { get; }\r\n    public Dictionary<string, object> UserState { get; }\r\n}\r\n\r\npublic abstract class JsonStatefulConverter<T> : JsonConverter<T>\r\n{\r\n     public abstract void Write(Utf8JsonWriter writer, T value, JsonSerializerOptions options, ref JsonWriteState state);\r\n     public abstract T? Read(ref Utf8JsonReader writer, Type typeToConvert, JsonSerializerOptions options, ref JsonReadState state);\r\n\r\n      // Override the base methods: implemented in terms of the new virtuals and marked as sealed\r\n      public sealed override void Write(Utf8JsonWriter writer, T value, JsonSerializerOptions options) {}\r\n      public sealed override T? Read(ref Utf8JsonReader writer, Type typeToConvert, JsonSerializerOptions options) {}\r\n}\r\n\r\npublic abstract class JsonResumableConverter<T> : JsonConverter<T>\r\n{\r\n     public abstract bool TryWrite(Utf8JsonWriter writer, T value, JsonSerializerOptions options, ref JsonWriteState state);\r\n     public abstract bool TryRead(ref Utf8JsonReader writer, Type typeToConvert, JsonSerializerOptions options, ref JsonReadState state, out T? result);\r\n\r\n      // Override the base methods: implemented in terms of the new virtuals and marked as sealed\r\n      public sealed override void Write(Utf8JsonWriter writer, T value, JsonSerializerOptions options) {}\r\n      public sealed override T? Read(ref Utf8JsonReader writer, Type typeToConvert, JsonSerializerOptions options) {}\r\n}\r\n\r\npublic partial class JsonSerializer\r\n{\r\n     // Overloads to existing methods accepting state\r\n     public static string Serialize<T>(T value, JsonSerializerOptions options, ref JsonWriteState state);\r\n     public static string Serialize<T>(T value, JsonTypeInfo<T> typeInfo, ref JsonWriteState state);\r\n     public static T? Deserialize<T>(string json, JsonSerializerOptions options, ref JsonReadState state);\r\n     public static T? Deserialize<T>(string json, JsonTypeInfo<T> typeInfo, ref JsonReadState state);\r\n\r\n     // New method groups enabling low-level streaming serialization\r\n     public static bool TrySerialize(T value, JsonTypeInfo<T> typeInfo, ref JsonWriteState state);\r\n     public static bool TryDeserialize(string json, JsonTypeInfo<T> typeInfo, ref JsonReadState state);\r\n}\r\n```\r\n\r\nUsers should be able to author custom converters that can take full advantage of async serialization, and compose correctly with the contextual serialization state. This is particularly important in the case of library authors, who might want to extend async serialization support for custom sets of types. It could also be used to author top-level async serialization methods that target other data sources (e.g. using System.IO.Pipelines cf. https://github.com/dotnet/runtime/issues/29902)\r\n\r\n## Usage Examples\r\n\r\n```C#\r\nMyPoco value = new() { Value = \"value\" };\r\nJsonWriteState state = new() { UserState = { [\"sessionId\"] = \"myId\" }};\r\nJsonSerializer.Serialize(value, options, state); // { \"sessionId\" : \"myId\", \"value\" : \"value\" }\r\n\r\npublic class MyConverter : JsonStatefulConverter<MyPoco>\r\n{\r\n    public override void Write(Utf8JsonWriter writer, MyPoco value, JsonSerializerOptions options, ref JsonWriteState state)\r\n    {\r\n         writer.WriteStartObject();\r\n         writer.WriteString(\"sessionId\", (string)state.UserState[\"sessionId\"]);\r\n         writer.WriteString(\"value\", value.Value);\r\n     }\r\n}\r\n```\r\n\r\n## Alternative designs\r\n\r\nWe might want to consider the viability attaching the state values as properties on `Utf8JsonWriter` and `Utf8JsonReader`. It would avoid the need of introducing certain overloads, but on the flip side it could break scenaria where the writer/reader objects are being passed to nested serialization operations.\r\n\r\n## Goals\r\n\r\n* Support custom resumable converters.\r\n* Support custom converters that are passing the serialization state to child converters.\r\n* Support async serialization using data sources other than `Stream` (à la https://github.com/dotnet/runtime/issues/29902).\r\n* Support users attaching custom state to serialization operations (#71718)\r\n\r\n## Progress\r\n\r\n- [ ] Author prototype\r\n- [ ] API proposal & review\r\n- [ ] Implementation & tests\r\n- [ ] Conceptual documentation & blog posts.",
    "number": 63795,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "HEART",
          "createdAt": "2022-01-27T17:23:01Z",
          "user": "joelverhagen"
        },
        {
          "content": "HEART",
          "createdAt": "2022-02-28T16:42:43Z",
          "user": "beefo"
        },
        {
          "content": "HEART",
          "createdAt": "2022-03-02T19:05:32Z",
          "user": "mattchidley"
        },
        {
          "content": "HEART",
          "createdAt": "2022-04-28T14:34:12Z",
          "user": "Ruikuan"
        },
        {
          "content": "HEART",
          "createdAt": "2022-06-23T20:58:32Z",
          "user": "WhitWaldo"
        },
        {
          "content": "HEART",
          "createdAt": "2022-07-06T18:20:26Z",
          "user": "PaulusParssinen"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-07-21T09:36:10Z",
          "user": "oocx"
        },
        {
          "content": "EYES",
          "createdAt": "2022-09-26T17:47:51Z",
          "user": "veikkoeeva"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-10-18T13:41:39Z",
          "user": "bartelink"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-10-18T17:23:03Z",
          "user": "KoalaBear84"
        },
        {
          "content": "HEART",
          "createdAt": "2023-01-02T14:41:20Z",
          "user": "epsitec"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-01-27T15:33:40Z",
          "user": "bachratyg"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-01-28T05:30:30Z",
          "user": "artyomszasa"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-04-12T17:59:29Z",
          "user": "sfmskywalker"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-05-07T19:27:42Z",
          "user": "osexpert"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-06-12T03:48:14Z",
          "user": "czd890"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-10-29T14:01:20Z",
          "user": "alex-jitbit"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-12-03T17:09:03Z",
          "user": "beefo"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-12-03T22:09:52Z",
          "user": "ElectroluxV2"
        },
        {
          "content": "HEART",
          "createdAt": "2024-02-07T12:43:48Z",
          "user": "alex-jitbit"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-02-24T15:22:22Z",
          "user": "airbreather"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-03-04T21:28:22Z",
          "user": "dennis-yemelyanov"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-04-04T21:52:54Z",
          "user": "max-meng1"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-05-24T11:49:02Z",
          "user": "AlexeyShirshov"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-05-30T15:15:34Z",
          "user": "andrewjsaid"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-05-31T13:58:11Z",
          "user": "julealgon"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-10-11T12:22:10Z",
          "user": "vis-hugo"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-10-27T09:43:52Z",
          "user": "joadan"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-11-13T07:26:34Z",
          "user": "aelij"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-11-14T20:18:57Z",
          "user": "mikhail-barg"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-03-28T23:53:34Z",
          "user": "withomasmicrosoft"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-03-30T14:12:30Z",
          "user": "dannyd89"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-03-31T17:02:28Z",
          "user": "TFR258"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-05-22T13:20:39Z",
          "user": "dotlogix"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-07-08T16:20:29Z",
          "user": "jamesbrookeparcel2go"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-07-18T21:12:33Z",
          "user": "Athari"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-08-08T09:55:01Z",
          "user": "Ramstad"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-09-03T10:37:34Z",
          "user": "austinw-fineart"
        }
      ],
      "totalCount": 38,
      "endCursor": "Y3Vyc29yOnYyOpHODOHYgQ=="
    },
    "updatedAt": "2025-04-04T15:50:33Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\n## Background and Motivation\r\n\r\nAsync serialization in System.Text.Json is a powerful feature that lets users serialize and deserialize from streaming JSON data, without the need to load the entire payload in-memory. At the converter level, this is achieved with \"resumable converters\", a pattern that allows for partial serialization and deserialization by marshalling the serialization state/stack into a mutable struct that gets passed along converters. It lets converters suspend and resume serialization as soon as the need to flush the buffer or read more data arises. This pattern is implemented using the internal [`JsonConveter<T>.TryWrite`](https://github.com/dotnet/runtime/blob/a13ee96335ea4c41cfe273855611caec4c35cae8/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/JsonConverterOfT.cs#L321) and [`JsonConverter<T>.TryRead`](https://github.com/dotnet/runtime/blob/a13ee96335ea4c41cfe273855611caec4c35cae8/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/JsonConverterOfT.cs#L148) methods.\r\n\r\nSince resumable converters are an internal implementation detail, custom converters cannot support resumable serialization. This can create performance problems in both serialization and deserialization:\r\n\r\n* In async serialization, System.Text.Json will delay flushing the buffer until the custom converter (and any child converters) have completed writing.\r\n* In async deserialization, System.Text.Json will need to read ahead all JSON data at the current depth to ensure that the custom converter has access to all required data at the first read attempt.\r\n\r\nBecause custom converters cannot pass the serialization state, System.Text.Json suffers from a class of functional bugs that arise because of the serialization state resetting every time a custom converter is encountered in the object graph (cf. https://github.com/dotnet/runtime/issues/51715).\r\n\r\n## Proposal\r\n\r\nUsers should be able to author custom converters that can take full advantage of async serialization, and compose correctly with the contextual serialization state. This is particularly important in the case of library authors, who might want to extend async serialization support for custom sets of types. It could also be used to author top-level async serialization methods that target other data sources (e.g. using System.IO.Pipelines cf. https://github.com/dotnet/runtime/issues/29902)\r\n\r\nThis is a proposal to publicize aspects of the `TryWrite`/`TryRead` pattern to the users of System.Text.Json. It should be noted that this is a feature aimed exclusively towards \"advanced\" users, primarily third-party library and framework authors.\r\n\r\n## Goals\r\n\r\n* Support custom resumable converters.\r\n* Support custom converters that are passing the serialization state to child converters.\r\n* Support async serialization using data sources other than `Stream` (à la https://github.com/dotnet/runtime/issues/29902).\r\n\r\n## Progress\r\n\r\n- [ ] Author prototype\r\n- [ ] API proposal & review\r\n- [ ] Implementation & tests\r\n- [ ] Conceptual documentation & blog posts.\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>eiriktsarpalis</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`area-System.Text.Json`, `User Story`, `Priority:2`, `Cost:M`, `Team:Libraries`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>7.0.0</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2022-01-14T15:14:19Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-01-14T15:14:19Z",
          "id": "IC_kwDODI9FZc48ZGcF"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Tagging @steveharter who might be interested in this.",
          "createdAt": "2022-01-14T15:14:31Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-01-14T15:14:31Z",
          "id": "IC_kwDODI9FZc48ZGev"
        },
        {
          "author": "jeffhandley",
          "body": "I'm updating this feature's milestone to Future as it is not likely to make it into .NET 7.",
          "createdAt": "2022-04-06T01:11:57Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-04-06T13:38:36Z",
                "user": "eiriktsarpalis"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOCWffRA=="
          },
          "updatedAt": "2022-04-06T01:11:57Z",
          "id": "IC_kwDODI9FZc5A8iRT"
        },
        {
          "author": "eiriktsarpalis",
          "body": "I've updated the issue description and examples to broaden the scope to stateful converters. Sketch of API proposal and a basic example has been included. PTAL.",
          "createdAt": "2022-10-14T14:32:08Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-10-14T14:32:08Z",
          "id": "IC_kwDODI9FZc5MPWKA"
        },
        {
          "author": "layomia",
          "body": "There are scenarios where a custom converter might want metadata info about the type (including it's properties) or property it is processing, e.g. https://github.com/dotnet/runtime/issues/35240#issuecomment-617453603. I understand that with `JsonSerializerOptions.GetTypeInfo(Type)`, it is now possible to retrieve type metadata within converters, but should there be a first class mechanism, e.g. adding relevant type/property metadata to the state object passed to converters?\r\n\r\nI believe I've also come across scenarios where a converter might want to know where in the object graph it is being invoked, i.e the root object vs property values. Is that also state that should be passed?",
          "createdAt": "2022-10-14T18:05:17Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-10-14T18:53:47Z",
          "id": "IC_kwDODI9FZc5MQLjV"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Yes that's plausible. Effectively we should investigate what parts of ReadStack/WriteStack could/should be exposed to the user. I'm not sure if we could meaningfully expose what amounts to WriteStack.Current, since that only gets updated consistently when the internal converters are being called. Prototyping is certainly required to validate feasibility.",
          "createdAt": "2022-10-14T18:29:55Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-10-14T18:54:48Z",
                "user": "layomia"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-07-17T07:24:07Z",
                "user": "czd890"
              }
            ],
            "totalCount": 2,
            "endCursor": "Y3Vyc29yOnYyOpHODA32Sg=="
          },
          "updatedAt": "2022-10-14T18:29:55Z",
          "id": "IC_kwDODI9FZc5MQQzm"
        },
        {
          "author": "thomaslevesque",
          "body": "To be honest, with the proposed design, this feature would only be moderately useful, because it requires passing state explicitly to the Serialize/Deserialize methods. This doesn't help when you don't have control over these callsites, as is the case in ASP.NET Core JSON input/output formatters.\r\n\r\nI realize what I'm talking about isn't really \"state\", at least not callsite-specific state, but it's what was requested in #71718, which has been closed in favor this issue... I don't think the proposed design addresses the requirements of #71718.",
          "createdAt": "2022-10-19T01:36:45Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-10-19T01:36:45Z",
          "id": "IC_kwDODI9FZc5MfPfA"
        },
        {
          "author": "eiriktsarpalis",
          "body": "> I realize what I'm talking about isn't really \"state\", at least not callsite-specific state, but it's what was requested in https://github.com/dotnet/runtime/issues/71718, which has been closed in favor this issue... I don't think the proposed design addresses the requirements of https://github.com/dotnet/runtime/issues/71718.\r\n\r\nYes, this proposal specifically concerns state scoped to the operation rather than the options instance. The latter is achievable if you really need it whereas the former is outright impossible.",
          "createdAt": "2022-10-19T07:34:53Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-10-19T07:34:53Z",
          "id": "IC_kwDODI9FZc5MgZoC"
        },
        {
          "author": "stevejgordon",
          "body": "@eiriktsarpalis I must admit that I'd not read this through and assumed it solved the suggestion from my original proposal. I agree that this solves a different problem (which I've not personally run into). It would not help at all with the scenario I have when building a library. Is there any reason not to re-open #71718 to complement this? I think both are valid scenarios that should be possible to achieve with less ceremony.",
          "createdAt": "2022-10-19T08:10:25Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-10-19T08:10:25Z",
          "id": "IC_kwDODI9FZc5Mgjx1"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Agree, I've reopened the issue based on your feedback.",
          "createdAt": "2022-10-19T08:12:19Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-10-19T08:19:08Z",
                "user": "stevejgordon"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-10-19T12:56:00Z",
                "user": "thomaslevesque"
              }
            ],
            "totalCount": 2,
            "endCursor": "Y3Vyc29yOnYyOpHOCuHWjQ=="
          },
          "updatedAt": "2022-10-19T08:12:19Z",
          "id": "IC_kwDODI9FZc5MgkW6"
        },
        {
          "author": "osexpert",
          "body": "\"We might want to consider the viability attaching the state values as properties on Utf8JsonWriter and Utf8JsonReader\"\r\nI see when Deserialize from Stream, an Utf8JsonReader instance is made for every iteration of a while-loop, so does not seem like a good fit.",
          "createdAt": "2023-05-09T19:06:17Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-05-09T19:06:17Z",
          "id": "IC_kwDODI9FZc5b1eSg"
        },
        {
          "author": "dennis-yemelyanov",
          "body": "Was just looking for something like this. I'd like to be able to extract some value from the object during serialization and make it available after the serialization is done. It seems like currently the only way to achieve this is to be instantiating a new converter for each serialization, which is not great for perf.\r\n\r\nIs this still planned to be implemented at some point?",
          "createdAt": "2024-03-04T21:29:05Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-03-04T21:29:05Z",
          "id": "IC_kwDODI9FZc513h4M"
        },
        {
          "author": "brantburnett",
          "body": "Personally, I'm more interested in the performance benefits of the resuming bits of this proposal. While I realize they're somewhat related, I wonder if the lack of progress here could be partially related to the scope of including both resuming and user state in the same proposal. Should it be separated so the more valuable one (whichever that is) could be done independently, so long as the design has a path forward to the other?",
          "createdAt": "2024-03-22T21:02:41Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-03-22T21:02:41Z",
          "id": "IC_kwDODI9FZc54KFRB"
        },
        {
          "author": "eiriktsarpalis",
          "body": "> Should it be separated so the more valuable one (whichever that is) could be done independently, so long as the design has a path forward to the other?\r\n\r\nI think both are equally valuable. At the same time, we should be designing the serialization state types in a way that satisfy the requirements for both use cases.",
          "createdAt": "2024-03-22T21:14:51Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-03-22T21:14:51Z",
          "id": "IC_kwDODI9FZc54KMWR"
        },
        {
          "author": "andrewjsaid",
          "body": "What is the purpose of the `JsonReadState` and `JsonWriteState` parameters being passed in as ref?\r\nThe dictionary is already mutable so it's probably not that...",
          "createdAt": "2024-05-31T09:38:51Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-05-31T09:38:51Z",
          "id": "IC_kwDODI9FZc5_poQ8"
        },
        {
          "author": "eiriktsarpalis",
          "body": "The types already exist as [internal implementation detail](https://github.com/dotnet/runtime/blob/main/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/WriteStack.cs) and hold additional state which wouldn't be visible to users.",
          "createdAt": "2024-05-31T10:03:35Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-05-31T10:24:47Z",
                "user": "andrewjsaid"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-05-31T13:59:45Z",
                "user": "julealgon"
              }
            ],
            "totalCount": 2,
            "endCursor": "Y3Vyc29yOnYyOpHODkCiwQ=="
          },
          "updatedAt": "2024-05-31T10:03:35Z",
          "id": "IC_kwDODI9FZc5_p4T7"
        },
        {
          "author": "JustDre",
          "body": "Given that #64182 was closed in deference to this issue, I don't know why the solution needs to involve async converters when DeserializeAsyncEnumerable does not and yet provides significant memory savings over DeserializeAsync (whenever streaming deserialization is appropriate).  It seems the ability to call DeserializeAsyncEnumerable at any arbitrary point of an incoming stream, and leaving the stream open at the appropriate byte location upon exit, would be immensely useful.  While the solutions discussed above are optimal from a resource perspective, forcing all developers to fully support async converters seems like a bigger lift than necessary, simply to support non-root array deserialization.  If an overload can be implemented to achieve this, then once async converters become available, developers can opt in to implement them as appropriate.",
          "createdAt": "2024-11-11T19:23:22Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-11-11T19:23:22Z",
          "id": "IC_kwDODI9FZc6TKA6k"
        },
        {
          "author": "JustDre",
          "body": "Maybe it's not important, but issue #77018 (that tracks this one) is currently closed.  I don't see it being tracked by an equivalent issue for .NET 9, but since it's days (hours?) away from release, it probably needs to be tracked by the equivalent for .NET 10.",
          "createdAt": "2024-11-11T19:30:27Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-11-11T19:30:27Z",
          "id": "IC_kwDODI9FZc6TKDcI"
        },
        {
          "author": "Harpush",
          "body": "Any chance for non root deserialize to IAsyncEnumerable? Many APIs return the array inside an object thus eliminating the possibility to use IAsyncEnumerable",
          "createdAt": "2025-04-03T23:11:28Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-04-04T10:47:37Z",
                "user": "brantburnett"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-07-08T16:20:43Z",
                "user": "jamesbrookeparcel2go"
              }
            ],
            "totalCount": 2,
            "endCursor": "Y3Vyc29yOnYyOpHOEZzHxw=="
          },
          "updatedAt": "2025-04-03T23:11:28Z",
          "id": "IC_kwDODI9FZc6liHvD"
        },
        {
          "author": "eiriktsarpalis",
          "body": "> Any chance for non root deserialize to IAsyncEnumerable? Many APIs return the array inside an object thus eliminating the possibility to use IAsyncEnumerable\n\nHow would this work? Assuming you were trying to stream a large JSON object like so\n\n```json\n{ \"prop1\" : 1, \"largeProp\" : [1,2,3,4,5,....], \"prop2\": 2 }\n```\n\ninto the type\n\n```cshap\nrecord Poco(int prop1, IAsyncEnumerable<int> largeProp, int prop2);\n```\n\nthe returned value should have been hydrated with data for all its properties. How could this be reconciled with streaming?",
          "createdAt": "2025-04-04T12:32:45Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-04-04T12:32:45Z",
          "id": "IC_kwDODI9FZc6lngLQ"
        },
        {
          "author": "airbreather",
          "body": "I'm guessing the idea (because I have a similar use case to this) would be that we have a root object that is essentially nothing more than a container for an array? GeoJSON FeatureCollection comes to mind.\n\nEdit to elaborate: the implication being that we would deserialize only the inner array for a given property as though it were top-level, and all other properties would be ignored (except maybe for the purposes of raising format errors or something).\n\nIMO not worth significant investment because it only works for narrow use cases, but not fundamentally incompatible or useless either.",
          "createdAt": "2025-04-04T13:13:01Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-07-08T16:21:20Z",
                "user": "jamesbrookeparcel2go"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOEZzIIg=="
          },
          "updatedAt": "2025-04-04T13:16:16Z",
          "id": "IC_kwDODI9FZc6ln57-"
        },
        {
          "author": "eiriktsarpalis",
          "body": "> Edit to elaborate: the implication being that we would deserialize only the inner array for a given property as though it were top-level, and all other properties would be ignored (except maybe for the purposes of raising format errors or something).\n\nThat is definitely achievable. The potential shape we've been thinking about is a `JsonSerializer.DeserializeAsyncEnumerable` overload that accepts a JSON pointer to the nested location that needs to be streamed. It means that any other contextual information would be discarded.",
          "createdAt": "2025-04-04T13:19:01Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-07-08T16:21:19Z",
                "user": "jamesbrookeparcel2go"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOEZzIHw=="
          },
          "updatedAt": "2025-04-04T13:19:01Z",
          "id": "IC_kwDODI9FZc6ln9SJ"
        },
        {
          "author": "Harpush",
          "body": "Discarding is the way to go. Let's put aside streaming non array jsons as I am really not sure there is any way to do it except for tokens.\nThe idea is for cases like `{ \"data\": [/* huge array */] }`. I have zero interest in data wrapper and I would be happy with the service returning just an array. So ideally I would expect a way to specify path or even property where the array exists.\n\nAnother more low level oriented approach can be to allow getting a tokens stream from http stream skipping whatever you want and then an option to say deserialize async enumerable from here.\nThis will allow to easily even parse (as one big concatenated array) a json like `{data1: [], data2: []}`.",
          "createdAt": "2025-04-04T14:05:17Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-04-04T14:05:17Z",
          "id": "IC_kwDODI9FZc6loYs2"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Makes sense. I would say though that this is out of scope for this particular issue. Could you create a new one please?",
          "createdAt": "2025-04-04T14:08:34Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-04-04T14:09:30Z",
                "user": "Harpush"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-04-04T14:10:54Z",
                "user": "airbreather"
              }
            ],
            "totalCount": 2,
            "endCursor": "Y3Vyc29yOnYyOpHOEM73qA=="
          },
          "updatedAt": "2025-04-04T14:08:40Z",
          "id": "IC_kwDODI9FZc6loatg"
        },
        {
          "author": "Harpush",
          "body": "> Makes sense. I would say though that this is out of scope for this particular issue. Could you create a new one please?\n\nhttps://github.com/dotnet/runtime/issues/114265",
          "createdAt": "2025-04-04T14:53:47Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-04-04T15:10:07Z",
                "user": "eiriktsarpalis"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOEM8Whg=="
          },
          "updatedAt": "2025-04-04T14:53:47Z",
          "id": "IC_kwDODI9FZc6lo63q"
        }
      ],
      "totalCount": 25,
      "endCursor": "Y3Vyc29yOnYyOpHOpaOt6g=="
    },
    "url": "https://github.com/dotnet/runtime/issues/63795",
    "title": "Developers should be able to pass state to custom converters."
  },
  {
    "author": "VincentBu",
    "labels": [
      "test-failure",
      "area-System.Text.Json",
      "os-windows",
      "arch-x64"
    ],
    "createdAt": "2022-01-17T04:36:25Z",
    "body": "Frequency:\r\nDay | Run\r\n-- | --\r\n**3/27-7/22**\r\n5/19 | PR #69540 | \r\n4/25 | PR #66196 | \r\n4/11 | Official run | 2 failures\r\n4/5 | Official run | \r\n3/27 | PR #65249\r\n\r\n```kusto\r\nlet failedTests = (testNameSubstring : string, methodName : string, includePR : bool, messageSubstr: string, includePassedOnRerun : bool) {\r\ncluster('engsrvprod.kusto.windows.net').database('engineeringdata').AzureDevOpsTests\r\n    | where TestName contains testNameSubstring\r\n    | where includePassedOnRerun or (Outcome == 'Failed')\r\n    | extend startOfTestName = indexof_regex(TestName, @\"[^.]+$\")\r\n    | extend Method = substring(TestName, startOfTestName)\r\n    | extend Type = substring(TestName, 0, startOfTestName - 1)\r\n    | project-away startOfTestName\r\n    | where (methodName == '') or (Method == methodName)\r\n    | where Message contains messageSubstr\r\n    | distinct JobId, WorkItemId, Message, StackTrace, Method, Type, Arguments, Outcome\r\n    | join kind=inner (cluster('engsrvprod.kusto.windows.net').database('engineeringdata').Jobs\r\n        | where ((Branch == 'refs/heads/main') or (Branch == 'refs/heads/master') or (includePR and (Source startswith \"pr/\")))\r\n        | where Type startswith \"test/functional/cli/\"\r\n            and not(Properties contains \"runtime-staging\")\r\n        | summarize arg_max(Finished, Properties, Type, Branch, Source, Started, QueueName) by JobId\r\n        | project-rename JobType = Type) on JobId\r\n    | extend PropertiesJson = parse_json(Properties)\r\n    | extend OS = replace_regex(tostring(PropertiesJson.operatingSystem), @'\\((.*)\\).*|([^\\(].*)', @'\\1\\2')\r\n    | extend Runtime = iif(PropertiesJson.runtimeFlavor == \"mono\", \"Mono\", iif(PropertiesJson.DefinitionName contains \"coreclr\", \"CoreCLR\", \"\"))\r\n    | extend TargetBranch = extractjson(\"$.['System.PullRequest.TargetBranch']\", Properties)\r\n    | extend Architecture = PropertiesJson.architecture\r\n    | extend Scenario = iif(isempty(PropertiesJson.scenario), \"--\", PropertiesJson.scenario)\r\n    //| extend DefinitionName = PropertiesJson.DefinitionName\r\n    | project-away PropertiesJson\r\n};\r\nfailedTests('', 'VeryLongInputString', true, '', true);\r\n```\r\n\r\nRun: [runtime-libraries-coreclr outerloop 20220116.5](https://dev.azure.com/dnceng/public/_build/results?buildId=1555703&view=ms.vss-test-web.build-test-results-tab&runId=43865490&paneView=debug&resultId=104481)\r\n\r\nFailed test:\r\n```\r\nnet7.0-windows-Release-x64-CoreCLR_release-Windows.10.Amd64.ServerRS5.Open\r\n\r\n- System.Text.Json.Serialization.Tests.ValueTests.VeryLongInputString(length: 1073741791)\r\n\r\n```\r\n**Error message:**\r\n```\r\nSystem.OutOfMemoryException : Exception of type 'System.OutOfMemoryException' was thrown.\r\n\r\n\r\nStack trace\r\n   at System.Text.Json.JsonReaderHelper.TranscodeHelper(ReadOnlySpan`1 utf8Unescaped) in /_/src/libraries/System.Text.Json/src/System/Text/Json/Reader/JsonReaderHelper.Unescaping.cs:line 235\r\n   at System.Text.Json.Utf8JsonReader.GetString() in /_/src/libraries/System.Text.Json/src/System/Text/Json/Reader/Utf8JsonReader.TryGet.cs:line 36\r\n   at System.Text.Json.Serialization.JsonConverter`1.TryRead(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options, ReadStack& state, T& value) in /_/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/JsonConverterOfT.cs:line 286\r\n   at System.Text.Json.Serialization.JsonConverter`1.ReadCore(Utf8JsonReader& reader, JsonSerializerOptions options, ReadStack& state) in /_/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/JsonConverterOfT.ReadCore.cs:line 114\r\n   at System.Text.Json.JsonSerializer.ReadFromSpan[TValue](ReadOnlySpan`1 utf8Json, JsonTypeInfo jsonTypeInfo, Nullable`1 actualByteCount) in /_/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/JsonSerializer.Read.Helpers.cs:line 55\r\n   at System.Text.Json.JsonSerializer.ReadFromSpan[TValue](ReadOnlySpan`1 json, JsonTypeInfo jsonTypeInfo) in /_/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/JsonSerializer.Read.String.cs:line 398\r\n   at System.Text.Json.JsonSerializer.Deserialize[TValue](String json, JsonSerializerOptions options) in /_/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/JsonSerializer.Read.String.cs:line 53\r\n   at System.Text.Json.Serialization.Tests.ValueTests.DeserializeLongJsonString(Int32 stringLength) in /_/src/libraries/System.Text.Json/tests/System.Text.Json.Tests/Serialization/Value.ReadTests.cs:line 479\r\n   at System.Text.Json.Serialization.Tests.ValueTests.VeryLongInputString(Int32 length) in /_/src/libraries/System.Text.Json/tests/System.Text.Json.Tests/Serialization/Value.ReadTests.cs:line 458\r\n```",
    "number": 63861,
    "reactions": {
      "hasNextPage": false,
      "nodes": [],
      "totalCount": 0,
      "endCursor": null
    },
    "updatedAt": "2023-10-05T22:11:15Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\nRun: [runtime-libraries-coreclr outerloop 20220116.5](https://dev.azure.com/dnceng/public/_build/results?buildId=1555703&view=ms.vss-test-web.build-test-results-tab&runId=43865490&paneView=debug&resultId=104481)\r\n\r\nFailed test:\r\n```\r\nnet7.0-windows-Release-x64-CoreCLR_release-Windows.10.Amd64.ServerRS5.Open\r\n\r\n- System.Text.Json.Serialization.Tests.ValueTests.VeryLongInputString(length: 1073741791)\r\n\r\n```\r\n**Error message:**\r\n```\r\nSystem.OutOfMemoryException : Exception of type 'System.OutOfMemoryException' was thrown.\r\n\r\n\r\nStack trace\r\n   at System.Text.Json.JsonReaderHelper.TranscodeHelper(ReadOnlySpan`1 utf8Unescaped) in /_/src/libraries/System.Text.Json/src/System/Text/Json/Reader/JsonReaderHelper.Unescaping.cs:line 235\r\n   at System.Text.Json.Utf8JsonReader.GetString() in /_/src/libraries/System.Text.Json/src/System/Text/Json/Reader/Utf8JsonReader.TryGet.cs:line 36\r\n   at System.Text.Json.Serialization.JsonConverter`1.TryRead(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options, ReadStack& state, T& value) in /_/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/JsonConverterOfT.cs:line 286\r\n   at System.Text.Json.Serialization.JsonConverter`1.ReadCore(Utf8JsonReader& reader, JsonSerializerOptions options, ReadStack& state) in /_/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/JsonConverterOfT.ReadCore.cs:line 114\r\n   at System.Text.Json.JsonSerializer.ReadFromSpan[TValue](ReadOnlySpan`1 utf8Json, JsonTypeInfo jsonTypeInfo, Nullable`1 actualByteCount) in /_/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/JsonSerializer.Read.Helpers.cs:line 55\r\n   at System.Text.Json.JsonSerializer.ReadFromSpan[TValue](ReadOnlySpan`1 json, JsonTypeInfo jsonTypeInfo) in /_/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/JsonSerializer.Read.String.cs:line 398\r\n   at System.Text.Json.JsonSerializer.Deserialize[TValue](String json, JsonSerializerOptions options) in /_/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/JsonSerializer.Read.String.cs:line 53\r\n   at System.Text.Json.Serialization.Tests.ValueTests.DeserializeLongJsonString(Int32 stringLength) in /_/src/libraries/System.Text.Json/tests/System.Text.Json.Tests/Serialization/Value.ReadTests.cs:line 479\r\n   at System.Text.Json.Serialization.Tests.ValueTests.VeryLongInputString(Int32 length) in /_/src/libraries/System.Text.Json/tests/System.Text.Json.Tests/Serialization/Value.ReadTests.cs:line 458\r\n```\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>VincentBu</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`area-System.Text.Json`, `os-windows`, `arch-x64`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2022-01-17T04:36:29Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-01-17T04:36:29Z",
          "id": "IC_kwDODI9FZc48cnfP"
        },
        {
          "author": "danmoseley",
          "body": "curious, the OOM seems to have happened constructing the exception:\r\n```\r\n            catch (DecoderFallbackException ex)\r\n            {\r\n                // We want to be consistent with the exception being thrown\r\n                // so the user only has to catch a single exception.\r\n                // Since we already throw InvalidOperationException for mismatch token type,\r\n                // and while unescaping, using that exception for failure to decode invalid UTF-8 bytes as well.\r\n                // Therefore, wrapping the DecoderFallbackException around an InvalidOperationException.\r\n                throw ThrowHelper.GetInvalidOperationException_ReadInvalidUTF8(ex); // <<<<<<<<<<<\r\n            }\r\n```",
          "createdAt": "2022-01-17T19:08:33Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-01-17T19:08:33Z",
          "id": "IC_kwDODI9FZc48fPbL"
        },
        {
          "author": "VincentBu",
          "body": "Failed again in: [runtime-libraries-coreclr outerloop 20220405.2](https://dev.azure.com/dnceng/public/_build/results?buildId=1700187&view=ms.vss-test-web.build-test-results-tab&runId=46339608&resultId=104444&paneView=debug)\r\n\r\nFailed test:\r\n```\r\nnet7.0-windows-Release-x64-CoreCLR_release-(Windows.Nano.1809.Amd64.Open)windows.10.amd64.serverrs5.open@mcr.microsoft.com/dotnet-buildtools/prereqs:nanoserver-1809-helix-amd64-08e8e40-20200107182504\r\n\r\n- System.Text.Json.Serialization.Tests.ValueTests.VeryLongInputString(length: 1073741791)\r\n\r\n```\r\n**Error message:**\r\n```\r\nSystem.OutOfMemoryException : Exception of type 'System.OutOfMemoryException' was thrown.\r\n\r\n\r\nStack trace\r\n   at System.Text.Json.JsonReaderHelper.TranscodeHelper(ReadOnlySpan`1 utf8Unescaped) in /_/src/libraries/System.Text.Json/src/System/Text/Json/Reader/JsonReaderHelper.Unescaping.cs:line 235\r\n   at System.Text.Json.Utf8JsonReader.GetString() in /_/src/libraries/System.Text.Json/src/System/Text/Json/Reader/Utf8JsonReader.TryGet.cs:line 36\r\n   at System.Text.Json.Serialization.JsonConverter`1.TryRead(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options, ReadStack& state, T& value) in /_/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/JsonConverterOfT.cs:line 246\r\n   at System.Text.Json.Serialization.JsonConverter`1.ReadCore(Utf8JsonReader& reader, JsonSerializerOptions options, ReadStack& state) in /_/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/JsonConverterOfT.ReadCore.cs:line 114\r\n   at System.Text.Json.JsonSerializer.ReadFromSpan[TValue](ReadOnlySpan`1 utf8Json, JsonTypeInfo jsonTypeInfo, Nullable`1 actualByteCount) in /_/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/JsonSerializer.Read.Helpers.cs:line 55\r\n   at System.Text.Json.JsonSerializer.ReadFromSpan[TValue](ReadOnlySpan`1 json, JsonTypeInfo jsonTypeInfo) in /_/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/JsonSerializer.Read.String.cs:line 334\r\n   at System.Text.Json.JsonSerializer.Deserialize[TValue](String json, JsonSerializerOptions options) in /_/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/JsonSerializer.Read.String.cs:line 48\r\n   at System.Text.Json.Serialization.Tests.ValueTests.DeserializeLongJsonString(Int32 stringLength) in /_/src/libraries/System.Text.Json/tests/System.Text.Json.Tests/Serialization/Value.ReadTests.cs:line 479\r\n   at System.Text.Json.Serialization.Tests.ValueTests.VeryLongInputString(Int32 length) in /_/src/libraries/System.Text.Json/tests/System.Text.Json.Tests/Serialization/Value.ReadTests.cs:line 458\r\n```",
          "createdAt": "2022-04-06T01:51:14Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-07-22T12:56:23Z",
          "id": "IC_kwDODI9FZc5A8rJK"
        },
        {
          "author": "krwq",
          "body": "There two other OutOfMemory issues I've noticed:\r\nhttps://github.com/dotnet/runtime/issues/71962\r\nhttps://github.com/dotnet/runtime/issues/67943\r\n\r\nI'm not sure they're related but it might be useful hint for whoever is investigating",
          "createdAt": "2022-07-12T12:58:24Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-07-12T12:58:24Z",
          "id": "IC_kwDODI9FZc5Gb8Ox"
        },
        {
          "author": "karelz",
          "body": "Didn't happen in 2+ months, removing blocking-outerloop label.",
          "createdAt": "2022-07-22T12:58:21Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-07-22T14:30:59Z",
          "id": "IC_kwDODI9FZc5HFNON"
        }
      ],
      "totalCount": 5,
      "endCursor": "Y3Vyc29yOnYyOpHORxTTjQ=="
    },
    "url": "https://github.com/dotnet/runtime/issues/63861",
    "title": "Test failure System.Text.Json.Serialization.Tests.ValueTests.VeryLongInputString(length: 1073741791)"
  },
  {
    "author": "eiriktsarpalis",
    "labels": [
      "area-System.Text.Json",
      "test-enhancement"
    ],
    "createdAt": "2022-02-14T19:29:10Z",
    "body": "I think this should make the cache work reasonably well with collectible assemblies, but it's hard to tell for sure. Could you please add a test which:\r\n* Creates a new unloadable ALC and loads some assembly with test types into it\r\n* Serializes/deserializes objects of the types from the assembly above\r\n* Unloads the ALC\r\n* Validates that the ALC was actually unloaded\r\n\r\nGood guide what to do is here: https://docs.microsoft.com/en-us/dotnet/standard/assembly/unloadability\r\n\r\nIn short what we want to avoid:\r\nGlobal GC root which holds onto anything from unloadable ALCs as that will prevent the ALC from unloading. We already have quite a few caches in the FX which do this, so let's not add another one.\r\n\r\n_Originally posted by @vitek-karas in https://github.com/dotnet/runtime/pull/64646#discussion_r805620266_",
    "number": 65323,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "EYES",
          "createdAt": "2023-09-03T09:59:42Z",
          "user": "T0shik"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-05-17T15:09:41Z",
          "user": "CypherDoesStuff"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-10-11T15:35:58Z",
          "user": "rolevax"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-04-03T02:36:06Z",
          "user": "goncalo"
        }
      ],
      "totalCount": 4,
      "endCursor": "Y3Vyc29yOnYyOpHODAyrcA=="
    },
    "updatedAt": "2025-02-21T14:23:52Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @vitek-karas, @agocke, @vsadov\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\nI think this should make the cache work reasonably well with collectible assemblies, but it's hard to tell for sure. Could you please add a test which:\r\n* Creates a new unloadable ALC and loads some assembly with test types into it\r\n* Serializes/deserializes objects of the types from the assembly above\r\n* Unloads the ALC\r\n* Validates that the ALC was actually unloaded\r\n\r\nGood guide what to do is here: https://docs.microsoft.com/en-us/dotnet/standard/assembly/unloadability\r\n\r\nIn short what we want to avoid:\r\nGlobal GC root which holds onto anything from unloadable ALCs as that will prevent the ALC from unloading. We already have quite a few caches in the FX which do this, so let's not add another one.\r\n\r\n_Originally posted by @vitek-karas in https://github.com/dotnet/runtime/pull/64646#discussion_r805620266_\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>eiriktsarpalis</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`area-AssemblyLoader-coreclr`, `untriaged`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2022-02-14T19:29:16Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-02-14T19:29:16Z",
          "id": "IC_kwDODI9FZc499Q-o"
        },
        {
          "author": null,
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\nI think this should make the cache work reasonably well with collectible assemblies, but it's hard to tell for sure. Could you please add a test which:\r\n* Creates a new unloadable ALC and loads some assembly with test types into it\r\n* Serializes/deserializes objects of the types from the assembly above\r\n* Unloads the ALC\r\n* Validates that the ALC was actually unloaded\r\n\r\nGood guide what to do is here: https://docs.microsoft.com/en-us/dotnet/standard/assembly/unloadability\r\n\r\nIn short what we want to avoid:\r\nGlobal GC root which holds onto anything from unloadable ALCs as that will prevent the ALC from unloading. We already have quite a few caches in the FX which do this, so let's not add another one.\r\n\r\n_Originally posted by @vitek-karas in https://github.com/dotnet/runtime/pull/64646#discussion_r805620266_\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>eiriktsarpalis</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`area-System.Text.Json`, `untriaged`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2022-02-14T19:29:38Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-02-14T19:29:38Z",
          "id": "IC_kwDODI9FZc499RDt"
        },
        {
          "author": "eiriktsarpalis",
          "body": "From https://github.com/dotnet/runtime/pull/64646#discussion_r805962605\r\n\r\n> In short what we want to avoid:\r\nGlobal GC root which holds onto anything from unloadable ALCs as that will prevent the ALC from unloading. We already have quite a few caches in the FX which do this, so let's not add another one.\r\n\r\nSystem.Text.Json already suffers from that issue since we're rooting the default JsonSerializerOptions instance (and any caches it may create):\r\n\r\nhttps://github.com/dotnet/runtime/blob/cff924f9c823208b21d85f8fd5eed7eee8d4017a/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/JsonSerializerOptions.cs#L35\r\n\r\nWe need to work out an eviction policy that takes into account the rooted instance as well, however that's not in scope for the current PR, which only addresses the performance issue.",
          "createdAt": "2022-02-14T19:30:28Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-02-14T19:30:28Z",
          "id": "IC_kwDODI9FZc499RQ4"
        },
        {
          "author": "eiriktsarpalis",
          "body": "I'm not sure what the best solution would be here. @stephentoub added [JsonSerializerOptionsUpdateHandler](https://github.com/dotnet/runtime/blob/e4fb7303f7be173f5434d711d42b4bba706d0ad0/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/JsonSerializerOptionsUpdateHandler.cs) to support hot reload. Perhaps we should expose something like this for users to call into when unloading their ALC?",
          "createdAt": "2022-02-14T19:33:03Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-02-14T19:33:03Z",
          "id": "IC_kwDODI9FZc499R3C"
        },
        {
          "author": "teo-tsirpanis",
          "body": "Perhaps using `ConditionalWeakTable` to store the types will help. I will prepare a PR at a later time.",
          "createdAt": "2022-02-14T23:43:24Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-02-14T23:43:24Z",
          "id": "IC_kwDODI9FZc49-GgO"
        },
        {
          "author": "stephentoub",
          "body": "> Perhaps using ConditionalWeakTable to store the types will help. I will prepare a PR at a later time.\r\n\r\nCWT could easily result in types getting dropped from the cache way earlier than they should, just because the GC happened to run, in turn resulting in huge increases in costs for JsonSerializer.\r\n\r\nIt's possible it could play a role, but any such changes will require very careful measurement.",
          "createdAt": "2022-02-15T01:58:35Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-02-15T01:58:35Z",
          "id": "IC_kwDODI9FZc49-Z3U"
        },
        {
          "author": "teo-tsirpanis",
          "body": "Can a `Type` instance get collected before it gets unloaded? I didn't know that. And I see the CWT was considered but turned down in https://github.com/dotnet/runtime/blob/a25aa6641b605f1ad28c75cddcfa204f8153abe3/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/JsonSerializerOptions.Caching.cs#L111\r\n\r\nAnother thing I thought is to add an `Unload` event handler on the unloadable ALC of a type whose serialization info is going to get cached, but it needs some care to add only one handler per ALC.",
          "createdAt": "2022-02-15T11:52:23Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-02-15T11:52:31Z",
          "id": "IC_kwDODI9FZc49_--g"
        },
        {
          "author": "jkotas",
          "body": "> Can a Type instance get collected before it gets unloaded? I didn't know that.\r\n\r\nIt cannot. Type instances get collected only once the types gets unloaded.",
          "createdAt": "2022-02-15T13:37:42Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-02-15T13:37:42Z",
          "id": "IC_kwDODI9FZc4-AXrJ"
        },
        {
          "author": "stephentoub",
          "body": "But a reference to a Type will also prevent unloading, even if a weak reference, yes? _If_ that's the case, which I thought it was, then the key to the CWT couldn't be a Type and still have that help with unloadability, at which point something else needs to be the key, and we're back to things getting dropped from the cache more aggressively/randomly than desired. if I'm wrong about a weak reference preventing unloadability, then ignore my comment. ",
          "createdAt": "2022-02-15T13:51:55Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-02-15T13:51:55Z",
          "id": "IC_kwDODI9FZc4-AbbS"
        },
        {
          "author": "jkotas",
          "body": "Type used as the key in CWT won't prevent unloading. You can think about CWT as adding an expando field to the item that is used as the key. CWT does not extend the lifetime of the key, but it keeps the value reachable for as long as the key is reachable.\r\n\r\nXmlSerializer has similar global singleton caches and it uses CWT to make them work with unloadable types: https://github.com/dotnet/runtime/blob/main/src/libraries/System.Private.Xml/src/System/Xml/Serialization/ContextAwareTables.cs#L15.",
          "createdAt": "2022-02-15T14:06:23Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-02-15T14:08:55Z",
                "user": "eiriktsarpalis"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOCOuCIA=="
          },
          "updatedAt": "2022-02-15T14:06:23Z",
          "id": "IC_kwDODI9FZc4-AfFP"
        },
        {
          "author": "jkotas",
          "body": "BTW: The original System.Text.Json design was trying to avoid these problematic global caches: https://github.com/dotnet/runtime/issues/28325 . It is unfortunate that we end up reintroducing them.",
          "createdAt": "2022-02-15T14:10:18Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-02-15T14:10:18Z",
          "id": "IC_kwDODI9FZc4-AgF1"
        },
        {
          "author": "stephentoub",
          "body": "> Type used as the key in CWT won't prevent unloading.\r\n\r\nIs this specific to CWT or does it apply to weak references in general?",
          "createdAt": "2022-02-15T14:11:46Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-02-15T14:11:46Z",
          "id": "IC_kwDODI9FZc4-Age1"
        },
        {
          "author": "stephentoub",
          "body": "> The original System.Text.Json design was trying to avoid these problematic global caches: https://github.com/dotnet/runtime/issues/28325\r\n\r\nyes and no. It was keeping the cache in the options instance and saying the user was responsuble for caching, but in the same breath also saying that passing options was optional, which then means the system needs to cache the default for good perf. ",
          "createdAt": "2022-02-15T14:15:56Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-02-15T14:16:39Z",
                "user": "eiriktsarpalis"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOCOuIww=="
          },
          "updatedAt": "2022-02-15T14:15:56Z",
          "id": "IC_kwDODI9FZc4-Ahn_"
        },
        {
          "author": "teo-tsirpanis",
          "body": "> Is this specific to CWT or does it apply to weak references in general?\n\nCWT uses dependent handles which are different from weak references. A weak reference on a type/object will not prevent its unloading/collection.",
          "createdAt": "2022-02-15T14:20:17Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-02-15T14:20:34Z",
                "user": "jkotas"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-02-15T14:20:47Z",
                "user": "vitek-karas"
              }
            ],
            "totalCount": 2,
            "endCursor": "Y3Vyc29yOnYyOpHOCOuMPQ=="
          },
          "updatedAt": "2022-02-15T14:20:17Z",
          "id": "IC_kwDODI9FZc4-Aix2"
        },
        {
          "author": "vitek-karas",
          "body": "> > Type used as the key in CWT won't prevent unloading.\r\n\r\n> Is this specific to CWT or does it apply to weak references in general?\r\n\r\nNo - unloading is driven by GC - if the Type object (treated as managed object) is collectible, it will be able to unload the assembly/ALC it belongs to. Basically - don't create managed memory leaks is the same thing as allow unloadability. (With the caveat that Type objects normally never go away, since they're tied by the runtime, unless the parent ALC is unloadable).",
          "createdAt": "2022-02-15T14:20:34Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-02-15T14:35:10Z",
                "user": "stephentoub"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOCOuZyw=="
          },
          "updatedAt": "2022-02-15T14:20:34Z",
          "id": "IC_kwDODI9FZc4-Ai2c"
        },
        {
          "author": "stephentoub",
          "body": "> CWT uses dependent handles\r\n\r\nYes, I know that.\r\nhttps://github.com/dotnet/coreclr/pulls?q=is%3Apr+conditionalweaktable+is%3Aclosed+author%3Astephentoub\r\n\r\nBut my mental model had long been that the key of a dependent handle _is_ a weak reference, and the dependent nature was from the value to the key. That's not the case? ",
          "createdAt": "2022-02-15T14:26:15Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-02-15T14:29:01Z",
          "id": "IC_kwDODI9FZc4-AkZC"
        },
        {
          "author": "teo-tsirpanis",
          "body": "It is a weak reference, but the types are strongly held _elsewhere_ until and if they are unloaded. When a type needs to be unloaded, it won't be hindered by being in a CWT's key.",
          "createdAt": "2022-02-15T14:28:48Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-02-15T14:28:48Z",
          "id": "IC_kwDODI9FZc4-AlHc"
        },
        {
          "author": "stephentoub",
          "body": "> but the types are strongly held elsewhere until and if they are unloaded\r\n\r\nHence my question about whether the described behavior was specific to CWT or for weak references in general, which Vitek answered. I'm not sure why \"CWT uses dependent handles which are different from weak references\" is relevant then. ",
          "createdAt": "2022-02-15T14:30:45Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-02-15T14:30:45Z",
          "id": "IC_kwDODI9FZc4-Alqw"
        },
        {
          "author": "teo-tsirpanis",
          "body": "Looks like I had got confused but your questions are answered either way. 😅\n\nIf you decide that a CWT is the best way to solve this, I can prepare a PR.",
          "createdAt": "2022-02-15T14:38:26Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-02-15T14:38:51Z",
          "id": "IC_kwDODI9FZc4-AnrU"
        },
        {
          "author": "krwq",
          "body": "It's unlikely we will have time to address this in 7.0, moving to 8.0",
          "createdAt": "2022-07-07T13:12:28Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-07-07T13:12:28Z",
          "id": "IC_kwDODI9FZc5GMKLa"
        },
        {
          "author": "FlurinBruehwiler",
          "body": "Hey, I am a beginner and this conversation goes a little bit over my head, but I think I'm running in to this exact issue. I want to unload an assembly, but it fails because I used System.Text.Json to serialize a type from the assembly. So my question is, is there currently a way to clear the cache (or disable it), or do I have to switch to a different Json Serializer?\r\n\r\nUpdate: Got it working now by clearing the caches through reflection.\r\n```\r\nvar assembly = typeof(JsonSerializerOptions).Assembly;\r\nvar updateHandlerType = assembly.GetType(\"System.Text.Json.JsonSerializerOptionsUpdateHandler\");\r\nvar clearCacheMethod = updateHandlerType?.GetMethod(\"ClearCache\", BindingFlags.Static | BindingFlags.Public);\r\nclearCacheMethod?.Invoke(null, new object?[] { null }); \r\n```",
          "createdAt": "2022-11-19T19:11:46Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-11-21T12:39:18Z",
                "user": "eiriktsarpalis"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-04-04T05:01:36Z",
                "user": "QianMoXi"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-06-09T20:25:23Z",
                "user": "Almas1997"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-06-10T01:33:55Z",
                "user": "erikpowa"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-02-28T12:40:01Z",
                "user": "renping106"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-03-28T02:51:58Z",
                "user": "GiantappMan"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-05-19T16:33:23Z",
                "user": "brancardoso"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-04-08T08:05:15Z",
                "user": "csharpfabian"
              }
            ],
            "totalCount": 8,
            "endCursor": "Y3Vyc29yOnYyOpHOENTJhg=="
          },
          "updatedAt": "2022-11-20T00:08:10Z",
          "id": "IC_kwDODI9FZc5OvBiX"
        },
        {
          "author": "simonferquel",
          "body": "A note about this, as part of working on CoreCLR support at Unity we encountered this issue. For now we are going to call `JsonSerializerOptionsUpdateHandler.ClearCache` by reflection as a workaround whenever we unload user code. ",
          "createdAt": "2023-12-15T09:54:02Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-12-15T09:54:02Z",
          "id": "IC_kwDODI9FZc5uuIYq"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Contrary to what I stated in the original post of the issue, the problem with unloading assemblies doesn't lie with the reusable caches implementation (it points to them using weak references) but the fact that we keep default singleton `JsonSerializerOptions` instances. These can all be cleared via the `JsonSerializerOptionsUpdateHandler.ClearCache` method which we added to support hot reload, but it seems we could make it public so that other consumers don't need to resort to reflection. cc @stephentoub",
          "createdAt": "2023-12-15T12:14:56Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-12-15T13:22:50Z",
                "user": "xoofx"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHODPuxsg=="
          },
          "updatedAt": "2023-12-15T12:14:56Z",
          "id": "IC_kwDODI9FZc5uu6QM"
        },
        {
          "author": "stephentoub",
          "body": "That effectively promotes what's intended to be an implementation detail to instead be something in the public API.  I'd rather explore alternative options, like using a CWT, or if that has measurably negative performance implications, looking at using a CWT only for types in unloadable assemblies.",
          "createdAt": "2024-01-02T03:21:00Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-01-02T03:21:00Z",
          "id": "IC_kwDODI9FZc5vrLl5"
        },
        {
          "author": "eiriktsarpalis",
          "body": "> That effectively promotes what's intended to be an implementation detail to instead be something in the public API.\r\n\r\nIt's pretty unambiguous in what it does and we have important customers taking a de facto dependency on the current private implementation. We probably couldn't change it much without introducing substantial disruption.\r\n\r\n> like using a CWT, or if that has measurably negative performance implications, looking at using a CWT only for types in unloadable assemblies.\r\n\r\nWe could try to measure this, but my concern is that this would still complicate lookup logic (checking if the assembly of the type is unloadable, looking up two separate caches). From my perspective the existing (private) approach is the simplest approach that shouldn't compromise lookup performance. ",
          "createdAt": "2024-01-08T09:52:01Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-01-08T09:52:01Z",
          "id": "IC_kwDODI9FZc5wGN03"
        },
        {
          "author": "stephentoub",
          "body": ">  we have important customers taking a de facto dependency on the current private implementation. We probably couldn't change it much without introducing substantial disruption.\r\n\r\nWe can't be in a situation where we're prevented from changing private APIs because someone is using them via private reflection. Someone doing so is on their own.",
          "createdAt": "2024-01-08T10:42:29Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-01-08T10:42:29Z",
          "id": "IC_kwDODI9FZc5wGhV0"
        },
        {
          "author": "vitek-karas",
          "body": "Aside from this being a bit weird from a caller's point of view (\"Why do I care it uses caches inside... why should I?\"), I think this would hurt our unloadability story. It's already a bit challenging because it's cooperative and it's easy to break things by holding onto references too long. The debugging story for this is also not the best (try to find GC roots for things in a given ALC, which currently requires SOS debugging). And even if I did go through all of that and found out that the GC root is inside `System.Text.Json`, how would I learn that I need to call this API?\r\n\r\nUnloadability should work out of the box - if my code doesn't hold onto anything in the ALC, I should be able to unload it. Note that this is not the only case in framework where we have global caches which hold onto types, if we used the same solution in the other places as well, I might need to call several such \"Clear\" methods every time I want to unload something. I just find that a really weird design choice.",
          "createdAt": "2024-01-08T10:45:00Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-01-08T10:52:41Z",
                "user": "stephentoub"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-02-28T12:42:26Z",
                "user": "renping106"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-03-15T15:05:23Z",
                "user": "FlurinBruehwiler"
              }
            ],
            "totalCount": 3,
            "endCursor": "Y3Vyc29yOnYyOpHOEKDI4Q=="
          },
          "updatedAt": "2024-01-08T10:45:00Z",
          "id": "IC_kwDODI9FZc5wGiTg"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Here's a benchmark comparing lookup performance between CD and CWT for `Type` keys:\r\n\r\n```C#\r\nusing BenchmarkDotNet.Attributes;\r\nusing BenchmarkDotNet.Running;\r\nusing System.Collections.Concurrent;\r\nusing System.Runtime.CompilerServices;\r\n\r\nBenchmarkRunner.Run<Benchmark>();\r\n\r\npublic class Benchmark\r\n{\r\n    [Params(1, 10, 100, 1000, 2000)]\r\n    public int Count;\r\n\r\n    public class TypeToHit;\r\n    public class  TypeToMiss;\r\n\r\n    private ConcurrentDictionary<Type, string> _concurrentDict = new();\r\n    private ConditionalWeakTable<Type, string> _conditionalWeakTable = new();\r\n\r\n    [GlobalSetup]\r\n    public void Init()\r\n    {\r\n        var types = typeof(int).Assembly.GetTypes()\r\n            .Take(Count - 1)\r\n            .Append(typeof(TypeToHit));\r\n\r\n        foreach (Type t in types)\r\n        {\r\n            _concurrentDict[t] = t.Name;\r\n            _conditionalWeakTable.Add(t, t.Name);\r\n        }\r\n    }\r\n\r\n    [Benchmark]\r\n    public string? ConcurrentDictionary_Hit() \r\n        => _concurrentDict.TryGetValue(typeof(TypeToHit), out string? value) ? value : null;\r\n\r\n    [Benchmark]\r\n    public string? ConcurrentDictionary_Miss() \r\n        => _concurrentDict.TryGetValue(typeof(TypeToMiss), out string? value) ? value : null;\r\n\r\n    [Benchmark]\r\n    public string? ConditionalWeakTable_Hit() \r\n        => _conditionalWeakTable.TryGetValue(typeof(TypeToHit), out string? value) ? value : null;\r\n\r\n    [Benchmark]\r\n    public string? ConditionalWeakTable_Miss() \r\n        => _conditionalWeakTable.TryGetValue(typeof(TypeToMiss), out string? value) ? value : null;\r\n}\r\n```\r\n\r\n## Results\r\n\r\n| Method                    | Count | Mean     | Error     | StdDev    |\r\n|-------------------------- |------ |---------:|----------:|----------:|\r\n| ConcurrentDictionary_Hit  | 1     | 4.457 ns | 0.0868 ns | 0.0812 ns |\r\n| ConcurrentDictionary_Miss | 1     | 2.089 ns | 0.0742 ns | 0.0694 ns |\r\n| ConditionalWeakTable_Hit  | 1     | 6.582 ns | 0.0474 ns | 0.0370 ns |\r\n| ConditionalWeakTable_Miss | 1     | 2.330 ns | 0.0684 ns | 0.0606 ns |\r\n| ConcurrentDictionary_Hit  | 10    | 4.069 ns | 0.0591 ns | 0.0524 ns |\r\n| ConcurrentDictionary_Miss | 10    | 1.884 ns | 0.0711 ns | 0.0665 ns |\r\n| ConditionalWeakTable_Hit  | 10    | 7.105 ns | 0.1192 ns | 0.0931 ns |\r\n| ConditionalWeakTable_Miss | 10    | 2.121 ns | 0.0416 ns | 0.0389 ns |\r\n| ConcurrentDictionary_Hit  | 100   | 4.188 ns | 0.1218 ns | 0.1139 ns |\r\n| ConcurrentDictionary_Miss | 100   | 1.964 ns | 0.0771 ns | 0.0721 ns |\r\n| ConditionalWeakTable_Hit  | 100   | 6.683 ns | 0.1510 ns | 0.1413 ns |\r\n| ConditionalWeakTable_Miss | 100   | 2.085 ns | 0.0577 ns | 0.0540 ns |\r\n| ConcurrentDictionary_Hit  | 1000  | 4.079 ns | 0.1199 ns | 0.1231 ns |\r\n| ConcurrentDictionary_Miss | 1000  | 1.882 ns | 0.0563 ns | 0.0527 ns |\r\n| ConditionalWeakTable_Hit  | 1000  | 6.738 ns | 0.1187 ns | 0.1110 ns |\r\n| ConditionalWeakTable_Miss | 1000  | 2.087 ns | 0.0582 ns | 0.0544 ns |\r\n| ConcurrentDictionary_Hit  | 2000  | 3.996 ns | 0.0831 ns | 0.0777 ns |\r\n| ConcurrentDictionary_Miss | 2000  | 1.834 ns | 0.0536 ns | 0.0501 ns |\r\n| ConditionalWeakTable_Hit  | 2000  | 6.664 ns | 0.1163 ns | 0.1031 ns |\r\n| ConditionalWeakTable_Miss | 2000  | 2.116 ns | 0.0585 ns | 0.0547 ns |\r\n\r\nRoughly speaking this is showing a 2x slowdown, but I'm not sure how substantially that would register in the context of a full-blown serialization operation. It probably would regress performance in some of our microbenchmarks measuring serialization for small POCOs.",
          "createdAt": "2024-01-08T13:11:07Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-01-08T13:11:07Z",
          "id": "IC_kwDODI9FZc5wHXtV"
        },
        {
          "author": "eiriktsarpalis",
          "body": "@vitek-karas are there any circumstances beyond assembly unload events that could result in `Type` instances getting collected? We'd want to avoid the possibility of needing to recompute caches for the same types.",
          "createdAt": "2024-01-08T13:13:02Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-01-08T13:13:02Z",
          "id": "IC_kwDODI9FZc5wHYfI"
        },
        {
          "author": "vitek-karas",
          "body": "I actually don't know if types built dynamically via `TypeBuilder` are collectible, if so, those would be the other case. ",
          "createdAt": "2024-01-08T13:18:41Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-01-08T13:18:41Z",
          "id": "IC_kwDODI9FZc5wHajw"
        },
        {
          "author": "jkotas",
          "body": "> types built dynamically via TypeBuilder are collectible\r\n\r\nUnloadability is at assembly granularity. The types are collectible if their assembly builder was created using AssemblyBuilderAccess.RunAndCollect.\r\n\r\n> assembly unload events\r\n\r\nI do not think we have public assembly unload event API.",
          "createdAt": "2024-01-08T14:58:22Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-01-08T14:58:22Z",
          "id": "IC_kwDODI9FZc5wIHAI"
        },
        {
          "author": "Delsin-Yu",
          "body": "Is there any chance we can get this in .Net 9?",
          "createdAt": "2024-06-17T08:29:35Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-06-17T08:29:35Z",
          "id": "IC_kwDODI9FZc6Bf-9_"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Very unlikely at this point.",
          "createdAt": "2024-06-17T09:20:02Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-06-17T13:32:24Z",
                "user": "Delsin-Yu"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHODl7gYw=="
          },
          "updatedAt": "2024-06-17T09:20:02Z",
          "id": "IC_kwDODI9FZc6BgvV4"
        },
        {
          "author": "Delsin-Yu",
          "body": "I want to include that the `Godot.Net` developers are also affected by this issue. It is not a rare case to do Json Serialization/Deserialization in Unlodable Assemblies (for editor tooling).\n\nNow that `.Net 9` is out, it would be great if we can hear the team's perspective on this feature and its position on the work list. It is really frustrating to see it postponed each time and eventually put on the `future` (if not `never`) list.\n\nDoes adding the unloadability to `System.Text.Json` cause intolerable performance degradation, or is the unloadability for the entire BCL a systematic task that needs to be addressed and should not be patched only for `System.Text.Json`?\n\nAlternatively, can we reload the CLR to ignore the not unloadable ALCs (like reloading the entire BCL)? I apologize for my lack of knowledge of the low-level runtime design.",
          "createdAt": "2025-02-20T20:29:09Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-02-20T21:38:40Z",
          "id": "IC_kwDODI9FZc6fTM22"
        },
        {
          "author": "eiriktsarpalis",
          "body": "I would be inclined to just promote the existing method to a public API. The solution of using a CWT instead of CD is bound to introduce performance regressions -- we already know that CD lookups account for a nontrivial part of the serialization cost so regressing that by 2x per the benchmarks above is not a good look.",
          "createdAt": "2025-02-21T12:46:50Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-02-21T12:46:50Z",
          "id": "IC_kwDODI9FZc6faRwm"
        },
        {
          "author": "simonferquel",
          "body": "Another approach would be to subscribe to ALC unload requests: when an entry in the cache is added, look if its owning ALC is already known. If it is not and it is unloadable, subscribe to the unloaded event to automatically clear cache.\nThis way, lookup complexity is the same, all additional checks are done only once when an entry is added.",
          "createdAt": "2025-02-21T12:57:55Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-02-21T12:57:55Z",
          "id": "IC_kwDODI9FZc6faXgz"
        },
        {
          "author": "tbdty",
          "body": "> Another approach would be to subscribe to ALC unload requests: when an entry in the cache is added, look if its owning ALC is already known. If it is not and it is unloadable, subscribe to the unloaded event to automatically clear cache. This way, lookup complexity is the same, all additional checks are done only once when an entry is added.\n\nThat will not work. There is no `Unloaded` event, there is an `Unloading` event. The latter occurs when an unload is requested, not when the actual unload is performed - and an unload will never be performed because you keep holding references to types from the ALC.",
          "createdAt": "2025-02-21T13:03:15Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-02-21T13:03:15Z",
          "id": "IC_kwDODI9FZc6faaP5"
        },
        {
          "author": "simonferquel",
          "body": "Unloading is what we want in that case: the ALC is not unloaded because System.Text.Json caches hold onto it: cache needs to be cleared when Unloading is raised so that the ALC can ultimately get unloaded once GC has collected all objects created from it.",
          "createdAt": "2025-02-21T13:05:59Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-02-21T13:05:59Z",
          "id": "IC_kwDODI9FZc6facGR"
        },
        {
          "author": "tbdty",
          "body": "> I would be inclined to just promote the existing method to a public API. The solution of using a CWT instead of CD is bound to introduce performance regressions -- we already know that CD lookups account for a nontrivial part of the serialization cost so regressing that by 2x per the benchmarks above is not a good look.\n\nThat is a very ugly workaround to the problem at best. You still have to actively be aware of System.Text.Json caching for unloading to work properly.\n\nWhat about the solution suggested in https://github.com/dotnet/runtime/issues/65323#issuecomment-1040314703? In this solution, you would maintain two caches: The current default one, and one for collectible types that uses a CWT. Things would \"just work\" and you would only pay the performance penalty if you actually use collectible assemblies.\n\n",
          "createdAt": "2025-02-21T13:06:34Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-02-21T13:06:34Z",
          "id": "IC_kwDODI9FZc6facbm"
        },
        {
          "author": "jkotas",
          "body": "> The solution of using a CWT instead of CD is bound to introduce performance regressions \n\nCan this be pay-for-play? Use CWT for unloadable types only?",
          "createdAt": "2025-02-21T13:07:31Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-02-21T13:08:47Z",
          "id": "IC_kwDODI9FZc6fac79"
        },
        {
          "author": "simonferquel",
          "body": "@tbdty please reconsider the option of subscribing to the unloading event, this is actually the event needed (we are trying to prevent ALC to be kept alive, so we need to clear when Unloading is requested, not when it actually completes - which wont happen unless we clear the cache)",
          "createdAt": "2025-02-21T13:09:51Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-02-21T13:09:51Z",
          "id": "IC_kwDODI9FZc6faeKG"
        },
        {
          "author": "tbdty",
          "body": "> Unloading is what we want in that case: the ALC is not unloaded because System.Text.Json caches hold onto it: cache needs to be cleared when Unloading is raised so that the ALC can ultimately get unloaded once GC has collected all objects created from it.\n\nThat is not how ALC works, there is no trigger to unload. The documentation even explicitly states that `Unload` is just a signal for the runtime to allow unloading as soon as it becomes possible. In my main use case, I actually create a collectible ALC, load an assembly from it, return that assembly and immediately call `Unload()` in the finally block. The references to the actual assembly may be dropped days or weeks later and the assembly is then collected.\n\nEven if you don't do it like this, your suggestion immediately breaks if someone calls `Unload` and then directly calls `JsonSerializer.Deserialize<TypeFromThatAssembly>`, because the cache is cleared when `Unload` is called, but a new cache entry is added afterwards. Getting this right will be a nightmare and extremely hard to debug.\n\nThe entire point of collectible ALC is that the GC is capable of detecting when unloading can happen. By keeping these caches, we are preventing that mechanism from working.",
          "createdAt": "2025-02-21T13:14:47Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-02-21T13:14:47Z",
          "id": "IC_kwDODI9FZc6fagq8"
        },
        {
          "author": "Delsin-Yu",
          "body": "It would be great to have something that can operate at the ALC level, like `[ALCStatic]` attribute on a field, but that's certainly a runtime change.",
          "createdAt": "2025-02-21T13:43:15Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-02-21T13:43:15Z",
          "id": "IC_kwDODI9FZc6favvd"
        },
        {
          "author": "jkotas",
          "body": "> It would be great to have something that can operate at the ALC level, like [ALCStatic] attribute on a field, but that's certainly a runtime change.\n\nIt would have similar overhead as conditional weak table. Also, I do not see how this can work here. The field that's keeping the ALC alive is in concurrent dictionary.",
          "createdAt": "2025-02-21T14:06:23Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-02-21T14:23:53Z",
                "user": "Delsin-Yu"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOEHL2UA=="
          },
          "updatedAt": "2025-02-21T14:06:23Z",
          "id": "IC_kwDODI9FZc6fa9mc"
        },
        {
          "author": "Delsin-Yu",
          "body": "> The field that's keeping the ALC alive is in concurrent dictionary.\n\nAh, you are correct; the calling assembly is different so it won't work anyway.",
          "createdAt": "2025-02-21T14:23:50Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-02-21T14:23:50Z",
          "id": "IC_kwDODI9FZc6fbHhi"
        }
      ],
      "totalCount": 45,
      "endCursor": "Y3Vyc29yOnYyOpHOn2x4Yg=="
    },
    "url": "https://github.com/dotnet/runtime/issues/65323",
    "title": "System.Text.Json should support unloadable assemblies correctly"
  },
  {
    "author": "VincentBu",
    "labels": [
      "test-failure",
      "area-System.Text.Json"
    ],
    "createdAt": "2022-02-16T01:45:03Z",
    "body": "Affected tests:\r\n- System.Text.Json.SourceGeneration.Tests.ConstructorTests_Metadata.MultipleThreadsLooping\r\n- System.Text.Json.SourceGeneration.Tests.ConstructorTests_Default_String.MultipleThreadsLooping\r\n\r\nFrequency:\r\nDay | Run | Notes\r\n-- | -- | --\r\n**3/27-7/22**\r\n6/30 | Official run | ConstructorTests_Default_String\r\n5/24 | Official run | ConstructorTests_Metadata\r\n\r\n```kusto\r\nlet failedTests = (testNameSubstring : string, methodName : string, includePR : bool, messageSubstr: string, includePassedOnRerun : bool) {\r\ncluster('engsrvprod.kusto.windows.net').database('engineeringdata').AzureDevOpsTests\r\n    | where TestName contains testNameSubstring\r\n    | where includePassedOnRerun or (Outcome == 'Failed')\r\n    | extend startOfTestName = indexof_regex(TestName, @\"[^.]+$\")\r\n    | extend Method = substring(TestName, startOfTestName)\r\n    | extend Type = substring(TestName, 0, startOfTestName - 1)\r\n    | project-away startOfTestName\r\n    | where (methodName == '') or (Method == methodName)\r\n    | where Message contains messageSubstr\r\n    | distinct JobId, WorkItemId, Message, StackTrace, Method, Type, Arguments, Outcome\r\n    | join kind=inner (cluster('engsrvprod.kusto.windows.net').database('engineeringdata').Jobs\r\n        | where ((Branch == 'refs/heads/main') or (Branch == 'refs/heads/master') or (includePR and (Source startswith \"pr/\")))\r\n        | where Type startswith \"test/functional/cli/\"\r\n            and not(Properties contains \"runtime-staging\")\r\n        | summarize arg_max(Finished, Properties, Type, Branch, Source, Started, QueueName) by JobId\r\n        | project-rename JobType = Type) on JobId\r\n    | extend PropertiesJson = parse_json(Properties)\r\n    | extend OS = replace_regex(tostring(PropertiesJson.operatingSystem), @'\\((.*)\\).*|([^\\(].*)', @'\\1\\2')\r\n    | extend Runtime = iif(PropertiesJson.runtimeFlavor == \"mono\", \"Mono\", iif(PropertiesJson.DefinitionName contains \"coreclr\", \"CoreCLR\", \"\"))\r\n    | extend TargetBranch = extractjson(\"$.['System.PullRequest.TargetBranch']\", Properties)\r\n    | extend Architecture = PropertiesJson.architecture\r\n    | extend Scenario = iif(isempty(PropertiesJson.scenario), \"--\", PropertiesJson.scenario)\r\n    //| extend DefinitionName = PropertiesJson.DefinitionName\r\n    | project-away PropertiesJson\r\n};\r\nfailedTests('', 'MultipleThreadsLooping', true, '', true);\r\n```\r\n\r\nRun: [runtime-libraries-coreclr outerloop 20220215.3](https://dev.azure.com/dnceng/public/_build/results?buildId=1613576&view=ms.vss-test-web.build-test-results-tab&runId=44921124&paneView=debug&resultId=103520)\r\n\r\nFailed test:\r\n```\r\nnet7.0-windows-Release-x86-CoreCLR_release-Windows.Amd64.Server2022.Open\r\n\r\n- System.Text.Json.SourceGeneration.Tests.ConstructorTests_Metadata.MultipleThreadsLooping\r\n\r\n```\r\n**Error message:**\r\n```\r\nSystem.Text.Json.JsonException : '0x0D' is invalid within a JSON string. The string should be correctly escaped. Path: $.MyTuple.Item2 | LineNumber: 284 | BytePositionInLine: 179.\r\n---- System.Text.Json.JsonReaderException : '0x0D' is invalid within a JSON string. The string should be correctly escaped. LineNumber: 284 | BytePositionInLine: 179.\r\n\r\n\r\nStack trace\r\n   at System.Text.Json.ThrowHelper.ReThrowWithPath(ReadStack& state, JsonReaderException ex) in /_/src/libraries/System.Text.Json/src/System/Text/Json/ThrowHelper.Serialization.cs:line 264\r\n   at System.Text.Json.Serialization.JsonConverter`1.ReadCore(Utf8JsonReader& reader, JsonSerializerOptions options, ReadStack& state) in /_/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/JsonConverterOfT.ReadCore.cs:line 114\r\n   at System.Text.Json.Serialization.JsonConverter`1.ReadCoreAsObject(Utf8JsonReader& reader, JsonSerializerOptions options, ReadStack& state) in /_/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/JsonConverterOfT.ReadCore.cs:line 15\r\n   at System.Text.Json.JsonSerializer.ReadFromSpan[TValue](ReadOnlySpan`1 utf8Json, JsonTypeInfo jsonTypeInfo, Nullable`1 actualByteCount) in /_/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/JsonSerializer.Read.Helpers.cs:line 55\r\n   at System.Text.Json.JsonSerializer.ReadFromSpan[TValue](ReadOnlySpan`1 json, JsonTypeInfo jsonTypeInfo) in /_/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/JsonSerializer.Read.String.cs:line 310\r\n   at System.Text.Json.JsonSerializer.Deserialize(String json, Type returnType, JsonSerializerContext context) in /_/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/JsonSerializer.Read.String.cs:line 0\r\n   at System.Text.Json.SourceGeneration.Tests.StringSerializerWrapper.DeserializeWrapper(String json, Type type, JsonSerializerOptions options) in /_/src/libraries/System.Text.Json/tests/System.Text.Json.SourceGeneration.Tests/Serialization/JsonSerializerWrapper.cs:line 104\r\n   at System.Text.Json.Serialization.Tests.ConstructorTests.<MultipleThreads>g__DeserializeObjectAsync|12_0(String json, Type type, JsonSerializerOptions options) in /_/src/libraries/System.Text.Json/tests/Common/ConstructorTests/ConstructorTests.Cache.cs:line 34\r\n   at System.Text.Json.Serialization.Tests.ConstructorTests.<MultipleThreads>g__DeserializeObjectFlippedAsync|12_2(Type type, JsonSerializerOptions options) in /_/src/libraries/System.Text.Json/tests/Common/ConstructorTests/ConstructorTests.Cache.cs:line 46\r\n   at System.Text.Json.Serialization.Tests.ConstructorTests.<MultipleThreads>g__RunTestAsync|12_5(Type type) in /_/src/libraries/System.Text.Json/tests/Common/ConstructorTests/ConstructorTests.Cache.cs:line 81\r\n   at System.Text.Json.Serialization.Tests.ConstructorTests.MultipleThreads() in /_/src/libraries/System.Text.Json/tests/Common/ConstructorTests/ConstructorTests.Cache.cs:line 86\r\n   at System.Text.Json.Serialization.Tests.ConstructorTests.MultipleThreadsLooping() in /_/src/libraries/System.Text.Json/tests/Common/ConstructorTests/ConstructorTests.Cache.cs:line 20\r\n--- End of stack trace from previous location ---\r\n----- Inner Stack Trace -----\r\n   at System.Text.Json.ThrowHelper.ThrowJsonReaderException(Utf8JsonReader& json, ExceptionResource resource, Byte nextByte, ReadOnlySpan`1 bytes) in /_/src/libraries/System.Text.Json/src/System/Text/Json/ThrowHelper.cs:line 279\r\n   at System.Text.Json.Utf8JsonReader.ConsumeStringAndValidate(ReadOnlySpan`1 data, Int32 idx) in /_/src/libraries/System.Text.Json/src/System/Text/Json/Reader/Utf8JsonReader.cs:line 1365\r\n   at System.Text.Json.Utf8JsonReader.ConsumeString() in /_/src/libraries/System.Text.Json/src/System/Text/Json/Reader/Utf8JsonReader.cs:line 1271\r\n   at System.Text.Json.Utf8JsonReader.ConsumePropertyName() in /_/src/libraries/System.Text.Json/src/System/Text/Json/Reader/Utf8JsonReader.cs:line 1226\r\n   at System.Text.Json.Utf8JsonReader.ConsumeNextToken(Byte marker) in /_/src/libraries/System.Text.Json/src/System/Text/Json/Reader/Utf8JsonReader.cs:line 1711\r\n   at System.Text.Json.Utf8JsonReader.ConsumeNextTokenOrRollback(Byte marker) in /_/src/libraries/System.Text.Json/src/System/Text/Json/Reader/Utf8JsonReader.cs:line 1702\r\n   at System.Text.Json.Utf8JsonReader.ReadSingleSegment() in /_/src/libraries/System.Text.Json/src/System/Text/Json/Reader/Ut\r\n```",
    "number": 65418,
    "reactions": {
      "hasNextPage": false,
      "nodes": [],
      "totalCount": 0,
      "endCursor": null
    },
    "updatedAt": "2022-08-09T10:37:12Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": "eiriktsarpalis",
          "body": "Appears related to #65021",
          "createdAt": "2022-02-17T16:59:47Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-02-17T16:59:47Z",
          "id": "IC_kwDODI9FZc4-LcxL"
        },
        {
          "author": "karelz",
          "body": "Less than 1 hit per month, removing blocking-outerloop label.",
          "createdAt": "2022-07-22T14:05:18Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-07-22T14:05:35Z",
          "id": "IC_kwDODI9FZc5HFcyf"
        }
      ],
      "totalCount": 2,
      "endCursor": "Y3Vyc29yOnYyOpHORxXMnw=="
    },
    "url": "https://github.com/dotnet/runtime/issues/65418",
    "title": "Test failure System.Text.Json.SourceGeneration.Tests.ConstructorTests_Metadata.MultipleThreadsLooping"
  },
  {
    "author": "elinor-fung",
    "labels": [
      "area-System.Text.Json",
      "disabled-test"
    ],
    "createdAt": "2022-03-05T02:30:51Z",
    "body": "After https://github.com/dotnet/runtime/pull/65863, these two are failing on net48 runs:\r\n- `System.Text.Json.Serialization.Tests.CacheTests.JsonSerializerOptions_ReuseConverterCaches`\r\n- `System.Text.Json.Serialization.Tests.CustomConverterTests.GetConverter_Poco_WriteThrowsNotSupportedException`\r\n\r\n```\r\nChild exception:\r\n  System.IO.FileLoadException: Could not load file or assembly 'System.Runtime.CompilerServices.Unsafe, Version=4.0.4.1, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a' or one of its dependencies. The located assembly's manifest definition does not match the assembly reference. (Exception from HRESULT: 0x80131040)\r\nFile name: 'System.Runtime.CompilerServices.Unsafe, Version=4.0.4.1, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a'\r\n   at System.Span`1..ctor(T[] array, Int32 start, Int32 length)\r\n   at System.Text.Json.PooledByteBufferWriter.Dispose()\r\n   at System.Text.Json.JsonSerializer.WriteStringUsingSerializer[TValue](TValue& value, JsonTypeInfo jsonTypeInfo)\r\n   at System.Text.Json.JsonSerializer.Serialize[TValue](TValue value, JsonSerializerOptions options)\r\n   at System.Text.Json.Serialization.Tests.CustomConverterTests.<>c.<GetConverter_Poco_WriteThrowsNotSupportedException>b__321_0()\r\n```\r\n\r\nBuild: https://dev.azure.com/dnceng/public/_build/results?buildId=1637814&view=ms.vss-test-web.build-test-results-tab&runId=45326006&paneView=debug&resultId=118036\r\n\r\ncc @eiriktsarpalis @layomia \r\n",
    "number": 66232,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-10-19T15:29:02Z",
          "user": "mrBen"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-03-11T14:50:30Z",
          "user": "nmoreaud"
        }
      ],
      "totalCount": 2,
      "endCursor": "Y3Vyc29yOnYyOpHOC2cg5w=="
    },
    "updatedAt": "2024-06-04T15:12:46Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\nAfter https://github.com/dotnet/runtime/pull/65863, these two are failing on net48 runs:\r\n- `System.Text.Json.Serialization.Tests.CacheTests.JsonSerializerOptions_ReuseConverterCaches`\r\n- `System.Text.Json.Serialization.Tests.CustomConverterTests.GetConverter_Poco_WriteThrowsNotSupportedException`\r\n\r\n```\r\nChild exception:\r\n  System.IO.FileLoadException: Could not load file or assembly 'System.Runtime.CompilerServices.Unsafe, Version=4.0.4.1, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a' or one of its dependencies. The located assembly's manifest definition does not match the assembly reference. (Exception from HRESULT: 0x80131040)\r\nFile name: 'System.Runtime.CompilerServices.Unsafe, Version=4.0.4.1, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a'\r\n   at System.Span`1..ctor(T[] array, Int32 start, Int32 length)\r\n   at System.Text.Json.PooledByteBufferWriter.Dispose()\r\n   at System.Text.Json.JsonSerializer.WriteStringUsingSerializer[TValue](TValue& value, JsonTypeInfo jsonTypeInfo)\r\n   at System.Text.Json.JsonSerializer.Serialize[TValue](TValue value, JsonSerializerOptions options)\r\n   at System.Text.Json.Serialization.Tests.CustomConverterTests.<>c.<GetConverter_Poco_WriteThrowsNotSupportedException>b__321_0()\r\n```\r\n\r\nBuild: https://dev.azure.com/dnceng/public/_build/results?buildId=1637814&view=ms.vss-test-web.build-test-results-tab&runId=45326006&paneView=debug&resultId=118036\r\n\r\ncc @eiriktsarpalis @layomia \r\n\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>elinor-fung</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`area-System.Text.Json`, `untriaged`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2022-03-05T02:30:56Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-03-05T02:30:56Z",
          "id": "IC_kwDODI9FZc4_KRCv"
        },
        {
          "author": "eiriktsarpalis",
          "body": "I've disabled the failing tests in #66248, reopening to track the issue.",
          "createdAt": "2022-03-05T20:00:16Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-03-05T20:01:02Z",
          "id": "IC_kwDODI9FZc4_K5_i"
        },
        {
          "author": "mrBen",
          "body": "Is there a known workaround for this bug? \r\n\r\nI get the same exception as described when calling `JsonSerializer.Serialize` and I'm stuck with .NET Framework at the moment because I'm writing a VS 2019 extension.\r\n\r\nAdding `<PackageReference Include=\"System.Runtime.CompilerServices.Unsafe\" Version=\"4.5.3\"/>` to my .csproj doesn't help, as I also get a `System.IO.FileLoadException` when I call `JsonSerializer.Deserialize`, but with version 6.0.0.0.\r\n\r\n> **System.IO.FileLoadException:** 'Could not load file or assembly 'System.Runtime.CompilerServices.Unsafe, Version=6.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a' or one of its dependencies. [...]",
          "createdAt": "2022-10-19T15:42:19Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-10-19T15:42:19Z",
          "id": "IC_kwDODI9FZc5Mi5wZ"
        },
        {
          "author": "arturfilar",
          "body": "Is there any update on this?\r\nUsing System.Text.Json 7.0.0 and it screams for 'System.Runtime.CompilerServices.Unsafe, Version=4.0.4.1. Which I don't think is even referenced by Json package. Weird",
          "createdAt": "2023-11-14T18:59:51Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-11-14T18:59:51Z",
          "id": "IC_kwDODI9FZc5r8Uwe"
        },
        {
          "author": "Erithax",
          "body": "I am also encountering this issue using `System.Text.Json.JsonSerializer.Deserialize<T>(text, opts);` 8.0.3 in NET48 and fixes proposed elsewhere like\r\n```xml\r\n<!-- app.config --> \r\n<dependentAssembly>\r\n  <assemblyIdentity name=\"System.Runtime.CompilerServices.Unsafe\" publicKeyToken=\"b03f5f7f11d50a3a\" culture=\"neutral\" />\r\n  <bindingRedirect oldVersion=\"0.0.0.0-6.0.0.0\" newVersion=\"6.0.0.0\" />\r\n</dependentAssembly>\r\n```\r\ndo not help.\r\n\r\nMy exact error, with fusion log enabled, is\r\n```\r\nSystem.IO.FileLoadException: Could not load file or assembly 'System.Runtime.CompilerServices.Unsafe, Version=4.0.4.1, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a' or one of its dependencies. The located assembly's manifest definition does not match the assembly reference. (Exception from HRESULT: 0x80131040)\r\nFile name: 'System.Runtime.CompilerServices.Unsafe, Version=4.0.4.1, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a'\r\n   at System.SpanHelpers.PerTypeValues`1.MeasureArrayAdjustment()\r\n   at System.SpanHelpers.PerTypeValues`1..cctor()\r\n\r\n=== Pre-bind state information ===\r\nLOG: DisplayName = System.Runtime.CompilerServices.Unsafe, Version=4.0.4.1, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a\r\n (Fully-specified)\r\nLOG: Appbase = file:///C:/redacted/\r\nLOG: Initial PrivatePath = NULL\r\nCalling assembly : System.Memory, Version=4.0.1.2, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51.\r\n===\r\nLOG: This bind starts in default load context.\r\nLOG: Using application configuration file: C:\\redacted\\red.exe.Config\r\nLOG: Using host configuration file: \r\nLOG: Using machine configuration file from C:\\Windows\\Microsoft.NET\\Framework64\\v4.0.30319\\config\\machine.config.\r\nLOG: The same bind was seen before, and was failed with hr = 0x80131040.\r\n```",
          "createdAt": "2024-06-04T14:50:41Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-06-04T15:12:46Z",
          "id": "IC_kwDODI9FZc6AA9w1"
        }
      ],
      "totalCount": 5,
      "endCursor": "Y3Vyc29yOnYyOpHOgAPcNQ=="
    },
    "url": "https://github.com/dotnet/runtime/issues/66232",
    "title": "System.Text.Json.Serialization.Tests failing with `FileLoadException` on net48 runs"
  },
  {
    "author": "AdamMil",
    "labels": [
      "bug",
      "area-System.Text.Json"
    ],
    "createdAt": "2022-04-01T19:54:03Z",
    "body": "### Description\r\n\r\nSystem.Text.Json.Utf8JsonReader is supposed to be resumable, so that you can read data in chunks, resuming the reader after each chunk. However, the JsonSerializer.Deserialize(ref Utf8JsonReader, ...) methods do not work reliably with a reader that has been resumed at the beginning of an object or array to deserialize. (I haven't tested strings, numbers, etc.)\r\n\r\nI believe this is because internally, JsonSerializer.Read\\<T\\>(ref Utf8JsonReader, JsonTypeInfo) tries to copy the entire object or array into a separate buffer, _including the initial '{' or '[' character which has already been consumed by the reader_, and then create a new reader to deserialize from that buffer. In the case of a reader that has been resumed at the StartObject or StartArray token, the '{' or '[' character will not exist - because it has already been consumed from the input stream. Really, I don't think JsonSerializer should be trying to look backwards, at data that has already been consumed from the input source. The reader is supposed to be forward-only.\r\n\r\n### Reproduction Steps\r\n\r\nHere is one way to cause the exception:\r\n````C#\r\npublic class Foo { public int a { get; set; } }\r\nvar bytes = System.Text.Encoding.ASCII.GetBytes(\"{\\\"a\\\":7}\").AsSpan();\r\nvar jr = new Utf8JsonReader(bytes[..1], false, new JsonReaderState());\r\nvar read = jr.Read(); // move to StartObject. consume '{'\r\njr = new Utf8JsonReader(bytes[(int)jr.BytesConsumed..], true, jr.CurrentState); // BytesConsumed is 1\r\nvar foo = JsonSerializer.Deserialize<Foo>(ref jr); // this fails\r\n````\r\n\r\nThere are many other, similar patterns that all fail.\r\n\r\n### Expected behavior\r\n\r\nJsonSerializer should respect the forward-only nature of the reader and not try to look backwards at already-consumed data, so that it can work with readers that have been resumed. The resumability of Utf8JsonReader is a core part of its design.\r\n\r\nMore specifically, the Deserialize methods that take a Utf8JsonReader should work if the reader is resumed at the start of the value to deserialize.\r\n\r\nIt would also be nice if it didn't try to copy the entire object or array - which can be quite large - into a separate buffer and then deserialize it using a separate reader. Can't it just use the reader I give it?\r\n\r\n### Actual behavior\r\n\r\nIt fails with an exception like the following:\r\n\r\n````\r\nSystem.Text.Json.JsonException\r\n  HResult=0x80131500\r\n  Message=The JSON value could not be converted to Test.Program+Foo. Path: $ | LineNumber: 0 | BytePositionInLine: 3.\r\n  Source=System.Text.Json\r\n  StackTrace:\r\n   at System.Text.Json.ThrowHelper.ThrowJsonException_DeserializeUnableToConvertValue(Type propertyType) in /_/src/libraries/System.Text.Json/src/System/Text/Json/ThrowHelper.Serialization.cs:line 55\r\n   at System.Text.Json.Serialization.Converters.ObjectDefaultConverter`1.OnTryRead(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options, ReadStack& state, T& value) in /_/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/Converters/Object/ObjectDefaultConverter.cs:line 25\r\n   at System.Text.Json.Serialization.JsonConverter`1.TryRead(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options, ReadStack& state, T& value) in /_/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/JsonConverterOfT.cs:line 249\r\n   at System.Text.Json.Serialization.JsonConverter`1.ReadCore(Utf8JsonReader& reader, JsonSerializerOptions options, ReadStack& state) in /_/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/JsonConverterOfT.ReadCore.cs:line 61\r\n   at System.Text.Json.JsonSerializer.ReadCore[TValue](JsonConverter jsonConverter, Utf8JsonReader& reader, JsonSerializerOptions options, ReadStack& state) in /_/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/JsonSerializer.Read.Helpers.cs:line 23\r\n   at System.Text.Json.JsonSerializer.Read[TValue](Utf8JsonReader& reader, JsonTypeInfo jsonTypeInfo) in /_/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/JsonSerializer.Read.Utf8JsonReader.cs:line 421\r\n   at System.Text.Json.JsonSerializer.Deserialize[TValue](Utf8JsonReader& reader, JsonSerializerOptions options) in /_/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/JsonSerializer.Read.Utf8JsonReader.cs:line 60\r\n   at Test.Program.Main() in Program.cs:line 25\r\n\r\n  This exception was originally thrown at this call stack:\r\n    System.Text.Json.ThrowHelper.ThrowJsonException_DeserializeUnableToConvertValue(System.Type) in ThrowHelper.Serialization.cs\r\n    System.Text.Json.Serialization.Converters.ObjectDefaultConverter<T>.OnTryRead(ref System.Text.Json.Utf8JsonReader, System.Type, System.Text.Json.JsonSerializerOptions, ref System.Text.Json.ReadStack, out T) in ObjectDefaultConverter.cs\r\n    System.Text.Json.Serialization.JsonConverter<T>.TryRead(ref System.Text.Json.Utf8JsonReader, System.Type, System.Text.Json.JsonSerializerOptions, ref System.Text.Json.ReadStack, out T) in JsonConverterOfT.cs\r\n    System.Text.Json.Serialization.JsonConverter<T>.ReadCore(ref System.Text.Json.Utf8JsonReader, System.Text.Json.JsonSerializerOptions, ref System.Text.Json.ReadStack) in JsonConverterOfT.ReadCore.cs\r\n    System.Text.Json.JsonSerializer.ReadCore<TValue>(System.Text.Json.Serialization.JsonConverter, ref System.Text.Json.Utf8JsonReader, System.Text.Json.JsonSerializerOptions, ref System.Text.Json.ReadStack) in JsonSerializer.Read.Helpers.cs\r\n    System.Text.Json.JsonSerializer.Read<TValue>(ref System.Text.Json.Utf8JsonReader, System.Text.Json.Serialization.Metadata.JsonTypeInfo) in JsonSerializer.Read.Utf8JsonReader.cs\r\n    System.Text.Json.JsonSerializer.Deserialize<TValue>(ref System.Text.Json.Utf8JsonReader, System.Text.Json.JsonSerializerOptions) in JsonSerializer.Read.Utf8JsonReader.cs\r\n    Test.Program.Main() in Program.cs\r\n````\r\n\r\n### Regression?\r\n\r\nI doubt it.\r\n\r\n### Known Workarounds\r\n\r\nInserting an extra '{' or '[' byte into the reader's input stream (so there are effectively two such bytes) when resuming, and then using reflection to set Utf8JsonReader._consumed = 1, will allow deserialization to succeed. I don't consider this an actual workaround that I could use in real code, because it depends on reflection and internal implementation details, but it will avoid the exception. (Also, a Utf8JsonReader can't be boxed, so normal reflection methods don't work.)\r\n\r\n````C#\r\npublic class Foo { public int a { get; set; } }\r\nvar bytes = System.Text.Encoding.ASCII.GetBytes(\"{\\\"a\\\":7}\").AsSpan();\r\nvar jr = new Utf8JsonReader(bytes[..1], false, new JsonReaderState());\r\nvar read = jr.Read(); // move to StartObject. consume '{'\r\n// put an extra '{' or '[' byte into the stream by subtracting one from BytesConsumed\r\njr = new Utf8JsonReader(bytes[((int)jr.BytesConsumed-1)..], true, jr.CurrentState);\r\njr._consumed = 1; // set this via reflection (e.g. using a dynamic method) or the debugger\r\nvar foo = JsonSerializer.Deserialize<Foo>(ref jr); // this succeeds with the above hack\r\n````\r\n\r\n### Configuration\r\n\r\n.NET 6.0 on Windows 10 Enterprise x64\r\n\r\n### Other information\r\n\r\n_No response_",
    "number": 67454,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-07-10T06:06:09Z",
          "user": "jing8956"
        }
      ],
      "totalCount": 1,
      "endCursor": "Y3Vyc29yOnYyOpHODGccSg=="
    },
    "updatedAt": "2022-04-08T11:11:35Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\n### Description\n\nSystem.Text.Json.Utf8JsonReader is supposed to be resumable, so that you can read data in chunks, resuming the reader after each chunk. However, the JsonSerializer.Deserialize(ref Utf8JsonReader, ...) methods do not work reliably with a reader that has been resumed (at least in the most likely cases of objects and arrays - I haven't tested strings, numbers, etc).\r\n\r\nI believe this is because internally, JsonSerializer.Read\\<T\\>(ref Utf8JsonReader, JsonTypeInfo) tries to copy the entire object or array into a separate buffer, _including the initial '{' or '[' character which has already been consumed by the reader_, and then create a new reader to deserialize from that buffer. In the case of a reader that has been resumed at the StartObject or StartArray token, the '{' or '[' character will not exist - because it has already been consumed from the input stream. Really, I don't think JsonSerializer should be trying to look backwards, at data that has already been consumed from the input source. The reader is supposed to be forward-only.\n\n### Reproduction Steps\n\nHere is one way to cause the exception:\r\n````C#\r\npublic class Foo { public int b { get; set; } }\r\nvar bytes = System.Text.Encoding.ASCII.GetBytes(\"{\\\"a\\\":7}\").AsSpan();\r\nvar jr = new Utf8JsonReader(bytes[..1], false, new JsonReaderState());\r\nvar read = jr.Read(); // move to StartObject. consume '{'\r\njr = new Utf8JsonReader(bytes[(int)jr.BytesConsumed..], true, jr.CurrentState); // BytesConsumed is 1\r\nvar foo = JsonSerializer.Deserialize<Foo>(ref jr); // this fails\r\n````\r\n\r\nThere are many other, similar patterns that all fail.\n\n### Expected behavior\n\nJsonSerializer should respect the forward-only nature of the reader and not try to look backwards at already-consumed data, so that it can work with readers that have been resumed. The resumability of Utf8JsonReader is a core part of its design.\r\n\r\nMore specifically, the Deserialize methods that take a Utf8JsonReader should work if the reader is resumed at the start of the value to deserialize.\r\n\r\nIt would also be nice if it didn't try to copy the entire object or array - which can be quite large - into a separate buffer and then deserialize it using a separate reader. Can't it use the reader I give it?\n\n### Actual behavior\n\nIt fails with an exception like the following:\r\n\r\n````\r\nSystem.Text.Json.JsonException\r\n  HResult=0x80131500\r\n  Message=The JSON value could not be converted to Test.Program+Foo. Path: $ | LineNumber: 0 | BytePositionInLine: 3.\r\n  Source=System.Text.Json\r\n  StackTrace:\r\n   at System.Text.Json.ThrowHelper.ThrowJsonException_DeserializeUnableToConvertValue(Type propertyType) in /_/src/libraries/System.Text.Json/src/System/Text/Json/ThrowHelper.Serialization.cs:line 55\r\n   at System.Text.Json.Serialization.Converters.ObjectDefaultConverter`1.OnTryRead(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options, ReadStack& state, T& value) in /_/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/Converters/Object/ObjectDefaultConverter.cs:line 25\r\n   at System.Text.Json.Serialization.JsonConverter`1.TryRead(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options, ReadStack& state, T& value) in /_/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/JsonConverterOfT.cs:line 249\r\n   at System.Text.Json.Serialization.JsonConverter`1.ReadCore(Utf8JsonReader& reader, JsonSerializerOptions options, ReadStack& state) in /_/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/JsonConverterOfT.ReadCore.cs:line 61\r\n   at System.Text.Json.JsonSerializer.ReadCore[TValue](JsonConverter jsonConverter, Utf8JsonReader& reader, JsonSerializerOptions options, ReadStack& state) in /_/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/JsonSerializer.Read.Helpers.cs:line 23\r\n   at System.Text.Json.JsonSerializer.Read[TValue](Utf8JsonReader& reader, JsonTypeInfo jsonTypeInfo) in /_/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/JsonSerializer.Read.Utf8JsonReader.cs:line 421\r\n   at System.Text.Json.JsonSerializer.Deserialize[TValue](Utf8JsonReader& reader, JsonSerializerOptions options) in /_/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/JsonSerializer.Read.Utf8JsonReader.cs:line 60\r\n   at Test.Program.Main() in Program.cs:line 25\r\n\r\n  This exception was originally thrown at this call stack:\r\n    System.Text.Json.ThrowHelper.ThrowJsonException_DeserializeUnableToConvertValue(System.Type) in ThrowHelper.Serialization.cs\r\n    System.Text.Json.Serialization.Converters.ObjectDefaultConverter<T>.OnTryRead(ref System.Text.Json.Utf8JsonReader, System.Type, System.Text.Json.JsonSerializerOptions, ref System.Text.Json.ReadStack, out T) in ObjectDefaultConverter.cs\r\n    System.Text.Json.Serialization.JsonConverter<T>.TryRead(ref System.Text.Json.Utf8JsonReader, System.Type, System.Text.Json.JsonSerializerOptions, ref System.Text.Json.ReadStack, out T) in JsonConverterOfT.cs\r\n    System.Text.Json.Serialization.JsonConverter<T>.ReadCore(ref System.Text.Json.Utf8JsonReader, System.Text.Json.JsonSerializerOptions, ref System.Text.Json.ReadStack) in JsonConverterOfT.ReadCore.cs\r\n    System.Text.Json.JsonSerializer.ReadCore<TValue>(System.Text.Json.Serialization.JsonConverter, ref System.Text.Json.Utf8JsonReader, System.Text.Json.JsonSerializerOptions, ref System.Text.Json.ReadStack) in JsonSerializer.Read.Helpers.cs\r\n    System.Text.Json.JsonSerializer.Read<TValue>(ref System.Text.Json.Utf8JsonReader, System.Text.Json.Serialization.Metadata.JsonTypeInfo) in JsonSerializer.Read.Utf8JsonReader.cs\r\n    System.Text.Json.JsonSerializer.Deserialize<TValue>(ref System.Text.Json.Utf8JsonReader, System.Text.Json.JsonSerializerOptions) in JsonSerializer.Read.Utf8JsonReader.cs\r\n    Test.Program.Main() in Program.cs\r\n````\n\n### Regression?\n\n_No response_\n\n### Known Workarounds\n\nInserting an extra '{' or '[' byte into the reader's input stream (so there are effectively two such bytes) when resuming then using reflection to set Utf8JsonReader._consumed = 1 will allow deserialization to succeed.\r\n\r\n````C#\r\npublic class Foo { public int b { get; set; } }\r\nvar bytes = System.Text.Encoding.ASCII.GetBytes(\"{\\\"a\\\":7}\").AsSpan();\r\nvar jr = new Utf8JsonReader(bytes[..1], false, new JsonReaderState());\r\nvar read = jr.Read(); // move to StartObject. consume '{'\r\n// put an extra '{' or '[' byte into the stream by subtracting one from BytesConsumed\r\njr = new Utf8JsonReader(bytes[((int)jr.BytesConsumed-1)..], true, jr.CurrentState);\r\njr._consumed = 1; // set this via reflection or the debugger\r\nvar foo = JsonSerializer.Deserialize<Foo>(ref jr); // this succeeds with the above hack\r\n````\n\n### Configuration\n\n.NET 6.0 on Windows 10 Enterprise x64\n\n### Other information\n\n_No response_\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>AdamMil</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`area-System.Text.Json`, `untriaged`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2022-04-01T19:54:08Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-04-01T19:54:08Z",
          "id": "IC_kwDODI9FZc5AvyuN"
        },
        {
          "author": "eiriktsarpalis",
          "body": "This is by design -- `Utf8JsonReader` might make it possible to make JSON reading resumable, but it doesn't contain the necessary state to resume _deserialization_. Deserialization state (the `ReadState` struct) is currently not exposed, but we are considering allowing user defined async/resumable converters in the future (see #63795).",
          "createdAt": "2022-04-02T09:30:15Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-04-02T09:30:15Z",
          "id": "IC_kwDODI9FZc5AxDX2"
        },
        {
          "author": "AdamMil",
          "body": "> Utf8JsonReader might make it possible to make JSON reading resumable, but it doesn't contain the necessary state to resume deserialization... we are considering allowing user defined async/resumable converters in the future\r\n\r\nI'm not referring to resuming deserialization or to resumable converters. Deserialization hasn't even begun yet. I'm referring to having a Utf8JsonReader positioned on a StartObject token with all of the data for the object available, and then passing it to Deserialize. It shouldn't make a difference whether the reader was resumed there or navigated there via Read.\r\n\r\nThis is not related to #63795.",
          "createdAt": "2022-04-05T16:22:48Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-04-05T16:25:27Z",
          "id": "IC_kwDODI9FZc5A6F15"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Your initial analysis on the root cause appears to be correct. It is not entirely clear to me what the [historical reasons for copying the contents of the buffer](https://github.com/dotnet/runtime/blob/16b2cf5baa8c14650261f957d7ea31d4ae723561/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/JsonSerializer.Read.Utf8JsonReader.cs#L384-L397) might be here. It doesn't seem necessary for either checkpointing or reading ahead (which already happens separately in the converter layer). @bartonjs or @ahsonkhan might have more context. \r\n\r\nLooking at our test coverage for the `Utf8JsonReader` Deserialize methods, I don't believe they were meant to support re-entrant reader instances. They are also not accounting for that case, producing misleading error messages when passing the fixed-up reader to the underlying converters. As part of https://github.com/dotnet/runtime/issues/63795 we'd be looking at exposing `JsonSerializer` methods that support re-entrancy at the serialization layer.\r\n\r\nOut of curiosity, what use case triggered this issue for you? Have you tried using any of the streaming deserialization APIs, in particular the `DeserializeAsyncEnumerable` method? ",
          "createdAt": "2022-04-05T19:23:01Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-04-05T19:23:01Z",
          "id": "IC_kwDODI9FZc5A7ECL"
        },
        {
          "author": "AdamMil",
          "body": "Thank you for taking another look.\r\n\r\nI'm not sure what you mean by \"re-entrant\" readers. Does that just mean one that's been resumed?\r\n\r\nI think this case only affects readers that are resumed exactly at the StartObject or StartArray token, in which case the deserializer tries to look backwards one byte into the reader's internal buffer to capture the initial '{' or '[' delimiter. This byte has already been consumed, so it fails after resuming because it's no longer in the internal buffer. One way to fix it without significant changes to the code would be to simply insert the corresponding '{' or '[' byte into the copy buffer and then copy the rest of the data from the reader, rather than trying to look backwards one byte.\r\n\r\n(Of course, my preference would be to avoid the TrySkip call and the copy into a separate buffer, and just deserialize the value using the reader I provide, but perhaps there's some reason you guys don't do that.)\r\n\r\nI hit this issue when implementing a class to allow reading from a stream with the Utf8JsonReader interface. The Deserialize methods that take a stream seem to want to deserialize the entire stream into some object or value, but what I want is to be able to pick out individual objects from a stream and deserialize them one by one. For a simple example, let's say you have a stream like this:\r\n````\r\n{ \"items\": [{\"a\":1}, {\"a\":2}], \"nextLink\": \"...\" }\r\n````\r\nIf the stream is positioned at the {\"a\":1} object, the JsonSerializer.Deserialize method will throw an exception upon seeing the ',' character after it. Similarly, if it's positioned at the '[' character, JsonSerializer.DeserializeAsyncEnumerable enumerator will throw an exception upon seeing the ',' character after the array. (And I can't simply swallow the exception, since it may throw before enumerating all the items. I guess it throws as soon as some kind of lookahead code sees the comma...)\r\n\r\nImagine that the {\"a\":1} object is much bigger and you have hundreds of thousands of them coming over a network stream. I'd prefer not to deserialize the whole stream into a giant object. I'd prefer to use a reader loop like:\r\n\r\n````C#\r\nwhile(reader.Read() && reader.TokenType != JsonTokenType.EndArray)\r\n{\r\n    processItem(JsonSerializer.Deserialize<MyItem>(ref reader, ...));\r\n}\r\n````\r\n\r\nIn my case it looks like:\r\n\r\n````C#\r\nwhile(streamReader.Read(ref reader) && reader.TokenType != JsonTokenType.EndArray)\r\n{\r\n    streamReader.EnsureComplete(ref reader);\r\n    processItem(JsonSerializer.Deserialize<MyItem>(ref reader, ...));\r\n}\r\n````\r\n\r\nThe EnsureComplete method makes sure all the data for the item the reader is currently positioned at is available to be read by the reader. This may require saving the reader state, reading more data, and resuming the reader based on the saved state. Since in my case the reader is practically always positioned on something like a StartObject token when I call EnsureComplete, it frequently gets resumed at the StartObject token and fails to deserialize.\r\n\r\nThe JsonSerializer.DeserializeAsyncEnumerable method is good for what it says: reading from root-level arrays, but in my case I want to read from an array nested inside a page object and still be able to read the \"nextLink\" property afterwards.\r\n\r\n(I think it would be nice if the JsonSerializer methods just deserialized whatever thing the stream is pointing at, but I realize that's infeasible to implement in a way that has good performance in general. To avoid over-reading a non-seekable stream, you'd have to read one byte at a time, and that's no good.)",
          "createdAt": "2022-04-05T21:53:37Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-04-05T22:59:01Z",
          "id": "IC_kwDODI9FZc5A7wrj"
        },
        {
          "author": "eiriktsarpalis",
          "body": "> I'm not sure what you mean by \"re-entrant\" readers. Does that just mean one that's been resumed?\r\n\r\nIn this context it means passing on the `JsonReaderState` token across multiple buffer chunks.\r\n\r\n> (Of course, my preference would be to avoid the TrySkip call and the copy into a separate buffer, and just deserialize the value using the reader I provide, but perhaps there's some reason you guys don't do that.)\r\n\r\nAgreed. I'm guessing this logic was added for a reason, but that reason is unknown to me and may well be obsolete. It might be worth launching an investigation but at this point we are severely backlogged and can't prioritize it. Would you be interested in taking a look?\r\n\r\n> The EnsureComplete method makes sure all the data for the item the reader is currently positioned at is available to be read by the reader. This may require saving the reader state, reading more data, and resuming the reader based on the saved state.\r\n\r\nUltimately this could be addressed by https://github.com/dotnet/runtime/issues/63795. It hasn't been prototyped yet, but we'd be looking at exposing `TrySerialize` and `TryDeserialize` methods roughly following this pattern:\r\n```C#\r\nwhile(streamReader.Read(ref reader) && reader.TokenType != JsonTokenType.EndArray)\r\n{\r\n     var state = new ReadState();\r\n     while (!JsonSerializer.TryDeserialize<MyItem>(ref reader, out MyItem? result, ref state, ...))\r\n     {\r\n          streamReader.Read(ref reader);\r\n     }\r\n\r\n     processItem(result);\r\n}\r\n```\r\nUltimately this is how the streaming serialization methods are implemented under wraps, exposing such methods could allow more bespoke streaming applications.",
          "createdAt": "2022-04-06T13:37:55Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-04-06T13:37:55Z",
          "id": "IC_kwDODI9FZc5A_Gm-"
        },
        {
          "author": "AdamMil",
          "body": "> Would you be interested in taking a look?\r\n\r\nPerhaps, although I'd first have to figure out how to get started debugging the standard library. Any pointers?\r\n\r\n> Ultimately this could be addressed by #63795. It hasn't been prototyped yet, but we'd be looking at exposing `TrySerialize` and `TryDeserialize` methods... Ultimately this is how the streaming serialization methods are implemented under wraps,\r\n\r\nOne thing I hope could be avoided is the way System.Text.Json code (both built-in and perhaps in your example above) may repeatedly scan the same region of the JSON data. For example, imagine a large JSON object that's a megabyte in size. Whether using a loop like the above, or using the existing streaming deserialization methods, what tends to happen is that JsonSerializer will call TrySkip to make sure it has enough data, and when that returns false it'll fail and effectively roll back the reader. Then it, or the caller, will read more data into the buffer, and TrySkip will be called again, which'll rescan the old data again, plus the new data. This will happen repeatedly until it finally buffers the full megabyte, and as a result it'll effectively scan multiple megabytes to read that 1MB object. (Maybe your hypothetical ReadState variable could help with that by preserving extra state, depending on what's in it, but from looking at the current System.Text.Json code I think TrySkip is still called.)\r\n\r\nAnother somewhat more vexing (but slightly further off-topic) example is people storing large binary data in JSON (as base64). The Utf8JsonReader doesn't seem to have any way to read a large string in chunks. With a large object, you can generally make some progress with each read, but with a large string, you can't make any progress until you've buffered the entire string, and as before the Utf8JsonReader.Read method will repeatedly rescan the entire buffer until it finally sees the whole string. And those large strings are generally stored in some object property, which is a frequent cause of the \"large object\" problem mentioned above.\r\n\r\nPersonally I wish you guys would not call TrySkip, and just optimistically try to deserialize from the reader, and roll back the reader (as you already do) if it fails. This actually increases the cost of repeated attempts, though. Either way, given the design of Utf8JsonReader (which can't pull in more data by itself), I think the onus is on the caller (or the stream reader in this case) to have the intelligence to read the entire value in one go, and not just blindly read a chunk of bytes into the buffer and say \"let's see if it works this time\". This is not _too_ difficult, but it nearly requires implementing your own JSON reader just to figure out how much data to give to the built-in Utf8JsonReader. It also gets more difficult with large strings (and large numbers in theory), since unlike a large object where you can at least detect the object from the StartObject token (and thus know that you should read to the end of it), the Utf8JsonReader won't give you a String token until it has the whole string in memory. It seems like something the standard library could help with, since few people are likely to do the work and get it right, but many could benefit from efficient streaming methods built in. Rather than providing TryDeserialize methods, you could provide methods to help people ensure it'll work the first time. (Then again, your hypothetical ReadState type may avoid the duplicated work.)\r\n\r\nI recall somebody saying you guys were thinking about eventually adding a stream reader... Another possibility is allowing the Utf8JsonReader to take a delegate that it can call to read more data. Either way, I'd hope more of the scanning work to enable effective streaming could be offloaded into the standard library. (I'm not just asking for myself, since I've already implemented all my asks locally, except fixes for bugs like this, which are outside my control.)",
          "createdAt": "2022-04-06T17:00:57Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-04-06T17:43:37Z",
          "id": "IC_kwDODI9FZc5A_6ea"
        },
        {
          "author": "eiriktsarpalis",
          "body": "> > Would you be interested in taking a look?\r\n> \r\n> Perhaps, although I'd first have to figure out how to get started debugging the standard library. Any pointers?\r\n\r\nSure, [this guide](https://github.com/dotnet/runtime/tree/main/docs/workflow) should help you getting started.",
          "createdAt": "2022-04-08T11:11:25Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-04-08T11:11:35Z",
          "id": "IC_kwDODI9FZc5BIgqx"
        }
      ],
      "totalCount": 8,
      "endCursor": "Y3Vyc29yOnYyOpHOQSIKsQ=="
    },
    "url": "https://github.com/dotnet/runtime/issues/67454",
    "title": "JsonSerializer.Deserialize can't be reliably used with Utf8JsonReaders that have been resumed"
  },
  {
    "author": "saber-wang",
    "labels": [
      "area-System.Text.Json"
    ],
    "createdAt": "2022-04-13T02:17:36Z",
    "body": "### Description\r\n\r\nOccasionally throw memory overflow when using JsonNode.ToJsonString\r\n\r\n\r\n\r\n### Reproduction Steps\r\n\r\n\r\nThe size of a single JsonObject is within 30000000 bytes\r\n\r\nvar transObj = new JsonObject();\r\ntransObj .ToJsonString(new JsonSerializerOptions(JsonSerializerDefaults.Web)\r\n                {\r\n                    Encoder = System.Text.Encodings.Web.JavaScriptEncoder.UnsafeRelaxedJsonEscaping\r\n                }))\r\n\r\n### Expected behavior\r\n\r\nReturn string\r\n\r\n\r\n\r\n### Actual behavior\r\n\r\n Throw  OutOfMemoryException\r\n\r\nsimple repros: https://github.com/saber-wang/JsonObjetcTest\r\n\r\n### Regression?\r\n\r\n_No response_\r\n\r\n### Known Workarounds\r\n\r\n_No response_\r\n\r\n### Configuration\r\n\r\nRun in container\r\nbase image: mcr.microsoft.com/dotnet/runtime:6.0-alpine\r\n\r\nmemory configuration\r\n```\r\n        resources:\r\n          limits:\r\n            memory: 2Gi\r\n          requests:\r\n            memory: 256Mi\r\n        securityContext:\r\n          capabilities:\r\n            add:\r\n            - NET_ADMIN\r\n          privileged: true\r\n```\r\n### Other information\r\n\r\n_No response_",
    "number": 67943,
    "reactions": {
      "hasNextPage": false,
      "nodes": [],
      "totalCount": 0,
      "endCursor": null
    },
    "updatedAt": "2022-04-25T15:53:30Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\n### Description\n\nOccasionally throw memory overflow when using JsonNode.ToJsonString\r\n\r\n\n\n### Reproduction Steps\n\n\r\nThe size of a single JsonObject is within 30000000 bytes\r\n\r\nvar transObj = new JsonObject();\r\ntransObj .ToJsonString(new JsonSerializerOptions(JsonSerializerDefaults.Web)\r\n                {\r\n                    Encoder = System.Text.Encodings.Web.JavaScriptEncoder.UnsafeRelaxedJsonEscaping\r\n                }))\n\n### Expected behavior\n\nReturn string\r\n\r\n\n\n### Actual behavior\n\n Throw  OutOfMemoryException\r\n\r\ndumps: https://github.com/saber-wang/dumps\n\n### Regression?\n\n_No response_\n\n### Known Workarounds\n\n_No response_\n\n### Configuration\n\nRun in container\r\nbase image: mcr.microsoft.com/dotnet/runtime:6.0-alpine\n\n### Other information\n\n_No response_\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>saber-wang</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`area-System.Text.Json`, `untriaged`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2022-04-13T02:17:40Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-04-13T02:17:40Z",
          "id": "IC_kwDODI9FZc5Baj4s"
        },
        {
          "author": "saber-wang",
          "body": "@mangod9 ",
          "createdAt": "2022-04-13T02:18:05Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-04-13T02:18:05Z",
          "id": "IC_kwDODI9FZc5Baj7n"
        },
        {
          "author": "mangod9",
          "body": "hi @saber-wang, could you also please provide what memory configuration you are using for the container? If you possibly have a sample json input that might help too. thanks",
          "createdAt": "2022-04-13T02:30:36Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-04-13T02:30:36Z",
          "id": "IC_kwDODI9FZc5Balbh"
        },
        {
          "author": "danmoseley",
          "body": "Please if you can share minimal, runnable code that repros this.",
          "createdAt": "2022-04-13T04:04:44Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-04-13T04:04:44Z",
          "id": "IC_kwDODI9FZc5Bav3O"
        },
        {
          "author": "saber-wang",
          "body": "@mangod9 \r\n```\r\n         limits:\r\n            memory: 2Gi\r\n```\r\nSample JSON I try to print it out the next time the memory overflows",
          "createdAt": "2022-04-13T05:17:35Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-04-13T05:17:35Z",
          "id": "IC_kwDODI9FZc5Ba5F5"
        },
        {
          "author": "mangod9",
          "body": "Hi @saber-wang, did you mean to close this issue? If so was it resolved on your end?",
          "createdAt": "2022-04-14T17:36:45Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-04-14T17:36:45Z",
          "id": "IC_kwDODI9FZc5BiF_R"
        },
        {
          "author": "saber-wang",
          "body": "@mangod9   I got the JSON and tested it and found that the memory overflow is in line with expectations. However, the memory used by jsonnode is more than twice that of the original JSON. In the future, I may not use jsonnode but directly process strings\r\n\r\nI can provide a simple repros if necessary\r\n\r\n",
          "createdAt": "2022-04-15T00:59:52Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-04-15T00:59:52Z",
          "id": "IC_kwDODI9FZc5BjO1v"
        },
        {
          "author": "saber-wang",
          "body": "@mangod9  A simple example  https://github.com/saber-wang/JsonObjetcTest",
          "createdAt": "2022-04-15T01:11:21Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-04-15T01:11:21Z",
          "id": "IC_kwDODI9FZc5BjRVu"
        }
      ],
      "totalCount": 8,
      "endCursor": "Y3Vyc29yOnYyOpHOQY0Vbg=="
    },
    "url": "https://github.com/dotnet/runtime/issues/67943",
    "title": "JsonNode.ToJsonString(JsonSerializerOptions options) Throw  OutOfMemoryException"
  },
  {
    "author": "gregsdennis",
    "labels": [
      "api-suggestion",
      "area-System.Text.Json"
    ],
    "createdAt": "2022-04-17T13:14:50Z",
    "body": "### Background and motivation\n\nAs a follow-up to #66948, the following was stated as a \"probably won't fix\" conclusion:\r\n\r\n> however I suspect that at this point changing `JsonValue` to have a baked in representation for JSON `null` would be a breaking change for many.\r\n\r\nI have a solution for this:  introduce `JsonNull : JsonNode` and a new option on [`JsonNodeOptions`](https://docs.microsoft.com/en-us/dotnet/api/system.text.json.nodes.jsonnodeoptions?view=net-6.0) that allows modelling of JSON nulls as this new type.\n\n### API Proposal\n\n```C#\r\nnamespace System.Text.Json.Nodes\r\n{\r\n    // new type\r\n    public class JsonNull : JsonNode\r\n    {\r\n    }\r\n\r\n    // extend\r\n    public class JsonNodeOptions\r\n    {\r\n        public JsonNullHandling NullHandling { get; set; }\r\n    }\r\n\r\n    // new type\r\n    public enum JsonNullHandling\r\n    {\r\n        UseDotnetNull,  // default, current behavior\r\n        UseJsonNull  // uses JsonNull\r\n    }\r\n}\r\n```\r\n\n\n### API Usage\n\n```c#\r\nvar obj = JsonNode.Parse(@\"{\r\n    \"\"value\"\": null\r\n}\") as JsonObject;\r\n\r\nvar value = obj[\"value\"];  // value is JsonNull\r\n\r\nvalue.GetPath();  // should return \"$.value\"\r\n```\r\n\r\nCurrently, the last statement throws a `NullReferenceException`, even though it's obvious from the code that there should be a value.\r\n\r\nNot sure about how to handle building values inline.\r\n\r\n```c#\r\nvar obj = new JsonObject\r\n    {\r\n        [\"dotnet-null\"] = null,\r\n        [\"json-null\"] = new JsonNull()\r\n    };\r\n```\n\nThey could either be coerced to follow the option setting or left as is to defer to the developer.\n\n### Alternative Designs\n\n_No response_\n\n### Risks\n\nThe risk was expressed in the linked issue: changes to the established API would likely break existing usages.  Making this a non-default processing option circumvents the issue completely.",
    "number": 68128,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-04-17T21:42:46Z",
          "user": "Frassle"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-11-01T14:35:08Z",
          "user": "Athari"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-02-10T09:06:46Z",
          "user": "amis92"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-04-22T15:56:40Z",
          "user": "mlaily"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-06-10T15:49:37Z",
          "user": "arviedelgado"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-07-23T14:31:14Z",
          "user": "mdekrey"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-09-25T13:30:32Z",
          "user": "olivier-spinelli"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-11-06T15:08:19Z",
          "user": "ProTip"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-03-07T15:39:44Z",
          "user": "reecebradley"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-07-01T09:01:38Z",
          "user": "gbtb"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-07-13T07:56:03Z",
          "user": "sachssoft"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-04-20T18:41:42Z",
          "user": "Smaug123"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-05-12T08:58:43Z",
          "user": "aayjaychan"
        },
        {
          "content": "HEART",
          "createdAt": "2025-06-05T00:08:12Z",
          "user": "lue-bird"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-07-29T10:10:54Z",
          "user": "ahmednfwela"
        },
        {
          "content": "HEART",
          "createdAt": "2025-08-02T21:20:43Z",
          "user": "ahmednfwela"
        }
      ],
      "totalCount": 16,
      "endCursor": "Y3Vyc29yOnYyOpHODJoF2A=="
    },
    "updatedAt": "2025-05-11T04:39:59Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\n### Background and motivation\n\nAs a follow-up to #66948, the following was stated as a \"probably won't fix\" conclusion:\r\n\r\n> however I suspect that at this point changing `JsonValue` to have a baked in representation for JSON `null` would be a breaking change for many.\r\n\r\nI have a solution for this:  introduce `JsonNull : JsonNode` and a new option on [`JsonNodeOptions`](https://docs.microsoft.com/en-us/dotnet/api/system.text.json.nodes.jsonnodeoptions?view=net-6.0) that allows modelling of JSON nulls as this new type.\n\n### API Proposal\n\n```C#\r\nnamespace System.Text.Json.Nodes\r\n{\r\n    // new type\r\n    public struct JsonNull : JsonNode\r\n    {\r\n    }\r\n\r\n    // extend\r\n    public class JsonNodeOptions\r\n    {\r\n        public JsonNullHandling NullHandling { get; set; }\r\n    }\r\n\r\n    // new type\r\n    public enum JsonNullHandling\r\n    {\r\n        UseDotnetNull,  // default, current behavior\r\n        UseJsonNull  // uses JsonNull\r\n    }\r\n}\r\n```\r\n\n\n### API Usage\n\n```c#\r\nvar obj = JsonNode.Parse(@\"{\r\n    \"\"value\"\": null\r\n}\") as JsonObject;\r\n\r\nvar value = obj[\"value\"];  // value is JsonNull\r\n\r\nvalue.GetPath();  // should return \"$.value\"\r\n```\r\n\r\nCurrently, the last statement throws a `NullReferenceException`, even though it's obvious from the code that there should be a value.\r\n\r\nNot sure about how to handle building values inline.\r\n\r\n```c#\r\nvar obj = new JsonObject\r\n    {\r\n        [\"dotnet-null\"] = null,\r\n        [\"json-null\"] = new JsonNull()\r\n    };\r\n```\n\n### Alternative Designs\n\n_No response_\n\n### Risks\n\nThe risk was expressed in the linked issue: changes to the established API would likely break existing usages.  Making this a non-default processing option circumvents the issue completely.\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>gregsdennis</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`api-suggestion`, `area-System.Text.Json`, `untriaged`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2022-04-17T13:14:54Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-04-17T13:14:54Z",
          "id": "IC_kwDODI9FZc5Bnf6d"
        },
        {
          "author": "eiriktsarpalis",
          "body": "~I don't think we'll be able to do this, as it would breaking code that relies on the current behaviour, i.e. `null` JSON values being represented as `null` JsonNodes.~\r\n\r\nOther than being able to retrieve the JsonPath for the null value, what are some of the benefits of introducing this alternative `null` representation? I don't think we should be bifurcating null representation semantics unless there's a really compelling reason.",
          "createdAt": "2022-04-18T10:58:56Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-04-18T11:01:15Z",
          "id": "IC_kwDODI9FZc5BpLCQ"
        },
        {
          "author": "FiniteReality",
          "body": "> Other than being able to retrieve the JsonPath for the null value, what are some of the benefits of introducing this alternative `null` representation? I don't think we should be bifurcating null representation semantics unless there's a really compelling reason.\r\n\r\nIt allows a meaningful distinction between a JSON field which is `null` and a JSON field which is not present. This is often used in web APIs where a client is modifying a resource and wants to differentiate between \"I don't want to modify this field\" and \"I want to erase this field\". [JSON Merge Patch](https://datatracker.ietf.org/doc/html/rfc7386) is an example of a fairly common implementation of something like this. For example given the JSON document:\r\n```json\r\n{\r\n    \"a\": \"b\",\r\n    \"c\": {\r\n        \"d\": \"e\",\r\n        \"f\": \"g\"\r\n    }\r\n}\r\n```\r\nthe following JSON payload can be sent to modify `a` and remove `f`, without touching `d`:\r\n```json\r\n{\r\n    \"a\":\"z\",\r\n    \"c\": {\r\n        \"f\": null\r\n    }\r\n}\r\n```",
          "createdAt": "2022-04-18T12:40:21Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-04-18T12:40:21Z",
          "id": "IC_kwDODI9FZc5Bpal9"
        },
        {
          "author": "gregsdennis",
          "body": "Retrieving the path is just an example that I found where the current paradigm fails and instead causes an unexpected exception.  I doubt this scenario is very edge-case.\r\n\r\n## History\r\n\r\nFor my old parser, Manatee.Json, I already had `JsonValue.Null`, a static field to represent JSON null.  Later, I had explored making it equivalent to .Net null by overriding the equality members and coercing .Net null to `JsonValue.Null` on assignment.  However, I quickly discovered that this caused a lot of problems, so I understand the desire to not split the implementation.\r\n\r\nFor that case, the only way to check for .Net null was through the `ReferenceEquals` method as other checks were overridden.\r\n\r\n```c#\r\nvar obj = new JsonObject { [\"foo\"] = null };\r\n\r\nif (obj[\"foo\"] == null) { }  // returns true\r\nif (ReferenceEquals(obj[\"foo\"], null) { }  // returns false\r\n```\r\n\r\nI didn't want this kind of inconsistency as it is quite confusing, so I left them as separate concepts.  However this model (defining JSON null separately) allowed me to implement JSON Path, JSON Pointer, JSON Schema, JSON Patch, and JSON Logic.  (I really wish I had documented this design decision when I built it.)\r\n\r\nI've since stopped development on that library and [reimplemented everything](https://github.com/gregsdennis/json-everything) in a suite that uses `JsonElement`.  Most of this functionality operates on static (unchanging) JSON data, but some, like JSON Patch, require that I mutate the data, so nodes would be much more practical.  @FiniteReality's comment illustrates this nicely.\r\n\r\n## Case\r\n\r\nAn example that shows the breakdown is a hypothetical tree crawler.  Since `JsonValue` supports pointing back to the parent, a naive crawler could move to a node, perform its action, and move back to the parent (using the pointer on the node) to continue.  But if the crawler finds itself on a `null` node, it gets stuck.  The design of the crawler must take on extra baggage (probably via extra checks or an internal parent pointer) to circumvent this scenario: a workaround must be made to account for a design decision of the SDK.  However if there was an actual value for JSON null, the extra effort to design around this limitation wouldn't need to be made.\r\n\r\nThis is just an off-the-cuff example.  I'm sure I'll run into more examples where I have to work around the SDK as I try to update my various libraries to use nodes.\r\n",
          "createdAt": "2022-04-18T12:52:16Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-04-18T12:56:36Z",
          "id": "IC_kwDODI9FZc5BpcvR"
        },
        {
          "author": "gregsdennis",
          "body": "@FiniteReality your example wouldn't _remove_ `f` exactly. It would clear `f`'s value.\n\n(Pedantry 🙂.)",
          "createdAt": "2022-04-18T13:00:52Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-04-18T13:00:52Z",
          "id": "IC_kwDODI9FZc5Bpd7T"
        },
        {
          "author": "FiniteReality",
          "body": "> @FiniteReality your example wouldn't _remove_ `f` exactly. It would clear `f`'s value.\r\n> \r\n> (Pedantry slightly_smiling_face.)\r\n\r\nThe RFC I linked specifies that `f` is removed in this case:\r\n> When applied to the target resource, the value of the \"a\" member is\r\n> replaced with \"z\" and \"f\" is removed, leaving the remaining content\r\n> untouched.",
          "createdAt": "2022-04-18T13:08:24Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-04-18T13:08:31Z",
          "id": "IC_kwDODI9FZc5BpfNV"
        },
        {
          "author": "gregsdennis",
          "body": "I just remembered that I had another use case in that other issue that bears mentioning here: returning nodes from methods.\r\n\r\nGiven the method signature:\r\n\r\n```c#\r\nJsonNode? FindValue(JsonNode root) { ... }\r\n```\r\n\r\nit's impossible to know whether the returned value, either a node or null, was found or not.  Perhaps the location exists and contains a null; perhaps it doesn't exist.  We can't know for sure.\r\n\r\nTherefore, as a developer, I'm _forced_ to use a different pattern for my method: the \"try\" pattern.\r\n\r\n```c#\r\n// return true if the path is found, false otherwise\r\n// if true is returned, result contains the value\r\nbool TryFindValue(JsonNode root, out JsonNode? result) { ... }\r\n```\r\n\r\nAnd then, this doesn't even follow the typical \"try\" pattern (e.g. `double.TryParse(...)`) because if `true` is returned, it's generally expected that `result` will be non-null.  Note that this is exactly the case with [TryGetPropertyValue()](https://docs.microsoft.com/en-us/dotnet/api/system.text.json.nodes.jsonobject.trygetpropertyvalue?view=net-6.0).  .Net is breaking the very pattern that it helped establish!\r\n\r\nImportantly, though, my freedom to choose the API that may best suit my (or my clients') need is removed.  It's not a complete blocker, but it doesn't give me any options, either.\r\n\r\n---\r\n\r\nAnother good example of unexpected behavior in known patterns is parsing:\r\n\r\n```c#\r\nvar json = JsonNode.Parse(userEnteredData);\r\n```\r\n\r\nSuppose `userEnteredData` contained the string \"null\".  It's a weird experience to get null as the result of parsing a non-empty string.\r\n\r\nSure, the method returns a nullable node, so the compiler protects us, but it's still unexpected.\r\n\r\n---\r\n\r\nLastly, in a language where we're now declaring the nullability of reference types, and with JSON null unified with .Net null, I can't see any time where `JsonNode` can be used in a non-null context.  That is, this type will _always_ need to be declared as `JsonNode?` because JSON null isn't recognized as a value and yet it can appear anywhere.\r\n\r\nThis should be considered a design flaw if the intent behind `JsonNode` is to be an object model for JSON.  **JSON holds null as a valid _value_, not as a placeholder for missing data.** The .Net model should recognize that.",
          "createdAt": "2022-04-22T11:58:12Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-04-22T08:32:20Z",
                "user": "mlaily"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-06-10T15:52:39Z",
                "user": "arviedelgado"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-09-25T13:27:00Z",
                "user": "olivier-spinelli"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-04-09T11:03:36Z",
                "user": "Ghost4Man"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-06-30T12:01:39Z",
                "user": "MaxDeg"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-04-21T09:12:27Z",
                "user": "Smaug123"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-06-05T00:08:57Z",
                "user": "lue-bird"
              }
            ],
            "totalCount": 7,
            "endCursor": "Y3Vyc29yOnYyOpHOEVYgNA=="
          },
          "updatedAt": "2022-04-22T12:01:38Z",
          "id": "IC_kwDODI9FZc5B8voA"
        },
        {
          "author": "krwq",
          "body": "I'm ok with supporting this assuming there is no other way but I don't like the proposed enum names, what about (don't know if it makes it sound any better):\r\n\r\n```csharp\r\n    public enum JsonNullHandling\r\n    {\r\n        UseNull,\r\n        UseNullValue,\r\n    }\r\n```\r\n\r\n@gregsdennis @FiniteReality assuming this gets approved by API review we currently don't have cycles to spend time on this - at earliest next release we would consider adding this and assuming time allows someone would implement it. Would you be willing to attend API review to describe scenarios (at least one of us would attend us well) and offer implementation with tests?",
          "createdAt": "2022-04-22T12:13:08Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-04-22T12:13:08Z",
          "id": "IC_kwDODI9FZc5B8yOP"
        },
        {
          "author": "gregsdennis",
          "body": "(Tangentially, JSON Path is moving to recognize JSON null as a valid value as well, see https://github.com/ietf-wg-jsonpath/draft-ietf-jsonpath-base/pull/181.)\r\n\r\nI'm fine with that naming.  My primary concern is enabling support.\r\n\r\nI'd be happy to attend.  Please feel free to email me details on the review meeting as well as to what degree I need to provide implementation/tests to my GH username at `yahoo.com`.",
          "createdAt": "2022-04-22T14:07:04Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-04-22T21:51:19Z",
          "id": "IC_kwDODI9FZc5B9Kdu"
        },
        {
          "author": "krwq",
          "body": "@gregsdennis thanks for offering help! I'll request pre-review from JSON folks first, if they have no feedback I'll mark this as api-ready-for-review and request slot during API review and will let you know",
          "createdAt": "2022-04-22T18:28:42Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-04-18T00:28:17Z",
                "user": "gregsdennis"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOC6C8Vg=="
          },
          "updatedAt": "2022-04-22T18:28:42Z",
          "id": "IC_kwDODI9FZc5B988H"
        },
        {
          "author": "steveharter",
          "body": "FYI the design rationale is mentioned in https://github.com/dotnet/designs/blob/main/accepted/2020/serializer/WriteableDomAndDynamic.md#missing-vs-null\r\n\r\n\r\nThe work-around is also mentioned there:\r\n```cs\r\nusing System.Text.Json.Nodes;\r\n\r\nJsonObject obj = JsonNode.Parse(@\"{\r\n    \"\"value\"\": null\r\n}\") as JsonObject;\r\n\r\nbool found = ((IDictionary<string, JsonNode>)obj).TryGetValue(\"value\", out JsonNode foo); //true\r\nbool found2 = ((IDictionary<string, JsonNode>)obj).TryGetValue(\"value2\", out JsonNode foo2); //false\r\n```",
          "createdAt": "2022-04-22T20:44:32Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-04-22T20:44:32Z",
          "id": "IC_kwDODI9FZc5B-R9g"
        },
        {
          "author": "gregsdennis",
          "body": "@steveharter thanks for that documentation on the rationale.  I wholeheartedly agree that the current API works when you're considering getting values into and out of the data model (when you have access to a parent node).  But working with the nodes directly, passing them around and operating on them, becomes much more difficult when JSON null is a value that you need and expect.\r\n\r\nI appreciate the openness to this change.  Thank you.",
          "createdAt": "2022-04-22T21:37:48Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-04-22T22:22:50Z",
          "id": "IC_kwDODI9FZc5B-e7J"
        },
        {
          "author": "eiriktsarpalis",
          "body": "> ```\r\n>// return true if the path is found, false otherwise\r\n>// if true is returned, result contains the value\r\n>bool TryFindValue(JsonNode root, out JsonNode? result) { ... }\r\n>```\r\n> And then, this doesn't even follow the typical \"try\" pattern (e.g. double.TryParse(...)) because if true is returned, it's generally expected that result will be non-null.\r\n\r\nI wouldn't say that this is generally expected, which is why methods that do guarantee a non-null result on success need to explicitly decorate the `out` parameter with the `[NotNullWhen(true)]` attribute.\r\n\r\nI'm still not convinced that this feature is necessary. As @steveharter pointed out it should be possible to distinguish between `null` and missing properties. If I'm understanding the remaining arguments correctly, the main source of concern is using `JsonNode?` to represent the full DOM feels awkward. It might be worth pointing out that the proposal would not change this fact in the general case, since it would be making JSON null representation a runtime flag specific to individual `JsonNode` instances: a method acting on arbitrary `JsonNode` instances would not be able to statically guarantee that lookup results are non-null.\r\n\r\nThis might have been a different conversation if we were designing `JsonNode` instances from scratch, but as it stands introducing a flag that effectively bifurcates null representation semantics seems inappropriate to me unless there is a compelling use case (i.e. one that is blocking specific usage scenaria).",
          "createdAt": "2022-04-23T19:49:30Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-04-23T19:49:30Z",
          "id": "IC_kwDODI9FZc5CBTs_"
        },
        {
          "author": "gregsdennis",
          "body": "> As @ steveharter pointed out it should be possible to distinguish between null and missing properties.\r\n\r\nAs I mentioned, this is only possible if you have the parent node.  You can't distinguish this difference if you're given the \"null\" node itself.\r\n\r\n> This might have been a different conversation if we were designing `JsonNode` instances from scratch...\r\n\r\nI (along with many others in the JSON functionality space) was invited to participate in the designs back when adding the STJ namespace was being considered (.Net Core 3).  No such invitation was issued for the addition of the nodes API.  I would have gladly raised this when nodes were being considered had I known about it.\r\n\r\nRegardless, history can't be changed, but this API _can_ be fixed.",
          "createdAt": "2022-04-23T20:41:42Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-04-25T05:45:41Z",
          "id": "IC_kwDODI9FZc5CBVfN"
        },
        {
          "author": "gregsdennis",
          "body": ">> And then, this doesn't even follow the typical \"try\" pattern (e.g. double.TryParse(...)) because if true is returned, it's generally expected that result will be non-null.\r\n\r\n> I wouldn't say that this is generally expected, which is why methods that do guarantee a non-null result on success need to explicitly decorate the `out` parameter with the `[NotNullWhen(true)]` attribute.\r\n\r\nThis pattern was defined by methods like `.TryParse()` (defined on all numeric types) and `.TryGetValue()` on `IDictionary<T1, T2>` long before the attribute was a thing.  It may be available now, but because of the existence and long history of these methods, users have come to expect a non-null `out` value when `true` is returned from these methods.\r\n\r\n(While `.TryGetValue()` _could_ return a null, it would require storing a null in the dictionary, which, in my experience, is a special use case where the developer should know what they're doing.  Typically, the key would be removed.)",
          "createdAt": "2022-04-25T05:50:51Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-04-25T05:53:52Z",
          "id": "IC_kwDODI9FZc5CDFUr"
        },
        {
          "author": "eiriktsarpalis",
          "body": "> > > And then, this doesn't even follow the typical \"try\" pattern (e.g. double.TryParse(...)) because if true is returned, it's generally expected that result will be non-null.\r\n> \r\n> > I wouldn't say that this is generally expected, which is why methods that do guarantee a non-null result on success need to explicitly decorate the `out` parameter with the `[NotNullWhen(true)]` attribute.\r\n> \r\n> This pattern was defined by methods like `.TryParse()` (defined on all numeric types) and `.TryGetValue()` on `IDictionary<T1, T2>` long before the attribute was a thing. It may be available now, but because of the existence and long history of these methods, users have come to expect a non-null `out` value when `true` is returned from these methods.\r\n\r\nWhile it's certainly common to expect it, I wouldn't say that's a universal rule: consider `Dictionary<int, int?>.TryGetValue`. In any case, nullability annotations if done correctly resolve any ambiguity that might exist in such expectations.\r\n\r\nIn any case, we would not be able to change the nullability annotation of the JsonObject lookup method with the proposed change.",
          "createdAt": "2022-04-25T07:05:01Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-04-25T07:12:01Z",
          "id": "IC_kwDODI9FZc5CDRNY"
        },
        {
          "author": "KalleOlaviNiemitalo",
          "body": "> ```C#\r\n> // new type\r\n> public struct JsonNull : JsonNode\r\n> {\r\n> }\r\n> ```\r\n\r\nJsonNull cannot be a struct if it is derived from class [JsonNode](https://docs.microsoft.com/dotnet/api/system.text.json.nodes.jsonnode?view=net-6.0).",
          "createdAt": "2022-04-25T07:15:52Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "LAUGH",
                "createdAt": "2022-04-25T07:54:53Z",
                "user": "Joe4evr"
              },
              {
                "content": "LAUGH",
                "createdAt": "2022-04-26T09:40:03Z",
                "user": "gregsdennis"
              }
            ],
            "totalCount": 2,
            "endCursor": "Y3Vyc29yOnYyOpHOCZ0rdg=="
          },
          "updatedAt": "2022-04-25T07:15:52Z",
          "id": "IC_kwDODI9FZc5CDUEB"
        },
        {
          "author": "krwq",
          "body": "we should perhaps consider making JsonNode constructor public, this way you could at least write an extension method which does exactly what @gregsdennis wants. Currently to mock this behavior you'd need to wrap every possible JsonNode",
          "createdAt": "2022-04-25T07:36:09Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-04-25T07:36:09Z",
          "id": "IC_kwDODI9FZc5CDZgn"
        },
        {
          "author": "gregsdennis",
          "body": "> JsonNull cannot be a struct if it is derived from class JsonNode.\n\nOops, yeah, I had it as struct at first and meant to change it.  Thanks. I've edited the original post.",
          "createdAt": "2022-04-25T08:11:48Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-04-25T08:11:48Z",
          "id": "IC_kwDODI9FZc5CDi-e"
        },
        {
          "author": "gregsdennis",
          "body": "If I have a model\r\n\r\n```c#\r\nprivate class JsonPatchOperation\r\n{\r\n\tpublic OperationType Op { get; set; }\r\n\tpublic JsonPointer? From { get; set; }\r\n\tpublic JsonPointer? Path { get; set; }\r\n\tpublic JsonNode? Value { get; set; }\r\n}\r\n```\r\n\r\nwhen I attempt to deserialize this\r\n\r\n```c#\r\nvar patchOperation = JsonSerializer.Deserialize<PatchOperation>(json);\r\n```\r\n\r\nhow do I know if `patchOperation.Value` is null because it was missing or because the value is JSON null?  This is important for validation because JSON Patch requires a value for some of the operations (e.g. `add`) but that value is allowed to be null.",
          "createdAt": "2022-06-10T08:47:51Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-08-25T11:14:08Z",
          "id": "IC_kwDODI9FZc5ErBic"
        },
        {
          "author": "gregsdennis",
          "body": "For what it's worth, [here](https://github.com/gregsdennis/json-everything/blob/master/Json.More/JsonNull.cs)'s what I ended up doing to support sending intentional nulls into method parameters with a default value.\r\n\r\nAnd here's how I use it: [call](https://github.com/gregsdennis/json-everything/blob/master/JsonSchema/PropertiesKeyword.cs#L82) / [method](https://github.com/gregsdennis/json-everything/blob/master/JsonSchema/ValidationContext.cs#L146-L149)",
          "createdAt": "2022-06-14T13:03:51Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-04-22T15:56:01Z",
                "user": "mlaily"
              },
              {
                "content": "CONFUSED",
                "createdAt": "2023-04-22T15:56:05Z",
                "user": "mlaily"
              }
            ],
            "totalCount": 2,
            "endCursor": "Y3Vyc29yOnYyOpHOC6ZMMw=="
          },
          "updatedAt": "2022-06-14T13:03:51Z",
          "id": "IC_kwDODI9FZc5E2k-Y"
        },
        {
          "author": "desjoerd",
          "body": "As null and an omitted property are serialized the same at this moment I created a package which adds OptionalValues which when a property is omitted deserializes it as Unspecified https://www.nuget.org/packages/OptionalValues/#readme-body-tab\n\nMaybe this helps when modeling a json merge patch or adding properties to an api model as a non breaking change",
          "createdAt": "2025-02-11T22:25:24Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-02-11T22:25:24Z",
          "id": "IC_kwDODI9FZc6eFWEx"
        },
        {
          "author": "neuecc",
          "body": "It's inconvenient that when a JsonNode is null, all the information like `Path` and `Parent` disappears, even though `JsonNode` normally contain a lot of information.\n`JsonNull : JsonNode` should exist.",
          "createdAt": "2025-02-20T15:22:09Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-02-21T01:15:31Z",
                "user": "gregsdennis"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-03-25T10:49:17Z",
                "user": "NiceWaffel"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-06-05T00:09:40Z",
                "user": "lue-bird"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-07-18T20:32:31Z",
                "user": "Athari"
              }
            ],
            "totalCount": 4,
            "endCursor": "Y3Vyc29yOnYyOpHOEbJgWw=="
          },
          "updatedAt": "2025-02-20T15:22:09Z",
          "id": "IC_kwDODI9FZc6fQM1U"
        },
        {
          "author": "Smaug123",
          "body": "I would *very much* like this to exist - I've spent an aggregate of several days working around the fact that `null` is a valid JSON value, and I am about to simply give up on nullable reference types in one project because of this.",
          "createdAt": "2025-04-20T18:05:23Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-04-20T18:05:23Z",
          "id": "IC_kwDODI9FZc6n7D5T"
        },
        {
          "author": "eiriktsarpalis",
          "body": "While I think everyone is in violent agreement that use of `null` to represent JSON null values is unfortunate, I find it unlikely we'd be able to change this in the future. In the years since `JsonNode` got released, a lot of APIs and have been designed and code has been written predicated on the assumption that `null` == JSON null. For example, an opt-in \"explicit null\" mode would not change the fact that most APIs returning `JsonNode` use nullable annotations, effectively hamstringing the effectiveness of the change.\n\nAnother consequence of introducing dual representation is that it would make handling of `JsonNode` instances in library code more complicated: a correct implementation would need to correctly account for both `null` and `JsonNull` values.\n\nI hate to say this, but the best course of action is to take no action.",
          "createdAt": "2025-04-23T08:09:20Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-04-23T08:09:20Z",
          "id": "IC_kwDODI9FZc6oSh8E"
        },
        {
          "author": "BryantL",
          "body": "Though I'm very well aware that others have been considering this for far longer than me, I've been pondering this for a number of months now.  \n\nI think a potentially key insight is that the current `TryGetPropertyValue` \"returns\" the \"value of the property\", which (assuming .Net non-null) has context about parent and self.  It's this context that is missing when \"value of the property\" is .Net null.\n\nTo my thinking, filling this \"context\" gap when .Net null is what is being sort by this and other similar requests.\nAssuming my thinking is correct then what's needing is a discussion on how to fill this context gap without impacting the current API or behaviours.\n\nWithout wanting to limit that discussion my thinking has led me to think the following proposed solution would be viable.  \n\nAdd a `TryGetProperty(string propertyName, out IJsonProperty? jsonProperty)` method to `JsonObject`.  \n\nA naive implementation of this method would (assuming property exists):\n\n-  For .Net non-null `JsonNode`, wrap in a `JsonProperty` that defers to the `JsonNode` for context of self and parent\n- For .Net null `JsonNode`, create a `JsonProperty` that holds the context for self and parent.\n\nA less naive implementation could eliminate the wrapping of .Net non-null `JsonNode` thereby reducing allocation to .Net null scenarios only.\n\nIf it's thought that this would be a potentially viable solution, I'm happy to write it up as its own API proposal but I don't want to fork the discussion from here unless its thought it might be.\n\nAgain, I don't want to limit the discussion and if my proposal is a dead end I still think the discussion should continue.\n\n\n\n\n\n\n\n\n",
          "createdAt": "2025-05-11T02:38:52Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-05-11T04:39:58Z",
          "id": "IC_kwDODI9FZc6rBvfx"
        }
      ],
      "totalCount": 26,
      "endCursor": "Y3Vyc29yOnYyOpHOqwb38Q=="
    },
    "url": "https://github.com/dotnet/runtime/issues/68128",
    "title": "[API Proposal]: Add JSON null independent of .Net null"
  },
  {
    "author": "Mikolaytis",
    "labels": [
      "area-System.Text.Json",
      "wishlist"
    ],
    "createdAt": "2022-04-23T15:37:38Z",
    "body": "Hi, I'm developing an app that should parse large json files(up to 1gb) inside zip files (.sketch format if you interested). \r\nFormat is open, so 100+ products can import/export this files.\r\nSome files from some products can be with invalid json in it. Current problem is an existing of 0x1F char in some json strings.\r\nWe're using Utf8JsonReader to get the best performance we can. But it throws exception on any char below space:\r\n\r\nhttps://github.com/dotnet/runtime/blob/e99fb185aa10ef177d19a51fd77b7a4b75db5395/src/libraries/System.Text.Json/src/System/Text/Json/Reader/Utf8JsonReader.MultiSegment.cs#L1051-L1055\r\n\r\nOn our side we cannot handle it with Skip - throws the same exception.\r\nWe are need to parse json with these invalid chars, because our competitors parsing them without any problem.\r\nAlso we don't want to trade performance for a fix.\r\n\r\nThe first solution I have in mind right now - is to copy System.Text.Json and re-write this part of code.\r\nSecond solution is to come with PR/API_request for adding a bool property inside JsonReaderSettings that disabling string validation.\r\nMaybe I'm missing other obvious solution. If so - help me please.\r\n\r\nPS: Filtering input before Utf8JsonReader - is a huge deal in terms of performance.",
    "number": 68439,
    "reactions": {
      "hasNextPage": false,
      "nodes": [],
      "totalCount": 0,
      "endCursor": null
    },
    "updatedAt": "2022-05-16T14:01:43Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\nHi, I'm developing an app that should parse large json files(up to 1gb) inside zip files (.sketch format if you interested). \r\nFormat is open, so 100+ products can import/export this files.\r\nSome files from some products can be with invalid json in it. Current problem is an existing of 0x1F char in some json strings.\r\nWe're using Utf8JsonReader to get the best performance we can. But it throws exception on any char below space:\r\n\r\nhttps://github.com/dotnet/runtime/blob/e99fb185aa10ef177d19a51fd77b7a4b75db5395/src/libraries/System.Text.Json/src/System/Text/Json/Reader/Utf8JsonReader.MultiSegment.cs#L1051-L1055\r\n\r\nOn our side we cannot handle it with Skip - throws the same exception.\r\nWe are need to parse json with this issues, because our competitors parsing them without any problem.\r\nAlso we don't want to trade performance for a fix.\r\n\r\nThe first solution I have in mind right now - is to copy System.Text.Json and re-write this part of code.\r\nSecond solution is to come with PR/API_request for adding a bool property inside JsonReaderSettings that disabling string validation.\r\nMaybe I'm missing other obvious solution. If so - help me please.\r\n\r\nPS: Filtering input before Utf8JsonReader - is a huge deal in terms of performance.\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>Mikolaytis</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`area-System.Text.Json`, `untriaged`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2022-04-23T15:37:44Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-04-23T15:37:44Z",
          "id": "IC_kwDODI9FZc5CA3My"
        },
        {
          "author": "Mikolaytis",
          "body": "After some googling I've found this suggestion [#45200 ](https://github.com/dotnet/runtime/issues/45200). \r\nCan be a workaround for our case...",
          "createdAt": "2022-04-23T15:43:23Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-04-23T15:43:23Z",
          "id": "IC_kwDODI9FZc5CA3ad"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Strings containing unescaped control characters are invalid per the [JSON spec](https://datatracker.ietf.org/doc/html/rfc8259#section-7). I'm assuming the reader is hardcoding enforcement out of performance and security considerations. We might consider adding a knob in the future provided there's sufficient demand, it is pay-for-play and meets our security bar. If I'm honest I don't find that to be very likely though.\r\n\r\ncc @GrabYourPitchforks",
          "createdAt": "2022-05-03T11:54:49Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-05-03T11:54:49Z",
          "id": "IC_kwDODI9FZc5ChQM5"
        },
        {
          "author": "GSPP",
          "body": "One workaround that I can think of is to write a wrapping stream that converts any invalid characters to something harmless. Maybe this can be a viable fix for you.",
          "createdAt": "2022-05-16T12:32:26Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-05-16T12:32:26Z",
          "id": "IC_kwDODI9FZc5DNgr9"
        },
        {
          "author": "Mikolaytis",
          "body": "@GSPP yes, this is a valid workaround, that costs performance! \r\nBecause I think we actually need to convert 0-32 characters into escaped represendation to not loose data. \r\nThis changes the overall length of stream.\r\nBTW 0-32 chars are used inside large texts. Maybe some specific languages using this chars for some separators or char modifiest and we need to keep them. Replacing them with spaces is a solution - but not the best one.",
          "createdAt": "2022-05-16T14:01:43Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-05-16T14:01:43Z",
          "id": "IC_kwDODI9FZc5DN49R"
        }
      ],
      "totalCount": 5,
      "endCursor": "Y3Vyc29yOnYyOpHOQzePUQ=="
    },
    "url": "https://github.com/dotnet/runtime/issues/68439",
    "title": "System.Text.Json Utf8JsonReader should handle unescaped control characters in strings"
  },
  {
    "author": "softlion",
    "labels": [
      "enhancement",
      "area-System.Text.Json"
    ],
    "createdAt": "2022-05-05T09:50:03Z",
    "body": "### Description\n\nThe JsonExtensionData property does not contain the properties from the deserialized Json that have matching read only or JsonIgnore properties on the target object.\n\n### Reproduction Steps\n\nWhen deserializing that json:\r\n\r\n```c#\r\nvar json = @\"{ \"\"value\"\": { \"\"content\"\": \"\"test\"\" } }\";\r\n```\r\n\r\ninto that object\r\n\r\n```c#\r\n    public class TestDefault\r\n    {\r\n        [JsonIgnore]\r\n        public JsonElement Value => Values[\"value\"];\r\n        \r\n        [JsonExtensionData]\r\n        public Dictionary<string, JsonElement> Values { get; set; }\r\n    }\r\n```\r\n\r\nwith this code:\r\n\r\n```c#\r\n    [TestClass]\r\n    public class TestNotionHtml\r\n    {\r\n        [TestMethod]\r\n        public void TestJsonExtensionData_Inherited()\r\n        {\r\n            var json = @\"{ \"\"value\"\": { \"\"content\"\": \"\"test\"\" } }\";\r\n            var r = JsonSerializer.Deserialize<TestDefault>(json, new(JsonSerializerDefaults.Web));\r\n            Assert.IsNotNull(r);\r\n            Assert.IsNotNull(r.Values);\r\n            Assert.AreEqual(1, r.Values.Count);\r\n            Assert.IsTrue(r.Values.ContainsKey(\"value\"));\r\n            Assert.IsNotNull(r.Value);\r\n        }\r\n  }\r\n```\r\n\r\nthe Values dictionary is empty.\r\n\n\n### Expected behavior\n\nValues should contains all properties that are not deserialized\n\n### Actual behavior\n\nValues is empty\n\n### Regression?\n\nNo\n\n### Known Workarounds\n\nNone\n\n### Configuration\n\n.net6\r\n\r\nsystem.text.json 6.0.3\r\n\n\n### Other information\n\n_No response_",
    "number": 68895,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-02-02T13:03:06Z",
          "user": "krwq"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-02-02T13:24:23Z",
          "user": "SilentCC"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-09-23T00:57:25Z",
          "user": "Ephron-WL"
        }
      ],
      "totalCount": 3,
      "endCursor": "Y3Vyc29yOnYyOpHOCyzGhw=="
    },
    "updatedAt": "2023-02-10T12:56:20Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\n### Description\n\nThe JsonExtensionData property does not contain the properties from the deserialized Json that have matching read only or JsonIgnore properties on the target object.\n\n### Reproduction Steps\n\nWhen deserializing that json:\r\n\r\n```c#\r\nvar json = @\"{ \"\"value\"\": { \"\"content\"\": \"\"test\"\" } }\";\r\n```\r\n\r\ninto that object\r\n\r\n```c#\r\n    public class TestDefault\r\n    {\r\n        [JsonIgnore]\r\n        public JsonElement Value => Values[\"value\"];\r\n        \r\n        [JsonExtensionData]\r\n        public Dictionary<string, JsonElement> Values { get; set; }\r\n    }\r\n```\r\n\r\nwith this code:\r\n\r\n```c#\r\n    [TestClass]\r\n    public class TestNotionHtml\r\n    {\r\n        [TestMethod]\r\n        public void TestJsonExtensionData_Inherited()\r\n        {\r\n            var json = @\"{ \"\"value\"\": { \"\"content\"\": \"\"test\"\" } }\";\r\n            var r = JsonSerializer.Deserialize<TestDefault>(json, new(JsonSerializerDefaults.Web));\r\n            Assert.IsNotNull(r);\r\n            Assert.IsNotNull(r.Values);\r\n            Assert.AreEqual(1, r.Values.Count);\r\n            Assert.IsTrue(r.Values.ContainsKey(\"value\"));\r\n            Assert.IsNotNull(r.Value);\r\n        }\r\n  }\r\n```\r\n\r\nthe Values dictionary is empty.\r\n\n\n### Expected behavior\n\nValues should contains all properties that are not deserialized\n\n### Actual behavior\n\nValues is empty\n\n### Regression?\n\nNo\n\n### Known Workarounds\n\nNone\n\n### Configuration\n\n.net6\r\n\r\nsystem.text.json 6.0.3\r\n\n\n### Other information\n\n_No response_\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>softlion</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`area-System.Text.Json`, `untriaged`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2022-05-05T09:50:09Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-05-05T09:50:09Z",
          "id": "IC_kwDODI9FZc5CqPfD"
        },
        {
          "author": "eiriktsarpalis",
          "body": "I can reproduce, here's a minimal reproduction:\r\n```C#\r\nvar json = @\"{ \"\"Value\"\": true }\";\r\nvar r = JsonSerializer.Deserialize<TestDefault>(json);\r\nConsole.WriteLine(r.ExtensionData?.Count ?? 0); // prints 0\r\n\r\npublic class TestDefault\r\n{\r\n    public bool Value { get; }\r\n\r\n    [JsonExtensionData]\r\n    public Dictionary<string, object> ExtensionData { get; set; }\r\n}\r\n```\r\nI wouldn't necessarily consider this to be a bug, although I can see why the expected behavior would be nice to have. We might want to consider it in a future release. cc @layomia @steveharter ",
          "createdAt": "2022-05-09T14:19:23Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-12-02T18:36:50Z",
                "user": "layomia"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOCwmb5g=="
          },
          "updatedAt": "2022-05-09T14:19:23Z",
          "id": "IC_kwDODI9FZc5C06EP"
        },
        {
          "author": "svick",
          "body": "This shouldn't have been closed, right?",
          "createdAt": "2022-11-27T14:34:57Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-11-27T14:34:57Z",
          "id": "IC_kwDODI9FZc5PK6Mj"
        },
        {
          "author": "Mizuwokiru",
          "body": "If someone still needs to use this approach, the issue can be avoided by adding JsonPropertyName attribute that doesn't match to any property of your object.\r\nFor example:\r\n```cs\r\npublic class TestDefault\r\n{\r\n    [JsonPropertyName($\"${nameof(Value)}\"), JsonIgnore]\r\n    public JsonElement Value => Values[\"value\"];\r\n\r\n    [JsonExtensionData]\r\n    public Dictionary<string, JsonElement> Values { get; set; }\r\n}\r\n```",
          "createdAt": "2023-02-10T11:56:48Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-08-01T16:55:38Z",
                "user": "Rauce"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-08-23T13:12:47Z",
                "user": "malylemireflo"
              }
            ],
            "totalCount": 2,
            "endCursor": "Y3Vyc29yOnYyOpHODveufQ=="
          },
          "updatedAt": "2023-02-10T11:58:39Z",
          "id": "IC_kwDODI9FZc5U-pkb"
        },
        {
          "author": "krwq",
          "body": "Better workaround would be:\r\n\r\n```csharp\r\nusing System.Text.Json;\r\nusing System.Text.Json.Serialization;\r\nusing System.Text.Json.Serialization.Metadata;\r\n\r\nJsonSerializerOptions options = new()\r\n{\r\n    TypeInfoResolver = new DefaultJsonTypeInfoResolver()\r\n    {\r\n        Modifiers =\r\n        {\r\n            ti =>\r\n            {\r\n                if (ti.Kind == JsonTypeInfoKind.Object)\r\n                {\r\n                    JsonPropertyInfo[] props = ti.Properties\r\n                        .Where(prop => prop.AttributeProvider == null || prop.AttributeProvider.GetCustomAttributes(typeof(JsonIgnoreAttribute), false).Length == 0)\r\n                        .ToArray();\r\n\r\n                    if (props.Length != ti.Properties.Count)\r\n                    {\r\n                        ti.Properties.Clear();\r\n                        foreach (var prop in props)\r\n                        {\r\n                            ti.Properties.Add(prop);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\nvar json = @\"{ \"\"Value\"\": { \"\"content\"\": \"\"test\"\" } }\";\r\nTestDefault obj = JsonSerializer.Deserialize<TestDefault>(json, options);\r\nif (obj.Values != null)\r\n{\r\n    foreach (var (k, v) in obj.Values)\r\n    {\r\n        Console.WriteLine($\"{k} => {v}\"); // Value => { \"content\": \"test\" }\r\n    }\r\n}\r\n\r\npublic class TestDefault\r\n{\r\n    [JsonIgnore]\r\n    public JsonElement Value => Values[\"value\"];\r\n\r\n    [JsonExtensionData]\r\n    public Dictionary<string, JsonElement>? Values { get; set; }\r\n}\r\n```\r\n\r\nNote 1: ignored properties will also not work with parametrized constructors in that case (assuming that was desired in the first place).\r\n\r\nNote 2: It needs testing with inheritance if needed for production",
          "createdAt": "2023-02-10T12:54:14Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-02-10T12:56:20Z",
          "id": "IC_kwDODI9FZc5U-4a_"
        }
      ],
      "totalCount": 5,
      "endCursor": "Y3Vyc29yOnYyOpHOVPuGvw=="
    },
    "url": "https://github.com/dotnet/runtime/issues/68895",
    "title": "System.Text.Json does not fill JsonExtensionData when a property with the same name already exists or has the JsonIgnoreAttribute"
  },
  {
    "author": "lewing",
    "labels": [
      "test-failure",
      "area-System.Text.Json"
    ],
    "createdAt": "2022-05-09T20:52:17Z",
    "body": "in https://github.com/dotnet/runtime/pull/68126 \r\n\r\nruntime (Libraries Test Run checked coreclr Linux_musl arm64 Debug)  failed with \r\n```\r\n===========================================================================================================\r\n/root/helix/work/workitem/e /root/helix/work/workitem/e\r\n  Discovering: System.Text.Json.Tests (method display = ClassAndMethod, method display options = None)\r\n  Discovered:  System.Text.Json.Tests (found 5090 of 5163 test cases)\r\n  Starting:    System.Text.Json.Tests (parallel test collections = on, max threads = 4)\r\n    System.Text.Json.Serialization.Tests.StreamTests_DeserializeAsyncEnumerable.DeserializeAsyncEnumerable_ReadSimpleObjectAsync(count: 1000, bufferSize: 1) [FAIL]\r\n      Assert.Equal() Failure\r\n      Expected: 1b33498a-7b7d-4dda-9c13-f6aa4ab449a6\r\n      Actual:   00000000-0000-0000-0000-000000000000\r\n      Stack Trace:\r\n        /_/src/libraries/System.Text.Json/tests/Common/TestClasses/TestClasses.SimpleTestClass.cs(327,0): at System.Text.Json.Serialization.Tests.SimpleTestClass.Verify()\r\n        /_/src/libraries/System.Text.Json/tests/System.Text.Json.Tests/Serialization/Stream.DeserializeAsyncEnumerable.cs(39,0): at System.Text.Json.Serialization.Tests.StreamTests_DeserializeAsyncEnumerable.DeserializeAsyncEnumerable_ReadSimpleObjectAsync(Int32 count, Int32 bufferSize)\r\n        /_/src/libraries/System.Text.Json/tests/System.Text.Json.Tests/Serialization/Stream.DeserializeAsyncEnumerable.cs(34,0): at System.Text.Json.Serialization.Tests.StreamTests_DeserializeAsyncEnumerable.DeserializeAsyncEnumerable_ReadSimpleObjectAsync(Int32 count, Int32 bufferSize)\r\n        --- End of stack trace from previous location ---\r\n  Finished:    System.Text.Json.Tests\r\n=== TEST EXECUTION SUMMARY ===\r\n   System.Text.Json.Tests  Total: 23966, Errors: 0, Failed: 1, Skipped: 0, Time: 456.030s\r\n```\r\n\r\nhttps://helixre8s23ayyeko0k025g8.blob.core.windows.net/dotnet-runtime-refs-pull-68126-merge-7e9a4eb51d274e8ba7/System.Text.Json.Tests/1/console.7c9744fa.log?helixlogtype=result\r\n\r\nretry passed",
    "number": 69076,
    "reactions": {
      "hasNextPage": false,
      "nodes": [],
      "totalCount": 0,
      "endCursor": null
    },
    "updatedAt": "2022-06-25T04:00:50Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\nin https://github.com/dotnet/runtime/pull/68126 \r\n\r\nruntime (Libraries Test Run checked coreclr Linux_musl arm64 Debug)  failed with \r\n```\r\n===========================================================================================================\r\n/root/helix/work/workitem/e /root/helix/work/workitem/e\r\n  Discovering: System.Text.Json.Tests (method display = ClassAndMethod, method display options = None)\r\n  Discovered:  System.Text.Json.Tests (found 5090 of 5163 test cases)\r\n  Starting:    System.Text.Json.Tests (parallel test collections = on, max threads = 4)\r\n    System.Text.Json.Serialization.Tests.StreamTests_DeserializeAsyncEnumerable.DeserializeAsyncEnumerable_ReadSimpleObjectAsync(count: 1000, bufferSize: 1) [FAIL]\r\n      Assert.Equal() Failure\r\n      Expected: 1b33498a-7b7d-4dda-9c13-f6aa4ab449a6\r\n      Actual:   00000000-0000-0000-0000-000000000000\r\n      Stack Trace:\r\n        /_/src/libraries/System.Text.Json/tests/Common/TestClasses/TestClasses.SimpleTestClass.cs(327,0): at System.Text.Json.Serialization.Tests.SimpleTestClass.Verify()\r\n        /_/src/libraries/System.Text.Json/tests/System.Text.Json.Tests/Serialization/Stream.DeserializeAsyncEnumerable.cs(39,0): at System.Text.Json.Serialization.Tests.StreamTests_DeserializeAsyncEnumerable.DeserializeAsyncEnumerable_ReadSimpleObjectAsync(Int32 count, Int32 bufferSize)\r\n        /_/src/libraries/System.Text.Json/tests/System.Text.Json.Tests/Serialization/Stream.DeserializeAsyncEnumerable.cs(34,0): at System.Text.Json.Serialization.Tests.StreamTests_DeserializeAsyncEnumerable.DeserializeAsyncEnumerable_ReadSimpleObjectAsync(Int32 count, Int32 bufferSize)\r\n        --- End of stack trace from previous location ---\r\n  Finished:    System.Text.Json.Tests\r\n=== TEST EXECUTION SUMMARY ===\r\n   System.Text.Json.Tests  Total: 23966, Errors: 0, Failed: 1, Skipped: 0, Time: 456.030s\r\n```\r\n\r\nhttps://helixre8s23ayyeko0k025g8.blob.core.windows.net/dotnet-runtime-refs-pull-68126-merge-7e9a4eb51d274e8ba7/System.Text.Json.Tests/1/console.7c9744fa.log?helixlogtype=result\r\n\r\nretry passed\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>lewing</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`area-System.Text.Json`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2022-05-09T20:52:22Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-05-09T20:52:22Z",
          "id": "IC_kwDODI9FZc5C2cyd"
        }
      ],
      "totalCount": 1,
      "endCursor": "Y3Vyc29yOnYyOpHOQtnMnQ=="
    },
    "url": "https://github.com/dotnet/runtime/issues/69076",
    "title": "System.Text.Json.Serialization.Tests.StreamTests_DeserializeAsyncEnumerable.DeserializeAsyncEnumerable_ReadSimpleObjectAsync(count: 1000, bufferSize: 1) [FAIL]"
  },
  {
    "author": "cytoph",
    "labels": [
      "enhancement",
      "area-System.Text.Json",
      "wishlist"
    ],
    "createdAt": "2022-05-24T14:44:46Z",
    "body": "Yeah, kind of what I wrote in the title.\r\n\r\nEven when the `NumberHandling` of the passed `JsonSerializerOptions` is set to `AllowReadingFromString` the default `Read` method will ignore it and throws an exception stating \"Cannot get the value of a token type 'String' as a number.\"\r\n\r\nhttps://github.com/dotnet/runtime/blob/fff4ff0913a2396cfae61c701f2b59ffe5e27b49/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/Converters/Value/DecimalConverter.cs#L13-L16\r\n\r\n`ReadNumberWithCustomHandling` on the other hand **will** indeed follow the set `NumberHandling`, but the method is internal and can therefore not be used outside of the library.\r\n\r\nhttps://github.com/dotnet/runtime/blob/fff4ff0913a2396cfae61c701f2b59ffe5e27b49/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/Converters/Value/DecimalConverter.cs#L33-L42\r\n\r\nThe use-case I have is a custom `JsonConverter` that contains a method that tries to get a JsonConverter for a specific generic type from the `JsonSerializerOptions` like this (which in case of `decimal` will get the `DecimalConverter` and throw said exception:\r\n\r\n```\r\nprivate static T GetValue<T>(ref Utf8JsonReader reader, JsonSerializerOptions options)\r\n{\r\n    var converter = (JsonConverter<T>)options.GetConverter(typeof(T));\r\n\r\n    if (converter != null)\r\n    {\r\n        reader.Read();\r\n        return converter.Read(ref reader, typeof(T), options);\r\n    }\r\n    else\r\n        return JsonSerializer.Deserialize<T>(ref reader, options);\r\n}\r\n```\r\n\r\nIf in any case relevant, this sample is referring to how it's done in the [docs for how to implement a custom JSON converter](https://docs.microsoft.com/en-us/dotnet/standard/serialization/system-text-json-converters-how-to?pivots=dotnet-5-0#sample-factory-pattern-converter).",
    "number": 69718,
    "reactions": {
      "hasNextPage": false,
      "nodes": [],
      "totalCount": 0,
      "endCursor": null
    },
    "updatedAt": "2022-05-25T11:20:56Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\nYeah, kind of what I wrote in the title.\r\n\r\nEven when the `NumberHandling` of the passed `JsonSerializerOptions` is set to `AllowReadingFromString` the default `Read` method will ignore it and throws an exception stating \"Cannot get the value of a token type 'String' as a number.\"\r\n\r\nhttps://github.com/dotnet/runtime/blob/fff4ff0913a2396cfae61c701f2b59ffe5e27b49/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/Converters/Value/DecimalConverter.cs#L13-L16\r\n\r\n`ReadNumberWithCustomHandling` on the other hand **will** indeed follow the set `NumberHandling`, but the method is internal and can therefore not be used outside of the library.\r\n\r\nhttps://github.com/dotnet/runtime/blob/fff4ff0913a2396cfae61c701f2b59ffe5e27b49/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/Converters/Value/DecimalConverter.cs#L33-L42\r\n\r\nThe use-case I have is a custom `JsonConverter` that contains a method that tries to get a JsonConverter for a specific generic type from the `JsonSerializerOptions` like this (which in case of `decimal` will get the `DecimalConverter` and throw said exception:\r\n\r\n```\r\nprivate static T GetValue<T>(ref Utf8JsonReader reader, JsonSerializerOptions options)\r\n{\r\n    var converter = (JsonConverter<T>)options.GetConverter(typeof(T));\r\n\r\n    if (converter != null)\r\n    {\r\n        reader.Read();\r\n        return converter.Read(ref reader, typeof(T), options);\r\n    }\r\n    else\r\n        return JsonSerializer.Deserialize<T>(ref reader, options);\r\n```\r\n\r\nIf in any case relevant, this sample is referring to how it's done in the [docs for how to implement a custom JSON converter](https://docs.microsoft.com/en-us/dotnet/standard/serialization/system-text-json-converters-how-to?pivots=dotnet-5-0#sample-factory-pattern-converter).\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>cytoph</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`area-System.Text.Json`, `untriaged`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2022-05-24T14:44:56Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-05-24T14:44:56Z",
          "id": "IC_kwDODI9FZc5Dtlnr"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Note that this behavior isn't specific to DecimalConverter -- all numeric converters follow the same pattern, e.g. [Int32Converter](https://github.com/dotnet/runtime/blob/fff4ff0913a2396cfae61c701f2b59ffe5e27b49/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/Converters/Value/Int32Converter.cs) works the same way. The converter uses separate internal methods for number handling because its value is informed by a few different sources: `JsonSerializerOptions`, `JsonNumberHandlingAttribute` as well as the value inherited from the parent type. The exposed public method signatures are simply insufficient when it comes to accommodating such scenaria.\r\n\r\nThat being said, I'm not sure why the public methods ignore the number handling setting of `JsonSerializerOptions`. It clearly is intentional, I suspect it might be related to performance considerations but I'm not sure what these are [given that the hot path never calls into them](https://github.com/dotnet/runtime/blob/6761c44636de0835614efc8acb18fe0e7c256602/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/JsonConverterOfT.cs#L291-L294). In any case, I'm afraid changing this now would be a breaking change specifically for the use case that you are citing. ",
          "createdAt": "2022-05-25T11:20:38Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-05-25T11:20:38Z",
          "id": "IC_kwDODI9FZc5Dxws8"
        }
      ],
      "totalCount": 2,
      "endCursor": "Y3Vyc29yOnYyOpHOQ8cLPA=="
    },
    "url": "https://github.com/dotnet/runtime/issues/69718",
    "title": "Default Read method of DecimalConverter ignores NumberHandling"
  },
  {
    "author": "mkhamoyan",
    "labels": [
      "test-failure",
      "area-System.Text.Json",
      "os-android",
      "runtime-mono"
    ],
    "createdAt": "2022-05-25T16:01:01Z",
    "body": "### Description\n\nIn last rolling [build](https://runfo.azurewebsites.net/view/build/?number=1788542) of runtime-extra-platforms System.Text.Json.Nodes.Tests.OperatorTests.ExplicitOperators_FromValues test is failing with following exception at System.Text.Json.Nodes.Tests.OperatorTests.ExplicitOperators_FromValues() in /_/src/libraries/System.Text.Json/tests/System.Text.Json.Tests/JsonNode/JsonNodeOperatorTests.cs:line 105\r\n   at System.Reflection.MethodInvoker.InterpretedInvoke(Object obj, Span`1 args, BindingFlags invokeAttr)\r\n\r\nAssert.Equal() Failure\r\nExpected: NaN\r\nActual:   2.2000000000000002\n\n### Reproduction Steps\n\nCheck last rolling [build](https://runfo.azurewebsites.net/view/build/?number=1788542) of runtime-extra-platforms \n\n### Expected behavior\n\nSystem.Text.Json.Nodes.Tests.OperatorTests.ExplicitOperators_FromValues  should pass.\n\n### Actual behavior\n\nSystem.Text.Json.Nodes.Tests.OperatorTests.ExplicitOperators_FromValues  is failing.\n\n### Regression?\n\n_No response_\n\n### Known Workarounds\n\n_No response_\n\n### Configuration\n\n_No response_\n\n### Other information\n\n_No response_",
    "number": 69800,
    "reactions": {
      "hasNextPage": false,
      "nodes": [],
      "totalCount": 0,
      "endCursor": null
    },
    "updatedAt": "2022-09-02T14:22:21Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\n### Description\n\nIn last rolling [build](https://runfo.azurewebsites.net/view/build/?number=1788542) of runtime-extra-platforms System.Text.Json.Nodes.Tests.OperatorTests.ExplicitOperators_FromValues test is failing with following exception at System.Text.Json.Nodes.Tests.OperatorTests.ExplicitOperators_FromValues() in /_/src/libraries/System.Text.Json/tests/System.Text.Json.Tests/JsonNode/JsonNodeOperatorTests.cs:line 105\r\n   at System.Reflection.MethodInvoker.InterpretedInvoke(Object obj, Span`1 args, BindingFlags invokeAttr)\r\n\r\nAssert.Equal() Failure\r\nExpected: NaN\r\nActual:   2.2000000000000002\n\n### Reproduction Steps\n\nCheck last rolling [build](https://runfo.azurewebsites.net/view/build/?number=1788542) of runtime-extra-platforms \n\n### Expected behavior\n\nSystem.Text.Json.Nodes.Tests.OperatorTests.ExplicitOperators_FromValues  should pass.\n\n### Actual behavior\n\nSystem.Text.Json.Nodes.Tests.OperatorTests.ExplicitOperators_FromValues  is failing.\n\n### Regression?\n\n_No response_\n\n### Known Workarounds\n\n_No response_\n\n### Configuration\n\n_No response_\n\n### Other information\n\n_No response_\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>mkhamoyan</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`area-System.Text.Json`, `untriaged`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2022-05-25T16:01:12Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-05-25T16:01:12Z",
          "id": "IC_kwDODI9FZc5DzH7w"
        },
        {
          "author": "mkhamoyan",
          "body": "From commit history only things that more or less can be related maybe are these PRs https://github.com/dotnet/runtime/pull/69326 and https://github.com/dotnet/runtime/pull/69768, @MichalStrehovsky , @eiriktsarpalis could you please take a look? can these PRs be related?",
          "createdAt": "2022-05-25T16:03:19Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-05-25T16:03:19Z",
          "id": "IC_kwDODI9FZc5DzIfF"
        },
        {
          "author": "eiriktsarpalis",
          "body": "According to the test results the following assertion is failing:\r\n\r\nhttps://github.com/dotnet/runtime/blob/b7b59cdff918bc84d637202c5b91dc918ba9a8eb/src/libraries/System.Text.Json/tests/System.Text.Json.Tests/JsonNode/JsonNodeOperatorTests.cs#L105\r\n\r\nFor whatever reason the error message states that the expected value is `NaN`, even though this is clearly not the expected argument being passed to the assertion. I don't think it's related to JSON changes.",
          "createdAt": "2022-05-25T17:05:31Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-05-25T17:05:31Z",
          "id": "IC_kwDODI9FZc5DzeLb"
        },
        {
          "author": "MichalStrehovsky",
          "body": "> https://github.com/dotnet/runtime/pull/69768\r\n\r\nThis affected file is not included from Mono, so I'm 100% sure it's unrelated.",
          "createdAt": "2022-05-26T00:09:34Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-05-26T00:09:34Z",
          "id": "IC_kwDODI9FZc5D1Imz"
        },
        {
          "author": "mkhamoyan",
          "body": "Seems the failure was sporadic, not available on new [build](https://runfo.azurewebsites.net/view/build/?number=1789813).\r\nI will wait for one more rolling build and if everything good will close the issue.",
          "createdAt": "2022-05-26T09:13:53Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-05-26T09:13:53Z",
          "id": "IC_kwDODI9FZc5D2YsU"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Should this be closed now?",
          "createdAt": "2022-06-07T15:19:13Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-06-07T15:19:13Z",
          "id": "IC_kwDODI9FZc5EeYu6"
        },
        {
          "author": null,
          "body": "Tagging subscribers to 'arch-android': @steveisok, @akoeplinger\nSee info in area-owners.md if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\n### Description\n\nIn last rolling [build](https://runfo.azurewebsites.net/view/build/?number=1788542) of runtime-extra-platforms System.Text.Json.Nodes.Tests.OperatorTests.ExplicitOperators_FromValues test is failing with following exception at System.Text.Json.Nodes.Tests.OperatorTests.ExplicitOperators_FromValues() in /_/src/libraries/System.Text.Json/tests/System.Text.Json.Tests/JsonNode/JsonNodeOperatorTests.cs:line 105\r\n   at System.Reflection.MethodInvoker.InterpretedInvoke(Object obj, Span`1 args, BindingFlags invokeAttr)\r\n\r\nAssert.Equal() Failure\r\nExpected: NaN\r\nActual:   2.2000000000000002\n\n### Reproduction Steps\n\nCheck last rolling [build](https://runfo.azurewebsites.net/view/build/?number=1788542) of runtime-extra-platforms \n\n### Expected behavior\n\nSystem.Text.Json.Nodes.Tests.OperatorTests.ExplicitOperators_FromValues  should pass.\n\n### Actual behavior\n\nSystem.Text.Json.Nodes.Tests.OperatorTests.ExplicitOperators_FromValues  is failing.\n\n### Regression?\n\n_No response_\n\n### Known Workarounds\n\n_No response_\n\n### Configuration\n\n_No response_\n\n### Other information\n\n_No response_\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>mkhamoyan</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`area-System.Text.Json`, `os-android`, `untriaged`, `runtime-mono`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2022-06-16T12:47:03Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-06-16T12:47:03Z",
          "id": "IC_kwDODI9FZc5E_-J6"
        },
        {
          "author": "karelz",
          "body": "This is still happening - see [runfo](https://runfo.azurewebsites.net/search/tests/?q=started%3A~7%20definition%3Aruntime-extra-platforms%20name%3A%22system.text.json.nodes.tests.operatortests.explicitoperators_fromvalues%22)\r\n- 6/15 - 10 failures (6 in rolling test runs, 4 in PRs) in [last 7 days](https://runfo.azurewebsites.net/search/tests/?q=started%3A~7+definition%3Aruntime-extra-platforms+name%3A%22system.text.json.nodes.tests.operatortests.explicitoperators_fromvalues%22)\r\n    - 24 failures in [last 30 days](https://runfo.azurewebsites.net/search/tests/?q=started%3A%7E30+definition%3Aruntime-extra-platforms+name%3A%22system.text.json.nodes.tests.operatortests.explicitoperators_fromvalues%22) - 12 failures in rolling test runs\r\n\r\nGiven the impact, can we please disable the test ASAP on Android? @steveisok ",
          "createdAt": "2022-06-16T12:50:01Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-06-24T09:39:06Z",
          "id": "IC_kwDODI9FZc5E_-3H"
        },
        {
          "author": "karelz",
          "body": "Test is disabled now - thanks @mkhamoyan! Not blocking CI anymore.",
          "createdAt": "2022-06-24T09:40:06Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-06-24T09:40:06Z",
          "id": "IC_kwDODI9FZc5FdoxY"
        }
      ],
      "totalCount": 9,
      "endCursor": "Y3Vyc29yOnYyOpHORXaMWA=="
    },
    "url": "https://github.com/dotnet/runtime/issues/69800",
    "title": "System.Text.Json.Nodes.Tests.OperatorTests.ExplicitOperators_FromValues failing on Android x86 in rolling build of runtime-extra-platforms"
  },
  {
    "author": "krwq",
    "labels": [
      "api-suggestion",
      "area-System.Text.Json",
      "wishlist"
    ],
    "createdAt": "2022-06-07T13:09:53Z",
    "body": "Currently:\r\n- tuples don't serialize by default (`options.IncludeFields = true` is required)\r\n- they don't preserve names (serialize as `{\"Item1\":\"foo\",\"Item2\":\"bar\"}`\r\n\r\nWe should improve this behavior and figure out how to not break people potentially relying on the existing behavior.\r\n\r\nExample possibilities for fixing this:\r\n- we provide converter for serialization\r\n- we provide options switch (i.e. TupleHandling)\r\n\r\nPossible ways of serialization:\r\n- array\r\n- object, we need to figure out if it's possible to preserve user provided names\r\n\r\nrelated: https://github.com/dotnet/runtime/issues/68264",
    "number": 70352,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-09-06T06:44:51Z",
          "user": "askazakov"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-08-16T18:33:45Z",
          "user": "austindrenski"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-08-25T20:12:59Z",
          "user": "macias"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-08-27T07:29:33Z",
          "user": "TDroogers"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-09-18T18:15:24Z",
          "user": "Tiberriver256"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-06-15T17:27:32Z",
          "user": "Oblomoff"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-07-01T03:13:21Z",
          "user": "Robik81"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-09-20T21:29:37Z",
          "user": "SamiG42"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-09-26T15:00:05Z",
          "user": "Vazde"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-10-28T16:27:50Z",
          "user": "BigMacEtienne"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-11-18T14:35:51Z",
          "user": "TheConstructor"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-12-02T08:28:52Z",
          "user": "aetos382"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-12-02T13:19:22Z",
          "user": "julealgon"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-12-04T01:57:47Z",
          "user": "ThioJoe"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-03-13T15:00:35Z",
          "user": "Joppe27"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-04-24T11:57:00Z",
          "user": "thomasdc"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-06-12T20:58:20Z",
          "user": "BOLT04"
        }
      ],
      "totalCount": 17,
      "endCursor": "Y3Vyc29yOnYyOpHODDyUUw=="
    },
    "updatedAt": "2024-12-02T09:03:31Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\nCurrently:\r\n- tuples don't serialize by default (`options.IncludeFields = true` is required)\r\n- they don't preserve names (serialize as `{\"Item1\":\"foo\",\"Item2\":\"bar\"}`\r\n\r\nWe should improve this behavior and figure out how to not break people potentially relying on the existing behavior.\r\n\r\nExample possibilities for fixing this:\r\n- we provide converter for serialization\r\n- we provide options switch (i.e. TupleHandling)\r\n\r\nPossible ways of serialization:\r\n- array\r\n- object, we need to figure out if it's possible to preserve user provided names\r\n\r\nrelated: https://github.com/dotnet/runtime/issues/68264\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>krwq</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`area-System.Text.Json`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2022-06-07T13:10:00Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-06-07T13:10:00Z",
          "id": "IC_kwDODI9FZc5EdwoJ"
        },
        {
          "author": "eiriktsarpalis",
          "body": "One issue with the current serialization of tuples is that it doesn't handle arities > 7 well:\r\n```C#\r\nvar tuple = (1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);\r\nstring json = JsonSerializer.Serialize(tuple, new JsonSerializerOptions { IncludeFields = true, WriteIndented = true });\r\nConsole.WriteLine(json); \r\n//{\r\n//  \"Item1\": 1,\r\n//  \"Item2\": 1,\r\n//  \"Item3\": 1,\r\n//  \"Item4\": 1,\r\n//  \"Item5\": 1,\r\n//  \"Item6\": 1,\r\n//  \"Item7\": 1,\r\n//  \"Rest\": {\r\n//    \"Item1\": 1,\r\n//    \"Item2\": 1,\r\n//    \"Item3\": 1,\r\n//    \"Item4\": 1,\r\n//    \"Item5\": 1,\r\n//    \"Item6\": 1,\r\n//    \"Item7\": 1,\r\n//    \"Rest\": {\r\n//      \"Item1\": 1,\r\n//      \"Item2\": 1\r\n//    }\r\n//  }\r\n//}\r\n```\r\nWe might want to consider exposing an opt-in converter that treats tuples as heterogeneous arrays:\r\n```C#\r\nvar options = new JsonSerializerOptions { Converters = { new JsonArrayTupleConverter() } };\r\nvar tuple = (\"foo\", 42, new { Data = true });\r\nJsonSerializer.Serialize(tuple, options); // [\"foo\", 42, { \"Data\" : true }]\r\n```\r\nAnd works with large arities as expected:\r\n```C#\r\nvar tuple = (1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);\r\nJsonSerializer.Serialize(tuple, options); // [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\r\n```",
          "createdAt": "2022-06-07T13:18:47Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-01-17T12:50:59Z",
                "user": "chillitom"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-11-18T14:35:57Z",
                "user": "TheConstructor"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-12-12T01:51:16Z",
                "user": "maxkatz6"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-04-10T14:28:50Z",
                "user": "ruslan-yefimov"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-05-28T10:05:14Z",
                "user": "anatawa12"
              }
            ],
            "totalCount": 5,
            "endCursor": "Y3Vyc29yOnYyOpHOEUFk-Q=="
          },
          "updatedAt": "2022-06-07T13:19:47Z",
          "id": "IC_kwDODI9FZc5EdzQd"
        },
        {
          "author": "huoyaoyuan",
          "body": "> We might want to consider exposing an opt-in converter that treats tuples as heterogeneous arrays:\r\n\r\nYes, please. Some apis use array to represent tuples, and would contain different types of elements within an array.",
          "createdAt": "2022-06-07T15:44:28Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-11-18T14:36:02Z",
                "user": "TheConstructor"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOD7X6Lg=="
          },
          "updatedAt": "2022-06-07T15:44:28Z",
          "id": "IC_kwDODI9FZc5EegEE"
        },
        {
          "author": "macias",
          "body": "@krwq My guess is you are talking about ValueTuples, not Tuples actually.\r\n\r\nIMHO it is unfortunate that JSON serializer was released in such shape (i.e. without support for value tuples), but since it is done, changing default behaviour could be risky. I think safe feature we all could agree on, would be to provide default ValueTuple converter.\r\n\r\nThis at least would allow to easy enabling it.",
          "createdAt": "2023-08-25T20:17:12Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-08-27T07:29:30Z",
                "user": "TDroogers"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-08-28T16:06:50Z",
                "user": "krwq"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-09-26T15:00:37Z",
                "user": "Vazde"
              }
            ],
            "totalCount": 3,
            "endCursor": "Y3Vyc29yOnYyOpHODzuBFQ=="
          },
          "updatedAt": "2023-08-25T20:17:12Z",
          "id": "IC_kwDODI9FZc5k9p4S"
        },
        {
          "author": "chillitom",
          "body": "> We might want to consider exposing an opt-in converter that treats tuples as heterogeneous arrays:\r\n> \r\n> var options = new JsonSerializerOptions { Converters = { new JsonArrayTupleConverter() } };\r\n\r\nAnyone have an implementation of such a `JsonArrayTupleConverter`?\r\n",
          "createdAt": "2024-01-17T12:52:24Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "EYES",
                "createdAt": "2024-01-17T18:36:01Z",
                "user": "gregsdennis"
              },
              {
                "content": "EYES",
                "createdAt": "2025-04-10T14:30:56Z",
                "user": "ruslan-yefimov"
              }
            ],
            "totalCount": 2,
            "endCursor": "Y3Vyc29yOnYyOpHOENtmEg=="
          },
          "updatedAt": "2024-01-17T12:52:24Z",
          "id": "IC_kwDODI9FZc5w_trb"
        },
        {
          "author": "gregsdennis",
          "body": "@chillitom ☝️ \r\n\r\nI've just released [Json.More.Net](https://www.nuget.org/packages/Json.More.Net/) v1.10.0 which includes a `JsonArrayTupleConverter`.\r\n\r\n```c#\r\nvar options = new JsonSerializerOptions { Converters = { JsonArrayTupleConverter.Instance } };\r\nvar json = JsonSerializer.Serialize((1, \"string\"), options);\r\nvar tuple = JsonSerializer.Deserialize<(int, string)>(json, options);\r\n```\r\n\r\nShould work with any size tuple.  Let me know if you have problems.\r\n\r\n![image](https://github.com/dotnet/runtime/assets/2676804/3be97a93-0f2d-4e4e-b4fe-94a433c75694)",
          "createdAt": "2024-01-17T21:28:10Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-01-17T22:10:48Z",
                "user": "chillitom"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-12-02T09:09:54Z",
                "user": "huoyaoyuan"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-04-10T14:31:06Z",
                "user": "ruslan-yefimov"
              },
              {
                "content": "ROCKET",
                "createdAt": "2025-04-10T14:31:11Z",
                "user": "ruslan-yefimov"
              }
            ],
            "totalCount": 4,
            "endCursor": "Y3Vyc29yOnYyOpHOENtmcA=="
          },
          "updatedAt": "2024-01-17T21:30:01Z",
          "id": "IC_kwDODI9FZc5xDyr9"
        },
        {
          "author": "Sandeep7OnShell",
          "body": "Sadly the issue was opened more than 2 years ago and still people are waiting for some meaningful solution. @ericstj @stephentoub Any way to get some help on this?",
          "createdAt": "2024-12-02T09:03:30Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-04-10T14:33:03Z",
                "user": "ruslan-yefimov"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-06-19T07:34:43Z",
                "user": "ltbyun"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-07-16T14:57:26Z",
                "user": "OpenByteDev"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-09-09T05:30:23Z",
                "user": "mattbdc"
              }
            ],
            "totalCount": 4,
            "endCursor": "Y3Vyc29yOnYyOpHOEhaw6Q=="
          },
          "updatedAt": "2024-12-02T09:03:30Z",
          "id": "IC_kwDODI9FZc6VqgaV"
        }
      ],
      "totalCount": 7,
      "endCursor": "Y3Vyc29yOnYyOpHOlaoGlQ=="
    },
    "url": "https://github.com/dotnet/runtime/issues/70352",
    "title": "JsonSerializer should serialize tuples by default"
  },
  {
    "author": "gregsdennis",
    "labels": [
      "api-suggestion",
      "area-System.Text.Json",
      "wishlist"
    ],
    "createdAt": "2022-06-08T11:50:54Z",
    "body": "The [documentation](https://github.com/dotnet/designs/blob/main/accepted/2020/serializer/WriteableDomAndDynamic.md#interop-with-jsonelement) states in the first sentence that there is a constructor in `JsonNode` derivations that take `JsonElement` in order to convert between them.  However, looking at hte [API docs](https://docs.microsoft.com/en-us/dotnet/api/system.text.json.nodes.jsonarray.-ctor?view=net-6.0), I see no such constructor.\r\n\r\nWas this missed?  What is the recommended way to convert from `JsonElement` to `JsonNode`?\r\n\r\nRelated to #52611",
    "number": 70427,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-12-04T13:11:27Z",
          "user": "JobaDiniz"
        }
      ],
      "totalCount": 1,
      "endCursor": "Y3Vyc29yOnYyOpHOC9L4gQ=="
    },
    "updatedAt": "2024-10-24T10:26:52Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\nThe [documentation](https://github.com/dotnet/designs/blob/main/accepted/2020/serializer/WriteableDomAndDynamic.md#interop-with-jsonelement) states in the first sentence that there is a constructor in `JsonNode` derivations that take `JsonElement` in order to convert between them.  However, looking at hte [API docs](https://docs.microsoft.com/en-us/dotnet/api/system.text.json.nodes.jsonarray.-ctor?view=net-6.0), I see no such constructor.\r\n\r\nWas this missed?  What is the recommended way to convert from `JsonElement` to `JsonNode`?\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>gregsdennis</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`area-System.Text.Json`, `untriaged`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2022-06-08T11:51:02Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "LAUGH",
                "createdAt": "2022-06-08T11:51:50Z",
                "user": "gregsdennis"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOCgzXCA=="
          },
          "updatedAt": "2022-06-08T11:51:02Z",
          "id": "IC_kwDODI9FZc5EiMgK"
        },
        {
          "author": "eiriktsarpalis",
          "body": "That functionality should be provided via the [`JsonValue.Create`](https://docs.microsoft.com/en-us/dotnet/api/system.text.json.nodes.jsonvalue.create?view=net-6.0#system-text-json-nodes-jsonvalue-create(system-text-json-jsonelement-system-nullable((system-text-json-nodes-jsonnodeoptions)))) methods. \r\n\r\nA note about the `dotnet/designs` repo is that it's meant to contain proposed designs rather than provide documentation for shipped products. As such it is often the case that the finally shipped product might diverge somewhat from the original design document. For conceptual documentation please refer to the `dotnet/docs` repo instead.",
          "createdAt": "2022-06-08T12:47:58Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-06-08T12:47:58Z",
          "id": "IC_kwDODI9FZc5EiaO_"
        },
        {
          "author": "gregsdennis",
          "body": "But that method returns a `JsonValue`, which only represents primitives.  What if the element is an object or array?\r\n\r\nI get this:\r\n\r\n```\r\nSystem.InvalidOperationException : The element cannot be an object or array.\r\n   at System.Text.Json.Nodes.JsonValue.VerifyJsonElementIsNotArrayOrObject(JsonElement& element)\r\n   at System.Text.Json.Nodes.JsonValue.Create(JsonElement value, Nullable`1 options)\r\n   at Json.Schema.Tests.DevTest.Test() in C:\\projects\\json-everything\\JsonSchema.Tests\\DevTest.cs:line 15\r\n```\r\n\r\n---\r\n\r\nIt appears that `JsonArray` and `JsonObject` also have creation methods.\r\n\r\nIs there not a single method that converts _any_ `JsonElement` into its appropriate `JsonNode` derivation?",
          "createdAt": "2022-06-09T04:17:39Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "HEART",
                "createdAt": "2024-12-04T13:13:07Z",
                "user": "JobaDiniz"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOD9h4tw=="
          },
          "updatedAt": "2022-06-09T04:24:51Z",
          "id": "IC_kwDODI9FZc5ElYn6"
        },
        {
          "author": "eiriktsarpalis",
          "body": "That's surprising, since `JsonValue` is generally capable of encapsulating arbitrary .NET values, e.g.\n```C#\nvar node = JsonValue.Create(new int[] { 1, 2, 3 });\nnode.ToJsonString(); // works as expected\n```\n\n> Is there not a single method that converts any JsonElement into its appropriate JsonNode derivation?\n\n@steveharter might know, if it doesn't we might consider adding a `Create` method to `JsonNode`. In the meantime it should be possible to synthesize a general-purpose converter using the existing methods:\n\n```C#\nstatic JsonNode? FromJsonElement(JsonElement element)\n{\n    return element.ValueKind switch\n    {\n        JsonValueKind.Null => null,\n        JsonValueKind.Array => JsonArray.Create(element),\n        JsonValueKind.Object => JsonObject.Create(element),\n        _ => JsonValue.Create(element)\n    };\n}\n```",
          "createdAt": "2022-06-09T10:39:32Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-01-04T17:48:22Z",
                "user": "deitry"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-06-07T02:11:06Z",
                "user": "cajuncoding"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-08-02T16:42:07Z",
                "user": "MattEdwardsWaggleBee"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-10-23T14:50:21Z",
                "user": "huoshan12345"
              }
            ],
            "totalCount": 4,
            "endCursor": "Y3Vyc29yOnYyOpHOD3vZpA=="
          },
          "updatedAt": "2024-10-24T10:26:52Z",
          "id": "IC_kwDODI9FZc5EmkLu"
        },
        {
          "author": "gregsdennis",
          "body": "The extension method is essentially what I've done for now.\n\nAlso, the code that produces that exception is\n\n```c#\nvar element = JsonDocument.Parse(\"[1,2,3]\").RootElement;\nvar node = JsonValue.Create(element);\n```",
          "createdAt": "2022-06-09T12:13:50Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-06-09T12:15:11Z",
          "id": "IC_kwDODI9FZc5Em42a"
        }
      ],
      "totalCount": 5,
      "endCursor": "Y3Vyc29yOnYyOpHORJuNmg=="
    },
    "url": "https://github.com/dotnet/runtime/issues/70427",
    "title": "[Question] Interop between JsonNode and JsonElement"
  },
  {
    "author": "aguacongas",
    "labels": [
      "enhancement",
      "area-System.Text.Json",
      "help wanted"
    ],
    "createdAt": "2022-06-10T07:39:48Z",
    "body": "### Description\r\n\r\n`JsonSerializer` throw the exception :\r\n> System.Text.Json.JsonException: 'The JSON value could not be converted to System.DateTime. Path: $ \r\n\r\nOn a date it serialize itself when the value is '0001-01-01T00:00:00+01:00'\r\n\r\n### Reproduction Steps\r\n\r\n* Set your time zone to **(UTC+01:00) Amsterdam, Berlin. Bern, Rome, Stockholm, Vienna**\r\n* Launch the test : \r\n```cs\r\n[Fact]\r\npublic void JsonSerializerIssue()\r\n{\r\n    var expected = new DateTime(1, 1, 1, 0, 0, 0, DateTimeKind.Local);\r\n    var serialized = JsonSerializer.Serialize(expected);\r\n    var result = JsonSerializer.Deserialize<DateTime>(serialized);\r\n\r\n    Assert.Equal(expected, result);\r\n}\r\n```\r\n\r\n### Expected behavior\r\n\r\nNo exception\r\n\r\n### Actual behavior\r\n\r\nThe exception \r\n> System.Text.Json.JsonException: 'The JSON value could not be converted to System.DateTime. Path: $ \r\n\r\nis thrown\r\n\r\n### Regression?\r\n\r\n_No response_\r\n\r\n### Known Workarounds\r\n\r\nWe can workaround with a `JsonConverter<DateTime>` but it's ugly and as the serialization do not throw an exception the deserialization should.\r\n\r\n```cs\r\nclass DateTimeConverterUsingDateTimeParse : JsonConverter<DateTime>\r\n{\r\n    public override DateTime Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)\r\n    {\r\n        throw new NotImplementedException();\r\n    }\r\n\r\n    public override void Write(Utf8JsonWriter writer, DateTime value, JsonSerializerOptions options)\r\n    {\r\n        writer.WriteStringValue(value.ToString(\"s\"));                \r\n    }\r\n}\r\n```\r\n\r\n\r\n### Configuration\r\n\r\n* Which version of .NET is the code running on? *netcoreapp3.1*\r\n* What OS and version, and what distro if applicable? *all, I guess*\r\n* What is the architecture (x64, x86, ARM, ARM64)? *x64*\r\n* Do you know whether it is specific to that configuration? *I don't think so*\r\n\r\n\r\n### Other information\r\n\r\n_No response_",
    "number": 70547,
    "reactions": {
      "hasNextPage": false,
      "nodes": [],
      "totalCount": 0,
      "endCursor": null
    },
    "updatedAt": "2022-06-10T15:21:10Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\n### Description\n\n`JsonSerializer` throw the exception :\r\n> System.Text.Json.JsonException: 'The JSON value could not be converted to System.DateTime. Path: $ \r\n\r\nOn a date it serialize itself when the value is '0001-01-01T00:00:00+01:00'\n\n### Reproduction Steps\n\n* Set your time zone to **(UTC+01:00) Amsterdam, Berlin. Bern, Rome, Stockholm, Vienna**\r\n* Launch the test : \r\n```cs\r\n[Fact]\r\npublic void JsonSerializerIssue()\r\n{\r\n    var expected = new DateTime(1, 1, 1, 0, 0, 0, DateTimeKind.Local);\r\n    var serialized = JsonSerializer.Serialize(expected);\r\n    var result = JsonSerializer.Deserialize<DateTime>(serialized);\r\n\r\n    Assert.Equal(expected, result);\r\n}\r\n```\n\n### Expected behavior\n\nNo exception\n\n### Actual behavior\n\nThe exeption \r\n> System.Text.Json.JsonException: 'The JSON value could not be converted to System.DateTime. Path: $ \r\nis thrown\n\n### Regression?\n\n_No response_\n\n### Known Workarounds\n\nWe can workaround with a `JsonConverter<DateTime>` but it's ugly and as the serialization do not throw an exception the deserialization should not as well\r\n\r\n```cs\r\nclass DateTimeConverterUsingDateTimeParse : JsonConverter<DateTime>\r\n{\r\n    public override DateTime Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)\r\n    {\r\n        throw new NotImplementedException();\r\n    }\r\n\r\n    public override void Write(Utf8JsonWriter writer, DateTime value, JsonSerializerOptions options)\r\n    {\r\n        writer.WriteStringValue(value.ToString(\"s\"));                \r\n    }\r\n}\r\n```\r\n\n\n### Configuration\n\n* Which version of .NET is the code running on? *netcoreapp3.1*\r\n* What OS and version, and what distro if applicable? *all, I guess*\r\n* What is the architecture (x64, x86, ARM, ARM64)? *x64*\r\n* Do you know whether it is specific to that configuration? *I don't think so*\r\n\n\n### Other information\n\n_No response_\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>aguacongas</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`area-System.Text.Json`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2022-06-10T07:39:56Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-06-10T07:39:56Z",
          "id": "IC_kwDODI9FZc5EqyrW"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Fundamentally, I think the issue is that `0001-01-01T00:00:00+01:00` is an invalid ISO-8601 date/time string. If I try to parse it using `DateTimeOffset.Parse` I get the following error:\r\n```\r\nThe UTC representation of the date '0001-01-01T00:00:00+01:00' falls outside the year range 1-9999.\r\n```\r\nAnd the same error surfaces if I try to convert you `DateTime` value to `DateTimeOffset`. I think the problem lies with the serializer, given that it serializes using ISO-8601 it should simply reject that particular value.\r\n\r\ncc @tarekgh ",
          "createdAt": "2022-06-10T13:10:24Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-06-10T13:10:24Z",
          "id": "IC_kwDODI9FZc5Er2H2"
        },
        {
          "author": "Clockwork-Muse",
          "body": ">  is an invalid ISO-8601 date/time string.\r\n\r\nnit: it's a valid date/time string, it's just outside the range supported by `DateTime`\r\n\r\nThat aside, if you're attempting to create an invalid date for \"not a value\"/\"not passed\" semantics, you should be passing `null`, or a UTC timestamp, not one with an offset.  (That's beside the question of whether you should be using `DateTime` at all, instead of `DateTimeOffset` or NodaTime, but that's a more involved analysis)",
          "createdAt": "2022-06-10T15:21:10Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-06-10T16:15:30Z",
                "user": "tarekgh"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-11-02T20:43:06Z",
                "user": "timschneeb"
              }
            ],
            "totalCount": 2,
            "endCursor": "Y3Vyc29yOnYyOpHOD5LTOw=="
          },
          "updatedAt": "2022-06-10T15:21:10Z",
          "id": "IC_kwDODI9FZc5EsWHn"
        }
      ],
      "totalCount": 3,
      "endCursor": "Y3Vyc29yOnYyOpHORLFh5w=="
    },
    "url": "https://github.com/dotnet/runtime/issues/70547",
    "title": "JsonSerializer does not support parsing DateTime value '0001-01-01T00:00:00+01:00'"
  },
  {
    "author": "stevejgordon",
    "labels": [
      "api-suggestion",
      "area-System.Text.Json"
    ],
    "createdAt": "2022-07-06T16:04:17Z",
    "body": "### Background and motivation\r\n\r\nWhile working on a [client library for Elasticsearch](https://github.com/elastic/elasticsearch-net), making heavy use of System.Text.Json, a common issue I have run into is the need to access some additional state inside custom converters. The Elasticsearch client has a settings class `ElasticsearchClientSettings` which includes state used to infer values for certain types at runtime. \r\n\r\nCurrently, this forces an instance of each converter which requires access to the settings to be created in advance and added to the `JsonSerializerOptions` **([example](https://github.com/elastic/elasticsearch-net/blob/main/src/Elastic.Clients.Elasticsearch/Serialization/DefaultRequestResponseSerializer.cs#L38)).** These converters can then accept an `ElasticsearchClientSettings` instance via their constructor. Some of these instances may never be needed if the types they (de)serialize are not used by consumers of our library. Additionally, we have some converters which we code generate which makes creating such instances and adding them to the `JsonSerializerOptions` more complicated.\r\n\r\nI have come up with a rather nasty workaround where I register a converter purely to hold state, which can then be retrieved from the options to gain access to the settings.\r\n\r\n```c#\r\ninternal sealed class ExtraSerializationData : JsonConverter<ExtraSerializationData>\r\n{\r\n    public ExtraSerializationData(IElasticsearchClientSettings settings) => Settings = settings;\r\n\r\n    public IElasticsearchClientSettings Settings { get; }\r\n\r\n    public override ExtraSerializationData? Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();\r\n    public override void Write(Utf8JsonWriter writer, ExtraSerializationData value, JsonSerializerOptions options) => throw new NotImplementedException();\r\n}\r\n```\r\n\r\nThis can then be accessed in the `Write` method of a custom converter:\r\n\r\n```c#\r\npublic override void Write(Utf8JsonWriter writer, SortOptions value, JsonSerializerOptions options)\r\n{\r\n    writer.WriteStartObject();\r\n\r\n    if (value.AdditionalPropertyName is IUrlParameter urlParameter)\r\n    {\r\n        var extraData = options.GetConverter(typeof(ExtraSerializationData)) as ExtraSerializationData;\r\n        var propertyName = urlParameter.GetString(extraData.Settings);\r\n        writer.WritePropertyName(propertyName);\r\n    }\r\n    else\r\n    {\r\n        throw new JsonException();\r\n    }\r\n    \r\n    JsonSerializer.Serialize(writer, value.Variant, value.Variant.GetType(), options);\r\n    writer.WriteEndObject();\r\n}\r\n```\r\n\r\n### API Proposal\r\n\r\nI would like to propose adding support to attach extra custom data (a property bag) to `JsonSerializerOptions`, to be accessible inside the `Read` and `Write` methods of custom converters derived from `JsonConveter<T>` by accessing the `JsonSerializerOptions`.\r\n\r\n```c#\r\npublic sealed class JsonSerializerOptions\r\n{\r\n    public IReadOnlyDictionary<string, object> CustomData { get; set; } = new Dictionary<string, object>(0); // some cached default empty value\r\n}\r\n```\r\n\r\nThis adds a property to act as a property bag for user-provided data. I'm proposing this be exposed as `IReadOnlyDictionary` to avoid new items being added/modified after the options become immutable. It could be `IDictionary` to support scenarios where some converters need to add data for subsequent use, although that sounds risky. I imagine this should be initialised with a cached empty dictionary in cases where the user does not explicitly set this.\r\n\r\n### API Usage\r\n\r\nDefine options with custom data:\r\n\r\n```c#\r\nvar options = new JsonSerializerOptions\r\n{\r\n    CustomData = new Dictionary<string, object> {{ \"settings\", new Settings() }} \r\n}\r\n\r\n```\r\n\r\nAccess within a custom converter:\r\n\r\n```c#\r\npublic override void Write(Utf8JsonWriter writer, SortOptions value, JsonSerializerOptions options)\r\n{\r\n    writer.WriteStartObject();\r\n\r\n    if (value.AdditionalPropertyName is IUrlParameter urlParameter && options.CustomData.TryGetValue(\"settings\", out var settings))\r\n    {\r\n        var propertyName = urlParameter.GetString(settings);\r\n        writer.WritePropertyName(propertyName);\r\n    }\r\n    else\r\n    {\r\n        throw new JsonException();\r\n    }\r\n    \r\n    JsonSerializer.Serialize(writer, value.Variant, value.Variant.GetType(), options);\r\n    writer.WriteEndObject();\r\n}\r\n\r\n```\r\n\r\n### Alternative Designs\r\n\r\nIf the `JsonSerializerOptions` were unsealed, that could also support my scenario. We could define a subclass of `JsonSerializerOptions` with extra properties. Inside our converters that require that data, they could try casting to the derived type and access any necessary extra properties.\r\n\r\n```diff\r\n- public sealed class JsonSerializerOptions\r\n+ public class JsonSerializerOptions\r\n{\r\n}\r\n```\r\n\r\n### Risks\r\n\r\nThis could potentially be misused to hold mutable types which could cause thread-safety issues. Documentation could be added to guide the intended usage.",
    "number": 71718,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "ROCKET",
          "createdAt": "2022-07-06T16:08:26Z",
          "user": "sethmlarson"
        },
        {
          "content": "ROCKET",
          "createdAt": "2022-07-06T16:55:52Z",
          "user": "Mpdreamz"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-07-08T06:04:18Z",
          "user": "gregsdennis"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-02-07T12:42:30Z",
          "user": "alex-jitbit"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-05-31T09:40:41Z",
          "user": "andrewjsaid"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-12-16T17:18:31Z",
          "user": "tecAmoRaller"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-09-04T08:16:20Z",
          "user": "austinw-fineart"
        }
      ],
      "totalCount": 7,
      "endCursor": "Y3Vyc29yOnYyOpHODOWOMg=="
    },
    "updatedAt": "2023-11-13T16:49:59Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\n### Background and motivation\n\nWhile working on a [client library for Elasticsearch](https://github.com/elastic/elasticsearch-net), making heavy use of System.Text.Json, a common issue I have run into is the need to access some additional state inside custom converters. The Elasticsearch client has a settings class `ElasticsearchClientSettings` which includes state used to infer values for certain types at runtime. \r\n\r\nCurrently, this forces an instance of each converter which requires access to the settings to be created in advance and added to the `JsonSerializerOptions` **([example](https://github.com/elastic/elasticsearch-net/blob/main/src/Elastic.Clients.Elasticsearch/Serialization/DefaultRequestResponseSerializer.cs#L38)).** These converters can then accept an `ElasticsearchClientSettings` instance via their constructor. Some of these instances may never be needed if the types they (de)serialize are not used by consumers of our library. Additionally, we have some converters which we code generate which makes creating such instances and adding them to the `JsonSerializerOptions` more complicated.\r\n\r\nI have come up with a rather nasty workaround where I register a converter purely to hold state, which can then be retrieved from the options to gain access to the settings.\r\n\r\n```c#\r\ninternal sealed class ExtraSerializationData : JsonConverter<ExtraSerializationData>\r\n{\r\n\tpublic ExtraSerializationData(IElasticsearchClientSettings settings) => Settings = settings;\r\n\r\n\tpublic IElasticsearchClientSettings Settings { get; }\r\n\r\n\tpublic override ExtraSerializationData? Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => throw new NotImplementedException();\r\n\tpublic override void Write(Utf8JsonWriter writer, ExtraSerializationData value, JsonSerializerOptions options) => throw new NotImplementedException();\r\n}\r\n```\r\n\r\nThis can then be accessed in the `Write` method of a custom converter:\r\n\r\n```c#\r\npublic override void Write(Utf8JsonWriter writer, SortOptions value, JsonSerializerOptions options)\r\n{\r\n    writer.WriteStartObject();\r\n\r\n    if (value.AdditionalPropertyName is IUrlParameter urlParameter)\r\n    {\r\n        var extraData = options.GetConverter(typeof(ExtraSerializationData)) as ExtraSerializationData;\r\n        var propertyName = urlParameter.GetString(extraData.Settings);\r\n        writer.WritePropertyName(propertyName);\r\n    }\r\n    else\r\n    {\r\n        throw new JsonException();\r\n    }\r\n    \r\n    JsonSerializer.Serialize(writer, value.Variant, value.Variant.GetType(), options);\r\n    writer.WriteEndObject();\r\n}\r\n```\n\n### API Proposal\n\nI would like to propose adding support to attach extra custom data (a property bag) to `JsonSerializerOptions`, to be accessible inside the `Read` and `Write` methods of custom converters derived from `JsonConveter<T>` by accessing the `JsonSerializerOptions`.\r\n\r\n```c#\r\npublic sealed class JsonSerializerOptions\r\n{\r\n    public IReadOnlyDictionary<string, object> CustomData { get; set; } = new Dictionary<string, object>(0); // some cached default empty value\r\n}\r\n```\r\n\r\nThis adds a property to act as a property bag for user-provided data. I'm proposing this be exposed as `IReadOnlyDictionary` to avoid new items being added/modified after the options become immutable. It could be `IDictionary` to support scenarios where some converters need to add data for subsequent use, although that sounds risky. I imagine this should be initialised with a cached empty dictionary in cases where the user does not explicitly set this.\n\n### API Usage\n\nDefine options with custom data:\r\n\r\n```c#\r\nvar options = new JsonSerializerOptions\r\n{\r\n    CustomData = new Dictionary<string, object> {{ \"settings\", new Settings() }} \r\n}\r\n\r\n```\r\n\r\nAccess within a custom converter:\r\n\r\n```c#\r\npublic override void Write(Utf8JsonWriter writer, SortOptions value, JsonSerializerOptions options)\r\n{\r\n    writer.WriteStartObject();\r\n\r\n    if (value.AdditionalPropertyName is IUrlParameter urlParameter && options.CustomData.TryGetValue(\"settings\", out var settings))\r\n    {\r\n        var propertyName = urlParameter.GetString(settings);\r\n        writer.WritePropertyName(propertyName);\r\n    }\r\n    else\r\n    {\r\n        throw new JsonException();\r\n    }\r\n    \r\n    JsonSerializer.Serialize(writer, value.Variant, value.Variant.GetType(), options);\r\n    writer.WriteEndObject();\r\n}\r\n\r\n```\n\n### Alternative Designs\n\n## Alternative Design\r\n\r\nIf the `JsonSerializerOptions` were unsealed, that could also support my scenario. We could define a subclass of `JsonSerializerOptions` with extra properties. Inside our converters that require that data, they could try casting to the derived type and access any necessary extra properties.\n\n### Risks\n\nThis could potentially be misused to hold mutable types which could cause thread-safety issues. Documentation could be added to guide the intended usage.\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>stevejgordon</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`api-suggestion`, `area-System.Text.Json`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2022-07-06T16:04:30Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-07-06T16:04:30Z",
          "id": "IC_kwDODI9FZc5GHopr"
        },
        {
          "author": "eiriktsarpalis",
          "body": "It's a reasonable requirement, but I don't think `JsonSerializerOptions` is the right type to attach state scoped to a particular serialization operation. As I think you're already pointing out, `JsonSerializerOptions` is meant as a singleton configuration/caching context, as such attaching state there would make it susceptible to race conditions (or encourage the anti-pattern of creating a new options instance per serialization operation).\r\n\r\nRelated to https://github.com/dotnet/runtime/issues/63795, we've been thinking about exposing async converter primitives which would also involve exposing the internal `WriteState`/`ReadState` types. It should be possible to let users attach custom state to these types a la `StreamingContext`.",
          "createdAt": "2022-07-06T16:42:03Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-02-24T15:23:27Z",
                "user": "airbreather"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHODYEt8Q=="
          },
          "updatedAt": "2022-07-06T16:42:03Z",
          "id": "IC_kwDODI9FZc5GHxim"
        },
        {
          "author": "stevejgordon",
          "body": "Thanks for the feedback @eiriktsarpalis. To be clear, in our use case, our `ElasticsearchClientSettings` are also immutable and required across many converters for many serialization operations for the lifetime of a client instance (which is reused for the life of consumer apps). We create and use a single instance of `JsonSerializerOptions`. \r\n\r\nThere's already potential for misuse if developers create new instances of the options per serialization operation. I'm not sure this promotes that much more for the common scenario of attaching additional context needed for many/all serialization in converters.\r\n\r\nI'll have to dig into the proposal for async converters to understand if custom state there would meet our need. Would we replace the existing converters with async ones? Would those apply to all scenarios, even synchronous serializer methods?",
          "createdAt": "2022-07-07T08:22:03Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-07-07T08:22:03Z",
          "id": "IC_kwDODI9FZc5GK0ed"
        },
        {
          "author": "eiriktsarpalis",
          "body": "> Would we replace the existing converters with async ones?\r\n\r\nIt would most likely involve exposing a couple of virtual methods in `JsonConverter<T>` that are currently marked internal. We haven't produced any prototypes yet, so that plan might be subject to change.\r\n\r\n> Would those apply to all scenarios, even synchronous serializer methods?\r\n\r\nYes, the converter methods that pass serialization state are used in both synchronous and asynchronous serialization. It just happens that async converters are implemented by passing their state machines via the serialization state objects.",
          "createdAt": "2022-07-07T11:22:34Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-07-07T11:22:50Z",
          "id": "IC_kwDODI9FZc5GLnX_"
        },
        {
          "author": "davidfowl",
          "body": "> It should be possible to let users attach custom state to these types a la StreamingContext.\r\n\r\nDo you have an example of what this would look like?",
          "createdAt": "2022-07-07T12:50:28Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-07-07T12:50:28Z",
          "id": "IC_kwDODI9FZc5GMC1l"
        },
        {
          "author": "eiriktsarpalis",
          "body": "> Do you have an example of what this would look like?\r\n\r\nFeature needs prototyping before we can propose something concrete, but _roughly speaking_ it might look as follows:\r\n```C#\r\nvar writer = new Utf8JsonWriter();\r\nvar state = new WriteState { UserState = new MyState() };\r\nstring json = JsonSerializer.Serialize(writer, new Foo(), ref state);\r\n\r\npublic class MyConverter : JsonResumableConverter<Foo>\r\n{\r\n    public bool TryWrite(Utf8JsonWriter writer, Foo value,  JsonSerializerOptions options, ref WriteState state)\r\n    {\r\n         var myState = (MyState)state.UserState;\r\n         /* serialization logic using state */\r\n    }\r\n}\r\n```\r\nwhere `JsonResumableConverter<T>` would be roughly equivalent to the [existing internal class of the same name](https://github.com/dotnet/runtime/blob/main/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/JsonResumableConverterOfT.cs).",
          "createdAt": "2022-07-07T13:51:25Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-07-07T13:53:12Z",
          "id": "IC_kwDODI9FZc5GMYBj"
        },
        {
          "author": "davidfowl",
          "body": "What happens when you don't control the callsite responsible for calling Serialize/Deserailize (like when using a framework)? Attaching this to options seems like the logical place since it:\r\n- Already flows everywhere\r\n- Is user defined options state for these calls.",
          "createdAt": "2022-07-07T15:53:35Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-10-19T01:32:19Z",
                "user": "thomaslevesque"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOCuFGJA=="
          },
          "updatedAt": "2022-07-07T15:53:35Z",
          "id": "IC_kwDODI9FZc5GNFof"
        },
        {
          "author": "eiriktsarpalis",
          "body": "That might be an option, although given the nature of `JsonSerializerOptions` I would guess a factory (i.e. `Func<object>`) might be more appropriate. It would still be less flexible than an argument being passed to serialization methods directly though.",
          "createdAt": "2022-07-07T16:10:58Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-07-07T16:10:58Z",
          "id": "IC_kwDODI9FZc5GNNmN"
        },
        {
          "author": "eiriktsarpalis",
          "body": "@stevejgordon in the meantime, have you considered using a `ConditionalWeakTable` to dynamically attach data to options instances? ",
          "createdAt": "2022-07-07T16:14:13Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-07-07T16:14:13Z",
          "id": "IC_kwDODI9FZc5GNOx0"
        },
        {
          "author": "gregsdennis",
          "body": "I've often wanted the inheritance model, using `JsonSerializerOptions` as a base class.",
          "createdAt": "2022-07-08T06:04:09Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-07-08T06:04:09Z",
          "id": "IC_kwDODI9FZc5GP9j4"
        },
        {
          "author": "stevejgordon",
          "body": "@eiriktsarpalis I hadn't considered that, only because I was completely unaware of its existence! :-) Looks like it could work for our requirement based on a small sample I put together this morning. Is this essentially how you'd expect a solution to look in such a case?\r\n\r\n```c#\r\nusing System.Runtime.CompilerServices;\r\nusing System.Text.Json;\r\nusing System.Text.Json.Serialization;\r\nusing Test;\r\n\r\nvar clientOne = new Client(new ClientSettings { Value = 1 });\r\nvar clientTwo = new Client(new ClientSettings { Value = 2 });\r\n\r\nvar data = new MyTypeToSerialize { Name = \"Test\" };\r\n\r\nvar resultOne = clientOne.Serializer.Serialize(data);\r\nvar resultTwo = clientTwo.Serializer.Serialize(data);\r\n\r\nConsole.WriteLine(resultOne);\r\nConsole.WriteLine(resultTwo);\r\nConsole.ReadKey();\r\n\r\nnamespace Test\r\n{\r\n    public class Client\r\n    {\r\n        internal static ConditionalWeakTable<JsonSerializerOptions, ClientSettings> SettingsTable { get; } = new();\r\n\r\n        public Client(ClientSettings settings)\r\n        {\r\n            Settings = settings;\r\n            Serializer = new MySerializer();\r\n            SettingsTable.Add(Serializer.Options, Settings);\r\n        }\r\n\r\n        public ClientSettings Settings { get; }\r\n        public MySerializer Serializer { get; }\r\n    }\r\n\r\n    public class ClientSettings\r\n    {\r\n        public int Value { get; init; }\r\n    }\r\n\r\n    public class MySerializer\r\n    {\r\n        public MySerializer() => Options = new JsonSerializerOptions();\r\n\r\n        public JsonSerializerOptions Options { get; }\r\n\r\n        public string Serialize<T>(T value) => JsonSerializer.Serialize(value, Options);\r\n    }\r\n\r\n    [JsonConverter(typeof(MyTypeToSerializeConverter))]\r\n    public class MyTypeToSerialize\r\n    {\r\n        public string? Name { get; set; }\r\n    }\r\n\r\n    internal sealed class MyTypeToSerializeConverter : JsonConverter<MyTypeToSerialize>\r\n    {\r\n        public override MyTypeToSerialize? Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => \r\n            throw new NotImplementedException();\r\n\r\n        public override void Write(Utf8JsonWriter writer, MyTypeToSerialize value, JsonSerializerOptions options)\r\n        {\r\n            writer.WriteStartObject();\r\n            writer.WritePropertyName(\"name\");\r\n            writer.WriteStringValue(value.Name ?? string.Empty);\r\n\r\n            if (Client.SettingsTable.TryGetValue(options, out var settings))\r\n            {\r\n                writer.WritePropertyName(\"settingsValue\");\r\n                writer.WriteNumberValue(settings.Value);\r\n            }\r\n\r\n            writer.WriteEndObject();\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nOutput:\r\n```\r\n{\"name\":\"Test\",\"settingsValue\":1}\r\n{\"name\":\"Test\",\"settingsValue\":2}\r\n```",
          "createdAt": "2022-07-08T06:47:18Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-07-08T06:48:24Z",
          "id": "IC_kwDODI9FZc5GQEp9"
        },
        {
          "author": "eiriktsarpalis",
          "body": "That's it more or less. I would probably also hide some of the implementation details behind extension methods:\r\n```C#\r\n    public static class Client\r\n    {\r\n        private static ConditionalWeakTable<JsonSerializerOptions, ClientSettings> SettingsTable { get; } = new();\r\n\r\n        public static ClientSettings? GetClientSettings(this JsonSerializerOptions options)\r\n             => SettingsTable.TryGetValue(options, out var settings) ? settings : null;\r\n\r\n        public static void SetClientSettings(this JsonSerializerOptions options, ClientSettings value) => SettingsTable.Add(options, value);\r\n    }\r\n```",
          "createdAt": "2022-07-08T11:01:44Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-07-08T11:16:30Z",
                "user": "stevejgordon"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOClyDrw=="
          },
          "updatedAt": "2022-07-08T11:01:44Z",
          "id": "IC_kwDODI9FZc5GQ-Xd"
        },
        {
          "author": "stevejgordon",
          "body": "Cool, thanks for the suggestion @eiriktsarpalis. Our client can't be static though. I'll likely switch to something based on `ConditionalWeakTable` because it's nicer than the hack I've done so far. I still think this proposal or one of the alternatives on the table would be useful as `ConditionalWeakTable` is certainly not an obvious workaround. This is a good candidate for my next blog post!",
          "createdAt": "2022-07-08T11:19:00Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "HEART",
                "createdAt": "2022-07-08T11:23:27Z",
                "user": "eiriktsarpalis"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOClyHIA=="
          },
          "updatedAt": "2022-07-08T13:49:07Z",
          "id": "IC_kwDODI9FZc5GRCMp"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Related to https://github.com/dotnet/runtime/issues/59892#issue-1014003992. While the callback interfaces do not handle state, we might want to consider extending the callbacks in the contract model so that any user-defined state can be handled appropriately.",
          "createdAt": "2022-07-19T12:18:57Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-07-19T12:18:57Z",
          "id": "IC_kwDODI9FZc5G3m2C"
        },
        {
          "author": "krwq",
          "body": "Closing this in favor of #63795",
          "createdAt": "2022-09-28T16:18:50Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-09-28T16:18:50Z",
          "id": "IC_kwDODI9FZc5LK5P0"
        },
        {
          "author": "stevejgordon",
          "body": "@eiriktsarpalis Finally completed [the blog post](https://twitter.com/stevejgordon/status/1582349217497915392) which describes the path to the final solution for my use case.",
          "createdAt": "2022-10-18T12:35:14Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "HEART",
                "createdAt": "2022-10-18T12:45:41Z",
                "user": "eiriktsarpalis"
              },
              {
                "content": "HEART",
                "createdAt": "2022-10-18T17:22:48Z",
                "user": "KoalaBear84"
              }
            ],
            "totalCount": 2,
            "endCursor": "Y3Vyc29yOnYyOpHOCuDsEg=="
          },
          "updatedAt": "2022-10-18T12:35:14Z",
          "id": "IC_kwDODI9FZc5MbpAG"
        },
        {
          "author": "thomaslevesque",
          "body": "Related: #34773",
          "createdAt": "2022-10-18T19:48:23Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-10-18T19:48:23Z",
          "id": "IC_kwDODI9FZc5Md9f7"
        },
        {
          "author": "thomaslevesque",
          "body": "> Closing this in favor of #63795\r\n\r\nI don't think #63795 addresses the requirements described in this issue, as explained in [this comment](https://github.com/dotnet/runtime/issues/63795#issuecomment-1283258304).\r\n\r\n> It's a reasonable requirement, but I don't think JsonSerializerOptions is the right type to attach state scoped to a particular serialization operation.\r\n\r\nMaybe not for a particular serialization operation, but what about \"all serialization operations using this JsonSerializationOptions instance\"? That's a legitimate use case, and currently the only ways to do it are cumbersome, to say the least (see @stevejgordon's [blog post](https://www.stevejgordon.co.uk/accessing-state-in-system-text-json-custom-converters), or [mine](https://thomaslevesque.com/2020/08/31/inject-service-into-system-text-json-converter/)). The `ConditionalWeakTable` approach is a bit better, but still arguably a hack...",
          "createdAt": "2022-10-19T01:42:22Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-10-19T08:20:00Z",
                "user": "stevejgordon"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOCuGONQ=="
          },
          "updatedAt": "2022-10-19T01:42:38Z",
          "id": "IC_kwDODI9FZc5MfQwe"
        },
        {
          "author": "eiriktsarpalis",
          "body": "@thomaslevesque thanks, I hadn't read your article before. It seems like the primary use case preventing you from injecting state directly to converters is `JsonConverterAttribute` annotations? Is there anything else I'm missing? \r\n\r\nI would guess that unsealing `JsonSerializerOptions` would not address your use case, so presumably something like the following would work?\r\n```C#\r\npublic class JsonSerializerOptions\r\n{\r\n    public object? UserData { get; set; } // As with other options properties, gets locked once used\r\n}\r\n```\r\nThis should work fine assuming the app author owns all custom converters, but we might want to consider a design where multiple converter designs interoperate:\r\n```C#\r\npublic class JsonSerializerOptions\r\n{\r\n    public IDictionary<string, object?> UserData { get; } // As with other options properties, gets locked once used\r\n}\r\n```",
          "createdAt": "2022-10-19T08:10:07Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-10-19T08:10:07Z",
          "id": "IC_kwDODI9FZc5MgjsT"
        },
        {
          "author": "eiriktsarpalis",
          "body": "@stevejgordon you might want to consider using a `JsonConverterFactory` in your examples to avoid the overhead of `ConditionalWeakTable` lookup on every serialization operation:\r\n```C#\r\ninternal sealed class WildcardQueryConverter : JsonConverterFactory\r\n{\r\n     public override bool CanConvert(Type type) => type == typeof(WildcardQuery);\r\n     public override JsonConverter? CreateConverter(Type type, JsonSerializerOptions options)\r\n     {\r\n           options.TryGetClientSettings(out var settings);\r\n           // same implementation as the original converter accepting `settings` parametrically\r\n           // the new instance is scoped to the current `JsonSerializerOptions` so it is safe to hardcode.\r\n           return new WildcardQueryConverterImplementation(settings);\r\n     }\r\n}\r\n```",
          "createdAt": "2022-10-19T08:21:15Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-10-19T12:45:01Z",
                "user": "thomaslevesque"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOCuHTdQ=="
          },
          "updatedAt": "2022-10-19T08:21:15Z",
          "id": "IC_kwDODI9FZc5MgnC9"
        },
        {
          "author": "stevejgordon",
          "body": "@eiriktsarpalis That's a good shout, thanks. I will review how easy that is to achieve with our code-gen.",
          "createdAt": "2022-10-19T09:52:30Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-10-19T09:52:30Z",
          "id": "IC_kwDODI9FZc5MhDiZ"
        },
        {
          "author": "thomaslevesque",
          "body": "Thanks for your reply @eiriktsarpalis!\r\n\r\n> It seems like the primary use case preventing you from injecting state directly to converters is `JsonConverterAttribute` annotations?\r\n\r\nIn this case, yes. I can't just add the converter to the `JsonSerializerOptions`, because it would then apply to all compatible types; I only want to apply it to some properties. And in that scenario, I don't control the converter's instantiation, so I can't inject state or services into it.\r\n\r\n> I would guess that unsealing JsonSerializerOptions would not address your use case\r\n\r\nNo, because I don't control the instantiation of the `JsonSerializerOptions` (at least in ASP.NET Core).\r\n\r\n> so presumably something like the following would work?\r\n> \r\n> ```\r\n> public class JsonSerializerOptions\r\n> {\r\n>     public object? UserData { get; set; } // As with other options properties, gets locked once used\r\n> }\r\n> ```\r\n\r\nIt's not perfect, but it would work. Your next suggestion with a property bag is probably better.",
          "createdAt": "2022-10-19T12:47:03Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-10-19T12:47:03Z",
          "id": "IC_kwDODI9FZc5Mh7EG"
        },
        {
          "author": "stratdev3",
          "body": "Interesting thread as it represents the long waiting option before i can fully remove the `Newtonsoft` package.\r\n\r\n**My use case** : i want to modify some information depending context. Example : hide emails for non essentials partners.\r\n\r\n### Newtonsoft\r\n\r\n`Newtonsoft` support the `OnSerializing` attribute with a context passed into the `SerializeObject` settings.\r\n\r\nsample code (copy/paste to [roslynpad](https://roslynpad.net/))\r\n\r\n```c#\r\n#r \"nuget:Newtonsoft.Json/13.0.3\"\r\n\r\nusing System.Runtime.Serialization;\r\nusing Newtonsoft.Json;\r\n\r\nvar user = new User() {\r\n    usr_mail = \"login@domain.tld\",\r\n    usr_nickname = \"nickname\"\r\n};\r\n\r\nvar context = \"GDPR\"; // pass serialization context\r\nvar settings = new JsonSerializerSettings {\r\n    Context = new StreamingContext(StreamingContextStates.Other, context)\r\n};\r\nJsonConvert.SerializeObject(user, settings).Dump();\r\n// {\"usr_mail\":null,\"usr_nickname\":\"nickname\"}\r\n\r\n\r\npublic class User {\r\n\r\n    public string usr_mail { get; set; }\r\n    public string usr_nickname { get; set; }\r\n\r\n    [OnSerializing]\r\n    internal void OnSerializedMethod(StreamingContext context) {\r\n        // retrieve serialization context and do stuff\r\n        if (context.Context is string ctx && ctx == \"GDPR\") {\r\n            usr_mail = null;\r\n        }\r\n    }\r\n\r\n}\r\n```\r\n\r\n### System.Text.Json\r\n\r\nThe current best effort is in NET7 : i can hide same field but not depending the context as i does not exist.\r\n\r\nsample code (copy/paste to [roslynpad](https://roslynpad.net/))\r\n\r\n```c#\r\n#r \"nuget: System.Text.Json, 7.0.3\"\r\n\r\nusing System.Runtime.Serialization;\r\nusing System.Text.Json.Serialization;\r\nusing System.Text.Json;\r\n\r\nvar user = new User() {\r\n    usr_mail = \"login@domain.tld\",\r\n    usr_nickname = \"nickname\"\r\n};\r\n\r\nJsonSerializer.Serialize(user).Dump();\r\n// {\"usr_mail\":null,\"usr_nickname\":\"nickname\"}\r\n\r\n\r\npublic class User : IJsonOnSerializing {\r\n\r\n    public string usr_mail { get; set; }\r\n    public string usr_nickname { get; set; }\r\n\r\n    void IJsonOnSerializing.OnSerializing() {\r\n        usr_mail = null;\r\n    }\r\n\r\n}\r\n```\r\n\r\nIf some of you have a workaround, i will appreciate 😀\r\n",
          "createdAt": "2023-11-13T16:45:59Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-12-16T17:18:18Z",
                "user": "tecAmoRaller"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOD_Mifg=="
          },
          "updatedAt": "2023-11-13T16:49:59Z",
          "id": "IC_kwDODI9FZc5rzDJ9"
        }
      ],
      "totalCount": 23,
      "endCursor": "Y3Vyc29yOnYyOpHOa8wyfQ=="
    },
    "url": "https://github.com/dotnet/runtime/issues/71718",
    "title": "[API Proposal]: Support Custom Data on `JsonSerializerOptions`"
  },
  {
    "author": "gregsdennis",
    "labels": [
      "bug",
      "area-System.Text.Json",
      "help wanted"
    ],
    "createdAt": "2022-07-07T21:39:27Z",
    "body": "### Description\n\nCurrently, when a parsed JSON object has duplicate keys, an `ArguementException` is thrown from the underlying dictionary implementation.  I would expect this to be thrown if I were manually attempting to add an existing key, but not from parsing.\n\n### Reproduction Steps\n\n```c#\r\nvar json = JsonNode.Parse(\"[{\\\"foo\\\":1, \\\"bar\\\":2, \\\"foo\\\":3}]\") as JsonArray;\r\n\r\nvar item = json[0][\"bar\"];\r\n```\n\n### Expected behavior\n\nMaybe throw `JsonException`?\n\n### Actual behavior\n\n`ArgumentException` is thrown.  Stack trace:\r\n\r\n```\r\nSystem.ArgumentException : An item with the same key has already been added. Key: {0} (Parameter 'foo')\r\n   at System.Text.Json.ThrowHelper.ThrowArgumentException_DuplicateKey(String propertyName)\r\n   at System.Text.Json.JsonPropertyDictionary`1.AddValue(String propertyName, T value)\r\n   at System.Text.Json.JsonPropertyDictionary`1.Add(String propertyName, T value)\r\n   at System.Text.Json.Nodes.JsonObject.InitializeIfRequired()\r\n   at System.Text.Json.Nodes.JsonObject.System.Collections.Generic.IDictionary<System.String,System.Text.Json.Nodes.JsonNode>.TryGetValue(String propertyName, JsonNode& jsonNode)\r\n   at System.Text.Json.Nodes.JsonObject.TryGetPropertyValue(String propertyName, JsonNode& jsonNode)\r\n   at System.Text.Json.Nodes.JsonObject.GetItem(String propertyName)\r\n   at System.Text.Json.Nodes.JsonNode.get_Item(String propertyName)\r\n```\n\n### Regression?\n\n_No response_\n\n### Known Workarounds\n\n_No response_\n\n### Configuration\n\nSeen in all released versions (.Net 6 and previous)\n\n### Other information\n\n_No response_",
    "number": 71784,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-07-12T09:47:43Z",
          "user": "krwq"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-09-27T14:52:39Z",
          "user": "AigioL"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-05-11T18:29:17Z",
          "user": "RFlipper"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-01-01T06:48:15Z",
          "user": "asklar"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-08-21T13:02:03Z",
          "user": "leonardo-gooten"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-09-03T15:42:06Z",
          "user": "verdie-g"
        }
      ],
      "totalCount": 6,
      "endCursor": "Y3Vyc29yOnYyOpHODOLpKg=="
    },
    "updatedAt": "2024-01-08T09:53:01Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\n### Description\n\nCurrently, when a parsed JSON object has duplicate keys, an `ArguementException` is thrown from the underlying dictionary implementation.  I would expect this to be thrown if I were manually attempting to add an existing key, but not from parsing.\n\n### Reproduction Steps\n\n```c#\r\nvar json = JsonNode.Parse(\"[{\\\"foo\\\":1, \\\"bar\\\":2, \\\"foo\\\":3}]\") as JsonArray;\r\n\r\nvar item = json[0][\"bar\"];\r\n```\n\n### Expected behavior\n\nMaybe throw `JsonException`?\n\n### Actual behavior\n\n`ArgumentException` is thrown.  Stack trace:\r\n\r\n```\r\nSystem.ArgumentException : An item with the same key has already been added. Key: {0} (Parameter 'foo')\r\n   at System.Text.Json.ThrowHelper.ThrowArgumentException_DuplicateKey(String propertyName)\r\n   at System.Text.Json.JsonPropertyDictionary`1.AddValue(String propertyName, T value)\r\n   at System.Text.Json.JsonPropertyDictionary`1.Add(String propertyName, T value)\r\n   at System.Text.Json.Nodes.JsonObject.InitializeIfRequired()\r\n   at System.Text.Json.Nodes.JsonObject.System.Collections.Generic.IDictionary<System.String,System.Text.Json.Nodes.JsonNode>.TryGetValue(String propertyName, JsonNode& jsonNode)\r\n   at System.Text.Json.Nodes.JsonObject.TryGetPropertyValue(String propertyName, JsonNode& jsonNode)\r\n   at System.Text.Json.Nodes.JsonObject.GetItem(String propertyName)\r\n   at System.Text.Json.Nodes.JsonNode.get_Item(String propertyName)\r\n```\n\n### Regression?\n\n_No response_\n\n### Known Workarounds\n\n_No response_\n\n### Configuration\n\nSeen in all released versions (.Net 6 and previous)\n\n### Other information\n\n_No response_\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>gregsdennis</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`area-System.Text.Json`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2022-07-07T21:39:34Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-07-07T21:39:34Z",
          "id": "IC_kwDODI9FZc5GOsVk"
        },
        {
          "author": "krwq",
          "body": "since this is easy enough let's try to fix this in 7.0",
          "createdAt": "2022-07-12T09:48:50Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-07-12T09:48:50Z",
          "id": "IC_kwDODI9FZc5GbRhk"
        },
        {
          "author": "eiriktsarpalis",
          "body": "I'm removing the `easy` label since changing this would require decoupling the implementation from `JsonPropertyDictionary`. Note that the same type is shared with the property cache in `JsonTypeInfo`, so we can't really address the issue here without subtly breaking member visibility in contract resolution logic. I think we should try to replace `JsonPropertyDictionary` with bespoke implementations in the corresponding scenaria, but that is nontrivial.",
          "createdAt": "2022-07-12T13:17:20Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-07-12T13:17:20Z",
          "id": "IC_kwDODI9FZc5GcBAs"
        },
        {
          "author": "AigioL",
          "body": "There are some third-party webapi that return json with duplicate keys, which is allowed in the Newtonsoft.Json.\r\n\r\nNow using the following code reflection modification fixes the problem, but will the November .NET 8 RTM fix it?\r\n\r\n```\r\n        const string json0 =\r\n\"\"\"\r\n{\r\n  \"test1\": \"Hello World\",\r\n  \"test1\": \"2\",\r\n  \"test1\": \"#\",\r\n  \"test1\": \"saf\",\r\n  \"test1\": \"😋\",\r\n  \"test2\": 22,\r\n  \"test3\": false\r\n}\r\n\"\"\";\r\n        var obj = System.Text.Json.JsonSerializer.Deserialize<System.Text.Json.Nodes.JsonObject>(json0);\r\n        TestContext.WriteLine(obj);\r\n        var value = obj.GetValue(() =>\r\n        {\r\n            var value = obj?[\"test1\"]?.ToString();\r\n            return value;\r\n        });\r\n        Assert.That(value, Is.EqualTo(\"😋\"));\r\n```\r\n\r\n```\r\npublic static partial class JsonObjectExtensions\r\n{\r\n    [RequiresUnreferencedCode(\"JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.\"]\r\n    [RequiresDynamicCode(\"JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.\")]\r\n    public static T? GetValue<T>(this System.Text.Json.Nodes.JsonObject? obj, Func<T?> func, bool checknull = true) where T : notnull\r\n    {\r\n        if (checknull && obj == null)\r\n            return default;\r\n        try\r\n        {\r\n            return func();\r\n        }\r\n        catch (ArgumentException)\r\n        {\r\n            /* \r\n        System.ArgumentException : An item with the same key has already been added. Key: test1 (Parameter 'propertyName')\r\n\r\n      StackTrace:\r\n        ThrowHelper.ThrowArgumentException_DuplicateKey(String paramName, String propertyName)\r\n        JsonObject.InitializeIfRequired()\r\n        JsonNode.get_Item(String propertyName)\r\n             */\r\n            InternalReflection.InitializeDictionary(obj);\r\n            return func();\r\n        }\r\n    }\r\n\r\n    [RequiresUnreferencedCode(\"JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.\")]\r\n    [RequiresDynamicCode(\"JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.\"]\r\n    static partial class InternalReflection\r\n    {\r\n        static readonly Lazy<MethodInfo> _GetUnderlyingRepresentation = new(() =>\r\n        {\r\n            var typeOfJObject = typeof(System.Text.Json.Nodes.JsonObject);\r\n            var methodGetUnderlyingRepresentation = typeOfJObject.GetMethod(\"GetUnderlyingRepresentation\", BindingFlags.Instance | BindingFlags.NonPublic);\r\n            object?[] parameters = [null, null];\r\n            return methodGetUnderlyingRepresentation.ThrowIsNull();\r\n        });\r\n\r\n        static void GetUnderlyingRepresentation(System.Text.Json.Nodes.JsonObject? obj, out object? dictionary, out JsonElement? jsonElement)\r\n        {\r\n            object?[] parameters = [null, null];\r\n            _GetUnderlyingRepresentation.Value.Invoke(obj, parameters);\r\n            dictionary = parameters[0];\r\n            jsonElement = (JsonElement?)parameters[1];\r\n        }\r\n\r\n        static readonly Lazy<Type> _CreateJsonPropertyDictionaryJsonNode = new(() =>\r\n        {\r\n            var typeOfJObject = typeof(System.Text.Json.Nodes.JsonObject);\r\n            var typeOfJsonPropertyDictionary = typeOfJObject.Assembly.GetType(\"System.Text.Json.JsonPropertyDictionary`1\", true);\r\n            var typeOfJsonPropertyDictionaryMakeGeneric = typeOfJsonPropertyDictionary.ThrowIsNull().MakeGenericType(typeof(JsonNode));\r\n            return typeOfJsonPropertyDictionaryMakeGeneric.ThrowIsNull();\r\n        });\r\n\r\n        static object? CreateJsonPropertyDictionaryJsonNode(bool caseInsensitive) => Activator.CreateInstance(_CreateJsonPropertyDictionaryJsonNode.Value, [caseInsensitive]);\r\n\r\n        /// <summary>\r\n        /// https://github.com/dotnet/runtime/blob/v8.0.0-rc.2.23479.6/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/Converters/Node/JsonNodeConverter.cs#L59\r\n        /// </summary>\r\n        static readonly Lazy<MethodInfo> _JsonNodeConverterCreate = new(() =>\r\n        {\r\n            var typeOfJObject = typeof(System.Text.Json.Nodes.JsonObject);\r\n            var typeOfJsonNodeConverter = typeOfJObject.Assembly.GetType(\"System.Text.Json.Serialization.Converters.JsonNodeConverter\", true);\r\n            var methodCreateJsonNode = typeOfJsonNodeConverter.ThrowIsNull().GetMethod(\"Create\", BindingFlags.Static | BindingFlags.Public);\r\n            return methodCreateJsonNode.ThrowIsNull();\r\n        });\r\n\r\n        static JsonNode? JsonNodeConverterCreate(JsonElement element, JsonNodeOptions? options) => (JsonNode?)_JsonNodeConverterCreate.Value.Invoke(null, [element, options]);\r\n\r\n        static readonly Lazy<PropertyInfo> _SetParent = new(() =>\r\n        {\r\n            var propertyParent = typeof(JsonNode).GetProperty(nameof(JsonNode.Parent));\r\n            return propertyParent.ThrowIsNull();\r\n        });\r\n\r\n        static void SetPropertyParent(JsonNode jsonNode, JsonNode parent) => _SetParent.Value.SetValue(jsonNode, parent);\r\n\r\n        static readonly Lazy<FieldInfo> _SetFieldDictionary = new(() =>\r\n        {\r\n            var typeOfJObject = typeof(System.Text.Json.Nodes.JsonObject);\r\n            var fieldDictionary = typeOfJObject.GetField(\"_dictionary\", BindingFlags.Instance | BindingFlags.NonPublic);\r\n            return fieldDictionary.ThrowIsNull();\r\n        });\r\n\r\n        static void SetFieldDictionary(System.Text.Json.Nodes.JsonObject obj, object? value) => _SetFieldDictionary.Value.SetValue(obj, value);\r\n\r\n        static readonly Lazy<FieldInfo> _SetFieldJsonElement = new(() =>\r\n        {\r\n            var typeOfJObject = typeof(System.Text.Json.Nodes.JsonObject);\r\n            var fieldDictionary = typeOfJObject.GetField(\"_jsonElement\", BindingFlags.Instance | BindingFlags.NonPublic);\r\n            return fieldDictionary.ThrowIsNull();\r\n        });\r\n\r\n        static void SetFieldJsonElement(System.Text.Json.Nodes.JsonObject obj, object? value) => _SetFieldJsonElement.Value.SetValue(obj, value);\r\n\r\n        static readonly Lazy<MethodInfo> _JsonPropertyDictionaryJsonNodeTryAddValue = new(() =>\r\n        {\r\n            var typeOfJObject = typeof(System.Text.Json.Nodes.JsonObject);\r\n            var typeOfJsonPropertyDictionary = typeOfJObject.Assembly.GetType(\"System.Text.Json.JsonPropertyDictionary`1\", true);\r\n            var typeOfJsonPropertyDictionaryMakeGeneric = typeOfJsonPropertyDictionary.ThrowIsNull().MakeGenericType(typeof(JsonNode));\r\n            var methodTryAddValue = typeOfJsonPropertyDictionaryMakeGeneric.GetMethod(\"TryAddValue\", BindingFlags.Instance | BindingFlags.NonPublic);\r\n            return methodTryAddValue.ThrowIsNull();\r\n        });\r\n\r\n        static void JsonPropertyDictionaryJsonNodeTryAddValue(object? dictionary, string? propertyName, JsonNode? value) => _JsonPropertyDictionaryJsonNodeTryAddValue.Value.Invoke(dictionary, [propertyName, value]);\r\n\r\n        public static void InitializeDictionary(System.Text.Json.Nodes.JsonObject? obj)\r\n        {\r\n            if (obj == null) return;\r\n            // https://github.com/dotnet/runtime/blob/v8.0.0-rc.2.23479.6/src/libraries/System.Text.Json/src/System/Text/Json/Nodes/JsonObject.IDictionary.cs#L196-L225\r\n            GetUnderlyingRepresentation(obj, out var dictionary, out var jsonElement);\r\n            if (dictionary == null)\r\n            {\r\n                bool caseInsensitive = obj.Options.HasValue && obj.Options.Value.PropertyNameCaseInsensitive;\r\n                dictionary = CreateJsonPropertyDictionaryJsonNode(caseInsensitive);\r\n                if (jsonElement.HasValue)\r\n                {\r\n                    IEnumerable<System.Text.Json.JsonProperty> items = jsonElement.Value.EnumerateObject();\r\n                    foreach (var item in items.Reverse()) // Loop in reverse order to take the value of the last one when repeated.\r\n                    {\r\n                        var jsonNode = JsonNodeConverterCreate(item.Value, obj.Options);\r\n                        if (jsonNode != null)\r\n                        {\r\n                            SetPropertyParent(jsonNode, obj);\r\n                        }\r\n                        JsonPropertyDictionaryJsonNodeTryAddValue(dictionary, item.Name, jsonNode);\r\n                    }\r\n                }\r\n                SetFieldDictionary(obj, dictionary);\r\n                Interlocked.MemoryBarrier();\r\n                SetFieldJsonElement(obj, null);\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n",
          "createdAt": "2023-10-18T18:56:15Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-12-29T16:39:30Z",
                "user": "jozefizso"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHODQydnA=="
          },
          "updatedAt": "2023-10-18T18:56:15Z",
          "id": "IC_kwDODI9FZc5pcut3"
        },
        {
          "author": "eiriktsarpalis",
          "body": "> will the November .NET 8 RTM fix it?\r\n\r\nUnfortunately, no. Development for .NET 8 concluded back in August and any work happening since targets .NET 9.",
          "createdAt": "2023-10-19T12:48:33Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_DOWN",
                "createdAt": "2023-12-29T16:39:51Z",
                "user": "jozefizso"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHODQydxw=="
          },
          "updatedAt": "2023-10-19T12:48:33Z",
          "id": "IC_kwDODI9FZc5pjh_5"
        },
        {
          "author": "BSS05",
          "body": "Hi @gregsdennis, \r\nIs this fixed? I still get this issue in latest version. I have no idea to fix it.",
          "createdAt": "2023-12-25T09:54:10Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-12-25T09:54:30Z",
          "id": "IC_kwDODI9FZc5vZR6c"
        },
        {
          "author": "gregsdennis",
          "body": "From Eirik's comment above, I would guess not.",
          "createdAt": "2023-12-25T10:05:40Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-12-25T10:05:40Z",
          "id": "IC_kwDODI9FZc5vZTa8"
        },
        {
          "author": "asklar",
          "body": "I just ran into this. In my case, I get the json from some web api. Merely calling Count on the JsonObject, or iterating through its child properties, results in the ArgumentException...\r\nI tried using `PropertyNamingPolicy` in the deserialization options, but I don't see that getting called (maybe it's only for serialization?).\r\n\r\nIs there a workaround to either allow multiple entries with the same name, allow the caller to rename duplicate entries, or at least ignore re-definitions or something? \r\n\r\nAs it is, the current behavior presents a problem to adopt System.Text.Json.",
          "createdAt": "2024-01-01T06:52:06Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-01-01T06:52:06Z",
          "id": "IC_kwDODI9FZc5vppvG"
        },
        {
          "author": "eiriktsarpalis",
          "body": "We would be happy to accept a PR that addresses the issue, since we can't prioritise a fix for the moment.",
          "createdAt": "2024-01-08T09:53:01Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-01-08T09:53:01Z",
          "id": "IC_kwDODI9FZc5wGOSl"
        }
      ],
      "totalCount": 9,
      "endCursor": "Y3Vyc29yOnYyOpHOcBjkpQ=="
    },
    "url": "https://github.com/dotnet/runtime/issues/71784",
    "title": "Duplicate object keys shouldn't result in an ArgumentException"
  },
  {
    "author": "eiriktsarpalis",
    "labels": [
      "api-suggestion",
      "area-System.Text.Json",
      "User Story",
      "Cost:L"
    ],
    "createdAt": "2022-07-11T14:08:16Z",
    "body": "Taken from https://github.com/dotnet/runtime/issues/63686#issuecomment-1110990139:\r\n\r\n> The [internal converters for collection and dictionary types do provide similar functionality](https://github.com/dotnet/runtime/blob/a49958b4b4f7a147b6cac91d510140863f7f57c5/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/Converters/Collection/ArrayConverter.cs#L26-L30), and we might consider exposing dedicated constructor delegates for each kind:\r\n> \r\n> * A `Func<IList, object>>? CreateEnumerable` delegate for `JsonTypeInfoKind.Enumerable`\r\n> * A `Func<IDictionary, object>>? CreateDictionary` delegate for `JsonTypeInfoKind.Dictionary`.\r\n> * A `Func<object[], object>? CreateObjectWithParameters` delegate for invoking parameterized constructors in `JsonTypeInfoKind.Object`.\r\n> \r\n> Note that these would require exposing the [`JsonTypeInfo.ElementType`](https://github.com/dotnet/runtime/blob/a49958b4b4f7a147b6cac91d510140863f7f57c5/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/Metadata/JsonTypeInfo.cs#L93) and [`JsonTypeInfo.KeyType`](https://github.com/dotnet/runtime/blob/a49958b4b4f7a147b6cac91d510140863f7f57c5/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/Metadata/JsonTypeInfo.cs#L135) properties, respectively. The parameterized constructor delegate would require exposing the internal [`JsonParameterInfo`]\r\nhttps://github.com/dotnet/runtime/issues/78098(https://github.com/dotnet/runtime/blob/a49958b4b4f7a147b6cac91d510140863f7f57c5/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/Metadata/JsonParameterInfo.cs#L12) metadata type.\r\n\r\n#### Related bugs that should be addressed in conjunction with this story:\r\n\r\n- [ ] https://github.com/dotnet/runtime/issues/73382\r\n- [ ] https://github.com/dotnet/runtime/issues/46088\r\n- [ ] https://github.com/dotnet/runtime/issues/77307\r\n- [ ] https://github.com/dotnet/runtime/issues/78098\r\n- [ ] https://github.com/dotnet/runtime/issues/44428\r\n- [ ] #81550",
    "number": 71944,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-06-18T17:57:50Z",
          "user": "SupinePandora43"
        }
      ],
      "totalCount": 1,
      "endCursor": "Y3Vyc29yOnYyOpHODEN0Lg=="
    },
    "updatedAt": "2023-02-03T15:26:35Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\nTaken from https://github.com/dotnet/runtime/issues/63686#issuecomment-1110990139:\r\n\r\n> The [internal converters for collection and dictionary types do provide similar functionality](https://github.com/dotnet/runtime/blob/a49958b4b4f7a147b6cac91d510140863f7f57c5/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/Converters/Collection/ArrayConverter.cs#L26-L30), and we might consider exposing dedicated constructor delegates for each kind:\r\n> \r\n> * A `Func<IList, object>>? CreateEnumerable` delegate for `JsonTypeInfoKind.Enumerable`\r\n> * A `Func<IDictionary, object>>? CreateDictionary` delegate for `JsonTypeInfoKind.Dictionary`.\r\n> * A `Func<object[], object>? CreateObjectWithParameters` delegate for invoking parameterized constructors in `JsonTypeInfoKind.Object`.\r\n> \r\n> Note that these would require exposing the [`JsonTypeInfo.ElementType`](https://github.com/dotnet/runtime/blob/a49958b4b4f7a147b6cac91d510140863f7f57c5/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/Metadata/JsonTypeInfo.cs#L93) and [`JsonTypeInfo.KeyType`](https://github.com/dotnet/runtime/blob/a49958b4b4f7a147b6cac91d510140863f7f57c5/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/Metadata/JsonTypeInfo.cs#L135) properties, respectively. The parameterized constructor delegate would require exposing the internal [`JsonParameterInfo`](https://github.com/dotnet/runtime/blob/a49958b4b4f7a147b6cac91d510140863f7f57c5/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/Metadata/JsonParameterInfo.cs#L12) metadata type.\r\n\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>eiriktsarpalis</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`area-System.Text.Json`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2022-07-11T14:08:23Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-07-11T14:08:23Z",
          "id": "IC_kwDODI9FZc5GXFlU"
        }
      ],
      "totalCount": 1,
      "endCursor": "Y3Vyc29yOnYyOpHORlxZVA=="
    },
    "url": "https://github.com/dotnet/runtime/issues/71944",
    "title": "Add support for parameterized constructors in System.Text.Json contract customization (converters)"
  },
  {
    "author": "eiriktsarpalis",
    "labels": [
      "enhancement",
      "area-System.Text.Json"
    ],
    "createdAt": "2022-07-11T18:59:13Z",
    "body": "The default System.Text.Json contract resolvers will fail early if they encounter misconfigured attributes such as the following:\r\n\r\n* Properties with conflicting names (possible via the `JsonPropertyNameAttribute`).\r\n* Invalid type arguments in `JsonConverterAttribute`.\r\n* `JsonExtensionDataAttribute` applied to unsupported property types or duplicate `JsonExtensionDataAttribute` properties.\r\n\r\nMisconfigured attributes in third-party libraries [are a real problem](https://github.com/dotnet/runtime/issues/58469#issuecomment-915599977) and as such one of the goals for contract customization is for users to be able to manually correct misconfigured attributes. In the future we should update our validation logic so that it happens post-configuration, where feasible.",
    "number": 71966,
    "reactions": {
      "hasNextPage": false,
      "nodes": [],
      "totalCount": 0,
      "endCursor": null
    },
    "updatedAt": "2022-09-28T16:14:28Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\nThe default System.Text.Json contract resolvers will fail early if they encounter misconfigured attributes such as the following:\r\n\r\n* Properties with conflicting names (possible via the `JsonPropertyNameAttribute`).\r\n* Invalid type arguments in `JsonConverterAttribute`.\r\n* `JsonExtensionDataAttribute` applied to unsupported property types or duplicate `JsonExtensionDataAttribute` properties.\r\n\r\nMisconfigured attributes in third-party libraries [are a real problem](https://github.com/dotnet/runtime/issues/58469#issuecomment-915599977) and as such one of the goals for contract customization is for users to be able to manually correct misconfigured attributes. In the future we should update our validation logic so that it happens post-configuration, where feasible.\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>eiriktsarpalis</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`area-System.Text.Json`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2022-07-11T18:59:20Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-07-11T18:59:20Z",
          "id": "IC_kwDODI9FZc5GYOoA"
        }
      ],
      "totalCount": 1,
      "endCursor": "Y3Vyc29yOnYyOpHORmDqAA=="
    },
    "url": "https://github.com/dotnet/runtime/issues/71966",
    "title": "System.Text.Json default contract resolvers fail early on misconfigured attributes"
  },
  {
    "author": "eiriktsarpalis",
    "labels": [
      "area-System.Text.Json",
      "User Story"
    ],
    "createdAt": "2022-07-11T19:09:41Z",
    "body": "Gathering some of the contract customization features we're planning on working for .NET 8. NB this list is subject to change.\r\n\r\n#### Object initialization\r\n\r\n- [x] https://github.com/dotnet/runtime/issues/73219\r\n- [x] https://github.com/dotnet/runtime/issues/78556\r\n- [ ] https://github.com/dotnet/runtime/issues/71944\r\n\r\n#### Contract configuration\r\n\r\n- [ ] https://github.com/dotnet/runtime/issues/71966\r\n- [x] https://github.com/dotnet/runtime/issues/37483\r\n- [x] https://github.com/dotnet/runtime/issues/77306\r\n- [x] #782\r\n\r\n#### Future\r\n\r\n- [x] https://github.com/dotnet/runtime/issues/71945\r\n- [ ] #55744\r\n",
    "number": 71967,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "EYES",
          "createdAt": "2022-09-26T18:11:36Z",
          "user": "veikkoeeva"
        },
        {
          "content": "EYES",
          "createdAt": "2022-10-18T13:44:40Z",
          "user": "occluder"
        },
        {
          "content": "HEART",
          "createdAt": "2022-10-22T02:32:49Z",
          "user": "jeffhandley"
        },
        {
          "content": "EYES",
          "createdAt": "2024-08-20T19:53:13Z",
          "user": "romainf-ubi"
        },
        {
          "content": "HEART",
          "createdAt": "2024-08-20T19:53:17Z",
          "user": "romainf-ubi"
        }
      ],
      "totalCount": 5,
      "endCursor": "Y3Vyc29yOnYyOpHOC6WKEg=="
    },
    "updatedAt": "2025-01-17T12:11:04Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "I couldn't figure out the best area label to add to this issue. If you have write-permissions please help me learn by adding exactly one [area label](https://github.com/dotnet/runtime/blob/master/docs/area-owners.md).",
          "createdAt": "2022-07-11T19:09:44Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-07-11T19:09:44Z",
          "id": "IC_kwDODI9FZc5GYQ3p"
        },
        {
          "author": null,
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\nGathering some of the contract customization features we're planning on working for .NET 8. NB this list is subject to change.\r\n\r\n- [ ] https://github.com/dotnet/runtime/issues/71944\r\n- [ ] https://github.com/dotnet/runtime/issues/71966\r\n- [ ] https://github.com/dotnet/runtime/issues/71945\r\n- [ ] https://github.com/dotnet/runtime/issues/71933\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>eiriktsarpalis</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>eiriktsarpalis</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`area-System.Text.Json`, `User Story`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>8.0.0</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2022-07-11T19:09:58Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-07-11T19:09:58Z",
          "id": "IC_kwDODI9FZc5GYQ66"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Closing, as we won't be investing on contract customization anymore in this release.",
          "createdAt": "2023-05-31T16:37:39Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-05-31T16:37:39Z",
          "id": "IC_kwDODI9FZc5dnNpu"
        }
      ],
      "totalCount": 3,
      "endCursor": "Y3Vyc29yOnYyOpHOXZzabg=="
    },
    "url": "https://github.com/dotnet/runtime/issues/71967",
    "title": "Planned System.Text.Json contract customization improvements"
  },
  {
    "author": "radical",
    "labels": [
      "test-failure",
      "arch-wasm",
      "area-System.Text.Json"
    ],
    "createdAt": "2022-07-11T23:00:01Z",
    "body": "[Build](https://dev.azure.com/dnceng/public/_build/results?buildId=1872987&view=logs&jobId=e36cdb78-1b23-5f53-5d15-e931194c7d32&j=b4344b0d-0f92-5d69-ccaf-e0b24fbf14a2&t=65a58faa-a542-5344-b5c8-897139f242cd), and [log](https://helixre107v0xdeko0k025g8.blob.core.windows.net/dotnet-runtime-refs-pull-71875-merge-624f8760879e44f287/System.Text.Json.Tests/1/console.f2a38d09.log?helixlogtype=result):\r\n\r\n```\r\n    System.Text.Json.Serialization.Tests.PropertyVisibilityTestsDynamic.JsonIgnoreAttribute_UnsupportedCollection [FAIL]\r\n      System.UriFormatException : Invalid URI: The hostname could not be parsed.\r\n      Stack Trace:\r\n        /_/src/libraries/System.Private.Uri/src/System/UriExt.cs(42,0): at System.Uri.CreateThis(String uri, Boolean dontEscape, UriKind uriKind, UriCreationOptions& creationOptions)\r\n        /_/src/libraries/System.Private.Uri/src/System/Uri.cs(369,0): at System.Uri..ctor(String uriString)\r\n        /_/src/libraries/System.Text.Json/tests/Common/PropertyVisibilityTests.cs(1193,0): at System.Text.Json.Serialization.Tests.PropertyVisibilityTests.JsonIgnoreAttribute_UnsupportedCollection()\r\n        --- End of stack trace from previous location ---\r\n  Finished:    System.Text.Json.Tests\r\n```",
    "number": 71981,
    "reactions": {
      "hasNextPage": false,
      "nodes": [],
      "totalCount": 0,
      "endCursor": null
    },
    "updatedAt": "2022-09-29T18:07:15Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\n[Build](https://dev.azure.com/dnceng/public/_build/results?buildId=1872987&view=logs&jobId=e36cdb78-1b23-5f53-5d15-e931194c7d32&j=b4344b0d-0f92-5d69-ccaf-e0b24fbf14a2&t=65a58faa-a542-5344-b5c8-897139f242cd), and [log](https://helixre107v0xdeko0k025g8.blob.core.windows.net/dotnet-runtime-refs-pull-71875-merge-624f8760879e44f287/System.Text.Json.Tests/1/console.f2a38d09.log?helixlogtype=result):\r\n\r\n```\r\n    System.Text.Json.Serialization.Tests.PropertyVisibilityTestsDynamic.JsonIgnoreAttribute_UnsupportedCollection [FAIL]\r\n      System.UriFormatException : Invalid URI: The hostname could not be parsed.\r\n      Stack Trace:\r\n        /_/src/libraries/System.Private.Uri/src/System/UriExt.cs(42,0): at System.Uri.CreateThis(String uri, Boolean dontEscape, UriKind uriKind, UriCreationOptions& creationOptions)\r\n        /_/src/libraries/System.Private.Uri/src/System/Uri.cs(369,0): at System.Uri..ctor(String uriString)\r\n        /_/src/libraries/System.Text.Json/tests/Common/PropertyVisibilityTests.cs(1193,0): at System.Text.Json.Serialization.Tests.PropertyVisibilityTests.JsonIgnoreAttribute_UnsupportedCollection()\r\n        --- End of stack trace from previous location ---\r\n  Finished:    System.Text.Json.Tests\r\n```\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>radical</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`area-System.Text.Json`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2022-07-11T23:00:34Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-07-11T23:00:34Z",
          "id": "IC_kwDODI9FZc5GZN-2"
        },
        {
          "author": "krwq",
          "body": "FYI disabled tests are no longer blocking CI so removing label",
          "createdAt": "2022-07-12T08:31:27Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-07-12T08:31:27Z",
          "id": "IC_kwDODI9FZc5Ga-ao"
        },
        {
          "author": "radical",
          "body": "> FYI disabled tests are no longer blocking CI so removing label\n\nOops, sorry, missed this one!",
          "createdAt": "2022-07-12T15:03:18Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-07-12T15:03:18Z",
          "id": "IC_kwDODI9FZc5Gce5e"
        },
        {
          "author": "eiriktsarpalis",
          "body": "@radical PTAL at this comment: https://github.com/dotnet/runtime/pull/71875/files#r919266335\r\n\r\nJudging by the original code in this change, this appears to be a regression in System.Uri contructor validation.",
          "createdAt": "2022-07-12T18:13:38Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-07-12T18:13:38Z",
          "id": "IC_kwDODI9FZc5Gdn_B"
        },
        {
          "author": "radical",
          "body": "@eiriktsarpalis Do you want me to revert this, or would you want to do it as part of the fixing the validation?",
          "createdAt": "2022-07-12T18:14:43Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-07-12T18:14:43Z",
          "id": "IC_kwDODI9FZc5Gdomb"
        },
        {
          "author": "eiriktsarpalis",
          "body": "I think simply reverting the accidental change would be good for now.",
          "createdAt": "2022-07-12T18:29:24Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-07-12T18:29:24Z",
          "id": "IC_kwDODI9FZc5GdxNh"
        },
        {
          "author": null,
          "body": "Tagging subscribers to 'arch-wasm': @lewing\nSee info in area-owners.md if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\n[Build](https://dev.azure.com/dnceng/public/_build/results?buildId=1872987&view=logs&jobId=e36cdb78-1b23-5f53-5d15-e931194c7d32&j=b4344b0d-0f92-5d69-ccaf-e0b24fbf14a2&t=65a58faa-a542-5344-b5c8-897139f242cd), and [log](https://helixre107v0xdeko0k025g8.blob.core.windows.net/dotnet-runtime-refs-pull-71875-merge-624f8760879e44f287/System.Text.Json.Tests/1/console.f2a38d09.log?helixlogtype=result):\r\n\r\n```\r\n    System.Text.Json.Serialization.Tests.PropertyVisibilityTestsDynamic.JsonIgnoreAttribute_UnsupportedCollection [FAIL]\r\n      System.UriFormatException : Invalid URI: The hostname could not be parsed.\r\n      Stack Trace:\r\n        /_/src/libraries/System.Private.Uri/src/System/UriExt.cs(42,0): at System.Uri.CreateThis(String uri, Boolean dontEscape, UriKind uriKind, UriCreationOptions& creationOptions)\r\n        /_/src/libraries/System.Private.Uri/src/System/Uri.cs(369,0): at System.Uri..ctor(String uriString)\r\n        /_/src/libraries/System.Text.Json/tests/Common/PropertyVisibilityTests.cs(1193,0): at System.Text.Json.Serialization.Tests.PropertyVisibilityTests.JsonIgnoreAttribute_UnsupportedCollection()\r\n        --- End of stack trace from previous location ---\r\n  Finished:    System.Text.Json.Tests\r\n```\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>radical</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`arch-wasm`, `area-System.Text.Json`, `test-failure`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>7.0.0</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2022-08-05T17:30:19Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-08-05T17:30:19Z",
          "id": "IC_kwDODI9FZc5H7I2X"
        }
      ],
      "totalCount": 7,
      "endCursor": "Y3Vyc29yOnYyOpHOR-yNlw=="
    },
    "url": "https://github.com/dotnet/runtime/issues/71981",
    "title": "[wasm] `STJ.Serialization.Tests.JsonIgnoreAttribute_UnsupportedCollection` failing on `main`"
  },
  {
    "author": "jtschuster",
    "labels": [
      "test-failure",
      "area-System.Text.Json"
    ],
    "createdAt": "2022-07-13T15:04:04Z",
    "body": "Frequency:\r\n- 7/22 - 1 hit in [last 60 days](https://runfo.azurewebsites.net/search/tests/?q=started%3A%7E60+definition%3Aruntime+name%3A%22system.text.json.tests.utf8jsonreadertests.readjsonstringswithcomments%22) (incl. PRs) / 4/1-7/22 Kusto query shows only 1 hit as well\r\n\r\n```kusto\r\nlet failedTests = (methodName : string, includePR : bool, messageSubstr: string, includePassedOnRerun : bool) {\r\ncluster('engsrvprod.kusto.windows.net').database('engineeringdata').AzureDevOpsTests\r\n    | where TestName contains methodName\r\n    | where includePassedOnRerun or (Outcome == 'Failed')\r\n    | extend startOfTestName = indexof_regex(TestName, @\"[^.]+$\")\r\n    | extend Method = substring(TestName, startOfTestName)\r\n    | extend Type = substring(TestName, 0, startOfTestName - 1)\r\n    | project-away startOfTestName\r\n    | where Method == methodName\r\n    | where Message contains messageSubstr\r\n    | distinct JobId, WorkItemId, Message, StackTrace, Method, Type, Arguments, Outcome\r\n    | join kind=inner (cluster('engsrvprod.kusto.windows.net').database('engineeringdata').Jobs\r\n        | where ((Branch == 'refs/heads/main') or (Branch == 'refs/heads/master') or (includePR and (Source startswith \"pr/\")))\r\n        | where Type startswith \"test/functional/cli/\"\r\n            and not(Properties contains \"runtime-staging\")\r\n        | summarize arg_max(Finished, Properties, Type, Branch, Source, Started, QueueName) by JobId\r\n        | project-rename JobType = Type) on JobId\r\n    | extend PropertiesJson = parse_json(Properties)\r\n    | extend OS = replace_regex(tostring(PropertiesJson.operatingSystem), @'\\((.*)\\).*|([^\\(].*)', @'\\1\\2')\r\n    | extend Runtime = iif(PropertiesJson.runtimeFlavor == \"mono\", \"Mono\", iif(PropertiesJson.DefinitionName contains \"coreclr\", \"CoreCLR\", \"\"))\r\n    | extend TargetBranch = extractjson(\"$.['System.PullRequest.TargetBranch']\", Properties)\r\n    | extend Architecture = PropertiesJson.architecture\r\n    | extend Scenario = iif(isempty(PropertiesJson.scenario), \"--\", PropertiesJson.scenario)\r\n    //| extend DefinitionName = PropertiesJson.DefinitionName\r\n    | project-away PropertiesJson\r\n};\r\nfailedTests('ReadJsonStringsWithComments', true, '', true);\r\n```\r\n\r\n[Build 1874165](https://runfo.azurewebsites.net/view/build/?number=1874165) - ubuntu.1804.armarch.open - [Test results](https://helixre107v0xdeko0k025g8.blob.core.windows.net/dotnet-runtime-refs-heads-main-455133167ff14f12a7/System.Text.Json.Tests/1/console.dfb6e8f2.log?%3Fhelixlogtype%3Dresult)\r\n\r\n```\r\nStarting:    System.Text.Json.Tests (parallel test collections = on, max threads = 4)\r\n    System.Text.Json.Tests.Utf8JsonReaderTests.ReadJsonStringsWithComments(jsonString: \"{\\\"Property1\\\": {\\\"Property1.1\\\": 42}, // comment\\\"...) [FAIL]\r\n      System.InvalidOperationException : End position was not reached during enumeration.\r\n      Stack Trace:\r\n        /_/src/libraries/System.Memory/src/System/ThrowHelper.cs(43,0): at System.ThrowHelper.ThrowInvalidOperationException_EndPositionNotReached()\r\n        /_/src/libraries/System.Text.Json/src/System/Text/Json/Reader/Utf8JsonReader.MultiSegment.cs(325,0): at System.Text.Json.Utf8JsonReader.GetNextSpan()\r\n        /_/src/libraries/System.Text.Json/src/System/Text/Json/Reader/Utf8JsonReader.MultiSegment.cs(1561,0): at System.Text.Json.Utf8JsonReader.ConsumeNextTokenMultiSegment(Byte marker)\r\n        /_/src/libraries/System.Text.Json/src/System/Text/Json/Reader/Utf8JsonReader.MultiSegment.cs(213,0): at System.Text.Json.Utf8JsonReader.ReadMultiSegment()\r\n        /_/src/libraries/System.Text.Json/src/System/Text/Json/Reader/Utf8JsonReader.cs(285,0): at System.Text.Json.Utf8JsonReader.Read()\r\n        /_/src/libraries/System.Text.Json/tests/System.Text.Json.Tests/Utf8JsonReaderTests.MultiSegment.cs(2096,0): at System.Text.Json.Tests.Utf8JsonReaderTests.ReadWithCommentsHelper(Utf8JsonReader& reader, Int32 expectedConsumed, Boolean validateThrows)\r\n        /_/src/libraries/System.Text.Json/tests/System.Text.Json.Tests/Utf8JsonReaderTests.MultiSegment.cs(1989,0): at System.Text.Json.Tests.Utf8JsonReaderTests.ReadJsonStringsWithComments(String jsonString)\r\n           at InvokeStub_Utf8JsonReaderTests.ReadJsonStringsWithComments(Object, Object, IntPtr*)\r\n           at System.Reflection.MethodInvoker.Invoke(Object obj, IntPtr* args, BindingFlags invokeAttr)\r\n```\r\n<!-- runfo report start -->\r\nRunfo Tracking Issue: [system.text.json.tests.utf8jsonreadertests.readjsonstringswithcomments](https://runfo.azurewebsites.net/tracking/issue/369)\r\n|Build|Definition|Kind|Run Name|\r\n|---|---|---|---|\r\n\r\n\r\n\r\nBuild Result Summary\r\n|Day Hit Count|Week Hit Count|Month Hit Count|\r\n|---|---|---|\r\n|0|0|0|\r\n\r\n<!-- runfo report end -->\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
    "number": 72100,
    "reactions": {
      "hasNextPage": false,
      "nodes": [],
      "totalCount": 0,
      "endCursor": null
    },
    "updatedAt": "2024-02-22T15:00:34Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\n[Build](https://runfo.azurewebsites.net/view/build/?number=1874165)\r\n[Log](https://helixre107v0xdeko0k025g8.blob.core.windows.net/dotnet-runtime-refs-heads-main-455133167ff14f12a7/System.Text.Json.Tests/1/console.dfb6e8f2.log?%3Fhelixlogtype%3Dresult)\r\n\r\n```\r\nStarting:    System.Text.Json.Tests (parallel test collections = on, max threads = 4)\r\n    System.Text.Json.Tests.Utf8JsonReaderTests.ReadJsonStringsWithComments(jsonString: \"{\\\"Property1\\\": {\\\"Property1.1\\\": 42}, // comment\\\"...) [FAIL]\r\n      System.InvalidOperationException : End position was not reached during enumeration.\r\n      Stack Trace:\r\n        /_/src/libraries/System.Memory/src/System/ThrowHelper.cs(43,0): at System.ThrowHelper.ThrowInvalidOperationException_EndPositionNotReached()\r\n        /_/src/libraries/System.Text.Json/src/System/Text/Json/Reader/Utf8JsonReader.MultiSegment.cs(325,0): at System.Text.Json.Utf8JsonReader.GetNextSpan()\r\n        /_/src/libraries/System.Text.Json/src/System/Text/Json/Reader/Utf8JsonReader.MultiSegment.cs(1561,0): at System.Text.Json.Utf8JsonReader.ConsumeNextTokenMultiSegment(Byte marker)\r\n        /_/src/libraries/System.Text.Json/src/System/Text/Json/Reader/Utf8JsonReader.MultiSegment.cs(213,0): at System.Text.Json.Utf8JsonReader.ReadMultiSegment()\r\n        /_/src/libraries/System.Text.Json/src/System/Text/Json/Reader/Utf8JsonReader.cs(285,0): at System.Text.Json.Utf8JsonReader.Read()\r\n        /_/src/libraries/System.Text.Json/tests/System.Text.Json.Tests/Utf8JsonReaderTests.MultiSegment.cs(2096,0): at System.Text.Json.Tests.Utf8JsonReaderTests.ReadWithCommentsHelper(Utf8JsonReader& reader, Int32 expectedConsumed, Boolean validateThrows)\r\n        /_/src/libraries/System.Text.Json/tests/System.Text.Json.Tests/Utf8JsonReaderTests.MultiSegment.cs(1989,0): at System.Text.Json.Tests.Utf8JsonReaderTests.ReadJsonStringsWithComments(String jsonString)\r\n           at InvokeStub_Utf8JsonReaderTests.ReadJsonStringsWithComments(Object, Object, IntPtr*)\r\n           at System.Reflection.MethodInvoker.Invoke(Object obj, IntPtr* args, BindingFlags invokeAttr)\r\n```\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>jtschuster</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`area-System.Text.Json`, `blocking-clean-ci`, `test-failure`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2022-07-13T15:04:09Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-07-13T15:04:09Z",
          "id": "IC_kwDODI9FZc5GiFbZ"
        },
        {
          "author": "karelz",
          "body": "Only one hit in [last 60 days](https://runfo.azurewebsites.net/search/tests/?q=started%3A%7E60+definition%3Aruntime+name%3A%22system.text.json.tests.utf8jsonreadertests.readjsonstringswithcomments%22) (as of 7/22) and also 1 hit in Kusto 4/1-7/22. Removing blocking-clean-ci label.",
          "createdAt": "2022-07-22T09:54:08Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-07-22T11:08:30Z",
          "id": "IC_kwDODI9FZc5HEoWM"
        }
      ],
      "totalCount": 2,
      "endCursor": "Y3Vyc29yOnYyOpHORxKFjA=="
    },
    "url": "https://github.com/dotnet/runtime/issues/72100",
    "title": "System.Text.Json.Tests.Utf8JsonReaderTests.ReadJsonStringsWithComments"
  },
  {
    "author": "eiriktsarpalis",
    "labels": [
      "bug",
      "area-System.Text.Json"
    ],
    "createdAt": "2022-07-14T11:03:18Z",
    "body": "_Originally posted by @ilya-scale in https://github.com/dotnet/runtime/issues/63747#issuecomment-1184282250_\r\n\r\nThis can be reproduced both with `ReferenceHandler.Preserve`:\r\n```C#\r\nvar value = new Poco { Value = \"string\" };\r\nvar options = new JsonSerializerOptions { ReferenceHandler = ReferenceHandler.Preserve };\r\nstring json = JsonSerializer.Serialize(value, options);\r\nConsole.WriteLine(json); // {\"$id\":\"1\",\"$id\":\"string\"}\r\nJsonSerializer.Deserialize<Poco>(json, options); // Fails with 'The metadata property '$id' must be the first reference preservation property in the JSON object. \r\n\r\npublic class Poco\r\n{\r\n    [JsonPropertyName(\"$id\")]\r\n    public string Value { get; set; }\r\n}\r\n```\r\nand polymorphism\r\n```C#\r\nBase value = new Derived { Value = \"value\" };\r\nstring json = JsonSerializer.Serialize(value);\r\nConsole.WriteLine(json); // {\"$type\":\"derived\",\"$type\":\"value\"}\r\nBase result = JsonSerializer.Deserialize<Base>(json); // System.Text.Json.JsonException: 'Deserialized object contains a duplicate type discriminator metadata property. \r\nConsole.WriteLine(result is Derived);\r\n\r\n[JsonDerivedType(typeof(Base), \"base\")]\r\n[JsonDerivedType(typeof(Derived), \"derived\")]\r\npublic class Base\r\n{\r\n    [JsonPropertyName(\"$type\")]\r\n    public string Value { get; set; }\r\n}\r\n\r\npublic class Derived : Base\r\n{\r\n}\r\n```\r\nWe should validation for both cases to ensure invalid JSON is not emitted over the wire.",
    "number": 72170,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-04-23T08:10:34Z",
          "user": "WojciechNagorski"
        }
      ],
      "totalCount": 1,
      "endCursor": "Y3Vyc29yOnYyOpHODBkoQw=="
    },
    "updatedAt": "2025-07-17T17:29:42Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\n_Originally posted by @ilya-scale in https://github.com/dotnet/runtime/issues/63747#issuecomment-1184282250_\r\n\r\nThis can be reproduced both with `ReferenceHandler.Preserve`:\r\n```C#\r\nvar value = new Poco { Value = \"string\" };\r\nvar options = new JsonSerializerOptions { ReferenceHandler = ReferenceHandler.Preserve };\r\nstring json = JsonSerializer.Serialize(value, options);\r\nConsole.WriteLine(json); // {\"$id\":\"1\",\"$id\":\"string\"}\r\nJsonSerializer.Deserialize<Poco>(json, options); // Fails with 'The metadata property '$id' must be the first reference preservation property in the JSON object. \r\n\r\npublic class Poco\r\n{\r\n    [JsonPropertyName(\"$id\")]\r\n    public string Value { get; set; }\r\n}\r\n```\r\nand polymorphism\r\n```C#\r\nBase value = new Derived { Value = \"value\" };\r\nstring json = JsonSerializer.Serialize(value);\r\nConsole.WriteLine(json); // {\"$type\":\"derived\",\"$type\":\"value\"}\r\nBase result = JsonSerializer.Deserialize<Base>(json); // System.Text.Json.JsonException: 'Deserialized object contains a duplicate type discriminator metadata property. \r\nConsole.WriteLine(result is Derived);\r\n\r\n[JsonDerivedType(typeof(Base), \"base\")]\r\n[JsonDerivedType(typeof(Derived), \"derived\")]\r\npublic class Base\r\n{\r\n    [JsonPropertyName(\"$type\")]\r\n    public string Value { get; set; }\r\n}\r\n\r\npublic class Derived : Base\r\n{\r\n}\r\n```\r\nWe should validation for both cases to ensure invalid JSON is not emitted over the wire.\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>eiriktsarpalis</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`area-System.Text.Json`, `untriaged`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2022-07-14T11:03:28Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-07-14T11:03:28Z",
          "id": "IC_kwDODI9FZc5Glxz8"
        },
        {
          "author": "ilya-scale",
          "body": "Would there be a way to have both polymorphic deserialization and a possibility to read the property, i.e. the discriminator from the resulting C# object, or you want to explicitly prohibit it so that it will not be possible?",
          "createdAt": "2022-07-14T12:37:44Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-07-14T12:37:44Z",
          "id": "IC_kwDODI9FZc5GmHg6"
        },
        {
          "author": "eiriktsarpalis",
          "body": "I think it would make sense to explicitly prohibit.",
          "createdAt": "2022-07-14T12:51:48Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-07-14T12:51:48Z",
          "id": "IC_kwDODI9FZc5GmK3I"
        },
        {
          "author": "ilya-scale",
          "body": "It is probably not a bad idea though to allow reading the type discriminator unless it will lead to some unforeseen consequences or complicated implementation? ",
          "createdAt": "2022-07-15T07:37:38Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-07-15T07:37:38Z",
          "id": "IC_kwDODI9FZc5Gpb0l"
        },
        {
          "author": "eiriktsarpalis",
          "body": "When I created this issue, I had assumed that this would be a metadata validation concern, but this is not the case with dictionary types; we'd need to validate individual key/value pairs at runtime which is not ideal from a performance perspective, and may not even be possible if we have a converter that overrides [`WriteAsPropertyName`](https://docs.microsoft.com/en-us/dotnet/api/system.text.json.serialization.jsonconverter-1.writeaspropertyname?view=net-6.0).\r\n\r\nIf not possible to enforce on Dictionary types, does it make sense to enforce it on object types from a consistency perspective?\r\n\r\nMoving to Future, we can consider doing this in later releases should there be demand.",
          "createdAt": "2022-08-02T18:03:10Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-08-02T18:03:10Z",
          "id": "IC_kwDODI9FZc5HtRRs"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Related issue: #1780. That one suggests escaping `$` to avoid conflicts, however polymorphism makes it possible to define metadata properties with `$` prefixes.",
          "createdAt": "2022-08-04T12:58:01Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-08-04T12:59:17Z",
          "id": "IC_kwDODI9FZc5H1jkU"
        },
        {
          "author": "layomia",
          "body": "JSON technically allows duplicate properties. For non-metadata properties STJ employs a \"last one wins\" strategy for deserialization.\r\n\r\nFor these metadata-based features, we seem to be throwing reasonable exceptions to avoid ambiguous metadata interpretation. Seems we can close this issue?",
          "createdAt": "2022-12-02T16:36:11Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-12-02T16:36:11Z",
          "id": "IC_kwDODI9FZc5Pmkye"
        },
        {
          "author": "eiriktsarpalis",
          "body": "I think the problem primarily here is with serialization: it emits duplicate entries even though these are impossible to deserialize using the same configuration. That being said, it's not a particularly important problem.",
          "createdAt": "2022-12-02T16:43:46Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-12-02T16:44:22Z",
          "id": "IC_kwDODI9FZc5PmmoY"
        },
        {
          "author": "dennis-yemelyanov",
          "body": "I have a related problem where I can avoid duplicate serialization, however I wasn't able to get the `Type` object property (also used as the discriminator) populated on deserialization.\r\n\r\nFor example, for the following class hierarchy:\r\n```cs\r\nabstract class Base\r\n{\r\n    public string Type { get; set; }\r\n}\r\n\r\nclass Person : Base\r\n{\r\n    public string Name { get; set; }\r\n}\r\n\r\nclass Container\r\n{\r\n    public Base Obj { get; set; }\r\n}\r\n```\r\n\r\nI wrote the following TypeResolver with an option to remove the `Type` property and avoid duplicate \"Type\" json keys written on serialization:\r\n```cs\r\npublic class PolymorphicTypeResolver : DefaultJsonTypeInfoResolver\r\n{\r\n    private readonly bool _removeTypeProperty;\r\n\r\n    public PolymorphicTypeResolver(bool removeTypeProperty)\r\n    {\r\n        _removeTypeProperty = removeTypeProperty;\r\n    }\r\n\r\n    public override JsonTypeInfo GetTypeInfo(Type type, JsonSerializerOptions options)\r\n    {\r\n        var typeInfo = base.GetTypeInfo(type, options);\r\n\r\n        if (typeInfo.Type == typeof(Person))\r\n        {\r\n            var typeProperty = typeInfo.Properties.Single(x => x.Name == \"Type\");\r\n\r\n            if (_removeTypeProperty)\r\n            {\r\n                typeInfo.Properties.Remove(typeProperty);\r\n            }\r\n        }\r\n\r\n        if (typeInfo.Type == typeof(Base))\r\n        {\r\n            typeInfo.PolymorphismOptions = new JsonPolymorphismOptions\r\n            {\r\n                TypeDiscriminatorPropertyName = \"Type\",\r\n                IgnoreUnrecognizedTypeDiscriminators = false,\r\n                UnknownDerivedTypeHandling = JsonUnknownDerivedTypeHandling.FailSerialization,\r\n                DerivedTypes = { new JsonDerivedType(typeof(Person), nameof(Person)) }\r\n            };\r\n        }\r\n\r\n        return typeInfo;\r\n    }\r\n}\r\n```\r\n\r\nI use the following code to create and roundtrip an object:\r\n```cs\r\nvar serializeOptions = new JsonSerializerOptions\r\n{\r\n    TypeInfoResolver = new PolymorphicTypeResolver(removeTypeProperty: true)\r\n};\r\n\r\nvar container = new Container { Obj = new Person { Name = \"John\" } };\r\n\r\nvar json = JsonSerializer.Serialize(container, serializeOptions);\r\n\r\nConsole.WriteLine(json);\r\n\r\nvar deserializeOptions = new JsonSerializerOptions\r\n{\r\n    TypeInfoResolver = new PolymorphicTypeResolver(removeTypeProperty: false)\r\n};\r\n\r\nvar result = JsonSerializer.Deserialize<Container>(json, deserializeOptions);\r\n\r\nConsole.WriteLine($\"Type: {result.Obj.Type}; Name: {((Person)result.Obj).Name}\");\r\n```\r\nThe problem is that the last line doesn't optput correct `Type` value:\r\n\r\n```\r\n{\"Obj\":{\"Type\":\"Person\",\"Name\":\"John\"}}\r\nType: ; Name: John\r\n```\r\nI want it to print `Type: Person; Name John` instead.\r\n\r\nI would appreciate it if there are any workarounds, maybe some customer converters or other tricks can be used to achieve the desired result?",
          "createdAt": "2023-02-22T01:55:04Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-02-22T01:55:04Z",
          "id": "IC_kwDODI9FZc5VymNc"
        },
        {
          "author": "eiriktsarpalis",
          "body": "@dennis-yemelyanov the scenario you're describing is not supported. Type discriminators map string identifiers to specific derived types and as such they cannot be bound to the runtime value of any properties of the object being serialized.",
          "createdAt": "2023-02-22T10:25:11Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-02-22T10:25:11Z",
          "id": "IC_kwDODI9FZc5V0TTe"
        },
        {
          "author": "dennis-yemelyanov",
          "body": "Thank you @eiriktsarpalis for confirming. I came up with a slightly different approach using a converter, but was curious if this approach is safe or could have potential issues like infinite recursion due to passing the same `options` to `Serialize`/`Deserialize`?\r\n\r\nBasically in the converter for the base class I first read json as `JsonObject`, then convert it to a specific class depending on the `Type` value. And when writing the JSON, simply write the object as a specific class:\r\n\r\n```cs\r\nclass PolymorphicConverter : JsonConverter<Base>\r\n{\r\n    public override Base? Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)\r\n    {\r\n        var jsonObj = JsonSerializer.Deserialize<JsonObject>(ref reader, options);\r\n\r\n        var type = (string)jsonObj[\"Type\"];\r\n\r\n        return type switch\r\n        {\r\n            \"Person\" => jsonObj.Deserialize<Person>(options),\r\n            _ => throw new InvalidOperationException($\"Unknown type '{type}'\")\r\n        };\r\n    }\r\n\r\n    public override void Write(Utf8JsonWriter writer, Base value, JsonSerializerOptions options)\r\n    {\r\n        if (value is Person person)\r\n        {\r\n            JsonSerializer.Serialize(writer, person, options);\r\n        }\r\n        else\r\n        {\r\n            throw new InvalidOperationException($\"Unknown type '{value.GetType().Name}'\");\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nThis also requires configuring a modifier for the `Type` property so it can have the correct value depending on the actual class type:\r\n\r\n```cs\r\nprivate static void ConfigureTypePropertyModifier(JsonTypeInfo jsonTypeInfo)\r\n{\r\n    if (jsonTypeInfo.Kind != JsonTypeInfoKind.Object)\r\n        return;\r\n\r\n    var typeProperty = jsonTypeInfo.Properties.SingleOrDefault(x => x.Name == \"Type\");\r\n\r\n    if (typeProperty != null)\r\n    {\r\n        typeProperty.Get = obj => obj.GetType().Name;\r\n    }\r\n}\r\n\r\nvar serializeOptions = new JsonSerializerOptions\r\n{\r\n    Converters = { new PolymorphicConverter() },\r\n    TypeInfoResolver = new DefaultJsonTypeInfoResolver\r\n    {\r\n        Modifiers = { ConfigureTypePropertyModifier }\r\n    }\r\n};\r\n\r\nvar container = new Container { Obj = new Person { Name = \"John\" } };\r\n\r\nvar json = JsonSerializer.Serialize(container, serializeOptions);\r\n\r\nConsole.WriteLine(json);\r\n\r\nvar result = JsonSerializer.Deserialize<Container>(json, serializeOptions);\r\n\r\nConsole.WriteLine($\"Type: {result.Obj.Type}; Name: {((Person)result.Obj).Name}\");\r\n```\r\nThis seems to work and prints the expected result:\r\n\r\n```\r\n{\"Obj\":{\"Name\":\"John\",\"Type\":\"Person\"}}\r\nType: Person; Name: John\r\n```\r\nWould you recommend going with this approach or are there any potential risks that I missed?",
          "createdAt": "2023-02-22T18:18:29Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-02-22T18:18:29Z",
          "id": "IC_kwDODI9FZc5V3SDx"
        },
        {
          "author": "vmachacek",
          "body": "this is issue for me, because when I serialize object which has 2 same properties (one injected by poly features of STJ and second just being there for a convenience on a server side) like so \n\n```\n{\n\t\"userInput\": {\n\t\t\"productModule\": \"Basic\",\n\t\t\"productModule\": \"Basic\",\n\t\t...\n\t}\n}\n```\n\nthan on deserialization it fails because it wont like the fact the `TypeDiscriminatorProperty` is duplicated .\n\nAny work around that?",
          "createdAt": "2025-02-25T14:47:45Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-02-25T14:47:45Z",
          "id": "IC_kwDODI9FZc6f38EV"
        },
        {
          "author": "Rick-van-Dam",
          "body": "Running into this as well. Will this be fixed in .NET 10 since it was added to that milestone?",
          "createdAt": "2025-03-31T11:02:07Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-03-31T11:02:07Z",
          "id": "IC_kwDODI9FZc6k3BmP"
        },
        {
          "author": "WojciechNagorski",
          "body": "@Rick-van-Dam  here you have a workaround https://github.com/dotnet/runtime/issues/110248#issuecomment-2506929211",
          "createdAt": "2025-04-23T08:10:04Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-08-11T08:09:23Z",
                "user": "Basssiiie"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOEdzLaw=="
          },
          "updatedAt": "2025-04-23T08:10:04Z",
          "id": "IC_kwDODI9FZc6oSiWV"
        }
      ],
      "totalCount": 14,
      "endCursor": "Y3Vyc29yOnYyOpHOqEollQ=="
    },
    "url": "https://github.com/dotnet/runtime/issues/72170",
    "title": "System.Text.Json metadata writer does not check for property name conflicts"
  },
  {
    "author": "ithline",
    "labels": [
      "bug",
      "area-System.Text.Json",
      "source-generator"
    ],
    "createdAt": "2022-07-22T11:28:37Z",
    "body": "### Description\n\nSystem.Text.Json source generator fails to generate output when two or more classes derived from `JsonSerializerContext` share the same name, even though their full name is different.\n\n### Reproduction Steps\n\nDeclare two partial classes with nested `JsonSerializerContext` derived types with same name.\r\n\r\n```C#\r\npublic partial class ModelA\r\n{\r\n    [JsonSerializable(typeof(ModelA))]\r\n    private partial class SerializerContext : JsonSerializerContext\r\n    {\r\n    }\r\n}\r\n\r\npublic partial class ModelB\r\n{\r\n    [JsonSerializable(typeof(ModelB))]\r\n    private partial class SerializerContext : JsonSerializerContext\r\n    {\r\n    }\r\n}\r\n\r\n```\n\n### Expected behavior\n\nGenerator creates code for both types.\n\n### Actual behavior\n\nGenerator fails with the following message in visual studio\r\n\r\n`Generator 'JsonSourceGenerator' failed to generate source. It will not contribute to the output and compilation errors may occur as a result. Exception was of type 'ArgumentException' with message 'The hintName 'SerializerContext.g.cs' of the added source file must be unique within a generator.\r\nParameter name: hintName'\r\nGenerator threw the following exception:\r\n'System.ArgumentException: The hintName 'SerializerContext.g.cs' of the added source file must be unique within a generator.\r\nParameter name: hintName\r\n   at Microsoft.CodeAnalysis.AdditionalSourcesCollection.Add(String hintName, SourceText source)\r\n   at System.Text.Json.SourceGeneration.JsonSourceGenerator.Emitter.AddSource(String fileName, String source, Boolean isRootContextDef)\r\n   at System.Text.Json.SourceGeneration.JsonSourceGenerator.Emitter.Emit()\r\n   at System.Text.Json.SourceGeneration.JsonSourceGenerator.Execute(Compilation compilation, ImmutableArray``1 contextClasses, SourceProductionContext sourceProductionContext)\r\n   at System.Text.Json.SourceGeneration.JsonSourceGenerator.<Initialize>b__2_3(SourceProductionContext spc, ValueTuple``2 source)\r\n   at Microsoft.CodeAnalysis.UserFunctionExtensions.<>c__DisplayClass3_0``2.<WrapUserAction>b__0(TInput1 input1, TInput2 input2, CancellationToken token)'.`\n\n### Regression?\n\n_No response_\n\n### Known Workarounds\n\nRename serializer context types that both have different names.\n\n### Configuration\n\n_No response_\n\n### Other information\n\n_No response_",
    "number": 72671,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-02-04T15:23:26Z",
          "user": "martincostello"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-07-22T09:42:36Z",
          "user": "RichardD2"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-01-28T05:07:00Z",
          "user": "RenderMichael"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-05-11T18:12:02Z",
          "user": "AliveDevil"
        }
      ],
      "totalCount": 4,
      "endCursor": "Y3Vyc29yOnYyOpHODCQSPw=="
    },
    "updatedAt": "2025-08-04T08:15:55Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\n### Description\n\nSystem.Text.Json source generator fails to generate output when two or more classes derived from `JsonSerializerContext` share the same name, even though their full name is different.\n\n### Reproduction Steps\n\nDeclare two partial classes with nested `JsonSerializerContext` derived types with same name.\r\n\r\n```C#\r\npublic partial class ModelA\r\n{\r\n    [JsonSerializable(typeof(ModelA))]\r\n    private partial class SerializerContext : JsonSerializerContext\r\n    {\r\n    }\r\n}\r\n\r\npublic partial class ModelB\r\n{\r\n    [JsonSerializable(typeof(ModelB))]\r\n    private partial class SerializerContext : JsonSerializerContext\r\n    {\r\n    }\r\n}\r\n\r\n```\n\n### Expected behavior\n\nGenerator creates code for both types.\n\n### Actual behavior\n\nGenerator fails with the following message in visual studio\r\n\r\n`Generator 'JsonSourceGenerator' failed to generate source. It will not contribute to the output and compilation errors may occur as a result. Exception was of type 'ArgumentException' with message 'The hintName 'SerializerContext.g.cs' of the added source file must be unique within a generator.\r\nParameter name: hintName'\r\nGenerator threw the following exception:\r\n'System.ArgumentException: The hintName 'SerializerContext.g.cs' of the added source file must be unique within a generator.\r\nParameter name: hintName\r\n   at Microsoft.CodeAnalysis.AdditionalSourcesCollection.Add(String hintName, SourceText source)\r\n   at System.Text.Json.SourceGeneration.JsonSourceGenerator.Emitter.AddSource(String fileName, String source, Boolean isRootContextDef)\r\n   at System.Text.Json.SourceGeneration.JsonSourceGenerator.Emitter.Emit()\r\n   at System.Text.Json.SourceGeneration.JsonSourceGenerator.Execute(Compilation compilation, ImmutableArray``1 contextClasses, SourceProductionContext sourceProductionContext)\r\n   at System.Text.Json.SourceGeneration.JsonSourceGenerator.<Initialize>b__2_3(SourceProductionContext spc, ValueTuple``2 source)\r\n   at Microsoft.CodeAnalysis.UserFunctionExtensions.<>c__DisplayClass3_0``2.<WrapUserAction>b__0(TInput1 input1, TInput2 input2, CancellationToken token)'.`\n\n### Regression?\n\n_No response_\n\n### Known Workarounds\n\nRename serializer context types that both have different names.\n\n### Configuration\n\n_No response_\n\n### Other information\n\n_No response_\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>ithline</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`area-System.Text.Json`, `untriaged`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2022-07-22T11:28:48Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-07-22T11:28:48Z",
          "id": "IC_kwDODI9FZc5HE7xL"
        },
        {
          "author": "eiriktsarpalis",
          "body": "I don't think we should be incorporating the type's full name in the generated source file by default, since that would deviate from established naming conventions when authoring partial classes. We might want to investigate if the `hintName` parameter in Roslyn's `SourceProductionContext` supports path names (i.e. `Path/To/Namespace/SerializerContext.g.cs`) but that should only kick in if duplicates are detected.\r\n\r\nIn the meantime, the suggested workaround would be to use unique context names or refactor into two separate projects.",
          "createdAt": "2022-07-25T08:43:22Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-07-25T08:43:22Z",
          "id": "IC_kwDODI9FZc5HJ1Rq"
        },
        {
          "author": "ithline",
          "body": "Well name of the nested class is `ModelA+SerializerContext`, I don't see why that couldn't be used as name of the generated source file (replacing `+` with `.`)?\r\n\r\nLogging generator does not have this problem as it generates all it's output into single file, maybe this could be another long-term solution.",
          "createdAt": "2022-07-25T10:31:37Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-07-25T10:31:37Z",
          "id": "IC_kwDODI9FZc5HKP4J"
        },
        {
          "author": "eiriktsarpalis",
          "body": "> Well name of the nested class is ModelA+SerializerContext, I don't see why that couldn't be used as name of the generated source file (replacing + with .)?\r\n\r\nPerhaps, but that would not address conflicts located in different namespaces.\r\n\r\n> Logging generator does not have this problem as it generates all it's output into single file, maybe this could be another long-term solution.\r\n\r\nThat wouldn't be compatible with the `JsonSerializerContext` model, unfortunately.",
          "createdAt": "2022-07-25T10:44:55Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-07-25T11:43:14Z",
                "user": "ithline"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOCoTdAQ=="
          },
          "updatedAt": "2022-07-25T10:44:55Z",
          "id": "IC_kwDODI9FZc5HKTfS"
        },
        {
          "author": "martincostello",
          "body": "Just hit this myself in a test project where I was using nested private classes in different test classes to create a `JsonSerializerContext` to use with specific existing test code. Even though the classes being tested and serialized have different names, having the same context class name causes compilation to fail as they both try to generate the same source for `string`.\r\n\r\n```csharp\r\npublic static partial class A\r\n{\r\n    private class TestClassA\r\n    {\r\n        public string Value { get; set; }\r\n    }\r\n\r\n    [JsonSerializable(typeof(TestClassA))]\r\n    private sealed partial class TestJsonSerializerContext : JsonSerializerContext\r\n    {\r\n    }\r\n}\r\n\r\npublic static partial class B\r\n{\r\n    private class TestClassB\r\n    {\r\n        public string Value { get; set; }\r\n    }\r\n\r\n    [JsonSerializable(typeof(TestClassB))]\r\n    private sealed partial class TestJsonSerializerContext : JsonSerializerContext\r\n    {\r\n    }\r\n}\r\n```\r\n\r\n```text\r\nGenerator 'JsonSourceGenerator' failed to generate source. It will not contribute to the output and compilation errors may occur as a result. Exception was of type 'ArgumentException' with message 'The hintName 'TestJsonSerializerContext.String.g.cs' of the added source file must be unique within a generator.\r\nParameter name: hintName'.\r\nSystem.ArgumentException: The hintName 'TestJsonSerializerContext.String.g.cs' of the added source file must be unique within a generator.\r\nParameter name: hintName\r\n   at Microsoft.CodeAnalysis.AdditionalSourcesCollection.Add(String hintName, SourceText source)\r\n   at Microsoft.CodeAnalysis.SourceOutputNode`1.AppendOutputs(IncrementalExecutionContext context, CancellationToken cancellationToken)\r\n```",
          "createdAt": "2024-02-04T15:29:38Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-02-04T15:29:38Z",
          "id": "IC_kwDODI9FZc5yyUvV"
        },
        {
          "author": "eiriktsarpalis",
          "body": "We should try to improve the naming scheme for generated source files so that conflicts like this are less likely. ",
          "createdAt": "2024-02-05T14:32:17Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-02-05T14:54:43Z",
                "user": "martincostello"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHODVhI9A=="
          },
          "updatedAt": "2024-02-05T14:32:17Z",
          "id": "IC_kwDODI9FZc5y3clM"
        },
        {
          "author": "ilonatommy",
          "body": "Reported recently in VS as breaking hot reload: [VS community issue](https://developercommunity.visualstudio.com/t/Blazor-WASM-HotReload-Unexpected-error/10940326).",
          "createdAt": "2025-08-04T08:15:55Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-08-04T08:15:55Z",
          "id": "IC_kwDODI9FZc67uuaW"
        }
      ],
      "totalCount": 7,
      "endCursor": "Y3Vyc29yOnYyOpHOu7rmlg=="
    },
    "url": "https://github.com/dotnet/runtime/issues/72671",
    "title": "STJ source generator fails when two JsonSerializerContext derived types have same name in project"
  },
  {
    "author": "jhartmann123",
    "labels": [
      "api-suggestion",
      "area-System.Text.Json"
    ],
    "createdAt": "2022-07-27T13:01:56Z",
    "body": "### Background and motivation\r\n\r\nWith the introduction of generic attributes, some attributes in `System.Text.Json.Serialization` are good candidates for generic versions, as all public constructors require a type parameter, namely:\r\n\r\n- `JsonConverterAttribute`\r\n- `JsonDerivedTypeAttribute` (introduced in #63747)\r\n\r\n### API Proposal\r\n\r\n```csharp\r\nnamespace System.Text.Json\r\n\r\npublic class JsonConverterAttribute<T> : JsonConverterAttribute\r\n{\r\n    public JsonConverterAttribute() : base(typeof(T))\r\n    { }\r\n}\r\n\r\npublic class JsonDerivedTypeAttribute<T> : JsonDerivedTypeAttribute\r\n{\r\n    public JsonDerivedTypeAttribute() : base(typeof(T))\r\n    { }\r\n\r\n    public JsonDerivedTypeAttribute(string typeDiscriminator) : base(typeof(T), typeDiscriminator)\r\n    { }\r\n\r\n    public JsonDerivedTypeAttribute(int typeDiscriminator) : base(typeof(T), typeDiscriminator)\r\n    { }\r\n}\r\n```\r\n\r\n\r\n### API Usage\r\n\r\n```csharp\r\n[JsonDerivedType<Derived>()]\r\npublic class Base\r\n{\r\n    public int X { get; set; }\r\n}\r\n\r\npublic class Derived : Base\r\n{\r\n    public int Y { get; set; }\r\n}\r\n```\r\n\r\n\r\n### Alternative Designs\r\n\r\n_No response_\r\n\r\n### Risks\r\n\r\n_No response_",
    "number": 72936,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-09-26T14:48:37Z",
          "user": "IEvangelist"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-02-19T10:50:49Z",
          "user": "KennethHoff"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-04-17T20:18:23Z",
          "user": "JZO001"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-05-13T00:18:59Z",
          "user": "aradalvand"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-09-15T07:31:15Z",
          "user": "space-alien"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-09-17T20:23:45Z",
          "user": "N0D4N"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-12-19T09:57:20Z",
          "user": "WeihanLi"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-03-17T05:37:53Z",
          "user": "kzu"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-06-05T14:47:22Z",
          "user": "Dreamescaper"
        },
        {
          "content": "EYES",
          "createdAt": "2024-09-18T20:28:32Z",
          "user": "veikkoeeva"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-11-05T03:37:39Z",
          "user": "MitchRazga"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-09-03T08:03:49Z",
          "user": "jeremia"
        }
      ],
      "totalCount": 12,
      "endCursor": "Y3Vyc29yOnYyOpHODOFnag=="
    },
    "updatedAt": "2023-10-06T20:06:05Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\n### Background and motivation\n\nWith the introduction of generic attributes, some attributes `System.Text.Json.Serialization` are good candidates for generic generic versions, as all public constructors require a type parameter, namely:\r\n\r\n- `JsonConverterAttribute`\r\n- `JsonDerivedTypeAttribute` (introduced in #63747)\n\n### API Proposal\n\n```csharp\r\nnamespace System.Text.Json\r\n\r\npublic class JsonConverterAttribute<T> : JsonConverterAttribute\r\n{\r\n    public JsonConverterAttribute() : base(typeof(T))\r\n    { }\r\n}\r\n\r\npublic class JsonDerivedTypeAttribute<T> : JsonDerivedTypeAttribute\r\n{\r\n    public JsonDerivedTypeAttribute() : base(typeof(T))\r\n    { }\r\n\r\n    public JsonDerivedTypeAttribute(string typeDiscriminator) : base(typeof(T), typeDiscriminator)\r\n    { }\r\n\r\n    public JsonDerivedTypeAttribute(int typeDiscriminator) : base(typeof(T), typeDiscriminator)\r\n    { }\r\n}\r\n```\r\n\n\n### API Usage\n\n```csharp\r\n[JsonDerivedType<Derived>()]\r\npublic class Base\r\n{\r\n    public int X { get; set; }\r\n}\r\n\r\npublic class Derived : Base\r\n{\r\n    public int Y { get; set; }\r\n}\r\n```\r\n\n\n### Alternative Designs\n\n_No response_\n\n### Risks\n\n_No response_\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>jhartmann123</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`api-suggestion`, `area-System.Text.Json`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2022-07-27T13:02:11Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-07-27T13:02:11Z",
          "id": "IC_kwDODI9FZc5HVGob"
        },
        {
          "author": "PaulusParssinen",
          "body": "I tried this for `JsonSerializableAttribute` here: https://github.com/dotnet/runtime/issues/71712",
          "createdAt": "2022-07-27T15:28:00Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-07-27T17:00:47Z",
                "user": "eiriktsarpalis"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOCo0pEg=="
          },
          "updatedAt": "2022-07-27T15:28:00Z",
          "id": "IC_kwDODI9FZc5HV2W5"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Closing as duplicate of #71712. See https://github.com/dotnet/runtime/issues/71712#issuecomment-1176445889 for a justification.",
          "createdAt": "2022-07-27T17:02:55Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-07-27T17:02:55Z",
          "id": "IC_kwDODI9FZc5HWYjY"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Reopening for consideration in the future.",
          "createdAt": "2022-09-26T14:48:00Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "HEART",
                "createdAt": "2022-09-26T14:48:48Z",
                "user": "IEvangelist"
              },
              {
                "content": "HEART",
                "createdAt": "2024-11-12T15:37:31Z",
                "user": "asser-dk"
              }
            ],
            "totalCount": 2,
            "endCursor": "Y3Vyc29yOnYyOpHOD6hKuA=="
          },
          "updatedAt": "2022-09-26T14:48:00Z",
          "id": "IC_kwDODI9FZc5K_epA"
        },
        {
          "author": "IEvangelist",
          "body": "Thanks for reconsidering this @eiriktsarpalis!",
          "createdAt": "2022-09-26T14:49:06Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-09-26T15:02:23Z",
                "user": "eiriktsarpalis"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-02-19T10:50:42Z",
                "user": "KennethHoff"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-12-19T09:57:40Z",
                "user": "WeihanLi"
              }
            ],
            "totalCount": 3,
            "endCursor": "Y3Vyc29yOnYyOpHODQDQ0A=="
          },
          "updatedAt": "2022-09-26T14:49:06Z",
          "id": "IC_kwDODI9FZc5K_fAB"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Possible API shape:\r\n```C#\r\nnamespace System.Text.Json\r\n\r\npublic class JsonConverterAttribute<TConverter> : JsonConverterAttribute\r\n    where TConverter : JsonConverter\r\n{\r\n    public JsonConverterAttribute();\r\n}\r\n\r\npublic class JsonDerivedTypeAttribute<TDerivedType> : JsonDerivedTypeAttribute\r\n     where TDerivedType : class\r\n{\r\n    public JsonDerivedTypeAttribute();\r\n    public JsonDerivedTypeAttribute(string typeDiscriminator);\r\n    public JsonDerivedTypeAttribute(int typeDiscriminator);\r\n}\r\n\r\npublic class JsonSerializableAttribute<T> : JsonSerialiableAttribute\r\n{\r\n    public class JsonSerializableAttribute();\r\n}\r\n```",
          "createdAt": "2022-09-26T15:02:06Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-03-09T21:58:29Z",
                "user": "PaulusParssinen"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-05-13T00:19:22Z",
                "user": "aradalvand"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-12-19T09:58:00Z",
                "user": "WeihanLi"
              }
            ],
            "totalCount": 3,
            "endCursor": "Y3Vyc29yOnYyOpHODQDQ5w=="
          },
          "updatedAt": "2022-09-26T15:02:06Z",
          "id": "IC_kwDODI9FZc5K_jRF"
        },
        {
          "author": "aradalvand",
          "body": "It's strange this didn't make it to .NET 8 at least, given how trivial it would be to add.\r\n\r\nIt's the sort of thing you'd intuitively expect to be there at this point, since C# has supported generic attributes for a while now; it's always ugly to have `[SomeAttribute(typeof(SomeType)]` usages in general.",
          "createdAt": "2023-10-06T02:49:51Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-10-06T02:58:27Z",
          "id": "IC_kwDODI9FZc5oTYw1"
        },
        {
          "author": "eiriktsarpalis",
          "body": "> It's the sort of thing you'd intuitively expect to be there at this point, since C# has supported generic attributes for a while now; it's always ugly to have [SomeAttribute(typeof(SomeType)] usages in general.\r\n\r\nFrom a cost-benefit perspective adding generic variants of existing attributes introduces duplication while not offering a whole lot of benefit. Other than saving the need to type five characters, they mostly don't enhance type safety and they cannot be used in .NET languages that don't support generic attributes. We've kept this open for future consideration, although it doesn't register very high in our priorities for the time being.",
          "createdAt": "2023-10-06T08:02:21Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_DOWN",
                "createdAt": "2024-12-20T05:58:20Z",
                "user": "MitchRazga"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOD_v40g=="
          },
          "updatedAt": "2023-10-06T08:02:21Z",
          "id": "IC_kwDODI9FZc5oUUJr"
        },
        {
          "author": "aradalvand",
          "body": "> introduces duplication while not offering a whole lot of benefit.\r\n\r\nThis reasoning makes no sense; the \"duplication\" (if we can call it that) that it introduces is minimal and the benefit is just better syntax and ehanced type-safety.\r\n\r\n> they mostly don't enhance type safety\r\n\r\nThey do though, you can pass any type to the constructor of `JsonConverterAttribute` (e.g. `[JsonConverter(typeof(int))]`) while the generic version [would enforce](https://github.com/dotnet/runtime/issues/72936#issuecomment-1258173509) that it's a `JsonConverter`.",
          "createdAt": "2023-10-06T17:30:26Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-09-17T22:20:00Z",
                "user": "Stroniax"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHODyl6rw=="
          },
          "updatedAt": "2023-10-06T19:10:43Z",
          "id": "IC_kwDODI9FZc5oYJsV"
        },
        {
          "author": "eiriktsarpalis",
          "body": "> > they mostly don't enhance type safety\r\n> \r\n> They do though, you can pass any type to the constructor of `JsonConverterAttribute` (e.g. `[JsonConverter(typeof(int))]`) while the generic version [would enforce](https://github.com/dotnet/runtime/issues/72936#issuecomment-1258173509) that it's a `JsonConverter`.\r\n\r\nIt wouldn't do anything when it comes to enforcing the right converter type though, so I might be annotating a property of type `int` with a `JsonConverter<string>` and the generic attribute would be none the wiser. It's true that it would be rejecting `[JsonConverter<int>]` annotations, but that's just guarding against pathological inputs -- I don't see how it could enhance type safety in real terms.\r\n\r\nFWIW it's fairly straightforward to define generic attributes in your code, if you need them:\r\n```C#\r\npublic class MyPoco\r\n{\r\n    [JsonConverter<JsonStringEnumConverter>]\r\n    public BindingFlags Value { get; set; }\r\n}\r\n\r\npublic class JsonConverterAttribute<T>() : JsonConverterAttribute(typeof(T))\r\n    where T : JsonConverter\r\n{ }\r\n```",
          "createdAt": "2023-10-06T20:06:05Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-10-06T20:06:05Z",
          "id": "IC_kwDODI9FZc5oY3Cb"
        }
      ],
      "totalCount": 10,
      "endCursor": "Y3Vyc29yOnYyOpHOaGNwmw=="
    },
    "url": "https://github.com/dotnet/runtime/issues/72936",
    "title": "[API Proposal]: Add generic versions of System.Text.Json.Serialization attributes"
  },
  {
    "author": "teo-tsirpanis",
    "labels": [
      "api-suggestion",
      "area-System.Text.Json",
      "linkable-framework"
    ],
    "createdAt": "2022-07-31T15:02:13Z",
    "body": "### Background and motivation\n\nUsing custom JSON converters that derive from `JsonConverterFactory` such as `JsonStringEnumConverter` does not always play well with AOT technologies even if we use the source generator. Consider the following code:\r\n\r\n``` csharp\r\nConsole.WriteLine(JsonSerializer.Deserialize<MyEnum>(\"\\\"A\\\"\", MyJsonContext.Default.MyEnum));\r\n\r\n[JsonSerializable(typeof(MyEnum))]\r\ninternal partial class MyJsonContext : JsonSerializerContext { }\r\n\r\n[JsonConverter(typeof(JsonStringEnumConverter))]\r\npublic enum MyEnum { A, B }\r\n```\r\n\r\nWhen compiled under NativeAOT, it will warn that `Using member 'System.Text.Json.Serialization.JsonStringEnumConverter.JsonStringEnumConverter()' which has 'RequiresDynamicCodeAttribute' can break functionality when AOT compiling. JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.`.\r\n\r\nWhen ran under NativeAOT it will throw a `System.Reflection.MissingMetadataException: 'System.Text.Json.Serialization.Converters.EnumConverter<MyEnum>' is missing metadata.`. Fixing it needs fiddling with `rd.xml` files.\r\n\r\nThe reason for these failures is that there is not a continuous sequence of generic method calls from the source generator up until the creation of the `EnumConverter`, making the NativeAOT compiler's life difficult. The source-generated code calls `new JsonStringEnumConverter().CreateConverter(typeof(MyEnum), …)`, which calls `EnumConverterFactory.Create(typeof(MyEnum), …)`, [which uses the infamous `Type.MakeGenericType` to instantiate `EnumConverter<MyEnum>`](https://github.com/dotnet/runtime/blob/ec5e8b5fac0ca3524c01b826a048b0b293b63a7d/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/Converters/Value/EnumConverterFactory.cs#L34).\r\n\r\nWe can avoid the dynamic type instantiation if we had a way to pass the type in the converter factory through a generic, which is what I am proposing.\n\n### API Proposal\n\nThe JSON source generator will be taught so that if it sees a `[JsonConverterAttribute(typeof(TConverter))]` on a type `T` or a member of type `T` where `TConverter` has a static method with one generic parameter that accepts a `JsonSerializerOptions` and returns a `JsonConverter`, instead of emitting the equivalent of `new TConverter().CreateConverter(typeof(T), Options)`, it would emit `TConverter.CreateConverter<T>(Options)`.\r\n\r\nHere's how `JsonStringEnumConverter` would be updated:\r\n\r\n```csharp\r\nnamespace System.Text.Json;\r\n\r\npublic class JsonStringEnumConverter\r\n{\r\n    public static JsonConverter CreateConverter<T>(JsonSerializerOptions options) where T : struct, Enum;\r\n}\r\n```\n\n### API Usage\n\nThe API is intended to be used by source-generated code as described above.\n\n### Alternative Designs\n\n* My first thought was to add an instance `JsonConverter CreateConverter<T>(JsonSerializerOptions options)` method to `JsonConverterFactory` but I realized mid-typing that `EnumConverter<T>` has generic constraints which cannot be bridged until dotnet/csharplang#6308 is implemented.\r\n* If the scenario is not widely applicable, we could make a solution specific to enums by adding an overload to `JsonMetadataServices.GetEnumConverter` that allows specifying whether we want to handle enums as strings, and teaching the source generator to emit a call to this when `JsonStringEnumConverter` is applied.\n\n### Risks\n\n_No response_",
    "number": 73124,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "HEART",
          "createdAt": "2022-08-01T00:28:39Z",
          "user": "MichalStrehovsky"
        },
        {
          "content": "HEART",
          "createdAt": "2022-10-24T14:51:39Z",
          "user": "kamyker"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-10-24T14:51:45Z",
          "user": "kamyker"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-06-20T01:07:07Z",
          "user": "almostchristian"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-07-10T19:36:38Z",
          "user": "mtone"
        }
      ],
      "totalCount": 5,
      "endCursor": "Y3Vyc29yOnYyOpHOCxOB8g=="
    },
    "updatedAt": "2024-08-02T09:39:50Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\n### Background and motivation\n\nUsing custom JSON converters that derive from `JsonConverterFactory` such as `JsonStringEnumConverter` does not always play well with AOT technologies even if we use the source generator. Consider the following code:\r\n\r\n``` csharp\r\nConsole.WriteLine(JsonSerializer.Deserialize<MyEnum>(\"\\\"A\\\"\", MyJsonContext.Default.MyEnum));\r\n\r\n[JsonSerializable(typeof(MyEnum))]\r\ninternal partial class MyJsonContext : JsonSerializerContext { }\r\n\r\n[JsonConverter(typeof(JsonStringEnumConverter))]\r\npublic enum MyEnum { A, B }\r\n```\r\n\r\nWhen compiled under NativeAOT, it will warn that `Using member 'System.Text.Json.Serialization.JsonStringEnumConverter.JsonStringEnumConverter()' which has 'RequiresDynamicCodeAttribute' can break functionality when AOT compiling. JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.`.\r\n\r\nWhen ran under NativeAOT it will throw a `System.Reflection.MissingMetadataException: 'System.Text.Json.Serialization.Converters.EnumConverter<MyEnum>' is missing metadata.`. Fixing it needs fiddling with `rd.xml` files.\r\n\r\nThe reason for these failures is that there is not a continuous sequence of generic method calls from the source generator up until the creation of the `EnumConverter`, making the NativeAOT compiler's life difficult. The source-generated code calls `new JsonStringEnumConverter().CreateConverter(typeof(MyEnum), …)`, which calls `EnumConverterFactory.Create(typeof(MyEnum), …)`, [which uses the infamous `Type.MakeGenericType` to instantiate `EnumConverter<MyEnum>`](https://github.com/dotnet/runtime/blob/ec5e8b5fac0ca3524c01b826a048b0b293b63a7d/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/Converters/Value/EnumConverterFactory.cs#L34).\r\n\r\nWe can avoid the dynamic type instantiation if we had a way to pass the type in the converter factory through a generic, which is what I am proposing.\n\n### API Proposal\n\nThe JSON source generator will be taught so that if it sees a `[JsonConverterAttribute(typeof(TConverter))]` on a type `T` or a member of type `T` where `TConverter` has a static method with one generic parameter that accepts a `JsonSerializerOptions` and returns a `JsonConverter`, instead of emitting the equivalent of `new TConverter().CreateConverter(typeof(T), Options)`, it would emit `TConverter.CreateConverter<T>(Options)`.\r\n\r\nHere's how `JsonStringEnumConverter` would be updated:\r\n\r\n```csharp\r\nnamespace System.Text.Json;\r\n\r\npublic class JsonStringEnumConverter\r\n{\r\n    public static JsonConverter CreateConverter<T>(JsonSerializerOptions options) where T : struct, Enum;\r\n}\r\n```\n\n### API Usage\n\nThe API is intended to be used by source-generated code as described above.\n\n### Alternative Designs\n\n* My first thought was to add an instance `JsonConverter CreateConverter<T>(JsonSerializerOptions options)` method to `JsonConverterFactory` but I realized mid-typing that `EnumConverter<T>` has generic constraints which cannot be bridged until dotnet/csharplang#6308 is implemented.\r\n* If the scenario is not widely applicable, we could make a solution specific to enums by adding an overload to `JsonMetadataServices.GetEnumConverter` that allows specifying whether we want to handle enums as strings, and teaching the source generator to emit a call to this when `JsonStringEnumConverter` is applied.\n\n### Risks\n\n_No response_\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>teo-tsirpanis</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`api-suggestion`, `area-System.Text.Json`, `untriaged`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2022-07-31T15:02:24Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-07-31T15:02:24Z",
          "id": "IC_kwDODI9FZc5HjUsg"
        },
        {
          "author": "eiriktsarpalis",
          "body": "You're correct to point out that `JsonConverterFactory` isn't particularly AOT-friendly when used in conjunction with generics, but the problem cannot be addressed simply by adding a generic factory method. As you mention there is the problem of generic constraints, but there's also other problems; for example, collection converters must know [both the type of the collection _and_ the type of the element](https://github.com/dotnet/runtime/blob/f1de614c74589fe8f682dda39889d189f2522504/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/Converters/Collection/IAsyncEnumerableConverterFactory.cs#L25-L33). And this can grow in complexity to an arbitrary extent, e.g. consider [dictionary type converters](https://github.com/dotnet/runtime/blob/f1de614c74589fe8f682dda39889d189f2522504/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/Converters/Collection/IEnumerableConverterFactory.cs#L193). This is a problem that cannot (at least in the case of .NET type systems) be overcome _without_ using reflection.\r\n\r\nThat being said, source generators very elegantly solve this problem, avoiding converter factories altogether and using [generic combinators acting on specific types](https://docs.microsoft.com/en-us/dotnet/api/system.text.json.serialization.metadata.jsonmetadataservices.createdictionaryinfo?view=net-6.0). This leads to added boilerplate, of course, but we can ignore that since it's all handled by the source generator.",
          "createdAt": "2022-08-01T13:27:53Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-08-01T13:27:53Z",
          "id": "IC_kwDODI9FZc5HmO_y"
        },
        {
          "author": "jkotas",
          "body": "> That being said, source generators very elegantly solve this problem, avoiding converter factories altogether and using [generic combinators acting on specific types](https://docs.microsoft.com/en-us/dotnet/api/system.text.json.serialization.metadata.jsonmetadataservices.createdictionaryinfo?view=net-6.0).\r\n\r\nI see we have `JsonMetadataServices.GetEnumConverter<T>`. How does one tell the source generator to use it for enum serialization?\r\n\r\nCan the source generator check for `JsonStringEnumConverter` and replace it with AOT friendly call to `JsonMetadataServices.GetEnumConverter<T>` to make the example at the top just work?",
          "createdAt": "2022-08-01T15:10:41Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-08-01T15:10:41Z",
          "id": "IC_kwDODI9FZc5HmuAC"
        },
        {
          "author": "teo-tsirpanis",
          "body": "`GetEnumConverter` will be used if we don't specify the custom converter attribute. The problem is that it does not support (de)serializing enums as strings. To support this we would need a new overload like `GetEnumConverter<T>(bool acceptStrings)`.",
          "createdAt": "2022-08-01T15:15:29Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-08-01T15:15:29Z",
          "id": "IC_kwDODI9FZc5HmvaM"
        },
        {
          "author": "jkotas",
          "body": "Ok, I understand that we are out-of-time to address this for .NET 7. We should look into doing something about this soon.\r\n\r\nThe current experience is sub-par: The warning tells you to use Json source generation for AOT compatibility, but it is not actually possible to resolve the issue using Json source generation.",
          "createdAt": "2022-08-01T15:39:52Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-08-01T15:39:52Z",
          "id": "IC_kwDODI9FZc5Hm2yp"
        },
        {
          "author": "eiriktsarpalis",
          "body": "> > That being said, source generators very elegantly solve this problem, avoiding converter factories altogether and using [generic combinators acting on specific types](https://docs.microsoft.com/en-us/dotnet/api/system.text.json.serialization.metadata.jsonmetadataservices.createdictionaryinfo?view=net-6.0).\r\n> \r\n> I see we have `JsonMetadataServices.GetEnumConverter<T>`. How does one tell the source generator to use it for enum serialization?\r\n> \r\n> Can the source generator check for `JsonStringEnumConverter` and replace it with AOT friendly call to `JsonMetadataServices.GetEnumConverter<T>` to make the example at the top just work?\r\n\r\nWe could do that, but fundamentally it is an ad-hoc solution that fixes the particular converter factory. Had I wanted to further customize enum serialization (e.g. by inheriting `JsonStringEnumConverter`) or, say, write a custom converter for generic arrays then it would still be impossible to make that work in AOT. `JsonConverterFactory` was not designed with such concerns in mind and it likely never will be able to address them in the general case. Which does makes me wonder whether there might be avenues to innovate and provide a replacement factory abstraction that is AOT friendly.\r\n\r\n> The current experience is sub-par: The warning tells you to use Json source generation for AOT compatibility, but it is not actually possible to resolve the issue using Json source generation.\r\n\r\nWe should provide a PR that provides a better warning specifically for the `JsonStringEnumConverter` constructor. It's the only custom converter factory we're exposing so we don't need to change a lot.",
          "createdAt": "2022-08-01T16:11:14Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-08-01T16:11:14Z",
          "id": "IC_kwDODI9FZc5HnAtE"
        },
        {
          "author": "eiriktsarpalis",
          "body": "I see a couple of components to be addressed in this issue:\r\n\r\n1. An AOT-friendly pattern that supersedes `JsonConverterFactory`, this is obviously more long term.\r\n2. Adding hardcoded support for `JsonStringEnumConverter`, which is pretty common in most serialization scenaria. Effectively we would have the source generator recognize & intercept `[JsonConverter(typeof(JsonStringEnumConverter))]` declarations and replace them with a call to a new `JsonMetadataServices.GetStringEnumConverter<T>` method which should at least serve to unblock that particular use case.",
          "createdAt": "2022-09-29T17:46:49Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-12-06T22:20:08Z",
                "user": "layomia"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-07-21T12:37:38Z",
                "user": "aligin"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-01-22T21:40:39Z",
                "user": "davidruhmann"
              }
            ],
            "totalCount": 3,
            "endCursor": "Y3Vyc29yOnYyOpHODTorog=="
          },
          "updatedAt": "2022-09-29T17:46:49Z",
          "id": "IC_kwDODI9FZc5LQeCd"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Leaving at 8.0.0 so that we at least address point number 2.",
          "createdAt": "2022-09-29T17:47:16Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-09-29T17:47:16Z",
          "id": "IC_kwDODI9FZc5LQeJU"
        },
        {
          "author": null,
          "body": "Tagging subscribers to 'linkable-framework': @eerhardt, @vitek-karas, @LakshanF, @sbomer, @joperezr\nSee info in area-owners.md if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\n### Background and motivation\n\nUsing custom JSON converters that derive from `JsonConverterFactory` such as `JsonStringEnumConverter` does not always play well with AOT technologies even if we use the source generator. Consider the following code:\r\n\r\n``` csharp\r\nConsole.WriteLine(JsonSerializer.Deserialize<MyEnum>(\"\\\"A\\\"\", MyJsonContext.Default.MyEnum));\r\n\r\n[JsonSerializable(typeof(MyEnum))]\r\ninternal partial class MyJsonContext : JsonSerializerContext { }\r\n\r\n[JsonConverter(typeof(JsonStringEnumConverter))]\r\npublic enum MyEnum { A, B }\r\n```\r\n\r\nWhen compiled under NativeAOT, it will warn that `Using member 'System.Text.Json.Serialization.JsonStringEnumConverter.JsonStringEnumConverter()' which has 'RequiresDynamicCodeAttribute' can break functionality when AOT compiling. JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.`.\r\n\r\nWhen ran under NativeAOT it will throw a `System.Reflection.MissingMetadataException: 'System.Text.Json.Serialization.Converters.EnumConverter<MyEnum>' is missing metadata.`. Fixing it needs fiddling with `rd.xml` files.\r\n\r\nThe reason for these failures is that there is not a continuous sequence of generic method calls from the source generator up until the creation of the `EnumConverter`, making the NativeAOT compiler's life difficult. The source-generated code calls `new JsonStringEnumConverter().CreateConverter(typeof(MyEnum), …)`, which calls `EnumConverterFactory.Create(typeof(MyEnum), …)`, [which uses the infamous `Type.MakeGenericType` to instantiate `EnumConverter<MyEnum>`](https://github.com/dotnet/runtime/blob/ec5e8b5fac0ca3524c01b826a048b0b293b63a7d/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/Converters/Value/EnumConverterFactory.cs#L34).\r\n\r\nWe can avoid the dynamic type instantiation if we had a way to pass the type in the converter factory through a generic, which is what I am proposing.\n\n### API Proposal\n\nThe JSON source generator will be taught so that if it sees a `[JsonConverterAttribute(typeof(TConverter))]` on a type `T` or a member of type `T` where `TConverter` has a static method with one generic parameter that accepts a `JsonSerializerOptions` and returns a `JsonConverter`, instead of emitting the equivalent of `new TConverter().CreateConverter(typeof(T), Options)`, it would emit `TConverter.CreateConverter<T>(Options)`.\r\n\r\nHere's how `JsonStringEnumConverter` would be updated:\r\n\r\n```csharp\r\nnamespace System.Text.Json;\r\n\r\npublic class JsonStringEnumConverter\r\n{\r\n    public static JsonConverter CreateConverter<T>(JsonSerializerOptions options) where T : struct, Enum;\r\n}\r\n```\n\n### API Usage\n\nThe API is intended to be used by source-generated code as described above.\n\n### Alternative Designs\n\n* My first thought was to add an instance `JsonConverter CreateConverter<T>(JsonSerializerOptions options)` method to `JsonConverterFactory` but I realized mid-typing that `EnumConverter<T>` has generic constraints which cannot be bridged until dotnet/csharplang#6308 is implemented.\r\n* If the scenario is not widely applicable, we could make a solution specific to enums by adding an overload to `JsonMetadataServices.GetEnumConverter` that allows specifying whether we want to handle enums as strings, and teaching the source generator to emit a call to this when `JsonStringEnumConverter` is applied.\n\n### Risks\n\n_No response_\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>teo-tsirpanis</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`api-suggestion`, `area-System.Text.Json`, `linkable-framework`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>8.0.0</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2022-09-29T22:14:22Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-09-29T22:14:22Z",
          "id": "IC_kwDODI9FZc5LReHq"
        },
        {
          "author": "kamyker",
          "body": "> 'System.Text.Json.Serialization.Converters.EnumConverter<MyEnum>' is missing metadata.`. Fixing it needs fiddling with `rd.xml` files.\r\n\r\nSince this issue is linked in the compiler: what exactly has to be done to fix it in .NET 7?\r\n\r\n I'm trying:\r\n ```\r\n<Assembly Name=\"System.Text.Json\">\r\n<Type Name=\"System.Text.Json.Serialization.Converters.EnumConverter`1[[MyAssembly.MyNamespace.MyType]]\" Dynamic=\"Required All\" />\r\n</Assembly>\r\n ```\r\n But that gives error:\r\n ```\r\nFailed to load type 'MyAssembly.MyNamespace.MyType' from assembly 'System.Text.Json,\r\n```\r\n",
          "createdAt": "2022-10-24T16:32:09Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-10-24T16:33:10Z",
          "id": "IC_kwDODI9FZc5M2Q5A"
        },
        {
          "author": "eiriktsarpalis",
          "body": "@kamyker I would recommend creating a separate issue, including a minimal reproducing app we could take a look at.",
          "createdAt": "2022-10-24T16:35:21Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-10-24T16:35:21Z",
          "id": "IC_kwDODI9FZc5M2Ry3"
        },
        {
          "author": "kamyker",
          "body": "Nvm it has to be:\r\n```\r\n<Assembly Name=\"System.Text.Json\">\r\n<Type Name=\"System.Text.Json.Serialization.Converters.EnumConverter`1[[MyNamespace.MyType,MyAssembly]]\" Dynamic=\"Required All\" />\r\n</Assembly>\r\n```",
          "createdAt": "2022-10-24T18:24:06Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-10-24T18:24:19Z",
          "id": "IC_kwDODI9FZc5M2vyN"
        },
        {
          "author": "eiriktsarpalis",
          "body": "One possible solution might be to simply replace `JsonConverterFactory` usage with public generic converters:\r\n```C#\r\npublic class JsonStringEnumConverter<TEnum> : JsonConverter<TEnum>\r\n    where TEnum : struct, Enum\r\n{\r\n}\r\n```\r\nSo that type/property-level annotations effectively become linker/AOT-safe:\r\n```C#\r\n[JsonConverter(typeof(JsonStringEnumConverter<TEnum>)]\r\npublic enum MyEnum { A = 0, B = 1 }\r\n```\r\nMight be something to consider when designing the APIs for #63791.",
          "createdAt": "2022-11-04T11:01:09Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-11-04T11:01:09Z",
          "id": "IC_kwDODI9FZc5Nrkhe"
        },
        {
          "author": "layomia",
          "body": "We should design this feature with https://github.com/dotnet/runtime/issues/63791 in mind.",
          "createdAt": "2022-12-13T17:38:33Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-12-13T17:38:33Z",
          "id": "IC_kwDODI9FZc5Qa57r"
        },
        {
          "author": "eiriktsarpalis",
          "body": "I think the API most recently approved in https://github.com/dotnet/runtime/issues/79311#issuecomment-1579280774 is probably the best approach for this going forward. TL;DR we'll keep using the `JsonConverterFactory` abstraction but each instance would be capable of generating converters for a single type.",
          "createdAt": "2023-06-07T19:15:55Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-06-07T19:15:55Z",
          "id": "IC_kwDODI9FZc5eQddd"
        },
        {
          "author": "Abdragiz",
          "body": "Will it be possible to use any class derived from `JsonConverterFactory`, such as `GeoJsonConverterFactory` from the [NetTopologySuite.IO.GeoJSON4STJ](https://github.com/NetTopologySuite/NetTopologySuite.IO.GeoJSON/tree/develop?tab=readme-ov-file#geojson4stj-usage) NuGet package, in an AOT-friendly manner? Or will these modifications be specific only to `JsonStringEnumConverter`?",
          "createdAt": "2024-03-12T19:25:19Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-03-12T19:25:19Z",
          "id": "IC_kwDODI9FZc52wVTL"
        },
        {
          "author": "teo-tsirpanis",
          "body": "@Abdragiz I took a look at `GeoJsonConverterFactory` and it does not seem to be doing stuff that is unsupported in AOT, so it will likely work.",
          "createdAt": "2024-03-12T22:55:37Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-03-12T22:55:37Z",
          "id": "IC_kwDODI9FZc52xlOk"
        },
        {
          "author": "BDisp",
          "body": "I'm also having this issue with native AOT. Is there any solution?",
          "createdAt": "2024-08-01T17:21:30Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-08-01T17:21:30Z",
          "id": "IC_kwDODI9FZc6G63G5"
        },
        {
          "author": "eiriktsarpalis",
          "body": "@BDisp What we ended up doing in .NET 8 for `JsonStringEnumConverter` AOT support is exposing a [generic variant of the type](https://learn.microsoft.com/en-us/dotnet/api/system.text.json.serialization.jsonstringenumconverter-1?view=net-8.0). You could try emulating that approach, see [this article](https://learn.microsoft.com/en-us/dotnet/core/whats-new/dotnet-8/runtime#source-generator) for more details.",
          "createdAt": "2024-08-02T09:39:32Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-08-02T10:42:19Z",
                "user": "BDisp"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHODskXIg=="
          },
          "updatedAt": "2024-08-02T09:39:50Z",
          "id": "IC_kwDODI9FZc6HANq6"
        }
      ],
      "totalCount": 19,
      "endCursor": "Y3Vyc29yOnYyOpHOhwDaug=="
    },
    "url": "https://github.com/dotnet/runtime/issues/73124",
    "title": "[API Proposal]: A pattern for AOT-friendly source-generated `JsonConverterFactory`-based converters."
  },
  {
    "author": "eiriktsarpalis",
    "labels": [
      "enhancement",
      "area-System.Text.Json",
      "User Story",
      "Cost:L",
      "Team:Libraries"
    ],
    "createdAt": "2022-08-02T18:18:12Z",
    "body": "Currently, System.Text.Json suffers from a few consistency/reliability bugs when it comes to consuming attributes defined in virtual/shadowed property hierarchies. These also manifest as divergences between reflection-based and source generated contract resolution semantics. We should try to fix as many of these as possible and expand our test coverage in this space. It might be the case that we need to introduce strategic breaking changes if absolutely necessary.\r\n\r\nProvisional list of customer reported issues:\r\n\r\n- [ ] #51165\r\n- [ ] #50078\r\n- [ ] #59675\r\n- [ ] https://github.com/dotnet/runtime/issues/96996\r\n- [ ] https://github.com/dotnet/runtime/issues/98634\r\n- [x] https://github.com/dotnet/runtime/issues/97621\r\n- [x] #41749\r\n- [x] #66900\r\n- [x] #60082\r\n- [x] #63443\r\n- [x] #76268",
    "number": 73255,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-05-03T15:38:31Z",
          "user": "PingTKP"
        }
      ],
      "totalCount": 1,
      "endCursor": "Y3Vyc29yOnYyOpHOC3qejw=="
    },
    "updatedAt": "2024-02-19T12:19:54Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\nCurrently, System.Text.Json suffers from a few consistency/reliability bugs when it comes to consuming attributes defined in virtual/shadowed property hierarchies. These also manifest as divergences between reflection-based and source generated contract resolution semantics. We should try to fix as many of these as possible and expand our test coverage in this space. It might be the case that we need to introduce strategic breaking changes if absolutely necessary.\r\n\r\nProvisional list of customer reported issues:\r\n\r\n- #41749\r\n- #51165\r\n- #50078\r\n- #59675\r\n- #66900\r\n- #60082\r\n- #63443\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>eiriktsarpalis</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`area-System.Text.Json`, `User Story`, `Cost:L`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>8.0.0</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2022-08-02T18:18:29Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-08-02T18:18:29Z",
          "id": "IC_kwDODI9FZc5HtVGv"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Moving to Future as we won't be able to work on this for 8.0",
          "createdAt": "2023-01-23T17:53:09Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-01-23T17:53:09Z",
          "id": "IC_kwDODI9FZc5TfbCI"
        }
      ],
      "totalCount": 2,
      "endCursor": "Y3Vyc29yOnYyOpHOU32wiA=="
    },
    "url": "https://github.com/dotnet/runtime/issues/73255",
    "title": "System.Text.Json should handle attributes in virtual or shadowed properties consistently"
  },
  {
    "author": "mikegoatly",
    "labels": [
      "api-suggestion",
      "area-System.Text.Json",
      "source-generator"
    ],
    "createdAt": "2022-08-03T12:59:57Z",
    "body": "### Background and motivation\n\nI've been looking at enabling trimming for some of our projects now we've migrated to .NET 6, and have found the current design for configuring the supported types on a `JsonSerializerContext` to be quite cumbersome.\r\n\r\nSome of our projects have a reasonable, though not excessive, number of models that can be both serialized and deserialized from a third party API. This could be a single instance of the entity, or a list, which means that for every model we want to work with, we need to remember to decorate our context class as:\r\n\r\n``` csharp\r\n[JsonSerializable(typeof(Model1))]\r\n[JsonSerializable(typeof(IList<Model1>))]\r\n[JsonSerializable(typeof(Model2))]\r\n[JsonSerializable(typeof(IList<Model2>))]\r\n[JsonSerializable(typeof(Model3))]\r\n[JsonSerializable(typeof(IList<Model3>))]\r\ninternal partial class ThirdPartyModelSerializationContext : JsonSerializerContext\r\n{\r\n}\r\n```\r\n\r\nThe number of interaction points we have with the API will undoubtedly grow, and every time a new model is required, it's necessary to remember that there's another class somewhere that needs to have its list of attributes updated.\r\n\r\nIt the model class itself could be decorated with an attribute indicating the context that it needs to be part of, it would be much easier to remember, e.g.:\r\n\r\n``` csharp\r\ninternal partial class ThirdPartyModelSerializationContext : JsonSerializerContext\r\n{\r\n}\r\n\r\n[JsonSerializerContext(typeof(ThirdPartyModelSerializationContext)]\r\npublic class Model1\r\n{\r\n   /// ...\r\n}\r\n```\r\n\n\n### API Proposal\n\n```csharp\r\npublic sealed class JsonSerializerContextAttribute : JsonAttribute\r\n{\r\n    public JsonSerializerContextAttribute(Type jsonSerializerContextType, params Type[] additionalRootTypes);\r\n}\r\n```\r\n\n\n### API Usage\n\n``` csharp\r\n// Use the existing approach for the edge case where a model must *only* be serializable as part of a list and \r\n// serialization should throw an error if someone tries to serialize an entity outside of a list type\r\n[JsonSerializable(typeof(IList<Model3>))]\r\ninternal partial class ThirdPartyModelSerializationContext : JsonSerializerContext\r\n{\r\n}\r\n\r\n// A model that only is only ever (de)serialized as itself\r\n[JsonSerializerContext(typeof(ThirdPartyModelSerializationContext)]\r\npublic class Model1\r\n{\r\n   /// ...\r\n}\r\n\r\n// A model that could be deserialized as itself or a list\r\n[JsonSerializerContext(typeof(ThirdPartyModelSerializationContext), typeof(IList<Model2>)]\r\npublic class Model2\r\n{\r\n   /// ...\r\n}\r\n```\r\n\n\n### Alternative Designs\n\n_No response_\n\n### Risks\n\n_No response_",
    "number": 73297,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-08-14T19:09:45Z",
          "user": "mus65"
        }
      ],
      "totalCount": 1,
      "endCursor": "Y3Vyc29yOnYyOpHOC6MKmQ=="
    },
    "updatedAt": "2022-09-29T17:53:28Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\n### Background and motivation\n\nI've been looking at enabling trimming for some of our projects now we've migrated to .NET 6, and have found the current design for configuring the supported types on a `JsonSerializerContext` to be quite cumbersome.\r\n\r\nSome of our projects have a reasonable, though not excessive, number of models that can be both serialized and deserialized from a third party API. This could be a single instance of the entity, or a list, which means that for every model we want to work with, we need to remember to decorate our context class as:\r\n\r\n``` csharp\r\n[JsonSerializable(typeof(Model1))]\r\n[JsonSerializable(typeof(IList<Model1>))]\r\n[JsonSerializable(typeof(Model2))]\r\n[JsonSerializable(typeof(IList<Model2>))]\r\n[JsonSerializable(typeof(Model3))]\r\n[JsonSerializable(typeof(IList<Model3>))]\r\ninternal partial class ThirdPartyModelSerializationContext : JsonSerializerContext\r\n{\r\n}\r\n```\r\n\r\nThe number of interaction points we have with the API will undoubtedly grow, and every time a new model is required, it's necessary to remember that there's another class somewhere that needs to have its list of attributes updated.\r\n\r\nIt the model class itself could be decorated with an attribute indicating the context that it needs to be part of, it would be much easier to remember, e.g.:\r\n\r\n``` csharp\r\ninternal partial class ThirdPartyModelSerializationContext : JsonSerializerContext\r\n{\r\n}\r\n\r\n[JsonSerializerContext(typeof(ThirdPartyModelSerializationContext)]\r\npublic class Model1\r\n{\r\n   /// ...\r\n}\r\n```\r\n\n\n### API Proposal\n\n```csharp\r\npublic sealed class JsonSerializerContextAttribute : JsonAttribute\r\n{\r\n    public JsonSerializerContextAttribute(Type jsonSerializerContextType, params Type[] additionalRootTypes);\r\n}\r\n```\r\n\n\n### API Usage\n\n``` csharp\r\n// Use the existing approach for the edge case where a model must *only* be serializable as part of a list and \r\n// serialization should throw an error if someone tries to serialize an entity outside of a list type\r\n[JsonSerializable(typeof(IList<Model3>))]\r\ninternal partial class ThirdPartyModelSerializationContext : JsonSerializerContext\r\n{\r\n}\r\n\r\n// A model that only is only ever (de)serialized as itself\r\n[JsonSerializerContext(typeof(ThirdPartyModelSerializationContext)]\r\npublic class Model1\r\n{\r\n   /// ...\r\n}\r\n\r\n// A model that could be deserialized as itself or a list\r\n[JsonSerializerContext(typeof(ThirdPartyModelSerializationContext), typeof(IList<Model2>)]\r\npublic class Model2\r\n{\r\n   /// ...\r\n}\r\n```\r\n\n\n### Alternative Designs\n\n_No response_\n\n### Risks\n\n_No response_\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>mikegoatly</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`api-suggestion`, `area-System.Text.Json`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2022-08-03T13:00:10Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-08-03T13:00:10Z",
          "id": "IC_kwDODI9FZc5Hwldx"
        },
        {
          "author": "eiriktsarpalis",
          "body": "It might be something we might consider, that being said there are a couple of drawbacks with that approach:\r\n\r\n* The new attribute makes it possible to point to contexts not in the current project, which a source generator cannot support. It shouldn't be a huge issue assuming we detect this and provide a user friendly diagnostic explaining why this cannot work.\r\n* It might negatively impact performance of the source generator, since it will need to look for and aggregate attributes from more types than just `JsonSerializerContext`.\r\n\r\ncc @layomia @CyrusNajmabadi",
          "createdAt": "2022-08-03T13:48:18Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-08-03T15:39:55Z",
                "user": "mikegoatly"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOCp9fQQ=="
          },
          "updatedAt": "2022-08-03T13:48:18Z",
          "id": "IC_kwDODI9FZc5HwzVE"
        },
        {
          "author": "Sergio0694",
          "body": "> \"It might negatively impact performance of the source generator, since it will need to look for and aggregate attributes from more types\"\r\n\r\nThis can still be quite efficient on Roslyn 4.0 already (use `CreateSyntaxProvider` ([example](https://github.com/CommunityToolkit/dotnet/blob/96517eace88d95ec52a881e3e1ed74ea51436b40/CommunityToolkit.Mvvm.SourceGenerators/Input/RelayCommandGenerator.cs#L28)) filtering types with at least one attribute, then work on filtering those out), but especially with recent Roslyn versions there's now a new API specifically to look attributes up by fully qualified name in a very very fast way, see https://github.com/dotnet/roslyn/issues/54725 🙂",
          "createdAt": "2022-08-03T17:00:30Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-08-03T17:00:30Z",
          "id": "IC_kwDODI9FZc5HxyGo"
        }
      ],
      "totalCount": 3,
      "endCursor": "Y3Vyc29yOnYyOpHOR8chqA=="
    },
    "url": "https://github.com/dotnet/runtime/issues/73297",
    "title": "[API Proposal]: Allow C# models to be decorated with an attribute to indicate required code generation, not JsonSerializerContext"
  },
  {
    "author": "eiriktsarpalis",
    "labels": [
      "bug",
      "area-System.Text.Json"
    ],
    "createdAt": "2022-08-04T15:30:01Z",
    "body": "Consider the following code sample:\r\n```C#\r\nvar options = new JsonSerializerOptions\r\n{\r\n    TypeInfoResolver = new DefaultJsonTypeInfoResolver\r\n    {\r\n        Modifiers =\r\n        {\r\n            static typeInfo =>\r\n            {\r\n                if (typeInfo.Type == typeof(IEnumerable<int>))\r\n                {\r\n                    typeInfo.CreateObject = () => new int[50];\r\n                }\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\nvar result = JsonSerializer.Deserialize<IEnumerable<int>>(\"[]\");\r\nConsole.WriteLine(result is int[]); // Prints \"false\"\r\n```\r\nThis is because many collection converters are hardcoding their `CreateObject` implementation which ignores any user-defined delegates:\r\n\r\nhttps://github.com/dotnet/runtime/blob/02910b4a024ff9a1c53dcef3328579a2db471a94/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/Converters/Collection/IEnumerableOfTConverter.cs#L23-L31\r\n\r\nNote that this is currently not possible to fix unless we expose an API equivalent to the `JsonCollectionConverter.Add` method. For .NET 7 we should add detection for converters hardcoding `CreateObject`/`Add` implementations to specific types and have the `JsonTypeInfo.CreateObject` setter throw if not supported by the converter.\r\n\r\nRelated to #71944.",
    "number": 73382,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-12-16T20:56:10Z",
          "user": "krwq"
        }
      ],
      "totalCount": 1,
      "endCursor": "Y3Vyc29yOnYyOpHOCr6YDQ=="
    },
    "updatedAt": "2023-06-02T11:29:11Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\nConsider the following code sample:\r\n```C#\r\nvar options = new JsonSerializerOptions\r\n{\r\n    TypeInfoResolver = new DefaultJsonTypeInfoResolver\r\n    {\r\n        Modifiers =\r\n        {\r\n            static typeInfo =>\r\n            {\r\n                if (typeInfo.Type == typeof(IEnumerable<int>))\r\n                {\r\n                    typeInfo.CreateObject = () => new int[50];\r\n                }\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\nvar result = JsonSerializer.Deserialize<IEnumerable<int>>(\"[]\");\r\nConsole.WriteLine(result is int[]); // Prints \"false\"\r\n```\r\nThis is because many collection converters are hardcoding their `CreateObject` implementation which ignores any user-defined delegates:\r\n\r\nhttps://github.com/dotnet/runtime/blob/02910b4a024ff9a1c53dcef3328579a2db471a94/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/Converters/Collection/IEnumerableOfTConverter.cs#L23-L31\r\n\r\nNote that this is currently not possible to fix unless we expose an API equivalent to the `JsonCollectionConverter.Add` method. For .NET 7 we should add detection for converters hardcoding `CreateObject`/`Add` implementations to specific types and have the `JsonTypeInfo.CreateObject` setter throw if not supported by the converter.\r\n\r\nRelated to #71944.\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>eiriktsarpalis</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`bug`, `area-System.Text.Json`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>8.0.0</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2022-08-04T15:30:21Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-08-04T15:30:21Z",
          "id": "IC_kwDODI9FZc5H2Sin"
        }
      ],
      "totalCount": 1,
      "endCursor": "Y3Vyc29yOnYyOpHOR9kopw=="
    },
    "url": "https://github.com/dotnet/runtime/issues/73382",
    "title": "System.Text.Json contract customization ignoring custom `CreateObject` delegates in certain collection types"
  },
  {
    "author": "layomia",
    "labels": [
      "area-System.Text.Json",
      "test-enhancement"
    ],
    "createdAt": "2022-08-10T19:33:08Z",
    "body": "We've already started sharing these tests. They are located [here](https://github.com/dotnet/runtime/tree/main/src/libraries/System.Text.Json/tests/Common). We should complete this effort to ensure the same behavior where expected. The remaining tests to consolidate are located [here](https://github.com/dotnet/runtime/tree/main/src/libraries/System.Text.Json/tests/System.Text.Json.Tests/Serialization). Tests suites that have been shared derive from [`SerializerTests`](https://github.com/dotnet/runtime/blob/fa75057cd0d00571ee4c433b9fd8c6476966b9d1/src/libraries/System.Text.Json/tests/Common/SerializerTests.cs).\r\n\r\n**Remaining tests**\r\n\r\n- [ ] Array tests\r\n- [ ] Cache tests\r\n- [ ] Camel case unit tests\r\n- [ ] Continuation tests\r\n- [ ] Cyclic tests\r\n- [ ] DOM tests\r\n- [ ] Dynamic tests\r\n- [ ] EnumConverter tests\r\n- [ ] Enum tests\r\n- [ ] Exception tests\r\n- [ ] Invalid JSON tests\r\n- [ ] Invalid type tests\r\n- [ ] JsonDocument tests\r\n- [ ] JsonElementTests\r\n- [ ] JsonPolymorphismOptions tests\r\n- [ ] JsonSerializer API validation tests\r\n- [ ] Null tests\r\n- [ ] Nullable tests\r\n- [ ] Number handling tests\r\n- [ ] Object tests\r\n- [ ] On-serialize tests\r\n- [ ] Options tests\r\n- [ ] Polymorphic tests\r\n- [ ] Property name tests\r\n- [ ] Property order tests\r\n- [ ] Property visibility tests\r\n- [ ] Read scenario tests\r\n- [ ] Read value tests\r\n- [ ] Required keyword tests\r\n- [ ] Span tests\r\n- [ ] Stream tests\r\n- [ ] TypeInfo resolver functional tests\r\n- [ ] Unsupported types tests\r\n- [ ] Value tests\r\n- [ ] Write value tests",
    "number": 73714,
    "reactions": {
      "hasNextPage": false,
      "nodes": [],
      "totalCount": 0,
      "endCursor": null
    },
    "updatedAt": "2022-09-27T16:50:52Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\nWe've already started sharing these tests. They are located [here](https://github.com/dotnet/runtime/tree/main/src/libraries/System.Text.Json/tests/Common). We should complete this effort to ensure the same behavior where expected. The remaining tests to consolidate are located [here](https://github.com/dotnet/runtime/tree/main/src/libraries/System.Text.Json/tests/System.Text.Json.Tests/Serialization). Tests suites that have been shared derive from [`SerializerTests`](https://github.com/dotnet/runtime/blob/fa75057cd0d00571ee4c433b9fd8c6476966b9d1/src/libraries/System.Text.Json/tests/Common/SerializerTests.cs).\r\n\r\n**Remaining tests**\r\n\r\n- [ ] Array tests\r\n- [ ] Cache tests\r\n- [ ] Camel case unit tests\r\n- [ ] Continuation tests\r\n- [ ] Cyclic tests\r\n- [ ] DOM tests\r\n- [ ] Dynamic tests\r\n- [ ] EnumConverter tests\r\n- [ ] Enum tests\r\n- [ ] Exception tests\r\n- [ ] Invalid JSON tests\r\n- [ ] Invalid type tests\r\n- [ ] JsonDocument tests\r\n- [ ] JsonElementTests\r\n- [ ] JsonPolymorphismOptions tests\r\n- [ ] JsonSerializer API validation tests\r\n- [ ] Null tests\r\n- [ ] Nullable tests\r\n- [ ] Number handling tests\r\n- [ ] Object tests\r\n- [ ] On-serialize tests\r\n- [ ] Options tests\r\n- [ ] Polymorphic tests\r\n- [ ] Property name tests\r\n- [ ] Property order tests\r\n- [ ] Property visibility tests\r\n- [ ] Read scenario tests\r\n- [ ] Read value tests\r\n- [ ] Required keyword tests\r\n- [ ] Span tests\r\n- [ ] Stream tests\r\n- [ ] TypeInfo resolver functional tests\r\n- [ ] Unsupported types tests\r\n- [ ] Value tests\r\n- [ ] Write value tests\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>layomia</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`area-System.Text.Json`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>8.0.0</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2022-08-10T19:33:17Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-08-10T19:33:17Z",
          "id": "IC_kwDODI9FZc5IMRuR"
        }
      ],
      "totalCount": 1,
      "endCursor": "Y3Vyc29yOnYyOpHOSDEbkQ=="
    },
    "url": "https://github.com/dotnet/runtime/issues/73714",
    "title": "Share serialization tests between source-gen and reflection JsonSerializer"
  },
  {
    "author": "hansmbakker",
    "labels": [
      "api-suggestion",
      "area-System.Text.Json",
      "wishlist"
    ],
    "createdAt": "2022-08-18T22:31:12Z",
    "body": "### Background and motivation\r\n\r\n[Kotlin / Gson supports an `alternate` name for json properties](https://github.com/google/gson/issues/639), which can be convenient to allow deserializing similar json to a unified class object.\r\n\r\nCurrently, `JsonPropertyNameAttribute` does not have support for this, and it is not possible to specify multiple instances of `JsonPropertyNameAttribute`.\r\n\r\nHaving this would remove the need for writing a custom JsonConverter for this case.\r\n\r\nNote: this is **only about deserialization** - serialization will always use the default `name` value.\r\n\r\n### API Proposal\r\n\r\n```csharp\r\nnamespace System.Text.Json.Serialization\r\n{\r\n    /// <summary>\r\n    /// Specifies the property name that is present in the JSON when serializing and deserializing.\r\n    /// This overrides any naming policy specified by <see cref=\"JsonNamingPolicy\"/>.\r\n    /// </summary>\r\n    [AttributeUsage(AttributeTargets.Property | AttributeTargets.Field, AllowMultiple = false)]\r\n    public sealed class JsonPropertyNameAttribute : JsonAttribute\r\n    {\r\n        /// <summary>\r\n        /// Initializes a new instance of <see cref=\"JsonPropertyNameAttribute\"/> with the specified property name.\r\n        /// </summary>\r\n        /// <param name=\"name\">The name of the property.</param>\r\n        public JsonPropertyNameAttribute(string name)\r\n        {\r\n            Name = name;\r\n        }\r\n\r\n        /// <summary>\r\n        /// Initializes a new instance of <see cref=\"JsonPropertyNameAttribute\"/> with the specified property name\r\n        /// and alternative property names for deserialization.\r\n        /// </summary>\r\n        /// <param name=\"name\">The name of the property.</param>\r\n        /// <param name=\"alternatives\">The alternative names of the property.</param>\r\n        public JsonPropertyNameAttribute(string name, string[] alternatives)\r\n        {\r\n            Name = name;\r\n            Alternatives = alternative;\r\n        }\r\n\r\n        /// <summary>\r\n        /// The name of the property.\r\n        /// </summary>\r\n        public string Name { get; }\r\n\r\n        /// <summary>\r\n        /// The alternative names of the property.\r\n        /// </summary>\r\n        /// <remarks>\r\n        /// Is only used for deserialization\r\n        /// </remarks>\r\n        public string[] Alternatives { get; }\r\n    }\r\n}\r\n```\r\n\r\n\r\n### API Usage\r\n\r\n```csharp\r\npublic class Test\r\n{\r\n   [JsonPropertyName(\"property\", alternatives = { \"oldPropertyNameForBackwardsCompatibility\" })]\r\n   public string Property { get; set; }\r\n}\r\n```\r\n\r\n\r\n### Alternative Designs\r\n\r\n_No response_\r\n\r\n### Risks\r\n\r\nWhile I would say having a clean json response from an API would be better, one does not always have control over the responses of the API.",
    "number": 74190,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-08-19T07:59:16Z",
          "user": "aromaa"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-08-21T03:06:04Z",
          "user": "NN---"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-08-21T13:20:15Z",
          "user": "acaly"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-11-21T15:14:48Z",
          "user": "wannabelikeyoda"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-05-01T10:58:47Z",
          "user": "Guiorgy"
        }
      ],
      "totalCount": 5,
      "endCursor": "Y3Vyc29yOnYyOpHOCvz4kA=="
    },
    "updatedAt": "2023-05-02T23:56:15Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\n### Background and motivation\n\n[Kotlin / Gson supports an `alternate` name for json properties](https://github.com/google/gson/issues/639), which can be convenient to allow deserializing similar json to a unified class object.\r\n\r\nCurrently, `JsonPropertyNameAttribute` does not have support for this, and it is not possible to specify multiple instances of `JsonPropertyNameAttribute`.\r\n\r\nHaving this would remove the need for writing a custom JsonConverter for this case.\r\n\r\nNote: this is **only about deserialization** - serialization will always use the default `name` value.\n\n### API Proposal\n\n```csharp\r\nnamespace System.Text.Json.Serialization\r\n{\r\n    /// <summary>\r\n    /// Specifies the property name that is present in the JSON when serializing and deserializing.\r\n    /// This overrides any naming policy specified by <see cref=\"JsonNamingPolicy\"/>.\r\n    /// </summary>\r\n    [AttributeUsage(AttributeTargets.Property | AttributeTargets.Field, AllowMultiple = false)]\r\n    public sealed class JsonPropertyNameAttribute : JsonAttribute\r\n    {\r\n        /// <summary>\r\n        /// Initializes a new instance of <see cref=\"JsonPropertyNameAttribute\"/> with the specified property name.\r\n        /// </summary>\r\n        /// <param name=\"name\">The name of the property.</param>\r\n        public JsonPropertyNameAttribute(string name)\r\n        {\r\n            Name = name;\r\n        }\r\n\r\n        /// <summary>\r\n        /// Initializes a new instance of <see cref=\"JsonPropertyNameAttribute\"/> with the specified property name.\r\n        /// </summary>\r\n        /// <param name=\"name\">The name of the property.</param>\r\n        /// <param name=\"alternatives\">The alternative names of the property.</param>\r\n        public JsonPropertyNameAttribute(string name, string[] alternatives)\r\n        {\r\n            Name = name;\r\n            Alternatives = alternative;\r\n        }\r\n\r\n        /// <summary>\r\n        /// The name of the property.\r\n        /// </summary>\r\n        public string Name { get; }\r\n\r\n        /// <summary>\r\n        /// The alternative names of the property.\r\n        /// </summary>\r\n        /// <remarks>\r\n        /// Is only used for deserialization\r\n        /// </remarks>\r\n        public string[] Alternatives { get; }\r\n    }\r\n}\r\n```\r\n\n\n### API Usage\n\n```csharp\r\npublic class Test\r\n{\r\n   [JsonPropertyName(\"property\", alternatives = { \"myProperty\" })]\r\n   public string MyProperty { get; set; }\r\n}\r\n```\r\n\n\n### Alternative Designs\n\n_No response_\n\n### Risks\n\nWhile I would say having a clean json response from an API would be better, one does not always have control over the responses of the API.\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>hansmbakker</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`api-suggestion`, `area-System.Text.Json`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2022-08-18T22:31:22Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-08-18T22:31:22Z",
          "id": "IC_kwDODI9FZc5IuFV3"
        },
        {
          "author": "aromaa",
          "body": "I have myself worked around this with the following but it for sure looks ugly. However, I'm also using this for polymorphic deserialization so having support for alternative names in the `JsonPolymorphicAttribute` too would be helpful.\r\n```csharp\r\ninternal sealed class JsonData\r\n{\r\n\t[JsonPropertyName(\"type\")]\r\n\tpublic string Type { get; init; }\r\n\r\n\t[JsonPropertyName(\"t\")]\r\n\tpublic string T\r\n\t{\r\n\t\tinit => this.Type = value;\r\n\t}\r\n}\r\n```",
          "createdAt": "2022-08-19T08:11:21Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-08-19T08:12:23Z",
          "id": "IC_kwDODI9FZc5IvYyH"
        },
        {
          "author": "gregsdennis",
          "body": "Under what conditions would an alternate name be used?",
          "createdAt": "2022-08-19T09:59:56Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-08-19T09:59:56Z",
          "id": "IC_kwDODI9FZc5IvyxF"
        },
        {
          "author": "hansmbakker",
          "body": "> Under what conditions would an alternate name be used?\r\n\r\nWhen having to e.g. support multiple versions of a REST API that have minor changes in property naming of the API response json.",
          "createdAt": "2022-08-19T11:01:35Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-08-19T11:01:50Z",
          "id": "IC_kwDODI9FZc5Iv_ol"
        },
        {
          "author": "krwq",
          "body": "You can actually easily add support for this yourself with contract resolver which is added in 7.0 preview7. Here is code sample:\r\n\r\n```csharp\r\nusing System.Text.Json;\r\nusing System.Text.Json.Serialization.Metadata;\r\n\r\nnamespace JsonAlternativeName\r\n{\r\n    internal class Program\r\n    {\r\n        static void Main(string[] args)\r\n        {\r\n            JsonSerializerOptions options = new()\r\n            {\r\n                TypeInfoResolver = new DefaultJsonTypeInfoResolver()\r\n                {\r\n                    Modifiers = { JsonAlternativeNameModifier }\r\n                }\r\n            };\r\n\r\n            string json = \"\"\"{\"Foo\": \"test1\", \"Baz\": \"test2\"}\"\"\";\r\n            Print(JsonSerializer.Deserialize<Test>(json, options)); // [ Foo = test1; Baz = test2]\r\n\r\n            json = \"\"\"{\"Bar\": \"test3\", \"ASD\": \"test4\"}\"\"\";\r\n            Print(JsonSerializer.Deserialize<Test>(json, options)); // [ Foo = test3; Baz = test4]\r\n\r\n            json = \"\"\"{\"Bar2\": \"test5\", \"Baz\": \"test6\"}\"\"\";\r\n            Print(JsonSerializer.Deserialize<Test>(json, options)); // [ Foo = test5; Baz = test6]\r\n        }\r\n\r\n        static void Print(Test test) => Console.WriteLine($\"[ Foo = {test.Foo}; Baz = {test.Baz}]\");\r\n\r\n        static void JsonAlternativeNameModifier(JsonTypeInfo typeInfo)\r\n        {\r\n            int initialCount = typeInfo.Properties.Count;\r\n            for (int i = 0; i < initialCount; i++)\r\n            {\r\n                JsonPropertyInfo prop = typeInfo.Properties[i];\r\n                if (prop.AttributeProvider != null)\r\n                {\r\n                    object[] attrs = prop.AttributeProvider.GetCustomAttributes(typeof(JsonAlternativeNameAttribute), inherit: true);\r\n                    foreach (var attr in attrs)\r\n                    {\r\n                        JsonAlternativeNameAttribute attribute = (JsonAlternativeNameAttribute)attr;\r\n                        JsonPropertyInfo newProp = typeInfo.CreateJsonPropertyInfo(prop.PropertyType, attribute.AltName);\r\n                        newProp.Set = prop.Set;\r\n                        typeInfo.Properties.Add(newProp);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    internal class Test\r\n    {\r\n        [JsonAlternativeName(\"Bar\")]\r\n        [JsonAlternativeName(\"Bar2\")]\r\n        public string Foo { get; set; }\r\n\r\n        [JsonAlternativeName(\"ASD\")]\r\n        public string Baz { get; set; }\r\n    }\r\n\r\n    [AttributeUsage(AttributeTargets.Property | AttributeTargets.Field, AllowMultiple = true)]\r\n    internal class JsonAlternativeNameAttribute : Attribute\r\n    {\r\n        public string AltName { get; set; }\r\n\r\n        public JsonAlternativeNameAttribute(string altName)\r\n        {\r\n            AltName = altName;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\ncsproj:\r\n\r\n```xml\r\n<Project Sdk=\"Microsoft.NET.Sdk\">\r\n\r\n  <PropertyGroup>\r\n    <OutputType>Exe</OutputType>\r\n    <TargetFramework>net6.0</TargetFramework>\r\n    <ImplicitUsings>enable</ImplicitUsings>\r\n    <Nullable>enable</Nullable>\r\n    <LangVersion>preview</LangVersion><!-- for triple quote syntax -->\r\n  </PropertyGroup>\r\n\r\n  <ItemGroup>\r\n    <PackageReference Include=\"System.Text.Json\" Version=\"7.0.0-preview.7.22375.6\" />\r\n  </ItemGroup>\r\n\r\n</Project>\r\n```",
          "createdAt": "2022-08-19T11:16:05Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "HEART",
                "createdAt": "2022-08-19T11:26:53Z",
                "user": "eiriktsarpalis"
              },
              {
                "content": "HEART",
                "createdAt": "2022-08-19T11:29:34Z",
                "user": "aromaa"
              },
              {
                "content": "HEART",
                "createdAt": "2022-08-20T21:11:17Z",
                "user": "layomia"
              },
              {
                "content": "HEART",
                "createdAt": "2022-08-21T03:06:36Z",
                "user": "NN---"
              },
              {
                "content": "HEART",
                "createdAt": "2023-04-30T19:47:13Z",
                "user": "Guiorgy"
              },
              {
                "content": "HEART",
                "createdAt": "2023-05-17T13:34:10Z",
                "user": "TRMack"
              }
            ],
            "totalCount": 6,
            "endCursor": "Y3Vyc29yOnYyOpHOC75eng=="
          },
          "updatedAt": "2022-08-19T11:16:05Z",
          "id": "IC_kwDODI9FZc5IwCbz"
        },
        {
          "author": "Guiorgy",
          "body": "@krwq Thank you for the tip, however this doesn't seem to work with non-public properties and public constructors. The constructor argument name must match the property name, however the properties added through `typeInfo.Properties.Add` don't have a match in the constructor, thus only the original name works. Here's an example:\r\n\r\n```cs\r\npublic sealed class Test2\r\n{\r\n    [JsonAlternativeName(\"Bar\")]\r\n    [JsonAlternativeName(\"Bar2\")]\r\n    public string Foo { get; }\r\n\r\n    [JsonAlternativeName(\"ASD\")]\r\n    public string Baz { get; }\r\n\r\n    [JsonConstructor]\r\n    public Test2(string foo, string baz)\r\n    {\r\n        Foo = foo;\r\n        Baz = baz;\r\n    }\r\n}\r\n\r\n[TestMethod]\r\npublic void Test2()\r\n{\r\n    string json = \"\"\"{\"Foo\": \"test1\", \"Baz\": \"test2\"}\"\"\";\r\n    var test = JsonSerializer.Deserialize<Test2>(json, options);\r\n    Assert.IsNotNull(test);\r\n    Assert.AreEqual(\"test1\", test.Foo); // pass\r\n    Assert.AreEqual(\"test2\", test.Baz); // pass\r\n\r\n    json = \"\"\"{\"Bar\": \"test3\", \"ASD\": \"test4\"}\"\"\";\r\n    test = JsonSerializer.Deserialize<Test2>(json, options);\r\n    Assert.IsNotNull(test);\r\n    Assert.AreEqual(\"test3\", test.Foo); // failed\r\n    Assert.AreEqual(\"test4\", test.Baz);\r\n\r\n    json = \"\"\"{\"Bar2\": \"test5\", \"Baz\": \"test6\"}\"\"\";\r\n    test = JsonSerializer.Deserialize<Test2>(json, options);\r\n    Assert.IsNotNull(test);\r\n    Assert.AreEqual(\"test5\", test.Foo);\r\n    Assert.AreEqual(\"test6\", test.Baz);\r\n}\r\n```\r\n\r\nDo you have any thought on how to handle such case?\r\n\r\nEDIT: Found a workaround! Well, almost...\r\n\r\nIf the properties have a setter action, they don't need a matching argument in the constructor, so for every property added override the setter:\r\n\r\n```cs\r\nvar setter = (object obj, object? value) =>\r\n{\r\n    if (prop.Set != null) prop.Set(obj, value);\r\n    else {\r\n        // the setter may be private\r\n        var privateSetter = typeInfo.Type.GetProperty(property.Name)?.GetSetMethod(nonPublic: true);\r\n        if (privateSetter != null) privateSetter.Invoke(obj, new[] { value });\r\n        else {\r\n            // there's no setter, so access the backing field dirrectly\r\n            var backingField = typeInfo.Type.GetField($\"<{property.Name}>k__BackingField\", BindingFlags.Instance | BindingFlags.NonPublic);\r\n            if (backingField != null) backingField.SetValue(obj, value);\r\n            else {\r\n                // it could be a field, not a property\r\n                var field = typeInfo.Type.GetField(property.Name);\r\n                if (field != null) field.SetValue(obj, value);\r\n                else throw new JsonException(\"Must be a property with no setter and a custom getter (no backing field). Can't handle this!\");\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\nnewProp.Set = setter;\r\ntypeInfo.Properties.Add(newProp);\r\n```\r\n\r\nIt's quite ugly, and still can't handle a property without a default backing field.\r\n\r\nLet me know if you find something better.\n\nEDIT2: On further though, there's a huge flaw in my workaround, it assumes that the constructor and setter (if present) transform the value in the same way. This may not always be the case. Besides going for a source generator, I can't think of a way to make it work right. I hope this feature gets implemented.",
          "createdAt": "2023-05-01T10:57:51Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-05-02T23:56:15Z",
          "id": "IC_kwDODI9FZc5bK3DW"
        }
      ],
      "totalCount": 6,
      "endCursor": "Y3Vyc29yOnYyOpHOWytw1g=="
    },
    "url": "https://github.com/dotnet/runtime/issues/74190",
    "title": "[API Proposal]: alternate name option for JsonPropertyNameAttribute"
  },
  {
    "author": "eiriktsarpalis",
    "labels": [
      "api-suggestion",
      "area-System.Text.Json",
      "User Story",
      "Cost:M"
    ],
    "createdAt": "2022-08-24T10:33:47Z",
    "body": "## Background & Motivation\n\nThe current design of the [`JsonSerializer` class](https://docs.microsoft.com/en-us/dotnet/api/system.text.json.jsonserializer?view=net-6.0) exposes all serialization functionality as static methods accepting configuration parametrically (and optionally). In hindsight, this design has contributed to a few ergonomic problems when using this API:\n\n1. Forgetting to pass `JsonSerializerOptions` to the serialization methods:\n\n   ```C#\n   var options = new JsonSerializerOptions { Converters = { new JsonStringEnumConverter() }};\n   JsonSerializer.Serialize(MyEnum.Value);\n   ```\n\n    This is probably the most common issue -- I've personally fallen for this too many times.\n\n2. Creating a new `JsonSerializerOptions` instance on each serialization:\n    ```C#\n    foreach (MyPoco value in values)\n    {\n         var options = new JsonSerializerOptions  { Converters = { new JsonStringEnumConverter() }};\n         JsonSerializer.Serialize(value, options); // recalculates JSON contracts from scratch on each iteration\n    }\n    ```\n    Even though this anti-pattern has been [explicitly documented](https://docs.microsoft.com/en-us/dotnet/standard/serialization/system-text-json-configure-options?pivots=dotnet-6-0#reuse-jsonserializeroptions-instances) as a potential performance bug, users keep falling for it. We've made attempts to mitigate the problem by implementing [shared metadata caches](https://github.com/dotnet/runtime/pull/64646) but ultimately the underlying issue still affects users. See also #65396 for plans an adding an analyzer in this space.\n\n3. Pervasive `RequiresUnreferenceCode`/`RequiresDynamicCode` annotations: all serialization methods accepting `JsonSerializerOptions` have been annotated as linker/AOT-unsafe even though legitimate scenaria exist where this is not the case:\n\n     ```C#\n     var options = new JsonSerializerOptions { TypeInfoResolver = MySourceGeneratedContext.Default };\n     JsonSerializer.Serialize(value, options); // warning: JSON serialization and deserialization might require types that cannot be statically analyzed.\n     ```\n\n4. Bifurcation of API surface between reflection and source generation: users need to call into distinct methods depending on whether they use sourcegen or reflection. The distinction between `JsonSerializerOptions` and `JsonSerializerContext` has always been tenuous and has been rendered obsolete with the infrastructural changes introduced by https://github.com/dotnet/runtime/issues/63686. Arguably, the source of JSON contracts is a configuration detail that should be dealt with at the composition root and not concern any serialization methods.\n\n## API Proposal\n\nThis issue proposes we expose instance methods in `JsonSerializer` (or some different class):\n```C#\nnamespace System.Text.Json;\n\npublic partial class JsonSerializerInstance // TODO come up with a better name\n{\n    public JsonSerializerOptions Options { get; }\n\n    public JsonSerializer(JsonSerializerOptions options); // linker-safe constructor, throws if options.TypeInfoResolver == null;\n                                                          // we might consider adding a linker-unsafe factory that populates TypeInfoResolver with the reflection resolver, like the existing serialization APIs do.\n\n    [RequiresUnreferencedCode]\n    public static JsonSerializer Default { get; } // serializer wrapping JsonSerializerOptions.Default\n\n\n    /* Serialization APIs */\n\n    public string Serialize<TValue>(TValue value);\n    public byte[] SerializeToUtf8Bytes<TValue>(TValue value);\n    public void Serialize<TValue>(Utf8JsonWriter utf8Json, TValue value);\n    public void Serialize<TValue>(Stream utf8Json, TValue value);\n    public void SerializeAsync<TValue>(Stream utf8Json, TValue value);\n    public JsonDocument SerializeToDocument<TValue>(TValue value);\n    public JsonElement SerializeToElement<TValue>(TValue value);\n    public JsonNode SerializeToNode<TValue>(TValue value);\n\n    public string Serialize(object? value, Type inputType);\n    public byte[] SerializeToUtf8Bytes(object? value, Type inputType);\n    public void Serialize(Utf8JsonWriter writer, object? value, Type inputType);\n    public void Serialize(Stream utf8Json, object? value, Type inputType);\n    public void SerializeAsync(Stream utf8Json, object? value, Type inputType);\n    public JsonDocument SerializeToDocument(object? value, Type inputType);\n    public JsonElement SerializeToElement(object? value, Type inputType);\n    public JsonNode SerializeToNode(object? value, Type inputType);\n\n    /* Deserialization APIs */\n\n    public TValue? Deserialize<TValue>(string json);\n    public TValue? Deserialize<TValue>(ReadOnlySpan<char> json);\n    public TValue? Deserialize<TValue>(ReadOnlySpan<byte> utf8Json);\n    public TValue? Deserialize<TValue>(ref Utf8JsonReader reader);\n    public TValue? Deserialize<TValue>(Stream utf8Json);\n    public ValueTask<TValue?> DeserializeAsync<TValue>(Stream utf8Json);\n    public IAsyncEnumerable<TValue?> DeserializeAsyncEnumerable<TValue>(Stream utf8Json);\n    public TValue? Deserialize<TValue>(JsonDocument document);\n    public TValue? Deserialize<TValue>(JsonElement element);\n    public TValue? Deserialize<TValue>(JsonNode node);\n\n    public object? Deserialize(ReadOnlySpan<byte> utf8Json, Type returnType);\n    public object? Deserialize(ReadOnlySpan<char> json, Type returnType);\n    public object? Deserialize(string json, Type returnType);\n    public object? Deserialize(JsonDocument document, Type returnType);\n    public object? Deserialize(JsonElement element, Type returnType);\n    public object? Deserialize(JsonNode node, Type returnType);\n    public object? Deserialize(ref Utf8JsonReader reader, Type returnType);\n    public object? Deserialize(Stream utf8Json, Type returnType);\n    public ValueTask<object?> DeserializeAsync(Stream utf8Json, Type returnType);\n}\n\nnamespace System.Text.Json.Serialization;\n\npublic partial class JsonSerializerContext\n{\n     public JsonSerializer Serializer { get; }\n}\n```\n\n## Usage Examples\n\nUsing the reflection-based serializer\n\n```C#\n/* composition root */\nvar options = new JsonSerializerOptions \n{ \n    Converters = new JsonStringEnumConverter(), \n    TypeInfoResolver = new DefaultJsonTypeInfoResolver() \n};\n\nvar serializer = new JsonSerializer(options);\n\n/* usage */\nserializer.Serialize(value); \n```\n\nUsing the source generator\n\n```C#\nJsonSerializer serializer = MyContext.Default.Serializer;\nserializer.Serialize(new MyPoco()); // Serializes using the source generator \n\n[JsonSerializable(typeof(MyPoco))]\npublic partial class MyContext : JsonSerializerContext\n{}\n```\n\n### Open Questions\n\n* Should we reuse the existing `JsonSerializer` class or introduce a new type?\n* Should we have an obsoletion plan for static APIs accepting `JsonSerializerOptions`?\n\nRelated to #65396, #31094, #64646\n\ncc @eerhardt @davidfowl @ericstj ",
    "number": 74492,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "ROCKET",
          "createdAt": "2022-10-10T15:54:49Z",
          "user": "IanKemp"
        },
        {
          "content": "ROCKET",
          "createdAt": "2023-01-26T19:27:17Z",
          "user": "JohannSig"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-01-26T19:27:22Z",
          "user": "JohannSig"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-08-24T01:12:41Z",
          "user": "Neme12"
        },
        {
          "content": "ROCKET",
          "createdAt": "2023-08-24T01:12:56Z",
          "user": "Neme12"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-12-13T04:10:22Z",
          "user": "siadatism"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-12-13T05:27:11Z",
          "user": "Sepand96"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-12-13T11:07:25Z",
          "user": "soroshsabz"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-12-13T11:18:06Z",
          "user": "RikoLearn"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-01-19T04:36:00Z",
          "user": "tanveerbadar"
        },
        {
          "content": "ROCKET",
          "createdAt": "2024-01-19T04:36:00Z",
          "user": "tanveerbadar"
        },
        {
          "content": "HEART",
          "createdAt": "2024-01-19T04:36:04Z",
          "user": "tanveerbadar"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-01-24T18:05:27Z",
          "user": "begerard"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-07-30T04:18:49Z",
          "user": "colejohnson66"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-07-30T09:53:42Z",
          "user": "austinw-fineart"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-08-01T14:05:28Z",
          "user": "KennethHoff"
        },
        {
          "content": "ROCKET",
          "createdAt": "2024-08-01T14:05:28Z",
          "user": "KennethHoff"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-08-10T22:33:37Z",
          "user": "Mrxx99"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-01-06T17:52:59Z",
          "user": "BrentRodhouse"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-01-10T12:47:12Z",
          "user": "Andrew25455"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-02-12T14:53:28Z",
          "user": "ninoalloy"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-06-13T12:24:04Z",
          "user": "Belllene"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-07-18T21:57:12Z",
          "user": "Athari"
        }
      ],
      "totalCount": 23,
      "endCursor": "Y3Vyc29yOnYyOpHODHoe9w=="
    },
    "updatedAt": "2025-02-20T15:36:15Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\n## Background & Motivation\r\n\r\nThe current design of the [`JsonSerializer` class](https://docs.microsoft.com/en-us/dotnet/api/system.text.json.jsonserializer?view=net-6.0) exposes all serialization functionality as static methods accepting configuration parametrically (and optionally). In hindsight, this design has contributed to a few ergonomic problems when using this API:\r\n\r\n1. Forgetting to pass `JsonSerializerOptions` to the serialization methods:\r\n\r\n   ```C#\r\n   var options = new JsonSerializerOptions { Converters = { new JsonStringEnumConverter() }};\r\n   JsonSerializer.Serialize(MyEnum.Value);\r\n   ```\r\n\r\n    This is probably the most common issue -- I've personally fallen for this too many times.\r\n\r\n2. Creating a new `JsonSerializerOptions` instance on each serialization:\r\n    ```C#\r\n    foreach (MyPoco value in values)\r\n    {\r\n         var options = new JsonSerializerOptions  { Converters = { new JsonStringEnumConverter() }};\r\n         JsonSerializer.Serialize(value, options); // recalculates JSON contracts from scratch on each iteration\r\n    }\r\n    ```\r\n    Even though this anti-pattern has been [explicitly documented](https://docs.microsoft.com/en-us/dotnet/standard/serialization/system-text-json-configure-options?pivots=dotnet-6-0#reuse-jsonserializeroptions-instances) as a potential performance bug, users keep falling for it. We've made attempts to mitigate the problem by implementing [shared metadata caches](https://github.com/dotnet/runtime/pull/64646) but ultimately the underlying issue still affects users. See also #65396 for plans an adding an analyzer in this space.\r\n\r\n3. Pervasive `RequiresUnreferenceCode`/`RequiresDynamicCode` annotations: all serialization methods accepting `JsonSerializerOptions` have been annotated as linker/AOT-unsafe even though legitimate scenaria exist where this is not the case:\r\n\r\n     ```C#\r\n     var options = new JsonSerializerOptions { TypeInfoResolver = MySourceGeneratedContext.Default };\r\n     JsonSerializer.Serialize(value, options); // warning: JSON serialization and deserialization might require types that cannot be statically analyzed.\r\n     ```\r\n\r\n## API Proposal\r\n\r\nThis issue proposes we expose instance methods in `JsonSerializer` (or some different class):\r\n```C#\r\nnamespace System.Text.Json;\r\n\r\npublic partial class JsonSerializer // Changed from static class\r\n{\r\n    public JsonSerializerOptions Options { get; }\r\n\r\n    public JsonSerializer(JsonSerializerOptions options); // linker-safe constructor, throws if options.TypeInfoResolver == null;\r\n                                                          // we might consider adding a linker-unsafe factory that populates TypeInfoResolver with the reflection resolver, like the existing serialization APIs do.\r\n\r\n    [RequiresUnreferencedCode]\r\n    public static JsonSerializer Default { get; } // serializer wrapping JsonSerializerOptions.Default\r\n\r\n\r\n    /* Serialization APIs */\r\n\r\n    public string Serialize<TValue>(TValue value);\r\n    public byte[] SerializeToUtf8Bytes<TValue>(TValue value);\r\n    public void Serialize<TValue>(Utf8JsonWriter utf8Json, TValue value);\r\n    public void Serialize<TValue>(Stream utf8Json, TValue value);\r\n    public void SerializeAsync<TValue>(Stream utf8Json, TValue value);\r\n    public JsonDocument SerializeToDocument<TValue>(TValue value);\r\n    public JsonElement SerializeToElement<TValue>(TValue value);\r\n    public JsonNode SerializeToNode<TValue>(TValue value);\r\n\r\n    public string Serialize(object? value, Type inputType);\r\n    public byte[] SerializeToUtf8Bytes(object? value, Type inputType);\r\n    public void Serialize(Utf8JsonWriter writer, object? value, Type inputType);\r\n    public void Serialize(Stream utf8Json, object? value, Type inputType);\r\n    public void SerializeAsync(Stream utf8Json, object? value, Type inputType);\r\n    public JsonDocument SerializeToDocument(object? value, Type inputType);\r\n    public JsonElement SerializeToElement(object? value, Type inputType);\r\n    public JsonNode SerializeToNode(object? value, Type inputType);\r\n\r\n    /* Deserialization APIs */\r\n\r\n    public TValue? Deserialize<TValue>(string json);\r\n    public TValue? Deserialize<TValue>(ReadOnlySpan<char> json);\r\n    public TValue? Deserialize<TValue>(ReadOnlySpan<byte> utf8Json);\r\n    public TValue? Deserialize<TValue>(ref Utf8JsonReader reader);\r\n    public TValue? Deserialize<TValue>(Stream utf8Json);\r\n    public ValueTask<TValue?> DeserializeAsync<TValue>(Stream utf8Json);\r\n    public IAsyncEnumerable<TValue?> DeserializeAsyncEnumerable<TValue>(Stream utf8Json);\r\n    public TValue? Deserialize<TValue>(JsonDocument document);\r\n    public TValue? Deserialize<TValue>(JsonElement element);\r\n    public TValue? Deserialize<TValue>(JsonNode node);\r\n\r\n    public object? Deserialize(ReadOnlySpan<byte> utf8Json, Type returnType);\r\n    public object? Deserialize(ReadOnlySpan<char> json, Type returnType);\r\n    public object? Deserialize(string json, Type returnType);\r\n    public object? Deserialize(JsonDocument document, Type returnType);\r\n    public object? Deserialize(JsonElement element, Type returnType);\r\n    public object? Deserialize(JsonNode node, Type returnType);\r\n    public object? Deserialize(ref Utf8JsonReader reader, Type returnType);\r\n    public object? Deserialize(Stream utf8Json, Type returnType);\r\n    public ValueTask<object?> DeserializeAsync(Stream utf8Json, Type returnType);\r\n}\r\n\r\nnamespace System.Text.Json.Serialization;\r\n\r\npublic partial class JsonSerializerContext\r\n{\r\n     public JsonSerializer Serializer { get; }\r\n}\r\n```\r\n\r\n## Usage Examples\r\n\r\nUsing the reflection-based serializer\r\n\r\n```C#\r\n/* composition root */\r\nvar options = new JsonSerializerOptions \r\n{ \r\n    Converters = new JsonStringEnumConverter(), \r\n    TypeInfoResolver = new DefaultJsonTypeInfoResolver() \r\n};\r\n\r\nvar serializer = new JsonSerializer(options);\r\n\r\n/* usage */\r\nserializer.Serialize(value); \r\n```\r\n\r\nUsing the source generator\r\n\r\n```C#\r\nJsonSerializer serializer = MyContext.Default.Serializer;\r\nserializer.Serialize(new MyPoco()); // Serializes using the source generator \r\n\r\n[JsonSerializable(typeof(MyPoco))]\r\npublic partial class MyContext : JsonSerializerContext\r\n{}\r\n```\r\n\r\n### Open Questions\r\n\r\n* Should we reuse the existing `JsonSerializer` class or introduce a new type?\r\n* Should we have an obsoletion plan for static APIs accepting `JsonSerializerOptions`?\r\n\r\nRelated to #65396, #31094, #64646\r\n\r\ncc @eerhardt @davidfowl @ericstj \n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>eiriktsarpalis</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`area-System.Text.Json`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2022-08-24T10:33:54Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-08-24T10:33:54Z",
          "id": "IC_kwDODI9FZc5JDDQO"
        },
        {
          "author": "krwq",
          "body": "IMO while it could be a good idea when we first created this project I'm not so convinced to do it now and creating second set of the same APIs elsewhere just feels weird. I think it might make more sense to create code analyzer to hint people they're using it wrong. I'm also tempted to say if anything maybe put those methods on the options directly but then it would \"weird really read\": `options.Serialize(...)`",
          "createdAt": "2022-08-24T12:02:45Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-08-24T12:04:05Z",
          "id": "IC_kwDODI9FZc5JDZqV"
        },
        {
          "author": "eerhardt",
          "body": "> Should we have an obsoletion plan for static APIs accepting JsonSerializerOptions?\r\n\r\nWhy would we obsolete this?",
          "createdAt": "2022-08-24T12:47:19Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-08-24T12:47:19Z",
          "id": "IC_kwDODI9FZc5JDlZt"
        },
        {
          "author": "eiriktsarpalis",
          "body": "> > Should we have an obsoletion plan for static APIs accepting JsonSerializerOptions?\r\n> \r\n> Why would we obsolete this?\r\n\r\nWe don't need to, strictly speaking, but it seems to be too much of a pit of failure at the moment. Obsoletion could be one way to guide users to the new APIs.",
          "createdAt": "2022-08-24T14:05:22Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-08-24T14:05:22Z",
          "id": "IC_kwDODI9FZc5JD9TO"
        },
        {
          "author": "davidfowl",
          "body": "Or an analyzer?",
          "createdAt": "2022-08-24T14:56:16Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-08-24T14:56:16Z",
          "id": "IC_kwDODI9FZc5JENeF"
        },
        {
          "author": "layomia",
          "body": "> Pervasive RequiresUnreferenceCode/RequiresDynamicCode annotations: all serialization methods accepting JsonSerializerOptions have been annotated as linker/AOT-unsafe even though legitimate scenaria exist where this is not the case\r\n\r\nThis is pretty compelling, but if we're not going to deprecate the existing static APIs, then it seems moot given that there are existing patterns to avoid the linker warnings. New APIs would add to an increasingly high concept count for using the serializer. New fixers to help users to help users detect and switch bad patterns would perhaps be sufficient to solve these problems.",
          "createdAt": "2022-08-24T18:11:32Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-08-24T18:44:28Z",
                "user": "davidfowl"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOCrGcYw=="
          },
          "updatedAt": "2022-08-24T18:11:32Z",
          "id": "IC_kwDODI9FZc5JFEuD"
        },
        {
          "author": "gregsdennis",
          "body": "@eiriktsarpalis can you show how your problem examples would change?  This might help explain how exposing these methods will solve the problems those scenarios present.\n\nAlso, if we've already documented that people shouldn't do these things, how will these changes alter users' behavior?",
          "createdAt": "2022-08-24T19:40:30Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-08-24T19:40:46Z",
          "id": "IC_kwDODI9FZc5JFc05"
        },
        {
          "author": "eiriktsarpalis",
          "body": "> it seems moot given that there are existing patterns to avoid the linker warnings.\r\n\r\nUnfortunately, that is not the case when it comes to using customized contract resolvers. These can only be consumed via the serialization methods that accept the optional `JsonSerializerOptions` argument which must be marked as RUC/RDC because of their default behavior. A user could write their own source generated contract resolver (and in fact it is conceivable that future iterations of the inbox source generator could target `IJsonTypeInfoResolver` directly instead of proxying via `JsonSerializerContext`/`JsonMetadataServices`). The current APIs however provide no good way of achieving this without producing false-positive linker warnings (and no amount of analyzers/fixers can address that particular problem).\r\n\r\n> can you show how your problem examples would change? This might help explain how exposing these methods will solve the problems those scenarios present.\r\n\r\nI think the \"Usage Examples\" section might clarify how these could be refactored, but ultimately the idea is that all serialization configuration is encapsulated behind a materialized \"JsonSerializer\" instance, so passing the right configuration becomes the responsibility of the composition root, rather than the callsite's, which is more conducive to applying DI patterns:\r\n\r\n```C#\r\npublic class MyClass\r\n{\r\n     // Use constructor injection to determine serialization configuration; could be reflection or sourcegen or a mix of both.\r\n     // Currently we need to call into separate sets of APIs in order to avoid linker warnings.\r\n     private readonly JsonSerializer _serializer;\r\n     public MyClass(JsonSerializer serializer) => _serializer = serializer;\r\n\r\n     public string GetJson() => _serializer.Serialize(_data); // instance methods do not accept JsonSerializerOptions and do not differentiate between \"reflection\" and \"sourcegen\" flavors. There is no need for any linker annotations here.\r\n}\r\n",
          "createdAt": "2022-08-25T12:33:15Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-08-25T12:35:23Z",
          "id": "IC_kwDODI9FZc5JJYk4"
        },
        {
          "author": "steveharter",
          "body": "The primary original reason for static methods was to be zero-alloc at least for simpler scenarios.\r\n\r\nAlso instantiating a \"serializer\" class may end up having the same problem we have today for those who just new up the \"options\" class on every use.\r\n\r\nIMO adding the Serialize() methods should be done on `JsonSerializerContext` or a derived class.",
          "createdAt": "2022-08-29T15:39:12Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-08-30T02:38:50Z",
                "user": "gregsdennis"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOCrWFZA=="
          },
          "updatedAt": "2022-08-29T15:39:12Z",
          "id": "IC_kwDODI9FZc5JV8Qx"
        },
        {
          "author": "eiriktsarpalis",
          "body": "> The primary original reason for static methods was to be zero-alloc at least for simpler scenarios.\r\n\r\nIt's definitely useful for quickly producing JSON when configuration is not a concern, but it definitely suffers from ergonomic concerns in less trivial scenaria. Arguably this can also be achieved via the new `JsonSerializerOptions.Default` property.\r\n\r\n> Also instantiating a \"serializer\" class may end up having the same problem we have today for those who just new up the \"options\" class on every use.\r\n\r\nAgree that this is still a theoretical concern, but even though an _optional_ parameter in a static method is (for most intents and purposes) equivalent to exposing an instance method on the parameter itself, the two approaches present themselves very differently to users not familiar with the library. Arguably the latter approach communicates more clearly that we're dealing with a serialization context and primes users to think of the type in terms of DI.\r\n\r\n> IMO adding the Serialize() methods should be done on JsonSerializerContext or a derived class.\r\n\r\nAgree in principle, but that ship has sailed when it comes to `JsonSerializerContext` specifically. Even though we shipped APIs that accept `JsonSerializerContext` as a first-class parameter, its design fundamentally makes it a configuration facet of `JsonSerializerOptions` (effectively rendering `JsonSerializerOptions` the only first-class configuration type). \r\n\r\nThe work in https://github.com/dotnet/runtime/issues/61734 doubles down on that design: starting with .NET 7 `JsonSerializerContext` is simply one implementation of `IJsonTypeInfoResolver`, which is yet another configuration setting on `JsonSerializerOptions`.\r\n\r\nRegarding the relationship of `JsonSerializerContext` and `JsonSerializerOptions`, I just updated the OP with a further point:\r\n\r\n> 4. Bifurcation of API surface between reflection and source generation: users need to call into distinct methods depending on whether they use sourcegen or reflection. The distinction between `JsonSerializerOptions` and `JsonSerializerContext` has always been tenuous and has been rendered obsolete with the infrastructural changes introduced by https://github.com/dotnet/runtime/issues/63686. Arguably, the source of JSON contracts is a configuration detail that should be dealt with at the composition root and not concern any serialization methods.",
          "createdAt": "2022-08-31T09:20:07Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-08-31T09:27:45Z",
          "id": "IC_kwDODI9FZc5JeVXJ"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Here's a sketch of how one could define a serializer instance using .NET 7 APIs that is completely AOT/linker-safe:\r\n```C#\r\npublic partial class JsonSerializerInstance\r\n{\r\n    private readonly JsonSerializerOptions _options;\r\n\r\n    public JsonSerializerInstance(JsonSerializerOptions options)\r\n    {\r\n        if (options.TypeInfoResolver is null)\r\n        {\r\n            // This is a departure from default semantics in JsonSerializer methods that accept JsonSerializerOptions,\r\n            // but it's essential for preserving AOT/linker safety in the serializer instance constructor.\r\n            throw new ArgumentException(\"The options parameter must specify a TypeInfoResolver value.\", nameof(options));\r\n        }\r\n\r\n        _options = options;\r\n    }\r\n\r\n    // Serialization/Deserialization methods call into JsonTypeInfo<T> overloads that are marked as linker-safe.\r\n    public string Serialize<T>(T value) => JsonSerializer.Serialize(value, GetTypeInfo<T>());\r\n    public T? Deserialize<T>(string json) => JsonSerializer.Deserialize(json, GetTypeInfo<T>());\r\n\r\n    public Task SerializeAsync<T>(Stream utf8Json, T value, CancellationToken cancellationToken = default) \r\n        => JsonSerializer.SerializeAsync(utf8Json, value, GetTypeInfo<T>(), cancellationToken);\r\n\r\n    public ValueTask<T?> DeserializeAsync<T>(Stream utf8Json, CancellationToken cancellationToken = default)\r\n        => JsonSerializer.DeserializeAsync(utf8Json, GetTypeInfo<T>(), cancellationToken);\r\n\r\n    private JsonTypeInfo<T> GetTypeInfo<T>() => (JsonTypeInfo<T>)_options.GetTypeInfo(typeof(T));\r\n```\r\nAny AOT/linker warning annotations are now exclusively the purview of factories configuring serializer instances:\r\n\r\n```C#\r\npublic partial class JsonSerializerInstance\r\n{\r\n    [RequiresDynamicCode(\"Method uses the default reflection-based resolver which requires dynamic code.\")]\r\n    [RequiresUnreferencedCode(\"Method uses the default reflection-based resolver which requires unreferenced code.\")]\r\n    public static JsonSerializerInstance Default { get; } = new(JsonSerializerOptions.Default);\r\n\r\n    [RequiresDynamicCode(\"Method uses the default reflection-based resolver which requires dynamic code.\")]\r\n    [RequiresUnreferencedCode(\"Method uses the default reflection-based resolver which requires unreferenced code.\")]\r\n    public static CreateUsingJsonSerializerSemantics(JsonSerializerOptions options)\r\n    {\r\n          options.TypeInfoResolver ??= new DefaultJsonTypeInfoResolver();\r\n          return new(options);\r\n    }\r\n\r\n    // No annotation needed since JsonSerializerContext instances are linker safe\r\n    public static JsonSerializerInstance Create(JsonSerializerContext jsonSerializerContext) => new(jsonSerializerContext.Options);\r\n}\r\n```\r\n\r\nAs soon as a \"JsonSerializerInstance\" is materialized, it can be used without concern for linker warnings and is agnostic w.r.t. whether it uses source gen or reflection serialization.",
          "createdAt": "2022-09-29T19:28:19Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-09-30T07:58:48Z",
          "id": "IC_kwDODI9FZc5LQ5ZS"
        },
        {
          "author": "qszhuan",
          "body": "why can't you provide a way to set the options globally just like `Newtonsoft.Json`? The fact with instance method is it won't solve all the issues, as the libraries using JsonSerializer still use the default options.\r\n\r\nFor example, `BinaryData` has an method **ToObjectFromJson**, we can't pass the JsonSerializer instance to it, as it only accepts `JsonSerializerOptions`.\r\n\r\nIt will be annoying that if we have to take care of this kind of thing everywhere we uses it.",
          "createdAt": "2022-10-13T06:35:20Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-11-29T22:06:58Z",
                "user": "thepirat000"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHODN_Jjw=="
          },
          "updatedAt": "2022-10-13T06:37:04Z",
          "id": "IC_kwDODI9FZc5MHvxe"
        },
        {
          "author": "eiriktsarpalis",
          "body": "> why can't you provide a way to set the options globally just like Newtonsoft.Json\r\n\r\nThat approach has its own set of problems, see https://github.com/dotnet/runtime/issues/31094#issuecomment-1235451167",
          "createdAt": "2022-10-13T14:47:27Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_DOWN",
                "createdAt": "2022-11-16T15:16:07Z",
                "user": "markadrake"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-01-26T19:20:05Z",
                "user": "JohannSig"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-08-24T01:15:36Z",
                "user": "Neme12"
              },
              {
                "content": "THUMBS_DOWN",
                "createdAt": "2023-11-29T22:07:22Z",
                "user": "thepirat000"
              }
            ],
            "totalCount": 4,
            "endCursor": "Y3Vyc29yOnYyOpHODN_Jyw=="
          },
          "updatedAt": "2022-10-13T14:47:27Z",
          "id": "IC_kwDODI9FZc5MKLL5"
        },
        {
          "author": "agocke",
          "body": "I'm not sure I fully understand how this solves the problem, but I may just not understand Json source generators well enough.\r\n\r\nLet's say I want to create an HttpClient with JsonSerialization\r\n\r\n```C#\r\nvar client = new HttpClient(new JsonSerializer(new  MyContext.Default.Serializer));\r\nclient.WriteAsJson(new MyType1());\r\nclient.WriteAsJson(new MyType2());\r\n```\r\n\r\nHow does this work? Does that MyTypeContext contain the JsonSerializer for all of the types automatically? Or do you need to specify which types it contains via the `JsonSerializable` attribute? If that's right, what if you need more than one context? Is the intent to allow multiple contexts to be passed?\r\n\r\nAlso, does this mean that each type may get a source-gen'd implementation generated multiple times in each assembly?",
          "createdAt": "2022-11-18T00:59:22Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-11-18T00:59:22Z",
          "id": "IC_kwDODI9FZc5OpKVK"
        },
        {
          "author": "davidfowl",
          "body": ">  Or do you need to specify which types it contains via the JsonSerializable attribute?\r\n\r\nThis is the answer.\r\n\r\n>  If that's right, what if you need more than one context? Is the intent to allow multiple contexts to be passed?\r\n\r\nYou can use [this new API](https://learn.microsoft.com/en-us/dotnet/api/system.text.json.serialization.metadata.jsontypeinforesolver.combine?view=net-7.0) to combine contexts.\r\n\r\n> Also, does this mean that each type may get a source-gen'd implementation generated multiple times in each assembly?\r\n\r\nI think it depends on where the `JsonSerializationContext` was defined. If each assembly has their own with the same type, you'd get 3 copies of the source genned context.",
          "createdAt": "2022-11-18T04:12:04Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-11-18T11:32:08Z",
                "user": "eiriktsarpalis"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOCv1ZFw=="
          },
          "updatedAt": "2022-11-18T04:12:04Z",
          "id": "IC_kwDODI9FZc5OpkiY"
        },
        {
          "author": "eiriktsarpalis",
          "body": "> > Also, does this mean that each type may get a source-gen'd implementation generated multiple times in each assembly?\r\n> \r\n> I think it depends on where the `JsonSerializationContext` was defined. If each assembly has their own with the same type, you'd get 3 copies of the source genned context.\r\n\r\nAnd that should be a fairly common scenario, given that each `JsonSerializerContext` generates metadata for the entire transitive closure of its type dependencies. The order of arguments in `JsonTypeInfoResolver.Combine` is significant, as it will return the first result in that sequence that is non-null.",
          "createdAt": "2022-11-18T11:37:35Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-11-18T11:37:35Z",
          "id": "IC_kwDODI9FZc5Oq90C"
        },
        {
          "author": "agocke",
          "body": "OK, this makes sense then, thanks.\r\n\r\n> And that should be a fairly common scenario, given that each JsonSerializerContext generates metadata for the entire transitive closure of its type dependencies. \r\n\r\nThis is good to know. Given that code size is a metric we're tracking for Native AOT we should keep an eye on how this scales out with larger apps. No action for now, though.",
          "createdAt": "2022-11-18T18:20:39Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-11-18T18:20:39Z",
          "id": "IC_kwDODI9FZc5Os1ux"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Generally speaking it should contribute to code size increases, see https://github.com/dotnet/runtime/issues/77897 as an example.",
          "createdAt": "2022-11-18T19:13:05Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-11-18T19:13:05Z",
          "id": "IC_kwDODI9FZc5OtCNW"
        },
        {
          "author": "Sergio0694",
          "body": "I love this proposal so far! Have a few questions as well 😄\r\n\r\n> ```csharp\r\n> JsonSerializer serializer = MyContext.Default.Serializer;\r\n> serializer.Serialize(new MyPoco()); // Serializes using the source generator \r\n> \r\n> [JsonSerializable(typeof(MyPoco))]\r\n> public partial class MyContext : JsonSerializerContext\r\n> {}\r\n> ```\r\n\r\nI read the previous conversation here and didn't see anyone commenting on this yet - looking at that example I'm a bit worried about the fact you don't have an explicit `T` check anymore compared to using a `JsonTypeInfo<T>` instance. In the Microsoft Store, I've added a few extensions for `JsonTypeInfo<T>` that mostly just forward to `JsonSerializer.<METHOD>(...)`, passing the input type info and additional arguments (as well as normalizing exceptions as a workaround for #78029 until that's fixed, but that's a separate issue). This way we can easily enforce that using the extension is _the only_ way to serialize/deserialize, so that all callsites would just look like this:\r\n\r\n```csharp\r\nSomeModel model = MicrosoftStoreJsonSerializerContext.Default.SomeModel.Deserialize(jsonText);\r\n```\r\n\r\nThis makes it very easy to see that:\r\n1. The `JsonSerializerContext` is always being passed when serializing/deserializing\r\n2. _And_ that the `T` you're using is definitely present (which is validated at compile time).\r\n\r\nIn the example above for the new API instead, there's no way to be sure just by looking at the callsite that the `JsonTypeInfo<T>` for that `T` is present. As in, one might've forgotten to add the `[JsonSerializable]` annotation on the context and you'd get no build error there. Are there plans to enforce this, or to maybe add an analyzer to validate callsites to account for this, or something? Additionally, are there any performance concerns in case there's tons of type infos being generated that this approach would have callers pass the whole context (which means it'd have to resolve the right type info), instead of just statically retrieving the correct `JsonTypeInfo<T>` member directly as a direct property read? 🤔\r\n\r\n> \"Generally speaking it should contribute to code size increases, see https://github.com/dotnet/runtime/issues/77897 as an example.\"\r\n\r\nJust in case there's anyone else curious about that and/or following the issue, we're working on adjusting things on our end as well to help reduce the binary size impact (as a separate effort than the planned improvements for the JSON generator), so we'll share what we've learnt and what numbers we got once we're done with that. I'm hoping we'll be able to have a noticeable binary size reduction compared to that whopping +17MB increase by just tweaking our JSON models 🙂\r\n\r\nAnd of course, all the planned improvements to reuse generate stubs should also help a ton for folks in these situations.",
          "createdAt": "2023-01-15T19:24:31Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-01-15T19:24:31Z",
          "id": "IC_kwDODI9FZc5Scm3k"
        },
        {
          "author": "layomia",
          "body": "> Unfortunately, that is not the case when it comes to using customized contract resolvers. These can only be consumed via the serialization methods that accept the optional JsonSerializerOptions argument which must be marked as RUC/RDC because of their default behavior.\r\n\r\n@eiriktsarpalis we could design API to attach a custom resolver to a context instance. Thought would have to into making it as clean as possible, but it should be just a wrapping.",
          "createdAt": "2023-01-15T21:37:47Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-01-15T21:37:47Z",
          "id": "IC_kwDODI9FZc5Sctz3"
        },
        {
          "author": "layomia",
          "body": "> OK, this makes sense then, thanks.\r\n> \r\n> > And that should be a fairly common scenario, given that each JsonSerializerContext generates metadata for the entire transitive closure of its type dependencies.\r\n> \r\n> This is good to know. Given that code size is a metric we're tracking for Native AOT we should keep an eye on how this scales out with larger apps. No action for now, though.\r\n\r\n@eiriktsarpalis @agocke @davidfowl  it might be good to think about it now. In the first release of the source generator, we decided not to introduce a global cache for sharing/abstracting metadata between assemblies. I think we should revisit the decision. Some potential challenges with this approach which would be good to keep in mind are documented [here](https://devblogs.microsoft.com/dotnet/try-the-new-system-text-json-source-generator/#versioning).\r\n\r\nMy idea at the time (toward the end of .NET 6 dev time) was to use `Assembly.GetCallingAssembly` as a mechanism to partition the cache but @jkotas pointed out that it was slow and unreliable. His thought was that the solution requires new thinking (in .NET 7 or after) across the ASP.NET, serializer(s), source generators, and IL linker. \r\n\r\nWanted to share this now in case it sparks some ideas.",
          "createdAt": "2023-01-16T00:22:00Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-01-16T10:49:11Z",
          "id": "IC_kwDODI9FZc5Sc3ej"
        },
        {
          "author": "layomia",
          "body": "Also cc @eerhardt - https://github.com/dotnet/runtime/issues/74492#issuecomment-1383298979.",
          "createdAt": "2023-01-16T00:22:42Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-01-16T10:49:24Z",
          "id": "IC_kwDODI9FZc5Sc3i6"
        },
        {
          "author": "jkotas",
          "body": "The callsite rewriting gives you fast reliable equivalent of `Assembly.GetCallingAssembly`, but I do not see how it can help to solve the versioning problems described in the blog post.",
          "createdAt": "2023-01-16T01:02:57Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-01-16T10:49:36Z",
          "id": "IC_kwDODI9FZc5Sc7wi"
        },
        {
          "author": "layomia",
          "body": "Gotcha. If we have a design to reduce the size of source generated code (https://github.com/dotnet/runtime/issues/77897) with the primary mechanism being shared caches between assemblies, do you think it would be incomplete if it doesn't solve the versioning issues? I recognize this area needs careful evaluation of the trade-offs (guided by .NET 8 goals).",
          "createdAt": "2023-01-16T03:04:21Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-01-16T10:49:57Z",
          "id": "IC_kwDODI9FZc5SdRfw"
        },
        {
          "author": "jkotas",
          "body": "I think large projects have high probability of running into versioning issues. It is very common for large projects to run into versioning issues with Newtonsoft.Json today. We do not want source generators turn into a new source of versioning problems that are impossible to solve.\r\n\r\nIf we are considering schemes that allow sharing of source generated serializers, I think we need to design it such that there is always an option to make explicit choice about when to share and when not share the source generated serializers.",
          "createdAt": "2023-01-16T03:30:54Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-01-16T04:16:21Z",
                "user": "layomia"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOCyr6ng=="
          },
          "updatedAt": "2023-01-16T10:50:08Z",
          "id": "IC_kwDODI9FZc5SdXSp"
        },
        {
          "author": "layomia",
          "body": "The off-topic conversation was about reducing the size footprint of src-gen'd code. It was moved to the appropriate issue: https://github.com/dotnet/runtime/issues/77897#issuecomment-1383852837.\r\n",
          "createdAt": "2023-01-16T04:17:10Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-01-16T10:54:03Z",
          "id": "IC_kwDODI9FZc5SdgRF"
        },
        {
          "author": "eiriktsarpalis",
          "body": "> looking at that example I'm a bit worried about the fact you don't have an explicit T check anymore compared to using a JsonTypeInfo<T> instance.\r\n\r\nThe proposal concerns exposing functionality that supersedes the `JsonSerializer` methods that accept `JsonSerializerOptions` parameter. The overloads accepting `JsonTypeInfo` don't have the aforementioned issues and as such the recommendation is to keep using them for statically typed serialization. I considered the possibility of proposing `Serialize` and `Deserialize` as extension methods on `JsonTypeInfo` instances themselves, but ultimately wouldn't provide much benefit compared to the existing APIs -- as you're pointing out they're fairly easy to define if necessary.",
          "createdAt": "2023-01-16T10:22:44Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-01-16T10:22:44Z",
          "id": "IC_kwDODI9FZc5Se2cE"
        },
        {
          "author": "Sergio0694",
          "body": "Ah, gotcha, yeah that makes sense, thank you for clarifying! 🙂\r\n\r\nSomewhat related, this also makes me think whether people currently suffering from the issues described here (eg. creating options every time or forgetting to pass them) couldn't already solve the issue by just defining multiple option accessors in the context and then just statically accessing that like with the default one 🤔\r\n\r\nTo make an example, one thing we're doing in the Store is, we have some cases where we want to serialize/deserialize with case invariant properties (but it could be any example of \"some statically known set of options different than the default ones to customize a given serialization operation\"). What we did is to just add a separate property to our JSON context, like so:\r\n\r\n```csharp\r\npublic sealed partial class MicrosoftStoreJsonSerializerContext : JsonSerializerContext\r\n{\r\n    private static MicrosoftStoreJsonSerializerContext? _camelCase;\r\n\r\n    public static MicrosoftStoreJsonSerializerContext CamelCase => _camelCase ??= new(new JsonSerializerOptions(s_defaultOptions) { PropertyNamingPolicy = JsonNamingPolicy.CamelCase });\r\n}\r\n```\r\n\r\nThis way whenever we need to use this, we simply use `CamelCase` instead of `Default` and keep the same pattern:\r\n\r\n```csharp\r\nSomeModel model = MicrosoftStoreJsonSerializerContext.CamelCase.SomeModel.Deserialize(json);\r\n```\r\n\r\nI wonder whether at least for cases where the options being used only have statically known properties (eg. like the naming policy here) it wouldn't be simpler for people to use this approach instead, which also doesn't need any new APIs. I guess I'm just curious because by just looking at the examples, for cases where again you only have statically known options, it's not immediately clear to me why should one use the new instance method approach to replace using `JsonSerializer` overloads taking explicit options, instead of just statically accessing the shared JSON context with the embedded custom options like above (which as mentioned also doesn't need any new API). Similarly for cases where `JsonTypeInfo<T>` isn't used, this approach also lets one just pass `YourJsonContext.TheCustomProperty.Options` to access the shared options to pass to `JsonSerializer`, which also avoids the issue of potentially creating options for every call. To be clear, just trying to understand this proposal better 😄",
          "createdAt": "2023-01-16T10:43:33Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-01-16T10:43:33Z",
          "id": "IC_kwDODI9FZc5Se9IA"
        },
        {
          "author": "stephentoub",
          "body": ">> Creating a new JsonSerializerOptions instance on each serialization\r\n\r\n> people currently suffering from the issues described here (eg. creating options every time\r\n\r\nThe other reasons may be sufficient to add such APIs, but I continue to believe adding them to avoid the pitfalls of creating options every time is misguided. We have plenty of evidence developers are just as happy to create a new instance of a serializer every time they need to serialize/deserialize something (see practically every use of BinaryFormatter), and even outside of the serializers (e.g. HttpClient), even when guidance strongly urges otherwise. ",
          "createdAt": "2023-01-16T13:25:23Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-01-17T06:23:07Z",
                "user": "davidfowl"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOCywSCQ=="
          },
          "updatedAt": "2023-01-16T13:28:18Z",
          "id": "IC_kwDODI9FZc5SfxMN"
        },
        {
          "author": "davidfowl",
          "body": "We need runtime analyzers 😄 ",
          "createdAt": "2023-01-17T06:23:38Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "HEART",
                "createdAt": "2023-01-17T09:21:03Z",
                "user": "alefranz"
              },
              {
                "content": "LAUGH",
                "createdAt": "2023-01-17T18:16:52Z",
                "user": "eiriktsarpalis"
              },
              {
                "content": "HEART",
                "createdAt": "2024-01-24T18:06:41Z",
                "user": "begerard"
              }
            ],
            "totalCount": 3,
            "endCursor": "Y3Vyc29yOnYyOpHODT8oGw=="
          },
          "updatedAt": "2023-01-17T06:23:38Z",
          "id": "IC_kwDODI9FZc5Si79k"
        },
        {
          "author": "Neme12",
          "body": "> Also instantiating a \"serializer\" class may end up having the same problem we have today for those who just new up the \"options\" class on every use.\r\n\r\nI think people are a lot less likely to write `new JsonSerializer().Serialize(obj)` than `JsonSerializer.Serialize(obj, new JsonSerializerOptions(...))`",
          "createdAt": "2023-09-09T15:12:31Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-09-09T15:12:57Z",
          "id": "IC_kwDODI9FZc5mEzJ7"
        },
        {
          "author": "Reza-Noei",
          "body": "Any update on this ? \r\n\r\nI personally don't want to add extra attribute on every single Properties of my custom type.\r\n\r\n@eiriktsarpalis ",
          "createdAt": "2023-12-12T16:46:18Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-12-13T04:10:52Z",
                "user": "siadatism"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-12-13T11:30:33Z",
                "user": "soroshsabz"
              }
            ],
            "totalCount": 2,
            "endCursor": "Y3Vyc29yOnYyOpHODPbtPQ=="
          },
          "updatedAt": "2023-12-12T16:46:18Z",
          "id": "IC_kwDODI9FZc5uaacH"
        },
        {
          "author": "eiriktsarpalis",
          "body": "This design is not being pursued for the near term.",
          "createdAt": "2023-12-12T18:19:57Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_DOWN",
                "createdAt": "2023-12-13T11:30:43Z",
                "user": "soroshsabz"
              },
              {
                "content": "THUMBS_DOWN",
                "createdAt": "2024-04-12T09:07:09Z",
                "user": "miminno"
              },
              {
                "content": "THUMBS_DOWN",
                "createdAt": "2024-07-15T23:44:20Z",
                "user": "MaxwellDAssistek"
              }
            ],
            "totalCount": 3,
            "endCursor": "Y3Vyc29yOnYyOpHODp2I4Q=="
          },
          "updatedAt": "2023-12-12T18:19:57Z",
          "id": "IC_kwDODI9FZc5ubAvB"
        },
        {
          "author": "Reza-Noei",
          "body": "> This design is not being pursued for the near term.\r\n\r\n I may have misunderstood your words, but I have something like the following:\r\n\r\n     public class Customer \r\n     {\r\n        ....\r\n        [JsonConverter(typeof(MsisdnConverter))]\r\n        public MSISDN Msisdn { get; set; }\r\n        ....\r\n     }\r\n     \r\n     public class SubscriberCard \r\n     {\r\n        ....\r\n        [JsonConverter(typeof(MsisdnConverter))]\r\n        public MSISDN Msisdn { get; set; }\r\n        ....\r\n     }\r\n     \r\nI have defined `Msisdn` as a building block of my enterprise application. \r\n\r\nI don't want to be worry about missing `[JsonConverter(typeof(MsisdnConverter))]` in the rest of my project (we have several developers in our team and it's totally possible). Similar to what `System.Text.Json` does with `DateTime`, I want to register a `JsonConverter` globally. \r\n\r\nI believe this requirement is meaningful, and I have searched for information on it (Note: `Newtonsoft.Json` has a way of handling this). \r\n\r\nI found this Issue to be the closest one. \r\nI can provide you with a design for this feature, but I still believe it's related to this Issue.\r\n\r\n@eiriktsarpalis ",
          "createdAt": "2023-12-13T14:07:34Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-12-13T14:10:14Z",
          "id": "IC_kwDODI9FZc5ugY-U"
        },
        {
          "author": "eiriktsarpalis",
          "body": "This appears to be unrelated to what is being discussed in this issue. You can apply a custom converter for your `MSISDN` type globally today either by applying a `JsonConverter` annotation on the type itself or by specifying it on the `JsonSerializerOptions.Converters` property.",
          "createdAt": "2023-12-13T14:26:05Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-12-13T14:26:05Z",
          "id": "IC_kwDODI9FZc5uggj2"
        },
        {
          "author": "andre-ss6",
          "body": "@eiriktsarpalis At https://github.com/dotnet/runtime/issues/31094#issuecomment-1166232038, you hinted that you'd prefer a design without an interface, and that is what you are proposing here as well.\r\n\r\nI'm curious, what was the reasoning behind the team choosing not to define an abstract interface for this? Why have only the static API?\r\n\r\nIf we had an interface, then we'd at least have a standard way to encapsulate a serializer and for libraries to depend on that.",
          "createdAt": "2024-08-08T12:41:37Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-08-08T12:41:37Z",
          "id": "IC_kwDODI9FZc6HpNMP"
        },
        {
          "author": "andre-ss6",
          "body": "Also, that issue remains, to this day, one of the top liked issues in this repo, even though it has been locked -- thus freezing reactions -- for two years now, so there seems to be clear interest from the community. Could the team share any insights as to why this is not currently a priority? Is there anything the community can do to help?",
          "createdAt": "2024-08-08T12:47:04Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-08-08T12:54:42Z",
          "id": "IC_kwDODI9FZc6HpQDS"
        },
        {
          "author": "shearer3000",
          "body": "who's here in almost 2025 and you can't config global serialisation defaults but they went to the moon in 69...\n",
          "createdAt": "2024-12-03T08:11:39Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_DOWN",
                "createdAt": "2024-12-03T16:58:22Z",
                "user": "Sergio0694"
              },
              {
                "content": "THUMBS_DOWN",
                "createdAt": "2024-12-04T20:07:24Z",
                "user": "OskarKlintrot"
              },
              {
                "content": "ROCKET",
                "createdAt": "2025-01-11T22:09:29Z",
                "user": "HugCoder"
              }
            ],
            "totalCount": 3,
            "endCursor": "Y3Vyc29yOnYyOpHOECCUjg=="
          },
          "updatedAt": "2024-12-03T08:13:19Z",
          "id": "IC_kwDODI9FZc6V1dip"
        },
        {
          "author": "davidfowl",
          "body": "Mutable statics are 👎🏾 ",
          "createdAt": "2024-12-03T17:16:29Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-12-03T17:29:14Z",
                "user": "eiriktsarpalis"
              },
              {
                "content": "THUMBS_DOWN",
                "createdAt": "2024-12-03T23:10:17Z",
                "user": "andre-ss6"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-12-04T20:07:24Z",
                "user": "OskarKlintrot"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-01-17T18:24:14Z",
                "user": "chrisoverzero"
              }
            ],
            "totalCount": 4,
            "endCursor": "Y3Vyc29yOnYyOpHOEDBn4A=="
          },
          "updatedAt": "2024-12-03T17:16:29Z",
          "id": "IC_kwDODI9FZc6V6hIe"
        },
        {
          "author": "ChrML",
          "body": "> who's here in almost 2025 and you can't config global serialisation defaults but they went to the moon in 69...\n\nYou can, by rolling your own wrapper. Unless it's extremely useful for most devs, I suggest leaving it out.\n\nI'm not sure making instances of this would be any better, it adds a lot of stuff for a very specific situation. And imo it doesn't help much if you want it global, as you still need to pass the JsonSerializer around.",
          "createdAt": "2025-02-14T02:01:44Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-04-28T12:44:57Z",
                "user": "TacoGuyAT"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOEP7P1w=="
          },
          "updatedAt": "2025-02-14T02:02:29Z",
          "id": "IC_kwDODI9FZc6eb01p"
        }
      ],
      "totalCount": 40,
      "endCursor": "Y3Vyc29yOnYyOpHOnm9NaQ=="
    },
    "url": "https://github.com/dotnet/runtime/issues/74492",
    "title": "Expose instance methods in JsonSerializer"
  },
  {
    "author": "austindrenski",
    "labels": [
      "enhancement",
      "area-System.Text.Json",
      "source-generator"
    ],
    "createdAt": "2022-08-26T14:48:21Z",
    "body": "### Description\r\n\r\n`JsonSerializerContext` produces warnings when models contain `StringValues` due to nullable annotation mismatch.\r\n\r\n\r\n### Reproduction Steps\r\n\r\n```csproj\r\n<Project Sdk=\"Microsoft.NET.Sdk\">\r\n\r\n  <PropertyGroup>\r\n    <LangVersion>latest</LangVersion>\r\n    <Nullable>enable</Nullable>\r\n    <OutputType>exe</OutputType>\r\n    <TargetFramework>net7.0</TargetFramework>\r\n  </PropertyGroup>\r\n\r\n  <ItemGroup>\r\n    <PackageReference Include=\"Microsoft.Extensions.Primitives\" Version=\"7.0.0-preview.7.22375.6\" />\r\n    <PackageReference Include=\"System.Text.Json\" Version=\"7.0.0-preview.7.22375.6\" />\r\n  </ItemGroup>\r\n\r\n</Project>\r\n```\r\n\r\n```csharp\r\nusing System;\r\nusing System.Text.Json.Serialization;\r\nusing Microsoft.Extensions.Primitives;\r\n\r\nConsole.WriteLine(\"Hello, world!\");\r\n\r\n[JsonSerializable(typeof(SomeClass))]\r\n[JsonSourceGenerationOptions(GenerationMode = JsonSourceGenerationMode.Default)]\r\npublic sealed partial class SomeJsonSerializerContext : JsonSerializerContext\r\n{\r\n}\r\n\r\npublic sealed class SomeClass\r\n{\r\n    public StringValues SomeStringValues { get; set; }\r\n}\r\n```\r\n\r\n```console\r\n$ dotnet build\r\nMSBuild version 17.4.0-preview-22368-02+c8492483a for .NET\r\n  Determining projects to restore...\r\n  All projects are up-to-date for restore.\r\nC:\\Program Files\\dotnet\\sdk\\7.0.100-preview.7.22377.5\\Sdks\\Microsoft.NET.Sdk\\targets\\Microsoft.NET.RuntimeIdentifierInference.targets(219,5): message NETSDK1057: You are using a preview version of .NET. See: https://aka.ms/dotnet-support-policy [C:\\Users\\adren\\rider\\system-text-json-source-generator-fails-on-stringvalues\\system-text-json-source-generator-fails-on-stringvalues.csproj]\r\nC:\\Users\\adren\\rider\\system-text-json-source-generator-fails-on-stringvalues\\System.Text.Json.SourceGeneration\\System.Text.Json.SourceGeneration.JsonSourceGenerator\\SomeJsonSerializerContext.StringValues.g.cs(31,32): warning CS8631: The type 'Microsoft.Extensions.Primitives.StringValues' cannot be used as type parameter 'TCollection' in the generic type or method 'JsonMetadataServices.CreateIListInfo<TCollection, TElement>(JsonSerializerOptions, JsonCollectionInfoValues<TCollection>)'. Nullability of type argument 'Microsoft.Extensions.Primitives.StringValues' doesn't match constraint type 'System.Collections.Generic.IList<string>'. [C:\\Users\\adren\\rider\\system-text-json-source-generator-fails-on-stringvalues\\system-text-json-source-generator-fails-on-stringvalues.csproj]\r\n  system-text-json-source-generator-fails-on-stringvalues -> C:\\Users\\adren\\rider\\system-text-json-source-generator-fails-on-stringvalues\\bin\\Debug\\net7.0\\system-text-json-source-generator-fails-on-stringvalues.dll\r\n\r\nBuild succeeded.\r\n\r\nC:\\Users\\adren\\rider\\system-text-json-source-generator-fails-on-stringvalues\\System.Text.Json.SourceGeneration\\System.Text.Json.SourceGeneration.JsonSourceGenerator\\SomeJsonSerializerContext.StringValues.g.cs(31,32): warning CS8631: The type 'Microsoft.Extensions.Primitives.StringValues' cannot be used as type parameter 'TCollection' in the generic type or method 'JsonMetadataServices.CreateIListInfo<TCollection, TElement>(JsonSerializerOptions, JsonCollectionInfoValues<TCollection>)'. Nullability of type argument 'Microsoft.Extensions.Primitives.StringValues' doesn't match constraint type 'System.Collections.Generic.IList<string>'. [C:\\Users\\adren\\rider\\system-text-json-source-generator-fails-on-stringvalues\\system-text-json-source-generator-fails-on-stringvalues.csproj]\r\n    1 Warning(s)\r\n    0 Error(s)\r\n\r\nTime Elapsed 00:00:01.41\r\n```\r\n\r\n### Expected behavior\r\n\r\nUsing `StringValues` in conjunction with `JsonSerializerContext` does not produce warnings.\r\n\r\n### Actual behavior\r\n\r\nUsing `StringValues` in conjunction with `JsonSerializerContext` produces warnings.\r\n\r\n> warning CS8631: The type 'Microsoft.Extensions.Primitives.StringValues' cannot be used as type parameter 'TCollection' in the generic type or method 'JsonMetadataServices.CreateIListInfo<TCollection, TElement>(JsonSerializerOptions, JsonCollectionInfoValues<TCollection>)'. Nullability of type argument 'Microsoft.Extensions.Primitives.StringValues' doesn't match constraint type 'System.Collections.Generic.IList<string>'.\r\n\r\n### Regression?\r\n\r\nThis works when using version `6.0.0` of `Microsoft.Extensions.Primitives` because the interfaces for `StringValues` were updated with nullable annotations for `7.0.0-preview*`.\r\n\r\n\r\n### Known Workarounds\r\n\r\n- Suppress `CS8631`\r\n- Stay on version `6.0.0` of `Microsoft.Extensions.Primitives`\r\n\r\n### Configuration\r\n\r\n```console\r\n$ dotnet --info\r\n.NET SDK:\r\n Version:   7.0.100-preview.7.22377.5\r\n Commit:    ba310d9309\r\n\r\nRuntime Environment:\r\n OS Name:     Windows\r\n OS Version:  10.0.22000\r\n OS Platform: Windows\r\n RID:         win10-x64\r\n Base Path:   C:\\Program Files\\dotnet\\sdk\\7.0.100-preview.7.22377.5\\\r\n\r\nHost:\r\n  Version:      7.0.0-preview.7.22375.6\r\n  Architecture: x64\r\n  Commit:       eecb028078\r\n```\r\n\r\n### Other information\r\n\r\nNot sure where the fix belongs, but here's where the warning bubbles from:\r\n\r\nhttps://github.com/dotnet/runtime/blob/536f34d9ab88e153aa11329e789afe6975fbe9a9/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/Metadata/JsonMetadataServices.Collections.cs#L195-L198",
    "number": 74652,
    "reactions": {
      "hasNextPage": false,
      "nodes": [],
      "totalCount": 0,
      "endCursor": null
    },
    "updatedAt": "2022-09-07T08:40:25Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\n### Description\n\n`System.Text.Json.JsonSerializerContext` produces warnings when models contain `StringValues` due to nullable annotation mismatch.\r\n\n\n### Reproduction Steps\n\n```csproj\r\n<Project Sdk=\"Microsoft.NET.Sdk\">\r\n\r\n  <PropertyGroup>\r\n    <LangVersion>latest</LangVersion>\r\n    <Nullable>enable</Nullable>\r\n    <OutputType>exe</OutputType>\r\n    <TargetFramework>net7.0</TargetFramework>\r\n  </PropertyGroup>\r\n\r\n  <ItemGroup>\r\n    <PackageReference Include=\"Microsoft.Extensions.Primitives\" Version=\"7.0.0-preview.7.22375.6\" />\r\n    <PackageReference Include=\"System.Text.Json\" Version=\"7.0.0-preview.7.22375.6\" />\r\n  </ItemGroup>\r\n\r\n</Project>\r\n```\r\n\r\n```csharp\r\nusing System;\r\nusing System.Text.Json.Serialization;\r\nusing Microsoft.Extensions.Primitives;\r\n\r\nConsole.WriteLine(\"Hello, world!\");\r\n\r\n[JsonSerializable(typeof(SomeClass))]\r\n[JsonSourceGenerationOptions(GenerationMode = JsonSourceGenerationMode.Default)]\r\npublic sealed partial class SomeJsonSerializerContext : JsonSerializerContext\r\n{\r\n}\r\n\r\npublic sealed class SomeClass\r\n{\r\n    public StringValues SomeStringValues { get; set; }\r\n}\r\n```\r\n\r\n```console\r\n$ dotnet build\r\nMSBuild version 17.4.0-preview-22368-02+c8492483a for .NET\r\n  Determining projects to restore...\r\n  All projects are up-to-date for restore.\r\nC:\\Program Files\\dotnet\\sdk\\7.0.100-preview.7.22377.5\\Sdks\\Microsoft.NET.Sdk\\targets\\Microsoft.NET.RuntimeIdentifierInference.targets(219,5): message NETSDK1057: You are using a preview version of .NET. See: https://aka.ms/dotnet-support-policy [C:\\Users\\adren\\rider\\system-text-json-source-generator-fails-on-stringvalues\\system-text-json-source-generator-fails-on-stringvalues.csproj]\r\nC:\\Users\\adren\\rider\\system-text-json-source-generator-fails-on-stringvalues\\System.Text.Json.SourceGeneration\\System.Text.Json.SourceGeneration.JsonSourceGenerator\\SomeJsonSerializerContext.StringValues.g.cs(31,32): warning CS8631: The type 'Microsoft.Extensions.Primitives.StringValues' cannot be used as type parameter 'TCollection' in the generic type or method 'JsonMetadataServices.CreateIListInfo<TCollection, TElement>(JsonSerializerOptions, JsonCollectionInfoValues<TCollection>)'. Nullability of type argument 'Microsoft.Extensions.Primitives.StringValues' doesn't match constraint type 'System.Collections.Generic.IList<string>'. [C:\\Users\\adren\\rider\\system-text-json-source-generator-fails-on-stringvalues\\system-text-json-source-generator-fails-on-stringvalues.csproj]\r\n  system-text-json-source-generator-fails-on-stringvalues -> C:\\Users\\adren\\rider\\system-text-json-source-generator-fails-on-stringvalues\\bin\\Debug\\net7.0\\system-text-json-source-generator-fails-on-stringvalues.dll\r\n\r\nBuild succeeded.\r\n\r\nC:\\Users\\adren\\rider\\system-text-json-source-generator-fails-on-stringvalues\\System.Text.Json.SourceGeneration\\System.Text.Json.SourceGeneration.JsonSourceGenerator\\SomeJsonSerializerContext.StringValues.g.cs(31,32): warning CS8631: The type 'Microsoft.Extensions.Primitives.StringValues' cannot be used as type parameter 'TCollection' in the generic type or method 'JsonMetadataServices.CreateIListInfo<TCollection, TElement>(JsonSerializerOptions, JsonCollectionInfoValues<TCollection>)'. Nullability of type argument 'Microsoft.Extensions.Primitives.StringValues' doesn't match constraint type 'System.Collections.Generic.IList<string>'. [C:\\Users\\adren\\rider\\system-text-json-source-generator-fails-on-stringvalues\\system-text-json-source-generator-fails-on-stringvalues.csproj]\r\n    1 Warning(s)\r\n    0 Error(s)\r\n\r\nTime Elapsed 00:00:01.41\r\n```\n\n### Expected behavior\n\nUsing `StringValues` in conjunction with `JsonSerializerContext` does not produce warnings.\n\n### Actual behavior\n\nUsing `StringValues` in conjunction with `JsonSerializerContext` produces warnings.\r\n\r\n> warning CS8631: The type 'Microsoft.Extensions.Primitives.StringValues' cannot be used as type parameter 'TCollection' in the generic type or method 'JsonMetadataServices.CreateIListInfo<TCollection, TElement>(JsonSerializerOptions, JsonCollectionInfoValues<TCollection>)'. Nullability of type argument 'Microsoft.Extensions.Primitives.StringValues' doesn't match constraint type 'System.Collections.Generic.IList<string>'.\n\n### Regression?\n\nThis works when using version `6.0.0` of `Microsoft.Extensions.Primitives` because the interfaces for `StringValues` were updated with nullable annotations for `7.0.0-preview*`.\r\n\n\n### Known Workarounds\n\n- Suppress `CS8631`\r\n- Stay on version `6.0.0` of `Microsoft.Extensions.Primitives`\n\n### Configuration\n\n```console\r\n$ dotnet --info\r\n.NET SDK:\r\n Version:   7.0.100-preview.7.22377.5\r\n Commit:    ba310d9309\r\n\r\nRuntime Environment:\r\n OS Name:     Windows\r\n OS Version:  10.0.22000\r\n OS Platform: Windows\r\n RID:         win10-x64\r\n Base Path:   C:\\Program Files\\dotnet\\sdk\\7.0.100-preview.7.22377.5\\\r\n\r\nHost:\r\n  Version:      7.0.0-preview.7.22375.6\r\n  Architecture: x64\r\n  Commit:       eecb028078\r\n```\n\n### Other information\n\nNot sure where the fix belongs, but here's where the warning bubbles from:\r\n\r\nhttps://github.com/dotnet/runtime/blob/536f34d9ab88e153aa11329e789afe6975fbe9a9/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/Metadata/JsonMetadataServices.Collections.cs#L195-L198\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>austindrenski</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`area-System.Text.Json`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2022-08-26T14:48:31Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-08-26T14:48:31Z",
          "id": "IC_kwDODI9FZc5JOsyv"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Related to #61734. I don't believe this is a regression in .NET 7, the warnings have surfaced because of updates to the nullability annotation of `StringValues`.",
          "createdAt": "2022-08-26T16:28:37Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-08-26T16:29:55Z",
          "id": "IC_kwDODI9FZc5JPHBG"
        },
        {
          "author": "austindrenski",
          "body": "> Related to #61734. I don't believe this is a regression in .NET 7, the warnings have surfaced because of updates to the nullability annotation of `StringValues`.\r\n\r\n@eiriktsarpalis I agree this isn't an STJ regression in .NET 7 (traces back to #55566 which shipped with .NET 6), but I _was_ surprised to run into it using a combination of `System.Text.Json` + `Microsoft.Extensions.Primitives` (i.e. no shade, just the same repo, so had assumed there would have been a test case somewhere).\r\n\r\nGiven RC1 is right around the corner, I'm assuming this won't meet the bar for shipping with `7.0.0`, but since it looks like it impacts _any_ `IList<T?> where T : class`, would it meet the bar for an STJ `7.0.1` release? \r\n\r\n## Investigation stuff\r\n\r\n_Collecting snippets here to see if this is something I can contribute to, or if it's out of my depth._\r\n\r\nHere's the generated source causing the issue from `SomeJsonSerializerContext.StringValues.g.cs`:\r\n\r\n```csharp\r\n// <auto-generated/>\r\n#nullable enable\r\n\r\n// Suppress warnings about [Obsolete] member usage in generated code.\r\n#pragma warning disable CS0618\r\n    public sealed partial class SomeJsonSerializerContext\r\n    {\r\n        private global::System.Text.Json.Serialization.Metadata.JsonTypeInfo<global::Microsoft.Extensions.Primitives.StringValues>? _StringValues;\r\n        public global::System.Text.Json.Serialization.Metadata.JsonTypeInfo<global::Microsoft.Extensions.Primitives.StringValues> StringValues\r\n        {\r\n            get => _StringValues ??= Create_StringValues(Options);\r\n        }\r\n        \r\n        private static global::System.Text.Json.Serialization.Metadata.JsonTypeInfo<global::Microsoft.Extensions.Primitives.StringValues> Create_StringValues(global::System.Text.Json.JsonSerializerOptions options)\r\n        {\r\n            global::System.Text.Json.Serialization.Metadata.JsonTypeInfo<global::Microsoft.Extensions.Primitives.StringValues>? jsonTypeInfo = null;\r\n            global::System.Text.Json.Serialization.JsonConverter? customConverter;\r\n            if (options.Converters.Count > 0 && (customConverter = GetRuntimeProvidedCustomConverter(options, typeof(global::Microsoft.Extensions.Primitives.StringValues))) != null)\r\n            {\r\n                jsonTypeInfo = global::System.Text.Json.Serialization.Metadata.JsonMetadataServices.CreateValueInfo<global::Microsoft.Extensions.Primitives.StringValues>(options, customConverter);\r\n            }\r\n            else\r\n            {\r\n                global::System.Text.Json.Serialization.Metadata.JsonCollectionInfoValues<global::Microsoft.Extensions.Primitives.StringValues> info = new global::System.Text.Json.Serialization.Metadata.JsonCollectionInfoValues<global::Microsoft.Extensions.Primitives.StringValues>()\r\n                {\r\n                    ObjectCreator = () => new global::Microsoft.Extensions.Primitives.StringValues(),\r\n                    NumberHandling = default,\r\n                    SerializeHandler = StringValuesSerializeHandler\r\n                };\r\n        \r\n                jsonTypeInfo = global::System.Text.Json.Serialization.Metadata.JsonMetadataServices.CreateIListInfo<global::Microsoft.Extensions.Primitives.StringValues, global::System.String>(options, info);\r\n        \r\n            }\r\n        \r\n            return jsonTypeInfo;\r\n        }\r\n        \r\n        \r\n        private static void StringValuesSerializeHandler(global::System.Text.Json.Utf8JsonWriter writer, global::Microsoft.Extensions.Primitives.StringValues value)\r\n        {\r\n            \r\n            writer.WriteStartArray();\r\n        \r\n            for (int i = 0; i < value.Count; i++)\r\n            {\r\n                writer.WriteStringValue(value[i]);\r\n            }\r\n        \r\n            writer.WriteEndArray();\r\n        }\r\n    }\r\n```\r\n\r\nwhere the offending line is:\r\n\r\n```csharp\r\n                jsonTypeInfo = global::System.Text.Json.Serialization.Metadata.JsonMetadataServices.CreateIListInfo<global::Microsoft.Extensions.Primitives.StringValues, global::System.String>(options, info);\r\n```\r\n\r\nand the literal patch would be:\r\n\r\n```diff\r\n-               jsonTypeInfo = global::System.Text.Json.Serialization.Metadata.JsonMetadataServices.CreateIListInfo<global::Microsoft.Extensions.Primitives.StringValues, global::System.String>(options, info);\r\n+               jsonTypeInfo = global::System.Text.Json.Serialization.Metadata.JsonMetadataServices.CreateIListInfo<global::Microsoft.Extensions.Primitives.StringValues, global::System.String?>(options, info);\r\n```\r\n\r\nBack tracking through the generator source code:\r\n\r\n- https://github.com/dotnet/runtime/blob/ecb3038f03b833c4c4d71493898a4a6669d5dcc8/src/libraries/System.Text.Json/gen/JsonSourceGenerator.Emitter.cs#L480-L488\r\n- https://github.com/dotnet/runtime/blob/ecb3038f03b833c4c4d71493898a4a6669d5dcc8/src/libraries/System.Text.Json/gen/JsonSourceGenerator.Emitter.cs#L475-L477\r\n- https://github.com/dotnet/runtime/blob/ecb3038f03b833c4c4d71493898a4a6669d5dcc8/src/libraries/System.Text.Json/gen/JsonSourceGenerator.Emitter.cs#L441\r\n- https://github.com/dotnet/runtime/blob/ecb3038f03b833c4c4d71493898a4a6669d5dcc8/src/libraries/System.Text.Json/gen/JsonSourceGenerator.Emitter.cs#L389\r\n- https://github.com/dotnet/runtime/blob/ecb3038f03b833c4c4d71493898a4a6669d5dcc8/src/libraries/System.Text.Json/gen/JsonSourceGenerator.Emitter.cs#L387\r\n- https://github.com/dotnet/runtime/blob/ecb3038f03b833c4c4d71493898a4a6669d5dcc8/src/libraries/System.Text.Json/gen/TypeGenerationSpec.cs#L67\r\n- https://github.com/dotnet/runtime/blob/ecb3038f03b833c4c4d71493898a4a6669d5dcc8/src/libraries/System.Text.Json/gen/TypeGenerationSpec.cs#L17-L20\r\n- https://github.com/dotnet/runtime/blob/ecb3038f03b833c4c4d71493898a4a6669d5dcc8/src/libraries/System.Text.Json/gen/TypeGenerationSpec.cs#L139\r\n- https://github.com/dotnet/runtime/blob/ecb3038f03b833c4c4d71493898a4a6669d5dcc8/src/libraries/System.Text.Json/gen/Reflection/TypeExtensions.cs#L10-L72\r\n\r\nSo it seems like the patch would probably involve making `TypeGenerationSpec` (more) aware of the annotated nullability of collection types being passed into it. Or maybe preserving the exact annotations when the type is an implemented interface (i.e. `StringValues : IList<string?>`).\r\n\r\nNot sure how much work that would involve, but going to keep poking at this until/unless someone with more experience wants to jump in.",
          "createdAt": "2022-08-26T20:24:32Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-08-26T20:26:00Z",
          "id": "IC_kwDODI9FZc5JP7AN"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Honestly,  I don't think this would meet the bar for a .NET 7 fix at this stage. Realistically the only safe intervention might be to introduce a `#nullable disable warnings` declaration in all source generated files cc @layomia @krwq",
          "createdAt": "2022-08-26T20:41:51Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-08-26T22:04:19Z",
                "user": "austindrenski"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOCrPUeQ=="
          },
          "updatedAt": "2022-08-26T20:41:51Z",
          "id": "IC_kwDODI9FZc5JP_5v"
        },
        {
          "author": "krwq",
          "body": "Given though technically it isn't directly our regression it is a regression from the overall product perspective. IMO we should at least bar check this and I agree the appropriate fix for 7.0 (if any) seems like disabling warnings for the generated code since we don't know all the edge cases",
          "createdAt": "2022-08-29T06:00:33Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-08-29T13:25:18Z",
                "user": "austindrenski"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOCrTdNA=="
          },
          "updatedAt": "2022-08-29T07:12:39Z",
          "id": "IC_kwDODI9FZc5JTXZC"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Let's try to mitigate the problem (and the related issue in #61734) by disabling nullability warnings in .NET 7.",
          "createdAt": "2022-08-29T17:13:41Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-08-29T19:11:24Z",
                "user": "austindrenski"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOCrU5rQ=="
          },
          "updatedAt": "2022-08-29T17:13:41Z",
          "id": "IC_kwDODI9FZc5JWWmw"
        },
        {
          "author": "eiriktsarpalis",
          "body": "See https://github.com/dotnet/runtime/pull/74801#issuecomment-1231686867. We should keep this one open.",
          "createdAt": "2022-08-31T08:32:52Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-08-31T08:32:52Z",
          "id": "IC_kwDODI9FZc5JeH8P"
        }
      ],
      "totalCount": 7,
      "endCursor": "Y3Vyc29yOnYyOpHOSXh_Dw=="
    },
    "url": "https://github.com/dotnet/runtime/issues/74652",
    "title": "Using `StringValues` with `JsonSerializerContext` produces warnings with `7.0.0-preview*`"
  },
  {
    "author": "CollinAlpert",
    "labels": [
      "question",
      "area-System.Text.Json",
      "tracking-external-issue"
    ],
    "createdAt": "2022-08-30T21:19:42Z",
    "body": "### Description\n\nUsing the STJ source generator to generate the `JsonTypeInfo` for types yields incorrect results when using the `JsonTypeInfo` in a HTTP request if the properties of the type are source generated.\n\n### Reproduction Steps\n\nMy Web API:\r\n```csharp\r\nvar app = WebApplication.Create(args);\r\napp.MapGet(\"/person\", () => Results.Ok(new Person(\"Steve\", 50)));\r\napp.Run();\r\n\r\nrecord Person(string Name, int Age);\r\n```\r\n\r\nMy Console Application:\r\n```csharp\r\nusing System.Net.Http.Json;\r\nusing System.Text.Json;\r\nusing System.Text.Json.Serialization;\r\nusing Lombok.NET;\r\n\r\nnamespace Test;\r\n\r\npublic class Program\r\n{\r\n    private static readonly HttpClient HttpClient = new();\r\n\t\r\n    public static async Task Main()\r\n    {\r\n        var options = new JsonSerializerOptions(JsonSerializerDefaults.Web);\r\n        options.AddContext<JsonContext>();\r\n\t\t\r\n        var person = await HttpClient.GetFromJsonAsync<Person>(\"http://localhost:5000/person\", options);\r\n        Console.WriteLine(person.Name);\r\n    }\r\n}\r\n\r\npartial class Person\r\n{\r\n    [Property]\r\n    private string _name = default!;\r\n\r\n    [Property]\r\n    private int _age;\r\n}\r\n\r\n[JsonSerializable(typeof(Person))]\r\npartial class JsonContext : JsonSerializerContext\r\n{\r\n}\r\n```\r\n\r\nI use [Lombok.NET](https://www.nuget.org/packages/Lombok.NET/) to generate the properties from my fields.\n\n### Expected behavior\n\nThe Console Application prints \"Steve\".\n\n### Actual behavior\n\nTh Console Application prints nothing since `person.Name` is null.\n\n### Regression?\n\n_No response_\n\n### Known Workarounds\n\nWhen defining my `Person` class like this, everything works:\r\n```csharp\r\nclass Person\r\n{\r\n    private string _name = default!;\r\n    private int _age;\r\n\r\n    public string Name { get => _name; set => _name = value; }\r\n\r\n    public int Age { get => _age; set => _age = value; }\r\n}\r\n```\r\n\r\nThis is however exactly what Lombok.NET generates.\r\n\n\n### Configuration\n\n.NET 7.0.0-preview.6\r\nmacOS 12.5.1 with Apple Silicon\n\n### Other information\n\nI have a hunch that this is caused by the fact that source generators cannot be dependent on each other and the STJ generator runs before the property generator. However I can see that the STJ generator generates a `JsonTypeInfo` for `Int32` and `String`, so it seems to find the properties somehow.",
    "number": 74841,
    "reactions": {
      "hasNextPage": false,
      "nodes": [],
      "totalCount": 0,
      "endCursor": null
    },
    "updatedAt": "2024-09-27T14:30:24Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\n### Description\n\nUsing the STJ source generator to generate the `JsonTypeInfo` for types yields incorrect results when using the `JsonTypeInfo` in a HTTP request if the properties of the type are source generated.\n\n### Reproduction Steps\n\nMy Web API:\r\n```csharp\r\nvar app = WebApplication.Create(args);\r\napp.MapGet(\"/person\", () => Results.Ok(new Person(\"Steve\", 50)));\r\napp.Run();\r\n\r\nrecord Person(string Name, int Age);\r\n```\r\n\r\nMy Console Application:\r\n```csharp\r\nusing System.Net.Http.Json;\r\nusing System.Text.Json;\r\nusing System.Text.Json.Serialization;\r\nusing Lombok.NET;\r\n\r\nnamespace Test;\r\n\r\npublic class Program\r\n{\r\n    private static readonly HttpClient HttpClient = new();\r\n\t\r\n    public static async Task Main()\r\n    {\r\n        var options = new JsonSerializerOptions(JsonSerializerDefaults.Web);\r\n        options.AddContext<JsonContext>();\r\n\t\t\r\n        var person = await HttpClient.GetFromJsonAsync<Person>(\"http://localhost:5000/person\", options);\r\n        Console.WriteLine(person.Name);\r\n    }\r\n}\r\n\r\npartial class Person\r\n{\r\n    [Property]\r\n    private string _name = default!;\r\n\r\n    [Property]\r\n    private int _age;\r\n}\r\n\r\n[JsonSerializable(typeof(Person))]\r\npartial class JsonContext : JsonSerializerContext\r\n{\r\n}\r\n```\r\n\r\nI use [Lombok.NET](https://www.nuget.org/packages/Lombok.NET/) to generate the properties from my fields.\n\n### Expected behavior\n\nThe Console Application prints \"Steve\".\n\n### Actual behavior\n\nTh Console Application prints nothing since `person.Name` is null.\n\n### Regression?\n\n_No response_\n\n### Known Workarounds\n\nWhen defining my `Person` class like this, everything works:\r\n```csharp\r\nclass Person\r\n{\r\n    private string _name = default!;\r\n    private int _age;\r\n\r\n    public string Name { get => _name; set => _name = value; }\r\n\r\n    public int Age { get => _age; set => _age = value; }\r\n}\r\n```\r\n\r\nThis is however exactly what Lombok.NET generates.\r\n\n\n### Configuration\n\n.NET 7.0.0-preview.6\r\nmacOS 12.5.1 with Apple Silicon\n\n### Other information\n\nI have a hunch that this is caused by the fact that source generators cannot be dependent on each other and the STJ generator runs before the property generator. However I can see that the STJ generator generates a `JsonTypeInfo` for `Int32` and `String`, so it seems to find the properties somehow.\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>CollinAlpert</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`area-System.Text.Json`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2022-08-30T21:19:57Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-08-30T21:19:57Z",
          "id": "IC_kwDODI9FZc5JcZUF"
        },
        {
          "author": "teo-tsirpanis",
          "body": "I think that this behavior is expected; source generators cannot see each other's output.",
          "createdAt": "2022-08-31T08:09:52Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-08-31T08:09:52Z",
          "id": "IC_kwDODI9FZc5JeB1c"
        },
        {
          "author": "krwq",
          "body": "AFAIK generators cannot be chained but it might be possible to work-around this issue by putting JsonSerializerContext in the separate library which depends on what Lombok produces",
          "createdAt": "2022-08-31T09:23:56Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-08-31T09:47:58Z",
                "user": "eiriktsarpalis"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOCrb36g=="
          },
          "updatedAt": "2022-08-31T09:24:07Z",
          "id": "IC_kwDODI9FZc5JeWUD"
        },
        {
          "author": "krwq",
          "body": "perhaps @333fred might have some other ideas about chaining",
          "createdAt": "2022-08-31T09:26:26Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "HEART",
                "createdAt": "2022-08-31T09:33:26Z",
                "user": "CollinAlpert"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOCrb0nA=="
          },
          "updatedAt": "2022-08-31T09:26:33Z",
          "id": "IC_kwDODI9FZc5JeW72"
        },
        {
          "author": "333fred",
          "body": "See https://github.com/dotnet/roslyn/issues/57239. ",
          "createdAt": "2022-08-31T14:15:33Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-08-31T14:17:30Z",
                "user": "CollinAlpert"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-08-31T16:24:37Z",
                "user": "eiriktsarpalis"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-09-01T10:47:55Z",
                "user": "krwq"
              }
            ],
            "totalCount": 3,
            "endCursor": "Y3Vyc29yOnYyOpHOCrgkJA=="
          },
          "updatedAt": "2022-08-31T14:15:33Z",
          "id": "IC_kwDODI9FZc5Jfg58"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Moving to Future for now, and we can circle back whenever https://github.com/dotnet/roslyn/issues/57239 has been addressed.",
          "createdAt": "2022-08-31T16:25:14Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-08-31T16:25:14Z",
          "id": "IC_kwDODI9FZc5JgH_P"
        }
      ],
      "totalCount": 6,
      "endCursor": "Y3Vyc29yOnYyOpHOSYB_zw=="
    },
    "url": "https://github.com/dotnet/runtime/issues/74841",
    "title": "JsonSerializableAttribute does not work with source generated properties"
  },
  {
    "author": "SefaOray",
    "labels": [
      "bug",
      "area-System.Text.Json"
    ],
    "createdAt": "2022-09-08T14:01:48Z",
    "body": "### Description\r\n\r\nI have the following class structure\r\n\r\n```\r\n[JsonPolymorphic(TypeDiscriminatorPropertyName = nameof(ActivityType))]\r\n[JsonDerivedType(typeof(LearnSkillActivity), (int) CareerActivities.LearnSkill)]\r\npublic abstract class BaseProfessionalActivity\r\n{\r\n     public abstract CareerActivities ActivityType { get; }\r\n}\r\n\r\npublic class LearnSkillActivity : BaseProfessionalActivity\r\n{\r\n    public string SkillId { get; set; }\r\n\r\n    public override CareerActivities ActivityType => CareerActivities.LearnSkill;\r\n}\r\n```\r\n\r\n### Reproduction Steps\r\n\r\nDeserializing following json doesn't work\r\n\r\n```\r\n{\r\n  \"activityType\": 0,\r\n  \"skillId\": \"63189799bc0a84a02ffc4bc9\"\r\n}\r\n```\r\n\r\nwhile the following works\r\n\r\n```\r\n{\r\n  \"ActivityType\": 0,\r\n  \"skillId\": \"63189799bc0a84a02ffc4bc9\"\r\n}\r\n```\r\n\r\nMind that only difference is the capical A in `ActivityType`\r\n\r\n### Expected behavior\r\nDeserializes correctly without error\r\n\r\n### Actual behavior\r\n\r\nThrows error\r\n\r\n`System.NotSupportedException: Deserialization of types without a parameterless constructor, a singular parameterized constructor, or a parameterized constructor annotated with 'JsonConstructorAttribute' is not supported`\r\n\r\n### Regression?\r\nNo response\r\n\r\n### Known Workarounds\r\nNo response\r\n\r\n### Configuration\r\n> dotnet --version\r\n7.0.100-preview.7.22377.5\r\n\r\n### Other information\r\nNo response",
    "number": 75269,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-03-07T17:40:49Z",
          "user": "jovinson-ms"
        }
      ],
      "totalCount": 1,
      "endCursor": "Y3Vyc29yOnYyOpHOC_0-CA=="
    },
    "updatedAt": "2025-03-07T18:12:44Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\n### Description\r\n\r\nI have the following class structure\r\n\r\n```\r\n[JsonPolymorphic(TypeDiscriminatorPropertyName = nameof(ActivityType))]\r\n[JsonDerivedType(typeof(LearnSkillActivity), (int) CareerActivities.LearnSkill)]\r\npublic abstract class BaseProfessionalActivity\r\n{\r\n     public abstract CareerActivities ActivityType { get; }\r\n}\r\n\r\npublic class LearnSkillActivity : BaseProfessionalActivity\r\n{\r\n    public string SkillId { get; set; }\r\n\r\n    public override CareerActivities ActivityType => CareerActivities.LearnSkill;\r\n}\r\n```\r\n\r\n### Reproduction Steps\r\n\r\nDeserializing following json doesn't work\r\n\r\n```\r\n{\r\n  \"activityType\": 0,\r\n  \"skillId\": \"63189799bc0a84a02ffc4bc9\"\r\n}\r\n```\r\n\r\nwhile the following works\r\n\r\n```\r\n{\r\n  \"ActivityType\": 0,\r\n  \"skillId\": \"63189799bc0a84a02ffc4bc9\"\r\n}\r\n```\r\n\r\nMind that only difference is the capical A in `ActivityType`\r\n\r\n### Expected behavior\r\nDeserializes correctly without error\r\n\r\n### Actual behavior\r\n\r\nThrows error\r\n\r\n`System.NotSupportedException: Deserialization of types without a parameterless constructor, a singular parameterized constructor, or a parameterized constructor annotated with 'JsonConstructorAttribute' is not supported`\r\n\r\n### Regression?\r\nNo response\r\n\r\n### Known Workarounds\r\nNo response\r\n\r\n### Configuration\r\n> dotnet --version\r\n7.0.100-preview.7.22377.5\r\n\r\n### Other information\r\nNo response\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>SefaOray</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`area-System.Text.Json`, `untriaged`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2022-09-08T14:02:08Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-09-08T14:02:08Z",
          "id": "IC_kwDODI9FZc5J9IM3"
        },
        {
          "author": "eiriktsarpalis",
          "body": "I tend to agree that this is an omission that should be fixed. However, it doesn't meet the bar for a .NET 7 fix. As a workaround I would suggest hardcoding the expected casing as a string literal instead of using `nameof`.",
          "createdAt": "2022-09-09T15:57:02Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-09-11T08:56:12Z",
                "user": "SefaOray"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOCsA7Uw=="
          },
          "updatedAt": "2022-09-09T15:58:43Z",
          "id": "IC_kwDODI9FZc5KCc38"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Moving to Future as we won't be able to work on this for 8.0",
          "createdAt": "2023-01-23T17:46:45Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-01-23T17:46:45Z",
          "id": "IC_kwDODI9FZc5TfZUv"
        },
        {
          "author": "iPilot",
          "body": "Serializer should also consider case options for discriminator property on serialization too. For now, discriminator property name is written as specified in attribute or contract model configuration.\r\n\r\nI'm also wondering, as we have generic attributes now, if it is possible to implement \r\n```JsonDerivedType<T> where T : Enum```\r\nas part of polymorphic serialization.\r\nIt is common practice to use enums for such purposes, isn't it?",
          "createdAt": "2023-03-15T19:27:25Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-05-15T00:29:16Z",
                "user": "efraimbart"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOC7rv5g=="
          },
          "updatedAt": "2023-03-15T19:34:49Z",
          "id": "IC_kwDODI9FZc5XqP2_"
        },
        {
          "author": "Mortana89",
          "body": "This is blocking our upgrade from .net 5 using Dahomey JSON polymorphism to .net 8 STJ.\r\nOur old frontend is using lowercase type discriminators but the new front-end/any other API integration works with camelcasing. How can we work around this? Was trying to implement a custom resolver and duplicating the derived types with lowercased discriminators, but the SDK does not allow registering the same type twice",
          "createdAt": "2024-04-16T15:55:18Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-04-16T15:55:18Z",
          "id": "IC_kwDODI9FZc56wFVE"
        },
        {
          "author": "jovinson-ms",
          "body": "@eiriktsarpalis any chance this will make .NET 10?",
          "createdAt": "2025-03-07T17:46:02Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-03-07T17:46:12Z",
          "id": "IC_kwDODI9FZc6hWkfX"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Unlikely at his point, unfortunately.",
          "createdAt": "2025-03-07T18:12:43Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-03-07T18:12:43Z",
          "id": "IC_kwDODI9FZc6hWv1n"
        }
      ],
      "totalCount": 7,
      "endCursor": "Y3Vyc29yOnYyOpHOoVr9Zw=="
    },
    "url": "https://github.com/dotnet/runtime/issues/75269",
    "title": ".NET 7 Preview 7 - Polymorphic Deserialization ignores PropertyNameCaseInsensitive setting"
  },
  {
    "author": "krwq",
    "labels": [
      "api-suggestion",
      "area-System.Text.Json"
    ],
    "createdAt": "2022-09-22T09:50:47Z",
    "body": "Serializing the same dictionary but with entries added in different order in STJ can result in different results every time you run your app. We should offer converter/option which can make this behavior stable.\r\n\r\nRepro:\r\n\r\n```csharp\r\nusing System.Text.Json;\r\n\r\nTest repro = new Test();\r\n\r\nif (Environment.TickCount % 2 == 0)\r\n{\r\n    repro.Dict.Add(\"left\", \"foo\");\r\n    repro.Dict.Add(\"right\", \"bar\");\r\n}\r\nelse\r\n{\r\n    repro.Dict.Add(\"right\", \"bar\");\r\n    repro.Dict.Add(\"left\", \"foo\");\r\n}\r\n\r\nConsole.WriteLine(JsonSerializer.Serialize(repro));\r\n\r\npublic class Test\r\n{\r\n    public Dictionary<string, string> Dict { get; } = new();\r\n}\r\n```\r\n\r\nOutput (randomly one of the following two):\r\n\r\n```\r\n{\"Dict\":{\"left\":\"foo\",\"right\":\"bar\"}}\r\n```\r\n\r\nor\r\n\r\n```\r\n{\"Dict\":{\"right\":\"bar\",\"left\":\"foo\"}}\r\n```\r\n\r\nExpected output:\r\n\r\n```\r\n{\"Dict\":{\"left\":\"foo\",\"right\":\"bar\"}}\r\n```\r\n",
    "number": 76008,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-09-22T11:48:22Z",
          "user": "colombod"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-09-26T10:15:03Z",
          "user": "ugumba"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-10-03T00:47:05Z",
          "user": "bbascarevic"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-01-17T12:48:52Z",
          "user": "0xced"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-01-25T14:27:21Z",
          "user": "Den-dp"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-03-31T19:37:36Z",
          "user": "charles-esterbrook"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-08-13T17:34:37Z",
          "user": "iikuzmychov"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-08-15T13:49:31Z",
          "user": "malciin"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-09-23T03:41:08Z",
          "user": "joelverhagen"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-12-11T15:39:34Z",
          "user": "doominator42"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-02-25T18:57:22Z",
          "user": "jjonescz"
        }
      ],
      "totalCount": 11,
      "endCursor": "Y3Vyc29yOnYyOpHOC_dgcw=="
    },
    "updatedAt": "2023-11-14T18:26:09Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\nSerializing the same dictionary but with entries added in different order in STJ can result in different results every time you run your app. We should offer converter/option which can make this behavior stable.\r\n\r\nRepro:\r\n\r\n```csharp\r\nusing System.Text.Json;\r\n\r\nTest repro = new Test();\r\n\r\nif (Environment.TickCount % 2 == 0)\r\n{\r\n    repro.Dict.Add(\"left\", \"foo\");\r\n    repro.Dict.Add(\"right\", \"bar\");\r\n}\r\nelse\r\n{\r\n    repro.Dict.Add(\"right\", \"bar\");\r\n    repro.Dict.Add(\"left\", \"foo\");\r\n}\r\n\r\nConsole.WriteLine(JsonSerializer.Serialize(repro));\r\n\r\npublic class Test\r\n{\r\n    public Dictionary<string, string> Dict { get; } = new();\r\n}\r\n```\r\n\r\nOutput (randomly one of the following two):\r\n\r\n```\r\n{\"Dict\":{\"left\":\"foo\",\"right\":\"bar\"}}\r\n```\r\n\r\nor\r\n\r\n```\r\n{\"Dict\":{\"right\":\"bar\",\"left\":\"foo\"}}\r\n```\r\n\r\nExpected output:\r\n\r\n```\r\n{\"Dict\":{\"left\":\"foo\",\"right\":\"bar\"}}\r\n```\r\n\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>krwq</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`api-suggestion`, `area-System.Text.Json`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2022-09-22T09:51:00Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-09-22T09:51:00Z",
          "id": "IC_kwDODI9FZc5KypgN"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Enumeration order of dictionary entries is generally speaking nondeterministic, and that is reflected by how entries get serialized in JSON. I can see how certain users might expect deterministic ordering, but there needs to be a commonly agreed upon order: should we sort by string keys? What if the key type is not a string?\r\n\r\nIs there prior art in this space? Does Json.NET offer similar functionality?",
          "createdAt": "2022-09-22T13:03:21Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-09-22T13:03:21Z",
          "id": "IC_kwDODI9FZc5Kza2z"
        },
        {
          "author": "Clockwork-Muse",
          "body": "Probably the biggest use of this isn't for reader-side enumeration.\r\nIt's for things like request caching, where you need stable results or you'd invalidate the cache.\r\nOr if the results would be signed for some reason, you want a stable order so that the hash doesn't change.",
          "createdAt": "2022-09-22T14:44:49Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-09-22T16:24:25Z",
                "user": "krwq"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-09-26T10:15:38Z",
                "user": "ugumba"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-10-03T00:47:43Z",
                "user": "bbascarevic"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-03-31T19:38:08Z",
                "user": "charles-esterbrook"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-08-15T13:49:48Z",
                "user": "malciin"
              }
            ],
            "totalCount": 5,
            "endCursor": "Y3Vyc29yOnYyOpHODuQ9qQ=="
          },
          "updatedAt": "2022-09-22T14:44:49Z",
          "id": "IC_kwDODI9FZc5Kz83D"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Should we be sorting by key? \r\n\r\nWhat about supported dictionary keys that are not strings? NB the default order of a key type might not be monotonic w.r.t. its JSON serialization, for example `2 < 10` holds however at the same time `\"10\" > \"2\"`.",
          "createdAt": "2022-09-22T15:52:39Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-09-22T15:52:39Z",
          "id": "IC_kwDODI9FZc5K0Ttm"
        },
        {
          "author": "krwq",
          "body": "yes, it's mostly about the serialized JSON being same for same entries, not about particular order. IMO unless there isn't anything builtin to give some defaults we should support at least string keys and maybe couple of numeric types. Possibly make sort func customizable through resolver but not necessarily",
          "createdAt": "2022-09-22T16:22:49Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-09-22T16:23:15Z",
          "id": "IC_kwDODI9FZc5K0c0m"
        },
        {
          "author": "eiriktsarpalis",
          "body": "FWIW the CBOR specification defines a [conformance mode](https://www.rfc-editor.org/rfc/rfc7049#section-3.9) mandating that map/object encodings are sorted lowest-to-highest by their key encodings. It might be worth investigating whether such a mode exists in the JSON space and whether we might consider supporting that out of the box.",
          "createdAt": "2022-09-22T16:28:58Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-09-26T17:02:58Z",
                "user": "krwq"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOCs0x-w=="
          },
          "updatedAt": "2022-09-22T16:28:58Z",
          "id": "IC_kwDODI9FZc5K0eiE"
        },
        {
          "author": "GSPP",
          "body": "Maybe users should just use a dictionary type that provides stable order?",
          "createdAt": "2022-09-26T14:14:41Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-09-26T22:49:07Z",
                "user": "layomia"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-10-03T22:42:23Z",
                "user": "TonyValenti"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-01-25T14:28:42Z",
                "user": "Den-dp"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-03-19T06:34:05Z",
                "user": "WeihanLi"
              }
            ],
            "totalCount": 4,
            "endCursor": "Y3Vyc29yOnYyOpHOEKez0w=="
          },
          "updatedAt": "2022-09-26T14:14:41Z",
          "id": "IC_kwDODI9FZc5K_S-u"
        },
        {
          "author": "krwq",
          "body": "@GSPP it is a good workaround but in general consider following scenario:\r\n- you get telemetry from random devices but always the same set of labels (keys in the dictionary)\r\n- you start your app and wait until all devices have sent you at least one measurement\r\n- you want to periodically send current state over the wire using JSON\r\n\r\n1. I wouldn't expect to have to use SortedDictionary in such scenario, in my app I don't need it sorted\r\n2. Receiver of telemetry even though they get identical measurements they may get different JSON every time\r\n3. Receiver don't have to parse data if it's same\r\n4. Sender if they had stable JSON allows you to do various optimizations - i.e. not sending entire thing over the wire and just send heartbeat saying equivalent to \"same as last time\"\r\n\r\nAnother scenario:\r\nThere are some libraries like i.e. [Assent](https://github.com/droyad/Assent) which allow you to easily baseline payloads like JSON. The way they work is when they detect difference in output they will fail test and show up diff window and ask you if this new baseline is ok, if you approve it will become new baseline. With unstable output of JSON those libraries can't effectively be used.",
          "createdAt": "2022-09-27T10:05:01Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-09-26T10:17:01Z",
                "user": "ugumba"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-01-25T14:29:15Z",
                "user": "Den-dp"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-03-31T19:41:03Z",
                "user": "charles-esterbrook"
              }
            ],
            "totalCount": 3,
            "endCursor": "Y3Vyc29yOnYyOpHODcgL3w=="
          },
          "updatedAt": "2022-09-27T10:05:01Z",
          "id": "IC_kwDODI9FZc5LDw0G"
        },
        {
          "author": "steveharter",
          "body": "I can see that having deterministic ordering including when round-tripping the JSON would sometimes be useful. However, if the code for the object being serialized can be changed, the corresponding dictionary type could be changed to `SortedDictionary<,>` easily enough.\r\n\r\n`Dictionary<,>` is non-deterministic but does unofficially maintain insertion order at least until an item is removed.\r\n\r\nFWIW `JsonObject` is deterministic even with removes and does this by maintaining a list internally. It also has a dictionary that helps with perf once there are a few items. New items are added to the end. Users expect this DOM class to be deterministic.",
          "createdAt": "2022-09-27T15:15:57Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-09-27T15:23:08Z",
                "user": "eiriktsarpalis"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-09-27T16:03:00Z",
                "user": "layomia"
              }
            ],
            "totalCount": 2,
            "endCursor": "Y3Vyc29yOnYyOpHOCs5Sjw=="
          },
          "updatedAt": "2022-09-27T15:15:57Z",
          "id": "IC_kwDODI9FZc5LFNun"
        },
        {
          "author": "GSPP",
          "body": "> Dictionary<,> is non-deterministic but does unofficially maintain insertion order at least until an item is removed.\r\n\r\nI have worked for a company where this was being relied on in about 1000 places. Unfortunately, it doesn't fully work even when just adding. There are some conditions that I forgot. I believe starting at about 1000 items it breaks down. I think there also was a problem with rehashing in case of too many collisions (a security feature).\r\n\r\nIn any case, I do not believe that relying on this should be encouraged as an unofficial workaround (not that you would have suggested otherwise). There should be a \"correct\" official guidance on how to achieve this scenario.\r\n\r\nI also believe that sorting keys is often inadequate. Yes, it does ensure determinism. But it also alters the natural order of items which could be meaningful. It can be semantically meaningful, but it also might have debugging value.\r\n\r\n\r\n\r\n",
          "createdAt": "2022-09-29T13:12:02Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-09-29T13:12:44Z",
          "id": "IC_kwDODI9FZc5LPI2r"
        },
        {
          "author": "Clockwork-Muse",
          "body": "> I also believe that sorting keys is often inadequate. Yes, it does ensure determinism. But it also alters the natural order of items which could be meaningful. It can be semantically meaningful, but it also might have debugging value.\r\n\r\nThe problem is that _usually_ you want a stable key-based sort specifically for those cases where items were inserted in different orders for whatever reason.  Insertion order being irrelevant to the serialized document.",
          "createdAt": "2022-09-29T13:55:47Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-09-29T13:55:47Z",
          "id": "IC_kwDODI9FZc5LPYCA"
        },
        {
          "author": "gregsdennis",
          "body": "This has come up for me as well while implementing the [`$json` operator for JSON-e](https://json-e.js.org/operators.html#json) ([issue/discussion](https://github.com/json-e/json-e/issues/489)).\r\n\r\nWhile the `SortedDictionary` approach is a good workaround, I think having a serializer option would be the best bet.\r\n\r\n```c#\r\npublic class JsonSerializerOptions\r\n{\r\n    // ...\r\n\r\n    public IComparer<string> KeyOrdering { get; set; }\r\n}\r\n```\r\n\r\nJust as as idea.  This way I can specify how I want to sort the keys, be it ordinal, or ignore case, or whatever.",
          "createdAt": "2023-11-14T07:35:24Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-11-14T07:35:24Z",
          "id": "IC_kwDODI9FZc5r3YAi"
        },
        {
          "author": "eiriktsarpalis",
          "body": "It sounds like a setting you'd want to specify on individual properties, not as global configuration.",
          "createdAt": "2023-11-14T11:57:04Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-11-14T11:57:04Z",
          "id": "IC_kwDODI9FZc5r43MT"
        },
        {
          "author": "gregsdennis",
          "body": "Not sure what you mean, @eiriktsarpalis.  I'd definitely want this on an entire single serialization.",
          "createdAt": "2023-11-14T17:11:58Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-11-14T17:11:58Z",
          "id": "IC_kwDODI9FZc5r7V_a"
        },
        {
          "author": "eiriktsarpalis",
          "body": "I'm not saying a global flag wouldn't be useful, but I can also see cases where such a blanket policy might be undesirable.\r\n\r\nFWIW we support key serialization beyond just strings (admittedly that's not as common though). Shouldn't the setting account for those as well?",
          "createdAt": "2023-11-14T17:15:59Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-11-14T17:15:59Z",
          "id": "IC_kwDODI9FZc5r7Xxw"
        },
        {
          "author": "gregsdennis",
          "body": "Sure. I'm just saying that I think an open-ended option would be a good solution for this. I'm not set on it being `IComparer<string>`.  It could be something like the `Encoder` option.",
          "createdAt": "2023-11-14T18:26:09Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-11-14T18:26:09Z",
          "id": "IC_kwDODI9FZc5r7_Px"
        }
      ],
      "totalCount": 16,
      "endCursor": "Y3Vyc29yOnYyOpHOa-_z8Q=="
    },
    "url": "https://github.com/dotnet/runtime/issues/76008",
    "title": "Stable Dictionary sorting for System.Text.Json"
  },
  {
    "author": "jgauffin",
    "labels": [
      "area-System.Text.Json",
      "wishlist"
    ],
    "createdAt": "2022-10-04T13:20:00Z",
    "body": "Today, multiple constructors are only supported if one of them is decorated with the `[JsonConstructor]` attribute.\r\n\r\nThe problem with that is that when you design an API, you use constructors to ensure that the developer has specified the correct combination of properties. Those combinations are different, and all properties might not be specified in each combination.\r\n\r\nWe also set those properties to get-only, just for convenience, so when you want to fill in optional properties, you do not have to see the mandatory ones. And by using private setters, the user cannot unset a mandatory parameter (intentional or by mistake).\r\n\r\nThat, in turn, makes it impossible to decorate one constructor with the `[JsonConstructor]` attribute since either of them can have been used before serializing, and choosing the wrong one will result in discarded information.\r\n\r\nTo remedy this, I've written a converter that matches constructors against the information available in the JSON document. It then selects the first constructor that can be used with the available data. It's included below. \r\n\r\nNote, I originally tried `JsonConverter<object>` to be able to add it once, but that didn't work well with System.Text.Json.\r\n\r\n**Feature request**: Add support for multiple constructors without the need for `[JsonConstructor]`.\r\n\r\n_This is only one of my converters to get the same functionality as in Json.NET. It would help a lot if it were possible to create non-generic converters._\r\n\r\n(this solution isn't very efficient, an alternative would be to support non-public default constructor + private setters)\r\n\r\n```csharp\r\npublic class MultipleConstructorsConverter<T> : JsonConverter<T>\r\n{\r\n    /// <inheritdoc />\r\n    public override T? Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)\r\n    {\r\n        if (reader.TokenType == JsonTokenType.StartObject)\r\n        {\r\n            reader.Read();\r\n        }\r\n\r\n        var values = new Dictionary<string, object>(StringComparer.OrdinalIgnoreCase);\r\n\r\n        DeserializePropertyValues(ref reader, typeToConvert, options, values);\r\n\r\n        var instance = CreateInstanceUsingAConstructor(typeToConvert, values);\r\n        if (instance == null)\r\n        {\r\n            throw new InvalidOperationException(\r\n                $\"Failed to find all parameters to any of the constructors: {typeToConvert}.\");\r\n        }\r\n\r\n        FillProperties(instance, values);\r\n        return (T)instance;\r\n    }\r\n\r\n    /// <inheritdoc />\r\n    public override void Write(Utf8JsonWriter writer, T value, JsonSerializerOptions options)\r\n    {\r\n        throw new NotSupportedException(\"Do not use this converter for serialization.\");\r\n    }\r\n\r\n    private static object? CreateInstanceUsingAConstructor(\r\n        Type typeToConvert,\r\n        IReadOnlyDictionary<string, object> values)\r\n    {\r\n        object? instance = null;\r\n        foreach (var constructor in typeToConvert.GetConstructors())\r\n        {\r\n            var parameterValues = new List<object>();\r\n            foreach (var parameter in constructor.GetParameters())\r\n            {\r\n                if (values.TryGetValue(parameter.Name, out var value))\r\n                {\r\n                    parameterValues.Add(value);\r\n                }\r\n            }\r\n\r\n            if (parameterValues.Count == constructor.GetParameters().Length)\r\n            {\r\n                instance = constructor.Invoke(parameterValues.ToArray());\r\n            }\r\n        }\r\n\r\n        return instance;\r\n    }\r\n\r\n    private static void DeserializePropertyValues(\r\n        ref Utf8JsonReader reader,\r\n        IReflect typeToConvert,\r\n        JsonSerializerOptions options,\r\n        IDictionary<string, object> values)\r\n    {\r\n        while (reader.TokenType is not JsonTokenType.EndObject)\r\n        {\r\n#pragma warning disable SA1009 // Closing parenthesis should be spaced correctly\r\n            var propertyName = reader.GetString()!;\r\n#pragma warning restore SA1009 // Closing parenthesis should be spaced correctly\r\n\r\n            // Move past property name\r\n            reader.Read();\r\n\r\n#pragma warning disable IDE0079\r\n#pragma warning disable S3011\r\n            var prop = typeToConvert\r\n                .GetProperties(BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.Public)\r\n                .FirstOrDefault(x => x.Name.Equals(propertyName, StringComparison.OrdinalIgnoreCase));\r\n#pragma warning restore\r\n\r\n            if (prop == null)\r\n            {\r\n                // Skip value\r\n                reader.Skip();\r\n\r\n                // Read past value\r\n                reader.Read();\r\n                continue;\r\n            }\r\n\r\n            var value = System.Text.Json.JsonSerializer.Deserialize(ref reader, prop.PropertyType, options);\r\n            if (value != null)\r\n            {\r\n                values[prop.Name] = value;\r\n            }\r\n\r\n            if (reader.TokenType is not JsonTokenType.PropertyName)\r\n            {\r\n                reader.Read();\r\n            }\r\n        }\r\n    }\r\n\r\n    private static void FillProperties(object instance, IReadOnlyDictionary<string, object> values)\r\n    {\r\n        if (values == null)\r\n        {\r\n            throw new ArgumentNullException(nameof(values));\r\n        }\r\n\r\n        if (instance == null)\r\n        {\r\n            throw new ArgumentNullException(nameof(instance));\r\n        }\r\n\r\n        foreach (var property in instance.GetType().GetProperties())\r\n        {\r\n            if (!values.TryGetValue(property.Name, out var value))\r\n            {\r\n                continue;\r\n            }\r\n\r\n           // this is an extension method that tries the set-method and fallbacks\r\n           // to assigning the backing field if it fails (to support get-only properties)\r\n            property.SetPropertyValue(instance, value);\r\n        }\r\n    }\r\n}\r\n```",
    "number": 76608,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-10-05T13:13:04Z",
          "user": "Enderlook"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-12-27T22:32:09Z",
          "user": "Ombrelin"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-11-10T06:44:07Z",
          "user": "oleg-varlamov"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-04-09T10:08:07Z",
          "user": "ds1371dani"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-04-30T06:37:38Z",
          "user": "tDemMbnk"
        }
      ],
      "totalCount": 5,
      "endCursor": "Y3Vyc29yOnYyOpHOC3kxyg=="
    },
    "updatedAt": "2024-01-29T01:57:04Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\nToday, multiple constructors are only supported if one of them is decorated with the `[JsonConstructor]` attribute.\r\n\r\nThe problem with that is that when you design an API, you use constructors to ensure that the developer has specified the correct combination of properties. Those combinations are different, and all properties might not be specified in each combination.\r\n\r\nWe also set those properties to get-only, just for convenience, so when you want to fill in optional parameters, you do not have to see the mandatory ones.\r\n\r\nThat, in turn, makes it impossible to decorate one constructor with the `[JsonConstructor]` attribute since either of them can have been used before serializing, and choosing the wrong one will result in discarded information.\r\n\r\nTo remedy this, I've written a converter that matches constructors against the information available in the JSON document. It then selects the first constructor that can be used with the available data. It's included below. \r\n\r\nNote, I originally tried `JsonConverter<object>` to be able to add it once, but that didn't work well with System.Text.Json.\r\n\r\n**Feature request**: Add support for multiple constructors without the need for `[JsonConstructor]`.\r\n\r\n_This is only one of my converters to get the same functionality as in Json.NET. It would help a lot if it were possible to create non-generic converters._\r\n\r\n```csharp\r\npublic class MultipleConstructorsConverter<T> : JsonConverter<T>\r\n{\r\n    /// <inheritdoc />\r\n    public override T? Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)\r\n    {\r\n        if (typeToConvert == typeof(TypeDto))\r\n        {\r\n            Debugger.Break();\r\n        }\r\n\r\n        if (reader.TokenType == JsonTokenType.StartObject)\r\n        {\r\n            reader.Read();\r\n        }\r\n\r\n        var values = new Dictionary<string, object>(StringComparer.OrdinalIgnoreCase);\r\n\r\n        DeserializePropertyValues(ref reader, typeToConvert, options, values);\r\n\r\n        var instance = CreateInstanceUsingAConstructor(typeToConvert, values);\r\n        if (instance == null)\r\n        {\r\n            throw new InvalidOperationException(\r\n                $\"Failed to find all parameters to any of the constructors: {typeToConvert}.\");\r\n        }\r\n\r\n        FillProperties(instance, values);\r\n        return (T)instance;\r\n    }\r\n\r\n    /// <inheritdoc />\r\n    public override void Write(Utf8JsonWriter writer, T value, JsonSerializerOptions options)\r\n    {\r\n        throw new NotSupportedException(\"Do not use this converter for serialization.\");\r\n    }\r\n\r\n    private static object? CreateInstanceUsingAConstructor(\r\n        Type typeToConvert,\r\n        IReadOnlyDictionary<string, object> values)\r\n    {\r\n        object? instance = null;\r\n        foreach (var constructor in typeToConvert.GetConstructors())\r\n        {\r\n            var parameterValues = new List<object>();\r\n            foreach (var parameter in constructor.GetParameters())\r\n            {\r\n                if (values.TryGetValue(parameter.Name, out var value))\r\n                {\r\n                    parameterValues.Add(value);\r\n                }\r\n            }\r\n\r\n            if (parameterValues.Count == constructor.GetParameters().Length)\r\n            {\r\n                instance = constructor.Invoke(parameterValues.ToArray());\r\n            }\r\n        }\r\n\r\n        return instance;\r\n    }\r\n\r\n    private static void DeserializePropertyValues(\r\n        ref Utf8JsonReader reader,\r\n        IReflect typeToConvert,\r\n        JsonSerializerOptions options,\r\n        IDictionary<string, object> values)\r\n    {\r\n        while (reader.TokenType is not JsonTokenType.EndObject)\r\n        {\r\n#pragma warning disable SA1009 // Closing parenthesis should be spaced correctly\r\n            var propertyName = reader.GetString()!;\r\n#pragma warning restore SA1009 // Closing parenthesis should be spaced correctly\r\n\r\n            // Move past property name\r\n            reader.Read();\r\n\r\n#pragma warning disable IDE0079\r\n#pragma warning disable S3011\r\n            var prop = typeToConvert\r\n                .GetProperties(BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.Public)\r\n                .FirstOrDefault(x => x.Name.Equals(propertyName, StringComparison.OrdinalIgnoreCase));\r\n#pragma warning restore\r\n\r\n            if (prop == null)\r\n            {\r\n                // Skip value\r\n                reader.Skip();\r\n\r\n                // Read past value\r\n                reader.Read();\r\n                continue;\r\n            }\r\n\r\n            var value = System.Text.Json.JsonSerializer.Deserialize(ref reader, prop.PropertyType, options);\r\n            if (value != null)\r\n            {\r\n                values[prop.Name] = value;\r\n            }\r\n\r\n            if (reader.TokenType is not JsonTokenType.PropertyName)\r\n            {\r\n                reader.Read();\r\n            }\r\n        }\r\n    }\r\n\r\n    private static void FillProperties(object instance, IReadOnlyDictionary<string, object> values)\r\n    {\r\n        if (values == null)\r\n        {\r\n            throw new ArgumentNullException(nameof(values));\r\n        }\r\n\r\n        if (instance == null)\r\n        {\r\n            throw new ArgumentNullException(nameof(instance));\r\n        }\r\n\r\n        foreach (var property in instance.GetType().GetProperties())\r\n        {\r\n            if (!values.TryGetValue(property.Name, out var value))\r\n            {\r\n                continue;\r\n            }\r\n\r\n            if (property.CanWrite)\r\n            {\r\n                property.SetPropertyValue(instance, value);\r\n            }\r\n        }\r\n    }\r\n}\r\n```\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>jgauffin</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`area-System.Text.Json`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2022-10-04T13:20:19Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-10-04T13:20:19Z",
          "id": "IC_kwDODI9FZc5LhLH1"
        },
        {
          "author": "eiriktsarpalis",
          "body": "This would be a breaking change if we added it by default, but we plan to cover that particular use case using parameterized constructor in the contract model: https://github.com/dotnet/runtime/issues/71944",
          "createdAt": "2022-10-04T13:30:15Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-10-04T13:30:15Z",
          "id": "IC_kwDODI9FZc5LhO06"
        },
        {
          "author": "jgauffin",
          "body": "How would it be a breaking change? If the [JsonConstructor] attribute is present, select that constructor. If it isn't, try to find one that works with available data. That will not break any backward compatibility.\r\n\r\nOr add it as an option in serializer settings.",
          "createdAt": "2022-10-04T21:36:35Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-01-29T01:52:54Z",
                "user": "Eptagone"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-02-18T20:16:43Z",
                "user": "jgauffin"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-04-09T10:08:07Z",
                "user": "ds1371dani"
              }
            ],
            "totalCount": 3,
            "endCursor": "Y3Vyc29yOnYyOpHODdhltQ=="
          },
          "updatedAt": "2022-10-04T21:43:07Z",
          "id": "IC_kwDODI9FZc5Ljh-1"
        },
        {
          "author": "ricardomomm",
          "body": "That is a very interesting request! Please consider it sooner :)",
          "createdAt": "2023-07-06T16:45:22Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-07-06T16:45:22Z",
          "id": "IC_kwDODI9FZc5gzChg"
        },
        {
          "author": "Eptagone",
          "body": "I also need something like that. One of the properties in my model can be a string or an integer, so i have two constructors, one for each type. I cannot change it to a single type because I'm using an external API.",
          "createdAt": "2024-01-29T01:57:03Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-01-29T01:57:03Z",
          "id": "IC_kwDODI9FZc5yEs8S"
        }
      ],
      "totalCount": 5,
      "endCursor": "Y3Vyc29yOnYyOpHOchLPEg=="
    },
    "url": "https://github.com/dotnet/runtime/issues/76608",
    "title": "Allow multiple constructors in System.Text.Json"
  },
  {
    "author": "krwq",
    "labels": [
      "api-suggestion",
      "area-System.Text.Json"
    ],
    "createdAt": "2022-10-21T09:13:24Z",
    "body": "It's very useful information to know if property is readable/writable (i.e. generating docs). But this information is currently not exactly obvious.\r\n\r\n- If `JsonPropertyInfo.Get != null` then we know property is readable\r\n- If `JsonPropertyInfo.Set != null` then we know property is writable\r\n\r\nbut above is not complete:\r\n- If `JsonPropertyInfo.Get != null` and there is parametrized ctor with related property property is also writable (technically it's init but that's transparent to user)\r\n\r\nwhile first two are easy to check the last one is not exactly trivial due to this information not being exposed.\r\n\r\nSomewhat related to https://github.com/dotnet/runtime/issues/71944 - it could potentially be solved as part of that issue but this issue is much more scoped than that.",
    "number": 77307,
    "reactions": {
      "hasNextPage": false,
      "nodes": [],
      "totalCount": 0,
      "endCursor": null
    },
    "updatedAt": "2023-01-23T18:00:49Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\nIt's very useful information to know if property is readable/writable (i.e. generating docs). But this information is currently not exactly obvious.\r\n\r\n- If `JsonPropertyInfo.Get != null` then we know property is readable\r\n- If `JsonPropertyInfo.Set != null` then we know property is writable\r\n\r\nbut above is not complete:\r\n- If `JsonPropertyInfo.Get != null` and there is parametrized ctor with related property property is also writable (technically it's init but that's transparent to user)\r\n\r\nwhile first two are easy to check the last one is not exactly trivial due to this information not being exposed.\r\n\r\nSomewhat related to https://github.com/dotnet/runtime/issues/71944 - it could potentially be solved as part of that issue but this issue is much more scoped than that.\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>krwq</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`area-System.Text.Json`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2022-10-21T09:13:31Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-10-21T09:13:31Z",
          "id": "IC_kwDODI9FZc5MsUCb"
        },
        {
          "author": "eiriktsarpalis",
          "body": "It will largely depend on how #71944 gets implemented. Clearly, we need to expose `JsonParameterInfo`. Currently the implementation requires each parameter to be bound to a corresponding `JsonPropertyInfo`, however this is only required for validating that each parameter corresponds to a property and is not strictly necessary for deserialization to succeed. \r\n\r\nWe have received feedback from users who believe that the current restriction is too strict, so perhaps it makes sense to completely decouple `JsonPropertyInfo` from `JsonParameterInfo`, at least in the contract model layer. If we do it that way, then clearly a property is writeable only if it defines a setter.",
          "createdAt": "2022-10-21T10:06:00Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-10-21T10:06:00Z",
          "id": "IC_kwDODI9FZc5MshlB"
        },
        {
          "author": "krwq",
          "body": "changing milestone to 8.0 - we should at least consider this for 8.0",
          "createdAt": "2022-10-21T10:19:54Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-10-21T10:19:54Z",
          "id": "IC_kwDODI9FZc5MslMl"
        },
        {
          "author": "krwq",
          "body": "@eiriktsarpalis I think I'd go the other way - from JSON point of view there are really no parameters. Only serialization has such concept - I'd rather go in direction of adding bool flag on the JsonPropertyInfo, i.e. `IsConstructorParameter` or nullable `ConstructorParameterName` and internally we can still do what we used to. IMO JsonTypeInfo.Properties should be exhaustive list of what can occur in the payload",
          "createdAt": "2022-10-21T12:42:35Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-10-21T12:42:35Z",
          "id": "IC_kwDODI9FZc5MtLUD"
        },
        {
          "author": "eiriktsarpalis",
          "body": "> I'd rather go in direction of adding bool flag on the JsonPropertyInfo\r\n\r\nNote that ordering of constructor parameters is significant and might not match the declared serialization order (which is also influenced by the `Order` property). Assuming we fix https://github.com/dotnet/runtime/issues/44428, it may well be the case that the type of JsonParameterInfo does not match the type of the corresponding JsonPropertyInfo.",
          "createdAt": "2022-10-21T12:49:57Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-10-21T12:49:57Z",
          "id": "IC_kwDODI9FZc5MtNUR"
        }
      ],
      "totalCount": 5,
      "endCursor": "Y3Vyc29yOnYyOpHOTLTVEQ=="
    },
    "url": "https://github.com/dotnet/runtime/issues/77307",
    "title": "Expose information about JsonPropertyInfo being readable/writable"
  },
  {
    "author": "MihaZupan",
    "labels": [
      "api-suggestion",
      "area-System.Text.Json",
      "tenet-performance"
    ],
    "createdAt": "2022-11-05T02:01:16Z",
    "body": "### Background and motivation\r\n\r\nZero-byte reads are a technique used in our networking stacks (System.Net, ASP.NET, YARP) to defer renting/allocating memory until there's data available on the socket.\r\nThis can greatly reduce memory usage in applications with a lot of concurrent operations.\r\nIn the case of YARP, we've seen a 10x reduction in process memory consumption when used with WebSockets.\r\n\r\nWith Json, this would help in cases where the whole object hasn't been read into memory yet.\r\nAn API that would benefit greatly is `JsonSerializer.DeserializeAsyncEnumerable` which can be long-lived and spend a lot of time just waiting on IO.\r\n\r\n\r\nStarting with .NET 7.0, the streams returned by `HttpClient` are able to take advantage of this technique.\r\n`System.Net.Http.Json` extensions are therefore a prime candidate where we should strongly consider enabling this option by default.\r\n\r\nPrior art:\r\n- [`StreamPipeReaderOptions.UseZeroByteReads`](https://apisof.net/catalog/8f3a52c8-e3dd-95ac-90b5-ddb6d51c5881) from `System.IO.Pipelines` (#37539)\r\n- [`SocketTransportOptions.WaitForDataBeforeAllocatingBuffer`](https://apisof.net/catalog/0c4dcd52-27b0-9425-40b2-8978029fb8d0) from Kestrel\r\n\r\n@davidfowl I assume this wouldn't do much in ASP.NET since the `HttpContext.Body` already does zero-byte reads internally, right? That is unless the json implementation would be able to defer allocating its own buffers on top of using ZBRs on the underlying transport.\r\n\r\n### API Proposal\r\n\r\n```csharp\r\nnamespace System.Text.Json;\r\n\r\npublic sealed class JsonSerializerOptions\r\n{\r\n    // New property on existing type\r\n    public bool UseZeroByteReads { get; set; }\r\n}\r\n```\r\n\r\n\r\n### API Usage\r\n\r\n```csharp\r\nprivate static readonly JsonSerializerOptions s_jsonOptions = new() { UseZeroByteReads = true };\r\n\r\npublic static IAsyncEnumerable<Foo> DeserializeAsync(Stream stream) =>\r\n    JsonSerializer.DeserializeAsyncEnumerable<Foo>(stream, s_jsonOptions);\r\n```\r\n\r\n\r\n### Alternative Designs\r\n\r\nIf the json implementation isn't capable of deferring allocations of its own buffers while waiting for more data, the user could achieve similar performance gains by implementing their own `Stream` wrapper that performed zero-byte reads and passing that to `JsonSerializer` instead.",
    "number": 77935,
    "reactions": {
      "hasNextPage": false,
      "nodes": [],
      "totalCount": 0,
      "endCursor": null
    },
    "updatedAt": "2023-10-13T17:54:20Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\n### Background and motivation\n\nZero-byte reads are a technique used in our networking stacks (System.Net, ASP.NET, YARP) to defer renting/allocating memory until there's data available on the socket.\r\nThis can greatly reduce memory usage in applications with a lot of concurrent operations.\r\nIn the case of YARP, we've seen a 10x reduction in process memory consumption when used with WebSockets.\r\n\r\nWith Json, this would help in cases where the whole object hasn't been read into memory yet.\r\nAn API that would benefit greatly is `JsonSerializer.DeserializeAsyncEnumerable` which can be long-lived and spend a lot of time just waiting on IO.\r\n\r\n\r\nStarting with .NET 7.0, the streams returned by `HttpClient` are able to take advantage of this technique.\r\n`System.Net.Http.Json` extensions are therefore a prime candidate where we should strongly consider enabling this option by default.\r\n\r\nPrior art:\r\n- [`StreamPipeReaderOptions.UseZeroByteReads`](https://apisof.net/catalog/8f3a52c8-e3dd-95ac-90b5-ddb6d51c5881) from `System.IO.Pipelines` (#37539)\r\n- [`SocketTransportOptions.WaitForDataBeforeAllocatingBuffer`](https://apisof.net/catalog/0c4dcd52-27b0-9425-40b2-8978029fb8d0) from Kestrel\r\n\r\n@davidfowl I assume this wouldn't do much in ASP.NET since the `HttpContext.Body` already does zero-byte reads internally, right? That is unless the json implementation would be able to defer allocating its own buffers on top of using ZBRs on the underlying transport.\n\n### API Proposal\n\n```csharp\r\nnamespace System.Text.Json;\r\n\r\npublic sealed class JsonSerializerOptions\r\n{\r\n    // New property on existing type\r\n    public bool UseZeroByteReads { get; set; }\r\n}\r\n```\r\n\n\n### API Usage\n\n```csharp\r\nprivate static readonly JsonSerializerOptions s_jsonOptions = new() { UseZeroByteReads = true };\r\n\r\npublic static IAsyncEnumerable<Foo> DeserializeAsync(Stream stream) =>\r\n    JsonSerializer.DeserializeAsyncEnumerable<Foo>(stream, s_jsonOptions);\r\n```\r\n\n\n### Alternative Designs\n\nIf the json implementation isn't capable of deferring allocations of its own buffers while waiting for more data, the user could achieve similar performance gains by implementing their own `Stream` wrapper that performed zero-byte reads and passing that to `JsonSerializer` instead.\n\n### Risks\n\nYARP always uses zero-byte reads on HTTP bodies. We've seen in the past that some implementations of `Stream` are not aware of the concept of zero-byte reads, causing them to report premature EOF exceptions when reading 0 bytes.\r\n\r\nIf the user runs into such a scenario, they should fix that `Stream` implementation, or turn off `UseZeroByteReads`.\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>MihaZupan</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`api-suggestion`, `area-System.Text.Json`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2022-11-05T02:01:33Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-11-05T02:01:33Z",
          "id": "IC_kwDODI9FZc5Nvy1I"
        },
        {
          "author": "krwq",
          "body": "@MihaZupan Stream.Read/ReadAsync are documented that zero bytes means EOF (last sentence specifically):\r\nhttps://learn.microsoft.com/en-us/dotnet/api/system.io.stream.read?view=net-7.0\r\n\r\n```\r\nThe total number of bytes read into the buffer. This can be less than the number of bytes allocated in the buffer if that many bytes are not currently available, or zero (0) if the end of the stream has been reached.\r\n```\r\n\r\nIf that is no longer true should we change the docs?\r\n\r\nIMO we're working correctly here, I think it makes more sense for you to create stream wrapper if you prefer different to default behavior.\r\n\r\nPossibly it makes more sense to add that flag to Stream itself?",
          "createdAt": "2022-11-08T10:31:43Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-11-08T10:32:11Z",
          "id": "IC_kwDODI9FZc5N5wvq"
        },
        {
          "author": "stephentoub",
          "body": "> are documented that zero bytes means\r\n\r\nThe zero here refers to the input, i.e. asking for zero bytes.",
          "createdAt": "2022-11-08T11:31:59Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-11-08T21:24:00Z",
                "user": "krwq"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOCvQFgA=="
          },
          "updatedAt": "2022-11-08T11:31:59Z",
          "id": "IC_kwDODI9FZc5N6Dny"
        },
        {
          "author": "krwq",
          "body": "@MihaZupan I'm marking this as Future for now. If this is impacting your scenario significantly or if you're planning to contribute please let me know and we can bump priority. We will unlikely have time to address this in 8.0 otherwise.",
          "createdAt": "2022-11-23T09:27:42Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-11-26T20:27:04Z",
                "user": "MihaZupan"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOCwO2VQ=="
          },
          "updatedAt": "2022-11-23T09:27:42Z",
          "id": "IC_kwDODI9FZc5O9lOi"
        },
        {
          "author": "MihaZupan",
          "body": "I suppose another alternative design here would be for `System.Text.Json` to always use zero-byte reads and there is no API to toggle that behavior.",
          "createdAt": "2023-07-25T18:12:26Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-07-27T10:40:19Z",
                "user": "davidfowl"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHODB-NUQ=="
          },
          "updatedAt": "2023-07-25T18:12:26Z",
          "id": "IC_kwDODI9FZc5iXcBz"
        },
        {
          "author": "MihaZupan",
          "body": "Any thoughts on [this](https://github.com/dotnet/runtime/issues/77935#issuecomment-1650311283) @krwq? We might not need an API review.",
          "createdAt": "2023-07-27T16:21:14Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-07-27T16:21:14Z",
          "id": "IC_kwDODI9FZc5ilS-a"
        },
        {
          "author": "ilmax",
          "body": "I feel like this doesn't belong to the JsonSerializerOptions. It's something too low level compared to what's in the option IMO. As a user I am expecting to find details about serialization convention, case handling and what not there, not low level details about how the serializer allocates memory while reading from a stream.\r\n\r\nMy suggestion is to always do zero bytes read and eventually, if you really want to have a switch, implement it via AppContext or something alike.\r\n\r\nJust my 2 cent :)",
          "createdAt": "2023-07-27T21:55:15Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-07-27T21:55:15Z",
          "id": "IC_kwDODI9FZc5in72E"
        },
        {
          "author": "MihaZupan",
          "body": "Any thoughts on this @dotnet/area-system-text-json: https://github.com/dotnet/runtime/issues/77935#issuecomment-1650311283?",
          "createdAt": "2023-10-13T17:21:00Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-10-13T17:21:00Z",
          "id": "IC_kwDODI9FZc5pBDvm"
        },
        {
          "author": "En3Tho",
          "body": "I agree with @ilmax here. I think if profitable, STJ should just implement this. Zero byte reads are now used in other places in BCL by default.",
          "createdAt": "2023-10-13T17:54:19Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-10-13T17:54:19Z",
          "id": "IC_kwDODI9FZc5pBTEz"
        }
      ],
      "totalCount": 9,
      "endCursor": "Y3Vyc29yOnYyOpHOaQUxMw=="
    },
    "url": "https://github.com/dotnet/runtime/issues/77935",
    "title": "[API Proposal]: JsonSerializerOptions.UseZeroByteReads"
  },
  {
    "author": "Sergio0694",
    "labels": [
      "enhancement",
      "area-System.Text.Json",
      "linkable-framework",
      "partner-impact"
    ],
    "createdAt": "2022-11-08T15:02:09Z",
    "body": "### Description\r\n\r\nWe're currently working on migrating all our JSON serialization from Newtonsoft.Json to System.Text.Json in the Microsoft Store (see also #77897), and we're hitting some issues with trimming (we're on .NET Native). In particular, this line:\r\n\r\nhttps://github.com/dotnet/runtime/blob/264d7391ec9f6e698051db0621c5e090d0ae4710/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/JsonConverter.cs#L19\r\n\r\nThis is crashing when trimming is enabled, because the linker will remove support for getting the assembly info from types. We can fix this by adding some .rd.xml directives, but it's error prone and not really a great solution. Eg. we can use:\r\n\r\n```xml\r\n<Type Name=\"System.Text.Json.Serialization.Converters.ObjectDefaultConverter`1\" Activate=\"Required Public\" />\r\n<Type Name=\"System.Text.Json.Serialization.Converters.DictionaryOfTKeyTValueConverter`3\" Activate=\"Required Public\" />\r\n<Type Name=\"System.Text.Json.Serialization.Converters.ListOfTConverter`2\" Activate=\"Required Public\" />\r\n```\r\n\r\nEtc. for all converters we need. It'd be much better if this was just fixed in System.Text.Json directly. I'm aware that reflection-free mode isn't supported (see #68093), but fixing this would also benefit other scenarios (such as our case) by still allowing the linker to just trim out more metadata and reduce the binary size further.\r\n\r\n> **Note**: to clarify, the ask is not to support the reflection-free mode, just to make this path friendlier to trimming.\r\n\r\ncc. @eiriktsarpalis @MichalStrehovsky \r\n\r\n### Reproduction Steps\r\n\r\nThe repro is pretty much the same as in the linked issue:\r\n\r\n```csharp\r\nstring json = \"\"\"\r\n    {\r\n        \"SomeMapping\": { \"A\": \"B\" },\r\n        \"SomeList\": [\"A\", \"B\"]\r\n    }\r\n    \"\"\";\r\n\r\n_ = System.Text.Json.JsonSerializer.Deserialize(rawJson, MicrosoftStoreJsonSerializerContext.Default.SomeModel);\r\n\r\npublic sealed class SomeModel\r\n{\r\n    public Dictionary<string, string> SomeMapping { get; set; }\r\n    public List<string> SomeList { get; set; }\r\n}\r\n\r\n[JsonSerializable(typeof(SomeModel))]\r\n[JsonSourceGenerationOptions(GenerationMode = JsonSourceGenerationMode.Metadata)]\r\ninternal sealed partial class MicrosoftStoreJsonSerializerContext : JsonSerializerContext\r\n{\r\n}\r\n```\r\n\r\n### Expected behavior\r\n\r\nThis should just work fine.\r\n\r\n### Actual behavior\r\n\r\nWe're getting a `MissingMetadataException`:\r\n\r\n```\r\nat System.Reflection.Runtime.TypeInfos.RuntimeNoMetadataNamedTypeInfo.get_Assembly() in f:\\\\dd\\\\ndp\\\\fxcore\\\\CoreRT\\\\src\\\\System.Private.Reflection.Core\\\\src\\\\System\\\\Reflection\\\\Runtime\\\\TypeInfos\\\\RuntimeNoMetadataNamedTypeInfo.cs:line 38 \r\nat System.Reflection.Runtime.TypeInfos.RuntimeConstructedGenericTypeInfo.get_Assembly() in f:\\\\dd\\\\ndp\\\\fxcore\\\\CoreRT\\\\src\\\\System.Private.Reflection.Core\\\\src\\\\System\\\\Reflection\\\\Runtime\\\\TypeInfos\\\\RuntimeConstructedGenericTypeInfo.cs:line 136\r\nat System.Text.Json.Serialization.JsonConverter`1..ctor(Boolean initialize) \r\nat System.Text.Json.Serialization.JsonConverter`1..ctor()\r\nat System.Text.Json.Serialization.JsonResumableConverter`1..ctor() \r\nat System.Text.Json.Serialization.JsonObjectConverter`1..ctor()\r\nat System.Text.Json.Serialization.Converters.ObjectDefaultConverter`1..ctor()\r\nat System.Text.Json.Serialization.Metadata.SourceGenJsonTypeInfo`1.<>c.<GetConverter>b__3_1()\r\nat System.Func`1.Invoke()\r\nat System.Text.Json.Serialization.Converters.JsonMetadataServicesConverter`1.get_Converter() \r\nat System.Text.Json.Serialization.Converters.JsonMetadataServicesConverter`1.get_ElementType() \r\nat System.Text.Json.Serialization.Metadata.JsonTypeInfo..ctor(Type type, JsonConverter converter, JsonSerializerOptions options)\r\nat System.Text.Json.Serialization.Metadata.JsonTypeInfo`1..ctor(JsonConverter converter, JsonSerializerOptions options) \r\nat System.Text.Json.Serialization.Metadata.SourceGenJsonTypeInfo`1..ctor(JsonSerializerOptions options, JsonObjectInfoValues`1 objectInfo)\r\nat System.Text.Json.Serialization.Metadata.JsonMetadataServices.CreateObjectInfo[T](JsonSerializerOptions options, JsonObjectInfoValues`1 objectInfo) \r\nat SomeProject.MicrosoftStoreJsonSerializerContext.Create_SomeModel(JsonSerializerOptions options)\r\nat SomeProject.MicrosoftStoreJsonSerializerContext.get_SomeModel()  \r\nat SomeProject.<<TryDeserializeSomeModel>g__Foo|77_0>d.MoveNext() \r\n```\r\n\r\n### Regression?\r\n\r\nI have a possible idea on how to fix this, by making that path entirely reflection-free. Consider this:\r\n\r\n```csharp\r\npublic abstract class JsonConverter<T>\r\n{\r\n    protected JsonConverter()\r\n    {\r\n        IsInternalType = CheckIsInternalType();\r\n    }\r\n\r\n    private protected virtual bool CheckIsInternalType() => false;\r\n}\r\n```\r\n\r\nNow, all converter types in System.Text.Json would just override the method accordingly:\r\n\r\n```csharp\r\npublic class SomeSealedJsonConverter<T> : JsonConverter<T>\r\n{\r\n    private protected override bool CheckIsInternalType() => true;\r\n}\r\n\r\npublic class SomeUnsealedJsonConverter<T> : JsonConverter<T>r\r\n{\r\n    private protected override bool CheckIsInternalType() => GetType() == typeof(SomeUnsealedJsonConverter<T>);\r\n}\r\n```\r\n\r\nThis makes sure that:\r\n\r\n- External converters directly inheriting from `JsonConverter<T>` will be marked as external.\r\n- External converters that inherit from unsealed STJ converters will also be marked as external.\r\n\r\nEssentially this should provide a reflection-free way of checking whether a concrete converter type is from the STJ assembly.\r\n\r\n### Configuration\r\n\r\n- System.Text.Json 7.0\r\n- .NET Native 6.2.14",
    "number": 78029,
    "reactions": {
      "hasNextPage": false,
      "nodes": [],
      "totalCount": 0,
      "endCursor": null
    },
    "updatedAt": "2023-05-31T16:22:35Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\n### Description\n\nWe're currently working on migrating all our JSON serialization from Newtonsoft.Json to System.Text.Json in the Microsoft Store (see also #77897), and we're hitting some issues with trimming (we're on .NET Native). In particular, this line:\r\n\r\nhttps://github.com/dotnet/runtime/blob/264d7391ec9f6e698051db0621c5e090d0ae4710/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/JsonConverter.cs#L19\r\n\r\nThis is crashing when trimming is enabled, because the linker will remove support for getting the assembly info from types. We can fix this by adding some .rd.xml directives, but it's error prone and not really a great solution. Eg. we can use:\r\n\r\n```xml\r\n<Type Name=\"System.Text.Json.Serialization.Converters.ObjectDefaultConverter`1\" Activate=\"Required Public\" />\r\n<Type Name=\"System.Text.Json.Serialization.Converters.DictionaryOfTKeyTValueConverter`3\" Activate=\"Required Public\" />\r\n<Type Name=\"System.Text.Json.Serialization.Converters.ListOfTConverter`2\" Activate=\"Required Public\" />\r\n```\r\n\r\nEtc. for all converters we need. It'd be much better if this was just fixed in System.Text.Json directly. I'm aware that reflection-free mode isn't supported (see #68093), but fixing this would also benefit other scenarios (such as our case) by still allowing the linker to just trim out more metadata and reduce the binary size further.\r\n\r\ncc. @eiriktsarpalis @MichalStrehovsky \n\n### Reproduction Steps\n\nThe repro is pretty much the same as in the linked issue:\r\n\r\n```csharp\r\nstring json = \"\"\"\r\n    {\r\n        \"SomeMapping\": { \"A\": \"B\" },\r\n        \"SomeList\": [\"A\", \"B\"]\r\n    }\r\n    \"\"\";\r\n\r\n_ = System.Text.Json.JsonSerializer.Deserialize(rawJson, MicrosoftStoreJsonSerializerContext.CamelCase.DAOfferDataContract);\r\n\r\npublic sealed class SomeModel\r\n{\r\n    public Dictionary<string, string> SomeMapping { get; set; }\r\n    public List<string> SomeList { get; set; }\r\n}\r\n\r\n[JsonSerializable(typeof(SomeModel))]\r\n[JsonSourceGenerationOptions(GenerationMode = JsonSourceGenerationMode.Metadata)]\r\ninternal sealed partial class MicrosoftStoreJsonSerializerContext : JsonSerializerContext\r\n{\r\n}\r\n```\n\n### Expected behavior\n\nThis should just work fine.\n\n### Actual behavior\n\nWe're getting a `MissingMetadataException`:\r\n\r\n```\r\nat System.Reflection.Runtime.TypeInfos.RuntimeNoMetadataNamedTypeInfo.get_Assembly() in f:\\\\dd\\\\ndp\\\\fxcore\\\\CoreRT\\\\src\\\\System.Private.Reflection.Core\\\\src\\\\System\\\\Reflection\\\\Runtime\\\\TypeInfos\\\\RuntimeNoMetadataNamedTypeInfo.cs:line 38 \r\nat System.Reflection.Runtime.TypeInfos.RuntimeConstructedGenericTypeInfo.get_Assembly() in f:\\\\dd\\\\ndp\\\\fxcore\\\\CoreRT\\\\src\\\\System.Private.Reflection.Core\\\\src\\\\System\\\\Reflection\\\\Runtime\\\\TypeInfos\\\\RuntimeConstructedGenericTypeInfo.cs:line 136\r\nat System.Text.Json.Serialization.JsonConverter`1..ctor(Boolean initialize) \r\nat System.Text.Json.Serialization.JsonConverter`1..ctor()\r\nat System.Text.Json.Serialization.JsonResumableConverter`1..ctor() \r\nat System.Text.Json.Serialization.JsonObjectConverter`1..ctor()\r\nat System.Text.Json.Serialization.Converters.ObjectDefaultConverter`1..ctor()\r\nat System.Text.Json.Serialization.Metadata.SourceGenJsonTypeInfo`1.<>c.<GetConverter>b__3_1()\r\nat System.Func`1.Invoke()\r\nat System.Text.Json.Serialization.Converters.JsonMetadataServicesConverter`1.get_Converter() \r\nat System.Text.Json.Serialization.Converters.JsonMetadataServicesConverter`1.get_ElementType() \r\nat System.Text.Json.Serialization.Metadata.JsonTypeInfo..ctor(Type type, JsonConverter converter, JsonSerializerOptions options)\r\nat System.Text.Json.Serialization.Metadata.JsonTypeInfo`1..ctor(JsonConverter converter, JsonSerializerOptions options) \r\nat System.Text.Json.Serialization.Metadata.SourceGenJsonTypeInfo`1..ctor(JsonSerializerOptions options, JsonObjectInfoValues`1 objectInfo)\r\nat System.Text.Json.Serialization.Metadata.JsonMetadataServices.CreateObjectInfo[T](JsonSerializerOptions options, JsonObjectInfoValues`1 objectInfo) \r\nat SomeProject.MicrosoftStoreJsonSerializerContext.Create_SomeModel(JsonSerializerOptions options)\r\nat SomeProject.MicrosoftStoreJsonSerializerContext.get_SomeModel()  \r\nat SomeProject.<<TryDeserializeSomeModel>g__Foo|77_0>d.MoveNext() \r\n```\n\n### Regression?\n\nI have a possible idea on how to fix this, by making that path entirely reflection-free. Consider this:\r\n\r\n```csharp\r\n// New internal interface in System.Text.Json\r\ninternal interface IInternalConverter\r\n{\r\n    Type TypeRoot { get; }\r\n}\r\n\r\n// Updated constructor for JsonConverter<T>\r\npublic abstract class JsonConverter<T>\r\n{\r\n    protected JsonConverter()\r\n    {\r\n        IsInternalType = GetType() == (this as IInternalConverter)?.TypeRoot;\r\n    }\r\n}\r\n```\r\n\r\nNow, all converter types in System.Text.Json would implement the interface explicitly. like so:\r\n\r\n```csharp\r\n// Converter in System.Text.Json\r\npublic class SomeJsonConverter<T> : JsonConverter<T>, IInternalConverter\r\n{\r\n    Type IInternalConverter.TypeRoot => typeof(SomeJsonConverter<T>);\r\n}\r\n```\r\n\r\nThis makes sure that:\r\n\r\n- External converters directly inheriting from `JsonConverter<T>` won't have the interface\r\n- External converters that inherit from unsealed STJ converters won't have a matching type at runtime\r\n\r\nEssentially this should provide a reflection-free way of checking whether a concrete converter type is from the STJ assembly.\n\n### Known Workarounds\n\n_No response_\n\n### Configuration\n\n- System.Text.Json 7.0\r\n- .NET Native 6.2.14\n\n### Other information\n\n_No response_\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>Sergio0694</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`area-System.Text.Json`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2022-11-08T15:02:31Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-11-08T15:02:31Z",
          "id": "IC_kwDODI9FZc5N7K2e"
        },
        {
          "author": "MichalStrehovsky",
          "body": "For further context, in .NET Native it's possible to have a type with all of its metadata removed. So the `GetType().Assembly` call is likely getting a `Type` object for a type whose metadata was removed. Such `Type` objects are going to throw (because they don't know their assembly... they don't even know their names).\r\n\r\nIt's not possible to get such `Type` object with .NET Core trimming - either PublishAot or PublishTrimmed will always return a Type that always knows its assembly. So this is just a .NET Native issue.\r\n\r\nBut .NET Native is NetStandard 2.0 and supported so...\r\n\r\nIt can probably be worked around with:\r\n\r\n```xml\r\n<Assembly Name=\"System.Text.Json\" Dynamic=\"All\" />\r\n```\r\n\r\nWhich tells the .NET Native compiler to keep the metadata for everything that was kept. It will keep more than necessary, but it should be safe for this line of code.",
          "createdAt": "2022-11-09T01:48:55Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-11-09T01:48:55Z",
          "id": "IC_kwDODI9FZc5N98z9"
        },
        {
          "author": "Sergio0694",
          "body": "That works, but causes a lot of metadata to be preserved. I narrowed that down a bit and this also seems to work:\r\n\r\n```xml\r\n<Type Name=\"System.Text.Json.Serialization.Converters.ObjectDefaultConverter`1\">\r\n    <Subtypes Activate=\"Required Public\" />\r\n</Type>\r\n```\r\n\r\nBut even just this causes 1MB of increase on the package size, which doesn't seem worth it given the issue is just that line. Adding the individual directives like I mentioned in the OP only adds 40KB of binary size, which is great, though of course it's a bit more brittle and requires additional testing to ensure no converter type is missed.\r\n\r\nI guess what I'm trying to say is - it feels like this issue could be fixed relatively easy by using a `private protected virtual` method like in my proposal, and that would benefit a lot of UWP developers (this is not the first time I see this specific issue causing problems in UWP apps, and not everyone is familiar with .rd.xml directives enough to fix this on their own).\r\n\r\nTo be clear - I'd be happy to contribute the fix myself 🙂\r\n\r\n> \"It's not possible to get such `Type` object with .NET Core trimming\"\r\n\r\nOut of curiosity - I know the reflection-free mode isn't supported in NativeAOT, but would the same still apply to the \"enhanced reflection free\" mode that was in the works? Ie. the one that would remove all `MethodBase` support or something (can't remember all the details exactly). As in, would `Type.Assembly` still be available even in that case anyway?",
          "createdAt": "2022-11-09T10:04:36Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-11-09T10:04:36Z",
          "id": "IC_kwDODI9FZc5N_kFg"
        },
        {
          "author": "eiriktsarpalis",
          "body": "> it feels like this issue could be fixed relatively easy by using a private protected virtual method like in my proposal\r\n\r\nI don't believe that would work in the general case. Apart from the fact that each internal derived type would need to be explicitly marked as internal (allowing for the possibility of new internal types potentially missing that declaration), it doesn't account for custom converters deriving from built-in converters that are both unsealed and public. Currently there's only one such class, `JsonStringEnumConverter` (which is actually a factory, so the value of `IsInternalConverter` will be imprecise but not necessarily carry any performance impact) but we are planning on adding more public converters like that, see https://github.com/dotnet/runtime/issues/73124#issuecomment-1303267422 and https://github.com/dotnet/runtime/issues/63791.",
          "createdAt": "2022-11-09T12:05:55Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-11-09T12:05:55Z",
          "id": "IC_kwDODI9FZc5OAHCM"
        },
        {
          "author": "Sergio0694",
          "body": "> \"it doesn't account for custom converters deriving from built-in converters that are both unsealed and public\"\r\n\r\nI'm not sure I understand why this wouldn't work, could you elaborate? Consider this case:\r\n\r\n```csharp\r\n// This is public and unsealed\r\npublic class InternalConverter<T> : JsonConverter<T>\r\n{\r\n    private protected override bool CheckIsInternalType() => GetType() == typeof(InternalConverter<T>);\r\n}\r\n\r\n// This is an external converter that inherits from it\r\npublic class ExternalConverter<T> : InternalConverter<T>\r\n{\r\n}\r\n```\r\n\r\nWhen either is instantiated, you can have two cases:\r\n- If `InternalConverter<T>` is instantiated (say, it's `InternalConverter<string>`), that `CheckIsInternalType` will return `true`, because it will result in `InternalConverter<string> == typeof(InternalConverter<string>)`.\r\n- If `ExternalConverter<T>` is instantiated (say, it's `ExternalConverter<string>`), that `CheckIsInternalType` will return `false`, because the check will now result in `ExternalConverter<string> == InternalConverter<string>`.\r\n\r\nEssentially, this solution accounts both cases just fine, as far as I can tell. 🙂\r\n\r\nNote: this is also a very similar approach to what `MemoryStream` does to check against derived types.\r\n\r\n> \"allowing for the possibility of new internal types potentially missing that declaration\"\r\n\r\nI can see that, but I think we can address that with tests, especially because we know the full set of converters. We might even be able to just come up with a way to fetch and validate all tests via reflection (eg. get all non abstract internal converters, instantiate them with random type arguments, invoke `CheckIsInternalType` and verify it returns `true`).\r\n\r\nTo clarify again, I'm happy to contribute this improvement myself, since it'd benefit us directly (and NativeAOT users) 😄",
          "createdAt": "2022-11-09T12:24:24Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-11-09T12:25:45Z",
          "id": "IC_kwDODI9FZc5OAMtW"
        },
        {
          "author": "eiriktsarpalis",
          "body": "> Consider this case:\r\n\r\nI assumed the virtual would simply set a flag, but this is running an equality comparison against the declared type. Would this work if reflection metadata has been stripped?",
          "createdAt": "2022-11-09T12:34:39Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-11-09T12:34:39Z",
          "id": "IC_kwDODI9FZc5OAPgO"
        },
        {
          "author": "Sergio0694",
          "body": "Yup this will work just fine, even in reflection-free mode you can directly compare `Type` instances for checking equality (which is exactly what we need), that is explicitly allowed. As in, that would work both on .NET Native (where the entire metadata is stripped) and in NativeAOT reflection-free mode (where the entire reflection stack is gone) 🙂\r\n\r\nIf performance is a concern, such a type comparison is actually just a direct comparison, so it's also faster than the current code (as another side bonus on top of not using reflection). See [sharplab example](https://sharplab.io/#v2:EYLgxg9gTgpgtADwGwBYA0AXEBDAzgWwB8ABABgAIBlAC2ygAcAZbYAOgCUBXAOwwEt8MANwBYAFDiA2gCk+GAOIxuMKHzAAKDAE96MCADN1fXgEoTAXXHEAzOWIAmctNwRulFX2wAbPgC8VADwAKgB84gDe4uTRdrbAEBBe5ACy6iZRMZFiMTl2AOzkihhBOjBp5AC8FeTaugbqzq7uqt5+gaEmotkxAL7iPUA=), where the whole check just compiles to:\r\n\r\n```asm\r\nJsonSerializer`1[[System.Int32, System.Private.CoreLib]].M()\r\n    L0000: mov rax, 0x7ffb7e5ad460\r\n    L000a: cmp [rcx], rax\r\n    L000d: sete al\r\n    L0010: movzx eax, al\r\n    L0013: ret\r\n```",
          "createdAt": "2022-11-09T12:39:52Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-11-09T12:39:52Z",
          "id": "IC_kwDODI9FZc5OAQyV"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Performance shouldn't be a concern, the virtual would be invoked only once by the constructor anyways. What does concern me is maintainability and risk of regression -- clearly our testing pipelines don't cover that particular scenario.",
          "createdAt": "2022-11-09T12:43:07Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-11-09T12:43:07Z",
          "id": "IC_kwDODI9FZc5OARqR"
        },
        {
          "author": "MichalStrehovsky",
          "body": "> But even just this causes 1MB of increase on the package size, which doesn't seem worth it given the issue is just that line\r\n\r\nTry dropping the `Required` part and leave it at `<Subtypes Activate=\"Public\" />`. `Required` roots things that would otherwise be unused.",
          "createdAt": "2022-11-10T00:17:16Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-11-10T00:17:16Z",
          "id": "IC_kwDODI9FZc5ODoTa"
        },
        {
          "author": "Sergio0694",
          "body": "That doesn't seem to be enough, I tried but unfortunately I still got `MissingMetadataException`-s with that 🥲",
          "createdAt": "2022-11-10T08:01:32Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "CONFUSED",
                "createdAt": "2022-11-10T08:04:15Z",
                "user": "MichalStrehovsky"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOCvWmig=="
          },
          "updatedAt": "2022-11-10T08:01:32Z",
          "id": "IC_kwDODI9FZc5OE58K"
        },
        {
          "author": "MichalStrehovsky",
          "body": "> Out of curiosity - I know the reflection-free mode isn't supported in NativeAOT, but would the same still apply to the \"enhanced reflection free\" mode that was in the works?\r\n\r\nThe compiler doesn't generate such data structures and I deleted the representation for this from the reflection stack in https://github.com/dotnet/runtime/pull/73612.",
          "createdAt": "2022-11-10T08:06:35Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-11-10T09:47:50Z",
                "user": "Sergio0694"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOCvXDVQ=="
          },
          "updatedAt": "2022-11-10T08:06:35Z",
          "id": "IC_kwDODI9FZc5OE7YR"
        },
        {
          "author": "Sergio0694",
          "body": "> \"What does concern me is maintainability and risk of regression -- clearly our testing pipelines don't cover that particular scenario.\"\r\n\r\n@eiriktsarpalis if we want to make sure to not miss any types, could we add a test that does the following:\r\n- Go through all public types in System.Text.Json's assembly\r\n- Filter those that are deriving from `JsonConverter<T>`\r\n- If they're generic, call `MakeGenericType` on them with some random type (say, `object`)\r\n- Get a default instance via `RuntimeHelpers.GetUninitializedObject`\r\n- Invoke `CheckIsInternalType` on them via reflection\r\n- Verify that it returns `true`\r\n\r\nAnd we can then also define a couple of converter types in the same test project and check those return `false`.\r\n\r\nSeems like that would give us a reliable way to automatically test all existing converters to ensure this works?\r\nWhat do you think? 🙂",
          "createdAt": "2022-11-10T09:50:18Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-11-10T09:50:18Z",
          "id": "IC_kwDODI9FZc5OFW9V"
        },
        {
          "author": "eiriktsarpalis",
          "body": "I mean we'll do that if we absolutely have to, but hoping for a cleaner solution or a potential workaround in other platforms that do need this.",
          "createdAt": "2022-11-10T16:59:28Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-11-10T17:00:27Z",
          "id": "IC_kwDODI9FZc5OHjcw"
        },
        {
          "author": null,
          "body": "Tagging subscribers to 'linkable-framework': @eerhardt, @vitek-karas, @LakshanF, @sbomer, @joperezr\nSee info in area-owners.md if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\n### Description\r\n\r\nWe're currently working on migrating all our JSON serialization from Newtonsoft.Json to System.Text.Json in the Microsoft Store (see also #77897), and we're hitting some issues with trimming (we're on .NET Native). In particular, this line:\r\n\r\nhttps://github.com/dotnet/runtime/blob/264d7391ec9f6e698051db0621c5e090d0ae4710/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/JsonConverter.cs#L19\r\n\r\nThis is crashing when trimming is enabled, because the linker will remove support for getting the assembly info from types. We can fix this by adding some .rd.xml directives, but it's error prone and not really a great solution. Eg. we can use:\r\n\r\n```xml\r\n<Type Name=\"System.Text.Json.Serialization.Converters.ObjectDefaultConverter`1\" Activate=\"Required Public\" />\r\n<Type Name=\"System.Text.Json.Serialization.Converters.DictionaryOfTKeyTValueConverter`3\" Activate=\"Required Public\" />\r\n<Type Name=\"System.Text.Json.Serialization.Converters.ListOfTConverter`2\" Activate=\"Required Public\" />\r\n```\r\n\r\nEtc. for all converters we need. It'd be much better if this was just fixed in System.Text.Json directly. I'm aware that reflection-free mode isn't supported (see #68093), but fixing this would also benefit other scenarios (such as our case) by still allowing the linker to just trim out more metadata and reduce the binary size further.\r\n\r\n> **Note:** to clarify, the ask is not to support the reflection-free mode, just to make this path friendlier to trimming.\r\n\r\ncc. @eiriktsarpalis @MichalStrehovsky \r\n\r\n### Reproduction Steps\r\n\r\nThe repro is pretty much the same as in the linked issue:\r\n\r\n```csharp\r\nstring json = \"\"\"\r\n    {\r\n        \"SomeMapping\": { \"A\": \"B\" },\r\n        \"SomeList\": [\"A\", \"B\"]\r\n    }\r\n    \"\"\";\r\n\r\n_ = System.Text.Json.JsonSerializer.Deserialize(rawJson, MicrosoftStoreJsonSerializerContext.CamelCase.DAOfferDataContract);\r\n\r\npublic sealed class SomeModel\r\n{\r\n    public Dictionary<string, string> SomeMapping { get; set; }\r\n    public List<string> SomeList { get; set; }\r\n}\r\n\r\n[JsonSerializable(typeof(SomeModel))]\r\n[JsonSourceGenerationOptions(GenerationMode = JsonSourceGenerationMode.Metadata)]\r\ninternal sealed partial class MicrosoftStoreJsonSerializerContext : JsonSerializerContext\r\n{\r\n}\r\n```\r\n\r\n### Expected behavior\r\n\r\nThis should just work fine.\r\n\r\n### Actual behavior\r\n\r\nWe're getting a `MissingMetadataException`:\r\n\r\n```\r\nat System.Reflection.Runtime.TypeInfos.RuntimeNoMetadataNamedTypeInfo.get_Assembly() in f:\\\\dd\\\\ndp\\\\fxcore\\\\CoreRT\\\\src\\\\System.Private.Reflection.Core\\\\src\\\\System\\\\Reflection\\\\Runtime\\\\TypeInfos\\\\RuntimeNoMetadataNamedTypeInfo.cs:line 38 \r\nat System.Reflection.Runtime.TypeInfos.RuntimeConstructedGenericTypeInfo.get_Assembly() in f:\\\\dd\\\\ndp\\\\fxcore\\\\CoreRT\\\\src\\\\System.Private.Reflection.Core\\\\src\\\\System\\\\Reflection\\\\Runtime\\\\TypeInfos\\\\RuntimeConstructedGenericTypeInfo.cs:line 136\r\nat System.Text.Json.Serialization.JsonConverter`1..ctor(Boolean initialize) \r\nat System.Text.Json.Serialization.JsonConverter`1..ctor()\r\nat System.Text.Json.Serialization.JsonResumableConverter`1..ctor() \r\nat System.Text.Json.Serialization.JsonObjectConverter`1..ctor()\r\nat System.Text.Json.Serialization.Converters.ObjectDefaultConverter`1..ctor()\r\nat System.Text.Json.Serialization.Metadata.SourceGenJsonTypeInfo`1.<>c.<GetConverter>b__3_1()\r\nat System.Func`1.Invoke()\r\nat System.Text.Json.Serialization.Converters.JsonMetadataServicesConverter`1.get_Converter() \r\nat System.Text.Json.Serialization.Converters.JsonMetadataServicesConverter`1.get_ElementType() \r\nat System.Text.Json.Serialization.Metadata.JsonTypeInfo..ctor(Type type, JsonConverter converter, JsonSerializerOptions options)\r\nat System.Text.Json.Serialization.Metadata.JsonTypeInfo`1..ctor(JsonConverter converter, JsonSerializerOptions options) \r\nat System.Text.Json.Serialization.Metadata.SourceGenJsonTypeInfo`1..ctor(JsonSerializerOptions options, JsonObjectInfoValues`1 objectInfo)\r\nat System.Text.Json.Serialization.Metadata.JsonMetadataServices.CreateObjectInfo[T](JsonSerializerOptions options, JsonObjectInfoValues`1 objectInfo) \r\nat SomeProject.MicrosoftStoreJsonSerializerContext.Create_SomeModel(JsonSerializerOptions options)\r\nat SomeProject.MicrosoftStoreJsonSerializerContext.get_SomeModel()  \r\nat SomeProject.<<TryDeserializeSomeModel>g__Foo|77_0>d.MoveNext() \r\n```\r\n\r\n### Regression?\r\n\r\nI have a possible idea on how to fix this, by making that path entirely reflection-free. Consider this:\r\n\r\n```csharp\r\npublic abstract class JsonConverter<T>\r\n{\r\n    protected JsonConverter()\r\n    {\r\n        IsInternalType = CheckIsInternalType();\r\n    }\r\n\r\n    private protected virtual bool CheckIsInternalType() => false;\r\n}\r\n```\r\n\r\nNow, all converter types in System.Text.Json would just override the method accordingly:\r\n\r\n```csharp\r\npublic class SomeSealedJsonConverter<T> : JsonConverter<T>\r\n{\r\n    private protected override bool CheckIsInternalType() => true;\r\n}\r\n\r\npublic class SomeUnsealedJsonConverter<T> : JsonConverter<T>r\r\n{\r\n    private protected override bool CheckIsInternalType() => GetType() == typeof(SomeUnsealedJsonConverter<T>);\r\n}\r\n```\r\n\r\nThis makes sure that:\r\n\r\n- External converters directly inheriting from `JsonConverter<T>` will be marked as external.\r\n- External converters that inherit from unsealed STJ converters will also be marked as external.\r\n\r\nEssentially this should provide a reflection-free way of checking whether a concrete converter type is from the STJ assembly.\r\n\r\n### Configuration\r\n\r\n- System.Text.Json 7.0\r\n- .NET Native 6.2.14\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>Sergio0694</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`enhancement`, `area-System.Text.Json`, `linkable-framework`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>8.0.0</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2022-11-10T17:00:21Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-11-10T17:00:21Z",
          "id": "IC_kwDODI9FZc5OHjxo"
        },
        {
          "author": "Sergio0694",
          "body": "The workarounds we have are either to preserve all converter types, which adds too much binary size as it preserves any converter type anywhere even if unused, or manually annotating the ones you need, which only adds a bit more metadata than needed but is acceptable on this front. The downside to this though is that it's a rather brittle solution, as it's fairly easy to miss one especially if a given converter is only used on some specific JSON models. I'd feel much more comfortable if this was just fixed at the source, and it'd allow us to proceed with more confidence to switch over the whole Store to System.Text.Json 😅\r\n\r\nAlso if it's any help (I know the team is busy), I really wouldn't mind contributing this myself 🙂",
          "createdAt": "2022-11-10T17:05:42Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-11-10T17:05:42Z",
          "id": "IC_kwDODI9FZc5OHleB"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Another possible solution is to investigate current usage of the `IsInternalConverter` flag and possibly replace it with something that doesn't require reflection.",
          "createdAt": "2022-11-10T17:08:00Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-11-10T17:08:00Z",
          "id": "IC_kwDODI9FZc5OHmLW"
        },
        {
          "author": "Sergio0694",
          "body": "That sounds like an even better idea 😄\r\nJust glancing at the code it's not immediately obvious to me what this property is even for (there's also no comments).",
          "createdAt": "2022-11-10T17:14:41Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-11-11T02:44:10Z",
                "user": "MichalStrehovsky"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOCvan-w=="
          },
          "updatedAt": "2022-11-10T17:14:41Z",
          "id": "IC_kwDODI9FZc5OHoMy"
        },
        {
          "author": "Sergio0694",
          "body": "Great to see this being added to the new AOT user story for .NET 8! 🎉\r\n\r\n@eiriktsarpalis should we add the `partner-impact` tag here too, since we're hitting this in the Store?\r\nThis specific reflection dependency being addressed in the next release would be a pretty nice win for us there 😄",
          "createdAt": "2022-12-02T21:15:23Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-12-05T13:53:48Z",
                "user": "eiriktsarpalis"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOCwr7YQ=="
          },
          "updatedAt": "2022-12-02T21:15:23Z",
          "id": "IC_kwDODI9FZc5Pn3mu"
        },
        {
          "author": "dongle-the-gadget",
          "body": "One thing I also want to mention, System.Text.Json apparently treats `List<A<B>>` as requiring converter `JsonConverter<List<A<B>>>`, which has its own reflection code:\r\nhttps://github.com/dotnet/runtime/blob/ec9fb02a2c6b606ef06acc911a0b104fd3d2a9a3/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/JsonConverterOfT.cs#L22\r\nThat means Sergio's previously mentioned workaround to add possibly every converter System.Text.Json implements needs to be changed to\r\n```xml\r\n<Type Name=\"System.Text.Json.Serialization.JsonConverter`1\">\r\n    <Subtypes Activate=\"Required Public\" />\r\n</Type>\r\n```\r\nfor this scenario to work.",
          "createdAt": "2023-02-04T18:05:51Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-02-06T14:57:20Z",
                "user": "eiriktsarpalis"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOC1hC7Q=="
          },
          "updatedAt": "2023-02-04T18:05:51Z",
          "id": "IC_kwDODI9FZc5Uct_O"
        }
      ],
      "totalCount": 19,
      "endCursor": "Y3Vyc29yOnYyOpHOVHLfzg=="
    },
    "url": "https://github.com/dotnet/runtime/issues/78029",
    "title": "JsonConverter constructor causes MissingMetadataException upon instantiation"
  },
  {
    "author": "SicJG",
    "labels": [
      "enhancement",
      "area-System.Text.Json"
    ],
    "createdAt": "2022-11-09T10:02:04Z",
    "body": "### Description\r\n\r\n1. Using [[JsonRequiredAttribute]](https://learn.microsoft.com/en-us/dotnet/api/system.text.json.serialization.jsonrequiredattribute?view=net-7.0) published with .Net 7.0, on propertry that doesn't have public setter/initter, but initialized through ctor throws InvalidOperationException during deserialization\r\n2. Obligation of property setter/initter existance is not described in documention [1](https://learn.microsoft.com/en-us/dotnet/standard/serialization/system-text-json/required-properties) [2](https://learn.microsoft.com/en-us/dotnet/api/system.text.json.serialization.jsonrequiredattribute) \r\n\r\n\r\n### Reproduction Steps\r\n\r\n```csharp\r\nusing System.Text.Json.Serialization;\r\n\r\nnamespace Test;\r\n\r\ninternal static class JsonRequired\r\n{\r\n    public sealed class RequiredAttributeCtor\r\n    {\r\n        [JsonPropertyName(\"value\")]\r\n        [JsonRequired]\r\n        public int Value { get; }\r\n\r\n        public RequiredAttributeCtor(int value)\r\n        {\r\n            Value = value;\r\n        }\r\n    }\r\n\r\n    public static RequiredAttributeCtor? Run()\r\n    {\r\n        const string input = \"\"\"{\"value\":1}\"\"\";\r\n        return System.Text.Json.JsonSerializer.Deserialize<RequiredAttributeCtor>(input);\r\n    }\r\n\r\n}\r\n```\r\n\r\n\r\n### Expected behavior\r\n\r\n### Local\r\nReproduction test returns instance of RequiredAttributeCtor type populated with data from input\r\n\r\n### Global\r\nAll of the required property initialization variations are supported\r\n\r\n```csharp\r\n\r\nusing System.Text.Json.Serialization;\r\n\r\nnamespace Test;\r\n\r\ninternal static class JsonRequired\r\n{\r\n    public sealed class RequiredAttributeCtor\r\n    {\r\n        [JsonPropertyName(\"value\")]\r\n        [JsonRequired]\r\n        public int Value { get; }\r\n\r\n        public RequiredAttributeCtor(int value)\r\n        {\r\n            Value = value;\r\n        }\r\n    }\r\n\r\n    public sealed class RequiredAttributeSet\r\n    {\r\n        [JsonPropertyName(\"value\")]\r\n        [JsonRequired]\r\n        public int Value { get; set; }\r\n    }\r\n\r\n    public sealed class RequiredAttributeInit\r\n    {\r\n        [JsonPropertyName(\"value\")]\r\n        [JsonRequired]\r\n        public int Value { get; init; }\r\n    }\r\n\r\n    public sealed class RequiredKeywordSet\r\n    {\r\n        [JsonPropertyName(\"value\")]\r\n        public required int Value { get; set; }\r\n    }\r\n\r\n    public sealed class RequiredKeywordInit\r\n    {\r\n        [JsonPropertyName(\"value\")]\r\n        public required int Value { get; init; }\r\n    }\r\n\r\n    public static void Run()\r\n    {\r\n        const string input = \"\"\"{\"value\":1}\"\"\";\r\n        var _1 =  System.Text.Json.JsonSerializer.Deserialize<RequiredAttributeCtor>(input);\r\n        var _2 =  System.Text.Json.JsonSerializer.Deserialize<RequiredAttributeSet>(input);\r\n        var _3 =  System.Text.Json.JsonSerializer.Deserialize<RequiredAttributeInit>(input);\r\n        var _4 =  System.Text.Json.JsonSerializer.Deserialize<RequiredKeywordSet>(input);\r\n        var _5 =  System.Text.Json.JsonSerializer.Deserialize<RequiredKeywordInit>(input);\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n### Actual behavior\r\n\r\nRunning reproduction test throws \r\n```\r\nUnhandled exception. System.InvalidOperationException: JsonPropertyInfo 'value' defined in type 'Test.JsonRequired+RequiredAttributeCtor' is marked required but does not specify a setter.\r\n   at System.Text.Json.ThrowHelper.ThrowInvalidOperationException_JsonPropertyRequiredAndNotDeserializable(JsonPropertyInfo jsonPropertyInfo)\r\n   at System.Text.Json.Serialization.Metadata.JsonPropertyInfo.Configure()\r\n   at System.Text.Json.Serialization.Metadata.JsonTypeInfo.InitializePropertyCache()\r\n   at System.Text.Json.Serialization.Metadata.JsonTypeInfo.Configure()\r\n   at System.Text.Json.Serialization.Metadata.JsonTypeInfo.<EnsureConfigured>g__ConfigureLocked|143_0()\r\n   at System.Text.Json.JsonSerializerOptions.GetTypeInfoInternal(Type type, Boolean ensureConfigured, Boolean resolveIfMutable)\r\n   at System.Text.Json.JsonSerializer.GetTypeInfo(JsonSerializerOptions options, Type inputType)\r\n   at System.Text.Json.JsonSerializer.Deserialize[TValue](String json, JsonSerializerOptions options)\r\n   at Test.JsonRequired.Run() in C:\\Projects\\Sandbox\\Test\\JsonRequiredWithCtor.cs:line 48\r\n```\r\n\r\n### Regression?\r\n\r\n_No response_\r\n\r\n### Known Workarounds\r\n\r\n_No response_\r\n\r\n### Configuration\r\n\r\nSDK version: 7.0.100\r\nOS: Windows 10 1909\r\nArch: x64\r\n\r\n### Other information\r\n\r\nIt seems like implementation of required keyword support in https://github.com/dotnet/runtime/pull/72937\r\nwas made in way that makes JsonRequiredAttribute usage absolutely simular to new \"required\" keyword usage, missing the fact that validating absence of input json property using attribute might be used in other scenarios.",
    "number": 78098,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-12-07T08:51:16Z",
          "user": "MartyIX"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-04-30T09:59:53Z",
          "user": "artyomszasa"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-08-23T16:56:07Z",
          "user": "kroymann"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-05-11T12:04:55Z",
          "user": "amongonz"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-07-14T14:11:30Z",
          "user": "iikuzmychov"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-11-06T09:14:45Z",
          "user": "AmrAlSayed0"
        }
      ],
      "totalCount": 6,
      "endCursor": "Y3Vyc29yOnYyOpHOC8cAEg=="
    },
    "updatedAt": "2025-08-29T15:24:52Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\n### Description\n\n1. Using [[JsonRequiredAttribute]](https://learn.microsoft.com/en-us/dotnet/api/system.text.json.serialization.jsonrequiredattribute?view=net-7.0) published with .Net 7.0, on propertry that doesn't have public setter/initter, but initialized through ctor throws InvalidOperationException\r\n2. Obligation of property setter/initter existance is not described in documention [1](https://learn.microsoft.com/en-us/dotnet/standard/serialization/system-text-json/required-properties) [2](https://learn.microsoft.com/en-us/dotnet/standard/serialization/system-text-json/required-properties) \r\n\n\n### Reproduction Steps\n\n```csharp\r\nusing System.Text.Json.Serialization;\r\n\r\nnamespace Test;\r\n\r\ninternal static class JsonRequired\r\n{\r\n    public sealed class RequiredAttributeCtor\r\n    {\r\n        [JsonPropertyName(\"value\")]\r\n        [JsonRequired]\r\n        public int Value { get; }\r\n\r\n        public RequiredAttributeCtor(int value)\r\n        {\r\n            Value = value;\r\n        }\r\n    }\r\n\r\n    public static RequiredAttributeCtor? Run()\r\n    {\r\n        const string input = \"\"\"{\"value\":1}\"\"\";\r\n        return System.Text.Json.JsonSerializer.Deserialize<RequiredAttributeCtor>(input);\r\n    }\r\n\r\n}\r\n```\r\n\n\n### Expected behavior\n\n### Local\r\nReproduction test returns instance of RequiredAttributeCtor type populated with data from input\r\n\r\n### Global\r\nAll of the required property initialization variations are supported\r\n\r\n```csharp\r\n\r\nusing System.Text.Json.Serialization;\r\n\r\nnamespace Test;\r\n\r\ninternal static class JsonRequired\r\n{\r\n    public sealed class RequiredAttributeCtor\r\n    {\r\n        [JsonPropertyName(\"value\")]\r\n        [JsonRequired]\r\n        public int Value { get; }\r\n\r\n        public RequiredAttributeCtor(int value)\r\n        {\r\n            Value = value;\r\n        }\r\n    }\r\n\r\n    public sealed class RequiredAttributeSet\r\n    {\r\n        [JsonPropertyName(\"value\")]\r\n        [JsonRequired]\r\n        public int Value { get; set; }\r\n    }\r\n\r\n    public sealed class RequiredAttributeInit\r\n    {\r\n        [JsonPropertyName(\"value\")]\r\n        [JsonRequired]\r\n        public int Value { get; init; }\r\n    }\r\n\r\n    public sealed class RequiredKeywordSet\r\n    {\r\n        [JsonPropertyName(\"value\")]\r\n        public required int Value { get; set; }\r\n    }\r\n\r\n    public sealed class RequiredKeywordInit\r\n    {\r\n        [JsonPropertyName(\"value\")]\r\n        public required int Value { get; init; }\r\n    }\r\n\r\n    public static void Run()\r\n    {\r\n        const string input = \"\"\"{\"value\":1}\"\"\";\r\n        var _1 =  System.Text.Json.JsonSerializer.Deserialize<RequiredAttributeCtor>(input);\r\n        var _2 =  System.Text.Json.JsonSerializer.Deserialize<RequiredAttributeSet>(input);\r\n        var _3 =  System.Text.Json.JsonSerializer.Deserialize<RequiredAttributeInit>(input);\r\n        var _4 =  System.Text.Json.JsonSerializer.Deserialize<RequiredKeywordSet>(input);\r\n        var _5 =  System.Text.Json.JsonSerializer.Deserialize<RequiredKeywordInit>(input);\r\n    }\r\n}\r\n\r\n```\r\n\n\n### Actual behavior\n\nRunning reproduction test throws \r\n```\r\nUnhandled exception. System.InvalidOperationException: JsonPropertyInfo 'value' defined in type 'Test.JsonRequired+RequiredAttributeCtor' is marked required but does not specify a setter.\r\n   at System.Text.Json.ThrowHelper.ThrowInvalidOperationException_JsonPropertyRequiredAndNotDeserializable(JsonPropertyInfo jsonPropertyInfo)\r\n   at System.Text.Json.Serialization.Metadata.JsonPropertyInfo.Configure()\r\n   at System.Text.Json.Serialization.Metadata.JsonTypeInfo.InitializePropertyCache()\r\n   at System.Text.Json.Serialization.Metadata.JsonTypeInfo.Configure()\r\n   at System.Text.Json.Serialization.Metadata.JsonTypeInfo.<EnsureConfigured>g__ConfigureLocked|143_0()\r\n   at System.Text.Json.JsonSerializerOptions.GetTypeInfoInternal(Type type, Boolean ensureConfigured, Boolean resolveIfMutable)\r\n   at System.Text.Json.JsonSerializer.GetTypeInfo(JsonSerializerOptions options, Type inputType)\r\n   at System.Text.Json.JsonSerializer.Deserialize[TValue](String json, JsonSerializerOptions options)\r\n   at Test.JsonRequired.Run() in C:\\Projects\\Sandbox\\Test\\JsonRequiredWithCtor.cs:line 48\r\n```\n\n### Regression?\n\n_No response_\n\n### Known Workarounds\n\n_No response_\n\n### Configuration\n\nSDK version: 7.0.100\r\nOS: Windows 10 1909\r\nArch: x64\n\n### Other information\n\nIt seems like implementation of required keyword support in https://github.com/dotnet/runtime/pull/72937\r\nwas made in way that makes JsonRequiredAttribute usage absolutely simular to new \"required\" keyword usage, missing the fact that validating absence of input json property using attribute might be used in other scenarios.\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>SicJG</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`area-System.Text.Json`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2022-11-09T18:48:37Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-11-09T18:48:37Z",
          "id": "IC_kwDODI9FZc5OCPx2"
        },
        {
          "author": "krwq",
          "body": "Only scenario `1` is not working currently. I think this is caused by artificial check I added which prevents from using read-only properties with `[Required]` - seems I missed the case with parametrized ctor + read-only property test case. I think the fix is simply adjusting that check + tests.",
          "createdAt": "2022-11-10T10:07:32Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-11-10T10:07:44Z",
          "id": "IC_kwDODI9FZc5OFcWz"
        },
        {
          "author": "krwq",
          "body": "@SicJG thanks for the report on this, I've sent a PR with a fix. Once it's merged you should be able to consume nightly NuGet package with a fix some time after that. I'll check if it qualifies for servicing fix for 7.0 but no promises on that.",
          "createdAt": "2022-11-10T11:39:09Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "HEART",
                "createdAt": "2022-11-10T11:52:52Z",
                "user": "SicJG"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOCvXhPg=="
          },
          "updatedAt": "2022-11-10T11:39:09Z",
          "id": "IC_kwDODI9FZc5OF2se"
        },
        {
          "author": "eiriktsarpalis",
          "body": "I don't believe this meets the bar for a 7.0 fix. `JsonRequiredAttribute` can only be applied to properties and has no effect on constructor parameters, even though the serializer will -by convention- associate constructor parameters to property getters when deriving constructor parameter metadata. The current behavior is consistent with how the C# compiler treats the `required` keyword in getter-only properties, for example the following does not compile:\r\n\r\n```C#\r\npublic class MyPoco\r\n{\r\n    public MyPoco(int value) => Value = value;\r\n\r\n    public required int Value { get; }\r\n}\r\n```\r\n\r\nThat being said, we should make sure that `JsonRequiredAttribute` can be applied consistently to constructor parameters in the future -- however this should probably be implemented in the context of https://github.com/dotnet/runtime/issues/71944 as there is a lot of nuance to be accounted for.",
          "createdAt": "2022-11-10T15:06:35Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-11-10T15:06:35Z",
          "id": "IC_kwDODI9FZc5OG5f2"
        },
        {
          "author": "MartyIX",
          "body": "Unfortunately, this is a blocker for us to use the `JsonRequiredAttribute` feature on .NET 7. Pity.",
          "createdAt": "2022-12-07T08:51:52Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-12-07T08:52:15Z",
          "id": "IC_kwDODI9FZc5P5_fz"
        },
        {
          "author": "krwq",
          "body": "@MartyIX the isolated fix is in the PR https://github.com/dotnet/runtime/pull/78152.\r\n\r\nThere is also workaround which I didn't mention yet:\r\n\r\n```csharp\r\nusing System.Text.Json;\r\nusing System.Text.Json.Serialization;\r\nusing System.Text.Json.Serialization.Metadata;\r\n\r\nJsonSerializerOptions options = new()\r\n{\r\n    TypeInfoResolver = new DefaultJsonTypeInfoResolver()\r\n    {\r\n        Modifiers = { JsonRequiredWithPropertiesWithoutSetter }\r\n    }\r\n};\r\n\r\nMyPoco obj = JsonSerializer.Deserialize<MyPoco>(\"\"\"{\"Value\": 123}\"\"\", options);\r\nConsole.WriteLine(obj.Value);\r\n\r\nvoid JsonRequiredWithPropertiesWithoutSetter(JsonTypeInfo typeInfo)\r\n{\r\n    if (typeInfo.Kind != JsonTypeInfoKind.Object)\r\n        return;\r\n\r\n    foreach (var property in typeInfo.Properties)\r\n    {\r\n        if (property.IsRequired && property.Set == null)\r\n        {\r\n            // this will never be called for parameterized constructors\r\n            property.Set = (obj, val) => throw new JsonException(\"Required property doesn't have setter\");\r\n        }\r\n    }\r\n}\r\n\r\npublic class MyPoco\r\n{\r\n    public MyPoco(int value) => Value = value;\r\n\r\n    [JsonRequired]\r\n    public int Value { get; }\r\n}\r\n```",
          "createdAt": "2022-12-07T09:35:52Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "HEART",
                "createdAt": "2022-12-07T09:37:47Z",
                "user": "MartyIX"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOCw1gYg=="
          },
          "updatedAt": "2022-12-07T09:36:37Z",
          "id": "IC_kwDODI9FZc5P6M0Y"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Moving to 9.0 per https://github.com/dotnet/runtime/pull/78152#issuecomment-1638468540",
          "createdAt": "2023-07-27T12:32:07Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-07-27T12:32:07Z",
          "id": "IC_kwDODI9FZc5ijt1J"
        },
        {
          "author": "SicJG",
          "body": "Might be considered as closed due to implementation of [JsonSerializerOptions.RespectRequiredConstructorParameters](https://github.com/dotnet/runtime/issues/100075) as well as [JsonSerializerOptions.RespectNullableAnnotations](https://github.com/dotnet/runtime/issues/100144)\r\nThank you for this functionality!\r\n",
          "createdAt": "2024-09-12T13:33:21Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-09-12T13:33:21Z",
          "id": "IC_kwDODI9FZc6L2a_j"
        },
        {
          "author": "eiriktsarpalis",
          "body": "It seems we might still want to make this work if the flag hasn't been enabled though. Let's leave this open for now.",
          "createdAt": "2024-09-12T13:38:01Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-09-12T13:38:01Z",
          "id": "IC_kwDODI9FZc6L2eun"
        },
        {
          "author": "louislewis2",
          "body": "Good day,\n\nWas this issue address and I am missing it in the details above?\nI am running into an issue, and I was kindly directed here.\n\nThe issue can be found here. \nhttps://github.com/dotnet/aspnetcore/issues/63378\n\nI have create a simply repository, in the link above which shows the error happening with the \"latest packages\"\n\nThank you\n",
          "createdAt": "2025-08-22T10:27:53Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-08-22T10:27:53Z",
          "id": "IC_kwDODI9FZc6_j_tY"
        },
        {
          "author": "SicJG",
          "body": "@louislewis2 \nIt seems that Microsoft.AspNet.OpenApi package makes some sort of conversion(more likely through JsonTypeInfo) from [System.ComponentModel.DataAnnotations.Required] that you use to [S.T.J.JsonRequired] resulting behaviour that you observe and that is described in current issue,\n",
          "createdAt": "2025-08-26T09:42:28Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-08-26T09:42:28Z",
          "id": "IC_kwDODI9FZc7AIbAA"
        },
        {
          "author": "louislewis2",
          "body": "Hi @SicJG \n\nThanks for your comments.\nHowever I am less interested in what code change I can make to resolve this issue.\nOver just the last 10+ years, that pattern I have implemented and taught in many companies.\n\nI could not possibly calculate the impact changing the code would have. (Nor would I like to honestly)\n\nIt is far easier for example to simply switch back to swagger generation solely and not make use of the newer methods.\nThe code and sample I provided are valid and a known pattern meaning, I do not think I am the only person who uses that pattern.\n\nThough the lack of someone from MS responding is a little disturbing, should I simply create a new issue to get attention?",
          "createdAt": "2025-08-29T15:24:52Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-08-29T15:24:52Z",
          "id": "IC_kwDODI9FZc7A9xIF"
        }
      ],
      "totalCount": 12,
      "endCursor": "Y3Vyc29yOnYyOpHOwPcSBQ=="
    },
    "url": "https://github.com/dotnet/runtime/issues/78098",
    "title": "S.T.J.JsonSerializer doesn't support properties marked with JsonRequiredAttribute that're initialized through ctor"
  },
  {
    "author": "krwq",
    "labels": [
      "api-suggestion",
      "area-System.Text.Json"
    ],
    "createdAt": "2022-11-10T11:28:12Z",
    "body": "Compiler `required` keyword semantics\r\n\r\n```csharp\r\nprivate class Test\r\n{\r\n    public required string Name { get; } // error\r\n\r\n    public Test(string name)\r\n    {\r\n        Name = name;\r\n    }\r\n}\r\n```\r\n\r\ndon't allow to compile above code because property doesn't have a setter - this makes sense because argument needs to be passed in the constructor anyway making `required` effectively redundant.\r\n\r\nOn the other hand when deserializing JSON `Name` does not have to be passed in the payload even though the only way to construct is through constructor - we will use default value (i.e. if value was `int` we'd pass 0 or `null` for `string` for you automatically):\r\n\r\n```csharp\r\nvar obj = System.Text.Json.JsonSerializer.Deserialize<Test>(\"{}\"); // no error\r\n\r\npublic sealed class Test\r\n{\r\n    public string Name { get; }\r\n\r\n    public Test(string name)\r\n    {\r\n        Name = name;\r\n    }\r\n}\r\n```\r\n\r\nConsider changing semantics here and make `Name` required instead making above code create error. Possibly there should be an option switch to opt-in to suggested behavior given this change will be breaking.\r\n\r\nExample API suggestion (possibly consider enum and more generic name in case we need more related options in the future):\r\n\r\n```csharp\r\npublic partial class JsonSerializerOptions\r\n{\r\n    public bool RequireConstructorParameters { get; set; }\r\n}\r\n```\r\n\r\nRelated: https://github.com/dotnet/runtime/issues/78098",
    "number": 78151,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "ROCKET",
          "createdAt": "2022-11-10T12:14:42Z",
          "user": "SicJG"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-11-30T21:22:38Z",
          "user": "bjornen77"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-08-23T16:51:39Z",
          "user": "kroymann"
        }
      ],
      "totalCount": 3,
      "endCursor": "Y3Vyc29yOnYyOpHOCyImDw=="
    },
    "updatedAt": "2023-01-25T17:28:50Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\nCompiler `required` keyword semantics\r\n\r\n```csharp\r\nprivate class Test\r\n{\r\n    public required string Name { get; } // error\r\n\r\n    public Test(string name)\r\n    {\r\n        Name = name;\r\n    }\r\n}\r\n```\r\n\r\ndon't allow to compile above code because property doesn't have a setter - this makes sense because argument needs to be passed in the constructor anyway making `required` effectively redundant.\r\n\r\nOn the other hand when deserializing JSON `Name` does not have to be passed in the payload even though the only way to construct is through constructor - we will use default value (i.e. if value was `int` we'd pass 0 or `null` for `string` for you automatically):\r\n\r\n```csharp\r\nvar obj = System.Text.Json.JsonSerializer.Deserialize<Test>(\"{}\"); // no error\r\n\r\npublic sealed class Test\r\n{\r\n    public string Name { get; }\r\n\r\n    public Test(string name)\r\n    {\r\n        Name = name;\r\n    }\r\n}\r\n```\r\n\r\nConsider changing semantics here and make `Name` required instead making above code create error. Possibly there should be an option switch to opt-in to suggested behavior given this change will be breaking.\r\n\r\nExample API suggestion (possibly consider enum and more generic name in case we need more related options in the future):\r\n\r\n```csharp\r\npublic partial class JsonSerializerOptions\r\n{\r\n    public RequireConstructorParameters { get; set; }\r\n}\r\n```\r\n\r\nRelated: https://github.com/dotnet/runtime/issues/78098\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>krwq</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`api-suggestion`, `area-System.Text.Json`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2022-11-10T11:28:20Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-11-10T11:28:20Z",
          "id": "IC_kwDODI9FZc5OFzKp"
        },
        {
          "author": "krwq",
          "body": "alternative design for that would be to provide Modifier for contract resolver but it's currently tricky to implement as a separate library because we don't have parametrized ctor APIs available yet (so basically user has to repeat JsonConstructor logic).",
          "createdAt": "2022-11-10T14:43:01Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-11-10T14:43:01Z",
          "id": "IC_kwDODI9FZc5OGxGW"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Proposal looks good to me. We should also include provision for configuring requiredness on the type level:\r\n```C#\r\npublic sealed class Test\r\n{\r\n    [JsonConstructor(RequireParameters = true)]\r\n    public Test(int p1, int p2, int p3, int p4, ...)\r\n    {\r\n    }\r\n}\r\n```\r\nand at the individual parameter level:\r\n```C#\r\npublic sealed class Test\r\n{\r\n    public Test(int p1, [JsonRequired] int p2, int p3, int p4, ...)\r\n    {\r\n    }\r\n}\r\n```",
          "createdAt": "2022-11-10T15:32:25Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-11-10T15:32:54Z",
          "id": "IC_kwDODI9FZc5OHCyy"
        },
        {
          "author": "krwq",
          "body": "Extra overload of `JsonConstructorAttribute` sound good but for JsonRequired - we put `[JsonConverter(...)]` and `[JsonNumberHandling(...)]` directly on the property so I'm not sure why we'd do it differently for `[JsonRequired]`...",
          "createdAt": "2022-11-10T17:58:42Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-11-10T17:58:42Z",
          "id": "IC_kwDODI9FZc5OH1-v"
        },
        {
          "author": "krwq",
          "body": "marking as 8.0 because we should look at this in conjunction with other 8.0 items.",
          "createdAt": "2022-11-23T09:29:49Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-11-23T09:29:49Z",
          "id": "IC_kwDODI9FZc5O9l3f"
        }
      ],
      "totalCount": 5,
      "endCursor": "Y3Vyc29yOnYyOpHOTvZd3w=="
    },
    "url": "https://github.com/dotnet/runtime/issues/78151",
    "title": "Treat constructor arguments as required properties"
  },
  {
    "author": "angelaki",
    "labels": [
      "api-suggestion",
      "area-System.Text.Json",
      "wishlist"
    ],
    "createdAt": "2022-11-22T17:27:28Z",
    "body": "### Background and motivation\n\nThe latests System.Text.Json APIs finally allow me to use Interfaces for deserialization since I'm able to control class to be used etc.. Creating my own TypeInfoResolver based on `DefaultJsonTypeInfoResolver` makes it now pretty hard to popule my own PropertyCollection since the default resolver uses pretty much internal APIs to generate it's property collection.\r\n\r\nIf I'm not mistaken, most of the magic happens in `ReflectionJsonTypeInfo` (internal sealed class).\n\n### API Proposal\n\nCreate a public API that offers these functionalities (e.g. by making this class public available?).\n\n### API Usage\n\n```csharp\r\npublic class MyTypeInfoResolver : DefaultJsonTypeInfoResolver\r\n{\r\n    public override JsonTypeInfo GetTypeInfo(Type type, JsonSerializerOptions options)\r\n    {\r\n        if (type.IsInterface)\r\n        {\r\n            var result = JsonTypeInfo.CreateJsonTypeInfo(type, options);\r\n            result.CreateObject = () => new CAA();\r\n\r\n            foreach (var p in type.GetProperties())\r\n            {\r\n                //Allow me to add properties here based on `System.Reflection.PropertyInfo`\r\n            }\r\n\r\n            return result;\r\n        }\r\n\r\n        return base.GetTypeInfo(type, options);\r\n    }\r\n}\r\n```\r\n\n\n### Alternative Designs\n\n_No response_\n\n### Risks\n\n_No response_",
    "number": 78711,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-09-30T21:15:27Z",
          "user": "ojonasplima"
        }
      ],
      "totalCount": 1,
      "endCursor": "Y3Vyc29yOnYyOpHOC7ciAg=="
    },
    "updatedAt": "2022-11-24T13:55:10Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\n### Background and motivation\n\nThe latests System.Text.Json APIs finally allow me to use Interfaces for deserialization since I'm able to control class to be used etc.. Creating my own TypeInfoResolver based on `DefaultJsonTypeInfoResolver` makes it now pretty hard to popule my own PropertyCollection since the default resolver uses pretty much internal APIs to generate it's property collection.\r\n\r\nIf I'm not mistaken, most of the magic happens in `ReflectionJsonTypeInfo` (internal sealed class).\n\n### API Proposal\n\nCreate a public API that offers these functionalities (e.g. by making this class public available?).\n\n### API Usage\n\n```csharp\r\npublic class MyTypeInfoResolver : DefaultJsonTypeInfoResolver\r\n{\r\n    public override JsonTypeInfo GetTypeInfo(Type type, JsonSerializerOptions options)\r\n    {\r\n        if (type.IsInterface)\r\n        {\r\n            var result = JsonTypeInfo.CreateJsonTypeInfo(type, options);\r\n            result.CreateObject = () => new CAA();\r\n\r\n            foreach (var p in type.GetProperties())\r\n            {\r\n                //Allow me to add properties here based on `System.Reflection.PropertyInfo`\r\n            }\r\n\r\n            return result;\r\n        }\r\n\r\n        return base.GetTypeInfo(type, options);\r\n    }\r\n}\r\n```\r\n\n\n### Alternative Designs\n\n_No response_\n\n### Risks\n\n_No response_\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>angelaki</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`api-suggestion`, `area-System.Text.Json`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2022-11-22T17:27:35Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-11-22T17:27:35Z",
          "id": "IC_kwDODI9FZc5O6uj3"
        },
        {
          "author": "eiriktsarpalis",
          "body": "I might not be understanding the request well enough but doesn't adding entries to the `JsonTypeInfo.Properties` property work for you? See [this docs section](https://learn.microsoft.com/en-us/dotnet/standard/serialization/system-text-json/custom-contracts#example-serialize-private-fields) for an example.",
          "createdAt": "2022-11-22T18:45:25Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-11-22T18:45:25Z",
          "id": "IC_kwDODI9FZc5O7DKu"
        },
        {
          "author": "layomia",
          "body": "Also, per the issue title and to raise the visibility of the method in the doc Eirik linked: are you aware of [`JsonTypeInfo.CreateJsonPropertyInfo`](https://docs.microsoft.com/en-us/dotnet/api/system.text.json.serialization.metadata.jsontypeinfo.createjsonpropertyinfo?view=net-7.0)?",
          "createdAt": "2022-11-22T18:59:44Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-11-22T19:03:06Z",
                "user": "eiriktsarpalis"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOCwCXMQ=="
          },
          "updatedAt": "2022-11-22T18:59:44Z",
          "id": "IC_kwDODI9FZc5O7HGe"
        },
        {
          "author": null,
          "body": "This issue has been marked `needs-author-action` and may be missing some important information.",
          "createdAt": "2022-11-22T19:00:11Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-11-22T19:00:11Z",
          "id": "IC_kwDODI9FZc5O7HNh"
        },
        {
          "author": "angelaki",
          "body": "Yes, I know [JsonTypeInfo.CreateJsonPropertyInfo](https://docs.microsoft.com/en-us/dotnet/api/system.text.json.serialization.metadata.jsontypeinfo.createjsonpropertyinfo?view=net-7.0), but thank you for mentioning it! Is there a reason it is not a static method? I was asking myself when I found it.\r\n\r\nNever the less, I'd like to have an easy API allowing me to generate a `System.Text.Json.Serialization.Metadata.JsonPropertyInfo` based on a `\r\nSystem.Reflection.PropertyInfo`. Imho this is a common use-case and right now I'd need to write an extension method for something the `DefaultJsonTypeInfoResolver` is doing internal anyway.",
          "createdAt": "2022-11-22T21:47:51Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-11-22T21:47:51Z",
          "id": "IC_kwDODI9FZc5O7trT"
        },
        {
          "author": "eiriktsarpalis",
          "body": "We might consider offering that as an accelerator method, but generally speaking it should pretty straightforward to write one yourself:\r\n```C#\r\npublic static JsonPropertyInfo CreateJsonPropertyInfo(this JsonTypeInfo jsonTypeInfo, PropertyInfo propertyInfo)\r\n{\r\n    // NB does not map any attribute data like JsonConverterAttribute or JsonPropertyName\r\n    JsonPropertyInfo jsonPropertyInfo = jsonTypeInfo.CreateJsonPropertyInfo(propertyInfo.PropertyType, propertyInfo.Name);\r\n    jsonPropertyInfo.AttributeProvider = propertyInfo;\r\n\r\n    if (propertyInfo.CanRead)\r\n        jsonPropertyInfo.Get = propertyInfo.GetValue;\r\n\r\n    if (propertyInfo.CanWrite)\r\n        jsonPropertyInfo.Set = propertyInfo.SetValue;\r\n\r\n    return jsonPropertyInfo;\r\n}\r\n```",
          "createdAt": "2022-11-23T11:23:37Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-04-01T14:52:37Z",
                "user": "KarlFenech-AscentSoftware"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHODck4aA=="
          },
          "updatedAt": "2022-11-23T11:23:37Z",
          "id": "IC_kwDODI9FZc5O-HER"
        },
        {
          "author": "angelaki",
          "body": "@eiriktsarpalis Yeah, sure. We're speaking about micro optimization here. But imho this extension method could / should be used by the reflector JsonPropertyInfo internally, too.\r\n\r\nCorresponding it should be an implementation supporting attributes etc. Optionally configurable.",
          "createdAt": "2022-11-23T11:57:03Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-11-23T11:59:13Z",
          "id": "IC_kwDODI9FZc5O-RVK"
        },
        {
          "author": "krwq",
          "body": "The reason CreateJsonPropertyInfo is not static is that we want it to be possible to create `JsonPropertyInfo<DeclaringType, PropertyType>` in the future. JsonPropertyInfo is currently forced to be tied with specific JsonTypeInfo implementation so that no one is tempted to create it with different options and we're not locked with the design forever.\r\n\r\nPlease update your proposal with specific API addition and we can consider that depending on the demand. Generally speaking creating properties from scratch most of the time should not be necessary because of the modifiers and different knobs in the options and that's why we didn't particularly focus on adding utilities.\r\n\r\nCan you describe your scenario more why it needs to add properties from scratch and it can't re-use what was added by default?",
          "createdAt": "2022-11-23T12:28:25Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-11-23T12:28:25Z",
          "id": "IC_kwDODI9FZc5O-bPY"
        },
        {
          "author": "angelaki",
          "body": "I've implemented an API where for in- and outgoing objects only interfaces are used. For a long time I was forced to use Newtonsoft.JSON, with S.T.J 7.0 I'm finally able to use interfaces (btw, thank you for this new, awesome API!).\r\n\r\nBut since Interfaces do not inherit properties the _classical way_, I need to loop through the interfaces and add their properties to serialization manually. That is where I'm forced to add the properties myself. (1)\r\n\r\nFurthermore I'm adding my own OutputFormatters (based on `SystemTextJsonOutputFormatter`) for similar proposes. Right now I need to add an OutputFormatter for every deviating serializer-settings, since my Controllers are able to set the used interface for serialization via attribute. Since the (sealed) `WriteResponseBodyAsync` method uses the `JsonSerializerOptions` provided with the constructor, I am not able to deal with varying settings in a single OutputFormatter. (2)\r\n\r\nIs one of those use-cases interesting for you to get respected?\r\n\r\n1. Commonly used method to create reflection based JsonPropertyInfos\r\n2. `SystemTextJsonOutputFormatter` being able to use varying `JsonSerializerOptions`\r\n\r\nplease let me know, so I would create a new API Proposal and close this discussion.",
          "createdAt": "2022-11-23T13:00:35Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-11-23T13:00:56Z",
          "id": "IC_kwDODI9FZc5O-jPK"
        },
        {
          "author": "eiriktsarpalis",
          "body": "> But since Interfaces do not inherit properties the classical way\r\n\r\nI'm guessing you mean this issue? https://github.com/dotnet/runtime/issues/41749",
          "createdAt": "2022-11-23T15:22:54Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-11-23T15:22:54Z",
          "id": "IC_kwDODI9FZc5O_alA"
        },
        {
          "author": "angelaki",
          "body": "@eiriktsarpalis at least this issue is pretty related, yes. But imho STJ isn't the library that needs to handle this. Guess we'll end up with the discussion, why .Net doesn't think inherited interface properties belong to the interface (just like inherited class properties does). Even though I never found a good reason for it, that is the way .Net handles this and changing it would be quite more than just a _breaking change_.\r\n\r\nI think the use-case is pretty advanced / rare and interface serialization should be handled manually anyway. Otherwise people could complain that the serializer writes properties, typeof(IObject).GetProperties() doesn't provide. Staying with .Net's behavior is just right I guess. Never the less, a common code base to generate properties (JsonPropertyInfo) based on PropertyInfos would be great.\r\n\r\nAnd what do you think of the SystemTextJsonFormatters being able to change the SerializerSettings context based? I could write a pretty simple PR containing this possibility. Wouldn't be a breaking change and allow even more customizations I think. I'd create an abstract `DynamicSystemTextJsonFormatter` providing and abstract function to get the `SerializerSettings` used. The default `SystemTextJsonsFormatter`s would just provide the only they received in their constructor.\r\n\r\nIf you think this use-case is too rare I'd stay with my solution implementing my very own Formatter that copies just the default ones code.",
          "createdAt": "2022-11-24T13:53:27Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-11-24T13:55:10Z",
          "id": "IC_kwDODI9FZc5PEIoY"
        }
      ],
      "totalCount": 11,
      "endCursor": "Y3Vyc29yOnYyOpHOTxCKGA=="
    },
    "url": "https://github.com/dotnet/runtime/issues/78711",
    "title": "[API Proposal]: Provide APIs to create JsonPropertyInfo based on PropertyInfo"
  },
  {
    "author": "drdamour",
    "labels": [
      "enhancement",
      "area-System.Text.Json",
      "wishlist"
    ],
    "createdAt": "2022-11-23T18:29:56Z",
    "body": "I like to use JsonExtensionData to detect if the producer starts adding things to the “extensible” json that they produce that my serializer types aren't handling.  I hook these up to log traps that let my program tell my team we should consider changes.\r\n\r\n\r\nI also like my types to be immutable on their public surface (everywhere if i can have it).  Hoping for #31645 for that\r\n\r\nAnd i prefer to have my dictionary hidden from\r\npublic surface since i dont want consumers to use stuff that hasnt really gone through vetting.\r\n\r\nbut it seems system.text.json cant leverage a non public prop for JsonExtensionData cause nothing can per #31511 but i propose JsonExtensionData is a special case that should be considered since the workarounds in that ticket dont seem to apply.\r\n\r\n\r\n",
    "number": 78775,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-11-23T19:14:52Z",
          "user": "NattyMojo"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-12-07T10:44:23Z",
          "user": "ddweber"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-03-31T17:04:11Z",
          "user": "Swimburger"
        }
      ],
      "totalCount": 3,
      "endCursor": "Y3Vyc29yOnYyOpHODAr_QQ=="
    },
    "updatedAt": "2023-05-12T22:07:33Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\nI like to use JsonExtensionData to detect if the producer starts adding things to the “extensible” json that they produce that my serializer types aren't handling.  I hook these up to log traps that let my program tell my team we should consider changes.\r\n\r\n\r\nI also like my types to be immutable on their public surface (everywhere if i can have it).  Hoping for #31645 for that\r\n\r\nAnd i prefer to have my dictionary hidden from\r\npublic surface since i dont want consumers to use stuff that hasnt really gone through vetting.\r\n\r\nbut it seems system.text.json cant leverage a non public prop for JsonExtensionData cause nothing can per #31511 but i propose JsonExtensionData is a special case that should be considered since the workarounds in that ticket dont seem to apply.\r\n\r\n\r\n\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>drdamour</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`area-System.Text.Json`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2022-11-23T18:30:03Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-11-23T18:30:03Z",
          "id": "IC_kwDODI9FZc5PAXND"
        },
        {
          "author": "eiriktsarpalis",
          "body": "We might consider extending `JsonIncludeAttribute` so that it can be used with non-public members, including extension properties.\r\n\r\nIn the meantime, it should be possible to work around your issue in .NET 7 using a custom contract resolver:\r\n```C#\r\nvar options = new JsonSerializerOptions\r\n{\r\n    TypeInfoResolver = new DefaultJsonTypeInfoResolver()\r\n    {\r\n        Modifiers =\r\n        {\r\n            static typeInfo =>\r\n            {\r\n                if (typeInfo.Kind == JsonTypeInfoKind.Object && \r\n                    typeInfo.Properties.All(prop => !prop.IsExtensionData))\r\n                {\r\n                    PropertyInfo? extensionProp = typeInfo.Type\r\n                        .GetProperties(BindingFlags.Instance | BindingFlags.NonPublic)\r\n                        .FirstOrDefault(prop => prop.GetCustomAttribute<JsonExtensionDataAttribute>() != null);\r\n\r\n                    if (extensionProp != null)\r\n                    {\r\n                        JsonPropertyInfo jsonPropertyInfo = typeInfo.CreateJsonPropertyInfo(extensionProp.PropertyType, extensionProp.Name);\r\n                        jsonPropertyInfo.Get = extensionProp.GetValue;\r\n                        jsonPropertyInfo.Set = extensionProp.SetValue;\r\n                        jsonPropertyInfo.IsExtensionData = true;\r\n                        typeInfo.Properties.Add(jsonPropertyInfo);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\nMyPoco result = JsonSerializer.Deserialize<MyPoco>(\"\"\"{\"foo\":\"bar\"}\"\"\", options);\r\nConsole.WriteLine(result.Data[\"foo\"]); // \"bar\"\r\n\r\npublic class MyPoco\r\n{\r\n    [JsonExtensionData]\r\n    internal Dictionary<string, object>? Data { get; set; }\r\n}\r\n```",
          "createdAt": "2022-11-24T12:49:49Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "HEART",
                "createdAt": "2022-11-26T06:25:03Z",
                "user": "jeffhandley"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-11-28T21:39:12Z",
                "user": "drdamour"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-12-07T10:44:33Z",
                "user": "ddweber"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-03-31T17:04:46Z",
                "user": "Swimburger"
              }
            ],
            "totalCount": 4,
            "endCursor": "Y3Vyc29yOnYyOpHOEMQ0JA=="
          },
          "updatedAt": "2022-11-24T12:49:49Z",
          "id": "IC_kwDODI9FZc5PD2az"
        },
        {
          "author": "drdamour",
          "body": "that's awesome, i didn't catch the IsExtensionData of the contract stuff.  ",
          "createdAt": "2022-11-28T21:39:51Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-11-29T11:40:30Z",
                "user": "eiriktsarpalis"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOCwWqzQ=="
          },
          "updatedAt": "2022-11-28T21:39:51Z",
          "id": "IC_kwDODI9FZc5PQwlM"
        },
        {
          "author": "l-404-l",
          "body": "> We might consider extending `JsonIncludeAttribute` so that it can be used with non-public members, including extension properties.\r\n> \r\n> In the meantime, it should be possible to work around your issue in .NET 7 using a custom contract resolver:\r\n> \r\n> ```cs\r\n> var options = new JsonSerializerOptions\r\n> {\r\n>     TypeInfoResolver = new DefaultJsonTypeInfoResolver()\r\n>     {\r\n>         Modifiers =\r\n>         {\r\n>             static typeInfo =>\r\n>             {\r\n>                 if (typeInfo.Kind == JsonTypeInfoKind.Object && \r\n>                     typeInfo.Properties.All(prop => !prop.IsExtensionData))\r\n>                 {\r\n>                     PropertyInfo? extensionProp = typeInfo.Type\r\n>                         .GetProperties(BindingFlags.Instance | BindingFlags.NonPublic)\r\n>                         .FirstOrDefault(prop => prop.GetCustomAttribute<JsonExtensionDataAttribute>() != null);\r\n> \r\n>                     if (extensionProp != null)\r\n>                     {\r\n>                         JsonPropertyInfo jsonPropertyInfo = typeInfo.CreateJsonPropertyInfo(extensionProp.PropertyType, extensionProp.Name);\r\n>                         jsonPropertyInfo.Get = extensionProp.GetValue;\r\n>                         jsonPropertyInfo.Set = extensionProp.SetValue;\r\n>                         jsonPropertyInfo.IsExtensionData = true;\r\n>                         typeInfo.Properties.Add(jsonPropertyInfo);\r\n>                     }\r\n>                 }\r\n>             }\r\n>         }\r\n>     }\r\n> };\r\n> \r\n> MyPoco result = JsonSerializer.Deserialize<MyPoco>(\"\"\"{\"foo\":\"bar\"}\"\"\", options);\r\n> Console.WriteLine(result.Data[\"foo\"]); // \"bar\"\r\n> \r\n> public class MyPoco\r\n> {\r\n>     [JsonExtensionData]\r\n>     internal Dictionary<string, object>? Data { get; set; }\r\n> }\r\n> ```\r\n\r\nYes please extend JsonIncludes to non-public members would help when creating complex models. ",
          "createdAt": "2023-05-12T22:07:33Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-04-09T22:24:19Z",
                "user": "Swimburger"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-07-04T10:01:57Z",
                "user": "atteneder"
              }
            ],
            "totalCount": 2,
            "endCursor": "Y3Vyc29yOnYyOpHOEZQr5Q=="
          },
          "updatedAt": "2023-05-12T22:07:33Z",
          "id": "IC_kwDODI9FZc5cK5p_"
        }
      ],
      "totalCount": 4,
      "endCursor": "Y3Vyc29yOnYyOpHOXCuafw=="
    },
    "url": "https://github.com/dotnet/runtime/issues/78775",
    "title": "[feature request]: system.text.json JsonExtensionData support for internal and private/protected"
  },
  {
    "author": "xperiandri",
    "labels": [
      "api-suggestion",
      "area-System.Text.Json"
    ],
    "createdAt": "2022-11-27T20:24:48Z",
    "body": "### Background and motivation\r\n\r\nIn GraphQL you need to put extension fields into a separate filed\r\nhttp://spec.graphql.org/October2021/#sec-Errors.Error-result-format\r\n\r\nIt will work backward, all the C# properties marked with this attribute will go to extensions field\r\n\r\n### API Proposal\r\n\r\n```csharp\r\n[AttributeUsage(AttributeTargets.Property | AttributeTargets.Field, AllowMultiple = false)]\r\npublic sealed class JsonExtensionDataAttribute : JsonAttribute\r\n{\r\n    public string? ExtensionsPropertyName { get; set; }\r\n\r\n    public JsonExtensionDataAttribute() { }\r\n    public JsonExtensionDataAttribute(string extensionsPropertyName) { }\r\n}\r\n```\r\n\r\n\r\n### API Usage\r\n\r\n```csharp\r\n[JsonExtensionData(\"extensions\")]\r\npublic int StatusCode { get; set; }\r\n```\r\n\r\n\r\n### Alternative Designs\r\n\r\nWrite a custom converter\r\n\r\n### Risks\r\n\r\n_No response_",
    "number": 78890,
    "reactions": {
      "hasNextPage": false,
      "nodes": [],
      "totalCount": 0,
      "endCursor": null
    },
    "updatedAt": "2022-12-16T19:07:28Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\n### Background and motivation\n\nIn GraphQL you need to put extension fields into a separate filed\r\nhttp://spec.graphql.org/October2021/#sec-Errors.Error-result-format\n\n### API Proposal\n\n```csharp\r\n[AttributeUsage(AttributeTargets.Property | AttributeTargets.Field, AllowMultiple = false)]\r\npublic sealed class JsonExtensionDataAttribute : JsonAttribute\r\n{\r\n    public string? ExtensionsPropertyName { get; set; }\r\n\r\n    public JsonExtensionDataAttribute() { }\r\n    public JsonExtensionDataAttribute(string extensionsPropertyName) { }\r\n}\r\n```\r\n\n\n### API Usage\n\n```csharp\r\n[JsonExtensionData(\"extensions\")]\r\n```\r\n\n\n### Alternative Designs\n\n_No response_\n\n### Risks\n\n_No response_\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>xperiandri</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`api-suggestion`, `area-System.Text.Json`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2022-11-27T20:25:03Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-11-27T20:25:03Z",
          "id": "IC_kwDODI9FZc5PLL_Q"
        },
        {
          "author": "layomia",
          "body": "Seems reasonable; would be nice to have compat with GraphQL. Would be great to see more user feedback to help with priotization.",
          "createdAt": "2022-12-16T19:07:16Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-12-16T19:07:16Z",
          "id": "IC_kwDODI9FZc5QyneZ"
        }
      ],
      "totalCount": 2,
      "endCursor": "Y3Vyc29yOnYyOpHOUMp3mQ=="
    },
    "url": "https://github.com/dotnet/runtime/issues/78890",
    "title": "[API Proposal]: Allow to specify propety name in `JsonExtensionDataAttribute` and work in oposite way"
  },
  {
    "author": "andref15",
    "labels": [
      "api-suggestion",
      "area-System.Text.Json",
      "wishlist"
    ],
    "createdAt": "2022-11-28T16:58:20Z",
    "body": "### Is there an existing issue for this?\n\n- [X] I have searched the existing issues\n\n### Describe the bug\n\nI have an ASP.net core Web API, that uses the standard system text json serializer and I configured the reference handling as IgnoreCycles.\r\nThe issue is that now when a Cycle is detected inside a collection, the resulting json looks like this:\r\n\r\n    {\r\n      \"MyCollection\": [\r\n        null\r\n       ]\r\n    }\r\n\r\nThis json is sent to an angular application, that sends this exact object back and this null entry in the list causes some issues down the line. I wasn't able to find any way to fix this (I tried setting the DefaultIgnoreCondition, hoping that it might also work in collections)\n\n### Expected Behavior\n\nIMO the serializer should skip the item entirely, if it's inside a collection, or at least provide some option to configure this behavior, sothat the resulting JSON looks like this:\r\n\r\n    {\r\n      \"MyCollection\": []\r\n    }\n\n### Steps To Reproduce\n\n_No response_\n\n### Exceptions (if any)\n\n_No response_\n\n### .NET Version\n\n7.0.100\n\n### Anything else?\n\nASP.net core 7\r\nVS 17.4.0",
    "number": 79033,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "EYES",
          "createdAt": "2023-06-24T19:24:54Z",
          "user": "lunatiqqc"
        },
        {
          "content": "EYES",
          "createdAt": "2024-05-07T13:01:31Z",
          "user": "paule96"
        }
      ],
      "totalCount": 2,
      "endCursor": "Y3Vyc29yOnYyOpHOC3u7pg=="
    },
    "updatedAt": "2023-08-12T09:10:52Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": "brunolins16",
          "body": "@andref15 thanks for contacting us.\r\n\r\n> that sends this exact object back and this null entry in the list causes some issues down the line\r\n\r\nI am not 100% sure what issues you are talking about, maybe if you can share your repro I can provide a more specific suggestion, however, I believe you might have been receiving `validation` issues, eg.:\r\n\r\n``` json\r\n\"errors\": {\r\n        \"Items[0].Items\": [\r\n            \"The Items field is required.\"\r\n        ]\r\n    }\r\n```\r\n\r\nIf that is the case, it is happening probably because your model does not accept nullable type and change it might workaround the issue you are facing, eg.:\r\n\r\n``` diff\r\npublic class MyItem\r\n{\r\n-    public MyItem[] Items { get; set; }\r\n+    public MyItem?[]? Items { get; set; }\r\n}\r\n```\r\n\r\n> IMO the serializer should skip the item entirely, if it's inside a collection, or at least provide some option to configure this behavior, sothat the resulting JSON looks like this:\r\n\r\nI believe add a `null` item is the expected behavior, you might have an option to use `ReferenceHandler.Preserve` instead. The\r\n@dotnet/area-system-text-json could probably provide you more information.\r\n",
          "createdAt": "2022-11-28T23:01:22Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-11-28T23:01:22Z",
          "id": "IC_kwDODI9FZc5PZYHn"
        },
        {
          "author": null,
          "body": "Hi @andref15. We have added the \"Needs: Author Feedback\" label to this issue, which indicates that we have an open question for you before we can take further action. This issue will be closed automatically in 7 days if we do not hear back from you by then - please feel free to re-open it if you come back to this issue after that time.",
          "createdAt": "2022-11-28T23:01:33Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-11-28T23:01:33Z",
          "id": "IC_kwDODI9FZc5PZYHw"
        },
        {
          "author": "andref15",
          "body": "Hi, thank you for your reply. \r\nI don't have any issues deserializing the object.\r\nThe Issue is that I have an Object with a Reference Cycle in a collection. When the API then serializes this object, the Collection in the json string contains null, which is what I would like to change.\r\nSadly I cannot use ReferenceHandler.Preserve because this seems to cause some problems in the Angular HttpClient. ",
          "createdAt": "2022-11-29T07:42:58Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-11-29T07:42:58Z",
          "id": "IC_kwDODI9FZc5PZYH1"
        },
        {
          "author": "brunolins16",
          "body": "\r\n\r\n\r\n> he Issue is that I have an Object with a Reference Cycle in a collection. When the API then serializes this object, the Collection in the json string contains null, which is what I would like to change.\r\n\r\nProbably @dotnet/area-system-text-json is the best group to help you.",
          "createdAt": "2022-11-29T19:28:03Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-11-29T19:28:17Z",
          "id": "IC_kwDODI9FZc5PZYH9"
        },
        {
          "author": "eiriktsarpalis",
          "body": "This behavior is by design, cyclical reference types will be replaced with a null literal in the JSON -- which also holds for collection elements.",
          "createdAt": "2022-11-29T19:58:09Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-11-29T19:58:09Z",
          "id": "IC_kwDODI9FZc5PZYIK"
        },
        {
          "author": "andref15",
          "body": "@eiriktsarpalis Is there any way to change this? A null entry in a collection can be pretty annoying, for example the EntityFramework throws an exception in that case. ",
          "createdAt": "2022-11-30T07:37:54Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-11-30T07:37:54Z",
          "id": "IC_kwDODI9FZc5PZYIQ"
        },
        {
          "author": "eiriktsarpalis",
          "body": "> Is there any way to change this? \r\n\r\nI don't believe there is -- generally speaking the library doesn't provide an option for skipping nulls (independent of reference handling).\r\n\r\n> A null entry in a collection can be pretty annoying\r\n\r\nIs it just collections? What about null properties in an object?\r\n\r\n> for example the EntityFramework throws an exception in that case.\r\n\r\nWhy would throwing be preferable in this case? Is avoiding cycles in your object graph feasible in your use case?",
          "createdAt": "2022-11-30T10:14:18Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-11-30T10:14:18Z",
          "id": "IC_kwDODI9FZc5PZYIY"
        },
        {
          "author": "andref15",
          "body": "> > Is there any way to change this?\r\n> \r\n> I don't believe there is -- generally speaking the library doesn't provide an option for skipping nulls (independent of reference handling).\r\n>\r\nOh, too bad.\r\n> \r\n> > A null entry in a collection can be pretty annoying\r\n> \r\n> Is it just collections? What about null properties in an object?\r\n> \r\nYes, it's just about collections. Null for properties is fine.\r\n>\r\n> > for example the EntityFramework throws an exception in that case.\r\n> \r\n> Why would throwing be preferable in this case? Is avoiding cycles in your object graph feasible in your use case?\r\n>\r\nSorry for the confusion, I don't mean that throwing an exception would be preferable, I mean one of the cases where null entries in a collection are problematic is when using the EntityFramework because this causes an exception to be thrown.\r\n\r\nAvoiding the object cycle might be an option for some of these cases, in others they are unavoidable, due to the way the API backend works...",
          "createdAt": "2022-11-30T10:25:05Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-11-30T10:26:21Z",
          "id": "IC_kwDODI9FZc5PZYIf"
        },
        {
          "author": "eiriktsarpalis",
          "body": "> > > A null entry in a collection can be pretty annoying\r\n> > \r\n> > \r\n> > Is it just collections? What about null properties in an object?\r\n> \r\n> Yes, it's just about collections. Null for properties is fine.\r\n\r\nI mean that's kind of arbitrary. Assuming we implemented a null skipping logic (like Json.NET does) it would skip all nulls, not just in collection elements.",
          "createdAt": "2022-11-30T10:36:16Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-11-30T10:36:16Z",
          "id": "IC_kwDODI9FZc5PZYIi"
        },
        {
          "author": "andref15",
          "body": "Well skipping all nulls would be fine as well, I would have expected the DefaultIgnoreCondition WhenWritingNull to include the object cycle handling.\r\nHowever I don't see what's so arbitrary about skipping null entries in a collection. I would appreciate if you could explain this a little further",
          "createdAt": "2022-11-30T10:51:56Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-11-30T10:51:56Z",
          "id": "IC_kwDODI9FZc5PZYIo"
        },
        {
          "author": "eiriktsarpalis",
          "body": "> Well skipping all nulls would be fine as well, I would have expected the DefaultIgnoreCondition WhenWritingNull to include the object cycle handling.\r\n\r\nThe [`DefaultIgnoreCondition` setting](https://learn.microsoft.com/en-us/dotnet/api/system.text.json.jsonserializeroptions.defaultignorecondition?view=net-7.0) only configures null skipping semantics for properties. I did a bit of digging and it seems that the configuration is honored by cycles found in properties: \r\n```C#\r\nusing System.Text.Json;\r\nusing System.Text.Json.Serialization;\r\n\r\nvar options = new JsonSerializerOptions \r\n{ \r\n    DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull, \r\n    ReferenceHandler = ReferenceHandler.IgnoreCycles \r\n};\r\n\r\nvar value = new Poco();\r\nvalue.NullProp = value;\r\nvalue.Collection = new object?[] { value };\r\n\r\nstring json = JsonSerializer.Serialize(value, options);\r\nConsole.WriteLine(json); // {\"Collection\":[null]}\r\n\r\npublic class Poco\r\n{\r\n    public object? NullProp { get; set; }\r\n    public object?[] Collection { get; set; }\r\n}\r\n```\r\nIMHO that's also kind of arbitrary (but in the inverted sense) however IIRC the rationale for doing that was that stripping nulls from arrays result in a change in the collection count -- arguably resulting in loss of information not directly related to nullity of individual elements.",
          "createdAt": "2022-11-30T11:09:17Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-11-30T11:09:17Z",
          "id": "IC_kwDODI9FZc5PZYIt"
        },
        {
          "author": "andref15",
          "body": "Hm, the change of the collection count is true, however I'm also not sure how useful the count is when the items in the array are unusable. IMO it would still be nice to have the option to choose between either of these behaviors",
          "createdAt": "2022-11-30T12:02:33Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-11-30T12:02:33Z",
          "id": "IC_kwDODI9FZc5PZYIw"
        },
        {
          "author": null,
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\n### Is there an existing issue for this?\n\n- [X] I have searched the existing issues\n\n### Describe the bug\n\nI have an ASP.net core Web API, that uses the standard system text json serializer and I configured the reference handling as IgnoreCycles.\r\nThe issue is that now when a Cycle is detected inside a collection, the resulting json looks like this:\r\n\r\n    {\r\n      \"MyCollection\": [\r\n        null\r\n       ]\r\n    }\r\n\r\nThis json is sent to an angular application, that sends this exact object back and this null entry in the list causes some issues down the line. I wasn't able to find any way to fix this (I tried setting the DefaultIgnoreCondition, hoping that it might also work in collections)\n\n### Expected Behavior\n\nIMO the serializer should skip the item entirely, if it's inside a collection, or at least provide some option to configure this behavior, sothat the resulting JSON looks like this:\r\n\r\n    {\r\n      \"MyCollection\": []\r\n    }\n\n### Steps To Reproduce\n\n_No response_\n\n### Exceptions (if any)\n\n_No response_\n\n### .NET Version\n\n7.0.100\n\n### Anything else?\n\nASP.net core 7\r\nVS 17.4.0\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>andref15</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`area-System.Text.Json`, `untriaged`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2022-11-30T12:10:22Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-11-30T12:10:22Z",
          "id": "IC_kwDODI9FZc5PZYLA"
        },
        {
          "author": "eiriktsarpalis",
          "body": "One possibility is extending `JsonSerializerOptions.DefaultIgnoreCondition` to collection elements, but that would be a possible breaking change. We need to compare what Json.NET is doing in this space, and if we do change it we would need to expose a `ShouldSerialize` predicate acting on collection elements in the contract model.",
          "createdAt": "2022-11-30T12:13:50Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-11-30T12:13:50Z",
          "id": "IC_kwDODI9FZc5PZZJV"
        },
        {
          "author": "iongion",
          "body": "Can you not add a new `ReferenceHandler.IgnoreCyclesSkipNull` and make it act like `Newtonsoft.Json` ?\r\n\r\nOther options\r\n\r\n> Keeping `ReferenceHandler.Preserve` but then - decyling client side libraries are lacking, one would expect some maturity here\r\n\r\n- Python\r\n- TS\r\n- Node\r\n- PHP\r\n- Ruby\r\n- R\r\n\r\nLacking a lot :(",
          "createdAt": "2023-08-12T09:10:52Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-08-12T09:10:52Z",
          "id": "IC_kwDODI9FZc5j4sHL"
        }
      ],
      "totalCount": 15,
      "endCursor": "Y3Vyc29yOnYyOpHOY-LByw=="
    },
    "url": "https://github.com/dotnet/runtime/issues/79033",
    "title": "Provide option to ignore null collection elements, not just null property values."
  },
  {
    "author": "terrajobst",
    "labels": [
      "api-approved",
      "area-System.Text.Json"
    ],
    "createdAt": "2022-11-30T20:52:36Z",
    "body": "**EDIT** See https://github.com/dotnet/runtime/issues/79059#issuecomment-1428662006 for API proposal.\r\n\r\n##\r\n\r\nIt seems there is currently no way to make JSON documents that reference a schema just deserializa.\r\n\r\n### Repro\r\n\r\n```json\r\n{\r\n    \"$schema\": \"http://example.org/myschema.json\",\r\n    \"Key1\": {\r\n        \"V1\": 10,\r\n        \"V2\": \"Ten\"\r\n    },\r\n    \"Key2\": {\r\n        \"V1\": 20,\r\n        \"V2\": \"Twenty\"\r\n    }\r\n}\r\n```\r\n\r\n```C#\r\nvar content = \"<json above>\";\r\nreturn JsonSerializer.Deserialize<Dictionary<string, CustomType>>(content);\r\n\r\nclass CustomType {\r\n    public int V1 { get; set; }\r\n    public string V2 { get; set; }\r\n}\r\n```\r\n\r\n### Expected Behavior\r\n\r\nIt just works. Or, based on `JsonSerializerOptions`, it could be configured to just work.\r\n\r\n### Actual Behavior\r\n\r\nIt causes an exception:\r\n\r\n> The JSON value could not be converted to CustomType. Path: $.$schema\r\n\r\nIn order to make it deserializable, the easiest option is to manually remove the schema node from the document:\r\n\r\n```C#\r\nif (JsonNode.Parse(content) is JsonObject jsonObject)\r\n{\r\n    if (jsonObject.Remove(\"$schema\"))\r\n        content = jsonObject.ToJsonString();\r\n}\r\n```\r\n\r\nThe more performant alternative would be to write a custom converter, but that seems like a lot of work. If the root type of the document weren't dictionary but a type I control, then presumably I could work this around by adding a property to my class and decorate it with `[JsonPropertyName(\"$schema\")]` but that feels equally hacky.\r\n\r\n### Customer Evidence\r\n\r\nIt’s not entirely clear to me if this is worth prioritizing. On the one hand, it seems a decent amount of our customers might use JSON schemas (based on this super scientific poll below).\r\n\r\nOn the other hand, it would only impact customers who use dictionaries as the document type. That combination might be quite rare and may not be be worth handling directly. And based on [James’s comments below](https://github.com/dotnet/runtime/issues/79059#issuecomment-1333163884), JSON.NET never handled that either. I suggest we leave it open for a bit and see what responses we get but my gut feel says cutting seems fine. \r\n\r\n[![A5B403CE-A45D-49BD-9861-9C3D65E3281F](https://user-images.githubusercontent.com/5169960/205173471-b334eaa9-b894-4f0d-aa15-c4e32cfd3a9b.jpeg)](https://twitter.com/terrajobst/status/1598060483927773184?s=46&t=Vtr5w2T7ukPN8Pa4WytK9w)\r\n",
    "number": 79059,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-11-30T21:08:20Z",
          "user": "stensones"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-11-30T21:14:13Z",
          "user": "jmezach"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-11-30T21:17:38Z",
          "user": "CamiloTerevinto"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-11-30T22:19:05Z",
          "user": "centreboard"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-12-02T18:01:47Z",
          "user": "svrooij"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-03-15T06:06:02Z",
          "user": "WeihanLi"
        }
      ],
      "totalCount": 6,
      "endCursor": "Y3Vyc29yOnYyOpHOC2i_aQ=="
    },
    "updatedAt": "2025-07-17T17:29:53Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\nIt seems there is currently no way to make JSON documents that reference a schema just deserializa.\r\n\r\n### Repro\r\n\r\n```json\r\n{\r\n    \"$schema\": \"http://example.org/myschema.json\",\r\n    \"Key1\": \"Value1\",\r\n    \"Key2\": \"Value2\"\r\n}\r\n```\r\n\r\n```C#\r\nvar content = \"<json above>\";\r\nreturn JsonSerializer.Deserialize<Dictionary<string, string>>(content);\r\n```\r\n\r\n### Expected Behavior\r\n\r\nIt just works. Or, based on `JsonSerializerOptions`, it could be configured to just work.\r\n\r\n### Actual Behavior\r\n\r\nIt causes an exception:\r\n\r\n> The JSON value could not be converted to System.String. Path: $.$schema\r\n\r\nIn order to make it deserializable, the easiest option is to manually remove the schema node from the document:\r\n\r\n```C#\r\nif (JsonNode.Parse(content) is JsonObject jsonObject)\r\n{\r\n    if (jsonObject.Remove(\"$schema\"))\r\n        content = jsonObject.ToJsonString();\r\n}\r\n```\r\n\r\nThe more performant alternative would be to write a custom converter, but that seems like a lot of work. If the root type of the document weren't dictionary but a type I control, then presumably I could work this around by adding a property to my class and decorate it with `[JsonPropertyName(\"$schema\")]` but that feels equally hacky.\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>terrajobst</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`area-System.Text.Json`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2022-11-30T20:52:43Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-11-30T20:52:43Z",
          "id": "IC_kwDODI9FZc5Pb7no"
        },
        {
          "author": "layomia",
          "body": "It seems reasonable to enable this scenario if we have substantial user asks for it. Feels like \"future\" for now wrt urgency.\r\n\r\nI wonder if this problem is scoped to JSON schema support or whether a general solution is needed i.e a feature to express that a set of property names should be omitted from (de)serialization. I assume this would be scoped to just dictionaries since we already have that for POCO properties (`[JsonIgnore]` and related features).",
          "createdAt": "2022-11-30T22:18:29Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-12-01T22:45:58Z",
                "user": "terrajobst"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOCwi93A=="
          },
          "updatedAt": "2022-11-30T22:18:29Z",
          "id": "IC_kwDODI9FZc5PcPql"
        },
        {
          "author": "gregsdennis",
          "body": "This isn't a JSON Schema problem (at least not properly).  JSON Schema puts no requirements on JSON data.\n\nIncluding `$schema` in an instance is a convention that some tools, like VS Code, uses to identify how to validate the data.\n\n`$schema` inside of a JSON Schema carries additional and specific meaning.",
          "createdAt": "2022-12-01T02:17:22Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-12-01T02:17:22Z",
          "id": "IC_kwDODI9FZc5PdOuq"
        },
        {
          "author": "ShreyasJejurkar",
          "body": "@terrajobst did you gave try with @JamesNK Newtonsoft one? Does it work there? ",
          "createdAt": "2022-12-01T04:36:28Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-12-01T04:36:28Z",
          "id": "IC_kwDODI9FZc5PdmZB"
        },
        {
          "author": "JamesNK",
          "body": "Newtonsoft.Json errors:\r\n\r\n> Newtonsoft.Json.JsonSerializationException: 'Error converting value \"http://example.org/myschema.json\" to type 'CustomType'. Path '$schema', line 2, position 49.'\r\n\r\nI'd recommend people load the JSON into a JObject and remove the `$schema` property and then deserialize it.",
          "createdAt": "2022-12-01T04:43:40Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-12-01T22:45:21Z",
                "user": "terrajobst"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOCwi9xg=="
          },
          "updatedAt": "2022-12-01T04:45:23Z",
          "id": "IC_kwDODI9FZc5Pdnds"
        },
        {
          "author": "gregsdennis",
          "body": "The System.Text.Json analog for that is `JsonNode`.  @terrajobst has the proper workaround in the opening comment.",
          "createdAt": "2022-12-01T06:05:48Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2022-12-01T22:45:24Z",
                "user": "terrajobst"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOCwi9yA=="
          },
          "updatedAt": "2022-12-01T06:05:48Z",
          "id": "IC_kwDODI9FZc5Pd-gX"
        },
        {
          "author": "eiriktsarpalis",
          "body": "A few observations:\r\n\r\n* POCO deserialization will generally skip any properties it fails to bind to so this shouldn't be an issue in that case. The same is true for non-generic dictionaries or `IDictionary<string, object>`, whose deserialization semantics closely follow those of `JsonObject`.\r\n* This issue only concerns generic dictionary deserialization, and the fact that all values in the deserialized JSON object must conform to whatever contract `TValue` imposes in `IDictionary<TKey, TValue>`. Assuming we get union types eventually (where something like `Dictionary<string, string | CustomType>` becomes expressible) it would be possible to work around the issue using appropriate modelling.\r\n* Assuming this is a request for JSON Schema support, this is being tracked in https://github.com/dotnet/runtime/issues/29887.\r\n* Assuming it is a request for property deny lists for dictionary deserialization in general, it might be something we could consider. I don't believe it is possible to work around the issue currently using `JsonIgnoreAttribute` or `JsonPropertyName` attributes since dictionaries don't use them.",
          "createdAt": "2022-12-01T10:53:38Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "HEART",
                "createdAt": "2022-12-01T22:45:32Z",
                "user": "terrajobst"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOCwi9zA=="
          },
          "updatedAt": "2022-12-01T10:53:38Z",
          "id": "IC_kwDODI9FZc5PfMI3"
        },
        {
          "author": "terrajobst",
          "body": "I added a customer evidence section with my thoughts. ",
          "createdAt": "2022-12-01T22:41:09Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-12-01T22:41:09Z",
          "id": "IC_kwDODI9FZc5Pi3Dm"
        },
        {
          "author": "terrajobst",
          "body": "@eiriktsarpalis \r\n\r\n> * Assuming this is a request for JSON Schema support\r\n\r\nThat’s a good point. I didn’t call it out explicitly but that wasn’t my intent. Rather, I think we could decide to never support JSON schemas (ie offer validation or an OM for reading one) while still making this scenario possible by simply ignoring the well-known property name during  The deserialization. So in that sense, I think of them of as orthogonal issues.",
          "createdAt": "2022-12-01T22:43:29Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-12-01T22:43:55Z",
          "id": "IC_kwDODI9FZc5Pi3dW"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Would we need to ignore other well-known metadata property names like `$type` or `$id`? There are dozens of schemes like that out there, I suspect we might want to expose it as deny list so that users can cherry-pick what they need to be skipped.",
          "createdAt": "2022-12-02T16:23:38Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-12-02T16:23:38Z",
          "id": "IC_kwDODI9FZc5Pmhtd"
        },
        {
          "author": "gregsdennis",
          "body": "This sounds like a slippery slope.",
          "createdAt": "2022-12-02T19:04:39Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-12-02T19:04:39Z",
          "id": "IC_kwDODI9FZc5PnP_M"
        },
        {
          "author": "terrajobst",
          "body": "I think one way to expose this would be like that:\r\n\r\n```C#\r\nnamespace System.Text.Json;\r\n\r\npublic sealed class JsonSerializerOptions\r\n{\r\n    public JsonDictionaryKeyFilter DictionaryKeyFilter { get; set; }\r\n}\r\n\r\npublic enum JsonDictionaryKeyFilter\r\n{\r\n    None,\r\n    IgnoreMetadataNames // Ignores any keys starting with $, such as `$schema`.\r\n}\r\n```\r\n\r\nOne could make this slightly more flexible by borrowing from the design of strongly typed strings and create an enum-like wrapper around a func, which offers some simple well-known versions:\r\n\r\n```C#\r\npublic readonly struct JsonDictionaryKeyFilter\r\n{\r\n    public static JsonDictionaryKeyFilter None { get; }\r\n    public static JsonDictionaryKeyFilter IgnoreMetadataNames { get; }\r\n    \r\n    public JsonDictionaryKeyFilter(Func<string, bool> filter);\r\n    public bool Include(string name);\r\n}\r\n```\r\n\r\nIn either design, the default would be `JsonDictionaryKeyFilter.None`.",
          "createdAt": "2022-12-02T20:58:34Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-12-02T21:04:06Z",
          "id": "IC_kwDODI9FZc5Pn0vB"
        },
        {
          "author": "eiriktsarpalis",
          "body": "I think the predicate approach works. I would prefer if we could avoid the wrapper type and just use `Func<string, bool>` or perhaps just use a dedicated delegate type. There also needs to be a configuration point on JsonTypeInfo.",
          "createdAt": "2022-12-03T08:22:08Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-12-03T08:22:08Z",
          "id": "IC_kwDODI9FZc5Po3S5"
        },
        {
          "author": "gregsdennis",
          "body": "Why does everyone keep using `Func<string, bool>` when `Predicate<string>` exists?!  I see it a lot.\n\nAnyway... Carry on.",
          "createdAt": "2022-12-03T17:36:32Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-12-03T17:36:32Z",
          "id": "IC_kwDODI9FZc5PpN0G"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Predicate predates Func and its use is largely restricted to Linq and a few generic collection methods. I don't believe we use it in any new APIs.",
          "createdAt": "2022-12-03T21:12:43Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-12-03T21:12:43Z",
          "id": "IC_kwDODI9FZc5PpbHR"
        },
        {
          "author": "gregsdennis",
          "body": "I know it's older, which is why I'm confused that it's not used more.\n\nI don't mean to derail the conversation though.  Carry on.",
          "createdAt": "2022-12-03T22:49:12Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-12-03T22:49:12Z",
          "id": "IC_kwDODI9FZc5PpeeK"
        },
        {
          "author": "eiriktsarpalis",
          "body": "> Would we need to ignore other well-known metadata property names like `$type` or `$id`? There are dozens of schemes like that out there, I suspect we might want to expose it as deny list so that users can cherry-pick what they need to be skipped.\r\n\r\n#82012 seems to support the fact we need to ignore arbitrary property names.",
          "createdAt": "2023-02-13T16:39:22Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-02-13T16:39:22Z",
          "id": "IC_kwDODI9FZc5VIY1F"
        },
        {
          "author": "eiriktsarpalis",
          "body": "We might want to use a design similar to `JsonNamingPolicy`:\r\n```C#\r\nnamespace System.Text.Json.Serialization;\r\n\r\npublic abstract class JsonDictionaryKeyFilter\r\n{\r\n    public static JsonDictionaryKeyFilter IgnoreMetadataNames { get; }\r\n\r\n    public abstract bool IgnoreKey(ReadOnlySpan<byte> utf8Key);\r\n}\r\n\r\nnamespace System.Text.Json;\r\n\r\npublic partial class JsonSerializerOptions\r\n{\r\n    public JsonDictionaryKeyFilter? DictionaryKeyFilter { get; set; } = null;\r\n}\r\n```",
          "createdAt": "2023-02-13T20:49:15Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-02-13T20:49:15Z",
          "id": "IC_kwDODI9FZc5VJ6b2"
        },
        {
          "author": "Sergio0694",
          "body": "Would it make sense to also have an attribute that would allow people to opt-in into this over arbitrary properties and with arbitrary values, rather than only at the options level? Somewhat related, if this can only be set from the options would this mean that if you need this you'd be unable to use the generated `Default` property from a JSON context, unless you manually set this property at some point before using it? Additionally, if you have multiple accessors for options from a given context (eg. we have a couple, one is the default one and one is for camel case naming policy), would this mean you'd have to remember to set this for each of those contexts before using them? 🤔",
          "createdAt": "2023-02-14T20:16:52Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-02-14T20:16:52Z",
          "id": "IC_kwDODI9FZc5VQPcK"
        },
        {
          "author": "gregsdennis",
          "body": "Please be aware that in JsonSchema.Net, I use the STJ serializer to deserialize actual schemas, for which the `$schema`, `$id`, and other properties _are_ considered and deserialized, not ignored.\n\nIf something is done here, please make the new behavior opt-in.",
          "createdAt": "2023-02-15T04:40:55Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-03-14T07:55:23Z",
                "user": "mwadams"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHODahk-w=="
          },
          "updatedAt": "2023-02-15T04:41:07Z",
          "id": "IC_kwDODI9FZc5VR3eo"
        },
        {
          "author": "eiriktsarpalis",
          "body": "> If something is done here, please make the new behavior opt-in.\r\n\r\nThat goes without saying. Making it the default behavior would be a breaking change.",
          "createdAt": "2023-02-15T08:26:27Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-02-15T10:05:04Z",
                "user": "gregsdennis"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOC2Gd_Q=="
          },
          "updatedAt": "2023-02-15T08:26:27Z",
          "id": "IC_kwDODI9FZc5VSki1"
        },
        {
          "author": "krwq",
          "body": "IMO that should be something that lives on JsonTypeInfo rather than global. Also we should think of cases like `Dictionary<string, Dictionary<string, string>>` when designing this. Possibly we could expose ElementTypeInfo/KeyTypeInfo to solve that problem (that needs a proper design though to not get us into recursive types hell).",
          "createdAt": "2023-02-15T09:16:06Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-02-15T09:16:27Z",
          "id": "IC_kwDODI9FZc5VSztp"
        },
        {
          "author": "eiriktsarpalis",
          "body": "> Would it make sense to also have an attribute\r\n\r\nIt wouldn't be possible to specify a filter value on the attribute level unless we either exposed a proxy enum type or the type of the `IgnoreMetadataNames` class. We don't do this for things like `DictionaryKeyPolicy`, which can only be configured globally.\r\n\r\n> Somewhat related, if this can only be set from the options would this mean that if you need this you'd be unable to use the generated Default property from a JSON context\r\n\r\nThat's right, although this added step should have no impact on serialization performance. We might want to consider exposing a parameter in `JsonSourceGenerationOptionsAttribute` eventually, but I wouldn't consider this a high enough priority, there's a big functionality gap between that attribute and `JsonSerializerOptions` already (including lack of options for the existing `DictionaryKeyPolicy`).\r\n\r\n> IMO that should be something that lives on JsonTypeInfo rather than global. \r\n\r\nI'm not too sure. This feature dovetails with reference handling which is also configured globally. I don't see why _couldn't_ expose this in `JsonTypeInfo` but bare minimum it should validate that no reference handling or polymorphism have been configured for the type. I would suggest keeping it simple for now and consider bringing it to `JsonTypeInfo` together with `DictionaryKeyPolicy` provided there is demand for that.",
          "createdAt": "2023-02-15T12:32:31Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-02-15T12:32:31Z",
          "id": "IC_kwDODI9FZc5VT-AA"
        },
        {
          "author": "terrajobst",
          "body": "[Video](https://www.youtube.com/watch?v=hyyNUh4s3Qo&t=0h28m55s)\n\n* It seems odd that we'd use UTF8 in this API, given that `JsonNamingPolicy` doesn't\r\n    - Since this is an opt-in policy we're OK with allocating for cases where the keys aren't strings\r\n* We should name the method `ShouldIgnoreKey`\r\n* We will apply this policy before `DictionaryKeyPolicy` and we will run it for both string and non-string key types.\r\n\r\n```C#\r\nnamespace System.Text.Json.Serialization;\r\n\r\npublic abstract class JsonDictionaryKeyFilter\r\n{\r\n    public static JsonDictionaryKeyFilter IgnoreMetadataNames { get; }\r\n    public abstract bool ShouldIgnoreKey(string key);\r\n}\r\n```\r\n\r\n```C#\r\nnamespace System.Text.Json;\r\n\r\npublic partial class JsonSerializerOptions\r\n{\r\n    public JsonDictionaryKeyFilter? DictionaryKeyFilter { get; set; } = null;\r\n}\r\n```",
          "createdAt": "2023-03-21T18:06:49Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-03-21T18:55:35Z",
          "id": "IC_kwDODI9FZc5YHhHC"
        },
        {
          "author": "Sergio0694",
          "body": "I missed the API review, small question on this API:\r\n\r\n```csharp\r\npublic abstract bool ShouldIgnoreKey(string key);\r\n```\r\n\r\nEven though we don't care about UTF8, is there any benefit in not making that at least `ReadOnlySpan<char>`? 🤔",
          "createdAt": "2023-03-21T18:10:11Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-03-21T19:15:38Z",
                "user": "krwq"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOC4Q-GA=="
          },
          "updatedAt": "2023-03-21T18:10:11Z",
          "id": "IC_kwDODI9FZc5YHiXY"
        },
        {
          "author": "krwq",
          "body": "@terrajobst presumably this doesn't apply for dictionary for extension data properties?",
          "createdAt": "2023-03-21T19:15:53Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-03-21T19:15:53Z",
          "id": "IC_kwDODI9FZc5YH2Rt"
        },
        {
          "author": "eiriktsarpalis",
          "body": "@krwq It shouldn't. These are always `Dictionary<string, object>` or similar so it's one size fits all.",
          "createdAt": "2023-03-21T20:35:43Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-03-21T20:35:53Z",
          "id": "IC_kwDODI9FZc5YINMl"
        },
        {
          "author": "AlexRadch",
          "body": "Can anybody help me with PR https://github.com/dotnet/runtime/pull/87868 ?",
          "createdAt": "2023-06-22T22:18:08Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-06-22T22:18:08Z",
          "id": "IC_kwDODI9FZc5fkbAf"
        },
        {
          "author": "eiriktsarpalis",
          "body": "@AlexRadch currently going through a backlog of other things, will get to yours eventually. Thanks!",
          "createdAt": "2023-06-23T14:36:14Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-06-23T14:36:14Z",
          "id": "IC_kwDODI9FZc5foNCT"
        },
        {
          "author": "koyote",
          "body": "I know this issue had the title changed to be Dictionary specific, but I feel like there's a related issue for non-dictionaries:\r\n\r\n```cs\r\n[JsonDerivedType(typeof(DerivedType), typeDiscriminator: nameof(DerivedType))]\r\npublic abstract class BaseType\r\n{\r\n}\r\n\r\npublic sealed class DerivedType : BaseType\r\n{\r\n}\r\n\r\ninternal class Program\r\n{\r\n    static void Main()\r\n    {\r\n        var text =\r\n        \"\"\"\r\n        {\r\n            \"$type\": \"DerivedType\",\r\n            \"$schema\": \"http://example.org/myschema.json\",\r\n        }\r\n        \"\"\";\r\n        var baseObj = JsonSerializer.Deserialize<BaseType>(text);\r\n    }\r\n}\r\n```\r\n\r\nThe above results in:\r\n```\r\nSystem.Text.Json.JsonException: Properties that start with '$' are not allowed in types that support metadata. Either escape the character or disable reference preservation and polymorphic deserialization. Path: $.$schema | LineNumber: 2 | BytePositionInLine: 14.\r\n   at System.Text.Json.ThrowHelper.ThrowJsonException(String message)\r\n   at System.Text.Json.ThrowHelper.ThrowJsonException_MetadataInvalidPropertyWithLeadingDollarSign(ReadOnlySpan`1 propertyName, ReadStack& state, Utf8JsonReader& reader)\r\n   at System.Text.Json.Serialization.Converters.ObjectDefaultConverter`1.OnTryRead(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options, ReadStack& state, T& value)\r\n   at System.Text.Json.Serialization.JsonConverter`1.OnTryReadAsObject(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options, ReadStack& state, Object& value)\r\n   at System.Text.Json.Serialization.Converters.ObjectDefaultConverter`1.OnTryRead(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options, ReadStack& state, T& value)\r\n   at System.Text.Json.Serialization.JsonConverter`1.TryRead(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options, ReadStack& state, T& value, Boolean& isPopulatedValue)\r\n   at System.Text.Json.Serialization.JsonConverter`1.ReadCore(Utf8JsonReader& reader, JsonSerializerOptions options, ReadStack& state)\r\n   at System.Text.Json.JsonSerializer.ReadFromSpan[TValue](ReadOnlySpan`1 utf8Json, JsonTypeInfo`1 jsonTypeInfo, Nullable`1 actualByteCount)\r\n   at System.Text.Json.JsonSerializer.ReadFromSpan[TValue](ReadOnlySpan`1 json, JsonTypeInfo`1 jsonTypeInfo)\r\n   at System.Text.Json.JsonSerializer.Deserialize[TValue](String json, JsonSerializerOptions options)\r\n```\r\n\r\nI am not sure what a good workaround would be as adding a `[JsonProperty(\"$schema\")]` attribute to a property on either class won't help here.\r\n\r\nShould any fix for the Dictionary case also take the above case into account or is this a separate issue that needs its own issue number?",
          "createdAt": "2024-03-13T21:47:04Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-04-02T15:00:59Z",
                "user": "S-Luiten"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOEMknMg=="
          },
          "updatedAt": "2024-03-13T21:47:04Z",
          "id": "IC_kwDODI9FZc5291GK"
        },
        {
          "author": "terrajobst",
          "body": "> Should any fix for the Dictionary case also take the above case into account or is this a separate issue that needs its own issue number?\r\n\r\nThat's a fair question. Originally, I scoped it to dictionaries because it's a built-in type that the user can't easily change the serialization behavior for, but I guess for custom objects a generic way to turn this off would be desirable as well, even though other workarounds exist.",
          "createdAt": "2024-03-15T05:03:25Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-03-15T05:03:25Z",
          "id": "IC_kwDODI9FZc53JWhM"
        },
        {
          "author": "S-Luiten",
          "body": "> I know this issue had the title changed to be Dictionary specific, but I feel like there's a related issue for non-dictionaries:\n\nI have the same issue, is seems like `$schema` and `$type` cannot be combined because `$schema` is not recognized as a metadata property. As a workaround I've been using `$schema` as the type discriminator property name, but this has its own set of issues so I'd like to see this fixed and be able to split it back into separate `$schema` and `$type` properties.",
          "createdAt": "2025-04-02T15:07:12Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-04-02T15:07:12Z",
          "id": "IC_kwDODI9FZc6lRwV3"
        }
      ],
      "totalCount": 32,
      "endCursor": "Y3Vyc29yOnYyOpHOpUcFdw=="
    },
    "url": "https://github.com/dotnet/runtime/issues/79059",
    "title": "Support filtering property names on dictionary deserialization."
  },
  {
    "author": "queequac",
    "labels": [
      "enhancement",
      "area-System.Text.Json"
    ],
    "createdAt": "2022-12-09T14:33:24Z",
    "body": "### Is there an existing issue for this?\n\n- [X] I have searched the existing issues\n\n### Describe the bug\n\nMy json documents contain fields with leading $-character. In general this is no issue, I can add a [JsonProperty(\"$something\")] to the property and it's serialized correctly.\r\n\r\nIn some cases I need polymorphism. In this case the minimal API is breaking.\r\nWhile the new JsonPolymorphic feature works as expected by defining some discriminator (which can have a leading $), here any further property using a leading $-character cannot be used.\r\n\r\nSample:\r\n\r\n```\r\n\r\n    public class Root\r\n    {\r\n        [JsonPropertyName(\"$more\")]\r\n        public Base More { get; set; }\r\n    }\r\n\r\n    [JsonPolymorphic]\r\n    [JsonDerivedType(typeof(A), \"a\")]\r\n    [JsonDerivedType(typeof(B), \"b\")]\r\n    public class Base {  }\r\n\r\n    public class A : Base\r\n    {\r\n        [JsonPropertyName(\"$dollar\")]\r\n        public string Dollar { get; set; }\r\n    }\r\n\r\n    public class B : Base\r\n    {\r\n        [JsonPropertyName(\"cents\")]\r\n        public string Dollar { get; set; }\r\n    }\r\n```\r\n\r\nI am using the following minimal API:\r\n```\r\n    app.MapPost(\"/root\", (HttpContext context, [FromBody] Root content) =>\r\n    {\r\n       // Do something.\r\n    }).WithName(\"PostReferences\").WithTags(\"Anchor Core Service\");\r\n```\r\n\r\nDeserializing the following works fine:\r\n`{ \"$more\": { \"$type\": \"b\", \"cents\": \"foo\" }`\r\n\r\nBut this does not:\r\n`{ \"$more\": { \"$type\": \"a\", \"$dollar\": \"foo\" }`\r\nHere the delegate is not even called, but the endpoint returns error 500.\r\n\r\nWhenever a property with a leading dollar sign is passed within the polymorophic class, it breaks. On the non polymorphic it is no problem (see Root)\r\n\r\nThis seems to be related to the fact that dollars are interpreted as metadata and polymorphism is using metadata for the discriminator... I found some `JsonSerializerSettings `that would allow to mess arround with `MetadataPropertyHandling`, but seems that's nothing I can set for Minimal API in .NET 7.\r\n\r\nAny suggestions how I could still deserialize the document I get passed with dollars in this case?\n\n### Expected Behavior\n\nDeserializing should allow dollar signs on polymorphic classes just like on non polymorphic ones.\n\n### Steps To Reproduce\n\n_No response_\n\n### Exceptions (if any)\n\nThe minimal API returns error code 500 with the following message:\r\n\r\n`Internal error. System error or malformed request. (Failed to read parameter \"Root content\" from the request body as JSON.)`\n\n### .NET Version\n\n7\n\n### Anything else?\n\n_No response_",
    "number": 79482,
    "reactions": {
      "hasNextPage": false,
      "nodes": [],
      "totalCount": 0,
      "endCursor": null
    },
    "updatedAt": "2024-08-05T15:28:42Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": "queequac",
          "body": "Seems to be related to System.Text.Json:\r\n`System.Text.Json.JsonException: Properties that start with '$' are not allowed in types that support metadata. Either escape the character or disable reference preservation and polymorphic deserialization.`\r\n\r\nTurning off polymorphism is not an option, since I cannot solve my issue then... and in case of escaping I am not sure what is meant, but most likely I don't have the dollar then anymore.",
          "createdAt": "2022-12-09T20:28:43Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-12-09T20:28:43Z",
          "id": "IC_kwDODI9FZc5QLQEX"
        },
        {
          "author": null,
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\n### Is there an existing issue for this?\n\n- [X] I have searched the existing issues\n\n### Describe the bug\n\nMy json documents contain fields with leading $-character. In general this is no issue, I can add a [JsonProperty(\"$something\")] to the property and it's serialized correctly.\r\n\r\nIn some cases I need polymorphism. In this case the minimal API is breaking.\r\nWhile the new JsonPolymorphic feature works as expected by defining some discriminator (which can have a leading $), here any further property using a leading $-character cannot be used.\r\n\r\nSample:\r\n\r\n```\r\n\r\n    public class Root\r\n    {\r\n        [JsonPropertyName(\"$more\")]\r\n        public Base More { get; set; }\r\n    }\r\n\r\n    [JsonPolymorphic]\r\n    [JsonDerivedType(typeof(A), \"a\")]\r\n    [JsonDerivedType(typeof(B), \"b\")]\r\n    public class Base {  }\r\n\r\n    public class A : Base\r\n    {\r\n        [JsonPropertyName(\"$dollar\")]\r\n        public string Dollar { get; set; }\r\n    }\r\n\r\n    public class B : Base\r\n    {\r\n        [JsonPropertyName(\"cents\")]\r\n        public string Dollar { get; set; }\r\n    }\r\n```\r\n\r\nI am using the following minimal API:\r\n```\r\n    app.MapPost(\"/root\", (HttpContext context, [FromBody] Root content) =>\r\n    {\r\n       // Do something.\r\n    }).WithName(\"PostReferences\").WithTags(\"Anchor Core Service\");\r\n```\r\n\r\nDeserializing the following works fine:\r\n`{ \"$more\": { \"$type\": \"b\", \"cents\": \"foo\" }`\r\n\r\nBut this does not:\r\n`{ \"$more\": { \"$type\": \"a\", \"$dollar\": \"foo\" }`\r\nHere the delegate is not even called, but the endpoint returns error 500.\r\n\r\nWhenever a property with a leading dollar sign is passed within the polymorophic class, it breaks. On the non polymorphic it is no problem (see Root)\r\n\r\nThis seems to be related to the fact that dollars are interpreted as metadata and polymorphism is using metadata for the discriminator... I found some `JsonSerializerSettings `that would allow to mess arround with `MetadataPropertyHandling`, but seems that's nothing I can set for Minimal API in .NET 7.\r\n\r\nAny suggestions how I could still deserialize the document I get passed with dollars in this case?\n\n### Expected Behavior\n\nDeserializing should allow dollar signs on polymorphic classes just like on non polymorphic ones.\n\n### Steps To Reproduce\n\n_No response_\n\n### Exceptions (if any)\n\nThe minimal API returns error code 500 with the following message:\r\n\r\n`Internal error. System error or malformed request. (Failed to read parameter \"Root content\" from the request body as JSON.)`\n\n### .NET Version\n\n7\n\n### Anything else?\n\n_No response_\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>queequac</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`area-System.Text.Json`, `investigate`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2022-12-10T04:35:16Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-12-10T04:35:16Z",
          "id": "IC_kwDODI9FZc5QLQGk"
        },
        {
          "author": "gregsdennis",
          "body": "Might be a more general case of https://github.com/dotnet/runtime/issues/79059",
          "createdAt": "2022-12-10T04:38:15Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-12-10T04:38:15Z",
          "id": "IC_kwDODI9FZc5QLQ9j"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Yes, this is a by-design restriction of the STJ metadata reader. Further investigation is needed to determine the original motivations and whether they are still valid, but we should definitely look at relaxing this in the future.",
          "createdAt": "2022-12-12T12:20:03Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-12-12T12:20:03Z",
          "id": "IC_kwDODI9FZc5QQD4m"
        },
        {
          "author": "ckpearson",
          "body": "Just ran into this issue myself, we're using `JsonPolymorphic` which by-default uses `$type` as the discriminator property, but also built an auto-versioning layer on top where a `$version` property also gets inserted; thankfully still at a stage during development where the version property can be renamed, but I don't recall there being a warning about this behaviour in the documentation about polymorphic JSON.",
          "createdAt": "2024-08-05T15:28:40Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "EYES",
                "createdAt": "2025-02-19T04:58:40Z",
                "user": "seanmcelroy"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOEG0_hg=="
          },
          "updatedAt": "2024-08-05T15:28:40Z",
          "id": "IC_kwDODI9FZc6HQ348"
        }
      ],
      "totalCount": 5,
      "endCursor": "Y3Vyc29yOnYyOpHOh0N-PA=="
    },
    "url": "https://github.com/dotnet/runtime/issues/79482",
    "title": "Cannot use Properties with $-character when reading System.Text.Json metadata."
  },
  {
    "author": "NinoFloris",
    "labels": [
      "api-suggestion",
      "area-System.Text.Json"
    ],
    "createdAt": "2022-12-13T20:51:28Z",
    "body": "### Background and motivation\r\n\r\nIt seems there is no way to let STJ handle naming convention mappings for any of the STJ DOM types. \r\n\r\nFor JsonElement this makes sense as the raw json is written out. For JsonNode however, which will be fully traversed by the serializer not having any tools for this is not such a welcoming status quo.\r\n\r\nI fully understand why JsonObject is not affected by PropertyNamingPolicy, each JsonObject field is not an actual property of JsonObject after all.\r\nI can also understand that even though a JsonObject is like a dictionary it should not be affected by DictionaryKeyPolicy. \r\n\r\nWhat I don't fully understand is the absense of any support in the serializer for this scenario. Should I write a custom traverse, recursively transform and mutate the field names to then pass it into the serializer for another traverse? Do we really want to penalize dynamic object shapes that much?\r\n\r\n### API Proposal\r\n\r\n```csharp\r\nnamespace System.Text.Json;\r\n\r\npublic class JsonSerializerOptions\r\n{\r\n    public JsonNamingPolicy JsonObjectKeyPolicy { get; set; }\r\n}\r\n```\r\n\r\n\r\n### API Usage\r\n\r\n```csharp\r\nvar jsonNode = JsonSerializer.Deserialize<JsonNode>(\"\"\"{\"Test\": 1}\"\"\");\r\n\r\nvar str = obj.ToJsonString(new JsonSerializerOptions { JsonObjectKeyPolicy = JsonNamingPolicy.CamelCase }) \r\nConsole.WriteLine(\"Expect true: \" + (str == \"\"\"{\"test\": 1}\"\"\"));\r\n```\r\n\r\n\r\n### Alternative Designs\r\n\r\nInstead of a new property an alternative is to allow DictionaryKeyPolicy to affect JsonObjects\r\n\r\n### Risks\r\n\r\nSlight perf regression as a check for the existence of a policy instance will be added.",
    "number": 79624,
    "reactions": {
      "hasNextPage": false,
      "nodes": [],
      "totalCount": 0,
      "endCursor": null
    },
    "updatedAt": "2022-12-14T14:17:49Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\n### Background and motivation\n\nIt seems there is no way to let STJ handle naming convention mappings for any of the STJ DOM types. \r\n\r\nFor JsonElement this makes sense as the raw json is written out. For JsonNode however, which will be fully traversed by the serializer not having any tools for this is not such a welcoming status quo.\r\n\r\nI fully understand why JsonObject is not affected by PropertyNamingPolicy, each JsonObject field is not an actual property of JsonObject after all.\r\nI can also understand that even though a JsonObject is like a dictionary it should not be affected by DictionaryKeyPolicy. \r\n\r\nWhat I don't fully understand is the absense of any support in the serializer for this scenario. Should I write a custom traverse, tranform the field names to then pass it into the serializer for another traverse? Do we really want to penalize dynamic object shapes that much?\n\n### API Proposal\n\n```csharp\r\nnamespace System.Text.Json;\r\n\r\npublic class JsonSerializerOptions\r\n{\r\n    public JsonNamingPolicy JsonObjectKeyPolicy { get; set; }\r\n}\r\n```\r\n\n\n### API Usage\n\n```csharp\r\nvar jsonNode = JsonSerializer.Deserialize<JsonNode>(\"\"\"{\"Test\": 1}\"\"\");\r\n\r\nvar str = obj.ToJsonString(new JsonSerializerOptions { JsonObjectKeyPolicy = JsonNamingPolicy.CamelCase }) \r\nConsole.WriteLine(\"Expect true: \" + (str == \"\"\"{\"test\": 1}\"\"\"));\r\n```\r\n\n\n### Alternative Designs\n\nInstead of a new property an alternative is to allow DictionaryKeyPolicy to affect JsonObjects\n\n### Risks\n\nSlight perf regression as a check for the existence of a policy instance will be added.\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>NinoFloris</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`api-suggestion`, `area-System.Text.Json`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2022-12-13T20:51:36Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-12-13T20:51:36Z",
          "id": "IC_kwDODI9FZc5QcmIW"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Shouldn't this live in [`JsonNodeOptions`](https://docs.microsoft.com/en-us/dotnet/api/system.text.json.nodes.jsonnodeoptions?view=net-7.0) instead?",
          "createdAt": "2022-12-14T13:14:56Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-12-14T13:14:56Z",
          "id": "IC_kwDODI9FZc5Qi7xL"
        }
      ],
      "totalCount": 2,
      "endCursor": "Y3Vyc29yOnYyOpHOUIu8Sw=="
    },
    "url": "https://github.com/dotnet/runtime/issues/79624",
    "title": "[API Proposal]: JsonSerializerOptions.JsonObjectKeyPolicy (naming policy)"
  },
  {
    "author": "magyarandras",
    "labels": [
      "api-suggestion",
      "area-System.Text.Json"
    ],
    "createdAt": "2022-12-16T14:13:21Z",
    "body": "### Background and motivation\n\nCurrently, the path information (Path, LineNumber, BytePositionInLine) is only appended to the error message when no custom error message is provided in the constructor of JsonException. However, when a custom message is set, there is no \"straightforward way\" to add it optionally. If someone throws a JsonException from the Read method of a custom JsonConverter, this information isn't available on the Utf8JsonReader.\r\n\r\nAs a workaround, it is possible to catch the exception at a \"higher level\" and add that information, but I think there should be an easier way to handle this. Furthermore, in this case, the author of a custom JsonConverter has to rely on someone to catch the exception and append or insert the path information later.\r\n\r\nA public property could be used to specify whether the path information should be inserted into the custom error message using a format string. This way the path information would be both optional (sometimes it may not be wanted in the custom error message) and flexible.\n\n### API Proposal\n\n```csharp\r\npublic class JsonException : Exception\r\n{\r\n    /// <summary>\r\n    /// Specifies that 'try' logic should insert Path information to the exception message using a format string.\r\n    /// </summary>\r\n    public bool InsertPathInformation { get; init; }\r\n}\r\n```\r\nFor more information see my implementation: [https://github.com/magyarandras/runtime/commit/f56f9c4a5cf807e4bacdcc1ea2e0327473457d49](https://github.com/magyarandras/runtime/commit/f56f9c4a5cf807e4bacdcc1ea2e0327473457d49)\n\n### API Usage\n\n```csharp\r\npublic class CustomJsonConverterWithInsertPathInfo : JsonConverter<int>\r\n{\r\n    public override int Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)\r\n        => throw new JsonException(\"Custom error message Path: {0}, Line number: {1}, Byte position in line: {2}\") { InsertPathInformation = true };\r\n\r\n    public override void Write(Utf8JsonWriter writer, int value, JsonSerializerOptions options) => throw new NotImplementedException();\r\n}\r\n\r\npublic class PropertyUsingCustomConverterThrowingWithPathInfo\r\n{\r\n    [JsonConverter(typeof(CustomJsonConverterWithInsertPathInfo))]\r\n    public int Id { get; set; }\r\n}\r\n```\r\n\r\n```csharp\r\ntry\r\n{\r\n    JsonSerializer.Deserialize<PropertyUsingCustomConverterThrowingWithPathInfo>(@\"{ \"\"Id\"\": \"\"invalid_value\"\" }\");\r\n}\r\ncatch (JsonException ex)\r\n{\r\n    //Should be \"Custom error message Path: $.Id, Line number: 0, Byte position in line: 23\"\r\n    Console.WriteLine(ex.Message);\r\n}\r\n```\r\n\n\n### Alternative Designs\n\n- A constructor parameter can be used instead of the init-only setter.\r\n- Another possibility is to provide the information to the format string in every case without the bool flag, in that case, there is no need for public API change, however, it could break people's existing code if they use format strings in the error messages.\n\n### Risks\n\n_No response_",
    "number": 79755,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "THUMBS_UP",
          "createdAt": "2022-12-19T08:56:55Z",
          "user": "martincostello"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-04-09T04:19:52Z",
          "user": "DigiBanks99"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-07-22T08:21:37Z",
          "user": "cklutz"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-02-07T08:32:04Z",
          "user": "quadrat"
        }
      ],
      "totalCount": 4,
      "endCursor": "Y3Vyc29yOnYyOpHOC-3VDA=="
    },
    "updatedAt": "2025-06-18T09:51:16Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\n### Background and motivation\n\nCurrently, the path information (Path, LineNumber, BytePositionInLine) is only appended to the error message when no custom error message is provided in the constructor of JsonException. However, when a custom message is set, there is no \"straightforward way\" to add it optionally. If someone throws a JsonException from the Read method of a custom JsonConverter, this information isn't available on the Utf8JsonReader.\r\n\r\nAs a workaround, it is possible to catch the exception at a \"higher level\" and add that information, but I think there should be an easier way to handle this. Furthermore, in this case, the author of a custom JsonConverter has to rely on someone to catch the exception and append or insert the path information later.\r\n\r\nA public property could be used to specify whether the path information should be inserted into the custom error message using a format string. This way the path information would be both optional (sometimes it may not be wanted in the custom error message) and flexible.\n\n### API Proposal\n\n```csharp\r\npublic class JsonException : Exception\r\n{\r\n    /// <summary>\r\n    /// Specifies that 'try' logic should insert Path information to the exception message using a format string.\r\n    /// </summary>\r\n    public bool InsertPathInformation { get; init; }\r\n}\r\n```\r\nFor more information see my implementation: [https://github.com/magyarandras/runtime/commit/f56f9c4a5cf807e4bacdcc1ea2e0327473457d49](https://github.com/magyarandras/runtime/commit/f56f9c4a5cf807e4bacdcc1ea2e0327473457d49)\n\n### API Usage\n\n```csharp\r\npublic class CustomJsonConverterWithInsertPathInfo : JsonConverter<int>\r\n{\r\n    public override int Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)\r\n        => throw new JsonException(\"Custom error message Path: {0}, Line number: {1}, Byte position in line: {2}\") { InsertPathInformation = true };\r\n\r\n    public override void Write(Utf8JsonWriter writer, int value, JsonSerializerOptions options) => throw new NotImplementedException();\r\n}\r\n\r\npublic class PropertyUsingCustomConverterThrowingWithPathInfo\r\n{\r\n    [JsonConverter(typeof(CustomJsonConverterWithInsertPathInfo))]\r\n    public int Id { get; set; }\r\n}\r\n```\r\n\r\n```csharp\r\ntry\r\n{\r\n    JsonSerializer.Deserialize<PropertyUsingCustomConverterThrowingWithPathInfo>(@\"{ \"\"Id\"\": \"\"invalid_value\"\" }\");\r\n}\r\ncatch (JsonException ex)\r\n{\r\n    //Should be \"Custom error message Path: $.Id, Line number: 0, Byte position in line: 23\"\r\n    Console.WriteLine(ex.Message);\r\n}\r\n```\r\n\n\n### Alternative Designs\n\n- A constructor parameter can be used instead of the init-only setter.\r\n- Another possibility is to provide the information to the format string in every case without the bool flag, in that case, there is no need for public API change, however, it could break people's existing code if they use format strings in the error messages.\n\n### Risks\n\n_No response_\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>magyarandras</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`api-suggestion`, `area-System.Text.Json`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2022-12-16T14:13:31Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-12-16T14:13:31Z",
          "id": "IC_kwDODI9FZc5Qwlnh"
        },
        {
          "author": "layomia",
          "body": "Yes we could provide an opt-in mechanism to include the path (i.e `JsonException.Path`) produced by the serializer or an API to for users to set it.\r\n\r\n@steveharter mentioned that the thought during API review was that the user may have a specific error message already and might not want the exception info cluttered.\r\n\r\nDepending on user feedback here we might want to challenge that assumption and perhaps include path info by default.",
          "createdAt": "2022-12-16T18:54:21Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2022-12-16T18:54:21Z",
          "id": "IC_kwDODI9FZc5Qyhj8"
        },
        {
          "author": "singggum3b",
          "body": "Might not be related but `System.Text.Json` have a `String.resx` file, but it seem impossible to override this file from application because of the hardcoded `SR` class. Any idea how ? \nSorry i'm new to Dotnet.",
          "createdAt": "2025-06-18T09:51:16Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-06-18T09:51:16Z",
          "id": "IC_kwDODI9FZc6x1OMr"
        }
      ],
      "totalCount": 3,
      "endCursor": "Y3Vyc29yOnYyOpHOsdTjKw=="
    },
    "url": "https://github.com/dotnet/runtime/issues/79755",
    "title": "[API Proposal]: Provide path information for custom JsonException error messages in System.Text.Json"
  },
  {
    "author": "npp127",
    "labels": [
      "enhancement",
      "area-System.Text.Json"
    ],
    "createdAt": "2023-01-03T10:49:41Z",
    "body": "### Description\r\n\r\nGiven a class\r\n\r\n~~~ c#\r\n    public class Test\r\n    {\r\n        public int MyProperty1 { get; set; } = 69;\r\n\r\n        public int MyProperty2 { get; } = 420;\r\n\r\n        public IEnumerable<int> Collection1 { get; set; } = new int[] { 69, 420 };\r\n\r\n        public IEnumerable<int> Collection2 { get; } = new int[] { 69, 420 };\r\n    };\r\n~~~\r\n\r\nby setting IgnoreReadOnlyProperties to true, one would expect that only \"MyProperty1\" and \"Collection1\" would be serialized.\r\nCollection2 Gets also serialized for whatever reason.\r\n\r\n\r\n\r\n\r\n### Reproduction Steps\r\n\r\nTest class\r\n\r\n\r\n~~~ c#\r\nnamespace T\r\n{\r\n    public class Test\r\n    {\r\n        public int MyProperty1 { get; set; } = 69;\r\n        public int MyProperty2 { get; } = 420;\r\n\r\n        public IEnumerable<int> Collection1 { get; set; } = new int[] { 69, 420 };\r\n\r\n        public IEnumerable<int> Collection2 { get; } = new int[] { 69, 420 };\r\n    };\r\n}\r\n~~~ \r\n\r\n\r\nProgram.cs\r\n\r\n~~~ c#\r\nusing System.Text.Json;\r\nusing T;\r\n\r\nvar opt = new JsonSerializerOptions()\r\n{\r\n    IgnoreReadOnlyProperties = true,\r\n    WriteIndented = true,\r\n};\r\n\r\n\r\nvar obj = new Test();\r\n\r\nvar json =  JsonSerializer.Serialize(obj, opt);\r\n\r\nConsole.WriteLine(json);\r\n~~~ \r\n\r\nCsproj\r\n\r\n\r\n~~~ xml\r\n<Project Sdk=\"Microsoft.NET.Sdk\">\r\n\t<PropertyGroup>\r\n\t\t<OutputType>Exe</OutputType>\r\n\t\t<TargetFramework>net7.0</TargetFramework>\r\n\t\t<ImplicitUsings>enable</ImplicitUsings>\r\n\t\t<Nullable>enable</Nullable>\r\n\t\t<LangVersion>latest</LangVersion>\r\n\t</PropertyGroup>\r\n</Project>\r\n~~~ \r\n\r\n\r\n\r\n\r\n### Expected behavior\r\n\r\n~~~  json\r\n{\r\n  \"MyProperty1\": 69,\r\n  \"Collection1\": [\r\n    69,\r\n    420\r\n  ]\r\n}\r\n~~~ \r\n\r\n### Actual behavior\r\n\r\n\r\n~~~  json\r\n{\r\n  \"MyProperty1\": 69,\r\n  \"Collection1\": [\r\n    69,\r\n    420\r\n  ],\r\n  \"Collection2\": [\r\n    69,\r\n    420\r\n  ]\r\n}\r\n~~~ \r\n\r\n### Regression?\r\n\r\n_No response_\r\n\r\n### Known Workarounds\r\n\r\n_No response_\r\n\r\n### Configuration\r\n\r\n_No response_\r\n\r\n### Other information\r\n\r\n_No response_",
    "number": 80113,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "HEART",
          "createdAt": "2023-01-03T11:00:24Z",
          "user": "fba97"
        },
        {
          "content": "HEART",
          "createdAt": "2023-01-03T11:00:31Z",
          "user": "lgritti"
        },
        {
          "content": "HEART",
          "createdAt": "2023-11-24T10:12:21Z",
          "user": "elgonzo"
        }
      ],
      "totalCount": 3,
      "endCursor": "Y3Vyc29yOnYyOpHOC0NMYg=="
    },
    "updatedAt": "2023-12-16T16:50:32Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\n### Description\n\nGiven a class\r\n\r\n~~~ c#\r\n    public class Test\r\n    {\r\n        public int MyProperty1 { get; set; } = 69;\r\n\r\n        public int MyProperty2 { get; } = 420;\r\n\r\n        public IEnumerable<int> Collection1 { get; set; } = new int[] { 69, 420 };\r\n\r\n        public IEnumerable<int> Collection2 { get; } = new int[] { 69, 420 };\r\n    };\r\n~~~\r\n\r\nby setting IgnoreReadOnlyProperties to true, one would expect that only \"MyProperty1\" and \"Collection1\" would be serialized.\r\nCollection2 Gets also serialized for whatever reason.\r\n\r\n\r\n\n\n### Reproduction Steps\n\nTest class\r\n\r\n\r\n~~~ c#\r\nnamespace T\r\n{\r\n    public class Test\r\n    {\r\n        public int MyProperty1 { get; set; } = 69;\r\n        public int MyProperty2 { get; } = 420;\r\n\r\n        public IEnumerable<int> Collection1 { get; set; } = new int[] { 69, 420 };\r\n\r\n        public IEnumerable<int> Collection2 { get; } = new int[] { 69, 420 };\r\n    };\r\n}\r\n~~~ \r\n\r\n\r\nProgram.cs\r\n\r\n~~~ c#\r\nusing System.Text.Json;\r\nusing T;\r\n\r\nvar opt = new JsonSerializerOptions()\r\n{\r\n    IgnoreReadOnlyProperties = true,\r\n    WriteIndented = true,\r\n};\r\n\r\n\r\nvar obj = new Test();\r\n\r\nvar json =  JsonSerializer.Serialize(obj, opt);\r\n\r\nConsole.WriteLine(json);\r\n~~~ \r\n\r\n\r\n\n\n### Expected behavior\n\n~~~  json\r\n{\r\n  \"MyProperty1\": 69,\r\n  \"Collection1\": [\r\n    69,\r\n    420\r\n  ]\r\n}\r\n~~~ \n\n### Actual behavior\n\n\r\n~~~  json\r\n{\r\n  \"MyProperty1\": 69,\r\n  \"Collection1\": [\r\n    69,\r\n    420\r\n  ],\r\n  \"Collection2\": [\r\n    69,\r\n    420\r\n  ]\r\n}\r\n~~~ \n\n### Regression?\n\n_No response_\n\n### Known Workarounds\n\n_No response_\n\n### Configuration\n\n_No response_\n\n### Other information\n\n_No response_\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>npp127</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`area-System.Text.Json`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2023-01-03T10:49:48Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-01-03T10:49:48Z",
          "id": "IC_kwDODI9FZc5RotOn"
        },
        {
          "author": "npp127",
          "body": "> it's like that by design for enumerables and dictionaries\r\n> \r\n> https://github.com/dotnet/runtime/blob/d783badaa38596beedefd58b59e2f031ba37c410/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/Metadata/JsonPropertyInfo.cs#L425-L441\r\n\r\n_Properties of collections types that only have setters are not supported._\r\n\r\nBut should they?\r\n\r\nI'm missing whats the point of the reasoning for not supporting that.  \r\nSomething like .IgnoreReadOnlyEnumerables with false as a default would allow users to avoid this behaviour\r\n",
          "createdAt": "2023-01-03T12:56:15Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-01-03T12:56:15Z",
          "id": "IC_kwDODI9FZc5RpIXn"
        },
        {
          "author": "krwq",
          "body": "I'm marking this as 8.0 for now because we should define behavior for this in #78556 and they should be looked at hollistically",
          "createdAt": "2023-01-17T16:09:22Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-01-17T16:09:22Z",
          "id": "IC_kwDODI9FZc5Sl4bx"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Duplicate of #67514 and #37599. IIUC this is intentional behavior and collections are treated specially w.r.t. this flag. Changing this now would be a breaking change. We might consider solving this using a different flag that supersedes `IgnoreReadOnlyProperties`.",
          "createdAt": "2023-01-17T17:13:05Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-01-17T17:14:40Z",
          "id": "IC_kwDODI9FZc5SmPZv"
        },
        {
          "author": "npp127",
          "body": "> Duplicate of #67514 and #37599. IIUC this is intentional behavior and collections are treated specially w.r.t. this flag. Changing this now would be a breaking change. We might consider solving this using a different flag that supersedes `IgnoreReadOnlyProperties`.\n\nShouldn't this behaviour be made configurable from the options?\n",
          "createdAt": "2023-01-17T17:19:14Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-01-17T17:19:14Z",
          "id": "IC_kwDODI9FZc5SmRVP"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Moving to Future.",
          "createdAt": "2023-06-16T13:10:49Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-06-16T13:10:49Z",
          "id": "IC_kwDODI9FZc5fDICR"
        },
        {
          "author": "wiz0u",
          "body": "Same for getter-only arrays. They get serialized, even though they are obviously not deserializable (can't set or resize the array)\r\n\r\nMy test program:\r\n```csharp\r\nusing System.Text.Json;\r\n \r\nvar test = new Test();\r\nConsole.WriteLine(JsonSerializer.Serialize(test, new JsonSerializerOptions { IgnoreReadOnlyProperties = true }));\r\n\r\npublic partial class Test\r\n{\r\n\tpublic int Id => 123;\r\n\tpublic int[] SomeArrayProp => new[] { 456 };\r\n\tpublic IEnumerable<int> SomeIEnumProp { get { yield return 789; } }\r\n}\r\n```",
          "createdAt": "2023-12-16T16:50:31Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "EYES",
                "createdAt": "2023-12-20T07:29:12Z",
                "user": "npp127"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHODQJt9A=="
          },
          "updatedAt": "2023-12-16T16:50:31Z",
          "id": "IC_kwDODI9FZc5uzBEF"
        }
      ],
      "totalCount": 7,
      "endCursor": "Y3Vyc29yOnYyOpHObswRBQ=="
    },
    "url": "https://github.com/dotnet/runtime/issues/80113",
    "title": "System.Text.Json IgnoreReadOnlyProperties not working for enumerables"
  },
  {
    "author": "squidink7",
    "labels": [
      "api-suggestion",
      "area-System.Text.Json"
    ],
    "createdAt": "2023-01-05T02:39:45Z",
    "body": "### Background and motivation\n\nI am currently using C# to create small self-contained applications with NativeAOT, many of which require JSON serialization for either saving application settings or receiving data from remote APIs. As NativeAOT does not (currently) work with reflection, I have been exclusively using source-generated serializers which require a bit more code to get working, in the form of the serialization context (which can become increasingly hard to maintain as an application grows, see #73297). While I'm not too familiar with the way the source-generator works behind the scenes or if this would even be possible with the current situation, simply comparing the flow of serializing an object to json to other AOT languages such as Dart, Kotlin/Native, and Swift there seems to be a lot less friction in those languages as compared to .NET. I was wondering if there could be a way for the source generator to write this class instead of the user.\n\n### API Proposal\n\nIdeally the source generator would create the context class when generating the rest of the required code, and store it in a standard location for the `Serialize` and `Deserialize` methods to search unless an existing context class is provided.\r\n\r\n(Unfortunately I am not experienced enough to determine how this would take form in framework code)\n\n### API Usage\n\nIf it's possible, having a default internal context for `JsonSerializer` to search would simplify the calls to `Serialize`/`Deserialize`, as the programmer no longer has to write\r\n\r\n(example code modified from [learn.microsoft.com](https://learn.microsoft.com/en-us/dotnet/standard/serialization/system-text-json/source-generation))\r\n```csharp\r\njsonString = JsonSerializer.Serialize(\r\n    weatherForecast, typeof(WeatherForecast));\r\n\r\n[JsonSerializable]\r\nclass WeatherForecast {\r\n    [...]\r\n}\r\n```\n\n### Alternative Designs\n\nCurrently reflection-based APIs use the same method signature as the proposal above, so to explicitly specify source generation as the method to use could help resolve this conflict.\r\n\r\n```csharp\r\nsourceGenOptions = new JsonSerializerOptions\r\n{\r\n    SerializerMode = JsonSerializerMode.SourceGen\r\n};\r\n\r\njsonString = JsonSerializer.Serialize(\r\n    weatherForecast, typeof(WeatherForecast), sourceGenOptions);\r\n```\r\nor\r\n```csharp\r\njsonString = JsonSerializer.Serialize(\r\n    weatherForecast, typeof(WeatherForecast), SourceGen = true);\r\n```\n\n### Risks\n\nThis reduces flexibility, as many options that would traditionally be passed through the context, and is therefore not intended to replace the existing method, but provide a syntactically simpler alternative for small applications.\r\nThese changes would be breaking, and require refactoring existing Serialization code. Provided the current method of writing a custom context class remains, it shouldn't cause too much breakage for current code-bases.",
    "number": 80220,
    "reactions": {
      "hasNextPage": false,
      "nodes": [],
      "totalCount": 0,
      "endCursor": null
    },
    "updatedAt": "2023-01-17T00:14:29Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\n### Background and motivation\n\nI am currently using C# to create small self-contained applications with NativeAOT, many of which require JSON serialization for either saving application settings or receiving data from remote APIs. As NativeAOT does not (currently) work with reflection, I have been exclusively using source-generated serializers which require a bit more code to get working, in the form of the serialization context (which can become increasingly hard to maintain as an application grows, see #73297). While I'm not too familiar with the way the source-generator works behind the scenes or if this would even be possible with the current situation, simply comparing the flow of serializing an object to json to other AOT languages such as Dart, Kotlin/Native, and Swift there seems to be a lot less friction in those languages as compared to .NET. I was wondering if there could be a way for the source generator to write this class instead of the user.\n\n### API Proposal\n\nIdeally the source generator would create the context class when generating the rest of the required code, and store it in a standard location for the `Serialize` and `Deserialize` methods to search unless an existing context class is provided.\r\n\r\n(Unfortunately I am not experienced enough to determine how this would take form in framework code)\n\n### API Usage\n\nIf it's possible, having a default internal context for `JsonSerializer` to search would simplify the calls to `Serialize`/`Deserialize`, as the programmer no longer has to write\r\n\r\n(example code modified from [learn.microsoft.com](https://learn.microsoft.com/en-us/dotnet/standard/serialization/system-text-json/source-generation))\r\n```csharp\r\njsonString = JsonSerializer.Serialize(\r\n    weatherForecast, typeof(WeatherForecast));\r\n\r\n[JsonSerializable]\r\nclass WeatherForecast {\r\n    [...]\r\n}\r\n```\n\n### Alternative Designs\n\nCurrently reflection-based APIs use the same method signature as the proposal above, so to explicitly specify source generation as the method to use could help resolve this conflict.\r\n\r\n```csharp\r\nsourceGenOptions = new JsonSerializerOptions\r\n{\r\n    SerializerMode = JsonSerializerMode.SourceGen\r\n};\r\n\r\njsonString = JsonSerializer.Serialize(\r\n    weatherForecast, typeof(WeatherForecast), sourceGenOptions);\r\n```\r\nor\r\n```csharp\r\njsonString = JsonSerializer.Serialize(\r\n    weatherForecast, typeof(WeatherForecast), SourceGen = true);\r\n```\n\n### Risks\n\nThis reduces flexibility, as many options that would traditionally be passed through the context, and is therefore not intended to replace the existing method, but provide a syntactically simpler alternative for small applications.\r\nThese changes would be breaking, and require refactoring existing Serialization code. Provided the current method of writing a custom context class remains, it shouldn't cause too much breakage for current code-bases.\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>squidink7</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`api-suggestion`, `area-System.Text.Json`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2023-01-05T02:39:53Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-01-05T02:39:53Z",
          "id": "IC_kwDODI9FZc5Rwp4N"
        },
        {
          "author": "Clockwork-Muse",
          "body": ">  I was wondering if there could be a way for the source generator to write this class instead of the user.\r\n\r\nStrictly speaking it's likely possible.  The problem is that if you put such a context in a \"well known\" location you - and every library you might reference - can have only one copy, which would be a fun way to cause waves of breaking changes throughout the ecosystem.  You could instead segment it by having a context object for each namespace an object is from, but namespaces can have objects from multiple packages, so it's still possible to cause breaking waves, plus all the fun of having multiple contexts that you're trying to juggle.  So the most realistic version is the instance listed in that other issue.\r\n\r\n> These changes would be breaking\r\n\r\nThis means it's extremely unlikely to happen.\r\n\r\n> Alternative Designs\r\n\r\nSource generators, as a feature, run solely at compile time, so you couldn't make it a runtime option.  They're also strictly additive, so you can't replace those calls at compile time with something else either.",
          "createdAt": "2023-01-05T06:17:05Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-01-05T06:17:05Z",
          "id": "IC_kwDODI9FZc5RxGjc"
        },
        {
          "author": "Tornhoof",
          "body": "Source Generators do not run ordered at the moment, it is afaik not possible to have one source generator depend on the output of another one. ",
          "createdAt": "2023-01-05T08:16:24Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-01-05T08:16:24Z",
          "id": "IC_kwDODI9FZc5RxaB6"
        },
        {
          "author": "layomia",
          "body": "Yeah we could expand on the current gesture for the source generator by allowing the `[JsonSerializable]` a directly on types. We'd need to establish a pattern for retrieving this metadata. I did initially envision the implicit creation of a \"default\" context for which types with the attribute are generated to, but that poses problems like @Clockwork-Muse points out. The design needs further thought but, if needed we could create an API to indicate the name/namespace of this implicit context. I imagine this would mitigate many of the concerns.\r\n\r\nThis pattern was discussed in the early period of the JSON source generator design and punted since it wasn't necessary for v1. With strong enough indication that this is a widely-felt problem we could come up with a solution here.",
          "createdAt": "2023-01-16T07:26:57Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-01-16T23:08:57Z",
                "user": "squidink7"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-01-22T14:26:52Z",
                "user": "robie2011"
              }
            ],
            "totalCount": 2,
            "endCursor": "Y3Vyc29yOnYyOpHODTk5ig=="
          },
          "updatedAt": "2023-01-16T07:26:57Z",
          "id": "IC_kwDODI9FZc5SeArr"
        },
        {
          "author": "krwq",
          "body": "On top of what @Clockwork-Muse said - I'm not sure how would we handle different options for those types. We definitely can't generate code for every possible option",
          "createdAt": "2023-01-16T09:23:45Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-01-16T09:23:45Z",
          "id": "IC_kwDODI9FZc5Sef4f"
        },
        {
          "author": "squidink7",
          "body": "Perhaps we could pass an instance of `JsonSerializerOptions` as an optional argument to the `[JsonSerializable]` decorators.\r\nE.g.\r\n```\r\nclass JsonConfig {\r\n    public static JsonSerializerOptions myJsonOptions = new();\r\n    ...\r\n}\r\n\r\n[JsonSerializable(Options = JsonConfig.myJsonOptions)]\r\nclass JsonResult {\r\n...\r\n```",
          "createdAt": "2023-01-16T23:06:24Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-01-16T23:06:24Z",
          "id": "IC_kwDODI9FZc5SiCLy"
        },
        {
          "author": "Clockwork-Muse",
          "body": "Attribute arguments must be constants, so that version doesn't work.  Probably, you'd want to have a factory interface you were required to implement that would return the option, which you could specify via type.\r\n",
          "createdAt": "2023-01-17T00:14:29Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-01-17T00:14:29Z",
          "id": "IC_kwDODI9FZc5SiK5I"
        }
      ],
      "totalCount": 7,
      "endCursor": "Y3Vyc29yOnYyOpHOUoiuSA=="
    },
    "url": "https://github.com/dotnet/runtime/issues/80220",
    "title": "[API Proposal]: Source Generate System.Text.Json Context Class"
  },
  {
    "author": "snjosephms",
    "labels": [
      "enhancement",
      "area-System.Text.Json"
    ],
    "createdAt": "2023-01-16T11:24:55Z",
    "body": "We are migrating our code base from Newtonsoft to System.Text.Json.\r\n\r\nWhile testing this migration effort, we have encountered the following error while deserializing a type which uses **ConcurrentBag**\r\n type: \"Message=The collection type 'System.Collections.Concurrent.ConcurrentBag`1' is abstract, an interface, or is read only, and could not be instantiated and populated.\"\r\n\r\nI see that this also documented here   - https://learn.microsoft.com/en-us/dotnet/standard/serialization/system-text-json/supported-collection-types?pivots=dotnet-7-0#systemcollectionsconcurrent-namespace\r\n\r\nIs there any workaround for providing support for ConcurrentBag type? \r\n\r\nThis is a major blocker in our migration effort as all hot path scenarios are dependent on this type",
    "number": 80688,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-09-19T21:03:00Z",
          "user": "justintoth"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-02-01T13:11:38Z",
          "user": "MrAntix"
        }
      ],
      "totalCount": 2,
      "endCursor": "Y3Vyc29yOnYyOpHOC-qxqQ=="
    },
    "updatedAt": "2024-07-05T11:52:49Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @dotnet/area-system-collections\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\nWe are migrating our code base from Newtonsoft to System.Text.Json.\r\n\r\nWhile testing this migration effort, we have encountered the following error while deserializing a type which uses **ConcurrentBag**\r\n type: \"Message=The collection type 'System.Collections.Concurrent.ConcurrentBag`1' is abstract, an interface, or is read only, and could not be instantiated and populated.\"\r\n\r\nI see that this also documented here   - https://learn.microsoft.com/en-us/dotnet/standard/serialization/system-text-json/supported-collection-types?pivots=dotnet-7-0#systemcollectionsconcurrent-namespace\r\n\r\nIs there any workaround for providing support for ConcurrentBag type? \r\n\r\nThis is a major blocker in our migration effort as all hot path scenarios are dependent on this type\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>snjosephms</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`area-System.Collections`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2023-01-16T11:25:02Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-01-16T11:25:02Z",
          "id": "IC_kwDODI9FZc5SfKpm"
        },
        {
          "author": "Tornhoof",
          "body": "you want a custom JsonConverter for your ``ConcurrentBag``, see https://learn.microsoft.com/en-us/dotnet/standard/serialization/system-text-json/converters-how-to?pivots=dotnet-7-0 for details.",
          "createdAt": "2023-01-16T13:31:10Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-01-18T19:20:57Z",
                "user": "eiriktsarpalis"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOCy4mLg=="
          },
          "updatedAt": "2023-01-16T13:31:10Z",
          "id": "IC_kwDODI9FZc5Sfy5F"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Here's a simple way to write a custom converter for ConcurrentBag:\r\n\r\n```C#\r\npublic class ConcurrentBagConverter<T> : JsonConverter<ConcurrentBag<T>>\r\n{\r\n    private readonly JsonConverter<IEnumerable<T>> _enumerableConverter = (JsonConverter<IEnumerable<T>>)JsonSerializerOptions.Default.GetConverter(typeof(IEnumerable<T>));\r\n\r\n    public override ConcurrentBag<T>? Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)\r\n    {\r\n        IEnumerable<T>? result = _enumerableConverter.Read(ref reader, typeToConvert, options);\r\n        return result is null ? null : new ConcurrentBag<T>(result);\r\n    }\r\n\r\n    public override void Write(Utf8JsonWriter writer, ConcurrentBag<T> value, JsonSerializerOptions options)\r\n        => _enumerableConverter.Write(writer, value, options);\r\n}\r\n```\r\n\r\nIn the future we should add support for collection types that satisfy common conventions such as\r\n\r\n1. Having a public parameterless constructor and a public `Add` method or\r\n2. Having a public constructor that accepts one `IEnumerable<T>` parameter (or `IEnumerable<KeyValuePair<TKey, TValue>>` for dictionary types.\r\n\r\nRelated to #71944.",
          "createdAt": "2023-01-18T19:54:11Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "HEART",
                "createdAt": "2023-01-19T04:45:31Z",
                "user": "snjosephms"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOC0b13A=="
          },
          "updatedAt": "2023-01-18T19:54:11Z",
          "id": "IC_kwDODI9FZc5StnRt"
        },
        {
          "author": "snjosephms",
          "body": "@eiriktsarpalis thanks for sharing the sample, \r\nIn this sample would passing the same JsonSerializerOptions in the overridden _JsonConverter.Read_ or _JsonConverter.Write_ be the cause of a potential stackoverflow error (resulting in a perf hit)?\r\nBelow is how I had written my implementation ConcurrentBagJsonConverter\r\n```\r\ninternal class ConcurrentBagJsonConverter : JsonConverter<ConcurrentBag<FlushDocument>>\r\n        {\r\n            public override ConcurrentBag<FlushDocument> Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)\r\n            {\r\n                if (reader.TokenType != JsonTokenType.StartArray)\r\n                    throw new InvalidOperationException();\r\n\r\n                ConcurrentBag<FlushDocument> bag = new ConcurrentBag<FlushDocument>();\r\n                while (reader.Read())\r\n                {\r\n                    if (reader.TokenType == JsonTokenType.EndArray)\r\n                        break;\r\n\r\n                    bag.Add(JsonSerializer.Deserialize<FlushDocument>(ref reader, options));\r\n                }\r\n\r\n                return bag;\r\n            }\r\n\r\n            public override void Write(Utf8JsonWriter writer, ConcurrentBag<FlushDocument> value, JsonSerializerOptions options)\r\n            {\r\n                // Passing JsonSerializerOptions *without* CustomConverter to avoid stackoverflow\r\n                System.Text.Json.JsonSerializer.Serialize(writer, value, ocSBMsgSerializerOptions);\r\n            }\r\n\r\n        }\r\n```",
          "createdAt": "2023-01-19T05:02:35Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-01-19T05:03:02Z",
          "id": "IC_kwDODI9FZc5TPAl7"
        },
        {
          "author": "krwq",
          "body": "@snjosephms that should work fine since we're not using same type for serialization/deserialization as in your case. if we change your Serialize call to pass in IEnumerable type that should not require extra options as well",
          "createdAt": "2023-01-19T13:08:36Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-01-19T13:08:36Z",
          "id": "IC_kwDODI9FZc5TQ8XT"
        },
        {
          "author": "justintoth",
          "body": "@eiriktsarpalis How would you go about registering your ConcurrentBagConverter? I'm having trouble with the syntax, because it expects a generic type to be passed in, when we would want to use this converter for all usages of ConcurrentBag, regardless of the generic type.\r\n\r\nEDIT: For others who find this thread, the answer was to create a factory class that can be added to the options Converters list:\r\n\r\n```\r\npublic class ConcurrentBagConverterFactory : JsonConverterFactory\r\n{\r\n\tprivate static Type[] ConvertibleTypes = new Type[]\r\n\t{\r\n\t\ttypeof(bool),\r\n\t\ttypeof(byte),\r\n\t\ttypeof(char),\r\n\t\ttypeof(decimal),\r\n\t\ttypeof(double),\r\n\t\ttypeof(float),\r\n\t\ttypeof(int),\r\n\t\ttypeof(long),\r\n\t\ttypeof(sbyte),\r\n\t\ttypeof(short),\r\n\t\ttypeof(uint),\r\n\t\ttypeof(ulong),\r\n\t\ttypeof(ushort),\r\n\t};\r\n\r\n\tpublic static bool CanConvertImpl(Type typeToConvert)\r\n\t{\r\n\t\tif (typeToConvert.IsGenericType\r\n\t\t\t&& typeToConvert.GetGenericTypeDefinition() == typeof(ConcurrentBag<>))\r\n\t\t{\r\n\t\t\tvar keyType = typeToConvert.GenericTypeArguments[0];\r\n\t\t\treturn keyType.IsEnum || ConvertibleTypes.Any(convertibleType => keyType == convertibleType);\r\n\t\t}\r\n\r\n\t\tvar baseType = typeToConvert.BaseType;\r\n\t\tif (!(baseType is null))\r\n\t\t{\r\n\t\t\treturn CanConvertImpl(baseType);\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\tpublic override bool CanConvert(Type typeToConvert)\r\n\t{\r\n\t\treturn CanConvertImpl(typeToConvert);\r\n\t}\r\n\r\n\tpublic override JsonConverter CreateConverter(Type typeToConvert, JsonSerializerOptions options)\r\n\t{\r\n\t\tvar converterType = typeof(ConcurrentBagConverter<>)\r\n\t\t\t.MakeGenericType(typeToConvert.GenericTypeArguments[0]);\r\n\r\n\t\tvar converter = (JsonConverter)Activator.CreateInstance(\r\n\t\t\tconverterType,\r\n\t\t\tBindingFlags.Instance | BindingFlags.Public,\r\n\t\t\tbinder: null,\r\n\t\t\tnew object[] {\r\n\t\t\t\t//_converterOptions, _namingPolicy\r\n\t\t\t},\r\n\t\t\tculture: null);\r\n\r\n\t\treturn converter;\r\n\t}\r\n}\r\n```",
          "createdAt": "2023-09-20T20:00:25Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-09-20T20:41:42Z",
          "id": "IC_kwDODI9FZc5nBH_g"
        },
        {
          "author": "eiriktsarpalis",
          "body": "@justintoth I would probably simplify this to the following, full code:\r\n```C#\r\nvar options = new JsonSerializerOptions { Converters = { new ConcurrentBagConverter() } };\r\nvar bag = JsonSerializer.Deserialize<ConcurrentBag<int>>(\"[1, 2, 3]\", options);\r\nConsole.WriteLine(bag.Count);\r\n\r\npublic class ConcurrentBagConverter<T> : JsonConverter<ConcurrentBag<T>>\r\n{\r\n    private readonly JsonConverter<IEnumerable<T>> _enumerableConverter;\r\n    public ConcurrentBagConverter(JsonConverter<IEnumerable<T>> enumerableConverter)\r\n        => _enumerableConverter = enumerableConverter;\r\n\r\n    public override ConcurrentBag<T>? Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)\r\n    {\r\n        IEnumerable<T>? result = _enumerableConverter.Read(ref reader, typeof(IEnumerable<T>), options);\r\n        return result is null ? null : new ConcurrentBag<T>(result);\r\n    }\r\n\r\n    public override void Write(Utf8JsonWriter writer, ConcurrentBag<T> value, JsonSerializerOptions options)\r\n        => _enumerableConverter.Write(writer, value, options);\r\n}\r\n\r\npublic class ConcurrentBagConverter : JsonConverterFactory\r\n{\r\n    public override bool CanConvert(Type typeToConvert) => typeToConvert.IsGenericType && typeToConvert.GetGenericTypeDefinition() == typeof(ConcurrentBag<>);\r\n\r\n    public override JsonConverter? CreateConverter(Type typeToConvert, JsonSerializerOptions options)\r\n    {\r\n        Debug.Assert(CanConvert(typeToConvert));\r\n        Type elementType = typeToConvert.GetGenericArguments()[0];\r\n        Type ienumerableType = typeof(IEnumerable<>).MakeGenericType(elementType);\r\n        Type converterType = typeof(ConcurrentBagConverter<>).MakeGenericType(elementType);\r\n        JsonConverter ienumerableConverter = options.GetConverter(ienumerableType);\r\n        return (JsonConverter)Activator.CreateInstance(converterType, ienumerableConverter)!;\r\n    }\r\n}\r\n```",
          "createdAt": "2023-09-21T16:33:03Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-09-27T16:16:29Z",
                "user": "justintoth"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHODH-D1w=="
          },
          "updatedAt": "2023-09-21T16:33:03Z",
          "id": "IC_kwDODI9FZc5nHH4-"
        },
        {
          "author": "dotnet-policy-service",
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. -->",
          "createdAt": "2024-07-05T11:52:49Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-07-05T11:52:49Z",
          "id": "IC_kwDODI9FZc6DxTcB"
        }
      ],
      "totalCount": 8,
      "endCursor": "Y3Vyc29yOnYyOpHOg8U3AQ=="
    },
    "url": "https://github.com/dotnet/runtime/issues/80688",
    "title": "Add support for collection types with parameterless or IEnumerable<T> constructors."
  },
  {
    "author": "eiriktsarpalis",
    "labels": [
      "area-System.Text.Json",
      "size-reduction",
      "partner-impact"
    ],
    "createdAt": "2023-01-20T13:56:17Z",
    "body": "The PR in #80755 attempted to reduce the size of System.Text.Json components in trimmed NativeAOT binaries. The per-namespace breakdown in https://github.com/dotnet/runtime/pull/80755#issuecomment-1397376908 shows that there might be opportunity to further reduce application size in the `System.Text.Json.Serialization.Metadata` namespace, which currently occupies approximately 600k in the Golidlocks app. More specifically, the metadata layer introduces overhead in a couple of ways:\r\n\r\n1. Using separate `JsonTypeInfo<T>` implementations for [source gen](https://github.com/dotnet/runtime/blob/a734aa467f1bbf4d5bf30fe217e1a36eb966ce08/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/Metadata/SourceGenJsonTypeInfoOfT.cs) and [reflection](https://github.com/dotnet/runtime/blob/main/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/Metadata/ReflectionJsonTypeInfoOfT.cs). This segregation largely exists for historical reasons and it could be removed, decoupling `JsonTypeInfo<T>` metadata from contract resolution behavior.\r\n2. The source generator sets `JsonTypeInfo` metadata using the [`JsonMetadataServices`](https://learn.microsoft.com/en-us/dotnet/api/system.text.json.serialization.metadata.jsonmetadataservices?view=net-7.0) APIs as a proxy. This happens because the source generator predates the public APIs on `JsonTypeInfo` itself. The proxy API introduces a number of generic classes such as `JsonCollectionInfoValues<T>`, `JsonObjectInfoValues<T>` and `JsonPropertyInfoValues<T>`. All these types could be trimmed if we updated the source generator to call into the `JsonTypeInfo` APIs directly. Note that this is currently blocked by #71944, the only remaining configuration point available  in `JsonMetadataServices` but not yet present in `JsonTypeInfo<T>`.\r\n\r\ncc @eerhardt @krwq @layomia ",
    "number": 80917,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-01-20T14:05:50Z",
          "user": "krwq"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-01-21T00:08:50Z",
          "user": "eerhardt"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-01-21T04:45:04Z",
          "user": "rogihee"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-03-20T10:47:23Z",
          "user": "PaulusParssinen"
        }
      ],
      "totalCount": 4,
      "endCursor": "Y3Vyc29yOnYyOpHODATsIA=="
    },
    "updatedAt": "2025-01-17T12:09:44Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\nThe PR in #80755 attempted to reduce the size of System.Text.Json components in trimmed NativeAOT binaries. The per-namespace breakdown in https://github.com/dotnet/runtime/pull/80755#issuecomment-1397376908 shows that there might be opportunity to further reduce application size in the `System.Text.Json.Serialization.Metadata` namespace. More specifically, the metadata layer introduces overhead in a couple of ways:\r\n\r\n1. Using separate `JsonTypeInfo<T>` implementations for [source gen](https://github.com/dotnet/runtime/blob/a734aa467f1bbf4d5bf30fe217e1a36eb966ce08/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/Metadata/SourceGenJsonTypeInfoOfT.cs) and [reflection](https://github.com/dotnet/runtime/blob/main/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/Metadata/ReflectionJsonTypeInfoOfT.cs). This segregation largely exists for historical reasons and it could be removed, decoupling `JsonTypeInfo<T>` metadata from contract resolution behavior.\r\n2. The source generator sets `JsonTypeInfo` metadata using the [`JsonMetadataServices`](https://learn.microsoft.com/en-us/dotnet/api/system.text.json.serialization.metadata.jsonmetadataservices?view=net-7.0) APIs as a proxy. This happens because the source generator predates the public APIs on `JsonTypeInfo` itself. The proxy API introduces a number of generic classes such as `JsonCollectionInfoValues<T>`, `JsonObjectInfoValues<T>` and `JsonPropertyInfoValues<T>`. All these types could be trimmed if we updated the source generator to call into the `JsonTypeInfo` APIs directly. Note that this is currently blocked by #71944, the only remaining configuration point available  in `JsonMetadataServices` but not yet present in `JsonTypeInfo<T>`.\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>eiriktsarpalis</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>eiriktsarpalis</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`area-System.Text.Json`, `untriaged`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2023-01-20T13:56:27Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-01-20T13:56:27Z",
          "id": "IC_kwDODI9FZc5TWluL"
        },
        {
          "author": null,
          "body": "Tagging subscribers to 'size-reduction': @eerhardt, @SamMonoRT, @marek-safar\nSee info in area-owners.md if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\nThe PR in #80755 attempted to reduce the size of System.Text.Json components in trimmed NativeAOT binaries. The per-namespace breakdown in https://github.com/dotnet/runtime/pull/80755#issuecomment-1397376908 shows that there might be opportunity to further reduce application size in the `System.Text.Json.Serialization.Metadata` namespace. More specifically, the metadata layer introduces overhead in a couple of ways:\r\n\r\n1. Using separate `JsonTypeInfo<T>` implementations for [source gen](https://github.com/dotnet/runtime/blob/a734aa467f1bbf4d5bf30fe217e1a36eb966ce08/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/Metadata/SourceGenJsonTypeInfoOfT.cs) and [reflection](https://github.com/dotnet/runtime/blob/main/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/Metadata/ReflectionJsonTypeInfoOfT.cs). This segregation largely exists for historical reasons and it could be removed, decoupling `JsonTypeInfo<T>` metadata from contract resolution behavior.\r\n2. The source generator sets `JsonTypeInfo` metadata using the [`JsonMetadataServices`](https://learn.microsoft.com/en-us/dotnet/api/system.text.json.serialization.metadata.jsonmetadataservices?view=net-7.0) APIs as a proxy. This happens because the source generator predates the public APIs on `JsonTypeInfo` itself. The proxy API introduces a number of generic classes such as `JsonCollectionInfoValues<T>`, `JsonObjectInfoValues<T>` and `JsonPropertyInfoValues<T>`. All these types could be trimmed if we updated the source generator to call into the `JsonTypeInfo` APIs directly. Note that this is currently blocked by #71944, the only remaining configuration point available  in `JsonMetadataServices` but not yet present in `JsonTypeInfo<T>`.\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>eiriktsarpalis</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`area-System.Text.Json`, `untriaged`, `size-reduction`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>Future</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2023-01-20T13:56:45Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-01-20T13:56:45Z",
          "id": "IC_kwDODI9FZc5TWlzZ"
        },
        {
          "author": "krwq",
          "body": "Shouldn't the split into source-gen/reflection help eventually? I'd assume if you use source-gen all ReflectionJsonTypeInfo should get trimmed away (and reverse). Should we strive into that actually happening if it's not currently?",
          "createdAt": "2023-01-20T14:04:25Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-01-20T14:04:25Z",
          "id": "IC_kwDODI9FZc5TWoC2"
        },
        {
          "author": "krwq",
          "body": "Other option we can move all the reflection logic to DefaultJsonTypeInfoResolver and keep JsonTypeInfo clean. That should achieve same effect and might actually be easier to achieve",
          "createdAt": "2023-01-20T14:05:34Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-01-20T14:05:46Z",
                "user": "eiriktsarpalis"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOC0i2pQ=="
          },
          "updatedAt": "2023-01-20T14:05:34Z",
          "id": "IC_kwDODI9FZc5TWobB"
        },
        {
          "author": "eiriktsarpalis",
          "body": "> Shouldn't the split into source-gen/reflection help eventually? I'd assume if you use source-gen all ReflectionJsonTypeInfo should get trimmed away (and reverse). Should we strive into that actually happening if it's not currently?\r\n\r\nThe derived types aren't necessary and because they are generic they contribute to a linear increase of application size in NativeAOT apps. There should eventually be one sealed `JsonTypeInfo<T>` class that each resolver populates independently.",
          "createdAt": "2023-01-20T14:07:35Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-01-20T14:07:35Z",
          "id": "IC_kwDODI9FZc5TWpCL"
        }
      ],
      "totalCount": 5,
      "endCursor": "Y3Vyc29yOnYyOpHOU1qQiw=="
    },
    "url": "https://github.com/dotnet/runtime/issues/80917",
    "title": "Potential size reduction opportunities in System.Text.Json NativeAOT"
  },
  {
    "author": "arizowa",
    "labels": [
      "area-System.Text.Json"
    ],
    "createdAt": "2023-02-01T05:01:40Z",
    "body": "### Description\r\n\r\nHello,\r\n\r\nI migrated Newtonsoft.Json to System.Text.Json\r\n\r\nBut the response of Api returns not same.\r\n\r\nI have two models:\r\n\r\n```\r\npublic class User {\r\n    public Guid Id { get; set; }\r\n    public string Email { get; set; }\r\n    public string Password { get; set; }\r\n    public virtual ICollection<UserProfile> UserProfiles { get; set; }\r\n}\r\n\r\npublic class UserProfile {\r\n    public Guid Id { get; set; }\r\n    public string Name { get; set; }\r\n    public Guid UserId { get; set; }\r\n    public virtual User User { get; set }\r\n}\r\n```\r\n\r\nAnd I used EF to query:\r\n\r\n```\r\nvar user = _userRepository.AsQueryable().Include(x => x.UserProfiles).AsNoTrackingWithIdentityResolution().FirstOrDefault(x => x.Id = userId);\r\nreturn user;\r\n```\r\n\r\nNewtonsoft.Json result:\r\n\r\n`\"userProfiles\": [],`\r\n\r\nSystem.Test.Json result:\r\n\r\n```\r\n\"userProfiles\": [\r\n    null\r\n ]\r\n```\r\n\r\nMy configuration:\r\n\r\n```\r\nbuilder.Services.AddControllers().AddJsonOptions(opts =>\r\n            {\r\n                opts.JsonSerializerOptions.PropertyNamingPolicy = JsonNamingPolicy.CamelCase;\r\n                opts.JsonSerializerOptions.ReferenceHandler = ReferenceHandler.IgnoreCycles;\r\n                opts.JsonSerializerOptions.NumberHandling = JsonNumberHandling.AllowReadingFromString;\r\n                opts.JsonSerializerOptions.WriteIndented = true;\r\n                opts.JsonSerializerOptions.MaxDepth = 0;\r\n            });\r\n```\r\n\r\nWhat can I do to convert result to same Newtonsoft.Json?\r\n\r\n### Reproduction Steps\r\n\r\nMigrate Newtonsoft.Json to System.Text.Json\r\n\r\n### Expected behavior\r\n\r\nSame result with Newtonsoft.Json\r\n\r\n### Actual behavior\r\n\r\nDeferent result \r\n\r\n### Regression?\r\n\r\n_No response_\r\n\r\n### Known Workarounds\r\n\r\n_No response_\r\n\r\n### Configuration\r\n\r\n_No response_\r\n\r\n### Other information\r\n\r\n_No response_",
    "number": 81458,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "EYES",
          "createdAt": "2023-06-24T20:01:01Z",
          "user": "lunatiqqc"
        }
      ],
      "totalCount": 1,
      "endCursor": "Y3Vyc29yOnYyOpHOCw6H8g=="
    },
    "updatedAt": "2024-02-07T12:26:10Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\n### Description\n\nHello,\r\n\r\nI migrated Newtonsoft.Json to System.Text.Json\r\n\r\nBut the response of Api returns not same.\r\n\r\nNewtonsoft.Json result:\r\n\r\n`\"userProfiles\": [],`\r\n\r\nSystem.Test.Json result:\r\n\r\n```\r\n\"userProfiles\": [\r\n    null\r\n ]\r\n```\r\n\r\nMy configuration:\r\n\r\n```\r\nbuilder.Services.AddControllers().AddJsonOptions(opts =>\r\n            {\r\n                opts.JsonSerializerOptions.PropertyNamingPolicy = JsonNamingPolicy.CamelCase;\r\n                opts.JsonSerializerOptions.ReferenceHandler = ReferenceHandler.IgnoreCycles;\r\n                opts.JsonSerializerOptions.NumberHandling = JsonNumberHandling.AllowReadingFromString;\r\n                opts.JsonSerializerOptions.WriteIndented = true;\r\n                opts.JsonSerializerOptions.MaxDepth = 0;\r\n            });\r\n```\r\n\r\nWhat can I do to convert result to same Newtonsoft.Json?\n\n### Reproduction Steps\n\nMigrate Newtonsoft.Json to System.Text.Json\n\n### Expected behavior\n\nSame result with Newtonsoft.Json\n\n### Actual behavior\n\nDeferent result \n\n### Regression?\n\n_No response_\n\n### Known Workarounds\n\n_No response_\n\n### Configuration\n\n_No response_\n\n### Other information\n\n_No response_\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>MinhMit</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`area-System.Text.Json`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2023-02-01T05:01:48Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-02-01T05:01:48Z",
          "id": "IC_kwDODI9FZc5UIUKU"
        },
        {
          "author": "gregsdennis",
          "body": "Can you edit your question to include an example of C# code that illustrates this difference?",
          "createdAt": "2023-02-01T05:18:58Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-02-01T05:18:58Z",
          "id": "IC_kwDODI9FZc5UIYh9"
        },
        {
          "author": "arizowa",
          "body": "> Can you edit your question to include an example of C# code that illustrates this difference?\r\n\r\nI'm updated.\r\nThanks for your time.",
          "createdAt": "2023-02-01T05:36:09Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-02-01T05:36:09Z",
          "id": "IC_kwDODI9FZc5UIa-o"
        },
        {
          "author": "gregsdennis",
          "body": "I assume the results you list are after deserialization, correct?  Do you think you can capture the JSON _before_ deserialization?",
          "createdAt": "2023-02-01T07:48:42Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-02-01T07:48:42Z",
          "id": "IC_kwDODI9FZc5UI1G3"
        },
        {
          "author": "arizowa",
          "body": "@gregsdennis : Yes, after deserialization, It's result of API\r\n\r\nI use both System.Text.Json and Newtonsoft.Json to deserialization one object. Result still different.\r\n\r\nResult of System.Text.Json:\r\n\r\n![Capture1](https://user-images.githubusercontent.com/5819667/216010757-26bcf8dc-538f-4f8a-88ec-e99f8bf9427d.PNG)\r\n\r\nResult of Newtonsoft.Json\r\n\r\n![Capture2](https://user-images.githubusercontent.com/5819667/216010840-8419f43b-cac2-4d8e-855e-92b12ca69ab4.PNG)\r\n",
          "createdAt": "2023-02-01T09:57:28Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-02-01T09:57:28Z",
          "id": "IC_kwDODI9FZc5UJgLN"
        },
        {
          "author": "gregsdennis",
          "body": "Can you show the contents of the `consumer` variable?\n\nI suspect what's happening is a difference between the lines in null-value handling.",
          "createdAt": "2023-02-01T23:45:05Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-02-01T23:45:05Z",
          "id": "IC_kwDODI9FZc5UN1xy"
        },
        {
          "author": "arizowa",
          "body": "> Can you show the contents of the `consumer` variable?\r\n> \r\n> I suspect what's happening is a difference between the lines in null-value handling.\r\n\r\n@gregsdennis  Yep, but not fully content, it's sensitive data.\r\n\r\nLv 1. Consumer has multiple ConsumerProfile\r\n\r\n![Capture1](https://user-images.githubusercontent.com/5819667/216215967-e72024cf-3c1f-4f7b-a188-f6adc794770c.PNG)\r\n\r\nLv 2. ConsumerProfile has Address. Notice extension to Id of Address\r\n\r\n![Capture2](https://user-images.githubusercontent.com/5819667/216216802-55782d46-d2e6-4847-b7db-80502e735548.PNG)\r\n\r\nLv 3. Address has System\r\n\r\n![Capture3](https://user-images.githubusercontent.com/5819667/216216819-e2750f27-2578-4ace-9816-68ad6f5938fe.png)\r\n\r\nLv 4. System has multiple Address. Null occurred at here\r\n\r\n![Capture4](https://user-images.githubusercontent.com/5819667/216216839-f7e20e76-86ab-412e-9893-6c7e141fa385.png)\r\n\r\nLv 5. Just show Id of Address to you\r\n\r\n![Capture5](https://user-images.githubusercontent.com/5819667/216216450-31073e83-7892-480c-a68e-1f32f0c9b53e.png)\r\n",
          "createdAt": "2023-02-02T02:29:46Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-02-02T02:35:07Z",
          "id": "IC_kwDODI9FZc5UOaHB"
        },
        {
          "author": "arizowa",
          "body": "@gregsdennis Any update, supporter?",
          "createdAt": "2023-02-03T04:08:23Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-02-03T04:08:23Z",
          "id": "IC_kwDODI9FZc5UVSjL"
        },
        {
          "author": "gregsdennis",
          "body": "Haven't had a chance to look further. I'm just a user interested in JSON.  I'm not Microsoft.",
          "createdAt": "2023-02-03T04:10:08Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-02-03T04:10:08Z",
          "id": "IC_kwDODI9FZc5UVTfs"
        },
        {
          "author": "arizowa",
          "body": "Yep, Thanks for your time.\r\nWaiting answer from Microsoft :(",
          "createdAt": "2023-02-03T04:12:10Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-02-03T04:12:10Z",
          "id": "IC_kwDODI9FZc5UVUWr"
        },
        {
          "author": "gregsdennis",
          "body": "Yeah, I don't know.\r\n\r\nI ran this test:\r\n\r\n```c#\r\nprivate class MyClass\r\n{\r\n\tpublic string Id { get; set; } = Guid.NewGuid().ToString();\r\n\tpublic List<string?> Values { get; set; }\r\n\r\n\tpublic MyClass(List<string?> values)\r\n\t{\r\n\t\tValues = values;\r\n\t}\r\n}\r\n\r\n[Test]\r\npublic void Test1()\r\n{\r\n\tPrint(new List<string?> { \"one\", \"two\", null, \"three\" });\r\n\tPrint(new List<string?> { null });\r\n\tPrint(new List<string?>());\r\n}\r\n\r\nprivate void Print(List<string?> data)\r\n{\r\n\tvar myClass = new MyClass(data);\r\n\r\n\tvar serializedWithNewtonsoft = njson.JsonConvert.SerializeObject(myClass);\r\n\tvar serializedWithStj = JsonSerializer.Serialize(myClass, new JsonSerializerOptions\r\n\t{\r\n\t\tPropertyNamingPolicy = JsonNamingPolicy.CamelCase,\r\n\t\tReferenceHandler = ReferenceHandler.IgnoreCycles,\r\n\t\tNumberHandling = JsonNumberHandling.AllowReadingFromString,\r\n\t\tMaxDepth = 0\r\n\t});\r\n\r\n\tConsole.WriteLine(serializedWithNewtonsoft);\r\n\tConsole.WriteLine(serializedWithStj);\r\n\tConsole.WriteLine();\r\n}\r\n```\r\n\r\nand got\r\n\r\n```\r\n{\"Id\":\"6f144bc2-6bf6-425c-8d2e-83798e409471\",\"Values\":[\"one\",\"two\",null,\"three\"]}\r\n{\"id\":\"6f144bc2-6bf6-425c-8d2e-83798e409471\",\"values\":[\"one\",\"two\",null,\"three\"]}\r\n\r\n{\"Id\":\"94b51022-b056-417f-bad5-52ad23954714\",\"Values\":[null]}\r\n{\"id\":\"94b51022-b056-417f-bad5-52ad23954714\",\"values\":[null]}\r\n\r\n{\"Id\":\"7e9f7ab1-d523-4577-88c8-9313f2ebe060\",\"Values\":[]}\r\n{\"id\":\"7e9f7ab1-d523-4577-88c8-9313f2ebe060\",\"values\":[]}\r\n```\r\n\r\nSeems to me all of the null handling is the same between the libs.",
          "createdAt": "2023-02-05T22:10:56Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-02-05T22:10:56Z",
          "id": "IC_kwDODI9FZc5UiTa-"
        },
        {
          "author": "arizowa",
          "body": "I think the reason might be because data and nested object.",
          "createdAt": "2023-02-06T08:08:54Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-02-06T08:08:54Z",
          "id": "IC_kwDODI9FZc5Ujyov"
        },
        {
          "author": "krwq",
          "body": "I haven't read the entire discussion but is it possible you're searching for https://learn.microsoft.com/en-us/dotnet/api/system.text.json.jsonserializeroptions.defaultignorecondition?view=net-7.0 ? (JsonIgnoreCondition.WhenWritingNull)",
          "createdAt": "2023-02-06T13:26:31Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-02-06T13:27:09Z",
          "id": "IC_kwDODI9FZc5UlXKv"
        },
        {
          "author": "d3ara1n",
          "body": "Microsoft's implementation simply ignores null annotations, whereas Json.Net either throws exceptions or inserts empty collections into non-null properties. The latter is much more elegant.",
          "createdAt": "2024-02-07T12:26:08Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-02-07T12:26:08Z",
          "id": "IC_kwDODI9FZc5zJxaE"
        }
      ],
      "totalCount": 14,
      "endCursor": "Y3Vyc29yOnYyOpHOcycWhA=="
    },
    "url": "https://github.com/dotnet/runtime/issues/81458",
    "title": "How to return empty list instance of list of null by system.text.json in net 7.0"
  },
  {
    "author": "dbaghdanov",
    "labels": [
      "enhancement",
      "area-System.Text.Json"
    ],
    "createdAt": "2023-02-02T17:36:39Z",
    "body": "### Description\n\nUpgrading my project from .netcore 3.1 to .net6 I came across one of my tests failing due to a change in how JsonSerializer.Serialize will serialize an anonymous type.  \n\n### Reproduction Steps\n\n```c#\r\nvar obj = new \r\n{\r\n  input = new {\r\n    foo = \"foo\"\r\n  },\r\n  INPUT = new {\r\n    foo = \"foo\"\r\n  }\r\n};\r\n\r\nvar json = JsonSerializer.Serialize(obj); // throws an exception\r\n```\n\n### Expected behavior\n\nIn .netcore 3.1 the above would have returned:\r\n\r\n```json\r\n{\"input\":{\"foo\":\"bar\"},\"INPUT\":{\"foo\":\"bar\"}}\r\n```\n\n### Actual behavior\n\nIn .net5+ this exception is thrown instead:\r\n\r\n```\r\nUnhandled exception. System.InvalidOperationException: Members 'input' and 'INPUT' on type '<>f__AnonymousType2`2[<>f__AnonymousType1`1[System.String],<>f__AnonymousType1`1[System.String]]' cannot both bind with parameter 'input' in the deserialization constructor.\r\n   at System.Text.Json.ThrowHelper.ThrowInvalidOperationException_MultiplePropertiesBindToConstructorParameters(Type parentType, String parameterName, String firstMatchName, String secondMatchName)\r\n   at System.Text.Json.Serialization.Metadata.JsonTypeInfo.InitializeConstructorParameters(JsonParameterInfoValues[] jsonParameters, Boolean sourceGenMode)\r\n   at System.Text.Json.Serialization.Metadata.JsonTypeInfo..ctor(Type type, JsonConverter converter, Type runtimeType, JsonSerializerOptions options)\r\n   at System.Text.Json.JsonSerializerOptions.<InitializeForReflectionSerializer>g__CreateJsonTypeInfo|112_0(Type type, JsonSerializerOptions options)\r\n   at System.Text.Json.JsonSerializerOptions.GetClassFromContextOrCreate(Type type)\r\n   at System.Text.Json.JsonSerializerOptions.GetOrAddClass(Type type)\r\n   at System.Text.Json.JsonSerializer.GetTypeInfo(JsonSerializerOptions options, Type runtimeType)\r\n   at System.Text.Json.JsonSerializer.Serialize[TValue](TValue value, JsonSerializerOptions options)\r\n```\r\n\r\nUnhandled exception. System.InvalidOperationException: Members 'input' and 'INPUT' on type '<>f__AnonymousType2`2[<>f__AnonymousType1`1[System.String],<>f__AnonymousType1`1[System.String]]' cannot both bind with parameter 'input' in the deserialization constructor.\n\n### Regression?\n\nWorked as I expected in .netcore 3.1 but not in .net5+\n\n### Known Workarounds\n\nIf I were to create a class to represent my anonymous type instead, then I do receive the expected JSON string.\r\n\r\n```c#\r\npublic sealed class Obj\r\n{\r\n    public Input input {get; set;}\r\n    public Input INPUT {get; set;}\r\n}\r\n\r\npublic sealed class Input\r\n{\r\n    public string foo {get;set;}\t\r\n}\r\n\r\n```\r\n\r\nAnd instantiate similar to my anonymous type:\r\n```c#\r\nvar obj = new Obj()\r\n{\r\n    input = new Input()\r\n    {\r\n        foo=\"bar\"\r\n    }, \r\n    INPUT = new Input()\r\n    {\r\n        foo=\"bar\"\r\n    }\r\n};\r\n\r\nvar json = JsonSerializer.Serialize(obj);\r\n```\r\n\r\nI do get my expected JSON string:\r\n```json\r\n{\"input\":{\"foo\":\"bar\"},\"INPUT\":{\"foo\":\"bar\"}}\r\n```\n\n### Configuration\n\n```\r\n$ dotnet --info\r\n.NET SDK (reflecting any global.json):\r\n Version:   6.0.405\r\n Commit:    27ab36058b\r\n\r\nRuntime Environment:\r\n OS Name:     debian\r\n OS Version:  11\r\n OS Platform: Linux\r\n RID:         debian.11-x64\r\n Base Path:   /usr/share/dotnet/sdk/6.0.405/\r\n\r\nglobal.json file:\r\n  /workspaces/bipsli/global.json\r\n\r\nHost:\r\n  Version:      6.0.13\r\n  Architecture: x64\r\n  Commit:       1af80ba017\r\n\r\n.NET SDKs installed:\r\n  6.0.405 [/usr/share/dotnet/sdk]\r\n\r\n.NET runtimes installed:\r\n  Microsoft.AspNetCore.App 6.0.13 [/usr/share/dotnet/shared/Microsoft.AspNetCore.App]\r\n  Microsoft.NETCore.App 6.0.13 [/usr/share/dotnet/shared/Microsoft.NETCore.App]\r\n```\n\n### Other information\n\nI posted this same question to StackOverflow where it was suggested that I open an issue here.\r\nhttps://stackoverflow.com/questions/75317065/exception-serializing-anonymous-type-to-json-when-nested-property-names-are-the",
    "number": 81550,
    "reactions": {
      "hasNextPage": false,
      "nodes": [],
      "totalCount": 0,
      "endCursor": null
    },
    "updatedAt": "2023-02-03T15:26:11Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\n### Description\n\nUpgrading my project from .netcore 3.1 to .net6 I came across one of my tests failing due to a change in how JsonSerializer.Serialize will serialize an anonymous type.  \n\n### Reproduction Steps\n\n```c#\r\nvar obj = new \r\n{\r\n  input = new {\r\n    foo = \"foo\"\r\n  },\r\n  INPUT = new {\r\n    foo = \"foo\"\r\n  }\r\n};\r\n\r\nvar json = JsonSerializer.Serialize(obj); // throws an exception\r\n```\n\n### Expected behavior\n\nIn .netcore 3.1 the above would have returned:\r\n\r\n```json\r\n{\"input\":{\"foo\":\"bar\"},\"INPUT\":{\"foo\":\"bar\"}}\r\n```\n\n### Actual behavior\n\nIn .net5+ this exception is thrown instead:\r\n\r\n```\r\nUnhandled exception. System.InvalidOperationException: Members 'input' and 'INPUT' on type '<>f__AnonymousType2`2[<>f__AnonymousType1`1[System.String],<>f__AnonymousType1`1[System.String]]' cannot both bind with parameter 'input' in the deserialization constructor.\r\n   at System.Text.Json.ThrowHelper.ThrowInvalidOperationException_MultiplePropertiesBindToConstructorParameters(Type parentType, String parameterName, String firstMatchName, String secondMatchName)\r\n   at System.Text.Json.Serialization.Metadata.JsonTypeInfo.InitializeConstructorParameters(JsonParameterInfoValues[] jsonParameters, Boolean sourceGenMode)\r\n   at System.Text.Json.Serialization.Metadata.JsonTypeInfo..ctor(Type type, JsonConverter converter, Type runtimeType, JsonSerializerOptions options)\r\n   at System.Text.Json.JsonSerializerOptions.<InitializeForReflectionSerializer>g__CreateJsonTypeInfo|112_0(Type type, JsonSerializerOptions options)\r\n   at System.Text.Json.JsonSerializerOptions.GetClassFromContextOrCreate(Type type)\r\n   at System.Text.Json.JsonSerializerOptions.GetOrAddClass(Type type)\r\n   at System.Text.Json.JsonSerializer.GetTypeInfo(JsonSerializerOptions options, Type runtimeType)\r\n   at System.Text.Json.JsonSerializer.Serialize[TValue](TValue value, JsonSerializerOptions options)\r\n```\r\n\r\nUnhandled exception. System.InvalidOperationException: Members 'input' and 'INPUT' on type '<>f__AnonymousType2`2[<>f__AnonymousType1`1[System.String],<>f__AnonymousType1`1[System.String]]' cannot both bind with parameter 'input' in the deserialization constructor.\n\n### Regression?\n\nWorked as I expected in .netcore 3.1 but not in .net5+\n\n### Known Workarounds\n\nIf I were to create a class to represent my anonymous type instead, then I do receive the expected JSON string.\r\n\r\n```c#\r\npublic sealed class Obj\r\n{\r\n    public Input input {get; set;}\r\n    public Input INPUT {get; set;}\r\n}\r\n\r\npublic sealed class Input\r\n{\r\n    public string foo {get;set;}\t\r\n}\r\n\r\n```\r\n\r\nAnd instantiate similar to my anonymous type:\r\n```c#\r\nvar obj = new Obj()\r\n{\r\n    input = new Input()\r\n    {\r\n        foo=\"bar\"\r\n    }, \r\n    INPUT = new Input()\r\n    {\r\n        foo=\"bar\"\r\n    }\r\n};\r\n\r\nvar json = JsonSerializer.Serialize(obj);\r\n```\r\n\r\nI do get my expected JSON string:\r\n```json\r\n{\"input\":{\"foo\":\"bar\"},\"INPUT\":{\"foo\":\"bar\"}}\r\n```\n\n### Configuration\n\n```\r\n$ dotnet --info\r\n.NET SDK (reflecting any global.json):\r\n Version:   6.0.405\r\n Commit:    27ab36058b\r\n\r\nRuntime Environment:\r\n OS Name:     debian\r\n OS Version:  11\r\n OS Platform: Linux\r\n RID:         debian.11-x64\r\n Base Path:   /usr/share/dotnet/sdk/6.0.405/\r\n\r\nglobal.json file:\r\n  /workspaces/bipsli/global.json\r\n\r\nHost:\r\n  Version:      6.0.13\r\n  Architecture: x64\r\n  Commit:       1af80ba017\r\n\r\n.NET SDKs installed:\r\n  6.0.405 [/usr/share/dotnet/sdk]\r\n\r\n.NET runtimes installed:\r\n  Microsoft.AspNetCore.App 6.0.13 [/usr/share/dotnet/shared/Microsoft.AspNetCore.App]\r\n  Microsoft.NETCore.App 6.0.13 [/usr/share/dotnet/shared/Microsoft.NETCore.App]\r\n```\n\n### Other information\n\nI posted this same question to StackOverflow where it was suggested that I open an issue here.\r\nhttps://stackoverflow.com/questions/75317065/exception-serializing-anonymous-type-to-json-when-nested-property-names-are-the\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>dbaghdanov</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`area-System.Text.Json`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2023-02-02T17:36:46Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-02-02T17:36:46Z",
          "id": "IC_kwDODI9FZc5UScNS"
        },
        {
          "author": "eiriktsarpalis",
          "body": "I can reproduce. This appears to have been caused by the introduction of constructor deserialization support. Constructor deserialization will attempt to bind constructor parameters to properties using case insensitive comparison, so if the type uses two properties with different casing it will fail at that binding phase. We should consider relaxing this restriction in line with work in #71944.\r\n\r\nIn the meantime, it should be possible to work around your issue using classes instead of anonymous types when you serialize.",
          "createdAt": "2023-02-03T15:25:11Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-02-03T16:34:05Z",
                "user": "dbaghdanov"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOC1aLkA=="
          },
          "updatedAt": "2023-02-03T15:26:11Z",
          "id": "IC_kwDODI9FZc5UZtBV"
        }
      ],
      "totalCount": 2,
      "endCursor": "Y3Vyc29yOnYyOpHOVGbQVQ=="
    },
    "url": "https://github.com/dotnet/runtime/issues/81550",
    "title": "JsonSerializer.Serialize an anonymous type, with duplicate nested names throws an unexpected exception"
  },
  {
    "author": "Legends",
    "labels": [
      "area-System.Text.Json"
    ],
    "createdAt": "2023-02-08T19:31:01Z",
    "body": "I have created a named pipe server (console app, .NET 7):\r\n\r\n```\r\nusing var server = new NamedPipeServerStream(\r\n                                    \"hostpipe\",\r\n                                    PipeDirection.InOut,\r\n                                    NamedPipeServerStream.MaxAllowedServerInstances,\r\n                                    PipeTransmissionMode.Message,\r\n                                    PipeOptions.Asynchronous);\r\n```\r\n\r\nthat spawns a child process (client console app, .NET 7) which creates a `NamedPipeClientStream` :\r\n\r\n``` using var client = new NamedPipeClientStream(\".\", pipeName, PipeDirection.InOut, PipeOptions.Asynchronous);``` \r\n\r\n**Problem:**\r\nFor example I want to message an object from the server to the client like:\r\n\r\nServer writes:\r\n```\r\npublic static async Task WriteMessageAsyncAsObject<T>(PipeStream pipe, T obj)\r\n{\r\n    await JsonSerializer.SerializeAsync<T>(pipe, obj); // works!\r\n }\r\n```\r\n\r\nand the client should read the incoming \"object\" (following code does not work, DeserializeAsync is blocking):\r\n```\r\npublic static async Task<T?> ReadMessageAsyncAsObject<T>(PipeStream pipe)\r\n{\r\n    // var bt = await ReadMessageAsync(pipe);\r\n    // var obj = JsonSerializer.Deserialize<T>(bt);\r\n    // return await Task.FromResult(obj);\r\n    return await JsonSerializer.DeserializeAsync<T>(pipe);  // doesn't work, the program stops here, it is blocked!\r\n}\r\n```\r\n\r\nBut if I replace `JsonSerializer.DeserializeAsync<T>` on the clientside with the following (this code here works, does not block):\r\n```\r\npublic static async Task<T?> ReadMessageAsyncAsObject<T>(PipeStream pipe)\r\n{\r\n    var bt = await ReadMessageAsync(pipe);  // reads the stream result asynchronously into a MemoryStream, which returns a byte[]\r\n    var obj = JsonSerializer.Deserialize<T>(bt);  // works now, but synchronous!\r\n    return await Task.FromResult(obj);\r\n    //return await JsonSerializer.DeserializeAsync<T>(pipe);  \r\n}\r\n```\r\n\r\n\r\nWhy is `await JsonSerializer.DeserializeAsync<T>` blocking on the clientside?\r\n\r\n\r\n\r\n",
    "number": 81840,
    "reactions": {
      "hasNextPage": false,
      "nodes": [],
      "totalCount": 0,
      "endCursor": null
    },
    "updatedAt": "2025-08-02T20:36:59Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @dotnet/ncl\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\n\r\nI have created a named pipe server (console app, .NET 7):\r\n\r\n```\r\nusing var server = new NamedPipeServerStream(\r\n                                                            \"hostpipe\",\r\n                                                            PipeDirection.InOut,\r\n                                                            NamedPipeServerStream.MaxAllowedServerInstances,\r\n                                                            PipeTransmissionMode.Message,\r\n                                                            PipeOptions.Asynchronous);\r\n```\r\n\r\nthat spawns a child process which creates a `NamedPipeClientStream? :\r\n`using var client = new NamedPipeClientStream(\".\", pipeName, PipeDirection.InOut, PipeOptions.Asynchronous);`\r\n\r\n**Problem:**\r\nFor example I want to message an object from the server to the client like:\r\n\r\nServer writes:\r\npublic static async Task WriteMessageAsyncAsObject<T>(PipeStream pipe, T obj)\r\n{\r\n    await JsonSerializer.SerializeAsync<T>(pipe, obj); // works!\r\n }\r\n\r\nand the client should read:\r\n public static async Task<T?> ReadMessageAsyncAsObject<T>(PipeStream pipe)\r\n        {\r\n            // var bt = await ReadMessageAsync(pipe);\r\n            // var obj = JsonSerializer.Deserialize<T>(bt);\r\n            // return await Task.FromResult(obj);\r\n            return await JsonSerializer.DeserializeAsync<T>(pipe);  // doesn't work, the program stops here, it is blocked!\r\n        }\r\n\r\nBut if I replace `JsonSerializer.DeserializeAsync<T>` on the clientside with the following:\r\n```\r\npublic static async Task<T?> ReadMessageAsyncAsObject<T>(PipeStream pipe)\r\n{\r\n    var bt = await ReadMessageAsync(pipe);  // reads the stream result asynchronously into a MemoryStream, which returns a byte[]\r\n    var obj = JsonSerializer.Deserialize<T>(bt);  // works now, but synchronous!\r\n    return await Task.FromResult(obj);\r\n    //return await JsonSerializer.DeserializeAsync<T>(pipe);  \r\n}\r\n```\r\n\r\n\r\n**Why is `JsonSerializer.DeserializeAsync<T>` blocking on the clientside?**\r\n\r\n\r\n\r\n\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>Legends</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`area-System.Net.Http`, `untriaged`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2023-02-08T19:31:08Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-02-08T19:31:08Z",
          "id": "IC_kwDODI9FZc5U00w5"
        },
        {
          "author": null,
          "body": "Tagging subscribers to this area: @dotnet/area-system-io\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\nI have created a named pipe server (console app, .NET 7):\r\n\r\n```\r\nusing var server = new NamedPipeServerStream(\r\n                                    \"hostpipe\",\r\n                                    PipeDirection.InOut,\r\n                                    NamedPipeServerStream.MaxAllowedServerInstances,\r\n                                    PipeTransmissionMode.Message,\r\n                                    PipeOptions.Asynchronous);\r\n```\r\n\r\nthat spawns a child process (client console app, .NET 7) which creates a `NamedPipeClientStream` :\r\n\r\n``` using var client = new NamedPipeClientStream(\".\", pipeName, PipeDirection.InOut, PipeOptions.Asynchronous);``` \r\n\r\n**Problem:**\r\nFor example I want to message an object from the server to the client like:\r\n\r\nServer writes:\r\n```\r\npublic static async Task WriteMessageAsyncAsObject<T>(PipeStream pipe, T obj)\r\n{\r\n    await JsonSerializer.SerializeAsync<T>(pipe, obj); // works!\r\n }\r\n```\r\n\r\nand the client should read the incoming \"object\" (following code does not work, DeserializeAsync is blocking):\r\n```\r\npublic static async Task<T?> ReadMessageAsyncAsObject<T>(PipeStream pipe)\r\n{\r\n    // var bt = await ReadMessageAsync(pipe);\r\n    // var obj = JsonSerializer.Deserialize<T>(bt);\r\n    // return await Task.FromResult(obj);\r\n    return await JsonSerializer.DeserializeAsync<T>(pipe);  // doesn't work, the program stops here, it is blocked!\r\n}\r\n```\r\n\r\nBut if I replace `JsonSerializer.DeserializeAsync<T>` on the clientside with the following (this code here works, does not block):\r\n```\r\npublic static async Task<T?> ReadMessageAsyncAsObject<T>(PipeStream pipe)\r\n{\r\n    var bt = await ReadMessageAsync(pipe);  // reads the stream result asynchronously into a MemoryStream, which returns a byte[]\r\n    var obj = JsonSerializer.Deserialize<T>(bt);  // works now, but synchronous!\r\n    return await Task.FromResult(obj);\r\n    //return await JsonSerializer.DeserializeAsync<T>(pipe);  \r\n}\r\n```\r\n\r\n\r\nWhy is `await JsonSerializer.DeserializeAsync<T>` blocking on the clientside?\r\n\r\n\r\n\r\n\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>Legends</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`area-System.IO`, `untriaged`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2023-02-13T23:20:12Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-02-13T23:20:12Z",
          "id": "IC_kwDODI9FZc5VKnps"
        },
        {
          "author": "wfurt",
          "body": "I don't think this is IO problem since `ReadMessageAsync` works fine according to description. \r\nThis is similar to https://github.com/dotnet/runtime/issues/73097 and we end up fixing it in HTTP. \r\n",
          "createdAt": "2023-02-14T16:38:07Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-02-14T16:38:07Z",
          "id": "IC_kwDODI9FZc5VPL9U"
        },
        {
          "author": null,
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\nI have created a named pipe server (console app, .NET 7):\r\n\r\n```\r\nusing var server = new NamedPipeServerStream(\r\n                                    \"hostpipe\",\r\n                                    PipeDirection.InOut,\r\n                                    NamedPipeServerStream.MaxAllowedServerInstances,\r\n                                    PipeTransmissionMode.Message,\r\n                                    PipeOptions.Asynchronous);\r\n```\r\n\r\nthat spawns a child process (client console app, .NET 7) which creates a `NamedPipeClientStream` :\r\n\r\n``` using var client = new NamedPipeClientStream(\".\", pipeName, PipeDirection.InOut, PipeOptions.Asynchronous);``` \r\n\r\n**Problem:**\r\nFor example I want to message an object from the server to the client like:\r\n\r\nServer writes:\r\n```\r\npublic static async Task WriteMessageAsyncAsObject<T>(PipeStream pipe, T obj)\r\n{\r\n    await JsonSerializer.SerializeAsync<T>(pipe, obj); // works!\r\n }\r\n```\r\n\r\nand the client should read the incoming \"object\" (following code does not work, DeserializeAsync is blocking):\r\n```\r\npublic static async Task<T?> ReadMessageAsyncAsObject<T>(PipeStream pipe)\r\n{\r\n    // var bt = await ReadMessageAsync(pipe);\r\n    // var obj = JsonSerializer.Deserialize<T>(bt);\r\n    // return await Task.FromResult(obj);\r\n    return await JsonSerializer.DeserializeAsync<T>(pipe);  // doesn't work, the program stops here, it is blocked!\r\n}\r\n```\r\n\r\nBut if I replace `JsonSerializer.DeserializeAsync<T>` on the clientside with the following (this code here works, does not block):\r\n```\r\npublic static async Task<T?> ReadMessageAsyncAsObject<T>(PipeStream pipe)\r\n{\r\n    var bt = await ReadMessageAsync(pipe);  // reads the stream result asynchronously into a MemoryStream, which returns a byte[]\r\n    var obj = JsonSerializer.Deserialize<T>(bt);  // works now, but synchronous!\r\n    return await Task.FromResult(obj);\r\n    //return await JsonSerializer.DeserializeAsync<T>(pipe);  \r\n}\r\n```\r\n\r\n\r\nWhy is `await JsonSerializer.DeserializeAsync<T>` blocking on the clientside?\r\n\r\n\r\n\r\n\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>Legends</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`area-System.Text.Json`, `untriaged`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2023-02-17T23:30:55Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-02-17T23:30:55Z",
          "id": "IC_kwDODI9FZc5Vjl6W"
        },
        {
          "author": "jozkee",
          "body": "I wasn't able to repro this. Perhaps, there's something special about the type you are serializing.\r\n\r\nProgram 1:\r\n```cs\r\nusing System.Diagnostics;\r\nusing System.IO.Pipes;\r\nusing System.Text.Json;\r\n\r\nnamespace ConsoleApp4\r\n{\r\n    internal class Program\r\n    {\r\n        static async Task Main(string[] args)\r\n        {\r\n            Console.WriteLine(\"Hello, World!\");\r\n\r\n            using var server = new NamedPipeServerStream(\r\n                                    \"hostpipe\",\r\n                                    PipeDirection.InOut,\r\n                                    NamedPipeServerStream.MaxAllowedServerInstances,\r\n                                    PipeTransmissionMode.Message,\r\n                                    PipeOptions.Asynchronous);\r\n\r\n            using Process p = Process.Start(@\"C:\\consoleapps\\ConsoleApp5\\ConsoleApp5\\bin\\Debug\\net7.0\\ConsoleApp5.exe\");\r\n            server.WaitForConnection();\r\n\r\n            var person = new Person\r\n            {\r\n                Age = 42,\r\n                Name = \"Foo\",\r\n            };\r\n            await WriteMessageAsyncAsObject(server, person);\r\n        }\r\n\r\n        public static async Task WriteMessageAsyncAsObject<T>(PipeStream pipe, T obj)\r\n        {\r\n            await JsonSerializer.SerializeAsync<T>(pipe, obj); // works!\r\n        }\r\n    }\r\n\r\n    internal class Person\r\n    {\r\n        public int Age { get; set; }\r\n        public string Name { get; set; }\r\n    }\r\n}\r\n```\r\n\r\nProgram2:\r\n```cs\r\nusing System.Diagnostics;\r\nusing System.IO.Pipes;\r\nusing System.Text.Json;\r\n\r\nnamespace ConsoleApp5\r\n{\r\n    internal class Program\r\n    {\r\n        static async Task Main(string[] args)\r\n        {\r\n            Console.WriteLine(\"Hello, World!\");\r\n\r\n            using var client = new NamedPipeClientStream(\".\", \"hostpipe\", PipeDirection.InOut, PipeOptions.Asynchronous);\r\n            client.Connect();\r\n\r\n            var r = await ReadMessageAsyncAsObject<Person>(client);\r\n\r\n            Console.WriteLine(r.Age);\r\n            Console.WriteLine(r.Name);\r\n        }\r\n\r\n        public static async Task<T?> ReadMessageAsyncAsObject<T>(PipeStream pipe)\r\n        {\r\n            // var bt = await ReadMessageAsync(pipe);\r\n            // var obj = JsonSerializer.Deserialize<T>(bt);\r\n            // return await Task.FromResult(obj);\r\n            return await JsonSerializer.DeserializeAsync<T>(pipe);  // doesn't work, the program stops here, it is blocked!\r\n        }\r\n    }\r\n\r\n    internal class Person\r\n    {\r\n        public int Age { get; set; }\r\n        public string Name { get; set; }\r\n    }\r\n}\r\n```\r\n\r\nOutput:\r\n```\r\nHello, World!\r\nHello, World!\r\n42\r\nFoo\r\n```",
          "createdAt": "2023-02-17T23:36:48Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-02-17T23:36:48Z",
          "id": "IC_kwDODI9FZc5VjmnJ"
        },
        {
          "author": null,
          "body": "This issue has been marked `needs-author-action` and may be missing some important information.",
          "createdAt": "2023-02-17T23:37:01Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-02-17T23:37:01Z",
          "id": "IC_kwDODI9FZc5Vjmov"
        },
        {
          "author": "wfurt",
          "body": "It may be the size @Jozkee. If you are on it, I would try something that would perhaps fill the pipe buffers  - maybe 100k ish.",
          "createdAt": "2023-02-17T23:38:48Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-02-17T23:38:48Z",
          "id": "IC_kwDODI9FZc5Vjm1O"
        },
        {
          "author": "jozkee",
          "body": "@wfurt gave it a quick try with `new NamedPipeServerStream(..., inBufferSize: 1, outBufferSize: 1)`, no error. Also tried serializing a `new Person { Age = 42, Name = new string('a', 100_000) }`, still no error :/. \r\n\r\nWould be nice to hear back from OP and see if he/she can provide a repro.",
          "createdAt": "2023-02-17T23:47:43Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-02-17T23:47:43Z",
          "id": "IC_kwDODI9FZc5VjnuV"
        },
        {
          "author": "Legends",
          "body": "I have created a reproduction repo [here](https://github.com/Legends/Blocking-Issue).\r\n\r\nAt first glance I can only see the following differences between your code and the repro:\r\n\r\n- On the client I additionally have: ` client.ReadMode = PipeTransmissionMode.Message;`\r\n- and async connect waits: => `ConnectAsync / WaitForConnectionAsync `.\r\n\r\n\r\n\r\n\r\n\r\n",
          "createdAt": "2023-02-18T06:01:40Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-02-18T07:38:51Z",
          "id": "IC_kwDODI9FZc5Vj-fu"
        },
        {
          "author": "eiriktsarpalis",
          "body": "I can reproduce the issue, the application hangs when the serializer tries to read the underlying stream for a second time here:\r\n\r\nhttps://github.com/dotnet/runtime/blob/f4ad730ac2c3f06fe68a3041c21590ef9de1b8c2/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/ReadBufferState.cs#L51-L57\r\n\r\nThe underlying implementation in Windows is this method:\r\n\r\nhttps://github.com/dotnet/runtime/blob/f4ad730ac2c3f06fe68a3041c21590ef9de1b8c2/src/libraries/System.IO.Pipes/src/System/IO/Pipes/PipeStream.Windows.cs#L314-L366\r\n\r\nWithout looking much into the code, I suspect there might be an issue with the `ReadWriteValueTaskSource` implementation that prevents the STJ callback from being scheduled appropriately.",
          "createdAt": "2023-02-20T13:46:03Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-02-20T13:47:04Z",
          "id": "IC_kwDODI9FZc5Vp6Mf"
        },
        {
          "author": null,
          "body": "Tagging subscribers to this area: @dotnet/area-system-io\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\nI have created a named pipe server (console app, .NET 7):\r\n\r\n```\r\nusing var server = new NamedPipeServerStream(\r\n                                    \"hostpipe\",\r\n                                    PipeDirection.InOut,\r\n                                    NamedPipeServerStream.MaxAllowedServerInstances,\r\n                                    PipeTransmissionMode.Message,\r\n                                    PipeOptions.Asynchronous);\r\n```\r\n\r\nthat spawns a child process (client console app, .NET 7) which creates a `NamedPipeClientStream` :\r\n\r\n``` using var client = new NamedPipeClientStream(\".\", pipeName, PipeDirection.InOut, PipeOptions.Asynchronous);``` \r\n\r\n**Problem:**\r\nFor example I want to message an object from the server to the client like:\r\n\r\nServer writes:\r\n```\r\npublic static async Task WriteMessageAsyncAsObject<T>(PipeStream pipe, T obj)\r\n{\r\n    await JsonSerializer.SerializeAsync<T>(pipe, obj); // works!\r\n }\r\n```\r\n\r\nand the client should read the incoming \"object\" (following code does not work, DeserializeAsync is blocking):\r\n```\r\npublic static async Task<T?> ReadMessageAsyncAsObject<T>(PipeStream pipe)\r\n{\r\n    // var bt = await ReadMessageAsync(pipe);\r\n    // var obj = JsonSerializer.Deserialize<T>(bt);\r\n    // return await Task.FromResult(obj);\r\n    return await JsonSerializer.DeserializeAsync<T>(pipe);  // doesn't work, the program stops here, it is blocked!\r\n}\r\n```\r\n\r\nBut if I replace `JsonSerializer.DeserializeAsync<T>` on the clientside with the following (this code here works, does not block):\r\n```\r\npublic static async Task<T?> ReadMessageAsyncAsObject<T>(PipeStream pipe)\r\n{\r\n    var bt = await ReadMessageAsync(pipe);  // reads the stream result asynchronously into a MemoryStream, which returns a byte[]\r\n    var obj = JsonSerializer.Deserialize<T>(bt);  // works now, but synchronous!\r\n    return await Task.FromResult(obj);\r\n    //return await JsonSerializer.DeserializeAsync<T>(pipe);  \r\n}\r\n```\r\n\r\n\r\nWhy is `await JsonSerializer.DeserializeAsync<T>` blocking on the clientside?\r\n\r\n\r\n\r\n\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>Legends</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`area-System.IO`, `needs-further-triage`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2023-02-20T13:46:44Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-02-20T13:46:44Z",
          "id": "IC_kwDODI9FZc5Vp6ZW"
        },
        {
          "author": "stephentoub",
          "body": "@eiriktsarpalis, I'm not sure why this would be considered a System.IO.Pipes problem.  The JsonSerializer.DeserializeAsync enters this loop:\r\nhttps://github.com/dotnet/runtime/blob/ac7afb9ccb88b895eeb3264e38ab22d0c5d726ec/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/ReadBufferState.cs#L49-L67\r\nIt reads the 50 bytes the server sent (which is the entire message sent by the server) and checks the while loop condition.  The `fillBuffer` argument is defaulting to `true`, so since it only read 50 bytes and was given a 16384 byte buffer, it loops around again to perform another read, which hangs, because there's nothing more to read (but it's not EOF because the Stream is still open for continued duplex communication).",
          "createdAt": "2023-02-20T19:34:44Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-02-21T06:46:56Z",
                "user": "adamsitnik"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-02-28T07:58:05Z",
                "user": "Legends"
              }
            ],
            "totalCount": 2,
            "endCursor": "Y3Vyc29yOnYyOpHOC24Inw=="
          },
          "updatedAt": "2023-02-20T19:37:33Z",
          "id": "IC_kwDODI9FZc5VrgOZ"
        },
        {
          "author": null,
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\nI have created a named pipe server (console app, .NET 7):\r\n\r\n```\r\nusing var server = new NamedPipeServerStream(\r\n                                    \"hostpipe\",\r\n                                    PipeDirection.InOut,\r\n                                    NamedPipeServerStream.MaxAllowedServerInstances,\r\n                                    PipeTransmissionMode.Message,\r\n                                    PipeOptions.Asynchronous);\r\n```\r\n\r\nthat spawns a child process (client console app, .NET 7) which creates a `NamedPipeClientStream` :\r\n\r\n``` using var client = new NamedPipeClientStream(\".\", pipeName, PipeDirection.InOut, PipeOptions.Asynchronous);``` \r\n\r\n**Problem:**\r\nFor example I want to message an object from the server to the client like:\r\n\r\nServer writes:\r\n```\r\npublic static async Task WriteMessageAsyncAsObject<T>(PipeStream pipe, T obj)\r\n{\r\n    await JsonSerializer.SerializeAsync<T>(pipe, obj); // works!\r\n }\r\n```\r\n\r\nand the client should read the incoming \"object\" (following code does not work, DeserializeAsync is blocking):\r\n```\r\npublic static async Task<T?> ReadMessageAsyncAsObject<T>(PipeStream pipe)\r\n{\r\n    // var bt = await ReadMessageAsync(pipe);\r\n    // var obj = JsonSerializer.Deserialize<T>(bt);\r\n    // return await Task.FromResult(obj);\r\n    return await JsonSerializer.DeserializeAsync<T>(pipe);  // doesn't work, the program stops here, it is blocked!\r\n}\r\n```\r\n\r\nBut if I replace `JsonSerializer.DeserializeAsync<T>` on the clientside with the following (this code here works, does not block):\r\n```\r\npublic static async Task<T?> ReadMessageAsyncAsObject<T>(PipeStream pipe)\r\n{\r\n    var bt = await ReadMessageAsync(pipe);  // reads the stream result asynchronously into a MemoryStream, which returns a byte[]\r\n    var obj = JsonSerializer.Deserialize<T>(bt);  // works now, but synchronous!\r\n    return await Task.FromResult(obj);\r\n    //return await JsonSerializer.DeserializeAsync<T>(pipe);  \r\n}\r\n```\r\n\r\n\r\nWhy is `await JsonSerializer.DeserializeAsync<T>` blocking on the clientside?\r\n\r\n\r\n\r\n\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>Legends</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`area-System.Text.Json`, `needs-further-triage`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2023-02-20T19:58:13Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-02-20T19:58:13Z",
          "id": "IC_kwDODI9FZc5VrlrK"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Ah yes, the async deserializer generally assumes that the stream only contains a single JSON document and will always try to fill its internal buffer up to capacity or EOF _before_ it starts deserializing. This is due to how async converters are designed and was meant to improve deserialization performance.\r\n\r\nEven though the internal buffer size can be controlled via the `JsonSerializerOptions.DefaultBufferSize` property, setting this to a smaller number would still make deserialization susceptible to the same hangs under [certain circumstances](https://github.com/dotnet/runtime/blob/ac7afb9ccb88b895eeb3264e38ab22d0c5d726ec/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/ReadBufferState.cs#L114-L130). Deserialization could also fail if it detects [trailing data after the first complete JSON document](https://github.com/dotnet/runtime/blob/463954dbc728470fb21a097188fc3dae91f6cbe4/src/libraries/System.Text.Json/src/System/Text/Json/Reader/Utf8JsonReader.cs#L1731-L1734).\r\n\r\nTL;DR the `DeserializeAsync` methods have not been designed to read from streams that represent channels and which could contain multiple values. The `DeserializeAsyncEnumerable` method does support this (and does not impose the same \"fillBuffer\" semantics) although it imposes certain constraints (the stream must be one JSON array) and it would make your application much less straightforward to implement. Alternatively you might want to consider filling a buffer manually and passing that to one of the sync `Deserialize` methods, although some work\r\n\r\nIn the future it might be possible to support your scenario in the regular `DeserializeAsync` methods by adding:\r\n\r\n1. A `JsonSerializerOptions` flag that disables \"fillBuffer\" semantics.\r\n2. A `JsonSerializerOptions` flag that disables failures if the stream contains trailing data.\r\n\r\nRelated to #36750, #33030.",
          "createdAt": "2023-02-21T10:42:08Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-02-28T07:56:24Z",
                "user": "Legends"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOC24IKA=="
          },
          "updatedAt": "2023-02-21T10:42:08Z",
          "id": "IC_kwDODI9FZc5Vuful"
        },
        {
          "author": "RobinHSanner",
          "body": "I was having the same issue and resolved it by liberally sprinkling .ConfigureAwait(false) sauce on everything in the call chain.",
          "createdAt": "2025-08-02T20:36:59Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-08-02T20:36:59Z",
          "id": "IC_kwDODI9FZc67jwdT"
        }
      ],
      "totalCount": 15,
      "endCursor": "Y3Vyc29yOnYyOpHOu48HUw=="
    },
    "url": "https://github.com/dotnet/runtime/issues/81840",
    "title": "Question: Named pipes: await JsonSerializer.DeserializeAsync<T> blocks, when reading from Named pipe"
  },
  {
    "author": "Sergio0694",
    "labels": [
      "area-System.Text.Json",
      "source-generator"
    ],
    "createdAt": "2023-02-11T18:34:55Z",
    "body": "### Description\r\n\r\nWhile continuing the migration of the Microsoft Store to System.Text.Json (we're getting there! 😄), I'm now migrating some unstructured JSON data we have (which currently deserializes to a dictionary and then uses a whole bunch of manual lookups, which is pretty bad), to instead using proper strongly typed models with System.Text.Json. Due to how some of these models are crafted, we end up needing a few custom converters to make the whole thing work correctly. This is fine, but I've noticed some weird interplay between custom converters and the JSON source generators that I'm not sure is by design, so I figured I'd ask 🙂\r\n\r\n### Reproduction Steps\r\n\r\nConsider this:\r\n\r\n```csharp\r\n[JsonSerializable(typeof(A))]\r\npublic partial class MyContext : JsonSerializerContext\r\n{\r\n}\r\n\r\n[JsonConverter(typeof(AConverter))]\r\npublic class A\r\n{\r\n    public B B { get; set; }\r\n}\r\n\r\npublic class B\r\n{\r\n}\r\n\r\npublic class AConverter : JsonConverter<A>\r\n{\r\n    public override A? Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)\r\n    {\r\n        throw new NotImplementedException();\r\n    }\r\n\r\n    public override void Write(Utf8JsonWriter writer, A value, JsonSerializerOptions options)\r\n    {\r\n        throw new NotImplementedException();\r\n    }\r\n}\r\n```\r\n\r\nIn this case, `AConverter` will deserialize `A` instances, with some custom logic. As part of this, it will also create a `B` instance by deserializing the corresponding property in the JSON. That is, after moving the reader to the start of the object token, it'll just call `JsonSerializer.DeserializeObject<B>(ref reader, options)`. We use this pattern extensively in our JSON contracts.\r\n\r\n### Expected behavior\r\n\r\nI wouldn't expend the annotation to cause the source generator to stop traversing the type hierarchy.\r\n\r\n### Actual behavior\r\n\r\nIf you annotate `A` with `[JsonSerializable(typeof(A))]`, the JSON source generator will stop crawling properties, and as a result the metadata for `B` and derived types will not be generated. Thus, trying to deserialize `A` will throw at runtime.\r\n\r\n### Regression?\r\n\r\nDon't think so.\r\n\r\n### Known Workarounds\r\n\r\nA workaround is to manually also specify `[JsonSerializable(typeof(B))]` on the JSON context. This works, but is pretty error prone, as it requires consumers to not just annotate the types they want to deserialize on their end, but also **all types that are skipped by the generator due to the internal implementation detail of how the JSON models are defined**.\r\n\r\nI can understand if this is by design to potentially save unnecessary metadata (say, if the custom converter never created that instance through a JSON serialization API, but rather manually through other means), but the resulting behavior is not ideal for consumers. Would it be possible **for the contract author** to somehow inform the generator that if someone marks the root type as being serialized, then the metadata for also X property (or properties) should be generated?\r\n\r\nThis would allow both to keep the current behavior and save metadata, while at the same time allowing authors of these contracts to make the behavior transparent and avoid nasty surprises on the consumer side.\r\n\r\nFor instance: it would be nice if you could add `[JsonSerializable(typeof(B))]` over `B` in this case so that the source generator could see that \"ok this type has a custom serializer so I'll stop traversing the hierarchy _but_ I'll keep gathering metadata for these additional types that you have specified, sure\". Would that make sense? 🙂\r\n\r\ncc. @eiriktsarpalis",
    "number": 82001,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-01-26T18:58:23Z",
          "user": "0xfeeddeadbeef"
        }
      ],
      "totalCount": 1,
      "endCursor": "Y3Vyc29yOnYyOpHOC1dZLA=="
    },
    "updatedAt": "2023-06-15T16:53:02Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\n### Description\n\nWhile continuing the migration of the Microsoft Store to System.Text.Json (we're getting there! 😄), I'm now migrating some unstructured JSON data we have (which currently deserializes to a dictionary and then uses a whole bunch of manual lookups, which is pretty bad), to instead using proper strongly typed models with System.Text.Json. Due to how some of these models are crafted, we end up needing a few custom converters to make the whole thing work correctly. This is fine, but I've noticed some weird interplay between custom converters and the JSON source generators that I'm not sure is by design, so I figured I'd ask 🙂\n\n### Reproduction Steps\n\nConsider this:\r\n\r\n```csharp\r\n[JsonSerializable(typeof(A))]\r\npublic partial class MyContext : JsonSerializerContext\r\n{\r\n}\r\n\r\n[JsonConverter(typeof(AConverter))]\r\npublic class A\r\n{\r\n    public B B { get; set; }\r\n}\r\n\r\npublic class B\r\n{\r\n}\r\n\r\npublic class AConverter : JsonConverter<A>\r\n{\r\n    public override A? Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)\r\n    {\r\n        throw new NotImplementedException();\r\n    }\r\n\r\n    public override void Write(Utf8JsonWriter writer, A value, JsonSerializerOptions options)\r\n    {\r\n        throw new NotImplementedException();\r\n    }\r\n}\r\n```\r\n\r\nIn this case, `AConverter` will deserialize `A` instances, with some custom logic. As part of this, it will also create a `B` instance by deserializing the corresponding property in the JSON. That is, after moving the reader to the start of the object token, it'll just call `JsonSerializer.DeserializeObject<B>(ref reader, options)`. We use this pattern extensively in our JSON contracts.\n\n### Expected behavior\n\nI wouldn't expend the annotation to cause the source generator to stop traversing the type hierarchy.\n\n### Actual behavior\n\nIf you annotate `A` with `[JsonSerializable(typeof(A))]`, the JSON source generator will stop crawling properties, and as a result the metadata for `B` and derived types will not be generated. Thus, trying to deserialize `A` will throw at runtime.\n\n### Regression?\n\nDon't think so.\n\n### Known Workarounds\n\nA workaround is to manually also specify `[JsonSerializable(typeof(B))]` on the JSON context. This works, but is pretty error prone, as it requires consumers to not just annotate the types they want to deserialize on their end, but also **all types that are skipped by the generator due to the internal implementation detail of how the JSON models are defined**.\r\n\r\nI can understand if this is by design to potentially save unnecessary metadata (say, if the custom converter never created that instance through a JSON serialization API, but rather manually through other means), but the resulting behavior is not ideal for consumers. Would it be possible **for the contract author** to somehow inform the generator that if someone marks the root type as being serialized, then the metadata for also X property (or properties) should be generated?\r\n\r\nThis would allow both to keep the current behavior and save metadata, while at the same time allowing authors of these contracts to make the behavior transparent and avoid nasty surprises on the consumer side.\r\n\r\nFor instance: it would be nice if you could add `[JsonSerializable(typeof(B))]` over `B` in this case so that the source generator could see that \"ok this type has a custom serializer so I'll stop traversing the hierarchy _but_ I'll keep gathering metadata for these additional types that you have specified, sure\". Would that make sense? 🙂\r\n\r\ncc. @eiriktsarpalis\n\n### Configuration\n\n_No response_\n\n### Other information\n\n_No response_\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>Sergio0694</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`area-System.Text.Json`, `untriaged`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2023-02-11T18:35:04Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-02-11T18:35:04Z",
          "id": "IC_kwDODI9FZc5VC_nB"
        },
        {
          "author": "eiriktsarpalis",
          "body": "You're right to point out that this is absolutely by-design and intended as a way to avoid unnecessary metadata generation. The source generator isn't able to tell what dependencies a custom converter may have so you're pretty much on your own when introducing them. Out of curiosity, what type of customization does your converter introduce? If it's just serializing properties as usual, could the same result be achieved using contract customization?\r\n\r\nAs a side note, we might want to relax that behaviour once https://github.com/dotnet/runtime/issues/63791 is implemented, as types specifying, say, `[JsonConverter(typeof(JsonObjectConverter))]` would need to have property metadata generated at compile time.",
          "createdAt": "2023-02-13T15:45:01Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-02-13T15:45:01Z",
          "id": "IC_kwDODI9FZc5VICEm"
        },
        {
          "author": "Sergio0694",
          "body": "Ah, yeah that makes sense, I think the current behavior is the best default 🙂\r\n\r\n> \"Out of curiosity, what type of customization does your converter introduce?\"\r\n\r\nWe currently have several custom converters, handling scenarios such as:\r\n- \"Payload converter\": this is used over an `object` property and internally has a mapping of type discriminators to strongly typed data models, and it simply parses the type discriminator and forwards to the correct serialization method. We can't just use the built-in type discriminator support here as there isn't a single type hierarchy here, but we have like 100+ different types to support that can be unrelated from each other.\r\n- \"Newtonsoft compatible bool converter\": deserializes a `bool` like with Newtonsoft (reads from both boolean tokens, `string`-s tokens with case invariant comparisons, or `null` (and returns `false`).\r\n- \"Resilient enum converter\": deserializes an enum as numeric value, `string` value with case invariant comparison, and returns `default` if the value isn't recognized (instead of throwing). This enables adding new enum values without breaking older clients (the built-in enum converter will instead throw if it finds a value that's not recognized).\r\n- \"Newtonsoft dictionary converter\": deserializes a dictionary and skips the type token (also see #82012).\r\n- \"Newtonsoft dictionary converter\": deserializes a list and skips the type token.\r\n- We also have a bunch of custom converters that deserialize list/dictionaries/objects from `string` values with custom formatting, often in ways that might not strictly speaking be standard JSON. For instance:\r\n  - Deserializing a `string` with a comma separated list of values, where every value might have an additional part after a given separator character, into a `Dictionary<string, object?>`.\r\n  - Deserializing a CSV `string` into a `List<string>`\r\n  - Deserializing a `string` containing another JSON serialized object, directly into that JSON model object.\r\n\r\n> \"could the same result be achieved using contract customization?\"\r\n\r\nNot sure, I haven't really ever used that feature in System.Text.Json so far. Might need to look into it 😄\r\n\r\n> \"we might want to relax that behaviour\"\r\n\r\nWould that mean letting the generator crawl everything, or would that have some opt-in mechanism like suggested here?",
          "createdAt": "2023-02-13T16:11:40Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-02-13T16:11:40Z",
          "id": "IC_kwDODI9FZc5VINl5"
        },
        {
          "author": "eiriktsarpalis",
          "body": "> > \"we might want to relax that behaviour\"\r\n> \r\n> Would that mean letting the generator crawl everything, or would that have some opt-in mechanism like suggested here?\r\n\r\nIn that case, the specific `JsonConverter` annotation would trigger opt in to a specific mode of metadata generation",
          "createdAt": "2023-02-13T16:23:13Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-02-13T16:25:15Z",
                "user": "Sergio0694"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOC19Tfg=="
          },
          "updatedAt": "2023-02-13T16:23:13Z",
          "id": "IC_kwDODI9FZc5VISm3"
        },
        {
          "author": "eiriktsarpalis",
          "body": "One possible workaround might be to specify the custom converter at run time rather than design time via the `JsonSerializerOptions.Converters` property.",
          "createdAt": "2023-06-15T16:53:02Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-06-15T16:53:02Z",
          "id": "IC_kwDODI9FZc5e-Yy6"
        }
      ],
      "totalCount": 5,
      "endCursor": "Y3Vyc29yOnYyOpHOXvmMug=="
    },
    "url": "https://github.com/dotnet/runtime/issues/82001",
    "title": "Annotating a type with a JSON converter blocks the JSON source generator crawling"
  },
  {
    "author": "CodeBlanch",
    "labels": [
      "area-System.Text.Json",
      "tenet-performance"
    ],
    "createdAt": "2023-02-17T19:31:18Z",
    "body": "Greetings once again STJ team! 😄 \r\n\r\nI ran into a kind of interesting situation trying to send an `application/x-json-stream` POST using `Utf8JsonWriter`.\r\n\r\nThe format I want is...\r\n\r\n```json\r\n{\"item1key1\": \"value1\"}\\n\r\n{\"item2key1\": \"value1\"}\\n\r\n{\"item3key1\": \"value1\"}\\n\r\n```\r\n\r\nEssentially newline delimited JSON.\r\n\r\nI made it work by doing this (more or less)...\r\n\r\n```csharp\r\n        var stream = new MemoryStream();\r\n        var writer = new Utf8JsonWriter(stream, new JsonWriterOptions { SkipValidation = true });\r\n\r\n        foreach (var item in batch)\r\n        {\r\n            // This is the interesting line here.\r\n            writer.Reset(stream);\r\n\r\n            this.SerializeItemToJson(item, writer);\r\n\r\n            writer.Flush();\r\n\r\n            stream.Write(NewLine, 0, 1);\r\n        }\r\n```\r\n\r\nThe interesting line is the `writer.Reset`. That is needed because of depth tracking inside `Utf8JsonWriter` which causes a `,` to be written out after the first item.\r\n\r\nThe challenge I have is the `Reset` method does a whole lot of housekeeping which slows things down.\r\n\r\nWhat I would like is either a way to just reset the depth so the comma isn't emitted or a way to tell `Utf8JsonWriter` to emit `\\n` where it would have done the comma (but only for these top-level objects).\r\n\r\nThoughts?",
    "number": 82314,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-02-19T20:34:33Z",
          "user": "campersau"
        }
      ],
      "totalCount": 1,
      "endCursor": "Y3Vyc29yOnYyOpHOCuesJQ=="
    },
    "updatedAt": "2023-03-16T16:44:07Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\nGreetings once again STJ team! 😄 \r\n\r\nI ran into a kind of interesting situation trying to send an `application/x-json-stream` POST using `Utf8JsonWriter`.\r\n\r\nThe format I want is...\r\n\r\n```json\r\n{\"item1key1\": \"value1\"}\\n\r\n{\"item2key1\": \"value1\"}\\n\r\n{\"item3key1\": \"value1\"}\\n\r\n```\r\n\r\nEssentially newline delimited JSON.\r\n\r\nI made it work by doing this (more or less)...\r\n\r\n```csharp\r\n        var stream = new MemoryStream();\r\n        var writer = new Utf8JsonWriter(stream, new JsonWriterOptions { SkipValidation = true });\r\n\r\n        foreach (var item in batch)\r\n        {\r\n            // This is the interesting line here.\r\n            writer.Reset(stream);\r\n\r\n            this.SerializeItemToJson(item, writer);\r\n\r\n            writer.Flush();\r\n\r\n            stream.Write(NewLine, 0, 1);\r\n        }\r\n```\r\n\r\nThe interesting line is the `writer.Reset`. That is needed because of depth tracking inside `Utf8JsonWriter` which causes a `,` to be written out after the first item.\r\n\r\nThe challenge I have is the `Reset` method does a whole lot of housekeeping which slows things down.\r\n\r\nWhat I would like is either a way to just reset the depth so the comma isn't emitted or a way to tell `Utf8JsonWriter` to emit `\\n` where it would have done the comma (but only for these top-level objects).\r\n\r\nThoughts?\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>CodeBlanch</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`area-System.Text.Json`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2023-02-17T19:31:25Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-02-17T19:31:25Z",
          "id": "IC_kwDODI9FZc5VinuT"
        },
        {
          "author": "gregsdennis",
          "body": "I'll let the dotnet team answer officially, but my guess is that the writer wasn't designed to write multiple JSON instances (as you do with JSON streams). It's probably expected that you create a new writer for a new instance (you can likely keep the same stream, though).\n\nI like your solution, though.",
          "createdAt": "2023-02-17T19:36:18Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-02-17T19:36:35Z",
          "id": "IC_kwDODI9FZc5Vio2J"
        },
        {
          "author": "svick",
          "body": "Related issue for the reading side: https://github.com/dotnet/runtime/issues/33030.",
          "createdAt": "2023-02-19T10:46:21Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-02-19T10:46:21Z",
          "id": "IC_kwDODI9FZc5Vlus5"
        },
        {
          "author": "eiriktsarpalis",
          "body": "> The challenge I have is the `Reset` method does a whole lot of housekeeping which slows things down.\r\n\r\nWhat does the `Reset` method do specifically that slows things down? Looking at its documentation it seems to have been designed specifically to address your use case and I couldn't detect anything in the implementation that might drastically impact performance.",
          "createdAt": "2023-02-20T12:21:03Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-02-20T12:21:03Z",
          "id": "IC_kwDODI9FZc5VpZP_"
        },
        {
          "author": null,
          "body": "This issue has been marked `needs-author-action` and may be missing some important information.",
          "createdAt": "2023-02-21T18:18:09Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-02-21T18:18:09Z",
          "id": "IC_kwDODI9FZc5VxA0z"
        },
        {
          "author": "CodeBlanch",
          "body": "@eiriktsarpalis The bummer with the current design is I have to call it in my inner loop. So I wouldn't say it is a slow operation, but it is slower than needed. Here's a benchmark:\r\n\r\n|              Method | NumberOfItems |         Mean |      Error |     StdDev |\r\n|-------------------- |-------------- |-------------:|-----------:|-----------:|\r\n|      ResetBenchmark |             1 |     56.98 ns |   0.862 ns |   0.720 ns |\r\n| ResetDepthBenchmark |             1 |     58.13 ns |   1.074 ns |   1.433 ns |\r\n|      ResetBenchmark |           100 |  5,528.35 ns |  90.470 ns |  84.625 ns |\r\n| ResetDepthBenchmark |           100 |  5,062.41 ns |  65.433 ns |  61.206 ns |\r\n|      ResetBenchmark |          1000 | 56,238.61 ns | 434.657 ns | 406.579 ns |\r\n| ResetDepthBenchmark |          1000 | 49,154.42 ns | 682.534 ns | 638.442 ns |\r\n\r\n[My particular use case](https://github.com/open-telemetry/opentelemetry-dotnet-contrib/blob/d3f6d09b65a7878cf18b22eeda826149279daa71/src/OpenTelemetry.Exporter.OneCollector/Internal/Serialization/CommonSchemaJsonSerializer.cs#L58) is I have a batch of items in memory I need to send off at some interval or when it gets full.\r\n\r\n<details>\r\n<summary>Benchmark code</summary>\r\n\r\n```csharp\r\npublic class Utf8JsonWriterBenchmarks\r\n{\r\n    private static readonly byte[] NewLine = \"\\n\"u8.ToArray();\r\n    private static readonly JsonEncodedText IndexPropertyName = JsonEncodedText.Encode(\"Index\");\r\n    private static readonly JsonEncodedText NamePropertyName = JsonEncodedText.Encode(\"Name\");\r\n    private static readonly Action<Utf8JsonWriter> ResetDepth = BuildResetDepthAction();\r\n    private readonly MemoryStream stream = new();\r\n    private readonly Utf8JsonWriter writer;\r\n\r\n    public Utf8JsonWriterBenchmarks()\r\n    {\r\n        this.writer = new(this.stream, new JsonWriterOptions { SkipValidation = true });\r\n    }\r\n\r\n    [Params(1, 100, 1000)]\r\n    public int NumberOfItems { get; set; }\r\n\r\n    [Benchmark]\r\n    public void ResetBenchmark()\r\n    {\r\n        this.stream.Position = 0;\r\n\r\n        for (int i = 0; i < this.NumberOfItems; i++)\r\n        {\r\n            this.writer.Reset(this.stream);\r\n\r\n            SerializeItem(i, this.writer);\r\n\r\n            this.writer.Flush();\r\n\r\n            this.stream.Write(NewLine, 0, 1);\r\n        }\r\n    }\r\n\r\n    [Benchmark]\r\n    public void ResetDepthBenchmark()\r\n    {\r\n        this.stream.Position = 0;\r\n        this.writer.Reset(this.stream);\r\n\r\n        for (int i = 0; i < this.NumberOfItems; i++)\r\n        {\r\n            ResetDepth(this.writer);\r\n\r\n            SerializeItem(i, this.writer);\r\n\r\n            this.writer.Flush();\r\n\r\n            this.stream.Write(NewLine, 0, 1);\r\n        }\r\n    }\r\n\r\n    private static void SerializeItem(int index, Utf8JsonWriter writer)\r\n    {\r\n        writer.WriteStartObject();\r\n        writer.WriteNumber(IndexPropertyName, index);\r\n        writer.WriteString(NamePropertyName, \"name\");\r\n        writer.WriteEndObject();\r\n    }\r\n\r\n    private static Action<Utf8JsonWriter> BuildResetDepthAction()\r\n    {\r\n        var currentDepthField = typeof(Utf8JsonWriter).GetField(\"_currentDepth\", BindingFlags.Instance | BindingFlags.NonPublic);\r\n\r\n        var dynamicMethod = new DynamicMethod(\r\n            \"ResetDepth\",\r\n            returnType: null,\r\n            new Type[] { typeof(Utf8JsonWriter) },\r\n            typeof(Utf8JsonWriterBenchmarks).Module,\r\n            skipVisibility: true);\r\n\r\n        var generator = dynamicMethod.GetILGenerator();\r\n\r\n        generator.Emit(OpCodes.Ldarg_0);\r\n        generator.Emit(OpCodes.Ldc_I4_0);\r\n        generator.Emit(OpCodes.Stfld, currentDepthField);\r\n        generator.Emit(OpCodes.Ret);\r\n\r\n        return (Action<Utf8JsonWriter>)dynamicMethod.CreateDelegate(typeof(Action<Utf8JsonWriter>));\r\n    }\r\n}\r\n```\r\n\r\n</details>",
          "createdAt": "2023-02-21T18:56:12Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-02-21T18:56:12Z",
          "id": "IC_kwDODI9FZc5VxLEB"
        },
        {
          "author": "eiriktsarpalis",
          "body": "You might be able to avoid a number of checks if you just use the parameterless `Reset()` method:\r\n```C#\r\n[Benchmark(Baseline = true)]\r\npublic void ResetBenchmark()\r\n{\r\n    this.stream.Position = 0;\r\n\r\n    for (int i = 0; i < this.NumberOfItems; i++)\r\n    {\r\n        SerializeItem(i, this.writer);\r\n\r\n        this.writer.Flush();\r\n        this.stream.Write(NewLine, 0, 1);\r\n        this.writer.Reset();\r\n    }\r\n}\r\n```\r\nWhich produces slightly better numbers percentage-wise:\r\n\r\n|              Method | NumberOfItems |         Mean |      Error |     StdDev | Ratio | RatioSD |\r\n|-------------------- |-------------- |-------------:|-----------:|-----------:|------:|--------:|\r\n|      ResetBenchmark |             1 |     79.85 ns |   0.881 ns |   0.824 ns |  1.00 |    0.00 |\r\n| ResetDepthBenchmark |             1 |     83.67 ns |   1.060 ns |   0.992 ns |  1.05 |    0.02 |\r\n|                     |               |              |            |            |       |         |\r\n|      ResetBenchmark |           100 |  7,790.08 ns |  83.742 ns |  74.235 ns |  1.00 |    0.00 |\r\n| ResetDepthBenchmark |           100 |  7,570.72 ns |  56.274 ns |  52.639 ns |  0.97 |    0.01 |\r\n|                     |               |              |            |            |       |         |\r\n|      ResetBenchmark |          1000 | 77,599.60 ns | 485.364 ns | 454.010 ns |  1.00 |    0.00 |\r\n| ResetDepthBenchmark |          1000 | 76,339.86 ns | 607.348 ns | 568.114 ns |  0.98 |    0.01 |\r\n\r\nImprovement is marginal, at the expense of not fully resetting the state of the writer. I would expect it to be even less pronounced if each loop called into `JsonSerializer` methods or if a less trivial JSON object was serialized on each iteration.\r\n\r\nSo I do think `Utf8JsonWriter.Reset()` is the way to go here.",
          "createdAt": "2023-02-21T19:36:16Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-02-21T19:36:16Z",
          "id": "IC_kwDODI9FZc5VxVBf"
        },
        {
          "author": "CodeBlanch",
          "body": "@eiriktsarpalis \r\n\r\nIn my actual code I do have to reset to a different stream but...\r\n\r\n```csharp\r\nwriter.Reset(inputStream);\r\nfor (...)\r\n{\r\n    // do stuff\r\n    writer.Reset();\r\n}\r\n```\r\n\r\n...works for me. Didn't realize the parameter-less reset preserves the current stream. Nice!\r\n\r\nI will say trying to do this `application/x-json-stream` using `Utf8JsonWriter` is still a bit awkward.\r\n\r\n* SkipValidation must be set to `true`\r\n* You have to write your own `\\n` somehow\r\n\r\nProbably something could be done to make it better but I'm not blocked so I'll just leave this out there in case anyone else wants to push for it 😄",
          "createdAt": "2023-02-21T22:36:16Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-02-21T22:36:16Z",
          "id": "IC_kwDODI9FZc5VyCno"
        },
        {
          "author": "cmbankester",
          "body": "Another downside to needing to reset the writer is that it also requires flushing the writer and by extension, the underlying stream. This causes problems with, e.g., using a `BufferedStream` as the buffer gets flushed each time the json writer is flushed, eliminating the performance gains of using a `BufferedStream` altogether. This applies to other buffering streams as well, such as Azure Blob write streams. Of course a custom duplex stream could be created that doesn't flush to the destination each time the writer flushes, but that seems abnormal and like sidestepping the actual problem.\r\n\r\nAs @CodeBlanch said, using `Utf8JsonWriter` in this situation is pretty awkward, which is a shame considering this is precisely the type of situation where I'd want to use it (i.e. customization of JSON stream serialization/formatting).\r\n\r\nI also just want to note that if we had the ability to disable the automatic comma insertion (e.g. a property like `SkipAutomaticListSeparatorInsertionAtDepthZero` on `JsonWriterOptions` [or something better, just spitballing]), this would be a non issue, as we can write newlines to the Utf8JsonWriter via `WriteRawValue(..., skipInputValidation: true)`, meaning we could implement as:\r\n\r\n```c#\r\nvar stream = new MemoryStream();\r\nvar writer = new Utf8JsonWriter(stream, new JsonWriterOptions { SkipValidation = true, SkipAutomaticListSeparatorInsertionAtDepthZero = true });\r\nforeach (var item in batch)\r\n{\r\n    this.SerializeItemToJson(item, writer);\r\n    writer.WriteRawValue(\"\\n\", skipInputValidation: true);\r\n}\r\n```",
          "createdAt": "2023-03-16T16:41:09Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-03-16T16:44:07Z",
          "id": "IC_kwDODI9FZc5XwedZ"
        }
      ],
      "totalCount": 9,
      "endCursor": "Y3Vyc29yOnYyOpHOV8HnWQ=="
    },
    "url": "https://github.com/dotnet/runtime/issues/82314",
    "title": "System.Text.Json: Utf8JsonWriter support for application/x-json-stream"
  },
  {
    "author": "TonyValenti",
    "labels": [
      "area-System.Text.Json",
      "wishlist"
    ],
    "createdAt": "2023-02-24T20:33:56Z",
    "body": "Will STJ be updated to support them?",
    "number": 82642,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-11-04T21:07:02Z",
          "user": "codymullins"
        }
      ],
      "totalCount": 1,
      "endCursor": "Y3Vyc29yOnYyOpHOC8ZPWw=="
    },
    "updatedAt": "2025-07-16T06:53:21Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\nWill STJ be updated to support them?\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>TonyValenti</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`area-System.Text.Json`, `untriaged`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2023-02-24T20:39:32Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-02-24T20:39:32Z",
          "id": "IC_kwDODI9FZc5WGHQC"
        },
        {
          "author": "eiriktsarpalis",
          "body": "We could, other immutable collections are already supported by STJ. One small concern I have is that whatever baked-in converters we do ship need to make an explicit choice as to whether the `optimizeForReading` flag is enabled when deserializing; whatever we do end up picking won't be user-configurable. @stephentoub might have opinions about this.\r\n\r\nSerialization for frozen collections should already be possible (since they all implement the right interfaces), it's deserialization support that needs to be added. One possible course of action is that we do nothing and simply expose support for [parameterized constructors](https://github.com/dotnet/runtime/issues/71944) in the contract model: frozen collections are a prime example of where such functionality would be useful.",
          "createdAt": "2023-02-27T15:05:23Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-08-20T22:52:11Z",
                "user": "julealgon"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHODu_MnA=="
          },
          "updatedAt": "2023-02-27T15:05:23Z",
          "id": "IC_kwDODI9FZc5WN8hA"
        },
        {
          "author": "stephentoub",
          "body": "> One small concern I have is that whatever baked-in converters we do ship need to make an explicit choice as to whether the optimizeForReading flag is enabled when deserializing; whatever we do end up picking won't be user-configurable. @stephentoub might have opinions about this.\r\n\r\nI'd want to better understand the user scenario for serializing/deserializing these as json.  The intent of optimizeForReading:true is for collections expected to be created once and then used repeatedly for a very long time, as creating them is more expensive, with the idea that spending more time at construction is a good tradeoff if there's going to be many, many subsequent reads.  If these collections are being routinely serialized back and forth as part of some communication scheme, I'd venture it'd be rare for them to them stick around for a very long time.  And if the odd one was, a new frozen collection could be created from it with the appropriate settings.  It'd likely be cheaper to just deserialize these as a standard `Dictionary<>`.",
          "createdAt": "2023-02-27T15:18:38Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-02-27T15:24:44Z",
                "user": "eiriktsarpalis"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-08-20T22:57:41Z",
                "user": "julealgon"
              }
            ],
            "totalCount": 2,
            "endCursor": "Y3Vyc29yOnYyOpHODu_OEQ=="
          },
          "updatedAt": "2023-02-27T15:18:38Z",
          "id": "IC_kwDODI9FZc5WOCw9"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Agreed. Generally speaking I'd expect collections on deserialized DTOs to be ephemeral in most cases so frozen collections aren't necessarily the ideal representation for doing that. At the same time users expect serialization to \"just work\" with the type at hand so perhaps having a default that optimizes for deserialization would be good enough for most use cases.",
          "createdAt": "2023-02-27T15:28:51Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-02-27T15:28:51Z",
          "id": "IC_kwDODI9FZc5WOHc-"
        },
        {
          "author": "TonyValenti",
          "body": "In my organization, we use records and Immutable structures for all JSON-based communication.  We often load JSON into an in-memory ImmutableDictionary cache and then access it from there.\r\n\r\nFrom what I was reading, it seemed like FrozenDictionary would give us better performance which is why I asked.",
          "createdAt": "2023-02-27T21:59:48Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-02-28T12:38:00Z",
                "user": "eiriktsarpalis"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOC25Whg=="
          },
          "updatedAt": "2023-02-27T21:59:48Z",
          "id": "IC_kwDODI9FZc5WQhqX"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Apropos, any new collection type that we support would also need to work in the source generator, currently this means adding new dedicated APIs in the `JsonMetadataServices` class. This suggests to me that tackling #71944 might let us kill two birds with one stone.",
          "createdAt": "2023-02-28T12:41:53Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-02-28T12:41:53Z",
          "id": "IC_kwDODI9FZc5WUHm6"
        },
        {
          "author": "terrajobst",
          "body": "In my case I have an immutable data structure that acts like a cache. It's constructed once and sticks around as long as the process exists. However, I want to save it to disk and reload it the next time, which is why it would be convenient if I could use frozen collections as this means I can serialize the cache as-is.",
          "createdAt": "2024-08-20T21:48:22Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-08-20T21:48:36Z",
          "id": "IC_kwDODI9FZc6JFH--"
        },
        {
          "author": "julealgon",
          "body": "@stephentoub \r\n> If these collections are being routinely serialized back and forth as part of some communication scheme, I'd venture it'd be rare for them to them stick around for a very long time.\r\n\r\nI do have an upcoming scenario (for a game) where I want to have parts of the game be data-driven and obtained via an API request during initial load. The results of this call will _not_ be updated for the remainder of the session, which could be minutes, hours, or days: basically unbounded.\r\n\r\nIt's not a very _common_ scenario I admit though.\r\n\r\n> And if the odd one was, a new frozen collection could be created from it with the appropriate settings. It'd likely be cheaper to just deserialize these as a standard `Dictionary<>`.\r\n\r\nThat's probably fair enough though, and likely what I would do in the scenario above if deserialization wasn't supported.\r\n\r\n",
          "createdAt": "2024-08-20T22:57:23Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-08-20T22:57:33Z",
          "id": "IC_kwDODI9FZc6JFalm"
        },
        {
          "author": "stephentoub",
          "body": "> simply expose support for https://github.com/dotnet/runtime/issues/71944 in the contract model: frozen collections are a prime example of where such functionality would be useful\n\n@eiriktsarpalis, should we support collection expression builders? FrozenSet has one, and FrozenDictionary will once dictionary expressions are a thing.\ncc: @CyrusNajmabadi ",
          "createdAt": "2024-08-31T18:19:07Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "ROCKET",
                "createdAt": "2024-09-02T13:05:08Z",
                "user": "julealgon"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHODwr4Lw=="
          },
          "updatedAt": "2024-08-31T18:19:07Z",
          "id": "IC_kwDODI9FZc6Kdjtg"
        },
        {
          "author": "TonyValenti",
          "body": "I would love it if you did. ",
          "createdAt": "2024-08-31T18:42:44Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-08-31T18:42:44Z",
          "id": "IC_kwDODI9FZc6Kdlf_"
        },
        {
          "author": "eiriktsarpalis",
          "body": "I think we should.",
          "createdAt": "2024-08-31T19:50:02Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-08-31T21:06:25Z",
                "user": "stephentoub"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHODwk9bw=="
          },
          "updatedAt": "2024-08-31T19:50:02Z",
          "id": "IC_kwDODI9FZc6KdpfO"
        },
        {
          "author": "eiriktsarpalis",
          "body": "One potential concern is the serializer handling types differently depending on whether the target uses CollectionBuilderAttribute. We should make sure types using the attribute are already supported if they exist in ns2.0",
          "createdAt": "2024-09-01T07:30:22Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-09-01T07:30:22Z",
          "id": "IC_kwDODI9FZc6KeWCY"
        },
        {
          "author": "codymullins",
          "body": "With regards to @eiriktsarpalis's comment:\n> I'd expect collections on deserialized DTOs to be ephemeral in most cases so frozen collections aren't necessarily the ideal representation\n\nI am running into this when serializing state to persist on page reloads or sharing links. I don't really need a separate `dto` if not for this -- the code is already client side via wasm. So just fyi, DTO serialization may not be the only use case here.",
          "createdAt": "2024-11-04T21:06:17Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-11-04T21:06:17Z",
          "id": "IC_kwDODI9FZc6SXwl4"
        }
      ],
      "totalCount": 13,
      "endCursor": "Y3Vyc29yOnYyOpHOkl8JeA=="
    },
    "url": "https://github.com/dotnet/runtime/issues/82642",
    "title": "STJ and Frozen collections"
  },
  {
    "author": "eiriktsarpalis",
    "labels": [
      "api-suggestion",
      "area-System.Text.Json",
      "tenet-performance"
    ],
    "createdAt": "2023-02-27T16:41:07Z",
    "body": "Users working on the contract model should have access to the currently internal `JsonPropertyInfo<TPropertyType>` class. This would let them write allocation-free code for the `Get`, `Set` and `ShouldSerialize` delegates:\r\n\r\n```C#\r\nnamespace System.Text.Json.Serialization.Metadata;\r\n\r\npublic class JsonPropertyInfo<TPropertyType> : JsonPropertyInfo\r\n{\r\n    public new Func<object, TPropertyType, bool> ShouldSerialize { get; set; }\r\n\r\n    public new Func<object, TPropertyType> Get { get; set; }\r\n    public new Action<object, TPropertyType> Set { get; set; }\r\n}\r\n```\r\n\r\n## Alternative design\r\n\r\nWe also discussed this alternative:\r\n```C#\r\nnamespace System.Text.Json.Serialization.Metadata;\r\n\r\npublic class JsonPropertyInfo<TDeclaringType, TPropertyType> : JsonPropertyInfo\r\n{\r\n    public new Func<TDeclaringType, TPropertyType, bool> ShouldSerialize { get; set; }\r\n\r\n    public new Func<TDeclaringType, TPropertyType> Get { get; set; }\r\n    public new PropertySetter<TDeclaringType, TPropertyType> Set { get; set; }\r\n}\r\n\r\npublic delegate void PropertySetter<TDeclaringType, TPropertyType>(ref TDeclaringType obj, TPropertyType value);\r\n```\r\n\r\nIt's unlikely we'd pursue this since it would increase the static footprint in NativeAOT due to the large number of generic specializations it would incur.\r\n\r\n\r\n## Notes on Performance (taken from https://github.com/dotnet/runtime/issues/63686)\r\n\r\nWe have considered different approaches here and it all boils down to perf of the property setter.\r\nAccording to simple perf tests run on different combinations of declaring types and property types as well 4 different approaches of setters using setter in form of:\r\n\r\n`delegate void PropertySetter<DeclaringType, PropertyType>(ref DeclaringType obj, PropertyType val);`\r\n\r\nproves to be overall fastest. Current implementation would require a bit of work for this to be changed and such support can be added later. Given above we've decided to for a time being support only non-generic `PropertyInfo` with the slowest setter since such type already exists and corresponding setter would have to be added regardless of choice. In the future `PropertyInfo<TDeclaringType, TPropertyType>` should be added to support for the fastest possible case.\r\n\r\nHere are benchmark results: https://gist.github.com/krwq/d9d1bad3d59ff30f8db2a53a27adc755\r\nHere is the benchmark code: https://gist.github.com/krwq/eb06529f0c99614579f84b69720ab46e",
    "number": 82720,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-06-10T04:45:09Z",
          "user": "Lanayx"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-08-29T07:06:10Z",
          "user": "mayorovp"
        }
      ],
      "totalCount": 2,
      "endCursor": "Y3Vyc29yOnYyOpHOC6l12w=="
    },
    "updatedAt": "2023-11-17T17:24:02Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\nUsers working on the contract model should have access to the currently internal `JsonPropertyInfo<TPropertyType>` class. This would let them write allocation-free code for the `Get`, `Set` and `ShouldSerialize` delegates:\r\n\r\n```C#\r\npublic class JsonPropertyInfo<TPropertyType> : JsonPropertyInfo\r\n{\r\n    public new Func<object, TPropertyType, bool> ShouldSerialize { get; set; }\r\n\r\n    public new Func<object, TPropertyType> Get { get; set; }\r\n    public new Action<object, TPropertyType> Set { get; set; }\r\n}\r\n```\r\n\r\n## JsonPropertyInfo vs JsonPropertyInfo&lt;TPropertyType&gt; vs JsonPropertyInfo<TDeclaringType, TPropertyType>\r\n\r\nWe have considered different approaches here and it all boils down to perf of the property setter.\r\nAccording to simple perf tests run on different combinations of declaring types and property types as well 4 different approaches of setters using setter in form of:\r\n\r\n`delegate void PropertySetter<DeclaringType, PropertyType>(ref DeclaringType obj, PropertyType val);`\r\n\r\nproves to be overall fastest. Current implementation would require a bit of work for this to be changed and such support can be added later. Given above we've decided to for a time being support only non-generic `PropertyInfo` with the slowest setter since such type already exists and corresponding setter would have to be added regardless of choice. In the future `PropertyInfo<TDeclaringType, TPropertyType>` should be added to support for the fastest possible case.\r\n\r\nHere are benchmark results: https://gist.github.com/krwq/d9d1bad3d59ff30f8db2a53a27adc755\r\nHere is the benchmark code: https://gist.github.com/krwq/eb06529f0c99614579f84b69720ab46e\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>eiriktsarpalis</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`api-suggestion`, `area-System.Text.Json`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>Future</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2023-02-27T16:43:18Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-02-27T16:43:18Z",
          "id": "IC_kwDODI9FZc5WOmxr"
        },
        {
          "author": "BreyerW",
          "body": "What about going with hybrid approach? More precisely `ShouldSerialize` and `Get` would use `object` while `Set` would use `ref TDeclaringType`. Would that reduce static footprint increase to more palatable levels? Or is main source of static footprint increase on class itself due to extra generic? It would be shame to lose about 10% - 25% perf on almost every scenario compared to `object` version. I have excluded `Get` since it doesnt return by ref so i think there wont be that big difference unless you used custom delegate with `ref readonly` or just `ref` return. `ShouldSerialize` is somewhat niche i think so its no brain to leave as `object` if that would reduce static footprint increase",
          "createdAt": "2023-02-28T23:58:27Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-03-01T00:14:25Z",
          "id": "IC_kwDODI9FZc5WX5f4"
        },
        {
          "author": "eiriktsarpalis",
          "body": "> Or is main source of static footprint increase on class itself due to extra generic?\r\n\r\nThis. Having two type parameters generally results in quadratic increase of the static footprint. We recently [removed such a type](https://github.com/dotnet/runtime/pull/80755) at the expense of performance in certain scenaria because it was contributing to over 1 MB of NativeAOT application sizes.",
          "createdAt": "2023-03-01T12:09:39Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-03-01T12:09:39Z",
          "id": "IC_kwDODI9FZc5WbdCg"
        },
        {
          "author": "BreyerW",
          "body": "@eiriktsarpalis  so this particular idea goes out of the window. Too bad. Throwing spaghetti at the wall to see if some stick: would it be possible to create nuget package that would enable fastest `JsonPropertyInfo<TDeclaringType, TPropertyType>` while built-in `System.Text.Json` gets `object` + 1 generic version?\r\n\r\nOr maybe flip the idea completely: dont introduce hybrid `object` + 1 generic at all but the fastest version guarded by switch or stored in separate nuget package or some other delivery device that im not aware of.\r\n\r\nThe idea here is to have no change in size for those who care about AoT size (cloud, IoT, mobile etc.) while those who care about speed (desktop, traditional servers etc.) would enable explicitly fastest but fattest version. ",
          "createdAt": "2023-03-01T12:28:22Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-03-01T12:28:22Z",
          "id": "IC_kwDODI9FZc5Wbk9D"
        },
        {
          "author": "eiriktsarpalis",
          "body": "> Throwing spaghetti at the wall to see if some stick: would it be possible to create nuget package that would enable fastest `JsonPropertyInfo<TDeclaringType, TPropertyType>` while built-in `System.Text.Json` gets `object` + 1 generic version?\r\n\r\nNot really. Unless the built-in converter infrastructure can actually see those generic types there wouldn't be much use for the strongly typed delegates. FWIW the internal JsonPropertyInfo implementation follows the first variant already -- it might be boxing the declaring type but at least it ensures that this only happens once per serialization or deserialization:\r\n\r\nhttps://github.com/dotnet/runtime/blob/14bf690caa082d839ccce1568dae663c6f2ede07/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/Converters/Object/ObjectDefaultConverter.cs#L280",
          "createdAt": "2023-03-01T12:41:26Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-03-01T12:41:26Z",
          "id": "IC_kwDODI9FZc5Wbox9"
        }
      ],
      "totalCount": 5,
      "endCursor": "Y3Vyc29yOnYyOpHOVm6MfQ=="
    },
    "url": "https://github.com/dotnet/runtime/issues/82720",
    "title": "Add generic JsonPropertyInfo metadata type(s)"
  },
  {
    "author": "wxyer",
    "labels": [
      "api-suggestion",
      "area-System.Text.Json"
    ],
    "createdAt": "2023-02-28T13:44:03Z",
    "body": "### Is there an existing issue for this?\r\n\r\n- [X] I have searched the existing issues\r\n\r\n### Is your feature request related to a problem? Please describe the problem.\r\n\r\n```c#\r\nclass example\r\n{\r\n     public double num1{get;set;}=0.34343434343434343434;\r\n}\r\n```\r\nwhen serialize class ,i wont num1 like 0.3434 ,only 4 digit\r\n\r\n### Describe the solution you'd like\r\n\r\n```c#\r\nclass example\r\n{\r\n     [JsonPrecision(4)]\r\n     public double num1{get;set;}=0.34343434343434343434;\r\n}\r\n```\r\n### Additional context\r\n\r\n_No response_",
    "number": 82774,
    "reactions": {
      "hasNextPage": false,
      "nodes": [],
      "totalCount": 0,
      "endCursor": null
    },
    "updatedAt": "2023-03-21T16:51:32Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\n### Is there an existing issue for this?\n\n- [X] I have searched the existing issues\n\n### Is your feature request related to a problem? Please describe the problem.\n\nclass example\r\n{\r\n     public double num1{get;set;}=0.34343434343434343434;\r\n}\r\nwhen serialize class ,i wont num1 like 0.3434 ,only 4 digit\n\n### Describe the solution you'd like\n\nclass example\r\n{\r\n     [JsonPrecision(4)]\r\n     public double num1{get;set;}=0.34343434343434343434;\r\n}\n\n### Additional context\n\n_No response_\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>wxyer</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`area-System.Text.Json`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2023-02-28T16:56:31Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-02-28T16:56:31Z",
          "id": "IC_kwDODI9FZc5WVrbi"
        },
        {
          "author": "krwq",
          "body": "There is currently no way to do that with simple settings but you can:\r\n- implement custom converter for numbers doing exactly what you want. You can use i.e. https://learn.microsoft.com/en-us/dotnet/api/system.text.json.utf8jsonwriter.writerawvalue?view=net-7.0 for forcing value to few digits after a comma\r\n- combine above with contract resolver and add modifier which adds support for JsonPrecisionAttribute you write yourself\r\n\r\nI'm slightly torn between closing this issue as by design or waiting for more feedback (it seems it is potentially useful for more people). I'll leave it open for now and let you decide if the workaround I provided you is satisfactory or not",
          "createdAt": "2023-03-06T12:44:37Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-03-06T12:45:37Z",
          "id": "IC_kwDODI9FZc5WydFt"
        }
      ],
      "totalCount": 2,
      "endCursor": "Y3Vyc29yOnYyOpHOVsnRbQ=="
    },
    "url": "https://github.com/dotnet/runtime/issues/82774",
    "title": "can system.text.json serialize a number property with a attribute to set number precision or digit length"
  },
  {
    "author": "eiriktsarpalis",
    "labels": [
      "area-System.Text.Json"
    ],
    "createdAt": "2023-03-07T13:06:23Z",
    "body": "The code\r\n```C#\r\nvar stack  = new Stack<int>(new int[] { 3, 2, 1 });\r\n\r\nfor (int i = 0; i < 5; i++)\r\n{\r\n    string json = JsonSerializer.Serialize(stack);\r\n    Console.WriteLine(json);\r\n    stack = JsonSerializer.Deserialize<Stack<int>>(json);\r\n}\r\n```\r\nProduces\r\n```\r\n[1,2,3]\r\n[3,2,1]\r\n[1,2,3]\r\n[3,2,1]\r\n[1,2,3]\r\n```\r\nEven though this can be expected given the nature of stacks in general, it certainly violates expectations when it comes to marshalling collections. FWIW this is not specific to STJ as similar behavior can be observed when applying a stack to its own IEnumerable constructor.",
    "number": 83086,
    "reactions": {
      "hasNextPage": false,
      "nodes": [],
      "totalCount": 0,
      "endCursor": null
    },
    "updatedAt": "2023-03-08T01:40:18Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\nThe code\r\n```C#\r\nvar stack  = new Stack<int>(new int[] { 3, 2, 1 });\r\n\r\nfor (int i = 0; i < 5; i++)\r\n{\r\n    string json = JsonSerializer.Serialize(stack);\r\n    Console.WriteLine(json);\r\n    stack = JsonSerializer.Deserialize<Stack<int>>(json);\r\n}\r\n```\r\nProduces\r\n```\r\n[1,2,3]\r\n[3,2,1]\r\n[1,2,3]\r\n[3,2,1]\r\n[1,2,3]\r\n```\r\nEven though this can be expected given the nature of stacks in general, it certainly violates expectations when it comes to marshalling collections. FWIW this is not specific to STJ as similar behavior can be observed when applying a stack to its own IEnumerable constructor.\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>eiriktsarpalis</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`area-System.Text.Json`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2023-03-07T13:06:30Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-03-07T13:06:30Z",
          "id": "IC_kwDODI9FZc5W6W-n"
        },
        {
          "author": "eiriktsarpalis",
          "body": "FWIW I'm not necessarily proposing that we fix this (users might rely on the current behavior 😱)  although we should make sure that it is at least documented given that the type is officially supported.",
          "createdAt": "2023-03-07T13:11:32Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-03-07T13:14:42Z",
          "id": "IC_kwDODI9FZc5W6Y6Z"
        },
        {
          "author": "gregsdennis",
          "body": "My opinion is that if people are depending upon bug behavior, they shouldn't be surprised when that big is fixed, even if they don't know it's a bug.\n\nI think fix it.",
          "createdAt": "2023-03-08T01:40:18Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-03-08T10:05:07Z",
                "user": "eiriktsarpalis"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-03-08T15:59:24Z",
                "user": "colejohnson66"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-03-09T10:54:17Z",
                "user": "krwq"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-03-09T16:51:04Z",
                "user": "vladd"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-07-25T11:27:54Z",
                "user": "cklutz"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-10-26T23:06:14Z",
                "user": "h3xds1nz"
              }
            ],
            "totalCount": 6,
            "endCursor": "Y3Vyc29yOnYyOpHOD4Nd2g=="
          },
          "updatedAt": "2023-03-08T01:40:18Z",
          "id": "IC_kwDODI9FZc5W-KUq"
        }
      ],
      "totalCount": 3,
      "endCursor": "Y3Vyc29yOnYyOpHOVvilKg=="
    },
    "url": "https://github.com/dotnet/runtime/issues/83086",
    "title": "System.Text.Json roundtrips Stack<T> instances in reverse order"
  },
  {
    "author": "gregsdennis",
    "labels": [
      "bug",
      "area-System.Text.Json"
    ],
    "createdAt": "2023-03-16T20:36:56Z",
    "body": "### Description\r\n\r\nThe `JsonNode.GetPath()` generally does well for C#-valid property names, but any string is valid as a key in JSON, and when a key has characters that need escaping, nothing happens and you get an invalid (unparsable) JSON Path as a result.\r\n\r\n### Reproduction Steps\r\n\r\n```\r\nJsonNode.Parse(\"\"\"{\"$defs\":{\"foo['bar\":\"baz\"}}\"\"\")[\"$defs\"][\"foo['bar\"].GetPath();\r\n```\r\n\r\n\r\n### Expected behavior\r\n\r\n~Returns `$.$defs['foo[\\'bar']`.~\r\n\r\nReturns `$['$defs']['foo[\\'bar']`.\r\n\r\n- The single quote needs to be escaped.\r\n- `$defs` is not valid as a shorthand property name, so it needs to be in bracketed syntax.\r\n\r\n### Actual behavior\r\n\r\nReturns `$.$defs['foo['bar']`.\r\n\r\n### Regression?\r\n\r\nUnknown\r\n\r\n### Known Workarounds\r\n\r\nNone.\r\n\r\n### Configuration\r\n\r\nSeems to happen everywhere.  dotnetfiddle, Linux.\r\n\r\nWill update with more details in a comment.\r\n\r\n### Other information\r\n\r\nOriginally reported https://github.com/gregsdennis/json-everything/issues/406.\r\n",
    "number": 83547,
    "reactions": {
      "hasNextPage": false,
      "nodes": [],
      "totalCount": 0,
      "endCursor": null
    },
    "updatedAt": "2023-10-06T08:05:58Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\n### Description\n\nThe `JsonNode.GetPath()` generally does well for C#-valid property names, but any string is valid as a key in JSON, and when a key has characters that need escaping, nothing happens and you get an invalid (unparsable) JSON Path as a result.\n\n### Reproduction Steps\n\n```\r\nJsonNode.Parse(\"\"\"{\"$defs\":{\"foo['bar\":\"baz\"}}\"\"\")[\"$defs\"][\"foo['bar\"].GetPath();\r\n```\r\n\n\n### Expected behavior\n\nReturns `$.$defs['foo[\\'bar']`.\n\n### Actual behavior\n\nReturns `$.$defs['foo['bar']`.\n\n### Regression?\n\nUnknown\n\n### Known Workarounds\n\nNone.\n\n### Configuration\n\nSeems to happen everywhere.  dotnetfiddle, Linux.\r\n\r\nWill update with more details in a comment.\n\n### Other information\n\nOriginally reported https://github.com/gregsdennis/json-everything/issues/406.\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>gregsdennis</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`area-System.Text.Json`, `untriaged`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2023-03-16T20:37:06Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "LAUGH",
                "createdAt": "2023-03-16T20:37:52Z",
                "user": "gregsdennis"
              },
              {
                "content": "LAUGH",
                "createdAt": "2023-03-16T20:39:05Z",
                "user": "amis92"
              }
            ],
            "totalCount": 2,
            "endCursor": "Y3Vyc29yOnYyOpHOC3_2XA=="
          },
          "updatedAt": "2023-03-16T20:37:06Z",
          "id": "IC_kwDODI9FZc5Xx7cU"
        },
        {
          "author": "amis92",
          "body": "The specific source code in question is the following:\r\n\r\nhttps://github.com/dotnet/runtime/blob/a396d6e912b3d143102a36554ef65196353da032/src/libraries/System.Text.Json/src/System/Text/Json/Nodes/JsonObject.cs#L131-L138\r\n\r\nWhile it actively looks for special characters to use indexer syntax (`['xyz']`) instead of shorthand (`.foo`), it does not attempt to escape the apostrophe `'`.",
          "createdAt": "2023-03-16T20:42:40Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-03-16T20:42:40Z",
          "id": "IC_kwDODI9FZc5Xx88m"
        },
        {
          "author": "gregsdennis",
          "body": "I should also mention that perhaps JSON Path is the wrong syntax to use for identifying a single location within a JSON tree.  JSON Pointer is more well-suited for that.",
          "createdAt": "2023-03-19T22:04:07Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-03-19T22:04:07Z",
          "id": "IC_kwDODI9FZc5X8QGI"
        },
        {
          "author": "gregsdennis",
          "body": "☝️ I'm adding `.GetPathFromRoot()` and `.GetPointerFromRoot()` to my [Json.More.Net](https://www.nuget.org/packages/Json.More.Net/) library to support this until it's in the runtime.",
          "createdAt": "2023-03-27T22:54:01Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-03-27T22:54:13Z",
          "id": "IC_kwDODI9FZc5YkgTX"
        }
      ],
      "totalCount": 4,
      "endCursor": "Y3Vyc29yOnYyOpHOWJIE1w=="
    },
    "url": "https://github.com/dotnet/runtime/issues/83547",
    "title": "`JsonNode.GetPath()` doesn't consider character escaping"
  },
  {
    "author": "TheBrambleShark",
    "labels": [
      "design-discussion",
      "api-suggestion",
      "area-System.Text.Json"
    ],
    "createdAt": "2023-03-19T19:42:34Z",
    "body": "### Background and motivation\n\nThe System.Text.Parsing namespace will hold language-agnostic interfaces and classes used for parsing text-based languages such as Json, Xml, Yaml, and others. This could potentially be used by Roslyn as well, should they find anything useful, but that's not a priority of this library.\r\n\r\nAdditionally, this library will not be functional on its own. It should merely provide the framework on which to build language-specific parsing libraries, for example System.Text.Json or a future System.Text.Xml. Changes to System.Text.Json to use this library will be a project in itself and thus will be placed in its own proposal.\r\n\r\nThe S.T.Parsing library should begin its life by abstracting components of System.Text.Json into agnostic forms, wherever possible. This will give us a good head start, but additional features can be added to this library as we find a need for them, even if such features are not applicable to every possible language.\n\n### API Proposal\n\nFirst, a few more generic things that won't follow the standard suggestion format.\r\n\r\n1. Migrate PooledByteBufferWriter.cs to System.Text.Parsing.PooledByteBufferWriter. Probably change visibility to `protected`, but I'm not too familiar with where this is used.\r\n2. Migrate HexConverter.cs to System.Text.Parsing.HexConverter. Probably change visibility to `public`, else `protected`.\r\n3. Migrate JsonNamingPolicy.cs to System.Text.Parsing.NamingPolicy. JsonNamingProperty should become a static class behaving like a type-safe enum, and specific policies like SnakeCaseNamingPolicy should instead implement NamingPolicy.\r\n\r\nWe should consider creating a bunch of generic Naming Policies. For instance, a SnakeCaseNamingPolicy could be applied to json as `\"some_key\": 42` and xml as `<some_key>42</some_key>`, so there is reuse to be had here.\r\n\r\nCreate System.Text.Parsing.Document.ITextDocument (or IDocument, whichever sounds better):\r\n```cs\r\n// I have only included public interfaces from JsonDocument here, but it may be prudent to expose some internal methods as well.\r\npublic interface ITextDocument<TRoot, TextWriter> : IDisposable\r\n    where TRoot : IElement\r\n    where TextWriter : ITextWriter\r\n{\r\n    void WriteTo(TextWriter writer);\r\n}\r\n```\r\n\r\nCreate System.Text.Parsing.Document.IElement\r\n```cs\r\n// Should these returns be generic somehow?\r\npublic interface IElement<TextWriter>\r\n    where TextWriter : ITextWriter\r\n{\r\n    // Potentially some sort of generic ValueKind.\r\n    \r\n    // All elements should at least be readable. Consumer can make this writable if they choose.\r\n    IElement this[int index] { get; }\r\n\r\n    int GetArrayLength();\r\n\r\n    IElement GetProperty(string propertyName);\r\n    IElement GetProperty(ReadOnlySpan<char> propertyName);\r\n    IElement GetProperty(ReadOnlySpan<byte> utf8PropertyName);\r\n\r\n    bool TryGetProperty<TElement>(string propertyName, out TElement value) where TElement : IElement;\r\n    bool TryGetProperty<TElement>(ReadOnlySpan<char> propertyName, out TElement value) where TElement : IElement;\r\n    bool TryGetProperty<TElement>(ReadOnlySpan<byte> utf8PropertyName, out TElement value) where TElement : IElement;\r\n\r\n    // Currently, there are separate GetInt(), GetByte(), etc. for the JsonElement type.\r\n    X GetX();\r\n    bool TryGetX(out x);\r\n\r\n    // I propose we skip those and simply use generics. If the consumer wishes to separate these out, e.g. for backwards compatibility, that's fine, but with the new `INumber` interface to handle numeric types we shouldn't face any roadblocks with a generic implementation. And if something comes up where that is the case, the consumer can always explicitly implement these and have them throw, then implement separate GetX and TryGetX methods.\r\n    TValue GetValue<TValue>();\r\n    bool TryGetValue<TValue>(out TValue);\r\n\r\n    string GetRawText();\r\n\r\n    // Provided for backwards-compatibility\r\n    bool ValueEquals(string? text);\r\n    bool ValueEquals(ReadOnlySpan<byte> utf8Text);\r\n\r\n    // Perform type comparison using default equality comparer.\r\n    bool ValueEquals<TValue>(TValue other);\r\n\r\n    void WriteTo(TextWriter writer);\r\n\r\n    public ArrayEnumerator EnumerateArray();\r\n\r\n    public ObjectEnumerator EnumerateObject();\r\n\r\n    public override string ToString();\r\n\r\n    public IElement Clone();\r\n}\r\n```\r\n\r\nCreate System.Text.Parsing.Document.JsonProperty\r\n```cs\r\npublic interface IProperty<TextWriter>\r\n    where TextWriter : ITextWriter\r\n{\r\n    string Name { get; }\r\n\r\n    bool NameEquals(string? text);\r\n    bool NameEquals(ReadOnlySpan<byte> utf8Text);\r\n    bool NameEquals(ReadOnlySpan<char> text);\r\n\r\n    bool WriteTo(TextWriter writer);\r\n\r\n    string ToString();\r\n}\r\n```\r\n\r\nCreate System.Text.Parsing.Reader.IReader\r\nMight also be a good candidate for an abstract class to implement a lot of the internal and private functionality.\r\n```cs\r\npublic interface IReader\r\n{\r\n    ReadOnlySpan<byte> ValueSpan { get; private set; }\r\n\r\n    long BytesConsumed { get; }\r\n\r\n    long TokenStartIndex { get; private set; }\r\n\r\n    int CurrentDepth { get; }\r\n\r\n    // Some sort of generic TokenType\r\n\r\n    bool HasValueSequence { get; private set; }\r\n    bool ValueIsEscaped { get; private set; }\r\n    bool IsFinalBlock { get; }\r\n    \r\n    ReadOnlySequence<byte> ValueSequence { get; private set; }\r\n\r\n    SequencePosition Position { get; }\r\n\r\n    ReaderState CurrentState { get; }\r\n\r\n    bool Read();\r\n\r\n    void Skip();\r\n    bool TrySkip();\r\n\r\n    bool ValueTextEquals(ReadOnlySpan<byte> utf8Text);\r\n    bool ValueTextEquals(string? text);\r\n    bool ValueTextEquals(ReadOnlySpan<char> text);\r\n}\r\n```\r\n\r\nCreate System.Text.Parsing.Writer.IWriter\r\nMight also be a good candidate for an abstract base class.\r\nI could go on forever I'm sure but this will get pretty repetitive. Discussion should be had for a list of candidates for migration/generalization.\r\n\n\n### API Usage\n\nThis library contains base classes and interfaces and should only be used by those wanting to implement their own parsing/serialization library. No samples are provided here because it's just standard implementation.\n\n### Alternative Designs\n\n_No response_\n\n### Risks\n\nThis proposal by itself should add no inherent risks as it is non-breaking. We are simply creating a new library and new types under its library.",
    "number": 83652,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-09-18T16:58:14Z",
          "user": "StephenHodgson"
        }
      ],
      "totalCount": 1,
      "endCursor": "Y3Vyc29yOnYyOpHOC7Hf7A=="
    },
    "updatedAt": "2023-04-02T22:00:17Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\n### Background and motivation\n\nThe System.Text.Parsing namespace will hold language-agnostic interfaces and classes used for parsing text-based languages such as Json, Xml, Yaml, and others. This could potentially be used by Roslyn as well, should they find anything useful, but that's not a priority of this library.\r\n\r\nAdditionally, this library will not be functional on its own. It should merely provide the framework on which to build language-specific parsing libraries, for example System.Text.Json or a future System.Text.Xml. Changes to System.Text.Json to use this library will be a project in itself and thus will be placed in its own proposal.\r\n\r\nThe S.T.Parsing library should begin its life by abstracting components of System.Text.Json into agnostic forms, wherever possible. This will give us a good head start, but additional features can be added to this library as we find a need for them, even if such features are not applicable to every possible language.\n\n### API Proposal\n\nFirst, a few more generic things that won't follow the standard suggestion format.\r\n\r\n1. Migrate PooledByteBufferWriter.cs to System.Text.Parsing.PooledByteBufferWriter. Probably change visibility to `protected`, but I'm not too familiar with where this is used.\r\n2. Migrate HexConverter.cs to System.Text.Parsing.HexConverter. Probably change visibility to `public`, else `protected`.\r\n3. Migrate JsonNamingPolicy.cs to System.Text.Parsing.NamingPolicy. JsonNamingProperty should become a static class behaving like a type-safe enum, and specific policies like SnakeCaseNamingPolicy should instead implement NamingPolicy.\r\n\r\nWe should consider creating a bunch of generic Naming Policies. For instance, a SnakeCaseNamingPolicy could be applied to json as `\"some_key\": 42` and xml as `<some_key>42</some_key>`, so there is reuse to be had here.\r\n\r\nCreate System.Text.Parsing.Document.ITextDocument (or IDocument, whichever sounds better):\r\n```cs\r\n// I have only included public interfaces from JsonDocument here, but it may be prudent to expose some internal methods as well.\r\npublic interface ITextDocument<TRoot, TextWriter> : IDisposable\r\n    where TRoot : IElement\r\n    where TextWriter : ITextWriter\r\n{\r\n    void WriteTo(TextWriter writer);\r\n}\r\n```\r\n\r\nCreate System.Text.Parsing.Document.IElement\r\n```cs\r\n// Should these returns be generic somehow?\r\npublic interface IElement<TextWriter>\r\n    where TextWriter : ITextWriter\r\n{\r\n    // Potentially some sort of generic ValueKind.\r\n    \r\n    // All elements should at least be readable. Consumer can make this writable if they choose.\r\n    IElement this[int index] { get; }\r\n\r\n    int GetArrayLength();\r\n\r\n    IElement GetProperty(string propertyName);\r\n    IElement GetProperty(ReadOnlySpan<char> propertyName);\r\n    IElement GetProperty(ReadOnlySpan<byte> utf8PropertyName);\r\n\r\n    bool TryGetProperty<TElement>(string propertyName, out TElement value) where TElement : IElement;\r\n    bool TryGetProperty<TElement>(ReadOnlySpan<char> propertyName, out TElement value) where TElement : IElement;\r\n    bool TryGetProperty<TElement>(ReadOnlySpan<byte> utf8PropertyName, out TElement value) where TElement : IElement;\r\n\r\n    // Currently, there are separate GetInt(), GetByte(), etc. for the JsonElement type.\r\n    X GetX();\r\n    bool TryGetX(out x);\r\n\r\n    // I propose we skip those and simply use generics. If the consumer wishes to separate these out, e.g. for backwards compatibility, that's fine, but with the new `INumber` interface to handle numeric types we shouldn't face any roadblocks with a generic implementation. And if something comes up where that is the case, the consumer can always explicitly implement these and have them throw, then implement separate GetX and TryGetX methods.\r\n    TValue GetValue<TValue>();\r\n    bool TryGetValue<TValue>(out TValue);\r\n\r\n    string GetRawText();\r\n\r\n    // Provided for backwards-compatibility\r\n    bool ValueEquals(string? text);\r\n    bool ValueEquals(ReadOnlySpan<byte> utf8Text);\r\n\r\n    // Perform type comparison using default equality comparer.\r\n    bool ValueEquals<TValue>(TValue other);\r\n\r\n    void WriteTo(TextWriter writer);\r\n\r\n    public ArrayEnumerator EnumerateArray();\r\n\r\n    public ObjectEnumerator EnumerateObject();\r\n\r\n    public override string ToString();\r\n\r\n    public IElement Clone();\r\n}\r\n```\r\n\r\nCreate System.Text.Parsing.Document.JsonProperty\r\n```cs\r\npublic interface IProperty<TextWriter>\r\n    where TextWriter : ITextWriter\r\n{\r\n    string Name { get; }\r\n\r\n    bool NameEquals(string? text);\r\n    bool NameEquals(ReadOnlySpan<byte> utf8Text);\r\n    bool NameEquals(ReadOnlySpan<char> text);\r\n\r\n    bool WriteTo(TextWriter writer);\r\n\r\n    string ToString();\r\n}\r\n```\r\n\r\nCreate System.Text.Parsing.Reader.IReader\r\nMight also be a good candidate for an abstract class to implement a lot of the internal and private functionality.\r\n```cs\r\npublic interface IReader\r\n{\r\n    ReadOnlySpan<byte> ValueSpan { get; private set; }\r\n\r\n    long BytesConsumed { get; }\r\n\r\n    long TokenStartIndex { get; private set; }\r\n\r\n    int CurrentDepth { get; }\r\n\r\n    // Some sort of generic TokenType\r\n\r\n    bool HasValueSequence { get; private set; }\r\n    bool ValueIsEscaped { get; private set; }\r\n    bool IsFinalBlock { get; }\r\n    \r\n    ReadOnlySequence<byte> ValueSequence { get; private set; }\r\n\r\n    SequencePosition Position { get; }\r\n\r\n    ReaderState CurrentState { get; }\r\n\r\n    bool Read();\r\n\r\n    void Skip();\r\n    bool TrySkip();\r\n\r\n    bool ValueTextEquals(ReadOnlySpan<byte> utf8Text);\r\n    bool ValueTextEquals(string? text);\r\n    bool ValueTextEquals(ReadOnlySpan<char> text);\r\n}\r\n```\r\n\r\nCreate System.Text.Parsing.Writer.IWriter\r\nMight also be a good candidate for an abstract base class.\r\nI could go on forever I'm sure but this will get pretty repetitive. Discussion should be had for a list of candidates for migration/generalization.\r\n\n\n### API Usage\n\nThis library contains base classes and interfaces and should only be used by those wanting to implement their own parsing/serialization library. No samples are provided here because it's just standard implementation.\n\n### Alternative Designs\n\n_No response_\n\n### Risks\n\nThis proposal by itself should add no inherent risks as it is non-breaking. We are simply creating a new library and new types under its library.\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>Foxtrek64</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`api-suggestion`, `area-System.Text.Json`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2023-03-19T19:42:42Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-03-19T19:42:42Z",
          "id": "IC_kwDODI9FZc5X8Hml"
        },
        {
          "author": "MihaZupan",
          "body": "What would be the benefits of having such an abstraction?",
          "createdAt": "2023-03-19T20:43:14Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-03-20T07:36:47Z",
                "user": "svick"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-03-27T00:09:31Z",
                "user": "Sergio0694"
              }
            ],
            "totalCount": 2,
            "endCursor": "Y3Vyc29yOnYyOpHOC4kweg=="
          },
          "updatedAt": "2023-03-19T20:43:14Z",
          "id": "IC_kwDODI9FZc5X8LAE"
        },
        {
          "author": "TheBrambleShark",
          "body": "@MihaZupan Primarily code deduplication. I also plan to propose System.Text.Xml as a replacement to System.Xml and it would require me to create exact copies of files available in S.T.J or copies with minor changes.\n\nThis will also be useful for people writing parsing libraries for other text config files or markup/down or whatever.",
          "createdAt": "2023-03-19T20:53:38Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-03-19T20:53:38Z",
          "id": "IC_kwDODI9FZc5X8Lkg"
        },
        {
          "author": "MihaZupan",
          "body": "The set of APIs you are proposing looks very biased towards a \"text to POCO\" data (de)serialization use case, not generic text parsing. Who would be the consumer of these abstractions -- when would someone use something like `IReader`?\r\n\r\n> Primarily code deduplication\r\n\r\nCan you give an example of code that could be deduplicated?\r\n\r\n> This will also be useful for people writing parsing libraries for other text config files or markup/down or whatever.\r\n\r\nHow so? You mentioned markdown as an example, but I don't see what having a shared set of interfaces to implement would improve for a parsing library such as [Markdig](https://github.com/xoofx/markdig).\r\n",
          "createdAt": "2023-03-19T21:24:42Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-03-19T21:24:42Z",
          "id": "IC_kwDODI9FZc5X8OCP"
        },
        {
          "author": "TheBrambleShark",
          "body": "> The set of APIs you are proposing looks very biased towards a \"text to POCO\" data (de)serialization use case\r\n\r\nThis is correct. I'm perfectly fine changing the name of the proposed library if you feel something else is more appropriate.\r\n\r\n> Who would be the consumer of these abstractions\r\n\r\nPrimarily those who wish to develop a library that allows for the (de)serialization of standardized text files. For instance, I recently had to write a library that would deserialize and serialize EDI X12 204 Motor Carrier Load Tender files, which is a text file for use with AS400 which represents an entire shipment history for a particular load. Having a library like System.Text.Parsing would have been very useful, but in its absense I had to roll my own tokenizer and (de)serializer.\r\n\r\n> Can you give an example of code that would be deduplicated?\r\n\r\nI can probably give a more precise example once I actually start looking at implementation, but as previously mentioned a lot of the naming policies would need to be duplicated across multiple code bases as well as the bodies of more generic things like documents, elements, and properties. I imagine a large majority of the code within JsonDocument for instance would be nearly identical to that of an XmlDocument, just swapping out references to certain things. For instance, Utf8JsonWriter would become Uft8XmlWriter, but both writers would share the exact same signatures. Its only their functionality that would differ based on the format of the text file.\r\n\r\n> Markdown/Markdig\r\n\r\nYou have a good point here.  Not sure why I suggested Markdown honestly. This is too loose of a format to be (de)serialized in the same way as XML/Json/Yml/etc. Markup such as Xaml or Html could certainly be candidates, though that's cheating a bit since those are really just XML with a different schema from the point of view of a library like this.",
          "createdAt": "2023-03-19T22:43:05Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-03-20T00:10:20Z",
          "id": "IC_kwDODI9FZc5X8Snz"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Do you have any examples (e.g. a prototype repo) showing how these interfaces are implemented and how they are meant to be consumed by parsers? If I'm consuming an `IElement`, how can I tell what the right `TElement` type parameter is when I call one of the `TryGetProperty` methods?",
          "createdAt": "2023-03-22T18:33:21Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-03-22T18:33:21Z",
          "id": "IC_kwDODI9FZc5YOBvz"
        },
        {
          "author": "eerhardt",
          "body": "FYI - @agocke. This looks a lot like https://github.com/agocke/serde-dn.\r\n\r\n",
          "createdAt": "2023-03-22T18:36:11Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-03-22T18:36:11Z",
          "id": "IC_kwDODI9FZc5YOCgX"
        },
        {
          "author": "agocke",
          "body": "Yup, I think this is serde-dn. I would like to revisit putting serde-dn into the framework. After looking at the EventSource serialization implementation, I think that could be solved with serde-dn. I think having a format-agnostic approach to solving reflection-free serialization problems is going to be important for the long-tail of framework serialization issues where we either can't or don't want to build individual source generators for each format.",
          "createdAt": "2023-03-22T18:42:49Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-09-20T21:15:04Z",
                "user": "StephenHodgson"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHODzEkYg=="
          },
          "updatedAt": "2023-03-22T18:43:40Z",
          "id": "IC_kwDODI9FZc5YOEUO"
        },
        {
          "author": "TheBrambleShark",
          "body": "I can put together a prototype repo, certainly. I was experimenting with an `ISerializationOperators` interface as an expected member, sort of following the example laid out by the new `INumber<TSelf>` and its sub-types.\r\n\r\nThat said, serde-dn looks like it definitely satisfies the requirements I'm looking for here. I'm perfectly happy with modifying this proposal to instead be the merging of serde-dn into the framework.",
          "createdAt": "2023-03-22T19:03:01Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-03-22T19:03:01Z",
          "id": "IC_kwDODI9FZc5YOLEn"
        },
        {
          "author": "TheBrambleShark",
          "body": "Renaming proposal to System.Text.Serialization as I feel the name is more accurate than .Parsing.",
          "createdAt": "2023-03-22T19:42:17Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-03-22T19:42:17Z",
          "id": "IC_kwDODI9FZc5YOWAK"
        },
        {
          "author": "krwq",
          "body": "What's the end goal of this abstraction? We want to create generic DOM for all serializers?\r\n\r\nIMO there are nuanced differences between various serializers and various people have different preferences. I think this kind of abstraction should live in the application layer to decide what defaults are appropriate for specific format for specific use case i.e. for XML when would you prefer attribute over sub-element or reverse? If it's defined by standard then why not use XML layer directly?\r\n\r\nI'd need to see more evidence of use cases and what's the benefit of using this rather than going direct. Is it really that common for people to switch between different formats? Why not create serialization model and just use serializers, abstraction would be couple of lines of code and faster than using DOM APIs?",
          "createdAt": "2023-03-23T10:46:56Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-03-23T10:48:53Z",
                "user": "MihaZupan"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-03-26T08:29:17Z",
                "user": "svick"
              }
            ],
            "totalCount": 2,
            "endCursor": "Y3Vyc29yOnYyOpHOC4jxuA=="
          },
          "updatedAt": "2023-03-23T10:47:39Z",
          "id": "IC_kwDODI9FZc5YRcTR"
        },
        {
          "author": "eiriktsarpalis",
          "body": "There are benefits to creating format-agnostic serializers and other platforms have seen success in using these: serde in Rust, pickling in Scala and FsPickler in F# are few examples. It means that you have to deal with the immense complexity of writing a serializer once and extending support to a specific format is simply a matter of implementing a couple of IFormatReader/IFormatWriter interfaces.\r\n\r\nThe are downsides too, most importantly such interfaces typically make implicit assumptions about the grammar that the underlying format supports. So if it's been designed around JSON then it tends to produce awkward/unidiomatic XML.",
          "createdAt": "2023-03-23T15:18:51Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-03-23T15:18:51Z",
          "id": "IC_kwDODI9FZc5YTCgx"
        },
        {
          "author": "agocke",
          "body": "One of the main benefits is that it allows reuse of the source generator, so that you only need one source generator to support many formats. This massively reduces the investment needed to make things AOT compatible.",
          "createdAt": "2023-03-23T17:00:55Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-03-23T17:02:14Z",
                "user": "eiriktsarpalis"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-03-26T14:07:55Z",
                "user": "PaulusParssinen"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-09-18T16:59:19Z",
                "user": "StephenHodgson"
              }
            ],
            "totalCount": 3,
            "endCursor": "Y3Vyc29yOnYyOpHODys01Q=="
          },
          "updatedAt": "2023-03-23T17:00:55Z",
          "id": "IC_kwDODI9FZc5YTrbB"
        },
        {
          "author": "agocke",
          "body": "Other languages: kotlinx.serialization in Kotlin, and Codable in Swift.\r\n\r\n.NET's one-serializer-per-format is actually quite unusual.",
          "createdAt": "2023-03-23T17:03:50Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-03-23T17:05:12Z",
                "user": "eiriktsarpalis"
              },
              {
                "content": "EYES",
                "createdAt": "2024-02-24T08:10:10Z",
                "user": "MineCake147E"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-09-20T21:17:03Z",
                "user": "StephenHodgson"
              }
            ],
            "totalCount": 3,
            "endCursor": "Y3Vyc29yOnYyOpHODzEk-w=="
          },
          "updatedAt": "2023-03-23T17:03:50Z",
          "id": "IC_kwDODI9FZc5YTsl0"
        },
        {
          "author": "krwq",
          "body": "Per offline conversation I'm assigning @agocke for long-term driving this (likely won't happen in 8.0, possibly for 9.0)",
          "createdAt": "2023-03-23T17:06:39Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-03-23T17:06:51Z",
                "user": "agocke"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-03-24T14:28:18Z",
                "user": "TheBrambleShark"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-09-20T21:17:10Z",
                "user": "StephenHodgson"
              }
            ],
            "totalCount": 3,
            "endCursor": "Y3Vyc29yOnYyOpHODzElBA=="
          },
          "updatedAt": "2023-03-23T17:06:39Z",
          "id": "IC_kwDODI9FZc5YTtsH"
        },
        {
          "author": "Ayazcan3333",
          "body": "// I have only included public interfaces from JsonDocument here, but it may be prudent to expose some internal methods as well.\r\npublic interface ITextDocument<TRoot, TextWriter> : IDisposable\r\n    where TRoot : IElement\r\n    where TextWriter : ITextWriter\r\n{\r\n    void WriteTo(TextWriter writer);\r\n}",
          "createdAt": "2023-04-02T22:00:17Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-04-02T22:00:17Z",
          "id": "IC_kwDODI9FZc5ZBDyg"
        }
      ],
      "totalCount": 16,
      "endCursor": "Y3Vyc29yOnYyOpHOWQQ8oA=="
    },
    "url": "https://github.com/dotnet/runtime/issues/83652",
    "title": "[API Proposal]: Consider adding a format-agnostic serializer."
  },
  {
    "author": "Varorbc",
    "labels": [
      "api-suggestion",
      "area-System.Text.Json",
      "wishlist"
    ],
    "createdAt": "2023-03-21T02:42:05Z",
    "body": "### Description\n\nRequiredAttribute does not validate null when I sent null request data\n\n### Reproduction Steps\n\n1.\r\n\r\n```\r\nusing System.ComponentModel.DataAnnotations;\r\nusing Microsoft.AspNetCore.Mvc;\r\n\r\nnamespace WebApi.Controllers;\r\n\r\n[ApiController]\r\n[Route(\"[controller]\")]\r\npublic class TestController : ControllerBase\r\n{\r\n    [HttpPost]\r\n    public Guid Test([FromBody] TestModel test) => test.Guid;\r\n}\r\n\r\npublic class TestModel\r\n{\r\n    [Required(DisallowAllDefaultValues = true)]\r\n    public Guid Guid { get; set; }\r\n}\r\n\r\n```\r\n\r\n2.\r\n```\r\n{\r\n  \"guid\": null\r\n}\r\n```\n\n### Expected behavior\n\n```\r\n{\r\n  \"type\": \"https://tools.ietf.org/html/rfc9110#section-15.5.1\",\r\n  \"title\": \"One or more validation errors occurred.\",\r\n  \"status\": 400,\r\n  \"errors\": {\r\n    \"Guid\": [\r\n      \"The Guid field is required.\"\r\n    ]\r\n  },\r\n  \"traceId\": \"00-d51bc3b8ec11932427c3b20e31bfad41-9c399e6a72b8608b-00\"\r\n}\r\n```\n\n### Actual behavior\n\n```\r\n{\r\n  \"type\": \"https://tools.ietf.org/html/rfc9110#section-15.5.1\",\r\n  \"title\": \"One or more validation errors occurred.\",\r\n  \"status\": 400,\r\n  \"errors\": {\r\n    \"test\": [\r\n      \"The test field is required.\"\r\n    ],\r\n    \"$.guid\": [\r\n      \"The JSON value could not be converted to System.Guid. Path: $.guid | LineNumber: 1 | BytePositionInLine: 14.\"\r\n    ]\r\n  },\r\n  \"traceId\": \"00-e1a35ba8e58dca7b176d433b24dab495-26b5f4265e056d22-00\"\r\n}\r\n```\n\n### Regression?\n\n_No response_\n\n### Known Workarounds\n\n_No response_\n\n### Configuration\n\n_No response_\n\n### Other information\n\n_No response_",
    "number": 83706,
    "reactions": {
      "hasNextPage": false,
      "nodes": [],
      "totalCount": 0,
      "endCursor": null
    },
    "updatedAt": "2023-08-04T16:17:27Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @ajcvickers, @bricelam, @roji\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\n### Description\n\nRequiredAttribute does not validate null when I sent null request data\n\n### Reproduction Steps\n\n1.\r\n\r\n```\r\nusing System.ComponentModel.DataAnnotations;\r\nusing Microsoft.AspNetCore.Mvc;\r\n\r\nnamespace WebApi.Controllers;\r\n\r\n[ApiController]\r\n[Route(\"[controller]\")]\r\npublic class TestController : ControllerBase\r\n{\r\n    [HttpPost]\r\n    public Guid Test([FromBody] TestModel test) => test.Guid;\r\n}\r\n\r\npublic class TestModel\r\n{\r\n    [Required(DisallowAllDefaultValues = true)]\r\n    public Guid Guid { get; set; }\r\n}\r\n\r\n```\r\n\r\n2.\r\n```\r\n{\r\n  \"guid\": null\r\n}\r\n```\n\n### Expected behavior\n\n```\r\n{\r\n  \"type\": \"https://tools.ietf.org/html/rfc9110#section-15.5.1\",\r\n  \"title\": \"One or more validation errors occurred.\",\r\n  \"status\": 400,\r\n  \"errors\": {\r\n    \"Guid\": [\r\n      \"The Guid field is required.\"\r\n    ]\r\n  },\r\n  \"traceId\": \"00-d51bc3b8ec11932427c3b20e31bfad41-9c399e6a72b8608b-00\"\r\n}\r\n```\n\n### Actual behavior\n\n```\r\n{\r\n  \"type\": \"https://tools.ietf.org/html/rfc9110#section-15.5.1\",\r\n  \"title\": \"One or more validation errors occurred.\",\r\n  \"status\": 400,\r\n  \"errors\": {\r\n    \"test\": [\r\n      \"The test field is required.\"\r\n    ],\r\n    \"$.guid\": [\r\n      \"The JSON value could not be converted to System.Guid. Path: $.guid | LineNumber: 1 | BytePositionInLine: 14.\"\r\n    ]\r\n  },\r\n  \"traceId\": \"00-e1a35ba8e58dca7b176d433b24dab495-26b5f4265e056d22-00\"\r\n}\r\n```\n\n### Regression?\n\n_No response_\n\n### Known Workarounds\n\n_No response_\n\n### Configuration\n\n_No response_\n\n### Other information\n\n_No response_\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>Varorbc</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`area-System.ComponentModel.DataAnnotations`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2023-03-21T02:42:11Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-03-21T02:42:11Z",
          "id": "IC_kwDODI9FZc5YDFXx"
        },
        {
          "author": "eiriktsarpalis",
          "body": "The error you're seeing comes from System.Text.Json, which fails before the validator gets to validate the deserialized object. To get System.Text.Json to support `null` values for value types, you should consider marking your property as nullable.\r\n\r\nIn the future, we might want to consider exposing a flag on `JsonSerializerOptions` that lets users treat `null` values in structs as if they're missing altogether (something like `JsonIgnoreCondition.WhenReadingNull`).",
          "createdAt": "2023-03-22T19:08:03Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-04-09T00:01:04Z",
                "user": "colejohnson66"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOC5e6QA=="
          },
          "updatedAt": "2023-03-22T19:08:03Z",
          "id": "IC_kwDODI9FZc5YOMde"
        },
        {
          "author": null,
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\n### Description\n\nRequiredAttribute does not validate null when I sent null request data\n\n### Reproduction Steps\n\n1.\r\n\r\n```\r\nusing System.ComponentModel.DataAnnotations;\r\nusing Microsoft.AspNetCore.Mvc;\r\n\r\nnamespace WebApi.Controllers;\r\n\r\n[ApiController]\r\n[Route(\"[controller]\")]\r\npublic class TestController : ControllerBase\r\n{\r\n    [HttpPost]\r\n    public Guid Test([FromBody] TestModel test) => test.Guid;\r\n}\r\n\r\npublic class TestModel\r\n{\r\n    [Required(DisallowAllDefaultValues = true)]\r\n    public Guid Guid { get; set; }\r\n}\r\n\r\n```\r\n\r\n2.\r\n```\r\n{\r\n  \"guid\": null\r\n}\r\n```\n\n### Expected behavior\n\n```\r\n{\r\n  \"type\": \"https://tools.ietf.org/html/rfc9110#section-15.5.1\",\r\n  \"title\": \"One or more validation errors occurred.\",\r\n  \"status\": 400,\r\n  \"errors\": {\r\n    \"Guid\": [\r\n      \"The Guid field is required.\"\r\n    ]\r\n  },\r\n  \"traceId\": \"00-d51bc3b8ec11932427c3b20e31bfad41-9c399e6a72b8608b-00\"\r\n}\r\n```\n\n### Actual behavior\n\n```\r\n{\r\n  \"type\": \"https://tools.ietf.org/html/rfc9110#section-15.5.1\",\r\n  \"title\": \"One or more validation errors occurred.\",\r\n  \"status\": 400,\r\n  \"errors\": {\r\n    \"test\": [\r\n      \"The test field is required.\"\r\n    ],\r\n    \"$.guid\": [\r\n      \"The JSON value could not be converted to System.Guid. Path: $.guid | LineNumber: 1 | BytePositionInLine: 14.\"\r\n    ]\r\n  },\r\n  \"traceId\": \"00-e1a35ba8e58dca7b176d433b24dab495-26b5f4265e056d22-00\"\r\n}\r\n```\n\n### Regression?\n\n_No response_\n\n### Known Workarounds\n\n_No response_\n\n### Configuration\n\n_No response_\n\n### Other information\n\n_No response_\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>Varorbc</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`area-System.Text.Json`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2023-03-22T19:08:23Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-03-22T19:08:23Z",
          "id": "IC_kwDODI9FZc5YOMjz"
        },
        {
          "author": "eiriktsarpalis",
          "body": "At risk of stating the obvious, you should consider making your struct property nullable if you're expecting `null` values in the JSON you're trying to deserialize.",
          "createdAt": "2023-08-04T11:25:23Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-08-04T11:25:23Z",
          "id": "IC_kwDODI9FZc5jRNR6"
        },
        {
          "author": "Stabzs",
          "body": "I'd like to request that the proposal be expanded with a `WhenNull` option to handle both read and write cases, since combinatorial attributes/flags will not be supported.",
          "createdAt": "2023-08-04T16:17:26Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-08-04T16:19:15Z",
                "user": "eiriktsarpalis"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-08-14T01:27:47Z",
                "user": "mozts2005"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-02-18T02:22:32Z",
                "user": "seungyongshim"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-07-31T13:54:38Z",
                "user": "JasonLandbridge"
              }
            ],
            "totalCount": 4,
            "endCursor": "Y3Vyc29yOnYyOpHODsQ-sw=="
          },
          "updatedAt": "2023-08-04T16:17:26Z",
          "id": "IC_kwDODI9FZc5jSydG"
        }
      ],
      "totalCount": 5,
      "endCursor": "Y3Vyc29yOnYyOpHOY0snRg=="
    },
    "url": "https://github.com/dotnet/runtime/issues/83706",
    "title": "System.Text.Json throws when deserializing JSON `null` into struct properties."
  },
  {
    "author": "astrberg",
    "labels": [
      "bug",
      "area-System.Text.Json"
    ],
    "createdAt": "2023-03-22T10:27:35Z",
    "body": "### Description\r\n\r\nUsing JsonObject contructor with JsonNodeOptions: PropertyNameCaseInsensitive = true results in incorrect options behavior.\r\n\r\n### Reproduction Steps\r\n\r\nRun following code snippet and note the value of variable \"iAmNull\"\r\n```cs\r\nvar jsonObject = new JsonObject(new List<KeyValuePair<string, JsonNode?>> { new(\"key\", \"value\") }, new JsonNodeOptions {PropertyNameCaseInsensitive = true} );\r\nvar iAmNull = jsonObject[\"kEy\"];\r\n```\r\n\r\n### Expected behavior\r\n\r\niAmNull should be 'value'\r\n\r\n### Actual behavior\r\n\r\niAmNull is 'null'\r\n\r\n### Regression?\r\n\r\n_No response_\r\n\r\n### Known Workarounds\r\n\r\nUse a different constructor. See code snippet:\r\n```cs\r\nvar jsonNodeOptions = new JsonNodeOptions { PropertyNameCaseInsensitive = true };\r\nvar jsonObject = new JsonObject(jsonNodeOptions) { new(\"key\", \"value\") };\r\n\r\nvar iAmNotNull= jsonObject[\"kEy\"];\r\n```\r\n\r\n### Configuration\r\n\r\n- Which version of .NET is the code running on? .NET 6\r\n- What OS and version, and what distro if applicable? Windows 10 22H2\r\n- What is the architecture (x64, x86, ARM, ARM64)? x64\r\n- Do you know whether it is specific to that configuration? Do you know whether it is specific to that configuration? No\r\n\r\n\r\n### Other information\r\n\r\n_No response_",
    "number": 83766,
    "reactions": {
      "hasNextPage": false,
      "nodes": [],
      "totalCount": 0,
      "endCursor": null
    },
    "updatedAt": "2023-03-23T10:18:53Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\n### Description\n\nUsing JsonObject contructor with JsonNodeOptions: PropertyNameCaseInsensitive = true results in incorrect options behavior.\n\n### Reproduction Steps\n\nRun following code snippet and note the value of variable \"iAmNull\"\r\n```cs\r\nvar jsonObject = new JsonObject(new List<KeyValuePair<string, JsonNode?>> { new(\"key\", \"value\") }, new JsonNodeOptions {PropertyNameCaseInsensitive = true} );\r\nvar iAmNull = jsonObject[\"kEy\"];\r\n```\n\n### Expected behavior\n\niAmNull should be = \"value\"\n\n### Actual behavior\n\niAmNull should NOT = null\n\n### Regression?\n\n_No response_\n\n### Known Workarounds\n\nUse a different constructor. See code snippet:\r\n```cs\r\nvar jsonNodeOptions = new JsonNodeOptions { PropertyNameCaseInsensitive = true };\r\nvar jsonObject = new JsonObject(jsonNodeOptions) { new(\"key\", \"value\") };\r\n\r\nvar iAmNotNull= jsonObject[\"kEy\"];\r\n```\n\n### Configuration\n\n- Which version of .NET is the code running on? .NET 6\r\n- What OS and version, and what distro if applicable? Windows 10 22H2\r\n- What is the architecture (x64, x86, ARM, ARM64)? x64\r\n- Do you know whether it is specific to that configuration? Do you know whether it is specific to that configuration? No\r\n\n\n### Other information\n\n_No response_\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>astrberg</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`area-System.Text.Json`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2023-03-22T10:28:33Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-03-22T10:28:33Z",
          "id": "IC_kwDODI9FZc5YLEEB"
        }
      ],
      "totalCount": 1,
      "endCursor": "Y3Vyc29yOnYyOpHOWCxBAQ=="
    },
    "url": "https://github.com/dotnet/runtime/issues/83766",
    "title": "JsonObject constructor incorrect options behavior for JsonNodeOptions: PropertyNameCaseInsensitive"
  },
  {
    "author": "krwq",
    "labels": [
      "api-suggestion",
      "area-System.Text.Json"
    ],
    "createdAt": "2023-03-28T12:49:40Z",
    "body": "https://github.com/dotnet/runtime/issues/78556 (PR: https://github.com/dotnet/runtime/pull/83669) is adding support for populating properties. The only missing element is top-level methods allowing scenarios similar to Patch.\r\n\r\nHypothetical usage:\r\n\r\n```csharp\r\nPerson p = new()\r\n{\r\n  Name = \"John Doe\",\r\n  Age = 42,\r\n};\r\n\r\nJsonSerializer.PopulateObject(\"\"\"{\"Age\": 47}\"\"\", typeof(Person), p); // order of args TBD\r\n// p.Name => \"John Doe\"\r\n// p.Age => 47\r\n\r\nclass Person\r\n{\r\n  public string Name { get; set; }\r\n  public int Age { get; set; }\r\n}\r\n```\r\n\r\nExample APIs could look like these:\r\n\r\n```csharp\r\npublic static partial class JsonSerializer\r\n{\r\n    public static void PopulateObject(System.IO.Stream utf8Json, System.Type type, object target, System.Text.Json.JsonSerializerOptions? options = null) { throw null; }\r\n    public static void PopulateObject(System.ReadOnlySpan<byte> utf8Json, System.Type type, object target, System.Text.Json.JsonSerializerOptions? options = null) { throw null; }\r\n    public static void PopulateObject([System.Diagnostics.CodeAnalysis.StringSyntaxAttribute(\"Json\")] System.ReadOnlySpan<char> json, System.Type type, object target, System.Text.Json.JsonSerializerOptions? options = null) { throw null; }\r\n    public static void PopulateObject([System.Diagnostics.CodeAnalysis.StringSyntaxAttribute(\"Json\")] string json, System.Type type, object target, System.Text.Json.JsonSerializerOptions? options = null) { throw null; }\r\n    public static void PopulateObject(ref System.Text.Json.Utf8JsonReader reader, System.Type type, object target, System.Text.Json.JsonSerializerOptions? options = null) { throw null; }\r\n    \r\n    public static System.Threading.Tasks.ValueTask PopulateObjectAsync(System.IO.Stream utf8Json, System.Type type, object target, System.Text.Json.JsonSerializerOptions? options = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) { throw null; }\r\n    public static System.Threading.Tasks.ValueTask PopulateObjectAsync<TValue>(System.IO.Stream utf8Json, TValue target, System.Text.Json.JsonSerializerOptions? options = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) where TValue : class { throw null; }\r\n    public static void PopulateObject<TValue>(System.IO.Stream utf8Json, TValue target, System.Text.Json.JsonSerializerOptions? options = null) where TValue : class { throw null; }\r\n    public static void PopulateObject<TValue>(System.ReadOnlySpan<byte> utf8Json, TValue target, System.Text.Json.JsonSerializerOptions? options = null) where TValue : class { throw null; }\r\n    public static void PopulateObject<TValue>([System.Diagnostics.CodeAnalysis.StringSyntaxAttribute(\"Json\")] System.ReadOnlySpan<char> json, TValue target, System.Text.Json.JsonSerializerOptions? options = null) where TValue : class { throw null; }\r\n    public static void PopulateObject<TValue>([System.Diagnostics.CodeAnalysis.StringSyntaxAttribute(\"Json\")] string json, TValue target, System.Text.Json.JsonSerializerOptions? options = null) where TValue : class { throw null; }\r\n    \r\n    public static void PopulateObject<TValue>(ref System.Text.Json.Utf8JsonReader reader, TValue target, System.Text.Json.JsonSerializerOptions? options = null) where TValue : class { throw null; }\r\n    \r\n    // TODO: add also JsonTypeInfo<T> and JsonSerializerContext overloads\r\n}\r\n```\r\n\r\n## Open questions\r\n\r\n- structs (if so then we either need `object` + `Type` or `ref`)\r\n- Do we need/want all overloads? Which one is most generic? (reader?) Which one is most popular (string?) Maybe just these two?\r\n\r\n## Cost\r\n\r\nBetter implementations would be to make converters implement Populate directly, I already have a prototype of that here: https://github.com/dotnet/runtime/pull/79659 - there is still some work left but theoretically should be functional (prototype was started before my PR for properties and needs rebase and integration and bug fixes likely - current version should pass all or most tests).\r\nThe simple/hacky implementation could be done if we added 1-2 overloads (i.e. async+ Utf8JsonReader and sync string overloads which take object and type) we should satisfy most scenarios without spending super long on that. Hacky implementation could just create top level property info and pretend root level is actually property. It would be an allocation or two but we don't need to do refactoring (to be fair that refactor is due and will be needed for converters work so I'm fine with any decision we make). The biggest cost will still be testing all overloads and blocking all improper configurations and testing through all possible converters supporting populate (if we restrict refactoring we technically can skip that part as it's already tested with properties).\r\n\r\nOne factor to mention here is that refactoring is needed if we are to create extension for converters (there are several open issues related to that). I've stubbed out deserialization part of that in the prototype PR. It should make the other work cheaper. Serialization bit needs more thinking before it can be productized but if we start using it internally we should be able to flush out most of the issues.\r\n\r\nAlternative APIs:\r\n- @BrunoBlanes: https://github.com/dotnet/runtime/issues/78556#issuecomment-1341470307 (`Deserialize(ref ...)`)\r\n\r\nKnown workarounds:\r\nhttps://github.com/dotnet/runtime/issues/78556#issuecomment-1331932270 - it's far from perfect but allows to unblock if really needed.\r\n\r\ncc: @BrunoBlanes @johncrim @dersia @VincentH-Net @eiriktsarpalis @layomia @tarekgh @gregsdennis ",
    "number": 84018,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "HEART",
          "createdAt": "2023-03-28T16:15:20Z",
          "user": "VincentH-Net"
        },
        {
          "content": "EYES",
          "createdAt": "2023-03-28T16:15:40Z",
          "user": "VincentH-Net"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-03-28T17:20:32Z",
          "user": "iamcarbon"
        },
        {
          "content": "HEART",
          "createdAt": "2023-03-28T17:20:34Z",
          "user": "iamcarbon"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-03-29T18:54:59Z",
          "user": "kronic"
        },
        {
          "content": "HEART",
          "createdAt": "2023-08-16T20:20:26Z",
          "user": "kjeske"
        },
        {
          "content": "EYES",
          "createdAt": "2023-08-16T20:20:29Z",
          "user": "kjeske"
        },
        {
          "content": "HEART",
          "createdAt": "2023-08-24T02:21:47Z",
          "user": "tamusjroyce"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-08-24T02:21:48Z",
          "user": "tamusjroyce"
        },
        {
          "content": "EYES",
          "createdAt": "2023-08-24T02:21:54Z",
          "user": "tamusjroyce"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-08-25T10:46:19Z",
          "user": "Waleed-KH"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-09-21T07:34:17Z",
          "user": "QianMoXi"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-01-04T14:58:18Z",
          "user": "alasdair-cooper"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-03-19T23:13:23Z",
          "user": "reflectronic"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-03-25T14:29:54Z",
          "user": "aromaa"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-04-15T18:34:54Z",
          "user": "Mrxx99"
        },
        {
          "content": "HEART",
          "createdAt": "2024-04-15T18:34:55Z",
          "user": "Mrxx99"
        },
        {
          "content": "EYES",
          "createdAt": "2024-04-15T18:34:56Z",
          "user": "Mrxx99"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-06-26T14:47:57Z",
          "user": "jsgoupil"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-10-02T07:18:02Z",
          "user": "Gaulomatic"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-11-06T02:00:32Z",
          "user": "shravan2x"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-01-06T09:25:26Z",
          "user": "khellang"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-03-11T17:58:05Z",
          "user": "Danielku15"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-04-04T21:24:27Z",
          "user": "Ghost4Man"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-06-03T09:40:18Z",
          "user": "nil4"
        }
      ],
      "totalCount": 25,
      "endCursor": "Y3Vyc29yOnYyOpHODDMkQA=="
    },
    "updatedAt": "2023-05-30T15:52:18Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\nhttps://github.com/dotnet/runtime/issues/78556 is adding support for populating properties. The only missing element is top-level methods allowing scenarios similar to Patch.\r\n\r\nHypothetical usage:\r\n\r\n```csharp\r\nPerson p = new()\r\n{\r\n  Name = \"John Doe\",\r\n  Age = 42,\r\n};\r\n\r\nJsonSerializer.PopulateObject(\"\"\"{\"Age\": 47}\"\"\", typeof(Person), p); // order of args TBD\r\n// p.Age => 47\r\n\r\nclass Person\r\n{\r\n  public string Name { get; set; }\r\n  public int Age { get; set; }\r\n}\r\n```\r\n\r\nExample APIs could look like these:\r\n\r\n```csharp\r\npublic static partial class JsonSerializer\r\n{\r\n    public static void PopulateObject(System.IO.Stream utf8Json, System.Type type, object target, System.Text.Json.JsonSerializerOptions? options = null) { throw null; }\r\n    public static void PopulateObject(System.ReadOnlySpan<byte> utf8Json, System.Type type, object target, System.Text.Json.JsonSerializerOptions? options = null) { throw null; }\r\n    public static void PopulateObject([System.Diagnostics.CodeAnalysis.StringSyntaxAttribute(\"Json\")] System.ReadOnlySpan<char> json, System.Type type, object target, System.Text.Json.JsonSerializerOptions? options = null) { throw null; }\r\n    public static void PopulateObject([System.Diagnostics.CodeAnalysis.StringSyntaxAttribute(\"Json\")] string json, System.Type type, object target, System.Text.Json.JsonSerializerOptions? options = null) { throw null; }\r\n    public static void PopulateObject(ref System.Text.Json.Utf8JsonReader reader, System.Type type, object target, System.Text.Json.JsonSerializerOptions? options = null) { throw null; }\r\n    \r\n    public static System.Threading.Tasks.ValueTask PopulateObjectAsync(System.IO.Stream utf8Json, System.Type type, object target, System.Text.Json.JsonSerializerOptions? options = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) { throw null; }\r\n    public static System.Threading.Tasks.ValueTask PopulateObjectAsync<TValue>(System.IO.Stream utf8Json, TValue target, System.Text.Json.JsonSerializerOptions? options = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) where TValue : class { throw null; }\r\n    public static void PopulateObject<TValue>(System.IO.Stream utf8Json, TValue target, System.Text.Json.JsonSerializerOptions? options = null) where TValue : class { throw null; }\r\n    public static void PopulateObject<TValue>(System.ReadOnlySpan<byte> utf8Json, TValue target, System.Text.Json.JsonSerializerOptions? options = null) where TValue : class { throw null; }\r\n    public static void PopulateObject<TValue>([System.Diagnostics.CodeAnalysis.StringSyntaxAttribute(\"Json\")] System.ReadOnlySpan<char> json, TValue target, System.Text.Json.JsonSerializerOptions? options = null) where TValue : class { throw null; }\r\n    public static void PopulateObject<TValue>([System.Diagnostics.CodeAnalysis.StringSyntaxAttribute(\"Json\")] string json, TValue target, System.Text.Json.JsonSerializerOptions? options = null) where TValue : class { throw null; }\r\n    \r\n    public static void PopulateObject<TValue>(ref System.Text.Json.Utf8JsonReader reader, TValue target, System.Text.Json.JsonSerializerOptions? options = null) where TValue : class { throw null; }\r\n    \r\n    // TODO: add also JsonTypeInfo<T> and JsonSerializerContext overloads\r\n}\r\n```\r\n\r\nOpen questions:\r\n- structs (if so then we either need `object` + `Type` or `ref`)\r\n- Do we need/want all overloads? Which one is most generic? (reader?) Which one is most popular (string?) Maybe just these two?\r\n\r\nAlternative APIs:\r\n- @BrunoBlanes: https://github.com/dotnet/runtime/issues/78556#issuecomment-1341470307 (`Deserialize(ref ...)`)\r\n\r\nKnown workarounds:\r\nhttps://github.com/dotnet/runtime/issues/78556#issuecomment-1331932270 - it's far from perfect but allows to unblock if really needed.\r\n\r\ncc: @BrunoBlanes @johncrim @dersia @VincentH-Net @eiriktsarpalis @layomia @tarekgh @gregsdennis \n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>krwq</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`area-System.Text.Json`, `untriaged`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2023-03-28T12:49:49Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-03-28T12:49:49Z",
          "id": "IC_kwDODI9FZc5YnzSZ"
        }
      ],
      "totalCount": 1,
      "endCursor": "Y3Vyc29yOnYyOpHOWJ80mQ=="
    },
    "url": "https://github.com/dotnet/runtime/issues/84018",
    "title": "Support top-level populate methods for JSON (patch)"
  },
  {
    "author": "krwq",
    "labels": [
      "documentation",
      "area-System.Text.Json",
      "help wanted"
    ],
    "createdAt": "2023-03-29T10:35:39Z",
    "body": "Currently some of our attributes contain metadata reference and some don't.\r\n\r\nReview all of them and make sure they do (when possible):\r\nhttps://github.com/dotnet/runtime/tree/main/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/Attributes\r\n\r\n_Originally posted by @layomia in https://github.com/dotnet/runtime/pull/83669#discussion_r1150851799_",
    "number": 84069,
    "reactions": {
      "hasNextPage": false,
      "nodes": [],
      "totalCount": 0,
      "endCursor": null
    },
    "updatedAt": "2023-03-29T10:35:47Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\nCurrently some of our attributes contain metadata reference and some don't.\r\n\r\nReview all of them and make sure they do (when possible):\r\nhttps://github.com/dotnet/runtime/tree/main/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/Attributes\r\n\r\n_Originally posted by @layomia in https://github.com/dotnet/runtime/pull/83669#discussion_r1150851799_\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>krwq</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`documentation`, `area-System.Text.Json`, `help wanted`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>Future</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2023-03-29T10:35:46Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-03-29T10:35:46Z",
          "id": "IC_kwDODI9FZc5Ytmx5"
        }
      ],
      "totalCount": 1,
      "endCursor": "Y3Vyc29yOnYyOpHOWLZseQ=="
    },
    "url": "https://github.com/dotnet/runtime/issues/84069",
    "title": "JSON attributes docs should have mentions for corresponding metadata"
  },
  {
    "author": "gregsdennis",
    "labels": [
      "area-System.Text.Json",
      "tenet-performance"
    ],
    "createdAt": "2023-04-02T23:51:17Z",
    "body": "Reading through the [`JsonSerializer` code](https://github.com/dotnet/runtime/blob/8ffad5201e02ec8657065aabc543135903767535/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/JsonSerializer.Read.Node.cs#L30), these extension methods merely write out the JSON data into text and then deserialize that text.  Wouldn't it be faster to deserialize directly from `JsonNode`?\r\n\r\nI do see that efforts have been made to utilize spans and buffer pools, which helps with memory consumption.\r\n\r\nAlso, the current method does provide some benefits:\r\n\r\n- single source of truth - all serialization happens through a single code path\r\n- easier to maintian\r\n\r\n### Why do I go through `JsonNode`?\r\n\r\nUnder various scenarios, I may need to inspect, analyze, or even manipulate the data before deserializing into my model.  Having the data in the mutable JSON data model provided by `JsonNode` allows me to do this.  My process is:\r\n\r\n1. Parse to `JsonNode`\r\n2. Muck about with it\r\n3. Deserialize to my model\r\n\r\nStep 3 can then be broken down into:\r\n\r\n3a. re-serialize the `JsonNode` to text\r\n3b. deserialize my model from text (which means parsing it again)\r\n\r\nI think this is rather wasteful when you _could_ just go directly to the model from `JsonNode`. (My previous JSON library, Manatee.Json, worked by deserializing directly from the JSON model.)",
    "number": 84234,
    "reactions": {
      "hasNextPage": false,
      "nodes": [],
      "totalCount": 0,
      "endCursor": null
    },
    "updatedAt": "2023-04-06T07:41:31Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\nReading through the [`JsonSerializer` code](https://github.com/dotnet/runtime/blob/8ffad5201e02ec8657065aabc543135903767535/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/JsonSerializer.Read.Node.cs#L30), these extension methods merely write out the JSON data into text and then deserialize that text.  Wouldn't it be faster to deserialize directly from `JsonNode`?\r\n\r\nI do see that efforts have been made to utilize spans and buffer pools, which helps with memory consumption.\r\n\r\nAlso, the current method does provide some benefits:\r\n\r\n- single source of truth - all serialization happens through a single code path\r\n- easier to maintian\r\n\r\n## Why do I go through `JsonNode`?\r\n\r\nUnder various scenarios, I may need to inspect or even manipulate the data before deserializing into my model.  Having the data in the mutable JSON data model provided by `JsonNode` allows me to do this.  My process is:\r\n\r\n1. Parse to `JsonNode`\r\n2. Muck about with it\r\n3. Deserialize to my model\r\n\r\nStep 3 can then be broken down into:\r\n\r\n3a. re-serialize the `JsonNode` to text\r\n3b. deserialize my model from text (which means parsing it again)\r\n\r\nI think this is rather wasteful when you _could_ just go directly to the model from `JsonNode`. (My previous JSON library, Manatee.Json, worked by deserializing directly from the JSON model.)\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>gregsdennis</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`area-System.Text.Json`, `untriaged`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2023-04-02T23:51:27Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "LAUGH",
                "createdAt": "2023-04-02T23:51:35Z",
                "user": "gregsdennis"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOC5EuQg=="
          },
          "updatedAt": "2023-04-02T23:51:27Z",
          "id": "IC_kwDODI9FZc5ZBJEX"
        },
        {
          "author": "eiriktsarpalis",
          "body": "The problem is that STJ's serialization and deserialization infrastructure is built on top of `Utf8JsonWriter` and `Utf8JsonReader` which are not abstractable types. `Utf8JsonReader` in particular is a ref struct that can only handle UTF-8 encoded buffers. So this is not merely a matter of inefficient code that could be improved, rather, it is an inefficiency forced by lack of abstraction in the underlying reader/converter infrastructure. To be perfectly honest, I don't think it could be improved without introducing major breaking changes.\r\n\r\n> I think this is rather wasteful when you could just go directly to the model from JsonNode. (My previous JSON library, Manatee.Json, worked by deserializing directly from the JSON model.)\r\n\r\nAbsolutely, and this is generally true for serialization libraries that abstract their reader and writer types. For example Json.NET has a dedicated [`JsonReader` implementation](https://github.com/JamesNK/Newtonsoft.Json/blob/0a2e291c0d9c0c7675d445703e51750363a549ef/Src/Newtonsoft.Json/Linq/JTokenReader.cs) for their DOM type. ",
          "createdAt": "2023-04-03T11:33:32Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-04-03T11:33:32Z",
          "id": "IC_kwDODI9FZc5ZDwjc"
        },
        {
          "author": "gregsdennis",
          "body": "Yeah, that's definitely something to think about.  And creating extended functionality (such as I could do in a library) would be laborious to maintain, trying to keep it in line with what the text deserialization does.\r\n\r\nIs there a reason you can't extract an interface from `Utf8JsonReader` and build the serializer on that?  You could create overloads in `JsonConverter<T>` for the read/write methods instead of changing their signature.\r\n\r\nI'm not sure what else might use it in a signature...",
          "createdAt": "2023-04-04T22:19:57Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-04-04T22:19:57Z",
          "id": "IC_kwDODI9FZc5ZNW5V"
        },
        {
          "author": "eiriktsarpalis",
          "body": "> Is there a reason you can't extract an interface from Utf8JsonReader and build the serializer on that?\r\n\r\nIt is a ref struct, so unfortunately we can't:\r\n\r\n![image](https://user-images.githubusercontent.com/2813363/230111934-1671f62e-dd36-45b6-9ec5-69dc54a208e6.png)\r\n\r\nSupporting abstractable readers would mean writing a new JSON stack from the ground up, so it's extremely unlikely we'd do it.",
          "createdAt": "2023-04-05T14:28:38Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "EYES",
                "createdAt": "2023-04-05T19:11:30Z",
                "user": "gregsdennis"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOC5UHYw=="
          },
          "updatedAt": "2023-04-05T14:30:24Z",
          "id": "IC_kwDODI9FZc5ZQ1v5"
        },
        {
          "author": "gregsdennis",
          "body": "That makes me sad.\n\nOkay, thanks for the reasoning.",
          "createdAt": "2023-04-05T19:12:23Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-04-05T19:12:23Z",
          "id": "IC_kwDODI9FZc5ZSYNT"
        },
        {
          "author": "gregsdennis",
          "body": "@eiriktsarpalis I see you've put the milestone on here, but I don't know how you typically handle these kinds of issues.  My question has been answered, so feel free to close if you like.",
          "createdAt": "2023-04-05T20:56:14Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-04-05T20:56:14Z",
          "id": "IC_kwDODI9FZc5ZS9zC"
        },
        {
          "author": "eiriktsarpalis",
          "body": "I'd be inclined to leave open if that's ok. It's a real problem and it might be the case that future language innovation might make this scenario possible.",
          "createdAt": "2023-04-06T07:41:30Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-04-06T09:12:27Z",
                "user": "gregsdennis"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOC5WsPg=="
          },
          "updatedAt": "2023-04-06T07:41:30Z",
          "id": "IC_kwDODI9FZc5ZUzke"
        }
      ],
      "totalCount": 7,
      "endCursor": "Y3Vyc29yOnYyOpHOWVM5Hg=="
    },
    "url": "https://github.com/dotnet/runtime/issues/84234",
    "title": "`JsonSerializer.Deserialize<TValue>(JsonNode?)` extensions could be improved"
  },
  {
    "author": "EgorBo",
    "labels": [
      "enhancement",
      "area-System.Text.Json"
    ],
    "createdAt": "2023-04-04T15:49:21Z",
    "body": "MinimalAPI benchmark has a `DateOnly` [field](https://github.com/aspnet/Benchmarks/blob/main/src/BenchmarksApps/TodosApi/Todo.cs#L11) in an object it then serializes to utf8 json.\r\n\r\nIt seems that STJ doesn't have a fast-path `DateOnly -> UTF8` like it has for e.g. `DateTime` and `DateTimeOffset`. Instead, it does `DateOnly -> UTF16` string and then converts it to Utf8. \r\nhttps://github.com/dotnet/runtime/blob/50c9dca330d2c8e7eab6e3ca65673fa02c1f1950/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/Converters/Value/DateOnlyConverter.cs#L60-L63\r\n\r\n",
    "number": 84305,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-09-25T20:26:35Z",
          "user": "vchirikov"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-11-29T20:49:33Z",
          "user": "zmj"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-09-27T06:36:33Z",
          "user": "swimmesberger"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-05-24T20:05:42Z",
          "user": "PaulusParssinen"
        }
      ],
      "totalCount": 4,
      "endCursor": "Y3Vyc29yOnYyOpHODCxqMw=="
    },
    "updatedAt": "2025-07-17T17:29:58Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\nMinimalAPI benchmark has a `DateOnly` [field](https://github.com/aspnet/Benchmarks/blob/main/src/BenchmarksApps/TodosApi/Todo.cs#L11) in an object it then serializes to utf8 json.\r\n\r\nIt seems that STJ doesn't have a fast-path `DateOnly -> UTF8` like it has for e.g. `DateTime` and `DateTimeOffset`. Instead, it does `DateOnly -> UTF16` string and then converts it to Utf8. \r\nhttps://github.com/dotnet/runtime/blob/50c9dca330d2c8e7eab6e3ca65673fa02c1f1950/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/Converters/Value/DateOnlyConverter.cs#L60-L63\r\n\r\n\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>EgorBo</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`area-System.Text.Json`, `untriaged`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2023-04-04T15:49:29Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-04-04T15:49:29Z",
          "id": "IC_kwDODI9FZc5ZLmtc"
        },
        {
          "author": "eiriktsarpalis",
          "body": "STJ uses [bespoke formatting logic](https://github.com/dotnet/runtime/blob/main/src/libraries/System.Text.Json/src/System/Text/Json/Writer/JsonWriterHelper.Date.cs) in order to support formatting dates directly to UTF-8. I wouldn't be too keen to repeat this for `DateOnly`, or whatever other type we want to support out of the box. Instead, we should consider adding `DateOnly` and `TimeOnly` overloads to the [`Utf8Formatter` class](https://learn.microsoft.com/en-us/dotnet/api/system.buffers.text.utf8formatter.tryformat?view=net-8.0) so the converter can use that in newer TFMs.",
          "createdAt": "2023-04-05T14:09:52Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-04-05T14:09:52Z",
          "id": "IC_kwDODI9FZc5ZQuju"
        },
        {
          "author": null,
          "body": "Tagging subscribers to this area: @dotnet/area-system-buffers\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\nMinimalAPI benchmark has a `DateOnly` [field](https://github.com/aspnet/Benchmarks/blob/main/src/BenchmarksApps/TodosApi/Todo.cs#L11) in an object it then serializes to utf8 json.\r\n\r\nIt seems that STJ doesn't have a fast-path `DateOnly -> UTF8` like it has for e.g. `DateTime` and `DateTimeOffset`. Instead, it does `DateOnly -> UTF16` string and then converts it to Utf8. \r\nhttps://github.com/dotnet/runtime/blob/50c9dca330d2c8e7eab6e3ca65673fa02c1f1950/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/Converters/Value/DateOnlyConverter.cs#L60-L63\r\n\r\n\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>EgorBo</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`area-System.Buffers`, `untriaged`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2023-04-05T14:10:50Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-04-05T14:10:50Z",
          "id": "IC_kwDODI9FZc5ZQu8v"
        },
        {
          "author": "tannergooding",
          "body": "Worth noting we approved `IUtf8SpanFormattable` and `IUtf8SpanParsable`. The plan is to implement those on all the primitive/built-in types for .NET 8, including `DateOnly` and `TimeOnly`: https://github.com/dotnet/runtime/issues/81500\r\n\r\n`Utf8Formatter/Parser` support may still be beneficial since it has slightly different semantics (stops at the first invalid character, rather than fails at the first invalid character). However, that sounds like it may not be an overly important distinction for this scenario.",
          "createdAt": "2023-04-05T14:14:46Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-04-05T15:06:17Z",
                "user": "eiriktsarpalis"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOC5TADA=="
          },
          "updatedAt": "2023-04-05T14:14:46Z",
          "id": "IC_kwDODI9FZc5ZQwhR"
        },
        {
          "author": "stephentoub",
          "body": "#84469 adds IUtf8SpanFormattable to DateOnly.\r\n\r\nBut the time we're done with implementing IUtf8SpanFormattable everywhere that currently implements ISpanFormattable, I expect Utf8Formatter will effectively be obsolete.",
          "createdAt": "2023-04-08T22:34:27Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-04-08T22:34:27Z",
          "id": "IC_kwDODI9FZc5Zd0uS"
        },
        {
          "author": null,
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\nMinimalAPI benchmark has a `DateOnly` [field](https://github.com/aspnet/Benchmarks/blob/main/src/BenchmarksApps/TodosApi/Todo.cs#L11) in an object it then serializes to utf8 json.\r\n\r\nIt seems that STJ doesn't have a fast-path `DateOnly -> UTF8` like it has for e.g. `DateTime` and `DateTimeOffset`. Instead, it does `DateOnly -> UTF16` string and then converts it to Utf8. \r\nhttps://github.com/dotnet/runtime/blob/50c9dca330d2c8e7eab6e3ca65673fa02c1f1950/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/Converters/Value/DateOnlyConverter.cs#L60-L63\r\n\r\n\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>EgorBo</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`area-System.Text.Json`, `untriaged`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2023-04-09T06:06:55Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-04-09T06:06:55Z",
          "id": "IC_kwDODI9FZc5ZeDXF"
        },
        {
          "author": "eiriktsarpalis",
          "body": "In that case, I'm reassigning this back to STJ and scoping this to adding IUtf8SpanFormattable /IUtf8SpanParseable support in STJ's converters.",
          "createdAt": "2023-04-09T06:08:06Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-04-09T06:08:06Z",
          "id": "IC_kwDODI9FZc5ZeDZc"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Addressed in part by https://github.com/dotnet/runtime/pull/86931.",
          "createdAt": "2023-05-31T16:55:05Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-05-31T16:55:05Z",
          "id": "IC_kwDODI9FZc5dnT2R"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Moving to 9.0, since at this point we'll have less time to react to potential regressions.",
          "createdAt": "2023-07-18T14:28:43Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-07-18T14:28:43Z",
          "id": "IC_kwDODI9FZc5hxZIZ"
        },
        {
          "author": "rynowak",
          "body": "This is definitely something we'd get a lot of use out of. For context we create a lot of custom domain types that convertable to/from strings. We end up using these with JSON a lot, and so it's added friction to need to create JSON converters",
          "createdAt": "2025-05-03T00:27:44Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-05-03T00:27:44Z",
          "id": "IC_kwDODI9FZc6pxdGY"
        }
      ],
      "totalCount": 10,
      "endCursor": "Y3Vyc29yOnYyOpHOqcXRmA=="
    },
    "url": "https://github.com/dotnet/runtime/issues/84305",
    "title": "Consider using `IUtf8SpanParseable`/`IUtf8SpanFormattable` in STJ's built-in converters."
  },
  {
    "author": "eiriktsarpalis",
    "labels": [
      "enhancement",
      "area-System.Text.Json"
    ],
    "createdAt": "2023-04-05T19:09:55Z",
    "body": "The current implementation of the `Utf8JsonReader.CopyString` methods only accepts JSON string tokens, that is `JsonTokenType.PropertyName` and `JsonTokenType.String`. When implementing JsonConverters for large numeric types such as `BigInteger` (https://github.com/dotnet/runtime/issues/60780) or `Int128`/`UInt128` (https://github.com/dotnet/runtime/issues/73500) extending the method to also handle JSON number tokens would greatly simplify getting allocation-free views of underlying JSON number encodings.",
    "number": 84375,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-04-06T07:46:28Z",
          "user": "PaulusParssinen"
        }
      ],
      "totalCount": 1,
      "endCursor": "Y3Vyc29yOnYyOpHOCvUi4A=="
    },
    "updatedAt": "2025-01-17T12:09:34Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\nThe current implementation of the `Utf8JsonReader.CopyString` methods only accepts JSON string tokens, that is `JsonTokenType.PropertyName` and `JsonTokenType.String`. When implementing JsonConverters for large numeric types such as `BigInteger` (https://github.com/dotnet/runtime/issues/60780) or `Int128`/`UInt128` (https://github.com/dotnet/runtime/issues/73500) extending the method to also handle JSON number tokens would greatly simplify getting allocation-free views of the JSON numbers.\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>eiriktsarpalis</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`area-System.Text.Json`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2023-04-05T19:10:01Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-04-05T19:10:01Z",
          "id": "IC_kwDODI9FZc5ZSXoQ"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Following the discussion in https://github.com/dotnet/runtime/pull/88962#discussion_r1264957076 we have concluded that even though the functionality is useful, there is something offputting about a method called `CopyString` working with number tokens (even though JSON numbers are technically still encoded as arbitrarily long UTF-8 strings). We should consult with the API review board first, considering potential alternative method names such as `CopyValue`.",
          "createdAt": "2023-07-17T18:20:46Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-07-17T18:20:46Z",
          "id": "IC_kwDODI9FZc5hq8MW"
        }
      ],
      "totalCount": 2,
      "endCursor": "Y3Vyc29yOnYyOpHOYavDFg=="
    },
    "url": "https://github.com/dotnet/runtime/issues/84375",
    "title": "Extend `Utf8JsonReader.CopyString` to also accept `JsonTokenType.Number` values"
  },
  {
    "author": "Sergio0694",
    "labels": [
      "enhancement",
      "area-System.Text.Json"
    ],
    "createdAt": "2023-04-07T16:46:23Z",
    "body": "### Description\r\n\r\n> **Note**: related to #58770 \r\n\r\nWith the 8.0.0 release, System.Text.Json will support required and init-only properties. This is something we'd like to leverage in the Microsoft Store, as moving away from records to instead use normal classes with required init-only properties can help reduce code size (due to no longer having all the record fluff), while still keeping things \"well defined\" (ie. not having nullable properties you need to suppress warnings for, etc.). But, I've noticed that default values don't really seem to work.\r\n\r\nConsider this example:\r\n\r\n```csharp\r\nFoo? foo = JsonSerializer.Deserialize(\"{}\", MyJsonContext.Default.Foo);\r\n\r\nConsole.WriteLine(foo);\r\n\r\n[JsonSerializable(typeof(Foo))]\r\npublic partial class MyJsonContext : JsonSerializerContext\r\n{\r\n}\r\n\r\npublic record Foo(string Name = \"DefaultName\", int Number = 42);\r\n```\r\n\r\nThis will print \"Foo { Name = DefaultName, Number = 42 }\". That is, those default values are correctly used.\r\n\r\nConsider the same thing, but changing that record to a class like this:\r\n\r\n```csharp\r\npublic class Foo\r\n{\r\n    public string Name { get; init; } = \"DefaultName\";\r\n\r\n    public int Number { get; init; } = 42;\r\n}\r\n```\r\n\r\nThis will cause those default values to be completely lost instead. The same code above will deserialize an instance that just has the values of each property set to `default`. This is not really intuitive - I would've expected the default value from those property initializers to be preserved, whereas the generated code is just always assigning _something_ to every single property, even if the value isn't present in the JSON, which will just cause `default` to be assigned instead.\r\n\r\nShouldn't the generated code for the object initializer only assign init-only, non-required properties when they're actually present in the JSON? If not, is there some way to preserve the \"default value\" behavior for properties in some way? Eg. I've tried to see if there was already some `[JsonDefaultValue]` attribute or something, but it doesn't seem to be a thing. Should it?\r\n\r\ncc. @eiriktsarpalis @layomia",
    "number": 84484,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-12-08T13:49:36Z",
          "user": "airbreather"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-02-05T20:35:17Z",
          "user": "jguddas"
        }
      ],
      "totalCount": 2,
      "endCursor": "Y3Vyc29yOnYyOpHOC-zvTg=="
    },
    "updatedAt": "2025-09-09T15:16:17Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\n### Description\n\n> **Note**: related to #58770 \r\n\r\nWith the 8.0.0 release, System.Text.Json will support required and init-only properties. This is something we'd like to leverage in the Microsoft Store, as moving away from records to instead use normal classes with required init-only properties can help reduce code size (due to no longer having all the record fluff), while still keeping things \"well defined\" (ie. not having nullable properties you need to suppress warnings for, etc.). But, I've noticed that default values don't really seem to work.\r\n\r\nConsider this example:\r\n\r\n```csharp\r\nFoo? foo = JsonSerializer.Deserialize(\"{}\", MyJsonContext.Default.Foo);\r\n\r\nConsole.WriteLine(foo);\r\n\r\n[JsonSerializable(typeof(Foo))]\r\npublic partial class MyJsonContext : JsonSerializerContext\r\n{\r\n}\r\n\r\npublic record Foo(string Name = \"DefaultName\", int Number = 42);\r\n```\r\n\r\nThis will print \"Foo { Name = DefaultName, Number = 42 }\". That is, those default values are correctly used.\r\n\r\nConsider the same thing, but changing that record to a class like this:\r\n\r\n```csharp\r\npublic class Foo\r\n{\r\n    public string Name { get; init; } = \"DefaultName\";\r\n\r\n    public int Number { get; init; } = 42;\r\n}\r\n```\r\n\r\nThis will cause those default values to be completely lost instead. The same code above will deserialize an instance that just has the values of each property set to `default`. This is not really intuitive - I would've expected the default value from those property initializers to be preserved, whereas the generated code is just always assigning _something_ to every single property, even if the value isn't present in the JSON, which will just cause `default` to be assigned instead.\r\n\r\nShouldn't the generated code for the object initializer only assign init-only, non-required properties when they're actually present in the JSON? If not, is there some way to preserve the \"default value\" behavior for properties in some way?\r\n\r\ncc. @eiriktsarpalis @layomia\n\n### Reproduction Steps\n\nn/a\n\n### Expected behavior\n\nn/a\n\n### Actual behavior\n\nn/a\n\n### Regression?\n\n_No response_\n\n### Known Workarounds\n\n_No response_\n\n### Configuration\n\n_No response_\n\n### Other information\n\n_No response_\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>Sergio0694</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`area-System.Text.Json`, `untriaged`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2023-04-07T16:46:31Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-04-07T16:46:31Z",
          "id": "IC_kwDODI9FZc5Zbxrp"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Yeah, this is a known drawback of how the source generator is populating init-only properties. It's a chicken and egg situation: you cannot get the value of an init-only property before the object has been created, and you cannot set the value of an init-only property after the object has been created.\r\n\r\n> Shouldn't the generated code for the object initializer only assign init-only, non-required properties when they're actually present in the JSON?\r\n\r\nThe generator can only create the construction delegate at compile time, whereas what properties are specified in the JSON can only be known at run time. One possible solution would be to generate one constructor delegate for each possible subset of init-only properties are being specified, however that would result in a lot of code being generated: given $n$ init-only properties on a type, you would need to generate $2^n$ constructor delegates.\r\n\r\nOne obvious solution would be to use reflection, which would be trim/AOT safe in this instance. Another possibility might be that the compiler provides proxy APIs that serializers can use to write to init-only properties.\r\n\r\ncc @jaredpar @eerhardt @jkotas @layomia",
          "createdAt": "2023-04-07T17:42:12Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-04-07T17:53:27Z",
          "id": "IC_kwDODI9FZc5Zb8qU"
        },
        {
          "author": "Sergio0694",
          "body": "> \"Yeah, this is a known drawback of how the source generator is populating init-only properties. It's a chicken and egg situation: you cannot get the value of an init-only property before the object has been created, and you cannot set the value of an init-only property after the object has been created.\"\r\n\r\nAh... Right. Yeah that's not great 🥲\r\n\r\nWhat about having some `[JsonDefaultValue]` attribute one could use for properties? And the generator could read the value from that and assign the corresponding value in the generated type info, so that it'd match exactly the same behavior you get today when using default values for parameters of the primary record constructor? 🤔\r\n\r\nSomething like, in the example above:\r\n\r\n```csharp\r\npublic class Foo\r\n{\r\n    [JsonDefaultValue(\"DefaultName\")]\r\n    public string Name { get; init; }\r\n\r\n    [JsonDefaultValue(42)]\r\n    public int Number { get; init; }\r\n}\r\n```\r\n\r\nAnd you'd get the same as with records. The default value would be constrained to constants, but then again that's the same limitation you get for default values in parameters anyway, so it would essentially be on par with that?",
          "createdAt": "2023-04-07T17:49:05Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-04-07T17:49:05Z",
          "id": "IC_kwDODI9FZc5Zb9sw"
        },
        {
          "author": "jkotas",
          "body": "> Another possibility might be that the compiler provides proxy APIs that serializers can use to write to init-only properties.\r\n\r\nhttps://github.com/dotnet/runtime/issues/81741",
          "createdAt": "2023-04-07T17:49:44Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-04-07T17:57:10Z",
                "user": "eiriktsarpalis"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOC5c_7g=="
          },
          "updatedAt": "2023-04-07T17:49:44Z",
          "id": "IC_kwDODI9FZc5Zb9y4"
        },
        {
          "author": "Sergio0694",
          "body": "I know it's lower priority but I kinda hope the solution for this won't involve that, so it can also work downlevel 🥲\r\nThat's why I was hoping we could maybe just use something like an attribute to instruct the generator instead.",
          "createdAt": "2023-04-07T17:52:18Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-04-07T17:52:18Z",
          "id": "IC_kwDODI9FZc5Zb-MA"
        },
        {
          "author": "eiriktsarpalis",
          "body": "> > Another possibility might be that the compiler provides proxy APIs that serializers can use to write to init-only properties.\r\n> \r\n> #81741\r\n\r\nAssuming this requires new API, we wouldn't be able to use it in `netstandard2.0` SG targets though. I kind of like the pattern matching on reflection invoke approach, it would work in old TFMs but also be fast in bleeding edge ones.",
          "createdAt": "2023-04-07T17:59:22Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-04-07T17:59:22Z",
          "id": "IC_kwDODI9FZc5Zb_UP"
        },
        {
          "author": "jkotas",
          "body": "> we wouldn't be able to use it in netstandard2.0 SG targets though. I kind of like the pattern matching on reflection invoke approach, it would work in old TFMs but also be fast in bleeding edge ones.\r\n\r\nWe have discussed the pros and cons of each approach in depth. The problem with pattern matching reflection invoke is that it is fragile and very complicated.\r\n\r\nnetstandard2.0 targets can use classic reflection invoke. There is a lot of performance left on table when targeting netstandard2.0 in general.",
          "createdAt": "2023-04-07T18:06:47Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-12-08T13:51:21Z",
                "user": "airbreather"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOD-EUgg=="
          },
          "updatedAt": "2023-04-07T18:06:47Z",
          "id": "IC_kwDODI9FZc5ZcBDS"
        },
        {
          "author": "eiriktsarpalis",
          "body": "There's also added complexity for SG's needing to implement different access patterns depending on the TFM. Using inlined reflection everywhere seems like an obvious win for authors.\r\n\r\n> The problem with pattern matching reflection invoke is that it is fragile and very complicated.\r\n\r\nIs it related to overload resolution?",
          "createdAt": "2023-04-07T18:13:33Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-04-07T18:13:33Z",
          "id": "IC_kwDODI9FZc5ZcCIe"
        },
        {
          "author": "jkotas",
          "body": "Here is a simple example of a method invocation that takes integer and string: `typeof(MyType).GetMethod(\"MyMethod\", new Type[] { typeof(int), typeof(string) }).Invoke(null, new object[] { intValue, stringValue });`. This gets compiled into a lot of IL. There are multiple method calls, multiple array allocations, array element assignments, boxing, ... . It is what makes the pattern match complicated and fragile.\r\n\r\nAlso, if the downlevel SG cared about performance even a bit, they would not want to use this unified pattern. They would want to cache the MethodInfo into a static or even convert it to a delegate, to reduce the steady perf hit.",
          "createdAt": "2023-04-07T18:54:50Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-04-07T18:55:51Z",
          "id": "IC_kwDODI9FZc5ZcI7o"
        },
        {
          "author": "eiriktsarpalis",
          "body": "> This gets compiled into a lot of IL.\r\n\r\nAssuming the scope of the proposed feature is serializer-like components, then we only really care about field, property and constructor member access. Fields and properties have relatively simple access patterns and supporting constructors isn't essential (since a source generator typically doesn't need to bypass accessibility there).\r\n\r\n> They would want to cache the MethodInfo into a static or even convert it to a delegate, to reduce the steady perf hit.\r\n\r\nPerhaps we should reconsider `infoof` :-) or something along these lines that avoids visibility checks, implements caching and uses an IL pattern that the JIT can easily recognise.",
          "createdAt": "2023-04-08T06:03:51Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-04-08T06:03:51Z",
          "id": "IC_kwDODI9FZc5ZdGt0"
        },
        {
          "author": "jkotas",
          "body": "> supporting constructors isn't essential (since a source generator typically doesn't need to bypass accessibility there).\r\n\r\nConstructors with parameters are in the list of EF Core requirements for https://github.com/dotnet/runtime/issues/81741.",
          "createdAt": "2023-04-08T13:28:55Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-04-08T13:29:53Z",
          "id": "IC_kwDODI9FZc5Zdcvt"
        },
        {
          "author": "Sergio0694",
          "body": "Will the generator support primary constructors in C# 12? Because I'm thinking a solution could be to use them in cases where you do need some default values, to still get some lightweight \"records\" without all the additional metadata bloat. Like:\r\n\r\n```csharp\r\npublic class Foo(\r\n    [property: JsonRequired] string firstName,\r\n    [property: JsonRequired] string lastName,\r\n    string tag = \"DefaultValue\",\r\n    int number = 42)\r\n{\r\n    public string FirstName => firstName;\r\n    public string LastName => lastName;\r\n    public string Tag => tag;\r\n    public int Number => number;\r\n}\r\n```\r\n\r\nIt's not ideal because you'd have to duplicate each property (as in, declare both a primary constructor parameter as well as an actual property), but at least it'd avoid all the additional codegen that normal records would cause. Since System.Text.Json already handles this for record constructors and explicit constructors, I assume this could just work? 🤔",
          "createdAt": "2023-04-12T09:55:43Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-04-12T09:55:43Z",
          "id": "IC_kwDODI9FZc5ZtGDR"
        },
        {
          "author": "eiriktsarpalis",
          "body": "> Since System.Text.Json already handles this for record constructors and explicit constructors, I assume this could just work?\r\n\r\nI believe so. Neither the source generator nor the reflection serialization have any special provision for positional record, but they still work. The only issue I'm aware of is inability to annotate the primary constructor with attributes such as `JsonConstructorAttribute`, but that is something to be addressed by the language. We should add test coverage for the new feature regardless.",
          "createdAt": "2023-04-12T11:10:59Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-04-12T11:10:59Z",
          "id": "IC_kwDODI9FZc5ZtdOL"
        },
        {
          "author": "Sergio0694",
          "body": "> \"The only issue I'm aware of is inability to annotate the primary constructor with attributes\"\r\n\r\nI think that might have already been fixed by https://github.com/dotnet/roslyn/pull/67695 😄\r\n\r\nSo you should be able to do:\r\n\r\n```csharp\r\n[method: JsonConstructor]\r\npublic class Person(string name)\r\n{\r\n    public String Name => name;\r\n}\r\n```\r\n\r\nIt looks a bit awkward but it _should_ work.",
          "createdAt": "2023-04-12T11:23:15Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "HOORAY",
                "createdAt": "2023-04-13T07:36:36Z",
                "user": "eiriktsarpalis"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOC5wujQ=="
          },
          "updatedAt": "2023-04-12T11:25:30Z",
          "id": "IC_kwDODI9FZc5Ztgmi"
        },
        {
          "author": "AArnott",
          "body": "This seems related to https://github.com/dotnet/csharplang/discussions/5588 where I point out that C# simply lacks the syntax for deserializers to emit C# code that honors default values of init accessor properties.",
          "createdAt": "2023-05-09T15:59:11Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-05-09T16:34:30Z",
                "user": "eiriktsarpalis"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOC7YUsw=="
          },
          "updatedAt": "2023-05-09T15:59:11Z",
          "id": "IC_kwDODI9FZc5b0YFY"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Moving to Future for now.",
          "createdAt": "2023-06-16T13:23:21Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-06-16T13:23:21Z",
          "id": "IC_kwDODI9FZc5fDL_5"
        },
        {
          "author": "eiriktsarpalis",
          "body": "I expect this will eventually be addressed by replacing the current constructor delegate approach with setters generated via https://github.com/dotnet/runtime/issues/81741",
          "createdAt": "2023-07-24T11:17:20Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-07-24T12:36:58Z",
                "user": "AArnott"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHODBmC5A=="
          },
          "updatedAt": "2023-07-24T11:17:20Z",
          "id": "IC_kwDODI9FZc5iNiTP"
        },
        {
          "author": "Neme12",
          "body": "> even convert it to a delegate\r\n\r\nI agree, caching the delegate seems like the best option.",
          "createdAt": "2023-09-09T15:24:16Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-09-09T15:24:16Z",
          "id": "IC_kwDODI9FZc5mEzvE"
        },
        {
          "author": "Neme12",
          "body": "> The generator can only create the construction delegate at compile time, whereas what properties are specified in the JSON can only be known at run time. One possible solution would be to generate one constructor delegate for each possible subset of init-only properties are being specified, however that would result in a lot of code being generated: given n init-only properties on a type, you would need to generate 2n constructor delegates.\r\n\r\nI understand the issue. But why does it then work for records though? Records also have init-only properties by default and default values still work there, so I'm confused.",
          "createdAt": "2023-09-09T15:29:30Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-09-09T15:29:30Z",
          "id": "IC_kwDODI9FZc5mEz_Q"
        },
        {
          "author": "VAllens",
          "body": "Any progress?\r\nWe believe the two behaviors should be consistent !",
          "createdAt": "2024-03-13T04:05:25Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-03-13T04:05:25Z",
          "id": "IC_kwDODI9FZc520PqC"
        }
      ],
      "totalCount": 20,
      "endCursor": "Y3Vyc29yOnYyOpHOdtD6gg=="
    },
    "url": "https://github.com/dotnet/runtime/issues/84484",
    "title": "Default values for init-only properties are lost with generated JsonTypeInfo"
  },
  {
    "author": "vllama",
    "labels": [
      "api-suggestion",
      "area-System.Text.Json"
    ],
    "createdAt": "2023-04-15T06:31:28Z",
    "body": "### Background and motivation\n\n\r\nCurrently to get the Keys of a JsonObject is has to be cast to one of the dictionaries it explicitly implements\r\nlike `(IDictionary<string, JsonNode>)jsonObject).Keys`\r\n\r\nWe are using JsonObject becasue we have to manipulate json quite a bit, and enumerating the keys helps a lot.\r\n\r\n```\n\n### API Proposal\n\n```csharp\r\nnamespace System.Text.Json.Nodes;\r\n\r\npublic partial class JsonObject\r\n{\r\n   public ICollection<string> Keys{get;}\r\n}\r\n```\r\n\n\n### API Usage\n\n```csharp\r\n// Fancy the value\r\nvar keys = myJsonObject.Keys;\r\n\r\n// Getting the values out\r\nforeach (var key in keys)\r\n    Console.WriteLine(v);\r\n...\r\n```\r\n\n\n### Alternative Designs\n\nExtension Method:\r\n```\r\npublic static ICollection<string> Keys(this JsonObject json) {\r\n\treturn ((IDictionary<string, JsonNode>)json).Keys;\r\n}\n\n### Risks\n\n_No response_",
    "number": 84880,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-04-15T07:38:51Z",
          "user": "gregsdennis"
        }
      ],
      "totalCount": 1,
      "endCursor": "Y3Vyc29yOnYyOpHOCvf-Gg=="
    },
    "updatedAt": "2023-04-17T22:47:38Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\n### Background and motivation\n\n\r\nCurrently to get the Keys of a JsonObject is has to be cast to one of the dictionaries it explicitly implements\r\nlike `(IDictionary<string, JsonNode>)jsonObject).Keys`\r\n\r\nWe are using JsonObject becasue we have to manipulate json quite a bit, and enumerating the keys helps a lot.\r\n\r\n```\n\n### API Proposal\n\n```csharp\r\nnamespace System.Text.Json.Nodes;\r\n\r\npublic partial class JsonObject\r\n{\r\n   public ICollection<string> Keys{get;}\r\n}\r\n```\r\n\n\n### API Usage\n\n```csharp\r\n// Fancy the value\r\nvar keys = myJsonObject.Keys;\r\n\r\n// Getting the values out\r\nforeach (var key in keys)\r\n    Console.WriteLine(v);\r\n...\r\n```\r\n\n\n### Alternative Designs\n\nExtension Method:\r\n```\r\npublic static ICollection<string> Keys(this JsonObject json) {\r\n\treturn ((IDictionary<string, JsonNode>)json).Keys;\r\n}\n\n### Risks\n\n_No response_\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>vllama</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`api-suggestion`, `area-System.Text.Json`, `untriaged`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2023-04-15T06:31:37Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-04-15T06:31:37Z",
          "id": "IC_kwDODI9FZc5Z-mcW"
        },
        {
          "author": "gregsdennis",
          "body": "There are currently the `TryGetPropertyValue()` and `ContainsKey()` properties that can help. I've used these extensively in my `json-everything` libraries.\n\nI'll leave this to the dotnet team to confirm, but I believe there are some optimizations they've implemented (e.g. partial object parsing), and they want to encourage people to use these methods over things like the `Keys` property (which would require parsing the entire object).",
          "createdAt": "2023-04-15T07:43:34Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-04-15T07:43:34Z",
          "id": "IC_kwDODI9FZc5Z-vAE"
        },
        {
          "author": "vllama",
          "body": "@gregsdennis : thanks for that.   I am currently using those as well, but since JsonObject Implements IDictionary, I don't believe enumerating keys would be a performance impact, especially since the use case for enumerating keys is most likely a very flat json structure. ",
          "createdAt": "2023-04-17T18:51:42Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-04-17T18:51:42Z",
          "id": "IC_kwDODI9FZc5aHf0_"
        }
      ],
      "totalCount": 3,
      "endCursor": "Y3Vyc29yOnYyOpHOWh39Pw=="
    },
    "url": "https://github.com/dotnet/runtime/issues/84880",
    "title": "[API Proposal]: Support Keys property on JsonObject"
  },
  {
    "author": "WhitWaldo",
    "labels": [
      "api-suggestion",
      "area-System.Text.Json",
      "code-analyzer"
    ],
    "createdAt": "2023-04-28T20:28:59Z",
    "body": "Per https://github.com/dotnet/runtime/issues/85479 and https://github.com/dotnet/runtime/issues/54189 the preferred approach to apply a custom JsonConverter is to apply the converter type to the type being converted so that it's used whether (de)serializing a single entity or a collection of entities using that converter.\r\n\r\nHaving not realized that, I would propose that an analyzer (potentially with a code fix) be added that identifies when `[JsonConverter]` has been applied to a property that itself represents a collection of the type the JsonConverter is typed for since this will actually throw at runtime. The code fix should move the `[JsonConverter]` attribute from its position on any various properties to the type definition itself (when available in the same assembly) so it's applied consistently whether to a single or collection of the type.\r\n\r\nThank you for the consideration!",
    "number": 85540,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-03-25T10:18:05Z",
          "user": "gpuchtel"
        }
      ],
      "totalCount": 1,
      "endCursor": "Y3Vyc29yOnYyOpHOC2woTA=="
    },
    "updatedAt": "2024-03-25T09:58:52Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\nPer https://github.com/dotnet/runtime/issues/85479 and https://github.com/dotnet/runtime/issues/54189 the preferred approach to apply a custom JsonConverter is to apply the converter type to the type being converted so that it's used whether (de)serializing a single entity or a collection of entities using that converter.\r\n\r\nHaving not realized that, I would propose that an analyzer (potentially with a code fix) be added that identifies when `[JsonConverter]` has been applied to a property that itself represents a collection of the type the JsonConverter is typed for since this will actually throw at runtime. The code fix should move the `[JsonConverter]` attribute from its position on any various properties to the type definition itself (when available in the same assembly) so it's applied consistently whether to a single or collection of the type.\r\n\r\nThank you for the consideration!\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>WhitWaldo</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`area-System.Text.Json`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2023-04-28T20:29:05Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-04-28T20:29:05Z",
          "id": "IC_kwDODI9FZc5bFE-t"
        },
        {
          "author": "eiriktsarpalis",
          "body": "It's an interesting proposal, we could consider it in the future. Thanks!",
          "createdAt": "2023-05-02T13:30:48Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-05-02T13:30:48Z",
          "id": "IC_kwDODI9FZc5bSJg8"
        },
        {
          "author": "gpuchtel",
          "body": "@eiriktsarpalis Why is this just \"an interesting proposal?\". This, IMO is a fundamental usage issue. I'm surprised (sad even) that Microsoft doesn't see it the same way.",
          "createdAt": "2024-03-25T09:58:51Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-03-25T09:58:51Z",
          "id": "IC_kwDODI9FZc54QoAG"
        }
      ],
      "totalCount": 3,
      "endCursor": "Y3Vyc29yOnYyOpHOeEKABg=="
    },
    "url": "https://github.com/dotnet/runtime/issues/85540",
    "title": "Analyzer/Code fix idea: JsonConverters applied to properties implementing a collection"
  },
  {
    "author": "Simonl9l",
    "labels": [
      "api-suggestion",
      "area-System.Text.Json"
    ],
    "createdAt": "2023-05-29T20:48:41Z",
    "body": "### Background and motivation\r\n\r\nAs the `system.text.json` code generation serialization usage become more widespread, libraries will (and do) expose their serialization contexts.\r\n\r\nIf in a local project, that has a local type, that contains a property of a type for a library as above, where the local type is registered as part of the local project serialization context  (via `[JsonSerializable]` attribute) it also generates serialization code for the libraries type.\r\n\r\nThe net effect is that there is duplicated serialization code generated for that library type and its sub components with the locally generated serialization context.\r\n\r\nIf there were a new attribute that indicated that a given type already has a code generated serializer defined in another (libraries or otherwise ) public serialization context, the local generated serialization context could hook into that  library's generated serialization code for that libraries type.\r\n\r\nIt seems sensible to uses the libraries generated serialization code for its type, as built into the \"released\" library than regenerating that code locally, that my for some reason behave differently invalidating the implementation contract of the library.\r\n\r\n### API Proposal\r\n\r\n```csharp\r\npublic record MyLocalType\r\n{\r\n  [JsonPropertySerializationContext(typeof(LibrariesSerializationContext))]  public TypeInLibrary MyUsageOfLibraryType { get; set; }  \r\n}\r\n```\r\n\r\n\r\n\r\n\r\n### API Usage\r\n\r\nAs above.\r\n\r\n### Alternative Designs\r\n\r\nNone that I know of.\r\n\r\n### Risks\r\n\r\nN/A",
    "number": 86876,
    "reactions": {
      "hasNextPage": false,
      "nodes": [],
      "totalCount": 0,
      "endCursor": null
    },
    "updatedAt": "2023-06-22T22:14:29Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\n### Background and motivation\r\n\r\nAs the `system.text.json` code generation serialization usage become more widespread, libraries will (and do) expose their serialization contexts.\r\n\r\nIf in a local project, that has a local type, that contains a property of a type for a library as above, where the local type is registered as part of the local project serialization context  (via `[JsonSerializable]` attribute) it also generates serialization code for the libraries type.\r\n\r\nThe net effect is that there is duplicated serialization code generated for that library type and its sub components with the locally generated serialization context.\r\n\r\nIf there were a new attribute that indicated that a given type already has a code generated serializer defined in another (libraries or otherwise ) public serialization context, the local generated serialization context could hook into that  library's generated serialization code for that libraries type.\r\n\r\nIt seems sensible to uses the libraries generated serialization code for its type, as built into the \"released\" library than regenerating that code locally, that my for some reason behave differently invalidating the implementation contract of the library.\r\n\r\n### API Proposal\r\n\r\n```csharp\r\npublic record MyLocalType\r\n{\r\n  [JsonPropertySerializationContext(typeof(LibrariesSerializationContext))]  public TypeInLibrary MyUsageOfLibraryType { get; set; }  \r\n}\r\n```\r\n\r\n\r\n\r\n\r\n### API Usage\r\n\r\nAs above.\r\n\r\n### Alternative Designs\r\n\r\nNone that I know of.\r\n\r\n### Risks\r\n\r\nN/A\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>Simonl9l</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`api-suggestion`, `area-System.Text.Json`, `untriaged`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2023-06-22T21:30:34Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-06-22T21:30:34Z",
          "id": "IC_kwDODI9FZc5fkQ8i"
        },
        {
          "author": "layomia",
          "body": "I believe this is already possible by adding an instance of the desired context type to the new [`JsonSerializerOptions.TypeInfoResolverChain`](https://learn.microsoft.com/en-us/dotnet/api/system.text.json.jsonserializeroptions.typeinforesolverchain?view=net-8.0) property. That would use the context across the entire input type graph.\r\n\r\nI'm not sure of the best way to achieve per-property context use like shown above, but I imagine a combination of using `DefaultJsonTypeInfoResolver.Modifiers` [feature](https://learn.microsoft.com/dotnet/standard/serialization/system-text-json/custom-contracts) and consulting a static instance of of the desired context within the modifier implementation would work. You'd use [`desiredContext.GetTypeInfo`](https://learn.microsoft.com/en-us/dotnet/api/system.text.json.serialization.jsonserializercontext.system-text-json-serialization-metadata-ijsontypeinforesolver-gettypeinfo?view=net-7.0) to retrieve generated metadata & use it to populate the modifier's input `JsonTypeInfo`. Admittedly this is complex but an inbox API would probably work out all the kinks.\r\n\r\nThese approaches use runtime configuration (vs using declarative attributes like shown above), but the new attribute would probably use similar techniques.\r\n\r\nWe've had related discussions about resolving customization differences across assemblies (i.e. stuff specified using `JsonSerializerOptions/Context/Attributes`), the downsides of metadata sharing (particularly any sort of implicitly used global caches), sharing metadata for primitives across assemblies etc. There's prior art for some of these considerations with how the `TypeInfoResolverChain` works.",
          "createdAt": "2023-06-22T22:14:16Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-06-22T22:14:16Z",
          "id": "IC_kwDODI9FZc5fkaS9"
        }
      ],
      "totalCount": 2,
      "endCursor": "Y3Vyc29yOnYyOpHOX5GkvQ=="
    },
    "url": "https://github.com/dotnet/runtime/issues/86876",
    "title": "Support reuse of JsonSerializerContext's from libraries, so as not to generate duplicate serialization code"
  },
  {
    "author": "eiriktsarpalis",
    "labels": [
      "bug",
      "area-System.Text.Json",
      "source-generator"
    ],
    "createdAt": "2023-06-01T13:18:12Z",
    "body": "The following unit test:\r\n\r\nhttps://github.com/dotnet/runtime/blob/534d1dfdca50108b06504ade48b7970d4395a42e/src/libraries/System.Text.Json/tests/Common/ExtensionDataTests.cs#L518-L529\r\n\r\nhardcodes testing to the reflection serializer. Switching the test to use source gen causes it to fail.\r\n\r\nDiscovered while investigating #86975.",
    "number": 87005,
    "reactions": {
      "hasNextPage": false,
      "nodes": [],
      "totalCount": 0,
      "endCursor": null
    },
    "updatedAt": "2023-06-01T13:18:32Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\nThe following unit test:\r\n\r\nhttps://github.com/dotnet/runtime/blob/534d1dfdca50108b06504ade48b7970d4395a42e/src/libraries/System.Text.Json/tests/Common/ExtensionDataTests.cs#L518-L529\r\n\r\nhardcodes testing to the reflection serializer. Switching the test to use source gen causes it to fail.\r\n\r\nDiscovered while investigating #86975.\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>eiriktsarpalis</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`area-System.Text.Json`, `untriaged`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2023-06-01T13:18:19Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-06-01T13:18:19Z",
          "id": "IC_kwDODI9FZc5ds2uV"
        }
      ],
      "totalCount": 1,
      "endCursor": "Y3Vyc29yOnYyOpHOXbNrlQ=="
    },
    "url": "https://github.com/dotnet/runtime/issues/87005",
    "title": "JsonExtensionDataAttribute not working with custom overflow converters in source gen"
  },
  {
    "author": "malaterre",
    "labels": [
      "api-suggestion",
      "area-System.Text.Json",
      "wishlist"
    ],
    "createdAt": "2023-06-07T07:38:24Z",
    "body": "### Background and motivation\r\n\r\nRemoving some entries in a JsonNode satisfying a predicate is a fairly common requirement but it is unnecessarily inefficient. This is closely related to equivalent issue for Dict (see #26314)\r\n\r\n### API Proposal\r\n\r\n```csharp\r\nnamespace System.Text.Json.Nodes;\r\n\r\npublic class JsonObject\r\n{\r\n    public void Remove(string key);\r\n}\r\n```\r\n\r\n\r\n### API Usage\r\n\r\n```csharp\r\nforeach(var entry in jsonNode)\r\n{\r\n    if (predicate(entry.Key))\r\n            jsonNode.Remove(entry.Key);\r\n}\r\n```\r\n\r\n\r\n### Alternative Designs\r\n\r\n```csharp\r\nforeach(var entry in jsonNode.ToList())\r\n{\r\n    if (predicate(entry.Key))\r\n            jsonNode.Remove(entry.Key);\r\n}\r\n```\r\n\r\n### Risks\r\n\r\n_No response_",
    "number": 87206,
    "reactions": {
      "hasNextPage": false,
      "nodes": [],
      "totalCount": 0,
      "endCursor": null
    },
    "updatedAt": "2023-06-07T10:04:19Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\n### Background and motivation\n\nRemoving some entries in a JsonNode satisfying a predicate is a fairly common requirement but it is unnecessarily inefficient.\n\n### API Proposal\n\n```csharp\r\nnamespace System.Text.Json.Nodes;\r\n\r\npublic class JsonObject\r\n{\r\n    public void Remove(string key);\r\n}\r\n```\r\n\n\n### API Usage\n\n```csharp\r\nforeach(var entry in jsonNode)\r\n{\r\n    if (predicate(entry.Key))\r\n            jsonNode.Remove(entry.Key);\r\n}\r\n```\r\n\n\n### Alternative Designs\n\nforeach(var entry in jsonNode.ToList())\r\n{\r\n    if (predicate(entry.Key))\r\n            jsonNode.Remove(entry.Key);\r\n}\r\n\n\n### Risks\n\n_No response_\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>malaterre</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`api-suggestion`, `area-System.Text.Json`, `untriaged`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2023-06-07T07:38:31Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-06-07T07:38:31Z",
          "id": "IC_kwDODI9FZc5eLpS9"
        },
        {
          "author": "jskeet",
          "body": "If it's *just* a matter of removing nodes, another design presents itself:\r\n\r\n```csharp\r\npublic class JsonNode\r\n{\r\n    public void RemoveAll(Func<string, JsonNode, bool> predicate);\r\n}\r\n```\r\n\r\nBut that won't help if you want to iterate over all nodes and take actions *other* than removing the node.",
          "createdAt": "2023-06-07T07:45:00Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-06-07T07:45:00Z",
          "id": "IC_kwDODI9FZc5eLsXe"
        }
      ],
      "totalCount": 2,
      "endCursor": "Y3Vyc29yOnYyOpHOXi7F3g=="
    },
    "url": "https://github.com/dotnet/runtime/issues/87206",
    "title": "[API Proposal]: Allow JsonObject.Remove during enumeration"
  },
  {
    "author": "mathieubergouniouxcab",
    "labels": [
      "enhancement",
      "area-System.Text.Json",
      "help wanted"
    ],
    "createdAt": "2023-06-26T15:19:50Z",
    "body": "### Background and motivation\n\n**CONTEXT:** \r\nThe following issue is very common : a developer tries to deserialize some Json data into a class that has an explicit or explicit JsonConstructor, but the deserialization fails because System.Text.Json fails to map the data's property names either to an existing field in the class or to an existing parameter in the class' constructor.\r\n\r\nIt gives such errors at deserialization:\r\n`System.InvalidOperationException: Each parameter in constructor '[...]' on type '[...]' must bind to an object property or field on deserialization. Each parameter name must match with a property or field on the object. The match can be case-insensitive.`\r\n\r\nExamples of such issues can be listed with a Google query on this very tracker : `site:https://github.com/dotnet/runtime/issues/   Each parameter in constructor must bind to an object property or field on deserialization`\r\n\r\n**The root causes** can be : \r\n- a discrepancy in the name, \r\n- a casing issue (e.g. camel case) -- that happens less often, because this can be configured\r\n- a type mismatch. \r\n\r\nThat last one is the trickiest one : The mismatch can be because there's a discrepancy in **nullability**, or in **typing** -- because one is an interface (e.g. IEnumerable) while the other one is a class (e.g. List). Newtonsoft was more permissive in that regard and it confuses old developers.\r\n\r\n**PROBLEM:**\r\n**The error message does not give a lot of explicit details on the exact offender.**\r\n\r\nIt **does** give a list of expected constructor parameters types. For example:\r\n...Each parameter in constructor 'Void .ctor(System.Nullable`1[System.Guid], string, Guid, string)' ...\r\n\r\nThat's good.\r\n\r\n\r\n**PROPOSED FIX:** \r\n- When the **name** cannot be matched, then Give the name of the offender, i.e. the name of the parameter that could not be bound.\r\n`Could not bind parameter 'id' in constructor (Guid, string, string)`\r\n- When the **type** cannot be matched (but the name was found) then give BOTH the expected type and the found type, side by side.\r\n`Parameter 'category' with type Guid could not be bound to property 'Category' with type Nullable<Guid>. `\r\nthe code performing those checks can be found here ; \r\nhttps://source.dot.net/#System.Text.Json/System/Text/Json/Serialization/Converters/Object/ObjectWithParameterizedConstructorConverter.cs,572\r\n\n\n### API Proposal\n\n-\n\n### API Usage\n\n-\n\n### Alternative Designs\n\n_No response_\n\n### Risks\n\n_No response_",
    "number": 88048,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-01-27T22:55:41Z",
          "user": "konrad-jamrozik"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-02-06T16:13:00Z",
          "user": "Richard-Dufour"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-02-23T13:46:49Z",
          "user": "gldraphael"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-03-23T08:08:15Z",
          "user": "DaveSkender"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-07-04T08:31:08Z",
          "user": "baterja"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-07-16T11:07:43Z",
          "user": "anaximander23"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-08-13T08:20:50Z",
          "user": "peibol71"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-11-09T22:39:31Z",
          "user": "nkosi23"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-01-17T20:11:01Z",
          "user": "Jure-BB"
        }
      ],
      "totalCount": 9,
      "endCursor": "Y3Vyc29yOnYyOpHOC-P0aA=="
    },
    "updatedAt": "2024-09-10T07:27:29Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\n### Background and motivation\n\n**CONTEXT:** \r\nThe following issue is very common : a developer tries to deserialize some Json data into a class that has an explicit or explicit JsonConstructor, but the deserialization fails because System.Text.Json fails to map the data's property names either to an existing field in the class or to an existing parameter in the class' constructor.\r\n\r\nIt gives such errors at deserialization:\r\n`System.InvalidOperationException: Each parameter in constructor '[...]' on type '[...]' must bind to an object property or field on deserialization. Each parameter name must match with a property or field on the object. The match can be case-insensitive.`\r\n\r\nExamples of such issues can be listed with a Google query on this very tracker : `site:https://github.com/dotnet/runtime/issues/   Each parameter in constructor must bind to an object property or field on deserialization`\r\n\r\n**The root causes** can be : \r\n- a discrepancy in the name, \r\n- a casing issue (e.g. camel case) -- that happens less often, because this can be configured\r\n- a type mismatch. \r\n\r\nThat last one is the trickiest one : The mismatch can be because there's a discrepancy in **nullability**, or in **typing** -- because one is an interface (e.g. IEnumerable) while the other one is a class (e.g. List). Newtonsoft was more permissive in that regard and it confuses old developers.\r\n\r\n**PROBLEM:**\r\n**The error message does not give a lot of explicit details on the exact offender.**\r\n\r\nIt **does** give a list of expected constructor parameters types. For example:\r\n...Each parameter in constructor 'Void .ctor(System.Nullable`1[System.Guid], string, Guid, string)' ...\r\n\r\nThat's good.\r\n\r\n\r\n**PROPOSED FIX:** \r\n- When the **name** cannot be matched, then Give the name of the offender, i.e. the name of the parameter that could not be bound.\r\n`Could not bind parameter 'id' in constructor (Guid, string, string)`\r\n- When the **type** cannot be matched (but the name was found) then give BOTH the expected type and the found type, side by side.\r\n`Parameter 'category' with type Guid could not be bound to property 'Category' with type Nullable<Guid>. `\r\nthe code performing those checks can be found here ; \r\nhttps://source.dot.net/#System.Text.Json/System/Text/Json/Serialization/Converters/Object/ObjectWithParameterizedConstructorConverter.cs,572\r\n\n\n### API Proposal\n\n-\n\n### API Usage\n\n-\n\n### Alternative Designs\n\n_No response_\n\n### Risks\n\n_No response_\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>mathieubergouniouxcab</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`api-suggestion`, `area-System.Text.Json`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2023-06-26T15:19:59Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-06-26T15:19:59Z",
          "id": "IC_kwDODI9FZc5f0692"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Marking up-for-grabs since it's an easy enhancement deriving from #44428.",
          "createdAt": "2023-06-26T15:29:30Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-06-26T15:34:25Z",
                "user": "mathieubergouniouxcab"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOC_EnRQ=="
          },
          "updatedAt": "2023-06-26T15:29:30Z",
          "id": "IC_kwDODI9FZc5f0-0A"
        },
        {
          "author": "bennatpjose",
          "body": "Hello, Can I attempt at fixing this? @eiriktsarpalis ",
          "createdAt": "2023-08-03T16:42:07Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-08-03T16:46:41Z",
          "id": "IC_kwDODI9FZc5jM0gf"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Thank you for the offer, but I would recommend holding off for the few weeks, as we're currently busy trying to finalize .NET 8 development. Happy to assign you this issue if you're still available next month.",
          "createdAt": "2023-08-03T16:58:30Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-08-03T16:59:06Z",
          "id": "IC_kwDODI9FZc5jM5wC"
        },
        {
          "author": "vesnx",
          "body": "I notice that the json constructor is not accepting the jsonpropeyNames\r\n```\r\n\r\n [System.Text.Json.Serialization.JsonSerializable(typeof(ToDo))]\r\n [System.Text.Json.Serialization.JsonSourceGenerationOptions(\r\n         GenerationMode = System.Text.Json.Serialization.JsonSourceGenerationMode.Metadata,\r\n         IgnoreReadOnlyProperties = true,    \r\n         IncludeFields = true,\r\n         IgnoreReadOnlyFields = false\r\n     )]\r\n public partial class ToDoJsonContext : System.Text.Json.Serialization.JsonSerializerContext\r\n {\r\n }\r\npublic class ToDo\r\n{\r\n    [JsonPropertyName(\"a\")]\r\n    private readonly int _rank;\r\n    [JsonPropertyName(\"b\")]\r\n    private readonly string _task;\r\n\r\n    [JsonConstructor]\r\n    public ToDo(int a, string b)\r\n    {\r\n        _rank = a;\r\n        _task = b;\r\n\r\n    }\r\n    [JsonIgnore]\r\n    public int Rank => _rank;\r\n\r\n    [JsonIgnore]\r\n    public string Task => _task;\r\n}\r\n```\r\n\r\nMy simple test class can not round trip this; it can with Netwonsoft json. \r\n```\r\ninternal class Program\r\n{\r\n    static async Task Main(string[] args)\r\n    {\r\n        /*test and work with a single entry*/\r\n\r\n        var entry = new ToDo(Random.Shared.Next(1,int.MaxValue), \"test a class\");\r\n        var json= JsonSerializer.Serialize<ToDo>(entry,ToDoJsonContext.Default.ToDo);\r\n        Console.WriteLine(json);\r\n        Debug.Assert(json.Contains(\"\\\"a\\\":\"),\"supposed to have \\\"a\\\": property\");\r\n        var copy= JsonSerializer.Deserialize<ToDo>(json,ToDoJsonContext.Default.ToDo);\r\n        Debug.Assert(copy is not null, \"Serialization failed for a single ToDo\");\r\n        Debug.Assert(copy.Rank == entry.Rank, $\"supposed to have the same rank {copy.Rank} and the original has {entry.Rank}.\");\r\n        Debug.Assert(string.Equals(copy.Task, entry.Task, StringComparison.Ordinal),$\"Texts is supposed to be the same however copy task = {copy.Task} and entry task = {entry.Task}\");\r\n  }\r\n}\r\n```\r\n",
          "createdAt": "2023-12-12T08:44:21Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-01-29T18:56:49Z",
                "user": "konrad-jamrozik"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-01-17T20:15:05Z",
                "user": "Jure-BB"
              }
            ],
            "totalCount": 2,
            "endCursor": "Y3Vyc29yOnYyOpHOEDCZ0A=="
          },
          "updatedAt": "2023-12-12T08:44:59Z",
          "id": "IC_kwDODI9FZc5uXFbI"
        },
        {
          "author": "konrad-jamrozik",
          "body": "@eiriktsarpalis is this still up-for-grabs? Anything to be mindful of if trying to take a stab at it?",
          "createdAt": "2024-01-29T18:33:40Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-01-29T18:33:40Z",
          "id": "IC_kwDODI9FZc5yKZ-w"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Sure, feel free to try it out.",
          "createdAt": "2024-01-29T22:15:20Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-01-30T07:11:42Z",
                "user": "konrad-jamrozik"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHODUmnTA=="
          },
          "updatedAt": "2024-01-29T22:15:20Z",
          "id": "IC_kwDODI9FZc5yLs8k"
        },
        {
          "author": "konrad-jamrozik",
          "body": "Awesome, thx! If I will have something, I'll submit a PR and link to it here. But I am not doing this yet. Anybody else is welcome to work on this, too.",
          "createdAt": "2024-01-30T07:11:39Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-01-30T07:11:39Z",
          "id": "IC_kwDODI9FZc5yNv_5"
        },
        {
          "author": "SteveDunn",
          "body": "Just came across this issue while trying to get this to work for [Vogen](https://github.com/SteveDunn/Vogen):\r\n\r\n```c#\r\npublic class Hash<T> : IEquatable<T>, IEnumerable<T> where T : IEquatable<T>\r\n{\r\n    private readonly ImmutableEquatableArray<T> _items;\r\n    \r\n    [JsonConstructor]\r\n    public Hash(T[] items) => _items = items.ToImmutableEquatableArray();\r\n...\r\n}\r\n```\r\n\r\nI don't think this fix would work for collections though. Even though I have that attribute on the constructor, and I deserialize with:\r\n```c#\r\nSystemTextJsonSerializer.Deserialize<FileHash>([1,2,3])\r\n```\r\n\r\nI still get `The collection type 'Vogen.Tests.Types.Hash``1[System.Byte]' is abstract, an interface, or is read only, and could not be instantiated and populated`",
          "createdAt": "2024-09-02T06:05:17Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-09-02T06:06:57Z",
          "id": "IC_kwDODI9FZc6Kg6PK"
        },
        {
          "author": "eiriktsarpalis",
          "body": "@SteveDunn I think that's somewhat of a different issue, namely there's no real way to support deserialization for custom collection types that aren't mutable (a.k.a. implementing `ICollection<T>.Add(T)`).  We're using [this issue](https://github.com/dotnet/runtime/issues/82642) to track potential support for custom collections that apply the `CollectionBuilderAttribute`.",
          "createdAt": "2024-09-09T09:53:13Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-09-10T07:25:24Z",
                "user": "SteveDunn"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHODxoY3w=="
          },
          "updatedAt": "2024-09-09T09:53:13Z",
          "id": "IC_kwDODI9FZc6LVd6H"
        },
        {
          "author": "vesnx",
          "body": "Doesn’t seem to match my issue where a field with a name isn’t mapped in the constructor\r\n\r\n \r\n\r\nFrom: Eirik Tsarpalis ***@***.***> \r\nSent: Monday, September 9, 2024 11:54 AM\r\nTo: dotnet/runtime ***@***.***>\r\nCc: VESNX SA ***@***.***>; Comment ***@***.***>\r\nSubject: Re: [dotnet/runtime] [System.Text.Json] : More accurate error messages when failing to map fields or parameters (Issue #88048)\r\n\r\n \r\n\r\n@SteveDunn <https://github.com/SteveDunn>  I think that's somewhat of a different issue, namely there's no real way to support deserialization for custom collection types that aren't mutable (a.k.a. implementing ICollection<T>.Add(T)). We're using this issue <https://github.com/dotnet/runtime/issues/82642>  to track potential support for custom collections that apply the CollectionBuilderAttribute.\r\n\r\n—\r\nReply to this email directly, view it on GitHub <https://github.com/dotnet/runtime/issues/88048#issuecomment-2337660551> , or unsubscribe <https://github.com/notifications/unsubscribe-auth/A7GVYP3DWYTZUU3IWOWPZP3ZVVV2FAVCNFSM6AAAAAAZUKJWTWVHI2DSMVQWIX3LMV43OSLTON2WKQ3PNVWWK3TUHMZDGMZXGY3DANJVGE> .\r\nYou are receiving this because you commented.  <https://github.com/notifications/beacon/A7GVYP6IQYUQMPSFEKSOJA3ZVVV2FA5CNFSM6AAAAAAZUKJWTWWGG33NNVSW45C7OR4XAZNMJFZXG5LFINXW23LFNZ2KUY3PNVWWK3TUL5UWJTULKXPIO.gif> Message ID: ***@***.*** ***@***.***> >\r\n\r\n",
          "createdAt": "2024-09-10T07:25:28Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-09-10T07:25:28Z",
          "id": "IC_kwDODI9FZc6Ld6c-"
        },
        {
          "author": "SteveDunn",
          "body": "Thanks @eiriktsarpalis . Maybe that attribute could also be utilised in System.Configration for the work we did on binding to collections.",
          "createdAt": "2024-09-10T07:27:28Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-09-10T07:27:28Z",
          "id": "IC_kwDODI9FZc6Ld7Yq"
        }
      ],
      "totalCount": 12,
      "endCursor": "Y3Vyc29yOnYyOpHOi3e2Kg=="
    },
    "url": "https://github.com/dotnet/runtime/issues/88048",
    "title": "[System.Text.Json] : More accurate error messages when failing to map fields or parameters"
  },
  {
    "author": "steveharter",
    "labels": [
      "test-failure",
      "area-System.Text.Json",
      "disabled-test",
      "Known Build Error"
    ],
    "createdAt": "2023-06-30T21:02:50Z",
    "body": "## Build Information\r\nBuild: https://dev.azure.com/dnceng-public/cbb18261-c48f-4abb-8651-8cdcb5474649/_build/results?buildId=326554\r\nBuild error leg or test failing: System.Text.Json.Tests.Utf8JsonWriterTests.WriteRawLargeJsonToStreamWithoutFlushing\r\nPull request: https://github.com/dotnet/runtime/pull/87335\r\n<!-- Error message template  -->\r\n    System.Text.Json.Tests.Utf8JsonWriterTests.WriteRawLargeJsonToStreamWithoutFlushing [FAIL]\r\n      System.OutOfMemoryException : Exception of type 'System.OutOfMemoryException' was thrown.\r\n      Stack Trace:\r\n        /_/src/libraries/System.Private.CoreLib/src/System/Array.cs(63,0): at System.Array.Resize[T](T[]& array, Int32 newSize)\r\n        /_/src/libraries/Common/src/System/Buffers/ArrayBufferWriter.cs(200,0): at System.Buffers.ArrayBufferWriter`1.CheckAndResizeBuffer(Int32 sizeHint)\r\n        /_/src/libraries/Common/src/System/Buffers/ArrayBufferWriter.cs(134,0): at System.Buffers.ArrayBufferWriter`1.GetMemory(Int32 sizeHint)\r\n        /_/src/libraries/System.Text.Json/src/System/Text/Json/Writer/Utf8JsonWriter.cs(1069,0): at System.Text.Json.Utf8JsonWriter.Grow(Int32 requiredSize)\r\n        /_/src/libraries/System.Text.Json/src/System/Text/Json/Writer/Utf8JsonWriter.WriteValues.Raw.cs(266,0): at System.Text.Json.Utf8JsonWriter.WriteRawValueCore(ReadOnlySpan`1 utf8Json, Boolean skipInputValidation)\r\n        /_/src/libraries/System.Text.Json/src/System/Text/Json/Writer/Utf8JsonWriter.WriteValues.Raw.cs(113,0): at System.Text.Json.Utf8JsonWriter.WriteRawValue(ReadOnlySpan`1 utf8Json, Boolean skipInputValidation)\r\n        /_/src/libraries/System.Text.Json/tests/System.Text.Json.Tests/Utf8JsonWriterTests.WriteRaw.cs(373,0): at System.Text.Json.Tests.Utf8JsonWriterTests.WriteRawLargeJsonToStreamWithoutFlushing()\r\n           at System.RuntimeMethodHandle.InvokeMethod(Object target, Void** arguments, Signature sig, Boolean isConstructor)\r\n        /_/src/libraries/System.Private.CoreLib/src/System/Reflection/MethodInvoker.cs(59,0): at System.Reflection.MethodInvoker.Invoke(Object obj, IntPtr* args, BindingFlags invokeAttr)\r\n   System.Text.Json.Tests: [Long Running Test] 'System.Text.Json.Tests.Utf8JsonWriterTests.WriteRawMaxUtf16InputLength', Elapsed: 00:02:03\r\n<!-- Use ErrorMessage for String.Contains matches. Use ErrorPattern for regex matches (single line/no backtracking). Set BuildRetry to `true` to retry builds with this error. Set ExcludeConsoleLog to `true` to skip helix logs analysis. -->\r\n\r\n```json\r\n{\r\n  \"ErrorMessage\": \"\",\r\n  \"ErrorPattern\": \"System.Text.Json.Tests.Utf8JsonWriterTests.WriteRawLargeJsonToStreamWithoutFlushing.*System.OutOfMemoryException : Exception of type 'System.OutOfMemoryException' was thrown\",\r\n  \"BuildRetry\": false,\r\n  \"ExcludeConsoleLog\": false\r\n}\r\n```\r\n\r\n\r\n<!-- Known issue validation start -->\r\n ### Known issue validation\r\n**Build: :mag_right:** https://dev.azure.com/dnceng-public/public/_build/results?buildId=326554\r\n**Error message validated:** `System.Text.Json.Tests.Utf8JsonWriterTests.WriteRawLargeJsonToStreamWithoutFlushing.*System.OutOfMemoryException : Exception of type 'System.OutOfMemoryException' was thrown`\r\n**Result validation: :x:** Known issue did not match with the provided build.\r\n**Validation performed at:** 6/30/2023 9:23:10 PM UTC\r\n<!-- Known issue validation end -->\r\n<!--Known issue error report start -->\r\n\r\n### Report\r\n#### Summary\r\n|24-Hour Hit Count|7-Day Hit Count|1-Month Count|\r\n|---|---|---|\r\n|0|0|0|\r\n<!--Known issue error report end -->",
    "number": 88272,
    "reactions": {
      "hasNextPage": false,
      "nodes": [],
      "totalCount": 0,
      "endCursor": null
    },
    "updatedAt": "2025-09-21T04:00:27Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\n## Build Information\r\nBuild: https://dev.azure.com/dnceng-public/cbb18261-c48f-4abb-8651-8cdcb5474649/_build/results?buildId=326554\r\nBuild error leg or test failing: System.Text.Json.Tests.Utf8JsonWriterTests.WriteRawLargeJsonToStreamWithoutFlushing\r\nPull request: https://github.com/dotnet/runtime/pull/87335\r\n<!-- Error message template  -->\r\n    System.Text.Json.Tests.Utf8JsonWriterTests.WriteRawLargeJsonToStreamWithoutFlushing [FAIL]\r\n      System.OutOfMemoryException : Exception of type 'System.OutOfMemoryException' was thrown.\r\n      Stack Trace:\r\n        /_/src/libraries/System.Private.CoreLib/src/System/Array.cs(63,0): at System.Array.Resize[T](T[]& array, Int32 newSize)\r\n        /_/src/libraries/Common/src/System/Buffers/ArrayBufferWriter.cs(200,0): at System.Buffers.ArrayBufferWriter`1.CheckAndResizeBuffer(Int32 sizeHint)\r\n        /_/src/libraries/Common/src/System/Buffers/ArrayBufferWriter.cs(134,0): at System.Buffers.ArrayBufferWriter`1.GetMemory(Int32 sizeHint)\r\n        /_/src/libraries/System.Text.Json/src/System/Text/Json/Writer/Utf8JsonWriter.cs(1069,0): at System.Text.Json.Utf8JsonWriter.Grow(Int32 requiredSize)\r\n        /_/src/libraries/System.Text.Json/src/System/Text/Json/Writer/Utf8JsonWriter.WriteValues.Raw.cs(266,0): at System.Text.Json.Utf8JsonWriter.WriteRawValueCore(ReadOnlySpan`1 utf8Json, Boolean skipInputValidation)\r\n        /_/src/libraries/System.Text.Json/src/System/Text/Json/Writer/Utf8JsonWriter.WriteValues.Raw.cs(113,0): at System.Text.Json.Utf8JsonWriter.WriteRawValue(ReadOnlySpan`1 utf8Json, Boolean skipInputValidation)\r\n        /_/src/libraries/System.Text.Json/tests/System.Text.Json.Tests/Utf8JsonWriterTests.WriteRaw.cs(373,0): at System.Text.Json.Tests.Utf8JsonWriterTests.WriteRawLargeJsonToStreamWithoutFlushing()\r\n           at System.RuntimeMethodHandle.InvokeMethod(Object target, Void** arguments, Signature sig, Boolean isConstructor)\r\n        /_/src/libraries/System.Private.CoreLib/src/System/Reflection/MethodInvoker.cs(59,0): at System.Reflection.MethodInvoker.Invoke(Object obj, IntPtr* args, BindingFlags invokeAttr)\r\n   System.Text.Json.Tests: [Long Running Test] 'System.Text.Json.Tests.Utf8JsonWriterTests.WriteRawMaxUtf16InputLength', Elapsed: 00:02:03\r\n<!-- Use ErrorMessage for String.Contains matches. Use ErrorPattern for regex matches (single line/no backtracking). Set BuildRetry to `true` to retry builds with this error. Set ExcludeConsoleLog to `true` to skip helix logs analysis. -->\r\n\r\n```json\r\n{\r\n  \"ErrorMessage\": \"\",\r\n  \"ErrorPattern\": \"System.Text.Json.Tests.Utf8JsonWriterTests.WriteRawLargeJsonToStreamWithoutFlushing.*System.OutOfMemoryException : Exception of type 'System.OutOfMemoryException' was thrown\",\r\n  \"BuildRetry\": false,\r\n  \"ExcludeConsoleLog\": false\r\n}\r\n```\r\n\r\n\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>steveharter</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`area-System.Text.Json`, `blocking-clean-ci`, `Known Build Error`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2023-06-30T21:03:02Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-06-30T21:03:02Z",
          "id": "IC_kwDODI9FZc5gReXg"
        },
        {
          "author": "eiriktsarpalis",
          "body": "I'm also seeing `System.Text.Json.Tests.Utf8JsonWriterTests.WriteRawMaxUtf16InputLength` fail a couple of times with OOM in the same build. It all impacts Debug builds on Windows.",
          "createdAt": "2023-07-01T08:13:46Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-07-01T08:13:46Z",
          "id": "IC_kwDODI9FZc5gTO4j"
        },
        {
          "author": "eiriktsarpalis",
          "body": "The test was disabled on Linux for similar reasons. I've posted https://github.com/dotnet/runtime/pull/89442 which disables it altogether.",
          "createdAt": "2023-07-25T15:03:00Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-07-25T15:03:00Z",
          "id": "IC_kwDODI9FZc5iWTem"
        }
      ],
      "totalCount": 3,
      "endCursor": "Y3Vyc29yOnYyOpHOYlk3pg=="
    },
    "url": "https://github.com/dotnet/runtime/issues/88272",
    "title": "OOM on  System.Text.Json.Tests.Utf8JsonWriterTests.WriteRawLargeJsonToStreamWithoutFlushing"
  },
  {
    "author": "eiriktsarpalis",
    "labels": [
      "enhancement",
      "area-System.Text.Json",
      "source-generator"
    ],
    "createdAt": "2023-07-07T11:46:20Z",
    "body": "The change in https://github.com/dotnet/runtime/pull/88452 added internal/private member support for `JsonIncludeAttribute`/`JsonConstructorAttribute` in the reflection-based serializer. We should consider extending this to the source generator via the recent feature introduced in https://github.com/dotnet/runtime/issues/81741. Note that this would only work for the latest TFMs (with some reflection-based fallback being necessary in older targets).\r\n\r\ncc @jkotas",
    "number": 88519,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "HEART",
          "createdAt": "2023-10-27T19:02:53Z",
          "user": "bp74"
        },
        {
          "content": "HEART",
          "createdAt": "2023-11-29T08:32:26Z",
          "user": "voroninp"
        },
        {
          "content": "HEART",
          "createdAt": "2024-05-10T09:08:26Z",
          "user": "ceztko"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-10-11T13:30:46Z",
          "user": "DVN237294"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-11-23T09:35:47Z",
          "user": "Jure-BB"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-02-22T13:52:13Z",
          "user": "YYHEggEgg"
        }
      ],
      "totalCount": 6,
      "endCursor": "Y3Vyc29yOnYyOpHOC_W18Q=="
    },
    "updatedAt": "2024-05-10T13:05:01Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\nThe change in https://github.com/dotnet/runtime/pull/88452 added internal/private member support for `JsonIncludeAttribute`/`JsonConstructorAttribute` in the reflection-based serializer. We should consider extending this to the source generator via the recent feature introduced in https://github.com/dotnet/runtime/issues/81741. Note that this would only work for the latest TFMs (with some reflection-based fallback being necessary in older targets).\r\n\r\ncc @jkotas\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>eiriktsarpalis</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`area-System.Text.Json`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>9.0.0</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2023-07-07T11:46:27Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-07-07T11:46:27Z",
          "id": "IC_kwDODI9FZc5g3_-0"
        },
        {
          "author": "jkotas",
          "body": "> with some reflection-based fallback being necessary in older targets\r\n\r\nWe should simply not support this feature with source generators for older targets.\r\n\r\nReflection-based callback in source generators for older targets would violate promise of System.Text.Json source generator producing fast code that is trimming and AOT friendly.",
          "createdAt": "2023-07-07T15:46:26Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-07-08T17:30:25Z",
                "user": "jkoritzinsky"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-11-29T08:32:56Z",
                "user": "voroninp"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-11-23T09:36:12Z",
                "user": "Jure-BB"
              }
            ],
            "totalCount": 3,
            "endCursor": "Y3Vyc29yOnYyOpHOD8Mypg=="
          },
          "updatedAt": "2023-07-07T15:46:26Z",
          "id": "IC_kwDODI9FZc5g5Mxy"
        },
        {
          "author": "ceztko",
          "body": "I'm happy to see this enhancement is officially endorsed by the team, I hope to see it for .NET9/10. While studying this limitation, I made a strange discovery and found out that putting a serializer context partial class within the class to be serialized (see the snippet below) allows the source generator to produce code that is indeed accessing the private fields, but still the compilation produces warnings and the serialization throws at runtime. I don't know if this can cause some concern today, but I am sure it will be properly replaced with the visibility suppression mechanism in the future.\r\n\r\n```csharp\r\n    public partial class Vehicle\r\n    {\r\n        [JsonInclude, JsonPropertyName(nameof(Brand))]\r\n        private string? _Brand;\r\n\r\n        [JsonIgnore]\r\n        public string? Brand => _Brand;\r\n\r\n        [JsonSerializable(typeof(Vehicle))]\r\n        internal partial class VehicleSerializerContext : JsonSerializerContext;\r\n    }\r\n\r\n    /* The following code is produced by the generator, and obviously compiles correctly\r\n     * Still it has the warning \"warning SYSLIB1038: The member 'Vehicle._Model' has been\r\n     *  annotated with the JsonIncludeAttribute but is not visible to the source generator\"\r\n     * and throws at runtime\r\n     * \r\n     *  Getter = static obj => ((global::ConsoleApp1.Vehicle)obj)._Model,\r\n     *  Setter = static (obj, value) => ((global::ConsoleApp1.Vehicle)obj)._Model = value!,\r\n     */\r\n```",
          "createdAt": "2024-05-10T07:54:50Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-05-10T08:00:52Z",
          "id": "IC_kwDODI9FZc59alnK"
        },
        {
          "author": "eiriktsarpalis",
          "body": "> While studying this limitation, I made a strange discovery and found out that putting a serializer context partial class within the class to be serialized (see the snippet below) allows the source generator to produce code that is indeed accessing the private fields.\r\n\r\nThis is expected behavior. It's not that (opted in) private members aren't supported in general, the more accurate statement is that members _inaccessible_ to the generated class are not supported. Per C# semantics private members are accessible to nested types, so in this (relatively rare) case the source generator happens to work.\r\n\r\n> but still the compilation produces warnings and the serialization throws at runtime.\r\n\r\nI can't reproduce in .NET 8. Is the project using multi-targeting perhaps?",
          "createdAt": "2024-05-10T11:13:13Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-05-10T11:13:13Z",
          "id": "IC_kwDODI9FZc59bvkY"
        },
        {
          "author": "ceztko",
          "body": "> I can't reproduce in .NET 8. Is the project using multi-targeting perhaps?\r\n\r\nNo. I can reproduce in .NET 8 (I'm using latest stable VS 17.9.6) with the following steps:\r\n\r\n- Create an empty console application;\r\n- Paste the code below and run (produces warnings and throws the exception reported below).\r\n- (_Workaround step_): As per the documentation of the warning (and the `System.Text.Json` documentation in general about source generators), making all the private fields in the code internals, compile and run will have everything run just fine. But you just told me private members in some contexts can be supported and that you can't reproduce...\r\n\r\n```csharp\r\nusing System.Text.Json;\r\nusing System.Text.Json.Serialization;\r\n\r\nnamespace ConsoleApp1\r\n{\r\n    [JsonDerivedType(typeof(MotorVehicle), \"MotorVehicle\")]\r\n    [JsonDerivedType(typeof(Car), \"Car\")]\r\n    public partial class Vehicle\r\n    {\r\n        [JsonInclude, JsonPropertyName(nameof(Model))]\r\n        private string? _Model;\r\n\r\n        [JsonIgnore]\r\n        public string? Model => _Model;\r\n\r\n        [JsonSerializable(typeof(Vehicle))]\r\n        internal partial class VehicleSerializerContext : JsonSerializerContext;\r\n    }\r\n\r\n    public partial class MotorVehicle : Vehicle\r\n    {\r\n        [JsonInclude]\r\n        [JsonPropertyName(nameof(TransmissionType))]\r\n        [JsonConverter(typeof(JsonStringEnumConverter<TransmissionType>))]\r\n        private TransmissionType _TransmissionType;\r\n\r\n        [JsonIgnore]\r\n        public TransmissionType TransmissionType => _TransmissionType;\r\n\r\n        [JsonSerializable(typeof(MotorVehicle))]\r\n        internal partial class MotorVehicleSerializerContext : JsonSerializerContext;\r\n    }\r\n\r\n    public partial class Car : MotorVehicle\r\n    {\r\n        [JsonInclude]\r\n        [JsonPropertyName(nameof(CarClassification))]\r\n        [JsonConverter(typeof(JsonStringEnumConverter<CarClassification>))]\r\n        private CarClassification _CarClassification;\r\n\r\n        [JsonIgnore]\r\n        public CarClassification CarClassification => _CarClassification;\r\n\r\n        [JsonSerializable(typeof(Car))]\r\n        internal partial class CarSerializerContext : JsonSerializerContext;\r\n    }\r\n\r\n    public enum CarClassification\r\n    {\r\n        Unknown = 0,\r\n        Small,\r\n        Medium,\r\n        Large,\r\n    }\r\n\r\n    public enum TransmissionType\r\n    {\r\n        Unknown = 0,\r\n        Manual,\r\n        Automatic\r\n    }\r\n\r\n    class Program\r\n    {\r\n        public static int Main(string[] _)\r\n        {\r\n            var json = JsonSerializer.Serialize(new Car(), Vehicle.VehicleSerializerContext.Default.Vehicle);\r\n            Console.WriteLine(json);\r\n\r\n            var result = JsonSerializer.Deserialize(json, Vehicle.VehicleSerializerContext.Default.Vehicle);\r\n            Console.WriteLine($\"result is {result!.GetType()}\");\r\n\r\n            return 0;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n\r\nThe compilation produces these warnings:\r\n```\r\nwarning SYSLIB1038: The member 'MotorVehicle._TransmissionType' has been annotated with the JsonIncludeAttribute but is not visible to the source generator. (https://learn.microsoft.com/dotnet/fundamentals/syslib-diagnostics/syslib1038)\r\nwarning SYSLIB1038: The member 'Car._CarClassification' has been annotated with the JsonIncludeAttribute but is not visible to the source generator. (https://learn.microsoft.com/dotnet/fundamentals/syslib-diagnostics/syslib1038)\r\nwarning SYSLIB1038: The member 'Vehicle._Model' has been annotated with the JsonIncludeAttribute but is not visible to the source generator. (https://learn.microsoft.com/dotnet/fundamentals/syslib-diagnostics/syslib1038)\r\n```\r\n\r\nAnd the exception is:\r\n\r\n```\r\nUnhandled exception. System.InvalidOperationException: The property '_CarClassification' on type 'ConsoleApp1.Car' which is annotated with 'JsonIncludeAttribute' is not accesible by the source generator.\r\n   at System.Text.Json.ThrowHelper.ThrowInvalidOperationException_JsonIncludeOnInaccessibleProperty(String memberName, Type declaringType)\r\n   at System.Text.Json.Serialization.Metadata.JsonMetadataServices.PopulateProperties(JsonTypeInfo typeInfo, JsonPropertyInfoList propertyList, Func`2 propInitFunc)\r\n   at System.Text.Json.Serialization.Metadata.JsonTypeInfo.<get_PropertyList>g__CreatePropertyList|65_0()\r\n   at System.Text.Json.Serialization.Metadata.JsonTypeInfo.ConfigureProperties()\r\n   at System.Text.Json.Serialization.Metadata.JsonTypeInfo.Configure()\r\n   at System.Text.Json.Serialization.Metadata.JsonTypeInfo.<EnsureConfigured>g__ConfigureSynchronized|172_0()\r\n   at System.Text.Json.JsonSerializerOptions.GetTypeInfoInternal(Type type, Boolean ensureConfigured, Nullable`1 ensureNotNull, Boolean resolveIfMutable, Boolean fallBackToNearestAncestorType)\r\n   at System.Text.Json.Serialization.Metadata.PolymorphicTypeResolver.DerivedJsonTypeInfo.GetJsonTypeInfo(JsonSerializerOptions options)\r\n   at System.Text.Json.Serialization.Metadata.PolymorphicTypeResolver.TryGetDerivedJsonTypeInfo(Type runtimeType, JsonTypeInfo& jsonTypeInfo, Object& typeDiscriminator)\r\n   at System.Text.Json.Serialization.JsonConverter.ResolvePolymorphicConverter(Object value, JsonTypeInfo jsonTypeInfo, JsonSerializerOptions options, WriteStack& state)\r\n   at System.Text.Json.Serialization.JsonConverter`1.TryWrite(Utf8JsonWriter writer, T& value, JsonSerializerOptions options, WriteStack& state)\r\n   at System.Text.Json.Serialization.JsonConverter`1.WriteCore(Utf8JsonWriter writer, T& value, JsonSerializerOptions options, WriteStack& state)\r\n   at System.Text.Json.Serialization.Metadata.JsonTypeInfo`1.Serialize(Utf8JsonWriter writer, T& rootValue, Object rootValueBoxed)\r\n   at System.Text.Json.JsonSerializer.WriteString[TValue](TValue& value, JsonTypeInfo`1 jsonTypeInfo)\r\n   at System.Text.Json.JsonSerializer.Serialize[TValue](TValue value, JsonTypeInfo`1 jsonTypeInfo)\r\n   at ConsoleApp1.Program.Main(String[] _) in C:\\Users\\ceztko\\Source\\Repos\\ConsoleApp1\\ConsoleApp2\\Program.cs:line 68\r\n```",
          "createdAt": "2024-05-10T12:05:55Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-05-10T12:07:07Z",
          "id": "IC_kwDODI9FZc59cAKf"
        },
        {
          "author": "eiriktsarpalis",
          "body": "I've been able to trim down to the following repro:\r\n```C#\r\nstring json = JsonSerializer.Serialize(new Derived(), Base.Context.Default.Derived);\r\nConsole.WriteLine(json);\r\n\r\npublic partial class Base\r\n{\r\n    [JsonSerializable(typeof(Derived))]\r\n    internal partial class Context : JsonSerializerContext;\r\n}\r\n\r\npublic class Derived : Base\r\n{\r\n    [JsonInclude]\r\n    private int Value;\r\n}\r\n```\r\n\r\nThe relevant code in the source generator uses the `Compilation.IsSymbolAccessibleWithin` method to determine if a member is accessible from a given symbol:\r\n\r\nhttps://github.com/dotnet/runtime/blob/56d7e5d80ed6dd5e80ca8225ab689a60cae3cfc7/src/libraries/System.Text.Json/gen/JsonSourceGenerator.Parser.cs#L1373-L1382\r\n\r\nPerhaps that method is hitting a corner case? cc @dotnet/roslyn\r\n\r\nThat being said, it seems like a super low-priority issue with a clear workaround.",
          "createdAt": "2024-05-10T12:29:32Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "ROCKET",
                "createdAt": "2024-05-10T12:52:00Z",
                "user": "ceztko"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHODhaTdg=="
          },
          "updatedAt": "2024-05-10T12:29:32Z",
          "id": "IC_kwDODI9FZc59cH8r"
        },
        {
          "author": "ceztko",
          "body": "> That being said, it seems like a super low-priority issue with a clear workaround.\r\n\r\nAs said, we were trying to exploit the limits of the system, and I came up with this idea of the inner class context. The workaround (making the fields internal) is acceptable for now but as you understand this lowers the quality of the encapsulation in my code and that's why I'm happy serialization of private fields will come anyway in a more general form, at some point.\r\n\r\n> Perhaps that method is hitting a corner case? cc @dotnet/roslyn\r\n\r\nFYI, it looks like the cc failed.",
          "createdAt": "2024-05-10T12:41:28Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-05-10T12:41:28Z",
          "id": "IC_kwDODI9FZc59cMIA"
        },
        {
          "author": "Joe4evr",
          "body": "> FYI, it looks like the cc failed.\r\n\r\nNah, github simply doesn't render the tag if you don't have permission to see inside the group being tagged.",
          "createdAt": "2024-05-10T13:05:00Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "EYES",
                "createdAt": "2024-05-10T13:12:27Z",
                "user": "ceztko"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-05-10T13:15:54Z",
                "user": "eiriktsarpalis"
              }
            ],
            "totalCount": 2,
            "endCursor": "Y3Vyc29yOnYyOpHODhadfg=="
          },
          "updatedAt": "2024-05-10T13:05:00Z",
          "id": "IC_kwDODI9FZc59cUjO"
        }
      ],
      "totalCount": 8,
      "endCursor": "Y3Vyc29yOnYyOpHOfXFIzg=="
    },
    "url": "https://github.com/dotnet/runtime/issues/88519",
    "title": "Add `JsonIncludeAttribute`/`JsonConstructorAttribute` support for private/inaccessible members in the source generator"
  },
  {
    "author": "konrad-jamrozik",
    "labels": [
      "enhancement",
      "area-System.Text.Json"
    ],
    "createdAt": "2023-07-12T06:00:50Z",
    "body": "### Description\r\n\r\n**Expected behavior**: If a read-only property has `[JsonInclude]` attribute, it should get serialized via `JsonSerializer.Serialize` even if following serialization options are used:\r\n\r\n``` csharp\r\nnew JsonSerializerOptions { IgnoreReadOnlyProperties = true })\r\n```\r\n\r\nbut this is not the case.\r\n\r\n**Actual behavior**: the property is ignored by serialization.\r\n\r\nNote that `[JsonIgnore]` will correctly override options that have `IgnoreReadOnlyProperties = false` and ignore a property. Hence I would expect an analogous \"mirrored\" behavior from `[JsonInclude]`.\r\n\r\nAs a side note, I was unable to find any documentation explaining the precedence of attributes vs serializer options.\r\n\r\n### Reproduction Steps\r\n\r\nGiven in this gist:\r\n\r\nhttps://gist.github.com/konrad-jamrozik/721a9c7624560fae0d1582353ef0708e\r\n\r\nTo repro, run `JsonIncludeReproTests.JsonIgnoreOverridesOptionsButJsonIncludeDoesNot`\r\n\r\n### Expected behavior\r\n\r\nSee the description above.\r\n\r\n### Actual behavior\r\n\r\nSee the description above.\r\n\r\n### Regression?\r\n\r\nI don't know.\r\n\r\n### Known Workarounds\r\n\r\nNone\r\n\r\n### Configuration\r\n\r\n.NET 8 preview. Details in the gist:\r\n\r\nhttps://gist.github.com/konrad-jamrozik/721a9c7624560fae0d1582353ef0708e\r\n\r\n### Other information\r\n\r\n_No response_",
    "number": 88716,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-08-16T10:47:40Z",
          "user": "tomaszmalik"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-05-19T13:06:27Z",
          "user": "HaraldMuehlhoffCC"
        }
      ],
      "totalCount": 2,
      "endCursor": "Y3Vyc29yOnYyOpHODCiHiA=="
    },
    "updatedAt": "2025-05-19T13:45:13Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\n### Description\n\nExpected behavior: If a read-only property has `[JsonInclude]` attribute, it should get serialized via `JsonSerializer.Serialize` even if following serialization options are used:\r\n\r\n``` csharp\r\nnew JsonSerializerOptions { IgnoreReadOnlyProperties = false })\r\n```\r\n\r\nbut this is not the case.\r\n\r\nActual behavior: the property is ignored by serialization.\r\n\r\nNote that `[JsonIgnore]` will correctly override options that have `IgnoreReadOnlyProperties = true` and ignore a property. Hence I would expected analogous \"mirrored\" behavior from `[JsonInclude]`.\n\n### Reproduction Steps\n\nGiven in this gist:\r\n\r\nhttps://gist.github.com/konrad-jamrozik/721a9c7624560fae0d1582353ef0708e\n\n### Expected behavior\n\nSee description above.\r\n\n\n### Actual behavior\n\nSee description above.\r\n\n\n### Regression?\n\nI don't know.\n\n### Known Workarounds\n\nNone\n\n### Configuration\n\n.NET 8 preview. Details in the gist:\r\n\r\nhttps://gist.github.com/konrad-jamrozik/721a9c7624560fae0d1582353ef0708e\n\n### Other information\n\n_No response_\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>konrad-jamrozik</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`area-System.Text.Json`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2023-07-12T06:01:09Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-07-12T06:01:09Z",
          "id": "IC_kwDODI9FZc5hRMpF"
        },
        {
          "author": "eiriktsarpalis",
          "body": "It's something we could consider rectifying.",
          "createdAt": "2023-07-12T09:41:59Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "HEART",
                "createdAt": "2023-07-12T19:51:11Z",
                "user": "konrad-jamrozik"
              },
              {
                "content": "HEART",
                "createdAt": "2025-05-19T13:10:15Z",
                "user": "HaraldMuehlhoffCC"
              }
            ],
            "totalCount": 2,
            "endCursor": "Y3Vyc29yOnYyOpHOESo_nA=="
          },
          "updatedAt": "2023-07-12T09:41:59Z",
          "id": "IC_kwDODI9FZc5hSTMw"
        },
        {
          "author": "konrad-jamrozik",
          "body": "@eiriktsarpalis probably it should also override [JsonSerializerOptions.IgnoreReadOnlyFields](https://learn.microsoft.com/en-us/dotnet/api/system.text.json.jsonserializeroptions.ignorereadonlyfields) (if it already doesn't).",
          "createdAt": "2023-07-12T19:52:54Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-07-13T09:13:10Z",
                "user": "eiriktsarpalis"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHODAkxYQ=="
          },
          "updatedAt": "2023-07-12T19:53:36Z",
          "id": "IC_kwDODI9FZc5hV3Gu"
        },
        {
          "author": "HaraldMuehlhoffCC",
          "body": "Just ran into the same problem; a setter (`private` or `init` will do) has to be defined ... otherwise `[JsonInclude]` is ignored.\nThis makes `IgnoreReadOnlyProperties = true` unusable in our use case as adding setters just for this would change the expressed intent; also very many changes would be required because of our very large codebase.",
          "createdAt": "2025-05-19T13:43:29Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-05-19T13:45:12Z",
          "id": "IC_kwDODI9FZc6sUogA"
        }
      ],
      "totalCount": 4,
      "endCursor": "Y3Vyc29yOnYyOpHOrFKIAA=="
    },
    "url": "https://github.com/dotnet/runtime/issues/88716",
    "title": "`JsonIncludeAttribute` should override global `JsonSerializerOptions.IgnoreReadOnlyProperties` configuration."
  },
  {
    "author": "Sc7-git",
    "labels": [
      "area-System.Text.Json",
      "wishlist"
    ],
    "createdAt": "2023-08-02T06:32:04Z",
    "body": "### Description\n\n```\r\n            int[,] array2D = new int[,] { { 1, 2 }, { 3, 4 }, { 5, 6 }, { 7, 8 } };\r\n            var array2DJson= System.Text.Json.JsonSerializer.Serialize(array2D);\r\n            var json = \"[[\\\"uhhvle7p55hc\\\",\\\"uhhvle7p55hd\\\",\\\"uhhvle7p55hh\\\"]]\";\r\n            var array = System.Text.Json.JsonSerializer.Deserialize<string[,]>(json);\r\n```\n\n### Reproduction Steps\n\n ```\r\n            int[,] array2D = new int[,] { { 1, 2 }, { 3, 4 }, { 5, 6 }, { 7, 8 } };\r\n            var array2DJson= System.Text.Json.JsonSerializer.Serialize(array2D);\r\n            var json = \"[[\\\"uhhvle7p55hc\\\",\\\"uhhvle7p55hd\\\",\\\"uhhvle7p55hh\\\"]]\";\r\n            var array = System.Text.Json.JsonSerializer.Deserialize<string[,]>(json);\r\n```\n\n### Expected behavior\n\nReturn serialization result\n\n### Actual behavior\n\nThe type 'System.Int32[,]' is not supported.\n\n### Regression?\n\n_No response_\n\n### Known Workarounds\n\n_No response_\n\n### Configuration\n\n_No response_\n\n### Other information\n\n_No response_",
    "number": 89843,
    "reactions": {
      "hasNextPage": false,
      "nodes": [],
      "totalCount": 0,
      "endCursor": null
    },
    "updatedAt": "2023-10-16T13:00:16Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\n### Description\n\n```\r\n            int[,] array2D = new int[,] { { 1, 2 }, { 3, 4 }, { 5, 6 }, { 7, 8 } };\r\n            var array2DJson= System.Text.Json.JsonSerializer.Serialize(array2D);\r\n            var json = \"[[\\\"uhhvle7p55hc\\\",\\\"uhhvle7p55hd\\\",\\\"uhhvle7p55hh\\\"]]\";\r\n            var array = System.Text.Json.JsonSerializer.Deserialize<string[,]>(json);\r\n```\n\n### Reproduction Steps\n\n ```\r\n            int[,] array2D = new int[,] { { 1, 2 }, { 3, 4 }, { 5, 6 }, { 7, 8 } };\r\n            var array2DJson= System.Text.Json.JsonSerializer.Serialize(array2D);\r\n            var json = \"[[\\\"uhhvle7p55hc\\\",\\\"uhhvle7p55hd\\\",\\\"uhhvle7p55hh\\\"]]\";\r\n            var array = System.Text.Json.JsonSerializer.Deserialize<string[,]>(json);\r\n```\n\n### Expected behavior\n\nReturn serialization result\n\n### Actual behavior\n\nThe type 'System.Int32[,]' is not supported.\n\n### Regression?\n\n_No response_\n\n### Known Workarounds\n\n_No response_\n\n### Configuration\n\n_No response_\n\n### Other information\n\n_No response_\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>Sc7-git</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`area-System.Text.Json`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2023-08-02T06:32:10Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-08-02T06:32:10Z",
          "id": "IC_kwDODI9FZc5jCbJW"
        },
        {
          "author": "huoyaoyuan",
          "body": "Duplicate of #44347. Currently there's no support for MD array.",
          "createdAt": "2023-08-02T06:46:15Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-08-02T06:46:15Z",
          "id": "IC_kwDODI9FZc5jCen4"
        },
        {
          "author": "gregsdennis",
          "body": "Three years later, and STJ is significantly more mature.  Can we use this issue to have another look at implementing it?\n\nNot sure what a JSON representation of a MD array would look like, though.  I wonder if there are any precedents.",
          "createdAt": "2023-08-02T08:42:09Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-10-16T13:01:14Z",
                "user": "m-gallesio"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-11-22T00:31:07Z",
                "user": "elgonzo"
              }
            ],
            "totalCount": 2,
            "endCursor": "Y3Vyc29yOnYyOpHODNSDBw=="
          },
          "updatedAt": "2023-08-02T08:42:09Z",
          "id": "IC_kwDODI9FZc5jDKAw"
        },
        {
          "author": "eiriktsarpalis",
          "body": "> Not sure what a JSON representation of a MD array would look like, though. \r\n\r\nThere doesn't appear to be a standard representation being used anywhere, although using jagged arrays is probably the safest (although likely not the most efficient) representation. I found [this article](https://www.openriskmanagement.com/representing-matrices-as-json-objects-part-1/) discussing various approaches.",
          "createdAt": "2023-08-02T10:30:36Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-10-16T13:01:18Z",
                "user": "m-gallesio"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-09-06T01:04:21Z",
                "user": "JobaDiniz"
              }
            ],
            "totalCount": 2,
            "endCursor": "Y3Vyc29yOnYyOpHODxMriw=="
          },
          "updatedAt": "2023-08-02T10:30:54Z",
          "id": "IC_kwDODI9FZc5jD4WS"
        },
        {
          "author": "m-gallesio",
          "body": "> There doesn't appear to be a standard representation being used anywhere, although using jagged arrays is probably the safest (although likely not the most efficient) representation.\r\n\r\nNewtonsoft.Json does this too:\r\n\r\n```csharp\r\nint[,] matrix = new int[2, 3]\r\n{\r\n    { 1, 2, 3 },\r\n    { 4, 5, 6 }\r\n};\r\nSystem.Console.WriteLine(Newtonsoft.Json.JsonConvert.SerializeObject(matrix));\r\n```\r\n\r\n> `[[1,2,3],[4,5,6]]`",
          "createdAt": "2023-10-16T13:00:16Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-10-16T13:02:19Z",
                "user": "eiriktsarpalis"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-09-06T01:04:33Z",
                "user": "JobaDiniz"
              }
            ],
            "totalCount": 2,
            "endCursor": "Y3Vyc29yOnYyOpHODxMrlQ=="
          },
          "updatedAt": "2023-10-16T13:00:16Z",
          "id": "IC_kwDODI9FZc5pKyil"
        }
      ],
      "totalCount": 5,
      "endCursor": "Y3Vyc29yOnYyOpHOaSsopQ=="
    },
    "url": "https://github.com/dotnet/runtime/issues/89843",
    "title": "The type 'System.Int32[,]' is not supported."
  },
  {
    "author": "sagimar",
    "labels": [
      "enhancement",
      "area-System.Text.Json",
      "wishlist"
    ],
    "createdAt": "2023-08-08T09:51:11Z",
    "body": "### Description\n\nWhen serializing a local path URI, the scheme ('file:///') is being lost.\r\nThis was checked both with Newtonsoft.Json and System.Text.Json.\r\nOn Windows, when de-serializing the URI, it knows to add back the scheme.\r\n**But, on Linux, it doesn't know to do this conversion, so the following uri: file:///tmp/ is being converted to /tmp/, thus the absolute URI became a relative one, and methods as .AbsoluteUri will throw an exception.**\n\n### Reproduction Steps\n\nvar uri = new Uri(Path.GetTempPath());\r\nvar serializedUri = JsonConvert.SerializeObject(uri);\r\nvar deserializedUri = JsonConvert.DeserializeObject<Uri>(serializedUri);\r\n\r\nserializedUri equals to: \"\\\"C:\\\\\\\\Users\\\\\\\\********\\\\\\\\AppData\\\\\\\\Local\\\\\\\\Temp\\\\\\\\\\\"\"\n\n### Expected behavior\n\nserializedUri should contain file:///\n\n### Actual behavior\n\nserializedUri does not contain file:/// - in Windows it knows to add it back on deserialization, but on Linux it doesn't.\n\n### Regression?\n\n_No response_\n\n### Known Workarounds\n\n_No response_\n\n### Configuration\n\n_No response_\n\n### Other information\n\n_No response_",
    "number": 90140,
    "reactions": {
      "hasNextPage": false,
      "nodes": [],
      "totalCount": 0,
      "endCursor": null
    },
    "updatedAt": "2023-08-08T11:59:32Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\n### Description\n\nWhen serializing a local path URI, the scheme ('file:///') is being lost.\r\nThis was checked both with Newtonsoft.Json and System.Text.Json.\r\nOn Windows, when de-serializing the URI, it knows to add back the scheme.\r\n**But, on Linux, it doesn't know to do this conversion, so the following uri: file:///tmp/ is being converted to /tmp/, thus the absolute URI became a relative one, and methods as .AbsoluteUri will throw an exception.**\n\n### Reproduction Steps\n\nvar uri = new Uri(Path.GetTempPath());\r\nvar serializedUri = JsonConvert.SerializeObject(uri);\r\nvar deserializedUri = JsonConvert.DeserializeObject<Uri>(serializedUri);\r\n\r\nserializedUri equals to: \"\\\"C:\\\\\\\\Users\\\\\\\\********\\\\\\\\AppData\\\\\\\\Local\\\\\\\\Temp\\\\\\\\\\\"\"\n\n### Expected behavior\n\nserializedUri should contain file:///\n\n### Actual behavior\n\nserializedUri does not contain file:/// - in Windows it knows to add it back on deserialization, but on Linux it doesn't.\n\n### Regression?\n\n_No response_\n\n### Known Workarounds\n\n_No response_\n\n### Configuration\n\n_No response_\n\n### Other information\n\n_No response_\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>sagimar</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`area-System.Text.Json`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2023-08-08T09:51:22Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-08-08T09:51:22Z",
          "id": "IC_kwDODI9FZc5jf26C"
        },
        {
          "author": null,
          "body": "Tagging subscribers to this area: @dotnet/ncl\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\n### Description\n\nWhen serializing a local path URI, the scheme ('file:///') is being lost.\r\nThis was checked both with Newtonsoft.Json and System.Text.Json.\r\nOn Windows, when de-serializing the URI, it knows to add back the scheme.\r\n**But, on Linux, it doesn't know to do this conversion, so the following uri: file:///tmp/ is being converted to /tmp/, thus the absolute URI became a relative one, and methods as .AbsoluteUri will throw an exception.**\n\n### Reproduction Steps\n\nvar uri = new Uri(Path.GetTempPath());\r\nvar serializedUri = JsonConvert.SerializeObject(uri);\r\nvar deserializedUri = JsonConvert.DeserializeObject<Uri>(serializedUri);\r\n\r\nserializedUri equals to: \"\\\"C:\\\\\\\\Users\\\\\\\\********\\\\\\\\AppData\\\\\\\\Local\\\\\\\\Temp\\\\\\\\\\\"\"\n\n### Expected behavior\n\nserializedUri should contain file:///\n\n### Actual behavior\n\nserializedUri does not contain file:/// - in Windows it knows to add it back on deserialization, but on Linux it doesn't.\n\n### Regression?\n\n_No response_\n\n### Known Workarounds\n\n_No response_\n\n### Configuration\n\n_No response_\n\n### Other information\n\n_No response_\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>sagimar</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`area-System.Net`, `untriaged`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2023-08-08T09:54:53Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-08-08T09:54:53Z",
          "id": "IC_kwDODI9FZc5jf4V_"
        },
        {
          "author": "gregsdennis",
          "body": "Tangentially related to https://github.com/dotnet/runtime/issues/85229",
          "createdAt": "2023-08-08T09:55:27Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-08-08T09:55:27Z",
          "id": "IC_kwDODI9FZc5jf4j8"
        },
        {
          "author": "MihaZupan",
          "body": "Do you mean that you took the string `\"/tmp/\"`, passed it to `new Uri` on Linux, serialized the Uri instance to json, then deserialized said json on a Windows system?\r\n\r\nJson will just save the original string you passed to the ctor.\r\nUri only recognizes absolute Unix file paths when running on Linux. A string like `\"/tmp/\"` will therefore be treated as absolute on Linux and relative on Windows.\r\nSimilar issues for reference: #80118, #76816, #69308\r\n\r\n@eiriktsarpalis would it be a breaking change for Json to serialize `AbsoluteUri` instead of `OriginalString`?\r\n```c#\r\nvalue.IsAbsolute ? value.AbsoluteUri : value.OriginalString\r\n```",
          "createdAt": "2023-08-08T10:19:15Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-08-08T10:19:15Z",
          "id": "IC_kwDODI9FZc5jgBUw"
        },
        {
          "author": "sagimar",
          "body": "No no, sorry will correct myself- I don't move it between Linux to Windows- I just checked the behaviour once on Windows and once on Linux.\r\n\r\nLet me fully explain my scenario in Linux-\r\nWhen I create a uri:\r\nvar uri = new Uri(Path.GetTempPath());\r\nI am receiving a Uri that contains 'File:///'- printing the uri results with: file:///tmp/\r\nWhen I serialize the uri, the serialized string is: /tmp/\r\nThus, on deserialization, I am receiving a Uri with the value: /tmp/ (missing the 'File:///') - so instead of holding an absolute uri as was before when constructed, it is now only a relative one.",
          "createdAt": "2023-08-08T10:36:11Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-08-08T10:36:11Z",
          "id": "IC_kwDODI9FZc5jgHbw"
        },
        {
          "author": "MihaZupan",
          "body": "Ah, I see now. What you are running into is\r\n```c#\r\nvar uri1 = new Uri(\"/tmp/\");\r\nvar uri2 = new Uri(\"/tmp/\", UriKind.RelativeOrAbsolute); // How System.Text.Json parses it\r\n\r\nConsole.WriteLine(uri1.IsAbsoluteUri); // True\r\nConsole.WriteLine(uri2.IsAbsoluteUri); // False\r\n```\r\n\r\nDue to some [backward-compatibility behavior of Uri](https://github.com/dotnet/runtime/blob/5730c2098b2fe3f18c0d43303eecc6b96823274e/src/libraries/System.Private.Uri/src/System/UriExt.cs#L49-L65), implicit Unix file paths will be treated as relative if you specify `UriKind.RelativeOrAbsolute`.\r\n\r\nI would recommend that you try to avoid creating Uris with implicit file paths (without the `file://` scheme prefix).\r\nYou should be able to workaround this issue by using `new Uri($\"file://{Path.GetTempPath()}\")`.",
          "createdAt": "2023-08-08T11:13:17Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-08-08T11:13:17Z",
          "id": "IC_kwDODI9FZc5jgUSn"
        },
        {
          "author": "sagimar",
          "body": "The workaround will probably work- but just to emphasize, I'm not sending UriKind.RelativeOrAbsolute. Even if I send UriKind.Absolute, it acts the same.\r\nThe issue is probably that the serialization takes the 'OriginalString', but the constructor of the Uri takes the 'OriginalString' and adds to it file:/// - finally this ends with a different uri when constructing the uri through the constructor and when serializing it.\r\n\r\nIf the Uri constructor added 'file://' to the uri, I believe it should be propogated to the serializer too, since currently there is a different behaviour when constructing the uri through the constructor or through serialiation+deserialization.",
          "createdAt": "2023-08-08T11:16:56Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-08-08T11:16:56Z",
          "id": "IC_kwDODI9FZc5jgVgO"
        },
        {
          "author": "MihaZupan",
          "body": "> I'm not sending UriKind.RelativeOrAbsolute\r\n\r\nRight, the Json serializer is.\r\n\r\nhttps://github.com/dotnet/runtime/blob/5730c2098b2fe3f18c0d43303eecc6b96823274e/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/Converters/Value/UriConverter.cs#L23\r\n\r\nhttps://github.com/dotnet/runtime/blob/5730c2098b2fe3f18c0d43303eecc6b96823274e/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/Converters/Value/UriConverter.cs#L36\r\n\r\nThe problem is that inputs like `/tmp/` are ambiguous - they can mean different things depending on the platform, and depending on which ctor arguments you pass in.\r\nIf you use `new Uri(string, UriKind.RelativeOrAbsolute)` instead of `new Uri(string)`, you should see the same behavior as when you deserialize with `System.Text.Json`.",
          "createdAt": "2023-08-08T11:21:13Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-08-08T11:21:13Z",
          "id": "IC_kwDODI9FZc5jgW4x"
        },
        {
          "author": "sagimar",
          "body": "Yes, so I think that if you pass it to a constructor that added the 'file://' to the url, so when serializing it, it should also add the 'file://' upon serialization, then we'll have a consistency behaviour, no?",
          "createdAt": "2023-08-08T11:23:06Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-08-08T11:23:06Z",
          "id": "IC_kwDODI9FZc5jgXdO"
        },
        {
          "author": "MihaZupan",
          "body": "The serializer could potentially try to preserve that behavior, yes. This is what I was referring to when asking\r\n\r\n> would it be a breaking change for Json to serialize `AbsoluteUri` instead of `OriginalString`?",
          "createdAt": "2023-08-08T11:25:22Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-08-08T14:35:38Z",
                "user": "sagimar"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHODDCE0A=="
          },
          "updatedAt": "2023-08-08T11:25:22Z",
          "id": "IC_kwDODI9FZc5jgYL9"
        },
        {
          "author": "sagimar",
          "body": "Yes, sounds good! If it is indeed not a breaking change, I think this is a good improvement. Thank you!",
          "createdAt": "2023-08-08T11:26:00Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-08-08T11:26:00Z",
          "id": "IC_kwDODI9FZc5jgYZA"
        },
        {
          "author": null,
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\n### Description\n\nWhen serializing a local path URI, the scheme ('file:///') is being lost.\r\nThis was checked both with Newtonsoft.Json and System.Text.Json.\r\nOn Windows, when de-serializing the URI, it knows to add back the scheme.\r\n**But, on Linux, it doesn't know to do this conversion, so the following uri: file:///tmp/ is being converted to /tmp/, thus the absolute URI became a relative one, and methods as .AbsoluteUri will throw an exception.**\n\n### Reproduction Steps\n\nvar uri = new Uri(Path.GetTempPath());\r\nvar serializedUri = JsonConvert.SerializeObject(uri);\r\nvar deserializedUri = JsonConvert.DeserializeObject<Uri>(serializedUri);\r\n\r\nserializedUri equals to: \"\\\"C:\\\\\\\\Users\\\\\\\\********\\\\\\\\AppData\\\\\\\\Local\\\\\\\\Temp\\\\\\\\\\\"\"\n\n### Expected behavior\n\nserializedUri should contain file:///\n\n### Actual behavior\n\nserializedUri does not contain file:/// - in Windows it knows to add it back on deserialization, but on Linux it doesn't.\n\n### Regression?\n\n_No response_\n\n### Known Workarounds\n\n_No response_\n\n### Configuration\n\n_No response_\n\n### Other information\n\n_No response_\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>sagimar</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`area-System.Text.Json`, `untriaged`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2023-08-08T11:55:02Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-08-08T11:55:02Z",
          "id": "IC_kwDODI9FZc5jgh5R"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Thanks for helping with triage @MihaZupan. We'll consider this in a future release. In the meantime you might want to consider authoring a custom `JsonConverter<Uri>` that addresses your use case.",
          "createdAt": "2023-08-08T11:59:10Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-08-08T14:35:29Z",
                "user": "sagimar"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-11-24T16:01:07Z",
                "user": "elgonzo"
              }
            ],
            "totalCount": 2,
            "endCursor": "Y3Vyc29yOnYyOpHODNi71Q=="
          },
          "updatedAt": "2023-08-08T11:59:10Z",
          "id": "IC_kwDODI9FZc5jgjPK"
        }
      ],
      "totalCount": 13,
      "endCursor": "Y3Vyc29yOnYyOpHOY4Izyg=="
    },
    "url": "https://github.com/dotnet/runtime/issues/90140",
    "title": "[URI] Uri serialization is missing Scheme"
  },
  {
    "author": "eiriktsarpalis",
    "labels": [
      "enhancement",
      "area-System.Text.Json"
    ],
    "createdAt": "2023-08-10T22:46:53Z",
    "body": "Consider the following example:\r\n```C#\r\nstring value = \"𐐀𐐨𐐨𐐀𐐨𐐨\"; // surrogate pairs with mixed capitalization\r\n\r\nConsole.WriteLine(JsonNamingPolicy.CamelCase.ConvertName(value)); // 𐐀𐐨𐐨𐐀𐐨𐐨 should be 𐐨𐐨𐐨𐐀𐐨𐐨\r\nConsole.WriteLine(JsonNamingPolicy.SnakeCaseLower.ConvertName(value)); // 𐐀𐐨𐐨𐐀𐐨𐐨 should be 𐐨𐐨𐐨_𐐨𐐨𐐨\r\n```\r\n\r\nNeither `JsonNamingPolicy.CamelCase` nor `JsonNamingPolicy.SnakeCase/KebabCase` have support for surrogate pairs. We should consider adding support for surrogate pairs in the future (although that would most likely require https://github.com/dotnet/runtime/issues/52947).\r\n\r\nSee https://github.com/eiriktsarpalis/runtime/commit/c1c5d1c8a039235a14caa0f02c7e97d1f696634c for a prototype implementation that polyfills `Rune`.\r\n\r\nRelated to https://github.com/dotnet/runtime/pull/90316",
    "number": 90352,
    "reactions": {
      "hasNextPage": false,
      "nodes": [],
      "totalCount": 0,
      "endCursor": null
    },
    "updatedAt": "2023-08-10T22:50:36Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\nConsider the following example:\r\n```C#\r\nstring value = \"𐐀𐐨𐐨𐐀𐐨𐐨\"; // surrogate pairs with mixed capitalization\r\n\r\nConsole.WriteLine(JsonNamingPolicy.CamelCase.ConvertName(value)); // 𐐀𐐨𐐨𐐀𐐨𐐨 should be 𐐨𐐨𐐨𐐀𐐨𐐨\r\nConsole.WriteLine(JsonNamingPolicy.SnakeCaseLower.ConvertName(value)); // 𐐀𐐨𐐨𐐀𐐨𐐨 should be 𐐨𐐨𐐨_𐐨𐐨𐐨\r\n```\r\n\r\nNeither `JsonNamingPolicy.CamelCase` nor `JsonNamingPolicy.SnakeCase/KebabCase` have support for surrogate pairs. We should consider adding support for surrogate pairs in the future (although that would most likely require https://github.com/dotnet/runtime/issues/52947).\r\n\r\nSee https://github.com/eiriktsarpalis/runtime/commit/c1c5d1c8a039235a14caa0f02c7e97d1f696634c for a prototype implementation that polyfills `Rune`.\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>eiriktsarpalis</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`enhancement`, `area-System.Text.Json`, `needs-area-label`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>Future</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2023-08-10T22:47:20Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-08-10T22:47:20Z",
          "id": "IC_kwDODI9FZc5jx4km"
        }
      ],
      "totalCount": 1,
      "endCursor": "Y3Vyc29yOnYyOpHOY8eJJg=="
    },
    "url": "https://github.com/dotnet/runtime/issues/90352",
    "title": "Built-in `JsonNamingPolicy` types don't recognize surrogate pairs"
  },
  {
    "author": "just-ero",
    "labels": [
      "api-suggestion",
      "area-System.Text.Json"
    ],
    "createdAt": "2023-08-18T08:49:18Z",
    "body": "### Background and motivation\n\nToday, developers must inherit from an abstract `JsonConverter<T>` class to convert their own or any other classes when serializing to and deserializing from JSON input. This causes some anti-patterns: the converting code is not coupled to the type directly (which, granted, is not possible to circumvent if the developer does not own the type), and the converter must be separately included either via `JsonSerializerOptions` or via attributes on the type or a `JsonSerializerContext`.\r\n\r\nThese are, to me, quite annoying and unintuitive patterns, which could be muchly improved via `IJsonSerializable<TSelf>` (and `IJsonDeserializable<TSelf>`) interfaces. The interface(s) would be placed directly on the type definition (so long as the developer owns the type, of course) and the implementations of (de-)serialization would be contained within the type, eliminating the need for a separate class and inclusion of converters via the means above.\r\n\r\nThis would greatly improve intuitiveness, make use of more common patterns, decrease required code size, and (potentially) reduce cognitive load by not having to monitor where and how converters are included.\n\n### API Proposal\n\n```csharp\r\nusing System.Text.Json;\r\n\r\nnamespace System.Text.Json.Serialization;\r\n\r\npublic interface IJsonSerializable<TSelf>\r\n    where TSelf : IJsonSerializable<TSelf>\r\n{\r\n    static abstract TSelf? Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options);\r\n}\r\n\r\npublic interface IJsonDeserializable<TSelf>\r\n    where TSelf : IJsonDeserializable<TSelf>\r\n{\r\n    static abstract void Write(Utf8JsonWriter writer, TSelf value, JsonSerializerOptions options);\r\n}\r\n```\r\n\n\n### API Usage\n\n```csharp\r\nclass C : IJsonSerializable<C>\r\n{\r\n    public int Foo { get; set; }\r\n\r\n    public static C? Read(ref Utf8JsonReader reader, JsonSerializerOptions options)\r\n    {\r\n        return new()\r\n        {\r\n            Foo = int.Parse(reader.GetString())\r\n        };\r\n    }\r\n}\r\n```\r\n\n\n### Alternative Designs\n\n```csharp\r\nusing System.Text.Json;\r\n\r\nnamespace System.Text.Json.Serialization;\r\n\r\npublic interface IJsonSerializable<TSelf>\r\n    where TSelf : IJsonSerializable<TSelf>\r\n{\r\n    static abstract TSelf? Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options);\r\n    static abstract void Write(Utf8JsonWriter writer, TSelf value, JsonSerializerOptions options);\r\n}\r\n```\r\n\n\n### Risks\n\n- This approach could have some unexpected results for developers (creating a `MyLibrary`), which use third-party libraries (a `TheirLibrary`) that implement such interfaces on their types (`TypeInTheirLibrary`). It may be possible to let a user of such a `TheirLibrary` *override* the serialization of `TypeInTheirLibrary` with a `JsonConverter<TypeInTheirLibrary>` in `MyLibrary`, converters take precedence depending on the \"closeness\" of it to the executing code.\r\n\r\n- I'm not sure how this factors into source generation and if it's possible at all to handle the interface implementations with it.",
    "number": 90787,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "THUMBS_DOWN",
          "createdAt": "2023-11-26T18:18:29Z",
          "user": "Tvde1"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-12-11T13:06:25Z",
          "user": "eiriktsarpalis"
        }
      ],
      "totalCount": 2,
      "endCursor": "Y3Vyc29yOnYyOpHOC0jktQ=="
    },
    "updatedAt": "2025-03-18T10:11:19Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\n### Background and motivation\n\nToday, developers must inherit from an abstract `JsonConverter<T>` class to convert their own or any other classes when serializing to and deserializing from JSON input. This causes some anti-patterns: the converting code is not coupled to the type directly (which, granted, is not possible to circumvent if the developer does not own the type), and the converter must be separately included either via `JsonSerializerOptions` or via attributes on the type or a `JsonSerializerContext`.\r\n\r\nThese are, to me, quite annoying and unintuitive patterns, which could be muchly improved via `IJsonSerializable<TSelf>` (and `IJsonDeserializable<TSelf>`) interfaces. The interface(s) would be placed directly on the type definition (so long as the developer owns the type, of course) and the implementations of (de-)serialization would be contained within the type, eliminating the need for a separate class and inclusion of converters via the means above.\r\n\r\nThis would greatly improve intuitiveness, make use of more common patterns, decrease required code size, and (potentially) reduce cognitive load by not having to monitor where and how converters are included.\n\n### API Proposal\n\n```csharp\r\nusing System.Text.Json;\r\n\r\nnamespace System.Text.Json.Serialization;\r\n\r\npublic interface IJsonSerializable<TSelf>\r\n    where TSelf : IJsonSerializable<TSelf>\r\n{\r\n    static abstract TSelf? Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options);\r\n}\r\n\r\npublic interface IJsonDeserializable<TSelf>\r\n    where TSelf : IJsonDeserializable<TSelf>\r\n{\r\n    static abstract void Write(Utf8JsonWriter writer, TSelf value, JsonSerializerOptions options);\r\n}\r\n```\r\n\n\n### API Usage\n\n```csharp\r\nclass C : IJsonSerializable<C>\r\n{\r\n    public int Foo { get; set; }\r\n\r\n    public static C? Read(ref Utf8JsonReader reader, JsonSerializerOptions options)\r\n    {\r\n        return new()\r\n        {\r\n            Foo = int.Parse(reader.GetString())\r\n        };\r\n    }\r\n}\r\n```\r\n\n\n### Alternative Designs\n\n```csharp\r\nusing System.Text.Json;\r\n\r\nnamespace System.Text.Json.Serialization;\r\n\r\npublic interface IJsonSerializable<TSelf>\r\n    where TSelf : IJsonSerializable<TSelf>\r\n{\r\n    static abstract TSelf? Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options);\r\n    static abstract void Write(Utf8JsonWriter writer, TSelf value, JsonSerializerOptions options);\r\n}\r\n```\r\n\n\n### Risks\n\n- This approach could have some unexpected results for developers (creating a `MyLibrary`), which use third-party libraries (a `TheirLibrary`) that implement such interfaces on their types (`TypeInTheirLibrary`). It may be possible to let a user of such a `TheirLibrary` *override* the serialization of `TypeInTheirLibrary` with a `JsonConverter<TypeInTheirLibrary>` in `MyLibrary`, converters take precedence depending on the \"closeness\" of it to the executing code.\r\n\r\n- I'm not sure how this factors into source generation and if it's possible at all to handle the interface implementations with it.\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>just-ero</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`api-suggestion`, `area-System.Text.Json`, `untriaged`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2023-08-18T08:49:28Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-08-18T08:49:28Z",
          "id": "IC_kwDODI9FZc5kWWl0"
        },
        {
          "author": "Atulin",
          "body": "This reminds me too much of active pattern to possibly be a good idea. Breaks SRP too.",
          "createdAt": "2023-08-18T09:16:53Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-08-18T09:56:10Z",
                "user": "Joe4evr"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-08-18T10:41:57Z",
                "user": "gregsdennis"
              },
              {
                "content": "THUMBS_DOWN",
                "createdAt": "2023-08-18T12:55:38Z",
                "user": "neon-sunset"
              }
            ],
            "totalCount": 3,
            "endCursor": "Y3Vyc29yOnYyOpHODEDESA=="
          },
          "updatedAt": "2023-08-18T09:16:53Z",
          "id": "IC_kwDODI9FZc5kWfA8"
        },
        {
          "author": "sakno",
          "body": "`static abstract void Write(Utf8JsonWriter writer, TSelf value, JsonSerializerOptions options);`\r\n\r\nWhy it should be **static**? `TSelf` can be passed implicitly as **this** instead of explicit `value` parameter.",
          "createdAt": "2023-08-18T09:29:34Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-08-18T09:29:34Z",
          "id": "IC_kwDODI9FZc5kWjGX"
        },
        {
          "author": "Tvde1",
          "body": "I also think data/models/classes should not be concerned with how they are serialized",
          "createdAt": "2023-08-18T09:50:50Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-08-18T09:56:05Z",
                "user": "Joe4evr"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-08-18T10:41:54Z",
                "user": "gregsdennis"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-08-18T13:14:42Z",
                "user": "LN-MDeRuscio"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-08-19T05:56:52Z",
                "user": "Hellevar"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-08-19T09:32:17Z",
                "user": "rgroenewoudt"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-08-20T20:32:30Z",
                "user": "Atulin"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-09-28T14:03:28Z",
                "user": "colejohnson66"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-11-24T15:06:33Z",
                "user": "elgonzo"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-01-11T20:02:45Z",
                "user": "jeffhandley"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-02-24T15:11:57Z",
                "user": "airbreather"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-09-18T16:57:45Z",
                "user": "StephenHodgson"
              }
            ],
            "totalCount": 11,
            "endCursor": "Y3Vyc29yOnYyOpHODys0JQ=="
          },
          "updatedAt": "2023-08-18T09:50:50Z",
          "id": "IC_kwDODI9FZc5kWqFQ"
        },
        {
          "author": "eiriktsarpalis",
          "body": "I'd be very much interested in pursuing something like this in the near future. It has been actively explored in @agocke's [Serde.NET](https://github.com/serdedotnet/serde) library and we should consider it as the pattern of choice for serialization in modern .NET libraries. \r\n\r\nAs an alternative approach we might consider defining the interface in a way that better composes with the existing serialization infrastructure:\r\n```C#\r\npublic interface IJsonSerializable<TSelf> where TSelf : IJsonSerializable<TSelf>\r\n{\r\n    static abstract JsonConverter<TSelf> CreateConverter(JsonSerializerOptions options);\r\n}\r\n```\r\nor perhaps\r\n```C#\r\npublic interface IJsonSerializable<TSelf> where TSelf : IJsonSerializable<TSelf>\r\n{\r\n    static abstract JsonTypeInfo<TSelf> CreateTypeInfo(JsonSerializerOptions options);\r\n}\r\n```\r\n\r\nThe approach has a couple of obvious drawbacks:\r\n\r\n1. Static abstracts don't work in netstandard2.0/netfx. Assuming we did bring this to STJ it wouldn't be supported in those TFMs.\r\n2. The pattern lacks flexibility since interface implementations can only be provided for types that we own. The Serde.NET source generator works arounds that problem using witness types but the approach is kind of clunky from a UX perspective. Given that C# is planning to add support for [extension interfaces](https://github.com/dotnet/csharplang/discussions/5496) in the future, we should design it with that feature in mind.\r\n\r\ncc @eerhardt @DamianEdwards @Sergio0694 ",
          "createdAt": "2023-08-18T09:51:35Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-08-18T09:51:35Z",
          "id": "IC_kwDODI9FZc5kWqTC"
        },
        {
          "author": "stephentoub",
          "body": "> The pattern lacks flexibility since interface implementations can only be provided for types that we own\r\n\r\nWe already tried once having core library types implement their own serialization to/from a specific format. We should not do that again.",
          "createdAt": "2023-08-18T10:43:16Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-08-18T10:44:49Z",
                "user": "just-ero"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-08-18T11:29:51Z",
                "user": "Joe4evr"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-08-18T11:41:03Z",
                "user": "stevemonaco"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-08-18T14:51:54Z",
                "user": "jkotas"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-08-18T18:31:22Z",
                "user": "Tornhoof"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-08-19T05:33:25Z",
                "user": "Atulin"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-08-19T05:56:48Z",
                "user": "Hellevar"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-08-19T12:44:25Z",
                "user": "Sergio0694"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-08-22T08:35:10Z",
                "user": "krwq"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-09-28T14:03:34Z",
                "user": "colejohnson66"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-11-24T15:07:52Z",
                "user": "elgonzo"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-01-11T20:12:23Z",
                "user": "jeffhandley"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-02-24T15:12:36Z",
                "user": "airbreather"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-03-18T17:06:43Z",
                "user": "raulsntos"
              }
            ],
            "totalCount": 14,
            "endCursor": "Y3Vyc29yOnYyOpHOEKZr0Q=="
          },
          "updatedAt": "2023-08-18T10:44:09Z",
          "id": "IC_kwDODI9FZc5kW49p"
        },
        {
          "author": "gregsdennis",
          "body": "I also hesitate to add this, and I agree with the SRP comment.  That said, it could be argued that putting serialization attributes on properties (e.g. `[JsonProperty]`) is mixing concerns.  Would proponents of SRP argue that these attributes should be avoided?  I can't say I would.\n\n---\n\nI used this approach in Manatee.Json, and the main drawback for me was that the serializer had to instantiate the object which meant there were requirements in a class's constructor.  This wouldn't be the case here since the methods are static.  (But I didn't have that option years ago.)\n\n[Interface](https://github.com/gregsdennis/Manatee.Json/blob/master/Manatee.Json/Serialization/IJsonSerializable.cs) / [Docs](https://gregsdennis.github.io/Manatee.Json/usage/serialization.html#ijsonserializable)\n\nHaving used both approaches, I think I prefer the independent converter option.\n\n> the converter must be separately included either via JsonSerializerOptions or via attributes on the type or a JsonSerializerContext.\n\nPersonally, I don't see an advantage to using\n\n```c#\nclass MyClass : IJsonSerializable<MyClass> { ... }\n```\n\nover\n\n```c#\n[JsonConverter(typeof(MyClassConverter))]\nclass MyClass { ... }\n\nclass MyClassConverter : JsonConverter<MyClass> { ... }\n```\n\nI usually keep the class and the converter in the same file anyway, so I don't have some of the code separation problems you mention.\n\nHaving a new way to do something that already works well isn't necessarily a good thing.\n\n\n\n\n",
          "createdAt": "2023-08-18T11:04:52Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-11-24T15:09:30Z",
                "user": "elgonzo"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHODNisKQ=="
          },
          "updatedAt": "2023-08-18T11:04:52Z",
          "id": "IC_kwDODI9FZc5kW_-1"
        },
        {
          "author": "neon-sunset",
          "body": "One of the nice aspects of this interface is it would allow making types `[JsonSerializable]` and by simply marking them as `partial`, have source generator see that and emit `IJsonSerializable<T>` implementation instead. While this is not as flexible as `JsonSerializerContext` API (can have multiple contexts with different settings), it definitely would fit the default usage pattern in most scenarios.\r\n\r\nAnd, after all, we do already have `ISpanParsable<T>` and co.",
          "createdAt": "2023-08-18T12:58:38Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-08-18T21:42:37Z",
          "id": "IC_kwDODI9FZc5kXga6"
        },
        {
          "author": "eiriktsarpalis",
          "body": "> I also hesitate to add this, and I agree with the SRP comment. \r\n\r\nDo SRP concerns apply to static (abstract) APIs as much though?\r\n\r\n> Personally, I don't see an advantage to using\r\n\r\nOne that jumps to mind is type-safe composability, namely it becomes straightforward to implement IJsonSerializable for a POCO as long as all its properties also implement IJsonSerializable. In the registered converters model there's always a layer of indirection (typically looking up a `Dictionary<Type, JsonConverter>`) every time a nontrivial property needs to be serialized. \r\n\r\n> We already tried once having core library types implement their own serialization to/from a specific format. We should not do that again.\r\n\r\nIf you mean adding `IJsonSerializable`/`IXmlSerializable` implementations on the string class, then I would agree. Assuming we had a roles/extension interfaces language feature in the future though, I think it would be reasonable to keep a `IJsonSerializable<string>` implementation in the same namespace as the interface declaration.",
          "createdAt": "2023-08-18T14:40:43Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-08-18T14:40:43Z",
          "id": "IC_kwDODI9FZc5kYB-K"
        },
        {
          "author": "Sergio0694",
          "body": "Just a random thought: with the constraint that we would still have to keep the serialization logic separate anyway (since in lots of cases you'd be serializing types you don't own), I have to say that I am not entirely sure I see a clear benefit in switching from a model type with a separate `[JsonSerializable]` annotation on a `JsonSerializerContext` type, to a model type with a separate `[JsonSerializable]` annotation over an extension type for that model type. I mean it seems to me you'd still end up with two separate types and the manually added attribute in either case, right? 🤔\r\n\r\nAlso, and I guess this is the part that's also confusing me — how would the serialization code access all extension types for nested properties? I is not clear to me how would those parts connect together at runtime if the serialization code is not implemented in the actual model type itself. Is there an example/prototype somewhere, or have we double checked with folks working on the feature (Julien?) that at least in theory an approach like that would in fact work? I think having even just a rough sketch of how the various building blocks would come together there would make it easier to follow the conversation here 🙂",
          "createdAt": "2023-08-19T12:52:10Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-08-19T12:52:10Z",
          "id": "IC_kwDODI9FZc5kbhpa"
        },
        {
          "author": "gregsdennis",
          "body": "Another approach to keeping the serialization logic in the model is to define the converter as a child class of the model.\n\n```c#\n[JsonConverter(typeof(MyModel.Converter))]\nclass MyModel\n{\n    class Converter : JsonConverter<MyModel>\n    {\n        // ...\n    }\n\n    // ...\n}\n```\n\nThe main argument I used for having the interface for Manatee.Json was that the only alternative was reflection.  That argument applies to separate converters as well.\n\nPersonally, I think whether the methods are defined externally to the model or internally makes no difference to me.  I _suppose_ you can have private constructors if the model is its own converter, if that's important to you.",
          "createdAt": "2023-08-20T00:50:18Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-08-22T08:38:29Z",
                "user": "krwq"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHODEYH2w=="
          },
          "updatedAt": "2023-08-20T01:24:50Z",
          "id": "IC_kwDODI9FZc5kcTzV"
        },
        {
          "author": "krwq",
          "body": "@just-ero can you clarify what's missing in contract customization which you'd gain from this? We're generally trying so that people don't have to write their own custom converters (some info on contract customization: [link1](https://learn.microsoft.com/en-us/dotnet/standard/serialization/system-text-json/custom-contracts); [link2](https://devblogs.microsoft.com/dotnet/system-text-json-in-dotnet-7/))",
          "createdAt": "2023-08-22T08:37:31Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-08-22T08:37:59Z",
          "id": "IC_kwDODI9FZc5kmMgq"
        },
        {
          "author": "agocke",
          "body": "> We already tried once having core library types implement their own serialization to/from a specific format. We should not do that again.\r\n\r\nSorry, missed this at the time. I think the Serde example is worth considering.\r\n\r\nIn the default case, types would express how they serialize into the \"abstract\" type system, and individual formats decide how they map to a given format. So a type might say something like, \"I'm a class with name 'X' and I have two int fields and a string field, with these names\" and the format would say, \"oh, well I know how to serialize JSON, and types are represented by objects, and int and string are native types so I'll just slot them right in.\"\r\n\r\nAnd on the other side, someone else would write a backed for YAML or TOML, or even EventSource, and they would each have their own encoding for \"two ints and a string field\", but you wouldn't need to go and mess with the original type serialize implementation for each format.\r\n\r\nAnd lastly, this would be just the default. Every field/property can have the equivalent of a \"type converter\" attribute which says, actually, use this type over here that implements the Serialize interface in a different way. And then you can change out the structure however you want. But you _still_ get to plug in any backend format you want.\r\n\r\nThe fundamental design is a separation between describing your type, and writing/reading a data format.",
          "createdAt": "2023-10-19T19:08:38Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-10-19T19:10:18Z",
                "user": "eiriktsarpalis"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-10-24T00:32:32Z",
                "user": "ufcpp"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-01-09T23:34:46Z",
                "user": "baronfel"
              }
            ],
            "totalCount": 3,
            "endCursor": "Y3Vyc29yOnYyOpHODR0i1Q=="
          },
          "updatedAt": "2023-10-19T19:09:29Z",
          "id": "IC_kwDODI9FZc5pl9pa"
        },
        {
          "author": "eiriktsarpalis",
          "body": "@agocke in a way this sounds a lot like reflection. Do we need a library to do this or should we have the compiler or runtime give us that metadata?",
          "createdAt": "2023-10-19T19:17:23Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-10-19T19:17:23Z",
          "id": "IC_kwDODI9FZc5pmAVN"
        },
        {
          "author": "jkotas",
          "body": "[Serde.NET](https://github.com/serdedotnet/serde) depends on annotating types with `[GenerateSerialize]` and `[GenerateDeserialize]` attributes.\r\n\r\nThe hard part is deciding whether the type should be annotated as serializable. For example: I am building a library that has nothing to do with serialization. I know that some users of my library will want to serialize/deserialize some (unknown) subset of types from my library. What should I do?",
          "createdAt": "2023-10-19T20:39:35Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-10-19T20:39:55Z",
          "id": "IC_kwDODI9FZc5pmZkZ"
        },
        {
          "author": "eiriktsarpalis",
          "body": "I believe Serde.NET makes it possible to generate interface implementations for third-party types using witness types, there's some info on that [here](https://serdedotnet.github.io/wrappers.html). Longer term though, I would expect this problem should be solved using roles/extension interface implementations.\r\n\r\ncc @MadsTorgersen ",
          "createdAt": "2023-10-20T10:38:38Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-10-20T10:38:38Z",
          "id": "IC_kwDODI9FZc5ppkBA"
        },
        {
          "author": "agocke",
          "body": "I do think the extension-implementation may mostly solve this problem.\r\n\r\nBut, I do think that it's important to have `Serialize` and `Deserialize` interfaces, even if they're implemented by some automatic system like reflection or source generation. In the case that you want to use the defaults, reflection is fine. But as soon as you want to customize your serialization things become complicated. Maybe you want to just change casing -- we add a switch for that. Maybe you want to rename some fields -- OK, we add attributes for that. And maybe you want to keep some fields and ignore others -- we add attributes for that. And when someone wants to ignore a field based on some runtime info... well that gets even harder.\r\n\r\nBy having the serialization/deserialization driven by interfaces, interface implementation becomes the ultimate escape hatch. You can make your serialization as simple or as complicated as you want by implementing the interfaces yourself.\r\n\r\nLastly, I'll cite Swift as a language that simply provides this functionality out of the box. Every type implements Codable if its public members implement Codable, and Codable is implemented for all primitive types. I think this could be viable for C# as well if we either use reflection, or make the unused data trimmable, or both.",
          "createdAt": "2023-10-23T23:23:02Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-10-24T13:15:29Z",
                "user": "eiriktsarpalis"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHODKxHbA=="
          },
          "updatedAt": "2023-10-23T23:23:02Z",
          "id": "IC_kwDODI9FZc5p3lr1"
        },
        {
          "author": "gregsdennis",
          "body": "> Every type implements Codable if its public members implement Codable\n\nThis is getting into duck and structural typing, which is something that .Net has steered clear of over its history.  I believe other systems like Go do this, though.",
          "createdAt": "2023-10-24T00:19:02Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-10-24T00:19:02Z",
          "id": "IC_kwDODI9FZc5p34np"
        },
        {
          "author": "eiriktsarpalis",
          "body": "> which is something that .Net has steered clear of over its history.\r\n\r\nGuessing this was mostly a matter of capability rather than principle though? Static abstract members are a recent addition that do enable such a paradigm, and we've already started rolling out abstractions such as generic math or `IParsable<T>`.",
          "createdAt": "2023-10-24T13:26:25Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-10-24T13:26:25Z",
          "id": "IC_kwDODI9FZc5p7fY1"
        },
        {
          "author": "eiriktsarpalis",
          "body": "cc @tannergooding who might be interested in this conversation.",
          "createdAt": "2023-10-24T13:26:41Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-10-24T13:26:41Z",
          "id": "IC_kwDODI9FZc5p7ff9"
        },
        {
          "author": "eiriktsarpalis",
          "body": "As a proof of concept, here's how one might easily implement an `IJsonSerializable<T>` abstraction on top of the existing APIs:\r\n\r\n```C#\r\npublic interface IJsonSerializable<T> where T : IJsonSerializable<T>\r\n{\r\n    static abstract JsonTypeInfo<T> GetTypeInfo();\r\n}\r\n\r\npublic static class JsonSerializerExt\r\n{\r\n    public static string Serialize<T>(T value) where T : IJsonSerializable<T>\r\n        => JsonSerializer.Serialize(value, T.GetTypeInfo());\r\n\r\n    public static T? Deserialize<T>(string json) where T : IJsonSerializable<T>\r\n        => JsonSerializer.Deserialize(json, T.GetTypeInfo());\r\n}\r\n```\r\nWhich with minimal boilerplate can be consumed as follows:\r\n```C#\r\nvar value = new MyPoco(1, 2);\r\nstring json = JsonSerializerExt.Serialize(value);\r\nConsole.WriteLine(json);\r\nvar deserialized = JsonSerializerExt.Deserialize<MyPoco>(json);\r\nConsole.WriteLine(value == deserialized);\r\n\r\npublic partial record MyPoco(int x, int y) : IJsonSerializable<MyPoco>\r\n{\r\n    static JsonTypeInfo<MyPoco> IJsonSerializable<MyPoco>.GetTypeInfo()\r\n        => MyContext.Default.MyPoco;\r\n}\r\n\r\n[JsonSerializable(typeof(MyPoco))]\r\npublic partial class MyContext : JsonSerializerContext;\r\n```\r\nAssuming such an interface was added in STJ proper, you could have the interface implementation generated by the source generator instead:\r\n```C#\r\nJsonSerializer.Serialize(new MyPoco(1, 2)); // Look ma, no additional parameters\r\n\r\n[GenerateIJsonSerializable]\r\npublic partial record MyPoco(int x, int y);\r\n```\r\nIt should even be possible to exploit interceptors so that any parameterless `JsonSerializer.Serialize` calls (which today fall back to reflection) get replaced with `IJsonSerializable` implementations (either on the type itself if in the same project or via a witness type if not).",
          "createdAt": "2023-12-12T13:46:46Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-12-12T13:46:46Z",
          "id": "IC_kwDODI9FZc5uZFjs"
        },
        {
          "author": "Sergio0694",
          "body": "This is kinda similar to the infrastructure I'm using in ComputeSharp. A couple of thoughts reading that proposed API surface:\r\n- I wonder if it would be possible to avoid having require the type to be `partial` at all, if instead the attribute caused the generator to emit an implicit extension type for that annotated type, implementing `IJsonSerializable<T>`, in the same namespace. I guess the two would kinda be equivalent then, perhaps with the latter being slightly easier to use?\r\n- Do you imagine the generator would be able to do some grouping across all annotated types, to generate the same synthesized JSON context per compilation? That should allow it to reuse generated type info for the same types across different annotated models, right? 🤔",
          "createdAt": "2023-12-12T14:52:22Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-12-12T14:52:22Z",
          "id": "IC_kwDODI9FZc5uZjBb"
        },
        {
          "author": "eiriktsarpalis",
          "body": "> if instead the attribute caused the generator to emit an implicit extension type for that annotated type\r\n\r\nIf and when the language gets support for extension interface implementations that is pretty much the plan :-)\r\n\r\n> Do you imagine the generator would be able to do some grouping across all annotated types, to generate the same synthesized JSON context per compilation? \r\n\r\nYes, there would be one implicitly declared context per project.",
          "createdAt": "2023-12-12T15:02:04Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "HEART",
                "createdAt": "2023-12-12T15:10:32Z",
                "user": "Sergio0694"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHODPUZDQ=="
          },
          "updatedAt": "2023-12-12T15:02:04Z",
          "id": "IC_kwDODI9FZc5uZn2j"
        },
        {
          "author": "jevansaks",
          "body": "In the `IJsonSerializable<T>` proposal, how do we reconcile that TypeInfos aren't static? Today a TypeInfo has a pointer back to a JsonSerializerOptions with a specific configuration. Would this proposal also attempt to disentangle these two things? (It's confusing that they're bound up together today, I wish a JsonTypeInfo just expressed the link between a type and its JsonConverter and options were passed around separately).",
          "createdAt": "2024-01-31T07:45:35Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-01-31T10:24:13Z",
                "user": "gregsdennis"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHODUza9A=="
          },
          "updatedAt": "2024-01-31T07:45:35Z",
          "id": "IC_kwDODI9FZc5yWuG6"
        },
        {
          "author": "eiriktsarpalis",
          "body": "> In the IJsonSerializable<T> proposal, how do we reconcile that TypeInfos aren't static?\r\n\r\nI presume you mean the variant described in https://github.com/dotnet/runtime/issues/90787#issuecomment-1852070124. It does not, it really just sketches an adapter between `JsonSerializerContext.Default` and an interface with static abstracts. As such, you're stuck with whatever configuration has been specified at compile time. We could conceivably amend this interface to accept a `JsonSerializerOptions` parameter like so:\r\n```C#\r\npublic interface IJsonSerializable<T> where T : IJsonSerializable<T>\r\n{\r\n    static abstract JsonTypeInfo<T> GetTypeInfo(JsonSerializerOption options);\r\n}\r\n```\r\nbut that creates additional challenges around caching the created JsonTypeInfo's.",
          "createdAt": "2024-01-31T12:32:16Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-01-31T12:32:16Z",
          "id": "IC_kwDODI9FZc5yYeE_"
        },
        {
          "author": "alc-aardvark",
          "body": "Should this be a static analysis and trimming problem. You could think of it something like generating a serializer for every class then trimming out the unused ones.\n\nIt would obviously need to be a bit smarter than this. \n\nBut then no additional code for nativeAOT serialization and deserialization ",
          "createdAt": "2025-03-18T10:10:38Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-03-18T10:11:18Z",
          "id": "IC_kwDODI9FZc6i3wxv"
        }
      ],
      "totalCount": 26,
      "endCursor": "Y3Vyc29yOnYyOpHOot8Mbw=="
    },
    "url": "https://github.com/dotnet/runtime/issues/90787",
    "title": "[API Proposal]: `IJsonSerializable<TSelf>`"
  },
  {
    "author": "michaelstonis",
    "labels": [
      "api-suggestion",
      "area-System.Text.Json"
    ],
    "createdAt": "2023-08-25T20:23:34Z",
    "body": "### Description\r\n\r\nWhen using a `DateTimeOffset` or `DateTime` and calling `ToString(\"O\")` will result in a date time string with seven (7) significant digits in the seconds fraction.\r\n\r\nThe [documentation for System.TextJson](https://github.com/dotnet/runtime/blob/main/src/libraries/System.Text.Json/src/System/Text/Json/Writer/Utf8JsonWriter.WriteProperties.DateTimeOffset.cs#L21C17-L21C17) states that it uses the same \"O\" format and the example shown also has seven significant digits shown. However, only six (6) digits are in the serialized JSON.\r\n\r\n### Reproduction Steps\r\n\r\nSimple console application.\r\n\r\n```\r\nusing System.Text.Json;\r\n\r\nvar nowDto = DateTimeOffset.Now;\r\nvar nowDt = DateTime.Now;\r\n\r\nvar roundtripNowDtoFromToString = nowDto.ToString(\"O\");\r\nvar roundtripNowDtoFromSystemTextJson = JsonSerializer.Serialize(nowDto).Replace(\"\\\"\", string.Empty);\r\n\r\nvar roundtripNowDtFromToString = nowDt.ToString(\"O\");\r\nvar roundtripNowDtFromSystemTextJson = JsonSerializer.Serialize(nowDt).Replace(\"\\\"\", string.Empty);\r\n\r\nConsole.WriteLine($\"DateTimeOffset - ToString: {roundtripNowDtoFromToString}\");\r\nConsole.WriteLine($\"DateTimeOffset - Json:     {roundtripNowDtoFromSystemTextJson}\");\r\n\r\nConsole.WriteLine($\"DateTime       - ToString: {roundtripNowDtFromToString}\");\r\nConsole.WriteLine($\"DateTime       - Json:     {roundtripNowDtFromSystemTextJson}\");\r\n```\r\n\r\n\r\n\r\nThis results in the following output:\r\n\r\n```\r\nDateTimeOffset - ToString: 2023-08-25T15:03:07.4735810-05:00\r\nDateTimeOffset - Json:     2023-08-25T15:03:07.473581-05:00\r\nDateTime       - ToString: 2023-08-25T15:03:07.5330680-05:00\r\nDateTime       - Json:     2023-08-25T15:03:07.533068-05:00\r\n```\r\n\r\n### Expected behavior\r\n\r\nWhen serializing a DateTimeOffset or DateTime the seconds fraction will have 7 decimal places.\r\n\r\n### Actual behavior\r\n\r\nWhen serializing a DateTimeOffset or DateTime the seconds fraction has 6 decimal places.\r\n\r\n### Regression?\r\n\r\n_No response_\r\n\r\n### Known Workarounds\r\n\r\nIf you specify the format specifically using `yyyy'-'MM'-'dd'T'HH':'mm':'ss.FFFFFFFK` it will be consistent.\r\n\r\n### Configuration\r\n\r\n- .NET 7\r\n- macOS 13.5\r\n\r\n### Other information\r\n\r\nIt appears that NewtonsoftJson has a similar formatting issue.\r\n\r\nhttps://github.com/JamesNK/Newtonsoft.Json/issues/2780",
    "number": 91134,
    "reactions": {
      "hasNextPage": false,
      "nodes": [],
      "totalCount": 0,
      "endCursor": null
    },
    "updatedAt": "2024-12-13T09:11:04Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\n### Description\n\nWhen using a `DateTimeOffset` or `DateTime` and calling `ToString(\"O\")` will result in a date time string with seven (7) significant digits in the seconds fraction.\r\n\r\nThe [documentation for System.TextJson](https://github.com/dotnet/runtime/blob/main/src/libraries/System.Text.Json/src/System/Text/Json/Writer/Utf8JsonWriter.WriteProperties.DateTimeOffset.cs#L21C17-L21C17) states that it uses the same \"O\" format and the example shown also has seven significant digits shown.\n\n### Reproduction Steps\n\nSimple console application.\r\n\r\n```\r\nusing System.Text.Json;\r\n\r\nvar nowDto = DateTimeOffset.Now;\r\nvar nowDt = DateTime.Now;\r\n\r\nvar roundtripNowDtoFromToString = nowDto.ToString(\"O\");\r\nvar roundtripNowDtoFromSystemTextJson = JsonSerializer.Serialize(nowDto).Replace(\"\\\"\", string.Empty);\r\n\r\nvar roundtripNowDtFromToString = nowDt.ToString(\"O\");\r\nvar roundtripNowDtFromSystemTextJson = JsonSerializer.Serialize(nowDt).Replace(\"\\\"\", string.Empty);\r\n\r\nConsole.WriteLine($\"DateTimeOffset - ToString: {roundtripNowDtoFromToString}\");\r\nConsole.WriteLine($\"DateTimeOffset - Json:     {roundtripNowDtoFromSystemTextJson}\");\r\n\r\nConsole.WriteLine($\"DateTime       - ToString: {roundtripNowDtFromToString}\");\r\nConsole.WriteLine($\"DateTime       - Json:     {roundtripNowDtFromSystemTextJson}\");\r\n```\r\n\r\n\r\n\r\nThis results in the following output:\r\n\r\n```\r\nDateTimeOffset - ToString: 2023-08-25T15:03:07.4735810-05:00\r\nDateTimeOffset - Json:     2023-08-25T15:03:07.473581-05:00\r\nDateTime       - ToString: 2023-08-25T15:03:07.5330680-05:00\r\nDateTime       - Json:     2023-08-25T15:03:07.533068-05:00\r\n```\n\n### Expected behavior\n\nWhen serializing a DateTimeOffset or DateTime the seconds fraction will have 7 decimal places.\n\n### Actual behavior\n\nWhen serializing a DateTimeOffset or DateTime the seconds fraction has 6 decimal places.\n\n### Regression?\n\n_No response_\n\n### Known Workarounds\n\nIf you specify the format specifically using `yyyy'-'MM'-'dd'T'HH':'mm':'ss.FFFFFFFK` it will be consistent.\n\n### Configuration\n\n- .NET 7\r\n- macOS 13.5\n\n### Other information\n\nIt appears that NewtonsoftJson has a similar formatting issue.\r\n\r\nhttps://github.com/JamesNK/Newtonsoft.Json/issues/2780\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>michaelstonis</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`area-System.Text.Json`, `untriaged`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2023-08-25T20:23:41Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-08-25T20:23:41Z",
          "id": "IC_kwDODI9FZc5k9rU_"
        },
        {
          "author": "Clockwork-Muse",
          "body": ".... wait till you find out about the deserialize/parse behavior....",
          "createdAt": "2023-08-25T20:33:36Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "LAUGH",
                "createdAt": "2023-08-25T22:31:14Z",
                "user": "vcsjones"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHODE1aAA=="
          },
          "updatedAt": "2023-08-25T20:33:36Z",
          "id": "IC_kwDODI9FZc5k9thd"
        },
        {
          "author": "danmoseley",
          "body": "Is there an accuracy issue here, or just aesthetic ? In your example, JSON case seems to be the shortest round trippable value, while the others are padding.\n\nhttps://sharplab.io/#v2:EYLgtghglgdgNAFxAJwK7wCYgNQB8ACATAIwCwAUPgAwAE+xAdACoCmAHggwFIDOA9jADcFCvgDMdQjQDCNAN4UaSyVIXllGmos1byFAG4RkNGHwDuAEQR8aAXhoWICFkyhgWAeQBmXni04AcubC5IbGppYIdg5OLm4sDEFmIQZGNMh86BgIyFAADklWfABiGWBMfADKObAA5tERRcxVNTC1ABQARB6dAJQhYemZMNm5BeZFpXxg9KwcvALRCzCVLLkQADZQAF5rDKvrW7vtjda9DABKLHkbEADGLF0AOp2dcHTEVAwAomB5CABPfoiUJpDJZGrjSJTcotXJtBoTTgVarwjrdPoDMHDUb5QoIGGzdgIZZLfgrNZQTY7PYHKlHR6nc5XG73R6dF5vD5fX7/IEpSjEACc7QAJJ1HM5XO5vL5/DQALQ0FGtWogeTgkaQ/ElMoqtEAX0xomFYolsWlnh8fiiSuW6o0ck1uKhkzKRPm5KNwL0gpF4slcXcOkVyrhdXVTpx2qRMP1dW9IXo/vNUviIbt5IdyijELG+MJxDmJK9mN0IfLIe0SgNFANQA===",
          "createdAt": "2023-08-26T01:06:17Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-08-26T01:06:17Z",
          "id": "IC_kwDODI9FZc5k-dME"
        },
        {
          "author": "michaelstonis",
          "body": "The issue is really just around consistency.\r\n\r\nI encountered this issue when building a system that persists data to a database and compares data at rest. I noticed that when `DateTime/Offset` objects were directly stored, the value was slightly different than when they were contained in JSON serialized by System.Text.Json. This is easily fixable by either updating the format of `ToString` or adding a custom converter for the JSON serializer. Understandably, the format could be different for a serialized JSON object, but the documentation is misleading.\r\n\r\nBelow are a few thoughts on it:\r\n\r\n1. The .NET `DateTime/Offset` definition of the \"O\" formatter or the round-trip format or .NET version of ISO 8601 implementation is standardized across the platform. That means if something from .NET is serialized to that format, it can always be compared consistently without additional parsing or manipulation.\r\n2. The docs for the System.Text.Json documentation are updated to say that it uses the `yyyy'-'MM'-'dd'T'HH':'mm':'ss.FFFFFFFK` format. This removes any ambiguity about it being directly comparable to the \"O\" format used by `DateTime/Offset`.",
          "createdAt": "2023-08-26T17:02:59Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-08-26T17:02:59Z",
          "id": "IC_kwDODI9FZc5k_qjd"
        },
        {
          "author": "danmoseley",
          "body": "> if something from .NET is serialized to that format, it can always be compared consistently without additional parsing or manipulation.\n\nIn general comparing numbers as strings is not ideal. I don't see a good reason why they should use the same string representation, so long as they're accurate and roundtrippable. However it's up to JSON area owners here.",
          "createdAt": "2023-08-26T22:41:56Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-08-26T22:41:56Z",
          "id": "IC_kwDODI9FZc5lAEDS"
        },
        {
          "author": "michaelstonis",
          "body": "I agree entirely that comparing numbers as strings is in no way ideal. \r\n\r\nThe case I am trying to make is that if something states that it _does_ serialize to a known format and the documentation supports that, it should do what it says on the box or the docs should be updated.\r\n\r\nIn this case, the strings `2023-08-25T15:03:07.4735810-05:00` and `2023-08-25T15:03:07.473581-05:00` are not equal. It is an easily solvable problem in more than a few ways, but a direct comparison cannot be done without parsing.",
          "createdAt": "2023-08-26T23:36:25Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-08-26T23:36:25Z",
          "id": "IC_kwDODI9FZc5lAF7y"
        },
        {
          "author": "krwq",
          "body": "Writing seems to be handled here:\r\n\r\nhttps://github.com/dotnet/runtime/blob/main/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/Converters/Value/DateTimeConverter.cs#L17\r\nhttps://github.com/dotnet/runtime/blob/main/src/libraries/System.Text.Json/src/System/Text/Json/Writer/Utf8JsonWriter.WriteValues.DateTime.cs#L22\r\nhttps://github.com/dotnet/runtime/blob/main/src/libraries/System.Text.Json/src/System/Text/Json/Writer/Utf8JsonWriter.WriteValues.DateTime.cs#L60\r\nhttps://github.com/dotnet/runtime/blob/main/src/libraries/System.Text.Json/src/System/Text/Json/Writer/JsonWriterHelper.Date.cs#L20\r\n\r\nBasically seems like it was done intentionally here:\r\nhttps://github.com/dotnet/runtime/blob/main/src/libraries/System.Text.Json/src/System/Text/Json/Writer/JsonWriterHelper.Date.cs#L43\r\n\r\nand motivated by https://github.com/dotnet/runtime/issues/28412\r\n\r\nI have a hard time agreeing with the statement made in that issue since while mathematically there is no difference between trailing 0 and lack of it in technical world it carries information about accuracy.\r\n\r\nSo to answer why it's because apparently XmlSerializer does that and we're now consistent but we should reiterate if we actually want that or if we should provide equivalent of https://learn.microsoft.com/en-us/dotnet/api/system.xml.xmldatetimeserializationmode?view=net-7.0",
          "createdAt": "2023-08-31T08:30:47Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-08-31T08:30:47Z",
          "id": "IC_kwDODI9FZc5lXQhp"
        },
        {
          "author": "krwq",
          "body": "Marking as api-suggestion since it might end up with adding new API. Given we produce correct round-trippable value and are consistent it's Future milestone to me since I'm not sure we'll want to fix/improve this anytime soon. We'd need stronger motivation to pick this up (more upvotes etc). I'm ok with updating the docs to mention that we trim trailing zeros",
          "createdAt": "2023-08-31T08:32:02Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-08-31T13:46:49Z",
                "user": "michaelstonis"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-11-22T00:29:35Z",
                "user": "elgonzo"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-12-13T08:46:29Z",
                "user": "markusschaber"
              }
            ],
            "totalCount": 3,
            "endCursor": "Y3Vyc29yOnYyOpHOD-3aSw=="
          },
          "updatedAt": "2023-08-31T08:34:27Z",
          "id": "IC_kwDODI9FZc5lXQ8-"
        },
        {
          "author": "yufeih",
          "body": "Keeping the zeros makes the string lexicographical comparable which is an important feature of ISO date strings. With this, it is a lot easier for JavaScript to compare dates in JSON date responses without having to parse the string as `Date`.",
          "createdAt": "2024-03-10T02:18:54Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-07-15T14:05:28Z",
                "user": "michaelstonis"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-05-28T14:13:02Z",
                "user": "Doomblaster"
              }
            ],
            "totalCount": 2,
            "endCursor": "Y3Vyc29yOnYyOpHOEUH4aw=="
          },
          "updatedAt": "2024-03-10T02:18:54Z",
          "id": "IC_kwDODI9FZc52b-PT"
        },
        {
          "author": "markusschaber",
          "body": "On the other hand, I like the fact that it shortens trailing zeroes. If your data only cares about seconds, and doesn't have sub second fractions, you don't want to have \".0000000\" appended to every timestamp.\n\nDateTime doesn't even have a constructor which allows combining the components \"year\", \"month\", \"day\", \"hours\", \"minutes\" and \"seconds\" with sub-second fractions.\n\nI also don't understand the argument about accuracy. Always printing 7 trailing zeroes cannot appropriately express the accuracy of the actual source of the time stamp, and implies accuracy of 100ns, which is definitely not guaranteed for most user-entered date/time information. Usually, information about accuracy is transported as companion data, expressed as some kind of interval, like \"+/- 20ms\". ",
          "createdAt": "2024-12-13T07:56:27Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-12-13T09:11:04Z",
          "id": "IC_kwDODI9FZc6XcbZz"
        }
      ],
      "totalCount": 10,
      "endCursor": "Y3Vyc29yOnYyOpHOl3G2cw=="
    },
    "url": "https://github.com/dotnet/runtime/issues/91134",
    "title": "System.Text.Json DateTime and DateTimeOffset only write six (6) significant digits for the seconds fraction"
  },
  {
    "author": "dlyz",
    "labels": [
      "area-System.Text.Json"
    ],
    "createdAt": "2023-08-29T15:18:18Z",
    "body": "### Description\r\n\r\nWe have a custom JsonConverter (`OuterConverter` for `OuterClass`) that use another JsonConverter directly to read/write its property (in our case of type `InnerStruct` that serializes using `InnerConverter`). The pattern is generally demonstrated in [Sample factory pattern converter](https://learn.microsoft.com/en-us/dotnet/standard/serialization/system-text-json/converters-how-to?pivots=dotnet-7-0#sample-factory-pattern-converter), but a little simplified in the repro below.\r\n\r\n```cs\r\n[JsonConverter(typeof(OuterConverter))]\r\npublic class OuterClass<T>\r\n{\r\n\tpublic T? Value { get; set; }\r\n}\r\n\r\n[JsonConverter(typeof(InnerConverter))]\r\npublic struct InnerStruct\r\n{\r\n\t// ...\r\n}\r\n\r\nJsonSerializer.Serialize<OuterClass<InnerStruct>>(/*...*/);\r\nJsonSerializer.Deserialize<OuterClass<InnerStruct>>(/*...*/);\r\n```\r\n\r\n`OuterClass` is generic and `OuterConverter` have to consider `_innerConverter.HandleNull` value before calling `_innerConverter.Read()/Write()`. `InnerConverter` does not override its `HandleNull` property, so the defaults will be used. And this default value will be `HandleNull == false`, but the framework does not use this value, it actually uses internal properties `HandleNullOnRead` and `HandleNullOnWrite`, and their values for **value types** (structs) are `true` and `false` respectively. This means that in the `OuterConverter` we think, that the `_innerConverter` can not read nulls (`_innerConverter.HandleNull == false`), but the framework and the `InnerConverter`'s author expect, that `InnerConverter` must read nulls. And currently there is no way for `OuterConverter` to know expected `HandleNullOnRead` behavior from `InnerConverter`.\r\n\r\n### Reproduction Steps\r\n\r\n**Minimal repro is under the spoiler.**\r\n\r\n<details>\r\n  <summary>Minimal repro</summary>\r\n\r\n```cs\r\nusing System;\r\nusing System.Diagnostics;\r\nusing System.Text.Json;\r\nusing System.Text.Json.Serialization;\r\nusing Xunit;\r\n\r\npublic class DefaultHandleNullTest\r\n{\r\n\tprivate class OuterConverter : JsonConverterFactory\r\n\t{\r\n\t\tpublic override JsonConverter? CreateConverter(Type typeToConvert, JsonSerializerOptions options)\r\n\t\t{\r\n\t\t\tvar innerType = typeToConvert.GetGenericArguments()[0];\r\n\t\t\tvar innerConverter = options.GetConverter(innerType);\r\n\t\t\treturn (JsonConverter)Activator.CreateInstance(\r\n\t\t\t\ttypeof(Cvt<>).MakeGenericType(innerType),\r\n\t\t\t\tinnerConverter\r\n\t\t\t)!;\r\n\t\t}\r\n\r\n\t\tpublic override bool CanConvert(Type typeToConvert)\r\n\t\t{\r\n\t\t\treturn typeToConvert.IsGenericType && typeToConvert.GetGenericTypeDefinition() == typeof(OuterClass<>);\r\n\t\t}\r\n\r\n\t\tprivate class Cvt<T> : JsonConverter<OuterClass<T>>\r\n\t\t{\r\n\t\t\tprivate readonly JsonConverter<T> _innerConverter;\r\n\r\n\t\t\tpublic Cvt(JsonConverter<T> innerConverter)\r\n\t\t\t{\r\n\t\t\t\t_innerConverter = innerConverter;\r\n\t\t\t}\r\n\r\n\t\t\tpublic override OuterClass<T>? Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)\r\n\t\t\t{\r\n\t\t\t\tif (reader.TokenType != JsonTokenType.StartObject) throw new JsonException();\r\n\t\t\t\treader.Read();\r\n\r\n\t\t\t\tif (!reader.ValueTextEquals(\"v\")) throw new JsonException();\r\n\t\t\t\treader.Read();\r\n\r\n\t\t\t\tT? value;\r\n\t\t\t\tif (reader.TokenType == JsonTokenType.Null && !_innerConverter.HandleNull)\r\n\t\t\t\t{\r\n\t\t\t\t\tif (default(T) is not null)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t// token is null, but this is a struct and inner converter can not handle that\r\n\t\t\t\t\t\t// this will throw in our test, but it shouldn't\r\n\t\t\t\t\t\tthrow new JsonException();\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tvalue = default;\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tvalue = _innerConverter.Read(ref reader, typeof(T), options);\r\n\t\t\t\t}\r\n\r\n\t\t\t\treader.Read();\r\n\r\n\t\t\t\tif (reader.TokenType != JsonTokenType.EndObject) throw new JsonException();\r\n\r\n\t\t\t\treturn new OuterClass<T> { Value = value };\r\n\t\t\t}\r\n\r\n\t\t\tpublic override void Write(Utf8JsonWriter writer, OuterClass<T> value, JsonSerializerOptions options)\r\n\t\t\t{\r\n\t\t\t\twriter.WriteStartObject();\r\n\r\n\t\t\t\twriter.WritePropertyName(\"v\");\r\n\r\n\t\t\t\tif (default(T) is null && !_innerConverter.HandleNull && value is null)\r\n\t\t\t\t{\r\n\t\t\t\t\twriter.WriteNullValue();\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\t_innerConverter.Write(writer, value.Value!, options);\r\n\t\t\t\t}\r\n\r\n\t\t\t\twriter.WriteEndObject();\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t[JsonConverter(typeof(OuterConverter))]\r\n\tpublic class OuterClass<T>\r\n\t{\r\n\t\tpublic T? Value { get; set; }\r\n\t}\r\n\r\n\r\n\tprivate class InnerConverter : JsonConverter<InnerStruct>\r\n\t{\r\n\t\t//// uncomment to pass the test\r\n\t\t// public override bool HandleNull => true;\r\n\r\n\t\tpublic override InnerStruct Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)\r\n\t\t{\r\n\t\t\tif (reader.TokenType == JsonTokenType.Null)\r\n\t\t\t{\r\n\t\t\t\treturn new InnerStruct { IsNull = true };\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tif (reader.TokenType != JsonTokenType.StartObject) throw new JsonException();\r\n\t\t\t\treader.Skip();\r\n\t\t\t\treturn default;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tpublic override void Write(Utf8JsonWriter writer, InnerStruct value, JsonSerializerOptions options)\r\n\t\t{\r\n\t\t\tif (value.IsNull)\r\n\t\t\t{\r\n\t\t\t\twriter.WriteNullValue();\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\twriter.WriteStartObject();\r\n\t\t\t\twriter.WriteEndObject();\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t[JsonConverter(typeof(InnerConverter))]\r\n\tpublic struct InnerStruct\r\n\t{\r\n\t\tpublic bool IsNull { get; init; }\r\n\t}\r\n\r\n\r\n\t[Fact]\r\n\tpublic void NestedDefaultNullHandlingStruct()\r\n\t{\r\n\t\tSDSCompare(\r\n\t\t\tnew InnerStruct { },\r\n\t\t\t@\"{}\",\r\n\t\t\t(l, r) => { Assert.False(r.IsNull); }\r\n\t\t);\r\n\t\tSDSCompare(\r\n\t\t\tnew InnerStruct { IsNull = true },\r\n\t\t\t@\"null\",\r\n\t\t\t(l, r) => { Assert.True(r.IsNull); }\r\n\t\t);\r\n\r\n\t\tSDSCompare(\r\n\t\t\tnew OuterClass<InnerStruct> { },\r\n\t\t\t@\"{\"\"v\"\":{}}\",\r\n\t\t\t(l, r) => { Assert.NotNull(r); Assert.False(r!.Value.IsNull); }\r\n\t\t);\r\n\r\n\t\t// here we receive JsonException during the deserialization from OuterConverter.Cvt<>.Read()\r\n\t\tSDSCompare(\r\n\t\t\tnew OuterClass<InnerStruct> { Value = new() { IsNull = true } },\r\n\t\t\t@\"{\"\"v\"\":null}\",\r\n\t\t\t(l, r) => { Assert.NotNull(r); Assert.True(r!.Value.IsNull); }\r\n\t\t);\r\n\t}\r\n\r\n\t// serialize-deserialize-serialize\r\n\tprivate static void SDSCompare<T>(\r\n\t\tT obj,\r\n\t\tstring expected,\r\n\t\tAction<T, T?>? sdComparer = null\r\n\t)\r\n\t{\r\n\t\tvar text = JsonSerializer.Serialize(obj);\r\n\r\n\t\tDebug.WriteLine(text);\r\n\t\tAssert.Equal(expected, text);\r\n\r\n\t\tvar obj2 = JsonSerializer.Deserialize<T>(text);\r\n\r\n\t\tsdComparer?.Invoke(obj, obj2);\r\n\r\n\t\tvar text2 = JsonSerializer.Serialize(obj2);\r\n\t\tAssert.Equal(text, text2);\r\n\t}\r\n}\r\n```\r\n\r\n</details>\r\n\r\n### Expected behavior\r\n\r\n`HandleNull == true` for value types by default, or public access to `HandleNullOnRead` and `HandleNullOnWrite`.\r\n\r\n### Actual behavior\r\n\r\n`HandleNull == false` by default for value types.\r\n\r\n### Regression?\r\n\r\n_No response_\r\n\r\n### Known Workarounds\r\n\r\n1. Use JsonSerializer.Serialize/Deserialize instead of JsonConverter.Read/Write. May impact performance. Can not be used in exotic cases when the converter should be acquired not from the current JsonSerializerOptions.\r\n2. Always override HandleNull in converter (InnerConverter in repro case). Applicable only when you own the code of the converter.\r\n\r\n### Configuration\r\n\r\nIn theory reproduces since the introduction of the HandleNull - from .NET 5. Tested on .NET 6.\r\n\r\n### Other information\r\n\r\n_No response_",
    "number": 91275,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-11-24T12:40:20Z",
          "user": "elgonzo"
        }
      ],
      "totalCount": 1,
      "endCursor": "Y3Vyc29yOnYyOpHOC0NY6w=="
    },
    "updatedAt": "2023-11-22T21:38:58Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\n### Description\n\nWe have a custom JsonConverter (`OuterConverter` for `OuterClass`) that use another JsonConverter directly to read/write its property (in our case of type `InnerStruct` that serializes using `InnerConverter`). The pattern is generally demonstrated in [Sample factory pattern converter](https://learn.microsoft.com/en-us/dotnet/standard/serialization/system-text-json/converters-how-to?pivots=dotnet-7-0#sample-factory-pattern-converter), but a little simplified in the repro below.\r\n\r\n```cs\r\n[JsonConverter(typeof(OuterConverter))]\r\npublic class OuterClass<T>\r\n{\r\n\tpublic T? Value { get; set; }\r\n}\r\n\r\n[JsonConverter(typeof(InnerConverter))]\r\npublic struct InnerStruct\r\n{\r\n\t// ...\r\n}\r\n\r\nJsonSerializer.Serialize<OuterClass<InnerStruct>>(/*...*/);\r\nJsonSerializer.Deserialize<OuterClass<InnerStruct>>(/*...*/);\r\n```\r\n\r\n`OuterClass` is generic and `OuterConverter` have to consider `_innerConverter.HandleNull` value before calling `_innerConverter.Read()/Write()`. `InnerConverter` does not override its `HandleNull` property, so the defaults will be used. And this default value will be `HandleNull == false`, but the framework does not use this value, it actually uses internal properties `HandleNullOnRead` and `HandleNullOnWrite`, and their values for **value types** (structs) are `true` and `false` respectively. This means that in the `OuterConverter` we think, that the `_innerConverter` can not read nulls (`_innerConverter.HandleNull == false`), but the framework and the `InnerConverter`'s author expect, that `InnerConverter` must read nulls. And currently there is no way for `OuterConverter` to know expected `HandleNullOnRead` behavior from `InnerConverter`.\n\n### Reproduction Steps\n\n**Minimal repro is under the spoiler.**\r\n\r\n<details>\r\n  <summary>Minimal repro</summary>\r\n\r\n```cs\r\nusing System;\r\nusing System.Diagnostics;\r\nusing System.Text.Json;\r\nusing System.Text.Json.Serialization;\r\nusing Xunit;\r\n\r\npublic class DefaultHandleNullTest\r\n{\r\n\tprivate class OuterConverter : JsonConverterFactory\r\n\t{\r\n\t\tpublic override JsonConverter? CreateConverter(Type typeToConvert, JsonSerializerOptions options)\r\n\t\t{\r\n\t\t\tvar innerType = typeToConvert.GetGenericArguments()[0];\r\n\t\t\tvar innerConverter = options.GetConverter(innerType);\r\n\t\t\treturn (JsonConverter)Activator.CreateInstance(\r\n\t\t\t\ttypeof(Cvt<>).MakeGenericType(innerType),\r\n\t\t\t\tinnerConverter\r\n\t\t\t)!;\r\n\t\t}\r\n\r\n\t\tpublic override bool CanConvert(Type typeToConvert)\r\n\t\t{\r\n\t\t\treturn typeToConvert.IsGenericType && typeToConvert.GetGenericTypeDefinition() == typeof(OuterClass<>);\r\n\t\t}\r\n\r\n\t\tprivate class Cvt<T> : JsonConverter<OuterClass<T>>\r\n\t\t{\r\n\t\t\tprivate readonly JsonConverter<T> _innerConverter;\r\n\r\n\t\t\tpublic Cvt(JsonConverter<T> innerConverter)\r\n\t\t\t{\r\n\t\t\t\t_innerConverter = innerConverter;\r\n\t\t\t}\r\n\r\n\t\t\tpublic override OuterClass<T>? Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)\r\n\t\t\t{\r\n\t\t\t\tif (reader.TokenType != JsonTokenType.StartObject) throw new JsonException();\r\n\t\t\t\treader.Read();\r\n\r\n\t\t\t\tif (!reader.ValueTextEquals(\"v\")) throw new JsonException();\r\n\t\t\t\treader.Read();\r\n\r\n\t\t\t\tT? value;\r\n\t\t\t\tif (reader.TokenType == JsonTokenType.Null && !_innerConverter.HandleNull)\r\n\t\t\t\t{\r\n\t\t\t\t\tif (default(T) is not null)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t// token is null, but this is a struct and inner converter can not handle that\r\n\t\t\t\t\t\t// this will throw in our test, but it shouldn't\r\n\t\t\t\t\t\tthrow new JsonException();\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tvalue = default;\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tvalue = _innerConverter.Read(ref reader, typeof(T), options);\r\n\t\t\t\t}\r\n\r\n\t\t\t\treader.Read();\r\n\r\n\t\t\t\tif (reader.TokenType != JsonTokenType.EndObject) throw new JsonException();\r\n\r\n\t\t\t\treturn new OuterClass<T> { Value = value };\r\n\t\t\t}\r\n\r\n\t\t\tpublic override void Write(Utf8JsonWriter writer, OuterClass<T> value, JsonSerializerOptions options)\r\n\t\t\t{\r\n\t\t\t\twriter.WriteStartObject();\r\n\r\n\t\t\t\twriter.WritePropertyName(\"v\");\r\n\r\n\t\t\t\tif (default(T) is null && !_innerConverter.HandleNull && value is null)\r\n\t\t\t\t{\r\n\t\t\t\t\twriter.WriteNullValue();\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\t_innerConverter.Write(writer, value.Value!, options);\r\n\t\t\t\t}\r\n\r\n\t\t\t\twriter.WriteEndObject();\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t[JsonConverter(typeof(OuterConverter))]\r\n\tpublic class OuterClass<T>\r\n\t{\r\n\t\tpublic T? Value { get; set; }\r\n\t}\r\n\r\n\r\n\tprivate class InnerConverter : JsonConverter<InnerStruct>\r\n\t{\r\n\t\t//// uncomment to pass the test\r\n\t\t// public override bool HandleNull => true;\r\n\r\n\t\tpublic override InnerStruct Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)\r\n\t\t{\r\n\t\t\tif (reader.TokenType == JsonTokenType.Null)\r\n\t\t\t{\r\n\t\t\t\treturn new InnerStruct { IsNull = true };\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tif (reader.TokenType != JsonTokenType.StartObject) throw new JsonException();\r\n\t\t\t\treader.Skip();\r\n\t\t\t\treturn default;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tpublic override void Write(Utf8JsonWriter writer, InnerStruct value, JsonSerializerOptions options)\r\n\t\t{\r\n\t\t\tif (value.IsNull)\r\n\t\t\t{\r\n\t\t\t\twriter.WriteNullValue();\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\twriter.WriteStartObject();\r\n\t\t\t\twriter.WriteEndObject();\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t[JsonConverter(typeof(InnerConverter))]\r\n\tpublic struct InnerStruct\r\n\t{\r\n\t\tpublic bool IsNull { get; init; }\r\n\t}\r\n\r\n\r\n\t[Fact]\r\n\tpublic void NestedDefaultNullHandlingStruct()\r\n\t{\r\n\t\tSDSCompare(\r\n\t\t\tnew InnerStruct { },\r\n\t\t\t@\"{}\",\r\n\t\t\t(l, r) => { Assert.False(r.IsNull); }\r\n\t\t);\r\n\t\tSDSCompare(\r\n\t\t\tnew InnerStruct { IsNull = true },\r\n\t\t\t@\"null\",\r\n\t\t\t(l, r) => { Assert.True(r.IsNull); }\r\n\t\t);\r\n\r\n\t\tSDSCompare(\r\n\t\t\tnew OuterClass<InnerStruct> { },\r\n\t\t\t@\"{\"\"v\"\":{}}\",\r\n\t\t\t(l, r) => { Assert.NotNull(r); Assert.False(r!.Value.IsNull); }\r\n\t\t);\r\n\r\n\t\t// here we receive JsonException during the deserialization from OuterConverter.Cvt<>.Read()\r\n\t\tSDSCompare(\r\n\t\t\tnew OuterClass<InnerStruct> { Value = new() { IsNull = true } },\r\n\t\t\t@\"{\"\"v\"\":null}\",\r\n\t\t\t(l, r) => { Assert.NotNull(r); Assert.True(r!.Value.IsNull); }\r\n\t\t);\r\n\t}\r\n\r\n\t// serialize-deserialize-serialize\r\n\tprivate static void SDSCompare<T>(\r\n\t\tT obj,\r\n\t\tstring expected,\r\n\t\tAction<T, T?>? sdComparer = null\r\n\t)\r\n\t{\r\n\t\tvar text = JsonSerializer.Serialize(obj);\r\n\r\n\t\tDebug.WriteLine(text);\r\n\t\tAssert.Equal(expected, text);\r\n\r\n\t\tvar obj2 = JsonSerializer.Deserialize<T>(text);\r\n\r\n\t\tsdComparer?.Invoke(obj, obj2);\r\n\r\n\t\tvar text2 = JsonSerializer.Serialize(obj2);\r\n\t\tAssert.Equal(text, text2);\r\n\t}\r\n}\r\n```\r\n\r\n</details>\n\n### Expected behavior\n\n`HandleNull == true` for value types, or public access to `HandleNullOnRead` and `HandleNullOnWrite`.\n\n### Actual behavior\n\n`HandleNull == false` by default for value types.\n\n### Regression?\n\n_No response_\n\n### Known Workarounds\n\n1. Use JsonSerializer.Serialize/Deserialize instead of JsonConverter.Read/Write. May impact performance. Can not be used in exotic cases when the converter should be acquired not from the current JsonSerializerOptions.\r\n2. Always override HandleNull in converter (InnerConverter in repro case). Applicable only when you own the code of the converter.\n\n### Configuration\n\nIn theory reproduces since the introduction of the HandleNull - from .NET 5. Tested on .NET 6.\n\n### Other information\n\n_No response_\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>dlyz</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`area-System.Text.Json`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2023-08-29T15:18:27Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-08-29T15:18:27Z",
          "id": "IC_kwDODI9FZc5lMBwV"
        },
        {
          "author": "layomia",
          "body": "We won't be able to change the default value as that would be a very impactful breaking change. I don't expect any PR/change to emerge from this issue but's worth taking another look, to re-assess/justify why ~~`HandleNullOnWrite` is `true`~~ different values are used in the internal converters.\r\n\r\n> Know workarounds\r\n\r\nHave you run into any concrete scenarios where these workarounds weren't sufficient?",
          "createdAt": "2023-08-29T21:02:02Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-08-30T16:57:56Z",
          "id": "IC_kwDODI9FZc5lN47q"
        },
        {
          "author": "dlyz",
          "body": "> We won't be able to change the default value as that would be a very impactful breaking change. \r\n\r\nYeah, I thought so, I've mentioned this option mostly to better explain the issue. Although at least documentation should be corrected because currently it states:\r\n\r\nhttps://github.com/dotnet/runtime/blob/7d15ceb59982add236b6254b477294a5f3eff112/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/JsonConverterOfT.cs#L69\r\n\r\nand this is correct for the framework behavior, but incorrect for actual HandleNull value.\r\n\r\n> Have you run into any concrete scenarios where these workarounds weren't sufficient?\r\n\r\nIn my specific case it was actually easier to use value of internal HandleNullOnRead property since my converters already use LINQ Expressions to build actual converter code. Totally not perfect, but it will work for the foreseeable future, and if/when it stops I probably go with JsonSerializer, it is suboptimal but sufficient.",
          "createdAt": "2023-08-30T16:25:47Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "EYES",
                "createdAt": "2023-08-30T17:02:39Z",
                "user": "layomia"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHODFSbRQ=="
          },
          "updatedAt": "2023-08-30T16:25:47Z",
          "id": "IC_kwDODI9FZc5lTC_3"
        }
      ],
      "totalCount": 3,
      "endCursor": "Y3Vyc29yOnYyOpHOZUwv9w=="
    },
    "url": "https://github.com/dotnet/runtime/issues/91275",
    "title": "Json: HandleNull property has misleading value for structs when not overridden explicitly in the converter"
  },
  {
    "author": "mariuszlip",
    "labels": [
      "api-suggestion",
      "area-System.Text.Json",
      "wishlist"
    ],
    "createdAt": "2023-09-01T16:30:27Z",
    "body": "### Background and motivation\r\n\r\nI have an application that transforms huge amounts of data on low-memory environment. The data is delivered from external service in a format that cannot be changed:\r\n```csharp\r\nclass DataFile\r\n{\r\n  public MetadataClass Metadata { get; set }\r\n  public IEnumerable<DataItem> DataList { get; set }\r\n}\r\n```\r\nDue to current constraints of System.Text.Json, the DataList is materialized immediately (as it is a nested Enumerable). After data is deserialized, it takes over 3GB of 8GB available memory, but quite often it just throws an OutOfMemory exception on (internal) List<DataItem> resize\r\n\r\nI'd like to specify an initial capacity of the deserialized Enumerable to avoid memory reallocations. My current alternatives are: (1) increase memory available (2) prepare a custom JsonConverter based on LinkedList<> (my current solution)\r\n\r\n### API Proposal\r\n\r\n// new class\r\n```csharp\r\nnamespace System.Text.Json.Serialization.Attributes;\r\n\r\npublic class JsonCollectionCapacityAttribute : JsonAttribute\r\n{\r\n    public JsonCollectionCapacityAttribute (int capacity) => Capacity = capacity\r\n\r\n    public int Capacity { get; }\r\n}\r\n```\r\n\r\n// in IEnumerableOfTConverter.cs\r\n```csharp\r\nprotected override void CreateCollection(ref Utf8JsonReader reader, scoped ref ReadStack state, JsonSerializerOptions options)\r\n{\r\n    if (!_isDeserializable)\r\n    {\r\n        ThrowHelper.ThrowNotSupportedException_CannotPopulateCollection(Type, ref reader, ref state);\r\n    }\r\n\r\n\r\n    var collectionCapacityAttribute = state.ParentProperty.AttributeProvider.GetCustomAttributes(typeof(JsonCollectionCapacityAttribute), false).FirstOrDefault();\r\n\r\n    state.Current.ReturnValue = collectionCapacityAttribute is null ? new List<TElement>() : new List<TElement>(collectionCapacityAttribute.Capacity);\r\n}\r\n```\r\n\r\n// in IAsyncEnumerableOfTConverter.cs\r\n```csharp\r\nprotected override void CreateCollection(ref Utf8JsonReader reader, scoped ref ReadStack state, JsonSerializerOptions options)\r\n{\r\n    var collectionCapacityAttribute = state.ParentProperty.AttributeProvider.GetCustomAttributes(typeof(JsonCollectionCapacityAttribute), false).FirstOrDefault();\r\n\r\n    state.Current.ReturnValue = collectionCapacityAttribute is null ? new BufferedAsyncEnumerable() : new BufferedAsyncEnumerable(collectionCapacityAttribute.Capacity);\r\n}\r\n```\r\n\r\n### API Usage\r\n\r\n```csharp\r\nclass DataFile\r\n{\r\n  public MetadataClass Metadata { get; set }\r\n\r\n  [JsonCollectionCapacity(1000000)]\r\n  public IEnumerable<DataItem> DataList { get; set }\r\n}\r\n```\r\n\r\n\r\n### Alternative Designs\r\n\r\n_No response_\r\n\r\n### Risks\r\n\r\n_No response_",
    "number": 91467,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-09-01T16:39:49Z",
          "user": "KeterSCP"
        }
      ],
      "totalCount": 1,
      "endCursor": "Y3Vyc29yOnYyOpHOCyVQeQ=="
    },
    "updatedAt": "2023-09-04T10:17:23Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\n### Background and motivation\n\nI have an application that transforms huge amounts of data on low-memory environment. The data is delivered from external service in a format that cannot be changed:\r\n```csharp\r\nclass DataFile\r\n{\r\n  public MetadataClass Metadata { get; set }\r\n  public IEnumerable<DataItem> DataList { get; set }\r\n}\r\n```\r\nDue to current constraints of System.Text.Json, the DataList is materialized immediately (as it is a nested Enumerable). After data is deserialized, it takes over 3GB of 8GB available memory, but quite often it just throws an OutOfMemory exception on (internal) List<DataItem> resize\r\n\r\nI'd like to specify an initial capacity of the deserialized Enumerable to avoid memory reallocations. My current alternatives are: (1) increase memory available (2) prepare a custom JsonConverter based on LinkedList<> (my current solution)\n\n### API Proposal\n\n// new class\r\n```csharp\r\nnamespace System.Text.Json.Serialization.Attributes;\r\n\r\npublic class JsonCollectionCapacityAttribute : JsonAttribute\r\n{\r\n    public JsonCollectionCapacityAttribute (int capacity) => Capacity = capacity\r\n\r\n    public int Capacity { get; }\r\n}\r\n```\r\n\r\n// in IEnumerableOfTConverter.cs\r\n```csharp\r\nprotected override void CreateCollection(ref Utf8JsonReader reader, scoped ref ReadStack state, JsonSerializerOptions options)\r\n{\r\n    if (!_isDeserializable)\r\n    {\r\n        ThrowHelper.ThrowNotSupportedException_CannotPopulateCollection(Type, ref reader, ref state);\r\n    }\r\n\r\n\r\n    var collectionCapacityAttribute = state.ParentProperty.AttributeProvider.GetCustomAttributes(typeof(JsonCollectionCapacityAttribute), false).FirstOrDefault();\r\n\r\n    state.Current.ReturnValue = collectionCapacityAttribute is null ? new List<TElement>() : List<TElement>(collectionCapacityAttribute.Capacity);\r\n}\r\n```\r\n\r\n// in IAsyncEnumerableOfTConverter.cs\r\n```csharp\r\nprotected override void CreateCollection(ref Utf8JsonReader reader, scoped ref ReadStack state, JsonSerializerOptions options)\r\n{\r\n    var collectionCapacityAttribute = state.ParentProperty.AttributeProvider.GetCustomAttributes(typeof(JsonCollectionCapacityAttribute), false).FirstOrDefault();\r\n\r\n            state.Current.ReturnValue = new BufferedAsyncEnumerable();\r\n    state.Current.ReturnValue = collectionCapacityAttribute is null ? new BufferedAsyncEnumerable() : BufferedAsyncEnumerable(collectionCapacityAttribute.Capacity);\r\n}\r\n```\n\n### API Usage\n\n```csharp\r\nclass DataFile\r\n{\r\n  public MetadataClass Metadata { get; set }\r\n\r\n  [JsonCollectionCapacity(1000000)]\r\n  public IEnumerable<DataItem> DataList { get; set }\r\n}\r\n```\r\n\n\n### Alternative Designs\n\n_No response_\n\n### Risks\n\n_No response_\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>mariuszlip</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`api-suggestion`, `area-System.Text.Json`, `untriaged`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2023-09-01T16:30:39Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-09-01T16:30:39Z",
          "id": "IC_kwDODI9FZc5lgfXq"
        },
        {
          "author": "huoyaoyuan",
          "body": "I wonder if a custom collection serves better for such scenario. You can make a linked list of chunks to totally avoid resize operations. The size wasting will also be limited to one chunk, while List<T> can waste almost half of capacity since it doubles it size.",
          "createdAt": "2023-09-01T18:00:03Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-09-04T10:10:40Z",
                "user": "eiriktsarpalis"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-09-13T07:16:31Z",
                "user": "mariuszlip"
              }
            ],
            "totalCount": 2,
            "endCursor": "Y3Vyc29yOnYyOpHODGoUxg=="
          },
          "updatedAt": "2023-09-01T18:00:03Z",
          "id": "IC_kwDODI9FZc5lg9TN"
        },
        {
          "author": "eiriktsarpalis",
          "body": "One possible workaround is to use contract customization to modify the constructor delegate:\r\n\r\n```C#\r\nvar options = new JsonSerializerOptions\r\n{\r\n    TypeInfoResolver = new DefaultJsonTypeInfoResolver\r\n    {\r\n        Modifiers =\r\n        {\r\n            static typeInfo =>\r\n            {\r\n                if (typeInfo.Type == typeof(List<int>))\r\n                {\r\n                    typeInfo.CreateObject = () => new List<int>(1000000);\r\n                }\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\nvar result = JsonSerializer.Deserialize<List<int>>(\"[1]\", options);\r\nConsole.WriteLine($\"{result.Count} {result.Capacity}\"); // 1 1000000\r\n```",
          "createdAt": "2023-09-04T10:17:23Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-09-04T10:17:23Z",
          "id": "IC_kwDODI9FZc5loDnB"
        }
      ],
      "totalCount": 3,
      "endCursor": "Y3Vyc29yOnYyOpHOZaA5wQ=="
    },
    "url": "https://github.com/dotnet/runtime/issues/91467",
    "title": "[API Proposal]: Initial capacity attribute for IEnumerable deserialization"
  },
  {
    "author": "DUXINYI",
    "labels": [
      "api-suggestion",
      "area-System.Text.Json"
    ],
    "createdAt": "2023-09-02T10:59:21Z",
    "body": "### Background and motivation\n\nCompare Reflection mode and Metadata mode, it should be great to use Metadata mode by default, as developer customize nothing for any Type and just use Serialize and Deserialize Funtion simply.\r\n\r\n![image](https://github.com/dotnet/runtime/assets/24663277/10fe2923-3b64-4ed4-9b80-d32bf3c9354e)\r\n\r\n\r\nI think it is possible to scan project and infer all simple call entry (not Converter implemented, not unsupported feature used), and generate a \"Default\" JsonSerializerContext for them.\r\nSo that benefits more performance advantages, and development friendly.\n\n### API Proposal\n\n```csharp\r\n// there are not any behavior differences between Reflection and Metadata mode\r\nvar myEntity = JsonSerializer.Deserialize<Entity>(json);\r\n```\r\n\r\nEquals to use \r\n```csarp\r\n[JsonSerializable(typeof(Entity))]\r\ninternal partial class MyJsonContext : JsonSerializerContext\r\n{\r\n}\r\nvar myEntity = JsonSerializer.Deserialize<Entity>(json, MyJsonContext.Default.Entity);\r\n```\n\n### API Usage\n\n```csharp\r\n\r\n```\r\n\n\n### Alternative Designs\n\nUse an attribute to disable this feature and turn back to Reflection mode as previous versions.\r\n```csarp\r\n[ReflectionMode]\r\nclass Entity{\r\n}\r\n```\n\n### Risks\n\nchanging the behavior of existing code",
    "number": 91495,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "EYES",
          "createdAt": "2023-09-02T11:02:18Z",
          "user": "gehongyan"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-11-17T21:14:36Z",
          "user": "Jure-BB"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-07-29T09:38:32Z",
          "user": "bugproof"
        }
      ],
      "totalCount": 3,
      "endCursor": "Y3Vyc29yOnYyOpHOC5xGPw=="
    },
    "updatedAt": "2023-09-06T09:35:22Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\n### Background and motivation\n\nCompare Reflection mode and Metadata mode, it should be great to use Metadata mode by default, as developer customize nothing for any Type and just use Serialize and Deserialize Funtion simply.\r\n\r\n![image](https://github.com/dotnet/runtime/assets/24663277/10fe2923-3b64-4ed4-9b80-d32bf3c9354e)\r\n\r\n\r\nI think it is possible to scan project and infer all simple call entry (not Converter implemented, not unsupported feature used), and generate a \"Default\" JsonSerializerContext for them.\r\nSo that benefits more performance advantages, and development friendly.\n\n### API Proposal\n\n```csharp\r\n// there are not any behavior differences between Reflection and Metadata mode\r\nvar myEntity = JsonSerializer.Deserialize<Entity>(json);\r\n```\r\n\r\nEquals to use \r\n```csarp\r\n[JsonSerializable(typeof(Entity))]\r\ninternal partial class MyJsonContext : JsonSerializerContext\r\n{\r\n}\r\nvar myEntity = JsonSerializer.Deserialize<Entity>(json, MyJsonContext.Default.Entity);\r\n```\n\n### API Usage\n\n```csharp\r\n\r\n```\r\n\n\n### Alternative Designs\n\nUse an attribute to disable this feature and turn back to Reflection mode as previous versions.\r\n```csarp\r\n[ReflectionMode]\r\nclass Entity{\r\n}\r\n```\n\n### Risks\n\nchanging the behavior of existing code\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>DUXINYI</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`api-suggestion`, `area-System.Text.Json`, `untriaged`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2023-09-02T10:59:29Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-09-02T10:59:29Z",
          "id": "IC_kwDODI9FZc5ljfN7"
        },
        {
          "author": "eiriktsarpalis",
          "body": "That should be possible to implement in the future using the new C# interceptors feature. It should make entry-level use of the source generator simpler, but it would still be more challenging when it comes to configurability. \r\n\r\ncc @layomia @eerhardt @captainsafia for thoughts.",
          "createdAt": "2023-09-04T09:57:45Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-09-04T09:58:05Z",
          "id": "IC_kwDODI9FZc5ln8rZ"
        },
        {
          "author": "layomia",
          "body": "Unless it would unblock many projects from switching to the generator, I don't think we should pursue this.",
          "createdAt": "2023-09-04T17:26:34Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-09-04T17:26:34Z",
          "id": "IC_kwDODI9FZc5lqNFY"
        },
        {
          "author": "captainsafia",
          "body": "> but it would still be more challenging when it comes to configurability.\r\n\r\nCan you clarify what the configurability challenges would be? Do you think users would still have to configure the `JsonSerializerContext` themselves?",
          "createdAt": "2023-09-05T14:52:43Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-09-05T14:52:43Z",
          "id": "IC_kwDODI9FZc5lu1Fg"
        },
        {
          "author": "eiriktsarpalis",
          "body": "There wouldn't be an explicitly declared `JsonSerializerContext`, presumably a interceptor approach would generate an ad-hoc one behind the scenes but it wouldn't be user-configurable at all. ",
          "createdAt": "2023-09-05T15:11:17Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-09-05T15:11:17Z",
          "id": "IC_kwDODI9FZc5lu9jJ"
        },
        {
          "author": "captainsafia",
          "body": "> There wouldn't be an explicitly declared `JsonSerializerContext`, presumably a interceptor approach would generate an ad-hoc one behind the scenes but it wouldn't be user-configurable at all.\r\n\r\nOK, this is what I had assumed. TBH, I'd be intrigued to investigate this idea. It would make the experience for integrating STJ into existing APIs a lot smoother.\r\n\r\nA while back, we had considered an analyzer-driven approach to smoothing out the experience for enabling the STJ generator for minimal APIs.\r\n\r\nThe idea would be that we would provide an analyzer/codefix pairing that would annotate the `JsonSerializerContext` appropriately based on the types discovered in a users app.\r\n\r\nUsing interceptors might be a better alternative for solving the same problem.",
          "createdAt": "2023-09-05T21:12:15Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-09-05T21:12:15Z",
          "id": "IC_kwDODI9FZc5lw5We"
        },
        {
          "author": "eiriktsarpalis",
          "body": "One concern I have with using interceptors here is that it wouldn't compose particularly well with the current model aspnet uses to configure serialization (users don't call `JsonSerializer` methods directly and instead need to configure a `JsonSerializerOptions` object indirectly).\r\n\r\nOne potential alternative is [this proposal](https://github.com/dotnet/runtime/issues/90787). Assuming we had a source generator creating `IJsonSerializable<TSelf>` implementations for POCOs, then JSON serialization in aspnet would be as simple as having users returning a `JsonResult<T> where T : IJsonSerializable<T>` value in their endpoints.",
          "createdAt": "2023-09-06T09:35:21Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-09-06T09:35:21Z",
          "id": "IC_kwDODI9FZc5lzhH0"
        }
      ],
      "totalCount": 7,
      "endCursor": "Y3Vyc29yOnYyOpHOZc4R9A=="
    },
    "url": "https://github.com/dotnet/runtime/issues/91495",
    "title": "Consider using interceptors in the STJ source generator"
  },
  {
    "author": "StasJS",
    "labels": [
      "enhancement",
      "area-System.Text.Json"
    ],
    "createdAt": "2023-09-11T10:54:11Z",
    "body": "### Description\r\n\r\nReading through https://learn.microsoft.com/en-us/dotnet/standard/serialization/system-text-json/supported-collection-types `JsonSerializer.Deserialize` will support deserialization to a ton of different collection interfaces.\r\n\r\nStrangely, `IReadOnlySet` is not mentioned at all in the page I linked. Not even to say it's not supported, as some collection types have e.g. `LinkedListNode<T>`.\r\n\r\nWhen trying to deserialize to an `IReadOnlySet`, `JsonSerializer` throws a `NotSupportedException`\r\n\r\n### Reproduction Steps\r\n\r\n- Run `dotnet new console`\r\n- Write `Program.cs`\r\n```c#\r\nusing System.Collections.Immutable;\r\nusing System.Text.Json;\r\n\r\n// Both of these work as expected\r\nvar setResult = JsonSerializer.Deserialize<ISet<int>>(\"[1]\");\r\nvar immutableSetResult = JsonSerializer.Deserialize<IImmutableSet<int>>(\"[1]\");\r\n\r\n// throws NotSupportedException\r\nJsonSerializer.Deserialize<IReadOnlySet<int>>(\"[1]\");\r\n```\r\n\r\n### Expected behavior\r\n\r\n`JsonSerializer.Deserialize<IReadOnlySet<int>>(\"[1]\");` ought to work, like it does for `ISet` or other readonly collections e.g. `IReadOnlyList`.\r\n\r\nI would also expect `IReadOnlySet` to be featured in this page https://learn.microsoft.com/en-us/dotnet/standard/serialization/system-text-json/supported-collection-types one way or another.\r\n\r\n### Actual behavior\r\n\r\n`JsonSerializer.Deserialize<IReadOnlySet<int>>(\"[1]\");` throws `NotSupportedException` and completely absent from https://learn.microsoft.com/en-us/dotnet/standard/serialization/system-text-json/supported-collection-types \r\n\r\n### Regression?\r\n\r\nDon't know.\r\n\r\n### Known Workarounds\r\n\r\nUse `ISet` or similar.\r\n\r\n### Configuration\r\n\r\n```\r\n> dotnet sdk check\r\nVersion      Status\r\n------------------------\r\n7.0.400      Up to date.\r\n\r\nMicrosoft.NETCore.App             7.0.10       Up to date.\r\nMicrosoft.WindowsDesktop.App      7.0.10       Up to date.\r\n```\r\nWindows 11 Pro x64\r\n```\r\n> [System.Environment]::OSVersion\r\nPlatform ServicePack Version      VersionString\r\n-------- ----------- -------      -------------\r\n Win32NT             10.0.22623.0 Microsoft Windows NT 10.0.22623.0\r\n```\r\n\r\n\r\n### Other information\r\n\r\n_No response_",
    "number": 91875,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-10-10T13:37:27Z",
          "user": "swimmesberger"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-12-12T10:51:50Z",
          "user": "alexander-jesner-AP"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-01-15T14:54:41Z",
          "user": "KrzysztofBranicki"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-01-15T14:59:05Z",
          "user": "plachor"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-01-15T15:00:08Z",
          "user": "grsw92"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-01-16T08:15:16Z",
          "user": "marekott"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-04-08T16:24:02Z",
          "user": "joeldinis"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-06-07T18:40:44Z",
          "user": "Mitchman215"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-06-14T20:31:41Z",
          "user": "AbakumovAlexandr"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-07-02T21:14:46Z",
          "user": "RobARichardson"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-08-19T07:44:13Z",
          "user": "fredericDelaporte"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-09-16T18:44:46Z",
          "user": "jolexxa"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-09-26T06:02:28Z",
          "user": "meinsiedler"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-10-01T18:12:14Z",
          "user": "chaimtevel"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-10-16T02:57:04Z",
          "user": "issue-dispenser"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-11-21T08:54:52Z",
          "user": "sveinungf"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-12-11T20:51:53Z",
          "user": "Trivivium"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-12-31T18:37:30Z",
          "user": "YoelDruxman"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-01-01T16:16:11Z",
          "user": "tabberbock"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-01-01T16:16:55Z",
          "user": "nrhoffmann"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-01-01T16:58:50Z",
          "user": "davidmenaged"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-02-09T21:57:51Z",
          "user": "Chillu1"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-04-29T19:29:18Z",
          "user": "ohmios"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-05-14T17:40:56Z",
          "user": "elgonzo"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-06-12T09:47:27Z",
          "user": "MartyIX"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-08-01T05:16:01Z",
          "user": "dgioulakis"
        }
      ],
      "totalCount": 26,
      "endCursor": "Y3Vyc29yOnYyOpHODJdi_w=="
    },
    "updatedAt": "2025-07-16T05:56:38Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\n### Description\n\nReading through https://learn.microsoft.com/en-us/dotnet/standard/serialization/system-text-json/supported-collection-types `JsonSerializer.Deserialize` will support deserialization to a ton of different collection interfaces.\r\n\r\nStrangely, `IReadOnlySet` is not mentioned at all in the page I linked. Not even to say it's not supported, as some collection types have e.g. `LinkedListNode<T>`.\r\n\r\nWhen trying to deserialize to an `IReadOnlySet`, `JsonSerializer` throws a `NotSupportedException`\n\n### Reproduction Steps\n\n- Run `dotnet new console`\r\n- Write `Program.cs`\r\n```\r\nusing System.Collections.Immutable;\r\nusing System.Text.Json;\r\n\r\n// Both of these work as expected\r\nvar setResult = JsonSerializer.Deserialize<ISet<int>>(\"[1]\");\r\nvar immutableSetResult = JsonSerializer.Deserialize<IImmutableSet<int>>(\"[1]\");\r\n\r\n// throws NotSupportedException\r\nJsonSerializer.Deserialize<IReadOnlySet<int>>(\"[1]\");\r\n```\n\n### Expected behavior\n\n`JsonSerializer.Deserialize<IReadOnlySet<int>>(\"[1]\");` ought to work, like it does for `ISet` or other readonly collections e.g. `IReadOnlyList`.\r\n\r\nI would also expect `IReadOnlySet` to be featured in this page https://learn.microsoft.com/en-us/dotnet/standard/serialization/system-text-json/supported-collection-types one way or another.\n\n### Actual behavior\n\n`JsonSerializer.Deserialize<IReadOnlySet<int>>(\"[1]\");` throws `NotSupportedException` and completely absent from https://learn.microsoft.com/en-us/dotnet/standard/serialization/system-text-json/supported-collection-types \n\n### Regression?\n\nDon't know.\n\n### Known Workarounds\n\nUse `ISet` or similar.\n\n### Configuration\n\n```\r\n> dotnet sdk check\r\nVersion      Status\r\n------------------------\r\n7.0.400      Up to date.\r\n\r\nMicrosoft.NETCore.App             7.0.10       Up to date.\r\nMicrosoft.WindowsDesktop.App      7.0.10       Up to date.\r\n```\r\nWindows 11 Pro x64\r\n```\r\n> [System.Environment]::OSVersion\r\nPlatform ServicePack Version      VersionString\r\n-------- ----------- -------      -------------\r\n Win32NT             10.0.22623.0 Microsoft Windows NT 10.0.22623.0\r\n```\r\n\n\n### Other information\n\n_No response_\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>StasJS</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`area-System.Text.Json`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2023-09-11T10:54:17Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-09-11T10:54:17Z",
          "id": "IC_kwDODI9FZc5mJCOp"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Because contract customization has not been fully implemented for collection types, it is not possible to work around this issue by customizing the `JsonTypeInfo.CreateObject` delegate. Instead, implementing a custom converter for the interface is necessary. Until this is addressed, my recommendation is to deserialize on models that use concrete collection types.\r\n\r\nWe should audit all built-in collection interfaces and check whether they are supported by the serializer. One possibility is to honor the newly added [`CollectionBuilderAttribute`](https://github.com/dotnet/runtime/issues/87569#issuecomment-1634635140) and use the delegate as specified by the interface declaration. ",
          "createdAt": "2023-09-11T12:41:31Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-09-11T12:41:31Z",
          "id": "IC_kwDODI9FZc5mJoZx"
        },
        {
          "author": "huoyaoyuan",
          "body": "Since `HashSet<T>` and `ISet<T>` are supported, it's reasonable to also include `IReadOnlySet<T>`.",
          "createdAt": "2023-09-12T04:36:13Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-09-18T10:15:17Z",
                "user": "JohnathanBarclay"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-01-15T14:54:03Z",
                "user": "KrzysztofBranicki"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-06-14T20:31:31Z",
                "user": "AbakumovAlexandr"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-08-29T14:06:13Z",
                "user": "alexeyshockov"
              }
            ],
            "totalCount": 4,
            "endCursor": "Y3Vyc29yOnYyOpHODwNXng=="
          },
          "updatedAt": "2023-09-12T04:36:13Z",
          "id": "IC_kwDODI9FZc5mOA4k"
        },
        {
          "author": "StasJS",
          "body": "Thanks for the update. @eiriktsarpalis do you see there being value in reconciling the documentation with current behaviour?\r\nIt sounds like any fix won't ship for quite some time.",
          "createdAt": "2023-09-17T09:57:21Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-09-17T09:57:21Z",
          "id": "IC_kwDODI9FZc5mqls9"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Yes, I think we should be documenting what types are supported.",
          "createdAt": "2023-09-17T10:06:37Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-09-17T10:06:37Z",
          "id": "IC_kwDODI9FZc5mqmHF"
        },
        {
          "author": "JohnathanBarclay",
          "body": "> Since `HashSet<T>` and `ISet<T>` are supported, it's reasonable to also include `IReadOnlySet<T>`.\r\n\r\nOther read-only collection types e.g. `IReadOnlyCollection<T>` & `IReadOnlyList<T>` are also supported, so this seems like an oversight.",
          "createdAt": "2023-09-18T10:29:36Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-11-22T00:19:41Z",
                "user": "elgonzo"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-01-15T14:54:36Z",
                "user": "KrzysztofBranicki"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-01-15T15:00:33Z",
                "user": "grsw92"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-08-19T08:06:17Z",
                "user": "fredericDelaporte"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-11-22T17:25:04Z",
                "user": "cpiber"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-05-14T15:39:39Z",
                "user": "kronic"
              }
            ],
            "totalCount": 6,
            "endCursor": "Y3Vyc29yOnYyOpHOESHMPA=="
          },
          "updatedAt": "2023-09-18T10:29:36Z",
          "id": "IC_kwDODI9FZc5mtQqs"
        },
        {
          "author": "KrzysztofBranicki",
          "body": "@eiriktsarpalis \r\n> Until this is addressed, my recommendation is to deserialize on models that use concrete collection types.\r\n\r\nThere is no concrete type `ReadOnlySet<T>` like there is e.g. `ReadOnlyCollection<T>`, also in this documentation [documentation ](https://learn.microsoft.com/en-us/dotnet/standard/serialization/system-text-json/supported-collection-types#systemcollectionsobjectmodel-namespace) you say that `ReadOnlyCollection<T>` does not support deserialization anyway (which is a separate question on it's own why that is). ",
          "createdAt": "2024-01-15T15:14:10Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-01-15T15:14:10Z",
          "id": "IC_kwDODI9FZc5wyxc7"
        },
        {
          "author": "eiriktsarpalis",
          "body": "> There is no concrete type ReadOnlySet<T> like there is e.g. ReadOnlyCollection<T>\r\n\r\nDon't `ImmutableHashSet<T>` or `ImmutableSortedSet<T>` work?",
          "createdAt": "2024-01-15T15:28:10Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-01-15T15:28:10Z",
          "id": "IC_kwDODI9FZc5wy3HK"
        },
        {
          "author": "KrzysztofBranicki",
          "body": "> Don't `ImmutableHashSet<T>` or `ImmutableSortedSet<T>` work?\r\n\r\nThey do if you are willing to accept [worst performance](https://github.com/dotnet/runtime/issues/29085) of those collections in scenarios where they are just used in DTOs (no expected mutations). And if someone doesn't care about performance he may just stick with Newtonsoft.Json.",
          "createdAt": "2024-01-15T15:44:46Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-01-15T15:47:41Z",
          "id": "IC_kwDODI9FZc5wy9tE"
        },
        {
          "author": "eiriktsarpalis",
          "body": "If that is a concern, then `HashSet<T>` and `SortedSet<T>` are alternatives, the trade-off being that they expose mutable APIs.",
          "createdAt": "2024-01-15T16:08:00Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-01-15T16:08:00Z",
          "id": "IC_kwDODI9FZc5wzGpO"
        },
        {
          "author": "KrzysztofBranicki",
          "body": "> If that is a concern, then `HashSet<T>` and `SortedSet<T>` are alternatives, the trade-off being that they expose mutable APIs.\r\n\r\nMutable events are not acceptable in event-driven architecture.",
          "createdAt": "2024-01-16T10:56:43Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "CONFUSED",
                "createdAt": "2024-01-16T15:29:01Z",
                "user": "chrisoverzero"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHODSyhOA=="
          },
          "updatedAt": "2024-01-16T10:56:43Z",
          "id": "IC_kwDODI9FZc5w3LA7"
        },
        {
          "author": "eiriktsarpalis",
          "body": "How about using mutable DTOs that are separate from your domain events? Alternatively you could try implementing a custom read-only set that wraps a regular set.",
          "createdAt": "2024-01-16T12:40:44Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-01-16T12:40:44Z",
          "id": "IC_kwDODI9FZc5w3wSk"
        },
        {
          "author": "KrzysztofBranicki",
          "body": "Thanks for the advice but, both options don't make sense in our use case. We will probably try to implement our own `JsonConverter` with hope that we will be able to remove it year from now when 9.0 is released.",
          "createdAt": "2024-01-17T11:14:46Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-01-17T11:14:46Z",
          "id": "IC_kwDODI9FZc5w_Icc"
        },
        {
          "author": "marekott",
          "body": "Hi @eiriktsarpalis, I have come up with custom converter for `IReadOnlySet` as follows. Could you advice if you see any potential problems or corner cases where it could fail?\r\n\r\n```csharp\r\ninternal class ReadOnlySetConverterFactory : JsonConverterFactory\r\n{\r\n    private readonly Type readOnlySetType = typeof(IReadOnlySet<>);\r\n    \r\n    public override bool CanConvert(Type typeToConvert) => typeToConvert.IsGenericType && typeToConvert.GetGenericTypeDefinition() == readOnlySetType;\r\n\r\n    public override JsonConverter? CreateConverter(Type typeToConvert, JsonSerializerOptions options)\r\n    {\r\n        var genericTypeParameter = typeToConvert.GetGenericArguments()[0];\r\n        var hashSetConverter = options.GetConverter(typeof(HashSet<>).MakeGenericType(genericTypeParameter));\r\n        \r\n        var converter = (JsonConverter)Activator.CreateInstance(\r\n            type: typeof(ReadOnlySetConverter<>).MakeGenericType(genericTypeParameter), BindingFlags.Instance | BindingFlags.Public,\r\n            binder: null,\r\n            args: new object[] { hashSetConverter },\r\n            culture: null)!;\r\n        \r\n        return converter;\r\n    }\r\n    \r\n    private class ReadOnlySetConverter<TValue> : JsonConverter<IReadOnlySet<TValue>>\r\n    {\r\n        private readonly JsonConverter<HashSet<TValue>> hashSetConverter;\r\n        private readonly Type hashSetType = typeof(HashSet<TValue>);\r\n\r\n        public ReadOnlySetConverter(JsonConverter<HashSet<TValue>> hashSetConverter) => this.hashSetConverter = hashSetConverter;\r\n\r\n        public override IReadOnlySet<TValue>? Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => \r\n            hashSetConverter.Read(ref reader, hashSetType, options);\r\n\r\n        public override void Write(Utf8JsonWriter writer, IReadOnlySet<TValue> value, JsonSerializerOptions options) => \r\n            hashSetConverter.Write(writer, value.ToHashSet(), options);\r\n    }\r\n}\r\n```",
          "createdAt": "2024-01-18T10:19:38Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-01-18T10:19:38Z",
          "id": "IC_kwDODI9FZc5xJCKM"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Superficially, this looks good to me. The only caveat is that it wouldn't work in Native AOT due to use of unsupported reflection.",
          "createdAt": "2024-01-18T11:39:19Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-01-18T13:52:16Z",
                "user": "marekott"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-01-19T10:21:36Z",
                "user": "KrzysztofBranicki"
              }
            ],
            "totalCount": 2,
            "endCursor": "Y3Vyc29yOnYyOpHODTQ21Q=="
          },
          "updatedAt": "2024-01-18T11:39:19Z",
          "id": "IC_kwDODI9FZc5xJgRt"
        },
        {
          "author": "AbakumovAlexandr",
          "body": "> If that is a concern, then `HashSet<T>` and `SortedSet<T>` are alternatives, the trade-off being that they expose mutable APIs.\r\n\r\n@eiriktsarpalis After reading the discussion above, I still can't answer this question: why the framework couldn't use `HashSet` where the declared type is `IReadOnlySet` at least for now (until performance issues of the immutable set are resolved)?\r\n\r\nIs it just to prevent clients from breaking DTO's contract like this:\r\n```\r\nvar set = (HashSet)dto.ReadOnlySetProperty;\r\nset.Remove(...);// Do mutable operations on dto.ReadOnlySetProperty collection declared to be immutable\r\n```\r\n? \r\n\r\nOk. Then, the solution is: don't break the declared DTO contract.\r\n\r\nBut this proposal would perfectly fix the situation for 'legit' clients which doesn't brake the declared immutable contract and which don't try to cast a property of an immutable type to its mutable counterpart, wouldn't it?",
          "createdAt": "2024-06-14T20:56:24Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-08-19T08:08:03Z",
                "user": "fredericDelaporte"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-08-29T14:09:24Z",
                "user": "alexeyshockov"
              }
            ],
            "totalCount": 2,
            "endCursor": "Y3Vyc29yOnYyOpHODwNdDg=="
          },
          "updatedAt": "2024-06-14T20:58:59Z",
          "id": "IC_kwDODI9FZc6BRIkD"
        },
        {
          "author": "CyrusNajmabadi",
          "body": "A value's actual runtime type is fair game for use. ",
          "createdAt": "2024-06-14T21:11:46Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-06-14T21:11:46Z",
          "id": "IC_kwDODI9FZc6BRMi0"
        },
        {
          "author": "AbakumovAlexandr",
          "body": "> A value's actual runtime type is fair game for use.\r\n\r\n@CyrusNajmabadi  Ok, If somebody has the practice of using a runtime type instead of a declared one in a class's API, what's an issue with the proposal even in this case? If somebody wants it - let him do it. But at the same time let the others ('legit' clients as I referred them above) declare `IReadOnlySet` property and use it as a read-only set, if they want to.\r\n\r\nOr one of the `System.Text.Json` design goals is to intentionally limit the use of practice you're considering as fair game? Then, the question would be: why, if it's fair game?",
          "createdAt": "2024-06-14T21:29:36Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-06-14T21:29:36Z",
          "id": "IC_kwDODI9FZc6BRRJw"
        },
        {
          "author": "CyrusNajmabadi",
          "body": "> what's an issue with the proposal even in this case?\n\nChoosing a type that is ok for the consumer to mutate when the producer does not want that. ",
          "createdAt": "2024-06-14T21:30:59Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-06-14T21:30:59Z",
          "id": "IC_kwDODI9FZc6BRRej"
        },
        {
          "author": "AbakumovAlexandr",
          "body": "@CyrusNajmabadi \r\n> Choosing a type that is ok for the consumer to mutate when the producer does not want that.\r\n\r\nIf it's something improper, then:\r\n```\r\n    public class HashSet<T> : ICollection<T>, ISet<T>, IReadOnlyCollection<T>, IReadOnlySet<T>, ISerializable, IDeserializationCallback\r\n```\r\n\r\nFor what purpose does `HashSet` declare itself to be `IReadOnlySet`, i.e. ability to be used as the read-only set? According to your logic, this opens an ability for someone to check the runtime type and mutate the set while a producer does not want that.\r\n\r\nIs it a wrong declaration which should be removed?",
          "createdAt": "2024-06-14T21:46:40Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-06-14T21:48:39Z",
          "id": "IC_kwDODI9FZc6BRVLb"
        },
        {
          "author": "CyrusNajmabadi",
          "body": "HashSet can serve as a read-only set when the producer of the set can decide they are ok with it being mutated.  It is not appropriate when the producer does not want that and that possibility is forced on them. ",
          "createdAt": "2024-06-14T22:24:36Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-06-14T22:24:36Z",
          "id": "IC_kwDODI9FZc6BRdTD"
        },
        {
          "author": "AbakumovAlexandr",
          "body": "@CyrusNajmabadi \r\n> It is not appropriate when the producer does not want that and that possibility is forced on them.\r\n\r\nCould you provide some info on which read-only collection types is it forced on in `System.Text.Json` exactly?\r\n\r\nIt's not forced on `IReadOnlyCollection` properties:\r\n![image](https://github.com/dotnet/runtime/assets/6968009/c1a30a25-58aa-467c-a81d-d7caaadc827c)\r\n\r\nIt's not forced on `IReadOnlyList` properties:\r\n![image](https://github.com/dotnet/runtime/assets/6968009/483be984-c4a6-4ec1-a529-e39bee557643)\r\n\r\n`System.Text.Json` constructs mutable `List`s for those at runtime.",
          "createdAt": "2024-06-14T22:43:37Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-06-15T03:14:15Z",
                "user": "StasJS"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-08-19T08:09:48Z",
                "user": "fredericDelaporte"
              }
            ],
            "totalCount": 2,
            "endCursor": "Y3Vyc29yOnYyOpHODutu6Q=="
          },
          "updatedAt": "2024-06-15T03:24:44Z",
          "id": "IC_kwDODI9FZc6BRgYj"
        },
        {
          "author": "StasJS",
          "body": "@CyrusNajmabadi I quite agree with @AbakumovAlexandr on this one. The ship has already sailed for the argument you are making via the JsonConverter treatment of existing readonly collections.\r\n\r\n@CyrusNajmabadi I would like to hear what solution you would propose for this issue. Hopefully you agree that the current state is awkward and it could be better? ",
          "createdAt": "2024-06-15T03:18:58Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-06-15T03:19:19Z",
          "id": "IC_kwDODI9FZc6BSXyf"
        },
        {
          "author": "CyrusNajmabadi",
          "body": "> I would like to hear what solution you would propose for this issue\r\n\r\nI would have it deserialize into a `ReadOnlySet<T>`: https://github.com/dotnet/runtime/pull/103306",
          "createdAt": "2024-06-15T03:29:23Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "ROCKET",
                "createdAt": "2024-06-15T03:37:35Z",
                "user": "StasJS"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHODlwulg=="
          },
          "updatedAt": "2024-06-15T03:29:23Z",
          "id": "IC_kwDODI9FZc6BSYfg"
        },
        {
          "author": "StasJS",
          "body": "@CyrusNajmabadi yes that recent PR introducing ReadOnlySet seems like the perfect solve for this I would think. Is anyone in a position to put a code change together? I can give it a go at some point soon but have not contributed to this repo before. ",
          "createdAt": "2024-06-15T08:10:37Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-06-15T08:10:37Z",
          "id": "IC_kwDODI9FZc6BS1cX"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Keep in mind that `ReadOnlySet<T>` is only available in `net9.0` whereas STJ needs to support `net8.0`. For consistency with how list and dictionary interfaces are handled, `HashSet<T>` would be the preferred implementation.",
          "createdAt": "2024-06-15T11:15:09Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-06-17T17:57:53Z",
                "user": "AbakumovAlexandr"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-08-19T08:10:32Z",
                "user": "fredericDelaporte"
              }
            ],
            "totalCount": 2,
            "endCursor": "Y3Vyc29yOnYyOpHODutvkQ=="
          },
          "updatedAt": "2024-06-15T11:15:09Z",
          "id": "IC_kwDODI9FZc6BTY2w"
        },
        {
          "author": "StasJS",
          "body": "If HashSet is picked to meet dotnet 8 timelines presumably it can't be changed for dotnet 9 and beyond to what would be the natural/obvious choice once ReadOnlySet ships due to risk of breaking code along the lines @CyrusNajmabadi has mentioned? \r\n\r\nThat sounds a little awkward",
          "createdAt": "2024-06-15T12:14:51Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-06-15T12:14:51Z",
          "id": "IC_kwDODI9FZc6BTtHD"
        },
        {
          "author": "eiriktsarpalis",
          "body": "From my perspective using mutable implementations is not a huge issue from the perspective of deserialization. The deserializer produces the type and passes ownership off to the caller once completed. If the caller wants to take the risk of downcasting to the runtime type to make mutations it's on them.",
          "createdAt": "2024-06-15T12:36:55Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-06-17T17:59:02Z",
                "user": "AbakumovAlexandr"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-06-17T20:27:56Z",
                "user": "StasJS"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-08-19T08:10:54Z",
                "user": "fredericDelaporte"
              }
            ],
            "totalCount": 3,
            "endCursor": "Y3Vyc29yOnYyOpHODutvzg=="
          },
          "updatedAt": "2024-06-15T12:36:55Z",
          "id": "IC_kwDODI9FZc6BT85N"
        },
        {
          "author": "AbakumovAlexandr",
          "body": "> If HashSet is picked to meet dotnet 8 timelines presumably it can't be changed for dotnet 9 ... due to risk of breaking code along the lines @CyrusNajmabadi has mentioned?\r\n> \r\n> That sounds a little awkward\r\n\r\nI don't think .NET Framework \\ .NET Core ever guaranteed compatibility across versions when a runtime type is used instead of a declared contract type. To my knowledge, it always was solely on a client code risk.\r\n\r\nHonestly, I'd be surprised if any class library project would pick covering such the practice as its design goal. It always looks like a direct invasion into internal undocumented framework implementation details and shouldn't be guaranteed, at least from a maintainability perspective.",
          "createdAt": "2024-06-17T18:18:31Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "HOORAY",
                "createdAt": "2024-06-17T20:27:52Z",
                "user": "StasJS"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHODl_BoA=="
          },
          "updatedAt": "2024-06-17T19:29:47Z",
          "id": "IC_kwDODI9FZc6BlV2L"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Moving 10.0.0. This should be addressed holisitically including extending support for all collection types, adding support for CollectionBuilderAttribute and IEnumerable constructors (https://github.com/dotnet/runtime/issues/80688)",
          "createdAt": "2024-07-05T14:27:44Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-07-05T14:27:44Z",
          "id": "IC_kwDODI9FZc6DyNc6"
        }
      ],
      "totalCount": 30,
      "endCursor": "Y3Vyc29yOnYyOpHOg8jXOg=="
    },
    "url": "https://github.com/dotnet/runtime/issues/91875",
    "title": "System.Text.Json cannot deserialize to IReadOnlySet"
  },
  {
    "author": "grosch-intl",
    "labels": [
      "enhancement",
      "area-System.Text.Json"
    ],
    "createdAt": "2023-09-20T08:04:25Z",
    "body": "### Description\n\nIt's often necessary to use the `required` flag on a property that you don't want serialized via JSON.  Adding the `JsonIgnore` attribute to such a property results in an `InvalidOperationException`.\n\n### Reproduction Steps\n\n```cs\r\nvoid Main() {\r\n\tvar dto = new DTO {\r\n\t\tNotRequiredNumber = 1,\r\n\t\tNumber = 2\r\n\t};\r\n\t\r\n\tJsonSerializer.Serialize<DTO>(dto);\r\n}\r\n\r\nclass DTO {\r\n\t[JsonIgnore]\r\n\tpublic required int Number { get; init; }\r\n\tpublic int NotRequiredNumber { get; init; }\r\n}\r\n```\n\n### Expected behavior\n\nShould be able to have the JSON generated without the ignored property.\r\n\n\n### Actual behavior\n\n JsonPropertyInfo 'Number' defined in type 'UserQuery+DTO' is marked required but does not specify a setter.\n\n### Regression?\n\nNo\n\n### Known Workarounds\n\n_No response_\n\n### Configuration\n\n- .NET 7\r\n- Windows 10\r\n- x64\r\n- Not specific to this configuration.\r\n\n\n### Other information\n\n_No response_",
    "number": 92330,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-09-26T19:50:10Z",
          "user": "AArnott"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-07-31T19:01:19Z",
          "user": "HeinrichvH"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-08-30T08:50:42Z",
          "user": "zvo-bla"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-02-18T13:17:13Z",
          "user": "dnmh-psc"
        }
      ],
      "totalCount": 4,
      "endCursor": "Y3Vyc29yOnYyOpHOC_MptQ=="
    },
    "updatedAt": "2025-05-21T08:36:49Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\n### Description\n\nIt's often necessary to use the `required` flag on a property that you don't want serialized via JSON.  Adding the `JsonIgnore` attribute to such a property results in an `InvalidOperationException`.\n\n### Reproduction Steps\n\n```cs\r\nvoid Main() {\r\n\tvar dto = new DTO {\r\n\t\tNotRequiredNumber = 1,\r\n\t\tNumber = 2\r\n\t};\r\n\t\r\n\tJsonSerializer.Serialize<DTO>(dto);\r\n}\r\n\r\nclass DTO {\r\n\t[JsonIgnore]\r\n\tpublic required int Number { get; init; }\r\n\tpublic int NotRequiredNumber { get; init; }\r\n}\r\n```\n\n### Expected behavior\n\nShould be able to have the JSON generated without the ignored property.\r\n\n\n### Actual behavior\n\n JsonPropertyInfo 'Number' defined in type 'UserQuery+DTO' is marked required but does not specify a setter.\n\n### Regression?\n\nNo\n\n### Known Workarounds\n\n_No response_\n\n### Configuration\n\n- .NET 7\r\n- Windows 10\r\n- x64\r\n- Not specific to this configuration.\r\n\n\n### Other information\n\n_No response_\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>grosch-intl</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`area-System.Text.Json`, `untriaged`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2023-09-20T08:04:33Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-09-20T08:04:33Z",
          "id": "IC_kwDODI9FZc5m8sTH"
        },
        {
          "author": "gregsdennis",
          "body": "To be clear, are you only asking for this to be supported during serialization and not during deserialization?",
          "createdAt": "2023-09-20T08:10:10Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-09-20T08:10:10Z",
          "id": "IC_kwDODI9FZc5m8uce"
        },
        {
          "author": "eiriktsarpalis",
          "body": "> are you only asking for this to be supported during serialization and not during deserialization?\r\n\r\nAnnotating a property with `[JsonIgnore]` means ignoring in both serialization and deserialization. As such the `JsonIgnore` annotation violates the contract of the `required` keyword, so failing in that case is in my opinion by-design behavior.\r\n\r\nWhat could be improved is the error message though, we should add better testing validating how the two features interact, specifically when the new ignore conditions are implemented in https://github.com/dotnet/runtime/issues/66490.",
          "createdAt": "2023-09-20T10:19:08Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-09-20T10:59:48Z",
                "user": "gregsdennis"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-09-26T19:50:31Z",
                "user": "AArnott"
              }
            ],
            "totalCount": 2,
            "endCursor": "Y3Vyc29yOnYyOpHODH36UQ=="
          },
          "updatedAt": "2023-09-20T10:19:08Z",
          "id": "IC_kwDODI9FZc5m9k6u"
        },
        {
          "author": "grosch-intl",
          "body": "> To be clear, are you only asking for this to be supported during serialization and not during deserialization?\r\n\r\nThat's correct, just during deserialization.",
          "createdAt": "2023-09-20T14:38:38Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-09-20T14:38:38Z",
          "id": "IC_kwDODI9FZc5m_SIl"
        },
        {
          "author": "gregsdennis",
          "body": "During _deserialization_ (going from JSON to C#)?  (Your code shows serialization.)\r\n\r\nI think you have a DTO design flaw then.  You're saying that you want to ignore `Number` in the JSON but that it's required to make a C# object.  I think this is just an invalid arrangement.\r\n\r\nWhy do you want `Number` to be required when creating this DTO from C#, but you don't want it populated when receiving it in JSON?  That seems inconsistent.\r\n\r\nI would split the DTO into two models: a domain model for populating in C# with `required` and a true DTO which is used solely for JSON serialization.  Then you'll just need a mapper to go between them.",
          "createdAt": "2023-09-20T19:17:00Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-09-20T19:17:00Z",
          "id": "IC_kwDODI9FZc5nA7eN"
        },
        {
          "author": "grosch-intl",
          "body": "Sorry @gregsdennis, I meant serialization as you assumed.  While you're technically 100% correct, I was hoping to not have to have another object.  This is already a temporary object that's populated via AutoMapper and ProjectTo.  While I don't want the caller to get the value, I do need it for the next query that's done in the same method.  \r\n\r\nI was hoping to avoid having to do yet another mapping to strip out that one property.\r\n\r\nThink of something like this obviously non-compiling code.  Need the internal ID for the next query but don't want to send it back.\r\n\r\n```csharp\r\nvar items = await _context.SomeTable.ProjectTo<SomeObj>(...).ToArrayAsync();\r\nvar ids = items.Select(x => x.InternalIdentifier).ToArrayAsync();\r\nvar otherStuff = await _context.SomeOtherTable\r\n    .Where(x => ids.Contains(x.SomeTableIdentifier))\r\n    .ToArrayAsync();\r\n\r\nvar mapping = otherStuff\r\n    .ToLookup(x => x.InternalIdentifier)\r\n    .ToDictionary(x => x.Key, x => x.Select(...));\r\n\r\nforeach (var item in items) {\r\n    item.Stuff = mapping[item.InternalIdentifier];\r\n```",
          "createdAt": "2023-09-20T21:35:28Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-09-20T21:35:28Z",
          "id": "IC_kwDODI9FZc5nBi-A"
        },
        {
          "author": "gregsdennis",
          "body": "Sure, do what makes sense for you.\n\nBut I agree that this is by-design behavior.",
          "createdAt": "2023-09-20T22:33:01Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-09-20T22:33:01Z",
          "id": "IC_kwDODI9FZc5nBvw5"
        },
        {
          "author": "AArnott",
          "body": "I hit this. In my case, I have a custom deserializer, but wanted to utilize the JsonSerializer for serialization. That's why it made sense for `[JsonIgnore]` and `required` to appear on the same property. But it rejects serialization even though it _could_ do that.",
          "createdAt": "2023-09-26T19:52:07Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-09-26T19:52:07Z",
          "id": "IC_kwDODI9FZc5nfDN4"
        },
        {
          "author": "TonyValenti",
          "body": "@AArnott  - How did you work around this?",
          "createdAt": "2025-01-28T15:52:00Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-01-28T15:52:00Z",
          "id": "IC_kwDODI9FZc6cIMIz"
        },
        {
          "author": "AArnott",
          "body": "@TonyValenti I don't recall, sorry. But I can only imagine I avoided System.Text.Json even for serialization since it didn't work. I probably would have switched to MessagePack, since that's my go-to for serialization anyway as it's faster and more compact. \nShameless plug: I have my own messagepack serializer library that is NativeAOT-ready now: [Nerdbank.MessagePack](https://aarnott.github.io/Nerdbank.MessagePack/docs/getting-started.html?tabs=net).",
          "createdAt": "2025-01-28T16:05:27Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "HEART",
                "createdAt": "2025-01-28T16:08:46Z",
                "user": "eiriktsarpalis"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOEEUfnQ=="
          },
          "updatedAt": "2025-01-28T16:05:27Z",
          "id": "IC_kwDODI9FZc6cIVIS"
        },
        {
          "author": "TonyValenti",
          "body": "As a work around I set the property via a constructor parameter, removed required, and marked it as JsonIgnore. ",
          "createdAt": "2025-01-28T18:14:47Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-01-28T18:25:29Z",
                "user": "AArnott"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOEEVs_A=="
          },
          "updatedAt": "2025-01-28T18:14:47Z",
          "id": "IC_kwDODI9FZc6cJf3R"
        },
        {
          "author": "cyrusdargahi",
          "body": "I've faced this situations many times too and every time it gets me.\n\nWhat I fail to understand is why is deserialization validated when all I want is to serialize? The two actions are unrelated.\nFor deserialization, I totally understand the limits and code generation scenarios, it makes sense.\n\nI want to create an instance with a required property in code, then I want to serialize that object and ignore the given property. That's it.\n\nI will never deserialize to this class. And one day if I decide to do that and I get this exception thrown, then I can deal with that issue then, that's also unrelated.\n\nI would rather not be stopped doing a totally doable action because some other action that I will never use would never work in a give scenario. It just doesn't make any sense.\n\nI would love to understand more about the reasoning here, is there any documentation or decision notes I can look at to get educated?",
          "createdAt": "2025-05-21T08:36:47Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-07-13T09:33:53Z",
                "user": "HugCoder"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOEaYOFw=="
          },
          "updatedAt": "2025-05-21T08:36:47Z",
          "id": "IC_kwDODI9FZc6sris9"
        }
      ],
      "totalCount": 12,
      "endCursor": "Y3Vyc29yOnYyOpHOrK4rPQ=="
    },
    "url": "https://github.com/dotnet/runtime/issues/92330",
    "title": "Improve error message in scenaria where `JsonIgnore` is combined with `required` members."
  },
  {
    "author": "alexaloni",
    "labels": [
      "bug",
      "area-System.Text.Json"
    ],
    "createdAt": "2023-09-28T17:02:43Z",
    "body": "### Description\r\n\r\nSystem.text.json serializes property decorated with JsonPropertyName attribute in the base class is recording 2 records in the output json , one with property name as key and a second with name specified in the attribute. \r\n\r\n### Reproduction Steps\r\n\r\n```C#\r\nConsole.WriteLine(JsonSerializer.Serialize(new Derived()));\r\n\r\npublic class Base\r\n{\r\n    [JsonPropertyName(\"test\")]\r\n    public virtual string Id { get => \"base\"; set { } }\r\n}\r\n\r\npublic class Derived : Base\r\n{\r\n    public override string Id { get => \"derived\"; set { } }\r\n}\r\n```\r\n\r\n### Expected behavior\r\n\r\nonly single entry with name specified in the JsonPropertyName should be adde to json.\r\n\r\n### Actual behavior\r\n\r\n{\"Id\":\"derived\",\"test\":\"derived\"}   -> added twice with different names.\r\n\r\n### Regression?\r\n\r\nWe have seen this since the initial version.\r\n\r\n### Known Workarounds\r\n\r\nI see two possible workarounds:\r\n\r\n1. Try using the base type as the generic parameter when creating your container object. Unlike Json.NET, STJ is sensitive when it comes to what type is being declared statically at the serialization callsite, or\r\n2. Replicate the JsonPropertyName property in the overrides. It's more boilerplate, but at least it's the best way to get the desired behavior while we ship a fix.\r\n\r\n### Configuration\r\n\r\n.NET 7 \r\n\r\n### Other information\r\n\r\n_No response_",
    "number": 92780,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-09-28T20:36:46Z",
          "user": "Xor-el"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-02-01T01:17:28Z",
          "user": "ravindUwU"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-02-27T12:45:14Z",
          "user": "neon-sunset"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-02-27T14:10:08Z",
          "user": "KubaZ2"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-05-21T02:39:51Z",
          "user": "KalebAxon"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-07-02T13:54:25Z",
          "user": "VitaliyChaban"
        }
      ],
      "totalCount": 6,
      "endCursor": "Y3Vyc29yOnYyOpHODFctFw=="
    },
    "updatedAt": "2025-03-02T10:55:23Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\n### Description\n\nSystem.text.json serializes property decorated with JsonPropertyName attribute in the base class is recording 2 records in the output json , one with property name as key and a second with name specified in the attribute. \n\n### Reproduction Steps\n\nConsole.WriteLine(JsonSerializer.Serialize(new Derived()));\r\n\r\npublic class Base\r\n{\r\n    [JsonPropertyName(\"test\")]\r\n    public virtual string Id { get => \"base\"; set { } }\r\n}\r\n\r\npublic class Derived : Base\r\n{\r\n    public override string Id { get => \"derived\"; set { } }\r\n}\n\n### Expected behavior\n\nonly single entry with name specified in the JsonPropertyName should be adde to json.\n\n### Actual behavior\n\n{\"Id\":\"derived\",\"test\":\"derived\"}   -> added twice with different names.\n\n### Regression?\n\nWe have seen this since the initial version.\n\n### Known Workarounds\n\nI see two possible workarounds:\r\n\r\n1. Try using the base type as the generic parameter when creating your container object. Unlike Json.NET, STJ is sensitive when it comes to what type is being declared statically at the serialization callsite, or\r\n2. Replicate the JsonPropertyName property in the overrides. It's more boilerplate, but at least it's the best way to get the desired behavior while we ship a fix.\n\n### Configuration\n\n.NET 7 \n\n### Other information\n\n_No response_\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>alexaloni</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`area-System.Text.Json`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2023-09-28T17:02:51Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-09-28T17:02:51Z",
          "id": "IC_kwDODI9FZc5nscvL"
        },
        {
          "author": "eiriktsarpalis",
          "body": "I can reproduce in .NET 8. This falls under the same umbrella of issues described in https://github.com/dotnet/runtime/issues/73255, namely it concerns attribute resolution of virtual properties. We should try to address all these issues in unison, although it would admit the probability of breaking changes.\r\n\r\nIn the meantime, you could try the following workarounds:\r\n\r\n1. Serialize the value using the base type as the generic parameter: `JsonSerializer.Serialize<Base>(new Derived());` or\r\n2. Apply the same `JsonPropertyName` attribute to the overridden property.",
          "createdAt": "2023-09-28T17:52:14Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-09-28T17:52:14Z",
          "id": "IC_kwDODI9FZc5nsssI"
        },
        {
          "author": "jmathiassen-visma",
          "body": "I see you mention attribute resolution of virtual properties, I assume this is the same problem I'm seeing when I'm doing this:\r\n\r\n```\r\nusing System;\r\nusing System.Text.Json;\r\nusing System.Text.Json.Serialization;\r\n\r\npublic static class test\r\n{\r\n    [JsonPolymorphic(UnknownDerivedTypeHandling = JsonUnknownDerivedTypeHandling.FallBackToNearestAncestor, TypeDiscriminatorPropertyName = \"action\")]\r\n    [JsonDerivedType(typeof(inherited), nameof(anEnum.attribute3))]\r\n    public class root\r\n    {\r\n        [JsonConverter(typeof(JsonStringEnumConverter))]\r\n        public anEnum action { get; set; }\r\n        [JsonConverter(typeof(JsonStringEnumConverter))]\r\n        public anEnum action2 { get; set; }\r\n    }\r\n\r\n    public class inherited : root\r\n    {\r\n        public string asdf { get; set; }\r\n        public string asdf2 { get; set; }\r\n    }\r\n\r\n    public enum anEnum\r\n    {\r\n        attribute1,\r\n        attribute2,\r\n        attribute3,\r\n        attribute4\r\n    }\r\n\r\n    static void Main(string[] args)\r\n    {\r\n        inherited input = new()\r\n        {\r\n            action = anEnum.attribute3,\r\n            action2 = anEnum.attribute2,\r\n            asdf = \"asdf1\",\r\n            asdf2 = \"asdf2\",\r\n        };\r\n        Console.WriteLine(JsonSerializer.Serialize(input));\r\n        Console.WriteLine(JsonSerializer.Serialize((root)input));\r\n    }\r\n}\r\n\r\n```\r\nThe output I get is the following:\r\n\r\n```\r\n    {\"asdf\":\"asdf1\",\"asdf2\":\"asdf2\",\"action\":\"attribute1\",\"action2\":\"attribute2\"}\r\n    {\"action\":\"attribute4\",\"asdf\":\"asdf1\",\"asdf2\":\"asdf2\",\"action\":\"attribute1\",\"action2\":\"attribute2\"}\r\n```\r\n\r\nIf I remove the jsonpolymorphic tag, and run the same code, I get the following:\r\n\r\n```\r\n{\"asdf\":\"asdf1\",\"asdf2\":\"asdf2\",\"action\":\"attribute3\",\"action2\":\"attribute2\"}\r\n{\"$type\":\"attribute4\",\"asdf\":\"asdf1\",\"asdf2\":\"asdf2\",\"action\":\"attribute3\",\"action2\":\"attribute2\"}\r\n```\r\n\r\nSo, the first line is serialized directly from the actual instantiated class (i.e. instanced, in this case), the second is when it's serialized via the root baseclass, i.e. I assume we're seeing the actually derived object, and I assume the first property is a virtual property that in the polymorphed instance has its name overridden by the polymorphism typediscriminatorpropertyname attribute, while in the non-polymorphed instance the virtual property is just named $type.\r\n\r\nWhen I deserialize it again, everything looks fine, it's only when I try to f.ex send it over the wire by serializing it via the base class that it actually turns into a problem.",
          "createdAt": "2024-10-02T09:52:54Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-10-03T09:08:53Z",
          "id": "IC_kwDODI9FZc6OWFn_"
        },
        {
          "author": "Xor-el",
          "body": "here is another variation that the [workarounds](https://github.com/dotnet/runtime/issues/92780#issuecomment-1739770632) mentioned above **does not** work for.\n\n```csharp\nusing System.Text.Json;\nusing System.Text.Json.Serialization;\n\nvar json = JsonSerializer.Serialize(new CustomerLimitTransactionLogRequest { AccountNumber = \"1234567890\" });\n\nConsole.WriteLine($\"Json Data: {json}\");\n\npublic abstract class BaseCustomerLimitRequest\n{\n    public virtual string? AccountNumber { get; set; }\n}\n\npublic class CustomerLimitTransactionLogRequest : BaseCustomerLimitRequest\n{\n    [JsonPropertyName(\"accountNo\")]\n    public override string? AccountNumber { get; set; }\n}\n```",
          "createdAt": "2025-03-02T10:55:04Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-03-02T10:55:23Z",
          "id": "IC_kwDODI9FZc6gfvHR"
        }
      ],
      "totalCount": 4,
      "endCursor": "Y3Vyc29yOnYyOpHOoH7x0Q=="
    },
    "url": "https://github.com/dotnet/runtime/issues/92780",
    "title": "System.text.json serializes virtual property decorated with JsonPropertyName attribute twice."
  },
  {
    "author": "Stroniax",
    "labels": [
      "api-suggestion",
      "area-System.Text.Json"
    ],
    "createdAt": "2023-09-29T15:56:57Z",
    "body": "### Background and motivation\n\nI am working with a web API that returns a paginated response. I'd like to deserialize the content of the `page` property into an `IAsyncEnumerable<T>` but I can't because it is not the root-level object. I can ignore the other members (in this example, `etag`).\r\n\r\n```json\r\n{\r\n  \"page\": [\r\n    { \"name\": \"item1\" },\r\n    { \"name\": \"item2\" }\r\n  ],\r\n  \"etag\": \"0000000\"\r\n}\r\n```\n\n### API Proposal\n\n```csharp\r\nnamespace System.Text.Json;\r\n\r\npartial class JsonSerializer\r\n{\r\n    /// <summary>\r\n    /// Deserializes a member of a json content stream into an <see cref=\"IAsyncEnumerable{T}\"/>,\r\n    /// ignoring all other members of the root element. <paramref name=\"jsonPath\"/> must refer to\r\n    /// a json array member.\r\n    /// </summary>\r\n    public IAsyncEnumerable<T> DeserializeAsyncEnumerableMember<T>(\r\n      Stream stream,\r\n      JsonPath jsonPath,\r\n      JsonSerializerOptions jsonOptions,\r\n      CancellationToken cancellationToken\r\n    );\r\n}\r\n\r\n/// <summary>\r\n/// API for strongly-typed json path specification.\r\n/// </summary>\r\n/// <remarks>\r\n/// Avoids requiring the caller to memorize the json path semantics\r\n/// </remarks>\r\npublic readonly struct JsonPath : ISpanParsable<JsonPath> {\r\n    /// <summary>Creates a new path representing a child node of the current object with the given index.</summary>\r\n    public JsonPath Index(int index);\r\n\r\n    /// <summary>Creates a new path representing a child node of the current object with the given property name.</summary>\r\n    public JsonPath Property(string propertyName);\r\n\r\n    /// <summary>The root-level object reference.</summary>\r\n    public static JsonPath Root { get; }\r\n\r\n  /// <summary>Produces a well-formed json path, such as \"$.item[0].child.foo\"</summary>\r\n  public override string ToString();\r\n}\r\n```\r\n\n\n### API Usage\n\n```csharp\r\nvar client = new HttpClient();\r\nvar response = await client.GetAsync(\r\n    \"https://some.api/data?page=6\",\r\n    HttpCompletionOption.ResponseHeadersRead,\r\n    cancellationToken\r\n    );\r\n\r\nresponse.EnsureSuccessStatusCode();\r\n\r\nvar nextPageUri = response.Headers.GetValues(\"X-Next-Page\").Single();\r\n\r\nawait var stream = response.Content.ReadAsStreamAsync(cancellationToken);\r\n\r\nvar data = JsonSerializer.DeserializeAsyncEnumerableMember<SomeApiData>(\r\n    stream,\r\n    JsonPath.Root.Property(\"data\"),\r\n    JsonSerializerOptions.Default,\r\n    cancelaltionToken\r\n    );\r\n\r\nawait foreach (var item in data) {\r\n    yield return item;\r\n}\r\n```\r\n\n\n### Alternative Designs\n\nConsider using `string` instead of introducing a `JsonPath` API. This may be more performant or allocate less, but may require higher burden on the user and higher chance of runtime failure by providing the wrong json path format.\n\n### Risks\n\n_No response_",
    "number": 92823,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-01-04T15:22:55Z",
          "user": "frankbuckley"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-09-05T15:33:08Z",
          "user": "Arithmomaniac"
        }
      ],
      "totalCount": 2,
      "endCursor": "Y3Vyc29yOnYyOpHOC6y40A=="
    },
    "updatedAt": "2023-09-29T18:43:42Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\n### Background and motivation\n\nI am working with a web API that returns a paginated response. I'd like to deserialize the content of the `page` property into an `IAsyncEnumerable<T>` but I can't because it is not the root-level object. I can ignore the other members (in this example, `etag`).\r\n\r\n```json\r\n{\r\n  \"page\": [\r\n    { \"name\": \"item1\" },\r\n    { \"name\": \"item2\" }\r\n  ],\r\n  \"etag\": \"0000000\"\r\n}\r\n```\n\n### API Proposal\n\n```csharp\r\nnamespace System.Text.Json;\r\n\r\npartial class JsonSerializer\r\n{\r\n    /// <summary>\r\n    /// Deserializes a member of a json content stream into an <see cref=\"IAsyncEnumerable{T}\"/>,\r\n    /// ignoring all other members of the root element. <paramref name=\"jsonPath\"/> must refer to\r\n    /// a json array member.\r\n    /// </summary>\r\n    public IAsyncEnumerable<T> DeserializeAsyncEnumerableMember<T>(\r\n      Stream stream,\r\n      JsonPath jsonPath,\r\n      JsonSerializerOptions jsonOptions,\r\n      CancellationToken cancellationToken\r\n    );\r\n}\r\n\r\n/// <summary>\r\n/// API for strongly-typed json path specification.\r\n/// </summary>\r\n/// <remarks>\r\n/// Avoids requiring the caller to memorize the json path semantics\r\n/// </remarks>\r\npublic readonly struct JsonPath : ISpanParsable<JsonPath> {\r\n    /// <summary>Creates a new path representing a child node of the current object with the given index.</summary>\r\n    public JsonPath Index(int index);\r\n\r\n    /// <summary>Creates a new path representing a child node of the current object with the given property name.</summary>\r\n    public JsonPath Property(string propertyName);\r\n\r\n    /// <summary>The root-level object reference.</summary>\r\n    public static JsonPath Root { get; }\r\n\r\n  /// <summary>Produces a well-formed json path, such as \"$.item[0].child.foo\"</summary>\r\n  public override string ToString();\r\n}\r\n```\r\n\n\n### API Usage\n\n```csharp\r\nvar client = new HttpClient();\r\nvar response = await client.GetAsync(\r\n    \"https://some.api/data?page=6\",\r\n    HttpCompletionOption.ResponseHeadersRead,\r\n    cancellationToken\r\n    );\r\n\r\nresponse.EnsureSuccessStatusCode();\r\n\r\nvar nextPageUri = response.Headers.GetValues(\"X-Next-Page\").Single();\r\n\r\nawait var stream = response.Content.ReadAsStreamAsync(cancellationToken);\r\n\r\nvar data = JsonSerializer.DeserializeAsyncEnumerableMember<SomeApiData>(\r\n    stream,\r\n    JsonPath.Root.Property(\"data\"),\r\n    JsonSerializerOptions.Default,\r\n    cancelaltionToken\r\n    );\r\n\r\nawait foreach (var item in data) {\r\n    yield return item;\r\n}\r\n```\r\n\n\n### Alternative Designs\n\nConsider using `string` instead of introducing a `JsonPath` API. This may be more performant or allocate less, but may require higher burden on the user and higher chance of runtime failure by providing the wrong json path format.\n\n### Risks\n\n_No response_\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>Stroniax</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`api-suggestion`, `area-System.Text.Json`, `untriaged`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2023-09-29T15:57:10Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-09-29T15:57:10Z",
          "id": "IC_kwDODI9FZc5nx1FF"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Thanks. It's something we've been considering but it may or may not require a dedicated `JsonPath` type. A string path parameter might suffice.",
          "createdAt": "2023-09-29T16:14:02Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-09-29T16:14:02Z",
          "id": "IC_kwDODI9FZc5nx948"
        },
        {
          "author": "gregsdennis",
          "body": "JSON Path is significantly more complex than what you've modeled.  See my implementation source at https://github.com/gregsdennis/json-everything.",
          "createdAt": "2023-09-29T18:43:42Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-09-29T18:43:42Z",
          "id": "IC_kwDODI9FZc5nyrJx"
        }
      ],
      "totalCount": 3,
      "endCursor": "Y3Vyc29yOnYyOpHOZ8qycQ=="
    },
    "url": "https://github.com/dotnet/runtime/issues/92823",
    "title": "[API Proposal]: Deserialize Json Member as IAsyncEnumerable"
  },
  {
    "author": "ithline",
    "labels": [
      "api-suggestion",
      "area-System.Text.Json"
    ],
    "createdAt": "2023-09-29T18:38:05Z",
    "body": "### Background and motivation\n\nRecently there has been added `UseStringEnumConverter` flag to `JsonSourceGenerationOptions`, but there is no way to configure naming policy for these converters.\r\n\r\nThe `Converters` property accepts `Type[]?` array, so it cannot be used either.\n\n### API Proposal\n\n```csharp\r\n\r\nnamespace System.Text.Json.Serialization;\r\n\r\npublic partial class JsonSourceGenerationOptionsAttribute : JsonAttribute\r\n{\r\n    public JsonKnownNamingPolicy EnumNamingPolicy { get; set; }\r\n}\r\n```\r\n\n\n### API Usage\n\n```csharp\r\n[JsonSourceGenerationOptions(\r\n    UseStringEnumConverter = true,\r\n    EnumNamingPolicy = JsonKnownNamingPolicy.CamelCase)]\r\ninternal sealed partial class MyJsonContext : JsonSerializerContext\r\n{\r\n}\r\n```\r\n\n\n### Alternative Designs\n\n_No response_\n\n### Risks\n\n_No response_",
    "number": 92828,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-11-30T15:49:35Z",
          "user": "JuanZamudioGBM"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-12-04T14:54:09Z",
          "user": "get-flat"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-12-07T19:17:19Z",
          "user": "Kumima"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-02-09T12:48:42Z",
          "user": "tpaananen"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-03-03T03:50:34Z",
          "user": "drjaydenm"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-03-17T18:22:36Z",
          "user": "pinkfloydx33"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-05-10T17:25:10Z",
          "user": "Pentadome"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-07-05T07:04:44Z",
          "user": "afroewis"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-11-29T03:33:56Z",
          "user": "aetos382"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-01-16T09:43:38Z",
          "user": "nandor23"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-07-08T07:24:55Z",
          "user": "huoyaoyuan"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-08-04T02:57:06Z",
          "user": "jp2masa"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-08-18T18:48:57Z",
          "user": "Chaosed0"
        }
      ],
      "totalCount": 13,
      "endCursor": "Y3Vyc29yOnYyOpHODLpGTA=="
    },
    "updatedAt": "2024-05-13T15:24:30Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\n### Background and motivation\n\nRecently there has been added `UseStringEnumConverter` flag to `JsonSourceGenerationOptions`, but there is no way to configure naming policy for these converters.\r\n\r\nThe `Converters` property accepts `Type[]?` array, so it cannot be used either.\n\n### API Proposal\n\n```csharp\r\n\r\nnamespace System.Text.Json.Serialization;\r\n\r\npublic partial class JsonSourceGenerationOptionsAttribute : JsonAttribute\r\n{\r\n    public JsonKnownNamingPolicy EnumNamingPolicy { get; set; }\r\n}\r\n```\r\n\n\n### API Usage\n\n```csharp\r\n[JsonSourceGenerationOptions(\r\n    UseStringEnumConverter = true,\r\n    EnumNamingPolicy = JsonKnownNamingPolicy.CamelCase)]\r\ninternal sealed partial class MyJsonContext : JsonSerializerContext\r\n{\r\n}\r\n```\r\n\n\n### Alternative Designs\n\n_No response_\n\n### Risks\n\n_No response_\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>ithline</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`api-suggestion`, `area-System.Text.Json`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2023-09-29T18:38:13Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-09-29T18:38:13Z",
          "id": "IC_kwDODI9FZc5nypve"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Sounds reasonable.",
          "createdAt": "2023-09-29T19:34:22Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-09-29T19:34:22Z",
          "id": "IC_kwDODI9FZc5ny4GD"
        },
        {
          "author": "eiriktsarpalis",
          "body": "> The Converters property accepts Type[]? array, so it cannot be used either.\r\n\r\nYou can always try extending the converter class with a custom naming policy and specify that in the `Converters` property:\r\n\r\n```C#\r\npublic enum MyEnum { A, B, C };\r\n\r\n[JsonSourceGenerationOptions(Converters = new[] { typeof(CamelCaseJsonStringEnumConverter<MyEnum>)})]\r\n[JsonSerializable(typeof(MyEnum))]\r\npublic partial class MyContext : JsonSerializerContext { }\r\n\r\npublic class CamelCaseJsonStringEnumConverter<TEnum>() \r\n    : JsonStringEnumConverter<TEnum>(JsonNamingPolicy.CamelCase) where TEnum : struct, Enum;\r\n```",
          "createdAt": "2023-09-29T19:39:10Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-10-02T08:20:37Z",
                "user": "ithline"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-05-10T17:27:20Z",
                "user": "Pentadome"
              }
            ],
            "totalCount": 2,
            "endCursor": "Y3Vyc29yOnYyOpHODhcHeg=="
          },
          "updatedAt": "2023-09-29T19:39:29Z",
          "id": "IC_kwDODI9FZc5ny5PG"
        },
        {
          "author": "alexanderdibenedetto",
          "body": "This would solve a lot of issues with the fact that the JsonStringEnumConverter locks you into CamelCase, and some of us need snake or kebob case instead for certain enumerations.",
          "createdAt": "2024-01-06T02:49:29Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-01-06T02:49:29Z",
          "id": "IC_kwDODI9FZc5wBwb3"
        },
        {
          "author": "Pentadome",
          "body": "> > The Converters property accepts Type[]? array, so it cannot be used either.\r\n> \r\n> You can always try extending the converter class with a custom naming policy and specify that in the `Converters` property:\r\n> \r\n> ```cs\r\n> public enum MyEnum { A, B, C };\r\n> \r\n> [JsonSourceGenerationOptions(Converters = new[] { typeof(CamelCaseJsonStringEnumConverter<MyEnum>)})]\r\n> [JsonSerializable(typeof(MyEnum))]\r\n> public partial class MyContext : JsonSerializerContext { }\r\n> \r\n> public class CamelCaseJsonStringEnumConverter<TEnum>() \r\n>     : JsonStringEnumConverter<TEnum>(JsonNamingPolicy.CamelCase) where TEnum : struct, Enum;\r\n> ```\r\n\r\n\r\nOr you can make a factory to support all enums.\r\n\r\n```cs\r\ninternal sealed class JsonStringEnumCamelCaseConverter : JsonConverterFactory\r\n{\r\n    public override bool CanConvert(Type typeToConvert)\r\n    {\r\n        return typeToConvert.IsEnum;\r\n    }\r\n\r\n    public override JsonConverter? CreateConverter(\r\n        Type typeToConvert,\r\n        JsonSerializerOptions options\r\n    )\r\n    {\r\n        if (!typeToConvert.IsEnum)\r\n            throw new ArgumentException(\"Type should be enum.\", nameof(typeToConvert));\r\n\r\n        var constructedType = typeof(JsonStringEnumConverter<>).MakeGenericType(typeToConvert);\r\n        return (JsonConverter)\r\n            Activator.CreateInstance(\r\n                constructedType,\r\n                BindingFlags.Default,\r\n                null,\r\n                [JsonNamingPolicy.CamelCase, true],\r\n                null\r\n            )!;\r\n    }\r\n}\r\n```",
          "createdAt": "2024-05-13T15:24:29Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-05-13T15:24:29Z",
          "id": "IC_kwDODI9FZc59pVaY"
        }
      ],
      "totalCount": 5,
      "endCursor": "Y3Vyc29yOnYyOpHOfaVWmA=="
    },
    "url": "https://github.com/dotnet/runtime/issues/92828",
    "title": "[API Proposal]: Add option to specify JsonNamingPolicy for enum serialization on JsonSourceGenerationOptions "
  },
  {
    "author": "eiriktsarpalis",
    "labels": [
      "enhancement",
      "area-System.Text.Json",
      "partner-impact"
    ],
    "createdAt": "2023-10-02T10:50:38Z",
    "body": "> Thanks, this looks like a real bug. FWIW it's not specific to primary constructors or records, this fails too:\r\n> \r\n> ```C#\r\n> using System.Text.Json.Serialization;\r\n> using System.Text.Json;\r\n> \r\n> var singleUserJson = \"\"\"{\"Username\":\"Filip\",\"PhoneNumbers\":[\"123456\"]}\"\"\";\r\n> var userFromJson = JsonSerializer.Deserialize<User>(singleUserJson);\r\n> Console.WriteLine(userFromJson.PhoneNumbers.Count); // 0\r\n> \r\n> public class User\r\n> {\r\n>     public User(string name)\r\n>         => Name = name;\r\n> \r\n>     public string Name { get; }\r\n> \r\n>     [JsonObjectCreationHandling(JsonObjectCreationHandling.Populate)]\r\n>     public List<string> PhoneNumbers { get; } = new();\r\n> }\r\n> ```\r\n\r\n_Originally posted by @eiriktsarpalis in https://github.com/dotnet/docs/issues/37329#issuecomment-1742795375_\r\n            ",
    "number": 92877,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-05-22T17:55:26Z",
          "user": "Tyrrrz"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-12-18T22:07:24Z",
          "user": "rog1039"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-01-27T12:02:04Z",
          "user": "xshaheen"
        }
      ],
      "totalCount": 3,
      "endCursor": "Y3Vyc29yOnYyOpHOC-fg7Q=="
    },
    "updatedAt": "2025-07-16T07:08:09Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\nThanks, this looks like a real bug. FWIW it's not specific to primary constructors or records, this fails too:\r\n\r\n```C#\r\nusing System.Text.Json.Serialization;\r\nusing System.Text.Json;\r\n\r\nvar singleUserJson = \"\"\"{\"Username\":\"Filip\",\"PhoneNumbers\":[\"123456\"]}\"\"\";\r\nvar userFromJson = JsonSerializer.Deserialize<User>(singleUserJson);\r\nConsole.WriteLine(userFromJson.PhoneNumbers.Count); // 0\r\n\r\npublic class User\r\n{\r\n    public User(string name)\r\n        => Name = name;\r\n\r\n    public string Name { get; }\r\n\r\n    [JsonObjectCreationHandling(JsonObjectCreationHandling.Populate)]\r\n    public List<string> PhoneNumbers { get; } = new();\r\n}\r\n```\r\n\r\n_Originally posted by @eiriktsarpalis in https://github.com/dotnet/docs/issues/37329#issuecomment-1742795375_\r\n            \n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>eiriktsarpalis</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`area-System.Text.Json`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2023-10-02T10:50:56Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-10-02T10:50:56Z",
          "id": "IC_kwDODI9FZc5n4PbD"
        },
        {
          "author": "fekberg",
          "body": "It behaves the same even if you mark the parameter as optional (default) value.\r\n\r\nHere's another case where it does not work, when using in combination with `JsonDerivedType` and `JsonPolymorphic`.\r\n\r\nIf you create a set of records like this:\r\n\r\n```\r\n\r\n[JsonDerivedType(typeof(User), typeDiscriminator: \"user\")]\r\n[JsonDerivedType(typeof(InactiveUser), typeDiscriminator: \"inactive\")]\r\n[JsonDerivedType(typeof(DisabledUser), typeDiscriminator: \"disabled\")]\r\n[JsonPolymorphic(TypeDiscriminatorPropertyName = \"$discriminator\")]\r\n[JsonObjectCreationHandling(JsonObjectCreationHandling.Populate)]\r\nrecord User\r\n{\r\n    public string Username { get; set; }\r\n\r\n    public List<string> PhoneNumbers { get; } = new();\r\n}\r\n\r\nrecord DisabledUser(DateTimeOffset DisabledSince)\r\n    : User();\r\n\r\nrecord InactiveUser(DateTimeOffset InactiveSince) \r\n    : User();\r\n\r\n```\r\n\r\nThe following will not populate `PhoneNumbers`:\r\n\r\n```\r\nvar jsonAsString = \"\"\"\r\n[\r\n    {\r\n        \"$discriminator\": \"user\",\r\n        \"Username\": \"Filip\",\r\n        \"PhoneNumbers\": [\r\n            \"12345\"\r\n        ]\r\n    },\r\n    {\r\n        \"$discriminator\": \"inactive\",\r\n        \"InactiveSince\": \"2023-10-02T11:53:24.2010948+00:00\",\r\n        \"Username\": \"Sofie\",\r\n        \"PhoneNumbers\": [\r\n            \"6789\"\r\n        ]\r\n    },\r\n    {\r\n        \"$discriminator\": \"disabled\",\r\n        \"DisabledSince\": \"2023-10-02T11:53:24.2011285+00:00\",\r\n        \"Username\": \"Mila\",\r\n        \"PhoneNumbers\": []\r\n    },\r\n    {\r\n        \"$discriminator\": \"disabled\",\r\n        \"DisabledSince\": \"2023-10-02T11:53:24.2011561+00:00\",\r\n        \"Username\": \"Elise\",\r\n        \"PhoneNumbers\": []\r\n    }\r\n]    \r\n\"\"\";\r\n\r\nvar usersFromJson = JsonSerializer.Deserialize<User[]>(jsonAsString);\r\n```\r\n\r\nIf you change the `User` record to instead define the `JsonObjectCreationHandling` on the property, it works for the base `User`, but not for the derived `InactiveUser` (because it has a constructor parameter):\r\n\r\n```\r\n\r\n[JsonDerivedType(typeof(User), typeDiscriminator: \"user\")]\r\n[JsonDerivedType(typeof(InactiveUser), typeDiscriminator: \"inactive\")]\r\n[JsonDerivedType(typeof(DisabledUser), typeDiscriminator: \"disabled\")]\r\n[JsonPolymorphic(TypeDiscriminatorPropertyName = \"$discriminator\")]\r\nrecord User\r\n{\r\n    public string Username { get; set; }\r\n\r\n    [JsonObjectCreationHandling(JsonObjectCreationHandling.Populate)]\r\n    public List<string> PhoneNumbers { get; } = new();\r\n}\r\n```\r\n",
          "createdAt": "2023-10-02T10:53:04Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-10-02T12:00:30Z",
          "id": "IC_kwDODI9FZc5n4QGb"
        },
        {
          "author": "krwq",
          "body": "The bug is here:\r\nhttps://github.com/dotnet/runtime/blob/main/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/Converters/Object/ObjectWithParameterizedConstructorConverter.cs#L338\r\n\r\nIt should be `CanDeserializeOrPopulate` - possibly more places need similar change.",
          "createdAt": "2023-10-02T13:46:58Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-10-02T13:46:58Z",
          "id": "IC_kwDODI9FZc5n5NNP"
        },
        {
          "author": "eiriktsarpalis",
          "body": "On closer inspection, the problem appears to be less trivial than I originally thought. The converter used for serializing types with parameterized constructors will deserialize both constructor parameters and properties _before_ it instantiates the deserialized object. \r\n\r\nThis is not accidental, instantiating the object _depends_  on all constructor parameters being deserialized, but at the same time deserializing properties with populate semantics _depends_ on the object being instantiated ahead of time, so the two requirements are fundamentally in conflict. \r\n\r\nI can't think of any good fixes other than buffering the object's JSON payload and replaying deserialization for properties _after_ instantiation has completed, however that would require a substantial rearchitecting of the parameterized constructor implementation which is probably too risky for a .NET 8 servicing update. My recommendation is to simply mark populate semantics as unsupported in .NET 8 and work on a proper fix in future releases.",
          "createdAt": "2023-10-02T16:45:10Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-10-02T18:17:01Z",
                "user": "jeffhandley"
              },
              {
                "content": "CONFUSED",
                "createdAt": "2023-10-03T01:59:31Z",
                "user": "RenderMichael"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-10-03T07:18:35Z",
                "user": "fekberg"
              }
            ],
            "totalCount": 3,
            "endCursor": "Y3Vyc29yOnYyOpHODIcbfA=="
          },
          "updatedAt": "2023-10-02T16:45:10Z",
          "id": "IC_kwDODI9FZc5n6abO"
        },
        {
          "author": "krwq",
          "body": "Current problem can be worked around like this:\r\n\r\n```csharp\r\nusing System.Text.Json.Serialization;\r\nusing System.Text.Json;\r\nusing System.Text.Json.Serialization.Metadata;\r\n\r\nJsonSerializerOptions options = new()\r\n{\r\n    TypeInfoResolver = new DefaultJsonTypeInfoResolver()\r\n    {\r\n        Modifiers = { PopulateForCollectionsAndDictionariesFix }\r\n    }\r\n};\r\nvar singleUserJson = \"\"\"{\"Name\":\"Filip\",\"PhoneNumbers\":[\"123456\"]}\"\"\";\r\nvar userFromJson = JsonSerializer.Deserialize<User>(singleUserJson, options);\r\nConsole.WriteLine(userFromJson.PhoneNumbers.Count); // 1\r\n\r\n\r\nstatic void PopulateForCollectionsAndDictionariesFix(JsonTypeInfo typeInfo)\r\n{\r\n    foreach (var property in typeInfo.Properties)\r\n    {\r\n        if (property.ObjectCreationHandling == JsonObjectCreationHandling.Populate && property.Set == null)\r\n        {\r\n            // adding a setter causes CanDeserialize flag to be true and populate to work\r\n            property.Set = (obj, val) => throw new JsonException(\"Setter should not be used since this property is Populate\");\r\n        }\r\n    }\r\n}\r\n\r\npublic class User\r\n{\r\n    public User(string name)\r\n        => Name = name;\r\n\r\n    public string Name { get; }\r\n\r\n    [JsonObjectCreationHandling(JsonObjectCreationHandling.Populate)]\r\n    public List<string> PhoneNumbers { get; } = new();\r\n}\r\n```\r\n\r\nI'd prefer we rather went ahead with doing nothing and allow people taking workaround until fix comes in than disallowing this entirely. I think the entire fix is literally replacing CanDeserialize with CanDeserializeAndPopulate in the file I mentioned earlier.",
          "createdAt": "2023-10-03T13:38:57Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-10-03T13:40:24Z",
          "id": "IC_kwDODI9FZc5oApYp"
        },
        {
          "author": "eiriktsarpalis",
          "body": "@krwq this doesn't work if you try to use async:\r\n```C#\r\nJsonSerializerOptions options = new()\r\n{\r\n    TypeInfoResolver = new DefaultJsonTypeInfoResolver()\r\n    {\r\n        Modifiers = { PopulateForCollectionsAndDictionariesFix }\r\n    }\r\n};\r\n\r\nvar stream = new MemoryStream(\"\"\"{\"Name\":\"Filip\",\"PhoneNumbers\":[\"123456\"]}\"\"\"u8.ToArray());\r\nvar userFromJson = await JsonSerializer.DeserializeAsync<User>(stream, options); // exception\r\n\r\n\r\nstatic void PopulateForCollectionsAndDictionariesFix(JsonTypeInfo typeInfo)\r\n{\r\n    foreach (var property in typeInfo.Properties)\r\n    {\r\n        if (property.ObjectCreationHandling == JsonObjectCreationHandling.Populate && property.Set == null)\r\n        {\r\n            // adding a setter causes CanDeserialize flag to be true and populate to work\r\n            property.Set = (obj, val) => throw new JsonException(\"Setter should not be used since this property is Populate\");\r\n        }\r\n    }\r\n}\r\n\r\npublic class User\r\n{\r\n    public User(string name)\r\n        => Name = name;\r\n\r\n    public string Name { get; }\r\n\r\n    [JsonObjectCreationHandling(JsonObjectCreationHandling.Populate)]\r\n    public List<string> PhoneNumbers { get; } = new();\r\n}\r\n```\r\n\r\nFundamentally the issue lies with async deserialization and how it handles parameterized constructors:\r\n\r\nhttps://github.com/dotnet/runtime/blob/d3569b99ead8f909556f5b416b6f57d94f30e668/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/Converters/Object/ObjectWithParameterizedConstructorConverter.cs#L207-L213",
          "createdAt": "2023-10-03T14:38:24Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-10-03T15:58:05Z",
                "user": "krwq"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHODIgJ7Q=="
          },
          "updatedAt": "2023-10-03T14:44:22Z",
          "id": "IC_kwDODI9FZc5oBGBg"
        },
        {
          "author": "eiriktsarpalis",
          "body": "https://github.com/dotnet/runtime/pull/92937 added validation explicitly prohibiting the scenario, moving to 9.0.0 for a proper fix.",
          "createdAt": "2023-10-03T17:10:16Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-10-03T17:10:16Z",
          "id": "IC_kwDODI9FZc5oCJXb"
        },
        {
          "author": "EnCey",
          "body": "It's unfortunate that this won't be in .NET 9 because it's one of the two reasons that force us to create boilerplate constructors: the first is nullability, which has been addressed in preview 6 (🎉) and the other is creating a collection with a specific comparer.\r\n\r\nSince it's not mentioned here or in the [docs](https://learn.microsoft.com/en-us/dotnet/standard/serialization/system-text-json/populate-properties) I want to point it out, as it is a frequent use case for us and requires various workarounds in STJ.\r\n\r\nWe frequently deal with case-insensitive dictionaries or sets and need to create a parameterized JSON constructor simply to deep-copy the dictionary/set created by STJ into one that uses the correct comparer. If we were able to pre-populate the collection property, the need for boilerplate code and deep copies would go away. ",
          "createdAt": "2024-07-22T11:03:55Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-07-22T11:03:55Z",
          "id": "IC_kwDODI9FZc6FrLHy"
        },
        {
          "author": "eiriktsarpalis",
          "body": "@EnCey would you be interested in contributing a fix? We have about 3 weeks left before .NET 9 development freezes.",
          "createdAt": "2024-07-22T11:26:37Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-07-22T11:26:37Z",
          "id": "IC_kwDODI9FZc6FrUrp"
        },
        {
          "author": "EnCey",
          "body": "What would be an acceptable fix @eiriktsarpalis ?\r\n\r\nBased on your post above:\r\n\r\n> I can't think of any good fixes other than buffering the object's JSON payload and replaying deserialization for properties _after_ instantiation has completed, however that would require a substantial rearchitecting of the parameterized constructor implementation which is probably too risky for a .NET 8 servicing update […]\r\n\r\nI suspect that I wouldn't be able to implement such a fundamental change (in time) that meets your quality targets. I'm not familiar with the code base, but I assume performance and memory use are very important to you and a naive solution won't fly.\r\n\r\nIf the use case of case-insensitive collections is deemed important enough, perhaps a simpler solution would be acceptable? Something like an attribute or option that allows a user to specify a comparer for collections, used by STJ when instantiating the collection? \r\n",
          "createdAt": "2024-07-22T11:50:25Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-07-22T11:50:25Z",
          "id": "IC_kwDODI9FZc6Freeb"
        },
        {
          "author": "eiriktsarpalis",
          "body": "> Something like an attribute or option that allows a user to specify a comparer for collections, used by STJ when instantiating the collection?\r\n\r\nThat would require adding new API, unfortunately we're out of time when it comes to adding new features to .NET 9.",
          "createdAt": "2024-07-22T11:59:37Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-07-22T11:59:37Z",
          "id": "IC_kwDODI9FZc6FriZN"
        },
        {
          "author": "eiriktsarpalis",
          "body": "We recently hit this issue in AI related work, so we should probably try to prioritize this.",
          "createdAt": "2024-10-07T15:09:06Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-10-07T15:09:06Z",
          "id": "IC_kwDODI9FZc6O4mfd"
        },
        {
          "author": "rog1039",
          "body": "For what it is worth, I am running into this issue as well. Hoped for .NET 9 fix but would love it if this could be fixed for .NET 10. Stuck with Newtonsoft.Json which is painful for performance reasons.",
          "createdAt": "2024-12-18T22:07:03Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-12-18T22:07:03Z",
          "id": "IC_kwDODI9FZc6YIelD"
        }
      ],
      "totalCount": 13,
      "endCursor": "Y3Vyc29yOnYyOpHOmCHpQw=="
    },
    "url": "https://github.com/dotnet/runtime/issues/92877",
    "title": "JsonObjectCreationHandling.Populate not working with parameterized constructors"
  },
  {
    "author": "eiriktsarpalis",
    "labels": [
      "enhancement",
      "area-System.Text.Json"
    ],
    "createdAt": "2023-10-06T12:58:32Z",
    "body": "Consider the following reproduction:\r\n\r\n```C#\r\nusing System.Text.Json;\r\nusing System.Text.Json.Serialization;\r\n\r\nstring json = \"\"\"{ \"Nested\" : { \"Id\" : \"id\" } }\"\"\";\r\n\r\nMyPoco? result = JsonSerializer.Deserialize<MyPoco>(json);\r\nConsole.WriteLine(result!.Nested.Id); // \"id\"\r\nresult = JsonSerializer.Deserialize<MyPoco>(json, MyContext.Default.MyPoco);\r\nConsole.WriteLine(result!.Nested.Id); // System.InvalidOperationException: Setting init-only properties is not supported in source generation mode.\r\n\r\n[JsonObjectCreationHandling(JsonObjectCreationHandling.Populate)]\r\npublic class MyPoco\r\n{\r\n    public NestedPoco Nested { get; } = new();\r\n}\r\n\r\npublic class NestedPoco\r\n{\r\n    public string Id { get; init; } = \"<null>\";\r\n}\r\n\r\n[JsonSerializable(typeof(MyPoco))]\r\npublic partial class MyContext : JsonSerializerContext { }\r\n```\r\n\r\nThis is most probably expected given the nature of init-only properties in source gen, but perhaps it would make sense to also fail in the case of the reflection serializer (since the current behavior violates the `init` contract of the nested poco).",
    "number": 93114,
    "reactions": {
      "hasNextPage": false,
      "nodes": [],
      "totalCount": 0,
      "endCursor": null
    },
    "updatedAt": "2024-07-05T12:15:49Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\nConsider the following reproduction:\r\n\r\n```C#\r\nusing System.Text.Json;\r\nusing System.Text.Json.Serialization;\r\n\r\nstring json = \"\"\"{ \"Nested\" : { \"Id\" : \"id\" } }\"\"\";\r\n\r\nMyPoco? result = JsonSerializer.Deserialize<MyPoco>(json);\r\nConsole.WriteLine(result!.Nested.Id); // \"id\"\r\nresult = JsonSerializer.Deserialize<MyPoco>(json, MyContext.Default.MyPoco);\r\nConsole.WriteLine(result!.Nested.Id); // System.InvalidOperationException: Setting init-only properties is not supported in source generation mode.\r\n\r\n[JsonObjectCreationHandling(JsonObjectCreationHandling.Populate)]\r\npublic class MyPoco\r\n{\r\n    public NestedPoco Nested { get; } = new();\r\n}\r\n\r\npublic class NestedPoco\r\n{\r\n    public string Id { get; init; } = \"<null>\";\r\n}\r\n\r\n[JsonSerializable(typeof(MyPoco))]\r\npublic partial class MyContext : JsonSerializerContext { }\r\n```\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>eiriktsarpalis</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`area-System.Text.Json`, `untriaged`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2023-10-06T12:58:39Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-10-06T12:58:39Z",
          "id": "IC_kwDODI9FZc5oWJ_u"
        },
        {
          "author": "krwq",
          "body": "something to consider when fixing this: should reflection work when `Nested` is initially `null`?",
          "createdAt": "2023-10-06T13:34:29Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-10-06T13:34:29Z",
          "id": "IC_kwDODI9FZc5oWXJY"
        }
      ],
      "totalCount": 2,
      "endCursor": "Y3Vyc29yOnYyOpHOaFlyWA=="
    },
    "url": "https://github.com/dotnet/runtime/issues/93114",
    "title": "`JsonObjectCreationHandling.Populate` handles init-only properties inconsistently in reflection/source gen"
  },
  {
    "author": "akurone",
    "labels": [
      "api-suggestion",
      "area-System.Text.Json",
      "wishlist"
    ],
    "createdAt": "2023-10-13T13:12:17Z",
    "body": "### Background and motivation\n\nBeyond the [already](https://github.com/dotnet/runtime/issues/77532#issuecomment-1304282950) [discussed](https://github.com/dotnet/runtime/issues/77532#issuecomment-1470583071) (in the issue #77532) benefits, providing a way to apply polymorphic type discriminators to derived types can also provide value for \"discriminated union\" types; consider this:\r\n\r\n```csharp\r\nusing System.Text.Json;\r\nusing System.Text.Json.Serialization;\r\n\r\nvar someC = new TemperatureUnit.Celsius();\r\nvar someF = new TemperatureUnit.Fahrenheit();\r\n\r\nConsole.WriteLine(\"Only the base type provides discriminator info:\");\r\nConsole.WriteLine(JsonSerializer.Serialize(someC as TemperatureUnit)); //{\"$type\":\"Celsius\",\"ExtraA\":5,\"Value\":42}\r\nConsole.WriteLine(JsonSerializer.Serialize(someF as TemperatureUnit)); //{\"$type\":\"Fahrenheit\",\"ExtraB\":10,\"Value\":42}\r\nConsole.WriteLine(\"Derived types don't:\");\r\nConsole.WriteLine(JsonSerializer.Serialize(someC)); //{\"ExtraA\":5,\"Value\":42}\r\nConsole.WriteLine(JsonSerializer.Serialize(someF)); //{\"ExtraB\":10,\"Value\":42}\r\n\r\n[JsonPolymorphic]\r\n[JsonDerivedType(typeof(Celsius), typeDiscriminator: nameof(Celsius))]\r\n[JsonDerivedType(typeof(Fahrenheit), typeDiscriminator: nameof(Fahrenheit))]\r\npublic abstract record TemperatureUnit\r\n{\r\n  public sealed record Celsius : TemperatureUnit { public int ExtraA { get; init; } = 5; }\r\n  public sealed record Fahrenheit : TemperatureUnit { public int ExtraB { get; init; } = 10; }\r\n\r\n  public int Value { get; init; } = 42;\r\n}\r\n```\r\nCurrently there is a [workaround](https://github.com/dotnet/runtime/issues/77532#issuecomment-1300541631) for including discriminator on derived types but it requires the derived type to be **not** `sealed`. And this breaks the use case here:\r\nSince all the intended derived types are nested and `sealed` (and the primary constructor can be marked private if needed), `TemperatureUnit` can be treated as a (fake:)) discriminated union that has a locked in behavior: not extendible, not changeable from outside.\n\n### API Proposal\n\nDirectly copying from @eiriktsarpalis's comment on #77532:\r\n```diff\r\nnamespace System.Text.Json.Serialization;\r\n\r\npublic class JsonPolymorphicAttribute\r\n{\r\n+    public bool ApplyToDerivedTypes { get; set; } = false;\r\n}\r\n```\r\n\r\n> Notes on behaviour:\r\n> \r\n> 1. Uses nearest ancestor resolution to detect any supertype that is polymorphic.\r\n> 2. The flag would trigger an exception in case of diamond ambiguity in interface hierarchies.\r\n> 3. Consequently, derived types specifying JsonDerivedType configuration of their own would override any ancestor polymorphic types.\r\n4. Should also be usable from `JsonTypeInfoResolver`, not just attribute.\r\n\n\n### API Usage\n\n```C#\r\nDerived derived = new Derived(1, 2);\r\n// produces same output for both declared types\r\nJsonSerializer.Serialize<Base>(derived); // {\"$type\":\"derived\",\"y\":2,\"x\":1}\r\nJsonSerializer.Serialize<Derived>(derived); // {\"$type\":\"derived\",\"y\":2,\"x\":1}\r\n\r\n[JsonPolymorphic(ApplyToDerivedTypes = true)]\r\n[JsonDerivedType(typeof(Derived), \"derived\")]\r\npublic record Base(int x);\r\npublic record Derived(int x, int y) : base(x);\r\n```\n\n### Alternative Designs\n\n_No response_\n\n### Risks\n\n_No response_",
    "number": 93471,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-01-13T18:52:53Z",
          "user": "dbc2"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-04-25T09:40:18Z",
          "user": "unsafePtr"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-07-13T10:31:58Z",
          "user": "manandre"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-11-24T14:33:39Z",
          "user": "IhnatKlimchuk"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-03-06T02:53:48Z",
          "user": "StasPerekrestov"
        }
      ],
      "totalCount": 5,
      "endCursor": "Y3Vyc29yOnYyOpHOC_weYw=="
    },
    "updatedAt": "2024-11-24T15:06:31Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\n### Background and motivation\n\nBeyond the [already](https://github.com/dotnet/runtime/issues/77532#issuecomment-1304282950) [discussed](https://github.com/dotnet/runtime/issues/77532#issuecomment-1470583071) (in the issue #77532) benefits, providing a way to apply polymorphic type discriminators to derived types can also provide value for \"discriminated union\" types; consider this:\r\n\r\n```csharp\r\nusing System.Text.Json;\r\nusing System.Text.Json.Serialization;\r\n\r\nvar someC = new TemperatureUnit.Celsius();\r\nvar someF = new TemperatureUnit.Fahrenheit();\r\n\r\nConsole.WriteLine(\"Only the base type provides discriminator info:\");\r\nConsole.WriteLine(JsonSerializer.Serialize(someC as TemperatureUnit)); //{\"$type\":\"Celsius\",\"ExtraA\":5,\"Value\":42}\r\nConsole.WriteLine(JsonSerializer.Serialize(someF as TemperatureUnit)); //{\"$type\":\"Fahrenheit\",\"ExtraB\":10,\"Value\":42}\r\nConsole.WriteLine(\"Derived types don't:\");\r\nConsole.WriteLine(JsonSerializer.Serialize(someC)); //{\"ExtraA\":5,\"Value\":42}\r\nConsole.WriteLine(JsonSerializer.Serialize(someF)); //{\"ExtraB\":10,\"Value\":42}\r\n\r\n[JsonPolymorphic]\r\n[JsonDerivedType(typeof(Celsius), typeDiscriminator: nameof(Celsius))]\r\n[JsonDerivedType(typeof(Fahrenheit), typeDiscriminator: nameof(Fahrenheit))]\r\npublic abstract record TemperatureUnit\r\n{\r\n  public sealed record Celsius : TemperatureUnit { public int ExtraA { get; init; } = 5; }\r\n  public sealed record Fahrenheit : TemperatureUnit { public int ExtraB { get; init; } = 10; }\r\n\r\n  public int Value { get; init; } = 42;\r\n}\r\n```\r\nCurrently there is a [workaround](https://github.com/dotnet/runtime/issues/77532#issuecomment-1300541631) for including discriminator on derived types but it requires the derived type to be **not** `sealed`. And this breaks the use case here:\r\nSince all the intended derived types are nested and `sealed` (and the primary constructor can be marked private if needed), `TemperatureUnit` can be treated as a (fake:)) discriminated union that has a locked in behavior: not extendible, not changeable from outside.\n\n### API Proposal\n\nDirectly copying from @eiriktsarpalis's comment on #77532:\r\n```diff\r\nnamespace System.Text.Json.Serialization;\r\n\r\npublic class JsonPolymorphicAttribute\r\n{\r\n+    public bool ApplyToDerivedTypes { get; set; } = false;\r\n}\r\n```\r\n\r\n> Notes on behaviour:\r\n> \r\n> 1. Uses nearest ancestor resolution to detect any supertype that is polymorphic.\r\n> 2. The flag would trigger an exception in case of diamond ambiguity in interface hierarchies.\r\n> 3. Consequently, derived types specifying JsonDerivedType configuration of their own would override any ancestor polymorphic types.\r\n4. Should also be usable from `JsonTypeInfoResolver`, not just attribute.\r\n\n\n### API Usage\n\n```C#\r\nDerived derived = new Derived(1, 2);\r\n// produces same output for both declared types\r\nJsonSerializer.Serialize<Base>(derived); // {\"$type\":\"derived\",\"y\":2,\"x\":1}\r\nJsonSerializer.Serialize<Derived>(derived); // {\"$type\":\"derived\",\"y\":2,\"x\":1}\r\n\r\n[JsonPolymorphic(ApplyToDerivedTypes = true)]\r\n[JsonDerivedType(typeof(Derived), \"derived\")]\r\npublic record Base(int x);\r\npublic record Derived(int x, int y) : base(x);\r\n```\n\n### Alternative Designs\n\n_No response_\n\n### Risks\n\n_No response_\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>akurone</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`api-suggestion`, `area-System.Text.Json`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2023-10-13T13:12:28Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-10-13T13:12:28Z",
          "id": "IC_kwDODI9FZc5o_li2"
        },
        {
          "author": "IhnatKlimchuk",
          "body": "This feature will be very useful with [GeoJson](https://datatracker.ietf.org/doc/html/rfc7946) and similar standards. You can create not only basic class serialization and deserialization, but also properly serialize class where it's derived class specificly. Example:\n\nDefining classes:\n```csharp\n    [JsonPolymorphic(TypeDiscriminatorPropertyName = \"type\")]\n    [JsonDerivedType(typeof(GeoJsonPoint), typeDiscriminator: nameof(GeometryType.Point))]\n    [JsonDerivedType(typeof(GeoJsonPolygon), typeDiscriminator: nameof(GeometryType.Polygon))]\n    public abstract class GeoJsonGeometry\n    {\n    }\n\n    public class GeoJsonPoint : GeoJsonGeometry\n    {\n        public double[] Coordinates { get; set; }\n    }\n\n    public class GeoJsonPolygon : GeoJsonGeometry\n    {\n        public double[][][] Coordinates { get; set; }\n    }\n```\n\nUsage:\n```csharp\n    ... // defining JsonSerializerOptions\n\n    var point = new GeoJsonPoint\n    {\n        Coordinates = [1, 1]\n    };\n\n    var correct = JsonSerializer.Serialize<GeoJsonGeometry>(point, options); // {\"type\":\"Point\",\"coordinates\":[1,1]} - success, valid GeoJson format\n    var fail = JsonSerializer.Serialize<GeoJsonPoint>(point, options); // {\"coordinates\":[1,1]} - fail, it's not valid GeoJson format\n```\n\nSo adding this can `encourage` more libraries and packages to start using `System.Text.Json` instead of `Newtonsoft.Json` with custom converters, as it will allow seamless and brief integration with GeoJson and similar standards into Elasticsearch ([docs](https://www.elastic.co/guide/en/elasticsearch/reference/current/geo-shape.html)), Opensearch ([docs](https://opensearch.org/docs/latest/field-types/supported-field-types/geo-shape/)), MongoDB ([docs](https://www.mongodb.com/docs/manual/reference/geojson/)), etc.\n\n@eiriktsarpalis I think adding this will greatly improve `System.Text.Json` popularity in 3rd party libs.",
          "createdAt": "2024-11-24T15:05:36Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-11-24T18:21:50Z",
                "user": "manandre"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-11-27T07:32:09Z",
                "user": "akurone"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-12-17T14:37:55Z",
                "user": "mstfgueclue"
              }
            ],
            "totalCount": 3,
            "endCursor": "Y3Vyc29yOnYyOpHOD_VeJA=="
          },
          "updatedAt": "2024-11-24T15:06:31Z",
          "id": "IC_kwDODI9FZc6Uxq-P"
        }
      ],
      "totalCount": 2,
      "endCursor": "Y3Vyc29yOnYyOpHOlMavjw=="
    },
    "url": "https://github.com/dotnet/runtime/issues/93471",
    "title": "[API Proposal]: System.Text.Json Polymorphic Attribute Should Provide an Option to Include Type Discriminators on Derived Types"
  },
  {
    "author": "emrys90",
    "labels": [
      "api-suggestion",
      "area-System.Text.Json",
      "wishlist",
      "source-generator"
    ],
    "createdAt": "2023-10-28T11:32:49Z",
    "body": "Is there a way to \"JavaScriptEncoder.UnsafeRelaxedJsonEscaping\" in JsonSourceGenerationOptions? I want to disable escaping unicode characters in my json. The closest I have found so far is instantiating options and using that with the context, but I would prefer to be able to just use the source generation only.",
    "number": 94135,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-11-22T00:16:03Z",
          "user": "elgonzo"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-12-25T02:54:29Z",
          "user": "mtone"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-01-22T13:31:49Z",
          "user": "moomiji"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-01-26T18:57:06Z",
          "user": "0xfeeddeadbeef"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-02-11T15:43:24Z",
          "user": "Agagamand"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-03-20T23:32:35Z",
          "user": "grbell-ms"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-04-15T10:23:30Z",
          "user": "maxkagamine"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-04-30T09:31:53Z",
          "user": "ceztko"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-05-07T11:39:13Z",
          "user": "blankego"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-05-17T09:10:18Z",
          "user": "Tornhoof"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-08-08T15:11:05Z",
          "user": "andrewmd5"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-10-06T03:41:39Z",
          "user": "MihailsKuzmins"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-10-15T11:50:38Z",
          "user": "frankbuckley"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-10-18T09:10:19Z",
          "user": "WeihanLi"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-11-14T16:16:47Z",
          "user": "jmbryan4"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-11-20T22:25:06Z",
          "user": "DrEsteban"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-12-10T08:51:58Z",
          "user": "mungojam"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-01-15T17:25:46Z",
          "user": "SergTomcat"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-02-18T15:25:31Z",
          "user": "miegir"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-05-20T21:58:56Z",
          "user": "slang25"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-08-25T17:22:45Z",
          "user": "olihou"
        }
      ],
      "totalCount": 21,
      "endCursor": "Y3Vyc29yOnYyOpHODMi9FA=="
    },
    "updatedAt": "2025-02-18T15:29:19Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\nIs there a way to \"JavaScriptEncoder.UnsafeRelaxedJsonEscaping\" in JsonSourceGenerationOptions? I want to disable escaping unicode characters in my json. The closest I have found so far is instantiating options and using that with the context, but I would prefer to be able to just use the source generation only.\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>emrys90</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`area-System.Text.Json`, `untriaged`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2023-10-28T11:33:00Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-10-28T11:33:00Z",
          "id": "IC_kwDODI9FZc5qUmaR"
        },
        {
          "author": "eiriktsarpalis",
          "body": "The problem with `JavaScriptEncoder` is that as a class it's not possible specify its values in attribute annotations. One we've addressed this traditionally is to expose a proxy enum for specifying known values, e.g. something like `JsonKnownEncoder`, however that would leave out the possibility of specifying user-defined encoder types. \r\n\r\nAnother alternative could be to have the attribute accept a `Type` parameter indicating the user-defined encoder type to use, however that leaves out `UnsafeRelaxedJsonEscaping` which currently uses an internal type.",
          "createdAt": "2023-10-29T17:08:01Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-04-18T13:28:18Z",
                "user": "Rebel028"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOEO3iTw=="
          },
          "updatedAt": "2023-10-29T17:08:01Z",
          "id": "IC_kwDODI9FZc5qWETG"
        },
        {
          "author": "emrys90",
          "body": "How about as a virtual method in JsonSerializerContext? The generated constructor could call it to modify any properties on the JsonSerializerOptions before it gets marked as read only.",
          "createdAt": "2023-10-29T22:19:20Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-10-29T22:19:20Z",
          "id": "IC_kwDODI9FZc5qWWtE"
        },
        {
          "author": "eiriktsarpalis",
          "body": "The issue is that the encoder will need to be read and executed at compile-time, which would not be possible to do using a run-time virtual property.",
          "createdAt": "2023-10-30T11:03:37Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-10-30T11:03:37Z",
          "id": "IC_kwDODI9FZc5qZDwS"
        },
        {
          "author": "emrys90",
          "body": "I tried assigning the encoder to the options at runtime using reflection. It appears to be working, but I'm sure there's issues I'm unaware of.\r\n\r\nAn enum option for it would be better than nothing though, if you can provide the most commonly used encoding settings as various options.",
          "createdAt": "2023-10-30T11:23:03Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-10-30T11:23:03Z",
          "id": "IC_kwDODI9FZc5qZKwt"
        },
        {
          "author": "eiriktsarpalis",
          "body": "While it does work, passing an encoder at run-time currently invalidates the use of fast-path serialization, since it requires that property names are encoded at compile-time. While it shouldn't have any impact functionally, it does affect performance. Exposing a setting in the source generator attribute should have provision for compile-time encoding.",
          "createdAt": "2023-10-30T14:46:53Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-10-30T14:46:53Z",
          "id": "IC_kwDODI9FZc5qarV9"
        },
        {
          "author": "emrys90",
          "body": "Ah I see. So for my needs then it sounds like its fine to do it this way? As I am going to have the performance hit either way since I require not escaping unicode characters. Hopefully we can get a way to get it compiled in the future.",
          "createdAt": "2023-10-31T01:50:41Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-10-31T10:31:14Z",
                "user": "eiriktsarpalis"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHODLclgg=="
          },
          "updatedAt": "2023-10-31T01:50:41Z",
          "id": "IC_kwDODI9FZc5qeO4r"
        },
        {
          "author": "blankego",
          "body": "Is there any workaround? My work doens't allow me to produce json in which non-ascii text is being escaped. And If I choose to use JsonSerializerOptions, the AOT compiling warning `RequiresUnreferencedCodeAttribute`  ensues.",
          "createdAt": "2024-05-07T11:46:34Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-05-07T11:46:34Z",
          "id": "IC_kwDODI9FZc59EDhH"
        },
        {
          "author": "eiriktsarpalis",
          "body": "> Is there any workaround? \r\n\r\nYes:\r\n\r\n```C#\r\nvar options = new JsonSerializerOptions\r\n{\r\n    Encoder = JavaScriptEncoder.UnsafeRelaxedJsonEscaping,\r\n};\r\n\r\nvar context = new MyContext(options);\r\nJsonSerializer.Serialize(42, context.Int32);\r\n\r\n[JsonSerializable(typeof(int))]\r\npartial class MyContext : JsonSerializerContext;\r\n```",
          "createdAt": "2024-05-09T12:34:20Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-05-09T13:50:16Z",
                "user": "ceztko"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-06-01T03:10:30Z",
                "user": "dameng324"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-06-09T09:29:29Z",
                "user": "martincostello"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-07-04T18:49:43Z",
                "user": "BDisp"
              },
              {
                "content": "HEART",
                "createdAt": "2024-07-30T23:58:37Z",
                "user": "amercer-fdi"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-09-11T13:03:30Z",
                "user": "TRARS"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-10-18T09:10:58Z",
                "user": "WeihanLi"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-11-14T16:16:57Z",
                "user": "jmbryan4"
              },
              {
                "content": "HEART",
                "createdAt": "2025-01-15T17:26:00Z",
                "user": "SergTomcat"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-07-11T15:54:22Z",
                "user": "dab0bby"
              }
            ],
            "totalCount": 10,
            "endCursor": "Y3Vyc29yOnYyOpHOEaRkpw=="
          },
          "updatedAt": "2024-05-09T12:34:20Z",
          "id": "IC_kwDODI9FZc59Usen"
        },
        {
          "author": "espenrl",
          "body": "Another workaround. It will replace the static property `Default`.\r\n\r\n``` csharp\r\npublic sealed partial class ExampleSerializerContext : JsonSerializerContext\r\n{\r\n    static ExampleSerializerContext()\r\n    {\r\n        // replace default context\r\n        Default = new ExampleSerializerContext(CreateJsonSerializerOptions(Default));\r\n    }\r\n\r\n    private static JsonSerializerOptions CreateJsonSerializerOptions(ExampleSerializerContext defaultContext)\r\n    {\r\n        var encoderSettings = new TextEncoderSettings();\r\n        encoderSettings.AllowRange(UnicodeRanges.BasicLatin);\r\n        encoderSettings.AllowRange(UnicodeRanges.Latin1Supplement); // æøå etc.\r\n\r\n        var options = new JsonSerializerOptions(defaultContext.GeneratedSerializerOptions!)\r\n        {\r\n            Encoder = JavaScriptEncoder.Create(encoderSettings)\r\n        };\r\n\r\n        return options;\r\n    }\r\n}\r\n```",
          "createdAt": "2024-07-16T22:05:12Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-08-16T16:13:39Z",
                "user": "5andr0"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-08-25T18:26:40Z",
                "user": "chrishamm"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-09-03T12:42:41Z",
                "user": "palhal"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-10-18T09:11:32Z",
                "user": "WeihanLi"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-11-14T16:16:58Z",
                "user": "jmbryan4"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-11-20T22:45:36Z",
                "user": "DrEsteban"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-11-22T04:51:30Z",
                "user": "sudoudaisuke"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-12-30T15:51:51Z",
                "user": "scgm0"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-01-15T17:25:59Z",
                "user": "SergTomcat"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-03-29T18:34:33Z",
                "user": "BrunoBlanes"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-04-18T13:29:12Z",
                "user": "Rebel028"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-09-18T17:19:05Z",
                "user": "Stepami"
              }
            ],
            "totalCount": 12,
            "endCursor": "Y3Vyc29yOnYyOpHOEi4VJQ=="
          },
          "updatedAt": "2024-07-16T22:05:12Z",
          "id": "IC_kwDODI9FZc6FCBm5"
        },
        {
          "author": "mungojam",
          "body": "> The problem with `JavaScriptEncoder` is that as a class it's not possible specify its values in attribute annotations. One we've addressed this traditionally is to expose a proxy enum for specifying known values, e.g. something like `JsonKnownEncoder`, however that would leave out the possibility of specifying user-defined encoder types.\n\nI wonder how many people just want to be able to pass in `UnicodeRanges.All` or some other small subset of options. An enum might cater for 95% of use cases.",
          "createdAt": "2024-12-10T08:54:18Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-04-18T13:29:00Z",
                "user": "Rebel028"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-05-07T06:40:50Z",
                "user": "SeWZC"
              }
            ],
            "totalCount": 2,
            "endCursor": "Y3Vyc29yOnYyOpHOERG6KA=="
          },
          "updatedAt": "2024-12-10T08:54:18Z",
          "id": "IC_kwDODI9FZc6W2cFO"
        },
        {
          "author": "miegir",
          "body": "Could it be possible to just separate property name encoding which should be done at compile time from value encoding which happens at runime? We should be able to override runtime encoder then.",
          "createdAt": "2025-02-18T15:29:17Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-02-18T15:29:17Z",
          "id": "IC_kwDODI9FZc6e6Ml8"
        }
      ],
      "totalCount": 12,
      "endCursor": "Y3Vyc29yOnYyOpHOnujJfA=="
    },
    "url": "https://github.com/dotnet/runtime/issues/94135",
    "title": "System.Text.Json JsonSourceGenerationOptions for Encoder?"
  },
  {
    "author": "mihtjel",
    "labels": [
      "area-System.Text.Json"
    ],
    "createdAt": "2023-11-06T13:51:34Z",
    "body": "We have some services returning somewhat complex objects with many sub-objects, including collections as well as references to specific elements in these collections. With the current `System.Text.Json.ReferenceResolver` implementation, I have to choose to either have `$id`-fields on all objects, or none. I would like to be able to only create them where needed, making the output terser.\r\n\r\nI believe this arises from `ReferenceResolver.GetReference` not being allowed to return `null`, which is further enforced and relied upon in `JsonSerializer.Write.HandleMetadata.TryGetReferenceForValue(...)`.\r\n\r\nAs an example, I currently get this:\r\n\r\n```\r\n{\r\n  \"$id\": \"1\",\r\n  \"id\": 1234,\r\n  \"someObject\": {\r\n    \"$id\": \"2\",\r\n    \"someProperty\": \"value\"\r\n  },\r\n  \"someOtherObject\": {\r\n    \"$id\": \"3\",\r\n    \"someCollection\": {\r\n      \"$id\": \"4\",\r\n      \"$values\": [\r\n        {\r\n          \"$id\": \"5\",\r\n          ...\r\n        },\r\n        {\r\n          \"$id\": \"6\",\r\n          ...\r\n        }\r\n      ]\r\n    },\r\n    \"primaryItem\": {\r\n      \"$ref\": \"5\"\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nWhat I really wanted in this case was more like this:\r\n\r\n```\r\n{\r\n  \"id\": 1234,\r\n  \"someObject\": {\r\n    \"someProperty\": \"value\"\r\n  },\r\n  \"someOtherObject\": {\r\n    \"someCollection\": [\r\n        {\r\n            \"$id\": \"1\",\r\n            ...\r\n        },\r\n        {\r\n            \"$id\": \"2\",\r\n            ...\r\n        }\r\n    ],\r\n    \"primaryItem\": {\r\n      \"$ref\": \"1\"\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nI believe the changes required would be fairly limited, mostly in `ReferenceResolver.cs` and `JsonSerializer.Write.HandleMetadata.cs`, although a change to a nullable return type for the `ReferenceResolver.GetReference(...)` method would presumably be breaking for implementations. I can contribute an implementation as a PR if this change to the functionality is agreed with by the project.",
    "number": 94410,
    "reactions": {
      "hasNextPage": false,
      "nodes": [],
      "totalCount": 0,
      "endCursor": null
    },
    "updatedAt": "2023-11-07T15:24:07Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\nWe have some services returning somewhat complex objects with many sub-objects, including collections as well as references to specific elements in these collections. With the current `System.Text.Json.ReferenceResolver` implementation, I have to choose to either have `$id`-fields on all objects, or none. I would like to be able to only create them where needed, making the output terser.\r\n\r\nI believe this arises from `ReferenceResolver.GetReference` not being allowed to return `null`, which is further enforced and relied upon in `JsonSerializer.Write.HandleMetadata.TryGetReferenceForValue(...)`.\r\n\r\nAs an example, I currently get this:\r\n\r\n```\r\n{\r\n  \"$id\": \"1\",\r\n  \"id\": 1234,\r\n  \"someObject\": {\r\n    \"$id\": \"2\",\r\n    \"someProperty\": \"value\"\r\n  },\r\n  \"someOtherObject\": {\r\n    \"$id\": \"3\",\r\n    \"someCollection\": {\r\n      \"$id\": \"4\",\r\n      \"$values\": [\r\n        {\r\n          \"$id\": \"5\",\r\n          ...\r\n        },\r\n        {\r\n          \"$id\": \"6\",\r\n          ...\r\n        }\r\n      ]\r\n    },\r\n    \"primaryItem\": {\r\n      \"$ref\": \"5\"\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nWhat I really wanted in this case was more like this:\r\n\r\n```\r\n{\r\n  \"id\": 1234,\r\n  \"someObject\": {\r\n    \"someProperty\": \"value\"\r\n  },\r\n  \"someOtherObject\": {\r\n    \"someCollection\": [\r\n        {\r\n            \"$id\": \"1\",\r\n            ...\r\n        },\r\n        {\r\n            \"$id\": \"2\",\r\n            ...\r\n        }\r\n    ],\r\n    \"primaryItem\": {\r\n      \"$ref\": \"1\"\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nI believe the changes required would be fairly limited, mostly in `ReferenceResolver.cs` and `JsonSerializer.Write.HandleMetadata.cs`, although a change to a nullable return type for the `ReferenceResolver.GetReference(...)` method would presumably be breaking for implementations. I can contribute an implementation as a PR if this change to the functionality is agreed with by the project.\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>mihtjel</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`area-System.Text.Json`, `untriaged`, `needs-area-label`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2023-11-06T14:18:25Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-11-06T14:18:25Z",
          "id": "IC_kwDODI9FZc5q_H6w"
        },
        {
          "author": "eiriktsarpalis",
          "body": "How would you want to be able to control which objects emit id's? Would it be scoped to specific types, using a predicate on the individual object or something else?",
          "createdAt": "2023-11-06T16:34:59Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-11-06T16:34:59Z",
          "id": "IC_kwDODI9FZc5rA5V3"
        },
        {
          "author": "mihtjel",
          "body": "The short form answer to your question is \"specific types, but really up to the developer writing the ReferenceResolver to determine.\" The rest below is just context :D\r\n\r\nFor the use case prompting this, I have created an Attribute to be used on the key property of any class that is to be referenced - and a custom ReferenceResolver, which then returns an id value of \"propertyName: value\", resulting in `\"$id\": \"propertyName: value\"` in the JSON. This makes some sense in our particular business environment.\r\n\r\nFor example, a Person might have a number of Contracts, each of which have an ContractId, and one of which is the Primary Contract:\r\n```\r\n{\r\n  \"personId\": 123,\r\n  \"contracts\": [\r\n    {\r\n      \"$id\": \"contractId: 1\",\r\n      \"contractId:\" 1,\r\n      \"department\": \"bla bla\",\r\n...\r\n    },{\r\n      \"$id\": \"contractId: 2\",\r\n      \"contractId\": 2,\r\n...\r\n    }\r\n  ],\r\n  \"primaryContract\": {\r\n    \"$ref\": \"contractId: 2\",\r\n```\r\n\r\nHere, I would use my ReferenceKeyAttribute on the ContractId property of the Contract class, indicating that reference IDs should be generated for these objects.",
          "createdAt": "2023-11-06T17:17:18Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-11-06T17:17:18Z",
          "id": "IC_kwDODI9FZc5rBcRu"
        },
        {
          "author": "eiriktsarpalis",
          "body": "> The short form answer to your question is \"specific types, but really up to the developer writing the ReferenceResolver to determine.\" The rest below is just context :D\r\n\r\nRight, but presumably that would require some kind of new API to be added to `ReferenceResolver`, right? Do you envision how that might look?",
          "createdAt": "2023-11-06T18:20:26Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-11-06T18:20:26Z",
          "id": "IC_kwDODI9FZc5rCf66"
        },
        {
          "author": "mihtjel",
          "body": "> Right, but presumably that would require some kind of new API to be added to `ReferenceResolver`, right? Do you envision how that might look?\r\n\r\nSo, as far as I can figure out, if `GetReference` in `ReferenceResolver` had `string?` instead of `string` as the return type, the current code (except for debug assertions) should actually do what I want.\r\n\r\n`GetReference` is called from here:\r\nhttps://github.com/dotnet/runtime/blob/0421836895392126ec33486c0f6d1d90fc07b84a/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/JsonSerializer.Write.HandleMetadata.cs#L77\r\n\r\nAnd looking at `WriteMetadataForObject` in the same file, on L28-32, the `\"$id\"` property is not written if `NewReferenceId` is `null`. \r\n\r\nI believe changing the return type would probably be quite breaking for any existing users of the `ReferenceResolver` class, and I don't have a great design for avoiding this on hand. Adding an `out bool` similar to the current `alreadyExists` may be a more compatible change, but I'm really not that well versed in how to design this sort of API change.\r\n\r\nEdit: Adding a new ReferenceHandlingStrategy to indicate a selective/partial ID assignment strategy might be a viable direction as well.",
          "createdAt": "2023-11-06T18:47:37Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-11-06T18:49:38Z",
          "id": "IC_kwDODI9FZc5rC4gj"
        },
        {
          "author": "mihtjel",
          "body": "I'm back in the office now, and just tried it out: My custom ReferenceResolver uses the tagged property if present, and if no such property existed, it previously generated consecutive IDs a'la PreserveReferenceResolver.\r\n\r\nI replaced this with `return null!;`, and now I only get metadata on the objects where I have specified an ID property. The only remaining issue for me is that it feels very wrong to return null from a method with a non-nullable return type.",
          "createdAt": "2023-11-07T10:13:05Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-11-07T10:13:05Z",
          "id": "IC_kwDODI9FZc5rLmrw"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Perhaps that suggests that the nullability annotations + documentation could be updated to formally support this.",
          "createdAt": "2023-11-07T15:23:53Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-11-13T08:22:42Z",
                "user": "mihtjel"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHODMbu5w=="
          },
          "updatedAt": "2023-11-07T15:23:53Z",
          "id": "IC_kwDODI9FZc5rOHCc"
        }
      ],
      "totalCount": 7,
      "endCursor": "Y3Vyc29yOnYyOpHOazhwnA=="
    },
    "url": "https://github.com/dotnet/runtime/issues/94410",
    "title": "Suggestion: Allow ReferenceResolvers to selectively assign reference IDs"
  },
  {
    "author": "zorix",
    "labels": [
      "api-suggestion",
      "area-System.Text.Json"
    ],
    "createdAt": "2023-11-24T12:47:24Z",
    "body": "### Description\r\n\r\nFollowing description about [Error Handling](https://learn.microsoft.com/en-us/dotnet/standard/serialization/system-text-json/converters-how-to?pivots=dotnet-8-0#error-handling) for Json Converters.\r\nWe can see when we call `throw new JsonException();` without arguments(empty message) it correctly append `Path` and it works, for example I got `{\"The JSON value could not be converted to Flags. Path: $.Flags | LineNumber: 6 | BytePositionInLine: 26.\"}`\r\nBUT\r\nNext example shows `throw new JsonException(\"Error occurred\")` and when message is provided I got only `{\"Error occurred\"}`\r\n\r\n### Reproduction Steps\r\n\r\n1. Throw `throw new JsonException(\"Error occurred\")` from custom JSON Converter\r\n2. See that `Message` doesn't contain `Path` info\r\n\r\n### Expected behavior\r\n\r\nMessage should contain `Path` info\r\n\r\n### Actual behavior\r\n\r\nWhen JsonException is thrown with message, `ThrowHelper` doesn't append info about `Path`\r\n\r\n### Regression?\r\n\r\n_No response_\r\n\r\n### Known Workarounds\r\n\r\n_No response_\r\n\r\n### Configuration\r\n\r\n_No response_\r\n\r\n### Other information\r\n\r\nBehaviour of [AppendPathInformation](https://github.com/dotnet/runtime/blob/main/src/libraries/System.Text.Json/src/System/Text/Json/JsonException.cs#L103) is not allowed to change by user code, for example we can't pass `true` to `JsonException` constructor to change this value also, this property is not public",
    "number": 95205,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "THUMBS_UP",
          "createdAt": "2023-11-24T14:12:34Z",
          "user": "elgonzo"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-09-16T16:46:12Z",
          "user": "Sylvain2703"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-01-04T21:40:38Z",
          "user": "bkoelman"
        }
      ],
      "totalCount": 3,
      "endCursor": "Y3Vyc29yOnYyOpHOC94KIg=="
    },
    "updatedAt": "2023-11-27T12:33:35Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\n### Description\n\nFollowing description about [Error Handling](https://learn.microsoft.com/en-us/dotnet/standard/serialization/system-text-json/converters-how-to?pivots=dotnet-8-0#error-handling) for Json Converters.\r\nWe can see when we call `throw new JsonException();` without arguments(empty message) it correctly append `Path` and it works, for example I got `{\"The JSON value could not be converted to Flags. Path: $.Flags | LineNumber: 6 | BytePositionInLine: 26.\"}`\r\nBUT\r\nNext example shows `throw new JsonException(\"Error occurred\")` and when message is provided I got only `{\"Error occurred\"}`\n\n### Reproduction Steps\n\n1. Throw `throw new JsonException(\"Error occurred\")` from custrom JSON Converter\r\n2. See that `Message` doesn't contain `Path` info\n\n### Expected behavior\n\nMessage should contain `Path` info\n\n### Actual behavior\n\nWhen JsonException is thrown with message, `ThrowHelper` doesn't append info about `Path`\n\n### Regression?\n\n_No response_\n\n### Known Workarounds\n\n_No response_\n\n### Configuration\n\n_No response_\n\n### Other information\n\nBehaviour of [AppendPathInformation](https://github.com/dotnet/runtime/blob/main/src/libraries/System.Text.Json/src/System/Text/Json/JsonException.cs#L103) is not allowed to change by user code, for example we can pass `true` to `JsonException` constructor to change this value also, this property is not public\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>zorix</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`area-System.Text.Json`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2023-11-24T12:47:31Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-11-24T12:47:31Z",
          "id": "IC_kwDODI9FZc5s0ObS"
        },
        {
          "author": "eiriktsarpalis",
          "body": "It's by design, as you're pointing out. We could consider improving this in the future.",
          "createdAt": "2023-11-24T15:52:08Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-11-24T15:52:08Z",
          "id": "IC_kwDODI9FZc5s1D24"
        },
        {
          "author": "zorix",
          "body": "Lets me clarify, when I read this paragraf\r\n```\r\nIf you throw a JsonException without a message, the serializer creates a message that includes the path to\r\nthe part of the JSON that caused the error. For example, the statement throw new JsonException()\r\nproduces an error message like the following example:\r\n```\r\n\r\nNext one says, only about properties that are set, but there is nothing about `Path` will it be set or not, also there is not example for this case\r\n```\r\nIf you do provide a message (for example, throw new JsonException(\"Error occurred\")), the serializer still\r\nsets the Path, LineNumber, and BytePositionInLine properties.\r\n```\r\n\r\nLooking at `NotSupportedException`\r\n```\r\nIf you throw a NotSupportedException, you always get the path information in the message.\r\n```\r\n\r\nI was not exactly sure about Path info, if this is expected, maybe doc should looks like\r\n```\r\nIf you do provide a message (for example, throw new JsonException(\"Error occurred\")), the serializer still sets the Path,\r\nLineNumber, and BytePositionInLine properties, but Message will NOT contain it.\r\n```\r\n\r\nAdding it as a feature would be awesome right code needs manual handling to add Path and also code needs to check for `Path: ` in text already because is some cases it's added. I think it's very confusing how it works now",
          "createdAt": "2023-11-24T18:51:33Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-11-24T18:51:33Z",
          "id": "IC_kwDODI9FZc5s1n9X"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Thank you for the context. I think changing the default behavior at this point would be a breaking change for users relying on the current documented behavior, but we could consider exposing the `AppendPathInformation` property for users to set.",
          "createdAt": "2023-11-27T12:33:01Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-11-27T13:55:07Z",
                "user": "zorix"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-09-16T16:46:07Z",
                "user": "Sylvain2703"
              }
            ],
            "totalCount": 2,
            "endCursor": "Y3Vyc29yOnYyOpHODyZtTA=="
          },
          "updatedAt": "2023-11-27T12:33:01Z",
          "id": "IC_kwDODI9FZc5s8T5c"
        }
      ],
      "totalCount": 4,
      "endCursor": "Y3Vyc29yOnYyOpHObPE-XA=="
    },
    "url": "https://github.com/dotnet/runtime/issues/95205",
    "title": "Consider exposing the `JsonException.AppendPathInformation` property"
  },
  {
    "author": "xbotter",
    "labels": [
      "enhancement",
      "area-System.Text.Json"
    ],
    "createdAt": "2023-12-12T05:38:02Z",
    "body": "### Description\n\nWhen I tried to add a custom JsonConverter attribute to the Encoding property, an error was thrown.\n\n### Reproduction Steps\n\n```C#\r\nvar model = new Model();\r\nConsole.WriteLine(JsonSerializer.Serialize(model));\r\n\r\nclass Model\r\n{\r\n    [JsonConverter(typeof(EncodingConverter))]\r\n    public Encoding Encoding { get; set; } = Encoding.UTF8;\r\n}\r\n\r\ninternal class EncodingConverter : JsonConverter<Encoding>\r\n{\r\n    public override Encoding? Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)\r\n    {\r\n        var name = reader.GetString();\r\n        if (name == null)\r\n            return null;\r\n        return Encoding.GetEncoding(name);\r\n    }\r\n\r\n    public override void Write(Utf8JsonWriter writer, Encoding value, JsonSerializerOptions options)\r\n    {\r\n        writer.WriteStringValue(value.WebName);\r\n    }\r\n}\r\n```\n\n### Expected behavior\n\n{\"Encoding\":\"utf-8\"}\n\n### Actual behavior\n\nUnhandled exception. System.InvalidOperationException: The type 'System.ReadOnlySpan`1[System.Byte]' of property 'Preamble' on type 'System.Text.Encoding' is invalid for serialization or deserialization because it is a pointer type, is a ref struct, or contains generic parameters that have not been replaced by specific types.\r\n   at System.Text.Json.ThrowHelper.ThrowInvalidOperationException_CannotSerializeInvalidType(Type typeToConvert, Type declaringType, MemberInfo memberInfo)\r\n   at System.Text.Json.Serialization.Metadata.DefaultJsonTypeInfoResolver.CreatePropertyInfo(JsonTypeInfo typeInfo, Type typeToConvert, MemberInfo memberInfo, JsonSerializerOptions options, Boolean shouldCheckForRequiredKeyword, Boolean hasJsonIncludeAttribute)\r\n   at System.Text.Json.Serialization.Metadata.DefaultJsonTypeInfoResolver.AddMembersDeclaredBySuperType(JsonTypeInfo typeInfo, Type currentType, Boolean constructorHasSetsRequiredMembersAttribute, PropertyHierarchyResolutionState& state)\r\n   at System.Text.Json.Serialization.Metadata.DefaultJsonTypeInfoResolver.PopulateProperties(JsonTypeInfo typeInfo)\r\n   at System.Text.Json.Serialization.Metadata.DefaultJsonTypeInfoResolver.CreateTypeInfoCore(Type type, JsonConverter converter, JsonSerializerOptions options)\r\n   at System.Text.Json.Serialization.Metadata.DefaultJsonTypeInfoResolver.GetTypeInfo(Type type, JsonSerializerOptions options)\r\n   at System.Text.Json.JsonSerializerOptions.GetTypeInfoNoCaching(Type type)\r\n   at System.Text.Json.JsonSerializerOptions.CachingContext.CreateCacheEntry(Type type, CachingContext context)\r\n--- End of stack trace from previous location ---\r\n   at System.Text.Json.JsonSerializerOptions.GetTypeInfoInternal(Type type, Boolean ensureConfigured, Nullable`1 ensureNotNull, Boolean resolveIfMutable, Boolean fallBackToNearestAncestorType)\r\n   at System.Text.Json.Serialization.Metadata.JsonPropertyInfo.Configure()\r\n   at System.Text.Json.Serialization.Metadata.JsonTypeInfo.ConfigureProperties()\r\n   at System.Text.Json.Serialization.Metadata.JsonTypeInfo.Configure()\r\n   at System.Text.Json.Serialization.Metadata.JsonTypeInfo.<EnsureConfigured>g__ConfigureSynchronized|172_0()\r\n   at System.Text.Json.JsonSerializerOptions.GetTypeInfoInternal(Type type, Boolean ensureConfigured, Nullable`1 ensureNotNull, Boolean resolveIfMutable, Boolean fallBackToNearestAncestorType)\r\n   at System.Text.Json.JsonSerializerOptions.GetTypeInfoForRootType(Type type, Boolean fallBackToNearestAncestorType)\r\n   at System.Text.Json.JsonSerializer.GetTypeInfo[T](JsonSerializerOptions options)\r\n   at System.Text.Json.JsonSerializer.Serialize[TValue](TValue value, JsonSerializerOptions options)\r\n   at Program.<Main>$(String[] args)\n\n### Regression?\n\nnet6.0 🆗  \r\nnet7.0 🆗  \r\nnet8.0 ❌\n\n### Known Workarounds\n\n_No response_\n\n### Configuration\n\n_No response_\n\n### Other information\n\n_No response_",
    "number": 95893,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-04-18T15:22:05Z",
          "user": "dbc2"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-04-17T03:49:11Z",
          "user": "hahn-kev"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-04-20T09:03:18Z",
          "user": "MrJul"
        }
      ],
      "totalCount": 3,
      "endCursor": "Y3Vyc29yOnYyOpHODBaePQ=="
    },
    "updatedAt": "2025-07-01T07:27:00Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\n### Description\n\nWhen I tried to add a custom JsonConverter attribute to the Encoding property, an error was thrown.\n\n### Reproduction Steps\n\n```C#\r\nvar model = new Model();\r\nConsole.WriteLine(JsonSerializer.Serialize(model));\r\n\r\nclass Model\r\n{\r\n    [JsonConverter(typeof(EncodingConverter))]\r\n    public Encoding Encoding { get; set; } = Encoding.UTF8;\r\n}\r\n\r\ninternal class EncodingConverter : JsonConverter<Encoding>\r\n{\r\n    public override Encoding? Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)\r\n    {\r\n        var name = reader.GetString();\r\n        if (name == null)\r\n            return null;\r\n        return Encoding.GetEncoding(name);\r\n    }\r\n\r\n    public override void Write(Utf8JsonWriter writer, Encoding value, JsonSerializerOptions options)\r\n    {\r\n        writer.WriteStringValue(value.WebName);\r\n    }\r\n}\r\n```\n\n### Expected behavior\n\n{\"Encoding\":\"utf-8\"}\n\n### Actual behavior\n\nUnhandled exception. System.InvalidOperationException: The type 'System.ReadOnlySpan`1[System.Byte]' of property 'Preamble' on type 'System.Text.Encoding' is invalid for serialization or deserialization because it is a pointer type, is a ref struct, or contains generic parameters that have not been replaced by specific types.\r\n   at System.Text.Json.ThrowHelper.ThrowInvalidOperationException_CannotSerializeInvalidType(Type typeToConvert, Type declaringType, MemberInfo memberInfo)\r\n   at System.Text.Json.Serialization.Metadata.DefaultJsonTypeInfoResolver.CreatePropertyInfo(JsonTypeInfo typeInfo, Type typeToConvert, MemberInfo memberInfo, JsonSerializerOptions options, Boolean shouldCheckForRequiredKeyword, Boolean hasJsonIncludeAttribute)\r\n   at System.Text.Json.Serialization.Metadata.DefaultJsonTypeInfoResolver.AddMembersDeclaredBySuperType(JsonTypeInfo typeInfo, Type currentType, Boolean constructorHasSetsRequiredMembersAttribute, PropertyHierarchyResolutionState& state)\r\n   at System.Text.Json.Serialization.Metadata.DefaultJsonTypeInfoResolver.PopulateProperties(JsonTypeInfo typeInfo)\r\n   at System.Text.Json.Serialization.Metadata.DefaultJsonTypeInfoResolver.CreateTypeInfoCore(Type type, JsonConverter converter, JsonSerializerOptions options)\r\n   at System.Text.Json.Serialization.Metadata.DefaultJsonTypeInfoResolver.GetTypeInfo(Type type, JsonSerializerOptions options)\r\n   at System.Text.Json.JsonSerializerOptions.GetTypeInfoNoCaching(Type type)\r\n   at System.Text.Json.JsonSerializerOptions.CachingContext.CreateCacheEntry(Type type, CachingContext context)\r\n--- End of stack trace from previous location ---\r\n   at System.Text.Json.JsonSerializerOptions.GetTypeInfoInternal(Type type, Boolean ensureConfigured, Nullable`1 ensureNotNull, Boolean resolveIfMutable, Boolean fallBackToNearestAncestorType)\r\n   at System.Text.Json.Serialization.Metadata.JsonPropertyInfo.Configure()\r\n   at System.Text.Json.Serialization.Metadata.JsonTypeInfo.ConfigureProperties()\r\n   at System.Text.Json.Serialization.Metadata.JsonTypeInfo.Configure()\r\n   at System.Text.Json.Serialization.Metadata.JsonTypeInfo.<EnsureConfigured>g__ConfigureSynchronized|172_0()\r\n   at System.Text.Json.JsonSerializerOptions.GetTypeInfoInternal(Type type, Boolean ensureConfigured, Nullable`1 ensureNotNull, Boolean resolveIfMutable, Boolean fallBackToNearestAncestorType)\r\n   at System.Text.Json.JsonSerializerOptions.GetTypeInfoForRootType(Type type, Boolean fallBackToNearestAncestorType)\r\n   at System.Text.Json.JsonSerializer.GetTypeInfo[T](JsonSerializerOptions options)\r\n   at System.Text.Json.JsonSerializer.Serialize[TValue](TValue value, JsonSerializerOptions options)\r\n   at Program.<Main>$(String[] args)\n\n### Regression?\n\nnet6.0 🆗  \r\nnet7.0 🆗  \r\nnet8.0 ❌\n\n### Known Workarounds\n\n_No response_\n\n### Configuration\n\n_No response_\n\n### Other information\n\n_No response_\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>xbotter</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`area-System.Text.Json`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2023-12-12T05:38:10Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-12-12T05:38:10Z",
          "id": "IC_kwDODI9FZc5uWR7c"
        },
        {
          "author": "eiriktsarpalis",
          "body": "This is an [intentional breaking change](https://learn.microsoft.com/en-us/dotnet/core/compatibility/serialization/8.0/metadata-resolving) introduced in .NET 8. TL;DR the serializer walks the entire type graph to determine whether parts of it are being serialized using the fast-path source generator, but because the custom converter is registered at the property level and not the type itself, an `InvalidOperationException` is thrown.\r\n\r\nYou can work around the issue by registering your custom converter at the type level like so:\r\n```C#\r\nvar options = new JsonSerializerOptions { Converters = { new EncodingConverter() } };\r\nvar model = new Model();\r\nConsole.WriteLine(JsonSerializer.Serialize(model, options)); // {\"Encoding\":\"utf-8\"}\r\n\r\nclass Model\r\n{\r\n    public Encoding Encoding { get; set; } = Encoding.UTF8;\r\n}\r\n```",
          "createdAt": "2023-12-12T09:34:42Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_DOWN",
                "createdAt": "2024-04-18T15:23:02Z",
                "user": "dbc2"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHODerleQ=="
          },
          "updatedAt": "2023-12-12T09:34:42Z",
          "id": "IC_kwDODI9FZc5uXdvD"
        },
        {
          "author": "martindevans",
          "body": "Unfortunately that doesn't really work for this use case.\r\n\r\nThe `Model` is a public class exported from a library (LLamaSharp), which the user might want to serialize. We have various converters which serialize internal parts of the model (note the `EncodingConverter` is `internal`).\r\n\r\nThis means the class can be encoded/decoded and it \"just works\" without any special configuration of the `JsonSerializerOptions` by the user. e.g. we can add new properties in the future with converter attributes and it's still compatible.\r\n\r\nIs there a way for this to work?",
          "createdAt": "2023-12-12T15:33:16Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-04-18T15:24:13Z",
                "user": "dbc2"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHODermTQ=="
          },
          "updatedAt": "2023-12-12T15:33:16Z",
          "id": "IC_kwDODI9FZc5uZ3-3"
        },
        {
          "author": "martindevans",
          "body": "Looking at the docs for the breaking change more closely, I'm not certain it covers the issue we're seeing here. It's talking about new **deserialization** error, however the problem here is a **serialization** failure introduced by upgrading from net6 to net8.\r\n\r\n```csharp\r\n[Fact]\r\npublic void SerializeRoundTripSystemTextJson()\r\n{\r\n    var expected = new ModelParams(\"abc/123\")\r\n    {\r\n        BatchSize = 17,\r\n        ContextSize = 42,\r\n        Seed = 42,\r\n        GpuLayerCount = 111,\r\n        TensorSplits = { [0] = 3 }\r\n    };\r\n\r\n    var json = System.Text.Json.JsonSerializer.Serialize(expected); // <-- the error xbotter posted comes from this line\r\n    var actual = System.Text.Json.JsonSerializer.Deserialize<ModelParams>(json)!;\r\n```",
          "createdAt": "2023-12-12T15:36:49Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-12-12T15:36:49Z",
          "id": "IC_kwDODI9FZc5uZ5tW"
        },
        {
          "author": "eiriktsarpalis",
          "body": "> Is there a way for this to work?\r\n\r\nI would recommend either using a DTO with a plain old string that doesn't encapsulate `Encoding` instances. Alternatively you could try adding a `JsonIgnore` attribute on `Encoding` property and use a satellite string property for serializing the web name. Roughly:\r\n```C#\r\nclass Model\r\n{\r\n    [JsonIgnore]\r\n    public Encoding Encoding { get; set; } = Encoding.UTF8;\r\n    [JsonPropertyName(\"Encoding\")]\r\n    public string EncodingName { get => Encoding.WebName; set { Encoding = Encoding.GetEncoding(value); } }\r\n}\r\n```\r\n\r\nIf you want to hide the satellite from users, you can either 1) mark the field private and also include a `JsonIncludeAttribute` (which doesn't work for source generators) or 2) add an EditorBrowsable.Never annotation.\r\n\r\n> Looking at the docs for the breaking change more closely, I'm not certain it covers the issue we're seeing here.\r\n\r\nThe doc speaks of deserialization failing as one particular symptom of the wider breaking change, but this case still falls under the same umbrella.",
          "createdAt": "2023-12-12T16:03:28Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-12-12T16:05:28Z",
          "id": "IC_kwDODI9FZc5uaGLd"
        },
        {
          "author": "eiriktsarpalis",
          "body": "> (note the EncodingConverter is internal)\r\n\r\nThis is unrelated to the conversation at hand, but given that this is a library component exposed to users I though I'd point out that converters for public types should also be made public because otherwise they won't work with source generated serializers.",
          "createdAt": "2023-12-12T16:08:24Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-12-12T16:54:15Z",
                "user": "martindevans"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHODPVRBQ=="
          },
          "updatedAt": "2023-12-12T16:08:24Z",
          "id": "IC_kwDODI9FZc5uaIfY"
        },
        {
          "author": "martindevans",
          "body": "Thanks for your help, I've gone with something similar to the \"satellite\" property you suggested.",
          "createdAt": "2023-12-12T16:55:48Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2023-12-12T17:45:58Z",
                "user": "eiriktsarpalis"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHODPVqLQ=="
          },
          "updatedAt": "2023-12-12T16:55:48Z",
          "id": "IC_kwDODI9FZc5uaebK"
        },
        {
          "author": "eiriktsarpalis",
          "body": "FWIW this particular scenario was never support in the source generator, and it only happened to work for the case of the reflection-based serializer. Leaving the issue open, since it _might_ be the case that we could work around the issue for both implementations in the future.",
          "createdAt": "2023-12-12T17:48:46Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-12-12T17:48:46Z",
          "id": "IC_kwDODI9FZc5ua1o4"
        },
        {
          "author": "xbotter",
          "body": "> > (note the EncodingConverter is internal)\r\n> \r\n> This is unrelated to the conversation at hand, but given that this is a library component exposed to users I though I'd point out that converters for public types should also be made public because otherwise they won't work with source generated serializers.\r\n\r\nDoes this mean that if I have a custom type, it is more recommended to declare the custom converter on the type rather than on the property?",
          "createdAt": "2023-12-13T04:40:02Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-12-13T04:40:02Z",
          "id": "IC_kwDODI9FZc5udnsa"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Correct.",
          "createdAt": "2023-12-13T14:27:48Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2023-12-13T14:27:48Z",
          "id": "IC_kwDODI9FZc5ughSb"
        },
        {
          "author": "Bazalii",
          "body": "What about generic JsonConverters? \r\n\r\nLets say I have a generic class which contains a property with type that is not serializable(`Span<T>`). I don't want to create a DTO for this model because of perfomance considerations and I also cannot set generic JsonConverter as default converter for my type because I have to explicitly specify type for annotation:\r\n```\r\n// this is not possible\r\n[JsonConverter(typeof(MyConverter<T>))]\r\npublic class MyGeneric<T>\r\n{\r\n    public Span<T> Items { get; }\r\n}\r\n```\r\n\r\nThe only way to solve this issue that I see is to use `[JsonIgnore]` attribute and set `[JsonConverter(typeof(MyConverter<concrete-class-here>))]` annotation for properties of type MyGeneric<T> in objects that I serialize:\r\n```\r\npublic class MyGeneric<T>\r\n{\r\n    [JsonIgnore]\r\n    public Span<T> Items { get; }\r\n}\r\n\r\npublic record MethodResponse\r\n{\r\n    [JsonConverter(typeof(MyConverter<string>))]\r\n    public MyGeneric <T> MyGeneric { get; init; }\r\n}\r\n```\r\n\r\nIn my opinion, this solution requires useless work and need of having `JsonConverter` annotation for every property in DTOs  that contain property of my type while it is known that MyConverter<T> will always be used for serialization of MyGeneric<T>. And I also have to add `[JsonIgnore]` attributes for every not serializable property of my type. \r\n\r\nAre there any better solutions?",
          "createdAt": "2024-05-10T12:06:36Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-05-10T12:06:36Z",
          "id": "IC_kwDODI9FZc59cAYX"
        },
        {
          "author": "hahn-kev",
          "body": "I'm also running into this issue, the only workaround I could come up with (I don't want to register the converter at the root) was to add a modifier to the TypeInfoResolver and use that to set a converter on the property in question.",
          "createdAt": "2025-04-17T03:52:10Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-04-17T03:52:10Z",
          "id": "IC_kwDODI9FZc6nlqNf"
        },
        {
          "author": "bill-poole",
          "body": "I have also run into this issue. It strikes me that the reflection-based serializer should not be validating the shape/properties of a property type if that property is decorated with `[JsonConverter]`. i.e., it seems like that is just wasted effort because the serializer is only going to call the `Read` and `Write` methods on the registered converter anyway. I find the existing behavior very counterintuitive.",
          "createdAt": "2025-07-01T07:27:00Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-07-01T07:27:00Z",
          "id": "IC_kwDODI9FZc60JES8"
        }
      ],
      "totalCount": 13,
      "endCursor": "Y3Vyc29yOnYyOpHOtCREvA=="
    },
    "url": "https://github.com/dotnet/runtime/issues/95893",
    "title": "Allow specifying `JsonConverter` attribute annotations on properties of unsupported type."
  },
  {
    "author": "eiriktsarpalis",
    "labels": [
      "area-System.Text.Json",
      "tenet-performance",
      "wishlist",
      "Cost:L"
    ],
    "createdAt": "2024-01-09T15:22:31Z",
    "body": "The built-in converters for `JsonNode` and `JsonElement` do not currently support async serialization and deserialization. A side-effect of that is that `object` types also don't support async deserialization (since object values are deserialized using either `JsonNode` or `JsonElement` instances, controlled via the [`UnknownTypeHandling` property](https://learn.microsoft.com/en-us/dotnet/api/system.text.json.jsonserializeroptions.unknowntypehandling?view=net-8.0)). This can create performance issues when deserializing large JSON payloads from data streams, since the entire payload needs to be buffered by the serializer before the parser can be called.\r\n\r\nRelated to https://github.com/dotnet/runtime/issues/96559.",
    "number": 96688,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-01-09T17:59:25Z",
          "user": "gregsdennis"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-01-10T15:13:52Z",
          "user": "Mrgaton"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-01-15T05:49:01Z",
          "user": "RenderMichael"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-02-24T15:20:42Z",
          "user": "airbreather"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-04-15T13:21:52Z",
          "user": "warappa"
        }
      ],
      "totalCount": 5,
      "endCursor": "Y3Vyc29yOnYyOpHODBOYww=="
    },
    "updatedAt": "2024-01-10T16:01:43Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\nThe built-in converters for `JsonNode` and `JsonElement` do not currently support async serialization and deserialization. A side-effect of that is that `object` types also don't support async deserialization (since object values are deserialized using either `JsonNode` or `JsonElement` instances, controlled via the [`UnknownTypeHandling` property](https://learn.microsoft.com/en-us/dotnet/api/system.text.json.jsonserializeroptions.unknowntypehandling?view=net-8.0)). This can create performance issues when deserializing large JSON payloads from data streams, since the entire payload needs to be buffered by the serializer before the parser can be called.\r\n\r\nRelated to https://github.com/dotnet/runtime/issues/96559.\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>eiriktsarpalis</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`area-System.Text.Json`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2024-01-09T15:22:38Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-01-09T15:22:38Z",
          "id": "IC_kwDODI9FZc5wQCpY"
        },
        {
          "author": null,
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\nThe built-in converters for `JsonNode` and `JsonElement` do not currently support async serialization and deserialization. A side-effect of that is that `object` types also don't support async deserialization (since object values are deserialized using either `JsonNode` or `JsonElement` instances, controlled via the [`UnknownTypeHandling` property](https://learn.microsoft.com/en-us/dotnet/api/system.text.json.jsonserializeroptions.unknowntypehandling?view=net-8.0)). This can create performance issues when deserializing large JSON payloads from data streams, since the entire payload needs to be buffered by the serializer before the parser can be called.\r\n\r\nRelated to https://github.com/dotnet/runtime/issues/96559.\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>eiriktsarpalis</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`area-System.Text.Json`, `tenet-performance`, `wishlist`, `Cost:L`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>Future</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2024-01-10T16:01:42Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-01-10T16:01:42Z",
          "id": "IC_kwDODI9FZc5wXO_z"
        }
      ],
      "totalCount": 2,
      "endCursor": "Y3Vyc29yOnYyOpHOcFzv8w=="
    },
    "url": "https://github.com/dotnet/runtime/issues/96688",
    "title": "Support async serialization for `JsonNode` and `JsonElement` types."
  },
  {
    "author": "carlossanlop",
    "labels": [
      "area-System.Text.Json",
      "os-mac-os-x",
      "test-bug",
      "arch-x64",
      "runtime-mono",
      "Known Build Error"
    ],
    "createdAt": "2024-01-12T03:46:06Z",
    "body": "### Error Blob\n\n```json\r\n{\r\n  \"ErrorMessage\": \"KioqKioqKioq\",\r\n  \"BuildRetry\": false,\r\n  \"ErrorPattern\": \"\",\r\n  \"ExcludeConsoleLog\": true\r\n}\r\n```\r\n\n\n### Reproduction Steps\n\n- PR: https://github.com/dotnet/runtime/pull/96783\r\n- Build: https://dev.azure.com/dnceng-public/public/_build/results?buildId=522551\r\n- Queue: `Libraries Test Run release mono OSX x64 Debug`\r\n- Run: https://dev.azure.com/dnceng-public/public/_build/results?buildId=522551&view=logs&j=c6f8dc49-92a1-5760-c098-ba97b8142bfb&t=22b0078b-0469-5ba6-8725-2121fdbae049\r\n- Log: https://helixre107v0xdeko0k025g8.blob.core.windows.net/dotnet-runtime-refs-pull-96783-merge-bb9e2883e11a45e8ad/System.Text.Json.Tests/1/console.13232992.log?helixlogtype=result\r\n- Output:\r\n```\r\n===========================================================================================================\r\n/private/tmp/helix/working/B6440A0C/w/B37609D6/e /private/tmp/helix/working/B6440A0C/w/B37609D6/e\r\n  Discovering: System.Text.Json.Tests (method display = ClassAndMethod, method display options = None)\r\n  Discovered:  System.Text.Json.Tests (found 2807 of 2855 test cases)\r\n  Starting:    System.Text.Json.Tests (parallel test collections = on, max threads = 12)\r\n    System.Text.Json.Tests.Utf8JsonWriterTests.Writing3MBBase64Bytes(formatted: True, skipValidation: False) [FAIL]\r\n      Assert.Equal() Failure\r\n                                       ↓ (pos 1371297)\r\n      Expected: ···KioqKioqKioqKioqKioqkioqKioqKioqKioqKioqKioqKioqKioqKioqKioqK···\r\n      Actual:   ···KioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqK···\r\n                                       ↑ (pos 1371297)\r\n      Stack Trace:\r\n        /_/src/libraries/System.Text.Json/tests/System.Text.Json.Tests/JsonTestHelper.cs(738,0): at System.Text.Json.JsonTestHelper.AssertContentsAgainstJsonNet(String expectedValue, String value, Boolean skipSpecialRules)\r\n        /_/src/libraries/System.Text.Json/tests/System.Text.Json.Tests/JsonTestHelper.cs(714,0): at System.Text.Json.JsonTestHelper.AssertContents(String expectedValue, ArrayBufferWriter`1 buffer, Boolean skipSpecialRules)\r\n        /_/src/libraries/System.Text.Json/tests/System.Text.Json.Tests/Utf8JsonWriterTests.cs(3175,0): at System.Text.Json.Tests.Utf8JsonWriterTests.Writing3MBBase64Bytes(Boolean formatted, Boolean skipValidation)\r\n        /_/src/mono/System.Private.CoreLib/src/System/Reflection/RuntimeMethodInfo.cs(370,0): at System.Reflection.RuntimeMethodInfo.Invoke(Object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture)\r\n  Finished:    System.Text.Json.Tests\r\n=== TEST EXECUTION SUMMARY ===\r\n   System.Text.Json.Tests  Total: 19695, Errors: 0, Failed: 1, Skipped: 0, Time: 83.984s\r\n/private/tmp/helix/working/B6440A0C/w/B37609D6/e\r\n----- end Wed Jan 10 19:26:02 EST 2024 ----- exit code 1 ----------------------------------------------------------\r\n```\r\n<!-- Known issue validation start -->\r\n ### Known issue validation\r\n**Build: :mag_right:** https://dev.azure.com/dnceng-public/public/_build/results?buildId=522551\r\n**Error message validated:** `KioqKioqKioq`\r\n**Result validation:** :x: Known issue did not match with the provided build.\r\n**Validation performed at:** 1/12/2024 3:46:27 AM UTC\r\n<!-- Known issue validation end -->\r\n<!--Known issue error report start -->\r\n\r\n### Report\r\n#### Summary\r\n|24-Hour Hit Count|7-Day Hit Count|1-Month Count|\r\n|---|---|---|\r\n|0|0|0|\r\n<!--Known issue error report end -->",
    "number": 96879,
    "reactions": {
      "hasNextPage": false,
      "nodes": [],
      "totalCount": 0,
      "endCursor": null
    },
    "updatedAt": "2025-09-21T04:00:45Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\n### Error Blob\n\n```json\r\n{\r\n  \"ErrorMessage\": \"KioqKioqKioq\",\r\n  \"BuildRetry\": false,\r\n  \"ErrorPattern\": \"\",\r\n  \"ExcludeConsoleLog\": true\r\n}\r\n```\r\n\n\n### Reproduction Steps\n\n- PR: https://github.com/dotnet/runtime/pull/96783\r\n- Build: https://dev.azure.com/dnceng-public/public/_build/results?buildId=522551\r\n- Queue: `Libraries Test Run release mono OSX x64 Debug`\r\n- Run: https://dev.azure.com/dnceng-public/public/_build/results?buildId=522551&view=logs&j=c6f8dc49-92a1-5760-c098-ba97b8142bfb&t=22b0078b-0469-5ba6-8725-2121fdbae049\r\n- Log: https://helixre107v0xdeko0k025g8.blob.core.windows.net/dotnet-runtime-refs-pull-96783-merge-bb9e2883e11a45e8ad/System.Text.Json.Tests/1/console.13232992.log?helixlogtype=result\r\n- Output:\r\n```\r\n===========================================================================================================\r\n/private/tmp/helix/working/B6440A0C/w/B37609D6/e /private/tmp/helix/working/B6440A0C/w/B37609D6/e\r\n  Discovering: System.Text.Json.Tests (method display = ClassAndMethod, method display options = None)\r\n  Discovered:  System.Text.Json.Tests (found 2807 of 2855 test cases)\r\n  Starting:    System.Text.Json.Tests (parallel test collections = on, max threads = 12)\r\n    System.Text.Json.Tests.Utf8JsonWriterTests.Writing3MBBase64Bytes(formatted: True, skipValidation: False) [FAIL]\r\n      Assert.Equal() Failure\r\n                                       ↓ (pos 1371297)\r\n      Expected: ···KioqKioqKioqKioqKioqkioqKioqKioqKioqKioqKioqKioqKioqKioqKioqK···\r\n      Actual:   ···KioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqK···\r\n                                       ↑ (pos 1371297)\r\n      Stack Trace:\r\n        /_/src/libraries/System.Text.Json/tests/System.Text.Json.Tests/JsonTestHelper.cs(738,0): at System.Text.Json.JsonTestHelper.AssertContentsAgainstJsonNet(String expectedValue, String value, Boolean skipSpecialRules)\r\n        /_/src/libraries/System.Text.Json/tests/System.Text.Json.Tests/JsonTestHelper.cs(714,0): at System.Text.Json.JsonTestHelper.AssertContents(String expectedValue, ArrayBufferWriter`1 buffer, Boolean skipSpecialRules)\r\n        /_/src/libraries/System.Text.Json/tests/System.Text.Json.Tests/Utf8JsonWriterTests.cs(3175,0): at System.Text.Json.Tests.Utf8JsonWriterTests.Writing3MBBase64Bytes(Boolean formatted, Boolean skipValidation)\r\n        /_/src/mono/System.Private.CoreLib/src/System/Reflection/RuntimeMethodInfo.cs(370,0): at System.Reflection.RuntimeMethodInfo.Invoke(Object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture)\r\n  Finished:    System.Text.Json.Tests\r\n=== TEST EXECUTION SUMMARY ===\r\n   System.Text.Json.Tests  Total: 19695, Errors: 0, Failed: 1, Skipped: 0, Time: 83.984s\r\n/private/tmp/helix/working/B6440A0C/w/B37609D6/e\r\n----- end Wed Jan 10 19:26:02 EST 2024 ----- exit code 1 ----------------------------------------------------------\r\n```\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>carlossanlop</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`area-System.Text.Json`, `os-mac-os-x`, `arch-x64`, `blocking-clean-ci`, `runtime-mono`, `Known Build Error`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2024-01-12T03:46:10Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-01-12T03:46:10Z",
          "id": "IC_kwDODI9FZc5wjoRZ"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Here's the test in question:\r\n\r\nhttps://github.com/dotnet/runtime/blob/346706614bc9e3345906c4696106c554602e9bf6/src/libraries/System.Text.Json/tests/System.Text.Json.Tests/Utf8JsonWriterTests.cs#L3075-L3130\r\n\r\nThe odd thing is that it appears that it's the expected string that's been corrupted, whereas the actual value is correct. The test itself is pretty old, and I'm not sure I entirely follow its logic -- it appears to be doing some sort of convoluted normalization logic to test an otherwise straightforward property of writing Base64 strings.\r\n",
          "createdAt": "2024-01-12T12:34:15Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-01-12T12:36:15Z",
          "id": "IC_kwDODI9FZc5wmOHb"
        },
        {
          "author": "jeffschwMSFT",
          "body": "was not seen recently... dropping blocking-clean-ci\r\n\r\n24-Hour Hit Count | 7-Day Hit Count | 1-Month Count\r\n-- | -- | --\r\n0 | 0 | 0",
          "createdAt": "2024-02-15T23:13:03Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-02-15T23:13:03Z",
          "id": "IC_kwDODI9FZc50FFkT"
        }
      ],
      "totalCount": 3,
      "endCursor": "Y3Vyc29yOnYyOpHOdBRZEw=="
    },
    "url": "https://github.com/dotnet/runtime/issues/96879",
    "title": "[6.0] Test failure in System.Text.Json.Tests.Utf8JsonWriterTests.Writing3MBBase64Bytes(formatted: True, skipValidation: False)"
  },
  {
    "author": "eiriktsarpalis",
    "labels": [
      "bug",
      "area-System.Text.Json"
    ],
    "createdAt": "2024-01-15T18:25:45Z",
    "body": "A bit of a rare corner case, but the serializer isn't currently handling properties that only override the setter:\r\n```C#\r\nusing System.Text.Json;\r\n\r\nstring json = JsonSerializer.Serialize(new Derived { X = 42 });\r\nConsole.WriteLine(json); // {}\r\n\r\npublic class Base\r\n{\r\n    public virtual int X { get; set; }\r\n}\r\n\r\npublic class Derived : Base\r\n{\r\n    public override int X { set => base.X = value; }\r\n}\r\n```\r\nThis is because the serializer only inspects the signature of the override, but it should instead try to honor the signature of the base definition. Impacts both reflection and source generated serializers.",
    "number": 96996,
    "reactions": {
      "hasNextPage": false,
      "nodes": [],
      "totalCount": 0,
      "endCursor": null
    },
    "updatedAt": "2024-07-16T08:41:55Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\nA bit of a rare corner case, but the serializer isn't currently handling properties that only override the setter:\r\n```C#\r\nusing System.Text.Json;\r\n\r\nstring json = JsonSerializer.Serialize(new Derived { X = 42 });\r\nConsole.WriteLine(json); // {}\r\n\r\npublic class Base\r\n{\r\n    public virtual int X { get; set; }\r\n}\r\n\r\npublic class Derived : Base\r\n{\r\n    public override int X { set => base.X = value; }\r\n}\r\n```\r\nThis is because the serializer only inspects the signature of the override, but it should instead try to honor the signature of the base definition. Impacts both reflection and source generated serializers.\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>eiriktsarpalis</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`area-System.Text.Json`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2024-01-15T18:25:52Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-01-15T18:25:52Z",
          "id": "IC_kwDODI9FZc5wzxPI"
        }
      ],
      "totalCount": 1,
      "endCursor": "Y3Vyc29yOnYyOpHOcM8TyA=="
    },
    "url": "https://github.com/dotnet/runtime/issues/96996",
    "title": "System.Text.Json ignores properties that override the setter only."
  },
  {
    "author": "KalininAndreyVictorovich",
    "labels": [
      "bug",
      "area-System.Text.Json"
    ],
    "createdAt": "2024-01-19T16:57:03Z",
    "body": "### Description\n\nWhen serializing object containing property marked with `[JsonExtensionData]` attribute, serializer produces invalid JSON like this one: `{\"Id\":1,{\"nested\":true}}`\n\n### Reproduction Steps\n\nRun the following code\r\n\r\n```C#\r\nvar mix = new Mix\r\n{\r\n    Id = 1,\r\n    Extra = new() { [\"nested\"] = true, }\r\n};\r\n\r\nvar text = System.Text.Json.JsonSerializer.Serialize(mix);\r\nConsole.WriteLine(text);\r\n// output {\"Id\":1,{\"nested\":true}}\r\n\r\n\r\npublic class Mix\r\n{\r\n    public int Id { get; set; }\r\n\r\n    [System.Text.Json.Serialization.JsonExtensionData]\r\n    public System.Text.Json.Nodes.JsonObject? Extra { get; set; }\r\n}\r\n\r\n```\n\n### Expected behavior\n\nCorrect JSON like `{\"Id\":1,\"nested\":true}` or at least valid JSON as if there was not `[JsonExtensionData]` attribute (`{\"Id\":1,\"Extra\":{\"nested\":true}}` ).\n\n### Actual behavior\n\nInvalid JSON `{\"Id\":1,{\"nested\":true}}`\n\n### Regression?\n\nReproducible at least on .Net 6 to .Net 8\n\n### Known Workarounds\n\n_No response_\n\n### Configuration\n\n.Net 8\r\nWindows 11\r\nx64\n\n### Other information\n\n_No response_",
    "number": 97225,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-03-31T22:16:35Z",
          "user": "Swimburger"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-04-02T23:15:08Z",
          "user": "AdamDavidHill"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-05-31T14:18:48Z",
          "user": "mus65"
        }
      ],
      "totalCount": 3,
      "endCursor": "Y3Vyc29yOnYyOpHODDDHsA=="
    },
    "updatedAt": "2025-03-23T00:59:57Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\n### Description\n\nWhen serializing object containing property marked with `[JsonExtensionData]` attribute, serializer produces invalid JSON like this one: `{\"Id\":1,{\"nested\":true}}`\n\n### Reproduction Steps\n\nRun the following code\r\n\r\n```C#\r\nvar mix = new Mix\r\n{\r\n    Id = 1,\r\n    Extra = new() { [\"nested\"] = true, }\r\n};\r\n\r\nvar text = System.Text.Json.JsonSerializer.Serialize(mix);\r\nConsole.WriteLine(text);\r\n// output {\"Id\":1,{\"nested\":true}}\r\n\r\n\r\npublic class Mix\r\n{\r\n    public int Id { get; set; }\r\n\r\n    [System.Text.Json.Serialization.JsonExtensionData]\r\n    public System.Text.Json.Nodes.JsonObject? Extra { get; set; }\r\n}\r\n\r\n```\n\n### Expected behavior\n\nCorrect JSON like `{\"Id\":1,\"nested\":true}` or at least valid JSON as if there was not `[JsonExtensionData]` attribute (`{\"Id\":1,\"Extra\":{\"nested\":true}}` ).\n\n### Actual behavior\n\nInvalid JSON `{\"Id\":1,{\"nested\":true}}`\n\n### Regression?\n\nReproducible at least on .Net 6 to .Net 8\n\n### Known Workarounds\n\n_No response_\n\n### Configuration\n\n.Net 8\r\nWindows 11\r\nx64\n\n### Other information\n\n_No response_\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>KalininAndreyVictorovich</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`area-System.Text.Json`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2024-01-19T16:57:12Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-01-19T16:57:12Z",
          "id": "IC_kwDODI9FZc5xS15y"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Can confirm that this occurs. It seems we never added testing for the serialization scenario -- deserialization appears to be working as expected.",
          "createdAt": "2024-01-19T17:45:11Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-03-31T22:16:48Z",
                "user": "Swimburger"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOEMTIpg=="
          },
          "updatedAt": "2024-01-19T17:45:11Z",
          "id": "IC_kwDODI9FZc5xTG9g"
        },
        {
          "author": "elgonzo",
          "body": "There is a related question as to whether this scenario is supposed to be allowed or not. Because the [documentation for JsonExtensionDataAttribute](https://learn.microsoft.com/en-us/dotnet/api/system.text.json.serialization.jsonextensiondataattribute?view=net-8.0) states:\r\n\r\n> The dictionary's TKey value **must be** [String](https://learn.microsoft.com/en-us/dotnet/api/system.string?view=net-8.0), and TValue must be [JsonElement](https://learn.microsoft.com/en-us/dotnet/api/system.text.json.jsonelement?view=net-8.0) or [Object](https://learn.microsoft.com/en-us/dotnet/api/system.object?view=net-8.0).\r\n\r\nHowever, the example code in the report uses `JsonObject` as extension data property - an `IDictionary<string, JsonNode>`, which according to the JsonExtensionDataAttribute documentation is not an allowed dictionary type.\r\n\r\nSo, basically the problem is either\r\n- the documentation is correct, but the (de)serializer fails to respond with an appropriate error/exception when encountering an unsupported extension data property type.\r\n- `IDictionary<string, JsonNode>` is supposed to be supported as extension data property type, in which case there is both a bug in the implementation and an error in the `JsonExtensionDataAttribute` documentation.\r\n\r\n<br>\r\n\r\n@eiriktsarpalis \r\n> deserialization appears to be working as expected\r\n\r\nDoes this then mean the [documentation for JsonExtensionDataAttribute](https://learn.microsoft.com/en-us/dotnet/api/system.text.json.serialization.jsonextensiondataattribute?view=net-8.0) is wrong about the types allowed for extension data properties?",
          "createdAt": "2024-01-19T17:52:56Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-03-31T22:17:24Z",
                "user": "Swimburger"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOEMTIzA=="
          },
          "updatedAt": "2024-01-19T17:54:41Z",
          "id": "IC_kwDODI9FZc5xTJUn"
        },
        {
          "author": "eiriktsarpalis",
          "body": "The documentation is correctly stating that `JsonObject` is one of the supported types. However there is a bug specifically impacting serialization for the particular type (FWIW `JsonExtensionData` is a feature primarily oriented towards dserialization).",
          "createdAt": "2024-01-19T17:55:48Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-01-19T17:55:48Z",
          "id": "IC_kwDODI9FZc5xTKMX"
        },
        {
          "author": "elgonzo",
          "body": "> The documentation is correctly stating that `JsonObject` is one of the supported types. [...]\r\n\r\nYou seem to be mistaken. Where does the documentation for [JsonExtensionDataAttribute](https://learn.microsoft.com/en-us/dotnet/api/system.text.json.serialization.jsonextensiondataattribute?view=net-8.0) state this?\r\n\r\nThe related documentation page \"[How to handle overflow JSON or use JsonElement or JsonNode in System.Text.Json](https://learn.microsoft.com/en-us/dotnet/standard/serialization/system-text-json/handle-overflow)\" also does not support your claim:\r\n\r\n> To capture extra data such as these properties, apply the [[JsonExtensionData]](https://learn.microsoft.com/en-us/dotnet/api/system.text.json.serialization.jsonextensiondataattribute) attribute to a property of type Dictionary<string,object> or Dictionary<string,JsonElement>.\r\n\r\n",
          "createdAt": "2024-01-19T17:56:43Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-01-19T18:04:30Z",
          "id": "IC_kwDODI9FZc5xTKeY"
        },
        {
          "author": "eiriktsarpalis",
          "body": "You're right, I misread the documentation which appears to be out of date. The correct statement on supported types can actually be found in the error messages of the implementation itself:\r\n\r\nhttps://github.com/dotnet/runtime/blob/2d751cac7311b344c237df3b3c63b33434b52217/src/libraries/System.Text.Json/gen/Resources/Strings.resx#L150-L152\r\n\r\nIn other words, what I mentioned earlier holds. `JsonObject` _is_ supported and there is a bug specifically concerning serialization.",
          "createdAt": "2024-01-19T18:06:29Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-01-19T18:06:29Z",
          "id": "IC_kwDODI9FZc5xTNpA"
        },
        {
          "author": "elgonzo",
          "body": "Okay. Regarding the documentation being out of date, should i file an issue report with the docs repo, or do you handle this internally between teams?",
          "createdAt": "2024-01-19T18:08:42Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-01-19T18:08:42Z",
          "id": "IC_kwDODI9FZc5xTOaC"
        },
        {
          "author": "eiriktsarpalis",
          "body": "It would help if you could file a separate issue in dotnet-api-docs. Thanks!",
          "createdAt": "2024-01-19T18:12:55Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "HEART",
                "createdAt": "2024-01-19T18:13:03Z",
                "user": "elgonzo"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHODTUqAA=="
          },
          "updatedAt": "2024-01-19T18:12:55Z",
          "id": "IC_kwDODI9FZc5xTRJo"
        },
        {
          "author": "RutulPatel8",
          "body": "> Can confirm that this occurs. It seems we never added testing for the serialization scenario -- deserialization appears to be working as expected.\r\n\r\nYes I have tested with Dot net core 6 version.\r\nIt is reproducible.\r\n![image](https://github.com/dotnet/runtime/assets/84405086/ce08a3f1-e729-4613-9fd9-8690ee8b244a)",
          "createdAt": "2024-01-20T07:02:37Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-01-20T07:02:37Z",
          "id": "IC_kwDODI9FZc5xW27d"
        },
        {
          "author": "TheArcaneBrony",
          "body": "Still reproducible in dotnet 9",
          "createdAt": "2025-03-23T00:59:56Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-03-23T00:59:56Z",
          "id": "IC_kwDODI9FZc6jq8c8"
        }
      ],
      "totalCount": 10,
      "endCursor": "Y3Vyc29yOnYyOpHOo6vHPA=="
    },
    "url": "https://github.com/dotnet/runtime/issues/97225",
    "title": "JsonSerializer.Serialize produces invalid JSON for [JsonExtensionData] property"
  },
  {
    "author": "sahinad",
    "labels": [
      "area-System.Text.Json",
      "tenet-performance"
    ],
    "createdAt": "2024-01-28T15:51:22Z",
    "body": "Hi,\r\n\r\nI have just found out this by running some benchmarks. Below, you'll see my findings.\r\n\r\nHere is my benchmark:\r\n```\r\nusing BenchmarkDotNet.Attributes;\r\nusing System.Text.Json;\r\nusing System.Text.Json.Serialization;\r\n\r\nnamespace Benchmarks;\r\n\r\n[MemoryDiagnoser]\r\npublic class SerializationWithSourceGeneratorBenchmark\r\n{\r\n    private readonly string _ordersJson = \"\"\"\r\n        [\r\n          {\r\n            \"Id\": 1,\r\n            \"OrderNumber\": 1001,\r\n            \"OrderDate\": \"2024-01-25T23:04:22.5061531+01:00\",\r\n            \"OrderStatus\": \"Processing\",\r\n            \"Description\": \"First order description\",\r\n            \"Address\": \"Home\",\r\n            \"BuyerId\": \"buyer001\",\r\n            \"BuyerEmail\": \"buyer001@example.com\"\r\n          },\r\n          {\r\n            \"Id\": 2,\r\n            \"OrderNumber\": 1002,\r\n            \"OrderDate\": \"2024-01-24T23:04:22.5063118+01:00\",\r\n            \"OrderStatus\": \"Shipped\",\r\n            \"Description\": \"Second order description\",\r\n            \"Address\": \"Work\",\r\n            \"BuyerId\": \"buyer002\",\r\n            \"BuyerEmail\": \"buyer002@example.com\"\r\n          },\r\n          {\r\n            \"Id\": 3,\r\n            \"OrderNumber\": 1003,\r\n            \"OrderDate\": \"2024-01-23T23:04:22.50632+01:00\",\r\n            \"OrderStatus\": \"Delivered\",\r\n            \"Description\": \"Third order description\",\r\n            \"Address\": \"Home office\",\r\n            \"BuyerId\": \"buyer003\",\r\n            \"BuyerEmail\": \"buyer003@example.com\"\r\n          }\r\n        ]\r\n        \"\"\";\r\n    private readonly List<Order> _orders =\r\n    [\r\n        new Order\r\n        {\r\n            Id = 1,\r\n            OrderNumber = 1001,\r\n            OrderDate = DateTime.Now,\r\n            OrderStatus = \"Processing\",\r\n            Description = \"First order description\",\r\n            Address = \"Home\",\r\n            BuyerId = \"buyer001\",\r\n            BuyerEmail = \"buyer001@example.com\"\r\n        },\r\n        new Order\r\n        {\r\n            Id = 2,\r\n            OrderNumber = 1002,\r\n            OrderDate = DateTime.Now.AddDays(-1),\r\n            OrderStatus = \"Shipped\",\r\n            Description = \"Second order description\",\r\n            Address = \"Work\",\r\n            BuyerId = \"buyer002\",\r\n            BuyerEmail = \"buyer002@example.com\"\r\n        },\r\n        new Order\r\n        {\r\n            Id = 3,\r\n            OrderNumber = 1003,\r\n            OrderDate = DateTime.Now.AddDays(-2),\r\n            OrderStatus = \"Delivered\",\r\n            Description = \"Third order description\",\r\n            Address = \"Home office\",\r\n            BuyerId = \"buyer003\",\r\n            BuyerEmail = \"buyer003@example.com\"\r\n        }\r\n    ];\r\n\r\n    [Benchmark]\r\n    public string RegularSerialization()\r\n    {\r\n        return JsonSerializer.Serialize(_orders);\r\n    }\r\n\r\n    [Benchmark]\r\n    public string SourceGeneratedSerialization()\r\n    {\r\n        return JsonSerializer.Serialize(_orders, OrderContext.Default.ListOrder);\r\n    }\r\n\r\n    [Benchmark]\r\n    public List<Order>? RegularDeserialization()\r\n    {\r\n        return JsonSerializer.Deserialize<List<Order>>(_ordersJson);\r\n    }\r\n\r\n    [Benchmark]\r\n    public List<Order>? SourceGeneratedDeserialization()\r\n    {\r\n        return JsonSerializer.Deserialize(_ordersJson, OrderContext.Default.ListOrder);\r\n    }\r\n}\r\n\r\n[JsonSerializable(typeof(List<Order>))]\r\npublic sealed partial class OrderContext : JsonSerializerContext\r\n{\r\n\r\n}\r\n\r\npublic sealed class Order\r\n{\r\n    public int Id { get; set; }\r\n    public int OrderNumber { get; set; }\r\n    public DateTime OrderDate { get; set; }\r\n    public required string OrderStatus { get; set; }\r\n    public required string Description { get; set; }\r\n    public required string Address { get; set; }\r\n    public required string BuyerId { get; set; }\r\n    public required string BuyerEmail { get; set; }\r\n}\r\n```\r\n\r\nThe result:\r\n![image](https://github.com/dotnet/runtime/assets/22755247/7290862a-21d1-46bb-b79b-dc3bf759f081)\r\n\r\nIf I make required properties nullable or just remove the required keyword and set them to `null!`, the result changes significantly for deserialization.\r\n\r\nUpdated model:\r\n```\r\npublic sealed class Order\r\n{\r\n    public int Id { get; set; }\r\n    public int OrderNumber { get; set; }\r\n    public DateTime OrderDate { get; set; }\r\n    public string? OrderStatus { get; set; }\r\n    public string? Description { get; set; }\r\n    public string? Address { get; set; }\r\n    public string? BuyerId { get; set; }\r\n    public string? BuyerEmail { get; set; }\r\n}\r\n```\r\n\r\nThe result after the change:\r\n![image](https://github.com/dotnet/runtime/assets/22755247/7cb67c77-30bd-40e0-b783-05312250e0f1)\r\n\r\n\r\nAm I missing something or is this an unexpected behavior?\r\n\r\nThanks in advance!",
    "number": 97612,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-01-28T19:08:04Z",
          "user": "davepcallan"
        }
      ],
      "totalCount": 1,
      "endCursor": "Y3Vyc29yOnYyOpHOC1e59A=="
    },
    "updatedAt": "2024-02-23T16:09:10Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\nHi,\r\n\r\nI have just found out this by running some benchmarks. Below, you'll see my findings.\r\n\r\nHere is my benchmark:\r\n```\r\nusing BenchmarkDotNet.Attributes;\r\nusing System.Text.Json;\r\nusing System.Text.Json.Serialization;\r\n\r\nnamespace Benchmarks;\r\n\r\n[MemoryDiagnoser]\r\npublic class SerializationWithSourceGeneratorBenchmark\r\n{\r\n    private readonly string _ordersJson = \"\"\"\r\n        [\r\n          {\r\n            \"Id\": 1,\r\n            \"OrderNumber\": 1001,\r\n            \"OrderDate\": \"2024-01-25T23:04:22.5061531+01:00\",\r\n            \"OrderStatus\": \"Processing\",\r\n            \"Description\": \"First order description\",\r\n            \"Address\": \"Home\",\r\n            \"BuyerId\": \"buyer001\",\r\n            \"BuyerEmail\": \"buyer001@example.com\"\r\n          },\r\n          {\r\n            \"Id\": 2,\r\n            \"OrderNumber\": 1002,\r\n            \"OrderDate\": \"2024-01-24T23:04:22.5063118+01:00\",\r\n            \"OrderStatus\": \"Shipped\",\r\n            \"Description\": \"Second order description\",\r\n            \"Address\": \"Work\",\r\n            \"BuyerId\": \"buyer002\",\r\n            \"BuyerEmail\": \"buyer002@example.com\"\r\n          },\r\n          {\r\n            \"Id\": 3,\r\n            \"OrderNumber\": 1003,\r\n            \"OrderDate\": \"2024-01-23T23:04:22.50632+01:00\",\r\n            \"OrderStatus\": \"Delivered\",\r\n            \"Description\": \"Third order description\",\r\n            \"Address\": \"Home office\",\r\n            \"BuyerId\": \"buyer003\",\r\n            \"BuyerEmail\": \"buyer003@example.com\"\r\n          }\r\n        ]\r\n        \"\"\";\r\n    private readonly List<Order> _orders =\r\n    [\r\n        new Order\r\n        {\r\n            Id = 1,\r\n            OrderNumber = 1001,\r\n            OrderDate = DateTime.Now,\r\n            OrderStatus = \"Processing\",\r\n            Description = \"First order description\",\r\n            Address = \"Home\",\r\n            BuyerId = \"buyer001\",\r\n            BuyerEmail = \"buyer001@example.com\"\r\n        },\r\n        new Order\r\n        {\r\n            Id = 2,\r\n            OrderNumber = 1002,\r\n            OrderDate = DateTime.Now.AddDays(-1),\r\n            OrderStatus = \"Shipped\",\r\n            Description = \"Second order description\",\r\n            Address = \"Work\",\r\n            BuyerId = \"buyer002\",\r\n            BuyerEmail = \"buyer002@example.com\"\r\n        },\r\n        new Order\r\n        {\r\n            Id = 3,\r\n            OrderNumber = 1003,\r\n            OrderDate = DateTime.Now.AddDays(-2),\r\n            OrderStatus = \"Delivered\",\r\n            Description = \"Third order description\",\r\n            Address = \"Home office\",\r\n            BuyerId = \"buyer003\",\r\n            BuyerEmail = \"buyer003@example.com\"\r\n        }\r\n    ];\r\n\r\n    [Benchmark]\r\n    public string RegularSerialization()\r\n    {\r\n        return JsonSerializer.Serialize(_orders);\r\n    }\r\n\r\n    [Benchmark]\r\n    public string SourceGeneratedSerialization()\r\n    {\r\n        return JsonSerializer.Serialize(_orders, OrderContext.Default.ListOrder);\r\n    }\r\n\r\n    [Benchmark]\r\n    public List<Order>? RegularDeserialization()\r\n    {\r\n        return JsonSerializer.Deserialize<List<Order>>(_ordersJson);\r\n    }\r\n\r\n    [Benchmark]\r\n    public List<Order>? SourceGeneratedDeserialization()\r\n    {\r\n        return JsonSerializer.Deserialize(_ordersJson, OrderContext.Default.ListOrder);\r\n    }\r\n}\r\n\r\n[JsonSerializable(typeof(List<Order>))]\r\npublic sealed partial class OrderContext : JsonSerializerContext\r\n{\r\n\r\n}\r\n\r\npublic sealed class Order\r\n{\r\n    public int Id { get; set; }\r\n    public int OrderNumber { get; set; }\r\n    public DateTime OrderDate { get; set; }\r\n    public required string OrderStatus { get; set; }\r\n    public required string Description { get; set; }\r\n    public required string Address { get; set; }\r\n    public required string BuyerId { get; set; }\r\n    public required string BuyerEmail { get; set; }\r\n}\r\n```\r\n\r\nThe result:\r\n![image](https://github.com/dotnet/runtime/assets/22755247/7290862a-21d1-46bb-b79b-dc3bf759f081)\r\n\r\nIf I make required properties nullable or just remove the required keyword and set them to `null!`, the result changes significantly for deserialization.\r\n\r\nUpdated model:\r\n```\r\npublic sealed class Order\r\n{\r\n    public int Id { get; set; }\r\n    public int OrderNumber { get; set; }\r\n    public DateTime OrderDate { get; set; }\r\n    public string? OrderStatus { get; set; }\r\n    public string? Description { get; set; }\r\n    public string? Address { get; set; }\r\n    public string? BuyerId { get; set; }\r\n    public string? BuyerEmail { get; set; }\r\n}\r\n```\r\n\r\nThe result after the change:\r\n![image](https://github.com/dotnet/runtime/assets/22755247/7cb67c77-30bd-40e0-b783-05312250e0f1)\r\n\r\n\r\nAm I missing something or is this an unexpected behavior?\r\n\r\nThanks in advance!\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>sahinad</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`area-System.Text.Json`, `tenet-performance`, `untriaged`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2024-01-28T15:51:33Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-01-28T15:51:33Z",
          "id": "IC_kwDODI9FZc5yD9kK"
        },
        {
          "author": "eiriktsarpalis",
          "body": "This is expected -- `required` and `init` members are encoded as virtual constructor parameters in the serialization contract (because they cannot be populated using setters). Unfortunately, deserializing via parameterized constructors does come with a slight overhead (related to allocating an intermediate `object[]` containing constructor parameters). It's something we could look at improving in the future.",
          "createdAt": "2024-01-29T10:04:06Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-01-29T17:48:32Z",
                "user": "davepcallan"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-01-29T21:30:42Z",
                "user": "sahinad"
              }
            ],
            "totalCount": 2,
            "endCursor": "Y3Vyc29yOnYyOpHODUjQyg=="
          },
          "updatedAt": "2024-01-29T10:04:06Z",
          "id": "IC_kwDODI9FZc5yGr9l"
        },
        {
          "author": "steveharter",
          "body": "Note there is an existing optimization where the alloc is prevented if there are <= 4 constructor parameters.",
          "createdAt": "2024-02-23T15:53:39Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-02-23T15:53:39Z",
          "id": "IC_kwDODI9FZc5060ZN"
        },
        {
          "author": "eiriktsarpalis",
          "body": "True, but that isn't being used for the case of the source generator.",
          "createdAt": "2024-02-23T16:09:08Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-02-23T16:09:08Z",
          "id": "IC_kwDODI9FZc5066rB"
        }
      ],
      "totalCount": 4,
      "endCursor": "Y3Vyc29yOnYyOpHOdOuqwQ=="
    },
    "url": "https://github.com/dotnet/runtime/issues/97612",
    "title": "System.Text.Json - The parameterized constructor converter allocates intermediate `object[]` when deserializing large arities."
  },
  {
    "author": "gregsdennis",
    "labels": [
      "bug",
      "area-System.Text.Json"
    ],
    "createdAt": "2024-02-02T20:01:16Z",
    "body": "### Description\n\nIt seems that when attempting to deserialize a type that's nested within another, and there's a failure (e.g. wrong JSON type) on the nested data, the reported position information is incorrect.\n\n### Reproduction Steps\n\nRepro: [ConsoleApp1.zip](https://github.com/dotnet/runtime/files/14144780/ConsoleApp1.zip)\r\n\r\nIt might not be minimal, but it's pretty small.\n\n### Expected behavior\n\nThe position in the JSON source should be reported correctly.\n\n### Actual behavior\n\nThe position in the JSON source is not reported correctly.\n\n### Regression?\n\nI'm not sure if this is a regression for source gen, but it definitely works without source gen.\n\n### Known Workarounds\n\nWe've created a number of `JsonSerializerOptions` extension methods in `Json.More` to mitigate this for now, but it's a less desired approach.\n\n### Configuration\n\nLibraries multitargeting .Net Standard 2.0 & .Net 8\r\nTests running in .Net 6 and .Net 8 (fails in both)\r\n\r\nRepro is just .Net 8\n\n### Other information\n\nSome offline context from @eiriktsarpalis:\r\n\r\n> `JsonSerializer.Deserialize` methods acceping a `Ut8fJsonReader`. The methods need to create a new `Utf8JsonReader `that is scoped to the particular JSON value you are trying to deserialize, which in the process loses information on the data that has been read so far.",
    "number": 97893,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-07-22T07:06:33Z",
          "user": "cklutz"
        }
      ],
      "totalCount": 1,
      "endCursor": "Y3Vyc29yOnYyOpHOC5lqdg=="
    },
    "updatedAt": "2024-02-02T21:36:59Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\n### Description\n\nIt seems that when attempting to deserialize a type that's nested within another, and there's a failure (e.g. wrong JSON type) on the nested data, the reported position information is incorrect.\n\n### Reproduction Steps\n\nRepro: [ConsoleApp1.zip](https://github.com/dotnet/runtime/files/14144780/ConsoleApp1.zip)\r\n\r\nIt might not be minimal, but it's pretty small.\n\n### Expected behavior\n\nThe position in the JSON source should be reported correctly.\n\n### Actual behavior\n\nThe position in the JSON source is not reported correctly.\n\n### Regression?\n\nI'm not sure if this is a regression for source gen, but it definitely works without source gen.\n\n### Known Workarounds\n\nWe've created a number of `JsonSerializerOptions` extension methods in `Json.More` to mitigate this for now, but it's a less desired approach.\n\n### Configuration\n\nLibraries multitargeting .Net Standard 2.0 & .Net 8\r\nTests running in .Net 6 and .Net 8 (fails in both)\r\n\r\nRepro is just .Net 8\n\n### Other information\n\nSome offline context from @eiriktsarpalis:\r\n\r\n> `JsonSerializer.Deserialize` methods acceping a `Ut8fJsonReader`. The methods need to create a new `Utf8JsonReader `that is scoped to the particular JSON value you are trying to deserialize, which in the process loses information on the data that has been read so far.\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>gregsdennis</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`area-System.Text.Json`, `untriaged`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2024-02-02T20:01:24Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "LAUGH",
                "createdAt": "2024-02-02T20:01:34Z",
                "user": "gregsdennis"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHODVOJAQ=="
          },
          "updatedAt": "2024-02-02T20:01:24Z",
          "id": "IC_kwDODI9FZc5ytvue"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Minimal reproduction:\r\n\r\n```C#\r\nvar reader = new Utf8JsonReader(\"\"\"\r\n    [\r\n        42\r\n    ]\r\n    \"\"\"u8);\r\n\r\nreader.Read();\r\nreader.Read();\r\n\r\ntry\r\n{\r\n    JsonSerializer.Deserialize<string>(ref reader);\r\n}\r\ncatch (JsonException e)\r\n{\r\n    Console.WriteLine(e.LineNumber); // 0, should be 1\r\n    Console.WriteLine(e.BytePositionInLine); // 2, should be 6\r\n}\r\n```",
          "createdAt": "2024-02-02T21:36:43Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-02-02T23:12:30Z",
                "user": "gregsdennis"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHODVPZyA=="
          },
          "updatedAt": "2024-02-02T21:36:43Z",
          "id": "IC_kwDODI9FZc5yuR23"
        }
      ],
      "totalCount": 2,
      "endCursor": "Y3Vyc29yOnYyOpHOcrkdtw=="
    },
    "url": "https://github.com/dotnet/runtime/issues/97893",
    "title": "Position information lost when calling `JsonSerializer.Deserialize` overloads accepting `Utf8JsonReader`."
  },
  {
    "author": "eiriktsarpalis",
    "labels": [
      "api-suggestion",
      "area-System.Text.Json"
    ],
    "createdAt": "2024-02-06T14:59:38Z",
    "body": "### Background and motivation\r\n\r\nBranching off from the conversation in #29960 and #97801 to consider a potential built-in `object` deserializer that targets .NET primitive values as opposed to targeting the DOM types: `JsonNode` or `JsonElement`. The background is enabling users migrating off of `Json.NET` needing a quick way to support `object` deserialization, provided that the deserialized object is \"simple enough\". This approach is known to create problems w.r.t. loss of fidelity when roundtripping, which is why it was explicitly ruled out when STJ was initially being designed. It is still something we might want to consider as an opt-in accelerator for users that do depend on that behaviour.\r\n\r\nThis proposal would map JSON to .NET types using the following recursive schema:\r\n\r\n* JSON null maps to .NET `null`.\r\n* JSON booleans map to .NET `bool` values.\r\n* JSON numbers map to `int`, `long` or `double`.\r\n* JSON strings map to .NET `string` values.\r\n* JSON arrays map to `List<object?>`.\r\n* JSON objects map to `Dictionary<string, object?>`.\r\n\r\nHere's a reference implementation of the above:\r\n\r\n```C#\r\npublic class NaturalObjectConverter : JsonConverter<object>\r\n{\r\n    public override object? Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)\r\n        => ReadObjectCore(ref reader);\r\n\r\n    public override void Write(Utf8JsonWriter writer, object value, JsonSerializerOptions options)\r\n    {\r\n        Type runtimeType = value.GetType();\r\n        if (runtimeType == typeof(object))\r\n        {\r\n            writer.WriteStartObject();\r\n            writer.WriteEndObject();\r\n        }\r\n        else\r\n        {\r\n            JsonSerializer.Serialize(writer, value, runtimeType, options);\r\n        }\r\n    }\r\n\r\n    private static object? ReadObjectCore(ref Utf8JsonReader reader)\r\n    {\r\n        switch (reader.TokenType)\r\n        {\r\n            case JsonTokenType.Null:\r\n                return null;\r\n\r\n            case JsonTokenType.False or JsonTokenType.True:\r\n                return reader.GetBoolean();\r\n\r\n            case JsonTokenType.Number:\r\n                if (reader.TryGetInt32(out int intValue))\r\n                {\r\n                    return intValue;\r\n                }\r\n                if (reader.TryGetInt64(out long longValue))\r\n                {\r\n                    return longValue;\r\n                }\r\n\r\n                // TODO decimal handling?\r\n                return reader.GetDouble();\r\n\r\n            case JsonTokenType.String:\r\n                return reader.GetString();\r\n\r\n            case JsonTokenType.StartArray:\r\n                var list = new List<object?>();\r\n                while (reader.Read() && reader.TokenType != JsonTokenType.EndArray)\r\n                {\r\n                    object? element = ReadObjectCore(ref reader);\r\n                    list.Add(element);\r\n                }\r\n                return list;\r\n\r\n            case JsonTokenType.StartObject:\r\n                var dict = new Dictionary<string, object?>();\r\n                while (reader.Read() && reader.TokenType != JsonTokenType.EndObject)\r\n                {\r\n                    Debug.Assert(reader.TokenType is JsonTokenType.PropertyName);\r\n                    string propertyName = reader.GetString()!;\r\n\r\n                    if (!reader.Read()) throw new JsonException();\r\n                    object? propertyValue = ReadObjectCore(ref reader);\r\n                    dict[propertyName] = propertyValue;\r\n                }\r\n                return dict;\r\n\r\n            default:\r\n                throw new JsonException();\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nThe reference implementation is intentionally simplistic and necessarily loses fidelity when it comes to its roundtripping abilities. A few noteworthy examples:\r\n\r\n* Values such as `DateTimeOffset`, `TimeSpan` and `Guid` are not roundtripped, instead users get back the string representation of these values. This is done intentionally for consistency, since such a deserialization scheme _cannot_ support all possible types that serialize to string.\r\n* Non-standard numeric representations such as `NaN`, `PositiveInfinity` and `NegativeInfinity` currently serialized as strings using the opt-in `JsonNumberHandling.AllowNamedFloatingPointLiterals` flag are not roundtripped and are instead returned as strings.\r\n* Numeric values can lose fidelity (e.g. `decimal.MaxValue` gets fit into a `double` representation).\r\n\r\n### API Proposal\r\n\r\n```diff\r\nnamespace System.Text.Json.Serialization;\r\n\r\npublic enum JsonUnknownTypeHandling\r\n{\r\n    JsonElement,\r\n    JsonNode,\r\n+    DotNetPrimitives,\r\n}\r\n```\r\n\r\n\r\n### API Usage\r\n\r\n```csharp\r\nvar options = new JsonSerializerOptions { UnknownTypeHandling = JsonUnknownTypeHandling.DotNetPrimitives };\r\n\r\nvar result = JsonSerializer.Deserialize<object>(\"\"\"[null, 1, 3.14, true]\"\"\", options);\r\nConsole.WriteLine(result is List<object>); // True\r\nforeach (object? value in (List<object>)result) Console.WriteLine(value?.GetType()); // null, int, double, bool\r\n```\r\n\r\n\r\n### Alternative Designs\r\n\r\nDo nothing, have users write their own custom converters.\r\n\r\n### Risks\r\n\r\nThere is no one way in which such a \"natural\" converter could be implemented and there also is no way in which the implementation could be extended by users. There is a good risk that users will not be able to use the feature because they require that the converter is able to roundtrip `DateOnly` or `Uri` instances, in which case they would still need to write a custom converter from scratch.\r\n\r\n\r\ncc @stephentoub @bartonjs @tannergooding who might have thoughts on how primitives get roundtripped.",
    "number": 98038,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-02-06T22:13:30Z",
          "user": "SmartmanApps"
        },
        {
          "content": "HEART",
          "createdAt": "2024-03-24T17:22:55Z",
          "user": "CSharpFiasco"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-10-24T02:50:58Z",
          "user": "RenderMichael"
        },
        {
          "content": "HEART",
          "createdAt": "2024-10-24T02:50:59Z",
          "user": "RenderMichael"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-04-04T08:26:23Z",
          "user": "PatrickHofman"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-05-15T10:52:33Z",
          "user": "Dreamescaper"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-07-16T19:37:37Z",
          "user": "ohads-MSFT"
        }
      ],
      "totalCount": 7,
      "endCursor": "Y3Vyc29yOnYyOpHODHSJ3w=="
    },
    "updatedAt": "2025-05-15T11:36:54Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\n### Background and motivation\n\nBranching off from the conversation in #29960 and #97801 to consider a potential built-in `object` deserializer that targets .NET primitive values as opposed to targeting the DOM types: `JsonNode` or `JsonElement`. The background is enabling users migrating off of `Json.NET` needing a quick way to support `object` deserialization, provided that the deserialized object is \"simple enough\". This approach is known to create problems w.r.t. loss of fidelity when roundtripping, which is why it was explicitly ruled out when STJ was initially being designed. It is still something we might want to consider as an opt-in accelerator for users that do depend on that behaviour.\r\n\r\nThis proposal would map JSON to .NET types using the following recursive schema:\r\n\r\n* JSON null maps to .NET `null`.\r\n* JSON booleans map to .NET `bool` values.\r\n* JSON numbers map to `int`, `long` or `double`.\r\n* JSON arrays map to `List<object?>`.\r\n* JSON objects map to `Dictionary<string, object?>`.\r\n\r\nHere's a reference implementation of the above:\r\n\r\n```C#\r\npublic class NaturalObjectConverter : JsonConverter<object>\r\n{\r\n    public override object? Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)\r\n        => ReadObjectCore(ref reader);\r\n\r\n    public override void Write(Utf8JsonWriter writer, object value, JsonSerializerOptions options)\r\n    {\r\n        Type runtimeType = value.GetType();\r\n        if (runtimeType == typeof(object))\r\n        {\r\n            writer.WriteStartObject();\r\n            writer.WriteEndObject();\r\n        }\r\n        else\r\n        {\r\n            JsonSerializer.Serialize(writer, value, runtimeType, options);\r\n        }\r\n    }\r\n\r\n    private static object? ReadObjectCore(ref Utf8JsonReader reader)\r\n    {\r\n        switch (reader.TokenType)\r\n        {\r\n            case JsonTokenType.Null:\r\n                return null;\r\n\r\n            case JsonTokenType.False or JsonTokenType.True:\r\n                return reader.GetBoolean();\r\n\r\n            case JsonTokenType.Number:\r\n                if (reader.TryGetInt32(out int intValue))\r\n                {\r\n                    return intValue;\r\n                }\r\n                if (reader.TryGetInt64(out long longValue))\r\n                {\r\n                    return longValue;\r\n                }\r\n\r\n                // TODO decimal handling?\r\n                return reader.GetDouble();\r\n\r\n            case JsonTokenType.String:\r\n                return reader.GetString();\r\n\r\n            case JsonTokenType.StartArray:\r\n                var list = new List<object?>();\r\n                while (reader.Read() && reader.TokenType != JsonTokenType.EndArray)\r\n                {\r\n                    object? element = ReadObjectCore(ref reader);\r\n                    list.Add(element);\r\n                }\r\n                return list;\r\n\r\n            case JsonTokenType.StartObject:\r\n                var dict = new Dictionary<string, object?>();\r\n                while (reader.Read() && reader.TokenType != JsonTokenType.EndObject)\r\n                {\r\n                    Debug.Assert(reader.TokenType is JsonTokenType.PropertyName);\r\n                    string propertyName = reader.GetString()!;\r\n\r\n                    if (!reader.Read()) throw new JsonException();\r\n                    object? propertyValue = ReadObjectCore(ref reader);\r\n                    dict[propertyName] = propertyValue;\r\n                }\r\n                return dict;\r\n\r\n            default:\r\n                throw new JsonException();\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nThe reference implementation is intentionally simplistic and necessarily loses fidelity when it comes to its roundtripping abilities. A few noteworthy examples:\r\n\r\n* Values such as `DateTimeOffset`, `TimeSpan` and `Guid` are not roundtripped, instead users get back the string representation of these values. This is done intentionally for consistency, since such a deserialization scheme _cannot_ support all possible types that serialize to string.\r\n* Non-standard numeric representations such as `NaN`, `PositiveInfinity` and `NegativeInfinity` currently serialized as strings using the opt-in `JsonNumberHandling.AllowNamedFloatingPointLiterals` flag are not roundtripped and are instead returned as strings.\r\n* Numeric values can lose fidelity (e.g. `decimal.MaxValue` gets fit into a `double` representation).\n\n### API Proposal\n\n```diff\r\nnamespace System.Text.Json.Serialization;\r\n\r\npublic enum JsonUnknownTypeHandling\r\n{\r\n    JsonElement,\r\n    JsonNode,\r\n+    DotNetPrimitives,\r\n}\r\n```\r\n\n\n### API Usage\n\n```csharp\r\nvar options = new JsonSerializerOptions { UnknownTypeHandling = JsonUnknownTypeHandling.DotNetPrimitives };\r\n\r\nvar result = JsonSerializer.Deserialize<object>(\"\"\"[null, 1, 3.14, true]\"\"\", options);\r\nConsole.WriteLine(result is List<object>); // True\r\nforeach (object? value in (List<object>)result) Console.WriteLine(value?.GetType()); // null, int, double, bool\r\n```\r\n\n\n### Alternative Designs\n\nDo nothing, have users write their own custom converters.\n\n### Risks\n\nThere is no one way in which such a \"natural\" converter could be implemented and there also is no way in which the implementation could be extended by users. There is a good risk that users will not be able to use the feature because they require that the converter is able to roundtrip `DateOnly` or `Uri` instances, in which case they would still need to write a custom converter from scratch.\r\n\r\n\r\ncc @stephentoub @bartonjs @tannergooding who might have thoughts on how primitives get roundtripped.\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>eiriktsarpalis</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`api-suggestion`, `area-System.Text.Json`, `untriaged`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2024-02-06T14:59:47Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-02-06T14:59:47Z",
          "id": "IC_kwDODI9FZc5zCPsE"
        },
        {
          "author": "RenderMichael",
          "body": "This would be great. I’ve had to define methods like \r\n\r\n``` csharp \r\nstatic object ToNormalObject(this JsonNode? value)\r\n{\r\n    // basically the same implementation as OP\r\n}\r\n```\r\n\r\nIn my migrations, I’ve had types with properties of `Dictionary<string, object?>` and due to the limitations described in this issue, a lot of the operations I was doing (mostly casting) went from “just working” to `InvalidCastException`s.\r\n\r\nAnother workaround I did was making the property type `JsonObject` and change all the uses of this property to use the JSON type. I didn’t like doing this because it exposed the implementation detail of serialization. But it’s the hardiest solution to the problem, and actually exposed some bugs 😄.",
          "createdAt": "2024-02-08T04:27:06Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-02-08T04:27:06Z",
          "id": "IC_kwDODI9FZc5zPIBH"
        },
        {
          "author": "eiriktsarpalis",
          "body": "> I didn’t like doing this because it exposed the implementation detail of serialization. But it’s the hardiest solution to the problem, and actually exposed some bugs 😄.\r\n\r\nI think that comment is spot on. This functionality is popular simply because it's what Json.NET was doing but it is fundamentally compromised when it comes to round-tripping capability.",
          "createdAt": "2024-02-08T09:14:50Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-02-08T09:14:50Z",
          "id": "IC_kwDODI9FZc5zQSFt"
        },
        {
          "author": "RenderMichael",
          "body": "The biggest problem with fidelity I encountered was numbers being non-roundtrippable. In my opinion the best solution would be to subtype `JsonValue` further for numbers, and add some numeric methods to this `JsonNumber` type, ideally even some generic math.\r\n\r\nAs a JSON number, it would have to follow JavaScript rules, but I think it can be done.\r\n\r\nThat’s a separate issue from deserializing to an `object` though.",
          "createdAt": "2024-02-08T13:40:34Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-02-08T14:20:38Z",
                "user": "eiriktsarpalis"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHODWBabA=="
          },
          "updatedAt": "2024-02-08T13:40:34Z",
          "id": "IC_kwDODI9FZc5zSL2S"
        },
        {
          "author": "eiriktsarpalis",
          "body": "I agree that a `JsonNumber` type would be useful, however substituting it in the existing `JsonNode` hierarchy would be very much a breaking change.",
          "createdAt": "2024-02-08T14:21:15Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-02-08T14:21:43Z",
          "id": "IC_kwDODI9FZc5zSeQ1"
        },
        {
          "author": "RenderMichael",
          "body": "> substituting it in the existing JsonNode hierarchy would be very much a breaking change.\r\n\r\nHow so? If `JsonNumber` is a subtype of `JsonValue`, then I don't see the problem unless there's some `GetType() == typeof(JsonValue)` shenanigans somewhere.\r\n\r\n",
          "createdAt": "2024-02-08T14:25:44Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-02-08T14:25:44Z",
          "id": "IC_kwDODI9FZc5zShAC"
        },
        {
          "author": "eiriktsarpalis",
          "body": "I was incorrectly assuming that `JsonValue<T>` is part of the public API surface, but it seems like it isn't.",
          "createdAt": "2024-02-08T18:20:07Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "EYES",
                "createdAt": "2024-02-08T18:44:43Z",
                "user": "RenderMichael"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHODWDryQ=="
          },
          "updatedAt": "2024-02-08T18:20:07Z",
          "id": "IC_kwDODI9FZc5zURz6"
        },
        {
          "author": "Dreamescaper",
          "body": "This functionality would certainly be useful. I've encountered a requirement to accept a property, which could be either `string`, or `int`, or `string[]`, or `int[]`.\nI had to introduce a custom converter, but would be really nice to be able simply to declare it as object.\n\nI'm willing to contribute it if that helps to bring it in.",
          "createdAt": "2025-05-15T11:36:51Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-05-15T11:36:51Z",
          "id": "IC_kwDODI9FZc6r3tav"
        }
      ],
      "totalCount": 8,
      "endCursor": "Y3Vyc29yOnYyOpHOq97Wrw=="
    },
    "url": "https://github.com/dotnet/runtime/issues/98038",
    "title": "[API Proposal]: Add a `JsonUnknownTypeHandling` setting for deserializing `object` to .NET primitive values"
  },
  {
    "author": "tanveerbadar",
    "labels": [
      "bug",
      "area-System.Text.Json"
    ],
    "createdAt": "2024-02-18T18:20:31Z",
    "body": "### Description\n\nSystem.Text.Json source generator is generating code which fails to compile if the following conditions are met:\r\n\r\n- using polymorphic serialization\r\n- `[JsonSourceGenerationOptions(DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull)]`\r\n- same property name is present in at least two types in an inheritance hierarchy\r\n- their json property names differ, by having different [JsonPropertyName] attributes applied or customized in only some of the types.\n\n### Reproduction Steps\n\nFollowing code demonstrates the problem\r\n\r\n```\r\nusing System.Text.Json.Serialization;\r\n\r\n[JsonPolymorphic]\r\n[JsonDerivedType(typeof(DerivedType))]\r\npartial class BaseType\r\n{\r\n    [JsonPropertyName(\"MoreData\")]\r\n    public string MoreData { get; set; }\r\n}\r\n\r\npartial class DerivedType : BaseType\r\n{\r\n    [JsonPropertyName(\"MoreData2\")]\r\n    public new string MoreData { get; set; }\r\n}\r\n\r\n[JsonSerializable(typeof(BaseType))]\r\n[JsonSourceGenerationOptions(DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull)]\r\npartial class MyContext : JsonSerializerContext\r\n{\r\n}\r\n```\n\n### Expected behavior\n\nGenerated code should have no compilation errors.\n\n### Actual behavior\n\nGenerated code has 2 locals with the same name.\r\n\r\n```\r\n    // Intentionally not a static method because we create a delegate to it. Invoking delegates to instance\r\n    // methods is almost as fast as virtual calls. Static methods need to go through a shuffle thunk.\r\n    private void DerivedTypeSerializeHandler(global::System.Text.Json.Utf8JsonWriter writer, global::DerivedType? value)\r\n    {\r\n        if (value == null)\r\n        {\r\n            writer.WriteNullValue();\r\n            return;\r\n        }\r\n        \r\n        writer.WriteStartObject();\r\n\r\n        string __value_MoreData = ((global::DerivedType)value).MoreData;\r\n        if (__value_MoreData != null)\r\n        {\r\n            writer.WriteString(PropName_MoreData2, __value_MoreData);\r\n        }\r\n        string __value_MoreData = ((global::BaseType)value).MoreData; // Error in this line.\r\n        if (__value_MoreData != null)\r\n        {\r\n            writer.WriteString(PropName_MoreData, __value_MoreData);\r\n        }\r\n\r\n        writer.WriteEndObject();\r\n    }\r\n```\n\n### Regression?\n\nNot sure\n\n### Known Workarounds\n\n_No response_\n\n### Configuration\n\nUsing .net 8, Windows 10, x64.\n\n### Other information\n\n_No response_",
    "number": 98634,
    "reactions": {
      "hasNextPage": false,
      "nodes": [],
      "totalCount": 0,
      "endCursor": null
    },
    "updatedAt": "2024-02-19T12:17:39Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": null,
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<details>\n<summary>Issue Details</summary>\n<hr />\n\n### Description\n\nSystem.Text.Json source generator is generating code which fails to compile if the following conditions are met:\r\n\r\n- using polymorphic serialization\r\n- `[JsonSourceGenerationOptions(DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull)]`\r\n- same property name is present in at least two types in an inheritance hierarchy\r\n- their json property names differ, by having different [JsonPropertyName] attributes applied or customized in only some of the types.\n\n### Reproduction Steps\n\nFollowing code demonstrates the problem\r\n\r\n```\r\nusing System.Text.Json.Serialization;\r\n\r\n[JsonPolymorphic]\r\n[JsonDerivedType(typeof(DerivedType))]\r\npartial class BaseType\r\n{\r\n    [JsonPropertyName(\"MoreData\")]\r\n    public string MoreData { get; set; }\r\n}\r\n\r\npartial class DerivedType : BaseType\r\n{\r\n    [JsonPropertyName(\"MoreData2\")]\r\n    public new string MoreData { get; set; }\r\n}\r\n\r\n[JsonSerializable(typeof(BaseType))]\r\n[JsonSourceGenerationOptions(DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull)]\r\npartial class MyContext : JsonSerializerContext\r\n{\r\n}\r\n```\n\n### Expected behavior\n\nGenerated code should have no compilation errors.\n\n### Actual behavior\n\nGenerated code has 2 locals with the same name.\r\n\r\n```\r\n    // Intentionally not a static method because we create a delegate to it. Invoking delegates to instance\r\n    // methods is almost as fast as virtual calls. Static methods need to go through a shuffle thunk.\r\n    private void DerivedTypeSerializeHandler(global::System.Text.Json.Utf8JsonWriter writer, global::DerivedType? value)\r\n    {\r\n        if (value == null)\r\n        {\r\n            writer.WriteNullValue();\r\n            return;\r\n        }\r\n        \r\n        writer.WriteStartObject();\r\n\r\n        string __value_MoreData = ((global::DerivedType)value).MoreData;\r\n        if (__value_MoreData != null)\r\n        {\r\n            writer.WriteString(PropName_MoreData2, __value_MoreData);\r\n        }\r\n        string __value_MoreData = ((global::BaseType)value).MoreData; // Error in this line.\r\n        if (__value_MoreData != null)\r\n        {\r\n            writer.WriteString(PropName_MoreData, __value_MoreData);\r\n        }\r\n\r\n        writer.WriteEndObject();\r\n    }\r\n```\n\n### Regression?\n\nNot sure\n\n### Known Workarounds\n\n_No response_\n\n### Configuration\n\nUsing .net 8, Windows 10, x64.\n\n### Other information\n\n_No response_\n\n<table>\n  <tr>\n    <th align=\"left\">Author:</th>\n    <td>tanveerbadar</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Assignees:</th>\n    <td>-</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Labels:</th>\n    <td>\n\n`area-System.Text.Json`, `untriaged`\n\n</td>\n  </tr>\n  <tr>\n    <th align=\"left\">Milestone:</th>\n    <td>-</td>\n  </tr>\n</table>\n</details>",
          "createdAt": "2024-02-18T18:20:40Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-02-18T18:20:40Z",
          "id": "IC_kwDODI9FZc50UBbR"
        },
        {
          "author": "eiriktsarpalis",
          "body": "This isn't related to polymorphism per se, here's a minimal reproduction:\r\n\r\n```C#\r\npartial class BaseType\r\n{\r\n    public string? MoreData { get; set; }\r\n}\r\n\r\npartial class DerivedType : BaseType\r\n{\r\n    [JsonPropertyName(\"MoreData2\")]\r\n    public new string? MoreData { get; set; }\r\n}\r\n\r\n[JsonSerializable(typeof(DerivedType))]\r\n[JsonSourceGenerationOptions(DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull)]\r\npartial class MyContext : JsonSerializerContext;\r\n```\r\n\r\nTL;DR the fast-path serializer isn't correctly deduplicating shadowed members when the shadowing type uses a custom property name.\r\n\r\nRelated to https://github.com/dotnet/runtime/issues/97621",
          "createdAt": "2024-02-19T12:15:23Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-02-19T12:16:43Z",
          "id": "IC_kwDODI9FZc50XiZV"
        }
      ],
      "totalCount": 2,
      "endCursor": "Y3Vyc29yOnYyOpHOdF4mVQ=="
    },
    "url": "https://github.com/dotnet/runtime/issues/98634",
    "title": "STJ fast-path generator does not always deduplicate shadowed members correctly."
  },
  {
    "author": "vivet",
    "labels": [
      "area-System.Text.Json"
    ],
    "createdAt": "2024-03-08T05:53:49Z",
    "body": "### Description\n\nWhen serializing with options ```ReferenceHandler.IgnoreCycles``` enabled, looping references will be serialized as null.\n\n### Reproduction Steps\n\nCreating a class structure as shown below and serializing it with ReferenceHandler.IgnoreCycles, produces the following json:\r\n\r\n```json\r\n{\r\n    \"Nested\": {\r\n        \"Samples\": [\r\n            null\r\n        ]\r\n    }\r\n}\r\n```\r\n\r\n```csharp\r\npublic class Sample\r\n{\r\n    public virtual Nested Nested { get; set; }\r\n}\r\npublic class Nested\r\n{\r\n    public virtual IEnumerable<Sample> Samples { get; set; }\r\n}\r\n\r\nvar sample = new Sample();\r\nvar association = new Nested\r\n{\r\n    Samples = new List<Sample> { sample }\r\n};\r\nsample.Nested = association;\r\n\r\nvar json = JsonSerializer.Serialize(sample, new JsonSerializerOptions { ReferenceHandler = ReferenceHandler.IgnoreCycles });\r\n\r\n```\r\n\r\nEven, if adding ```JsonIgnoreCondition.WhenWritingNull```, it will still write the null element in the list.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n\n### Expected behavior\n\nI would expect the json to be serialized as shown below:\r\n\r\n```json\r\n{\r\n    \"Nested\": {\r\n        \"Samples\": [\r\n        ]\r\n    }\r\n}\r\n```\n\n### Actual behavior\n\nThe json looks like below, having inserted a null element in the list.\r\n\r\n```json\r\n{\r\n    \"Nested\": {\r\n        \"Samples\": [\r\n            null\r\n        ]\r\n    }\r\n}\r\n```\n\n### Regression?\n\n_No response_\n\n### Known Workarounds\n\n_No response_\n\n### Configuration\n\n_No response_\n\n### Other information\n\nI discovered the problem when using EntityFramework. If having query with includes, then serializing that model to json and deserializing it back into the model and finally execute and Update in EF. That causes EF to believe there is an element in the list, an  a ```NullReferenceException``` is thrown.",
    "number": 99444,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-03-08T13:49:40Z",
          "user": "BiancaParsePort"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-03-08T13:52:39Z",
          "user": "idan-amiel-wk"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-03-11T05:50:34Z",
          "user": "puff1g"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-03-11T07:21:38Z",
          "user": "IulianBogdan"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-11-06T15:28:31Z",
          "user": "tsoumalis"
        }
      ],
      "totalCount": 5,
      "endCursor": "Y3Vyc29yOnYyOpHOC8coNw=="
    },
    "updatedAt": "2024-03-12T06:04:19Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": "dotnet-policy-service",
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. -->",
          "createdAt": "2024-03-08T05:58:06Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-03-08T05:58:06Z",
          "id": "IC_kwDODI9FZc52Uf-d"
        },
        {
          "author": "eiriktsarpalis",
          "body": "The current behaviour is by design, unfortunately it is hardcoded and there is no way that it can be changed. We might consider adding an additional option in the future provided there is demand and capacity.\r\n\r\n> If having query with includes, then serializing that model to json and deserializing it back into the model and finally execute and Update in EF. That causes EF to believe there is an element in the list, an a NullReferenceException is thrown.\r\n\r\nIf you are trying to round trip a model that contains cycles, silently omitting cyclic nodes is arguably worse since it fundamentally changes the shape of your data in ways that might be difficult to detect. `ReferenceHandler.Preserve` should be a better suited setting for this kind of scenario.",
          "createdAt": "2024-03-11T10:02:10Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-03-11T10:02:10Z",
          "id": "IC_kwDODI9FZc52fvMQ"
        },
        {
          "author": "vivet",
          "body": "Hi \r\n\r\n```ReferenceHandler.Preserve``` would make the cycle endless. Off course I could set max-depth, but I wouldn't know when to stop as I would somehow need to detect if it's cyclic or not. Even if I set ```DefaultIgnoreCondition``` to ignore writing null, the null element is still added. I can't see that there is any case where a null element makes sense, especially not if you instruct the serializer to ignore nulls. \r\n\r\nIf this is indeed by design, then it's not a very good design :-) \r\nFYI: Serializing with Newtonsoft produces the desired json, as an empty array.\r\n\r\n",
          "createdAt": "2024-03-11T11:09:14Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-03-11T11:09:14Z",
          "id": "IC_kwDODI9FZc52gVGK"
        },
        {
          "author": "eiriktsarpalis",
          "body": "> ReferenceHandler.Preserve would make the cycle endless. Off course I could set max-depth, but I wouldn't know when to stop as I would somehow need to detect if it's cyclic or not.\r\n\r\nYou might be misunderstanding how `ReferenceHandler.Preserve` works. Quoting [from the documentation](https://learn.microsoft.com/en-us/dotnet/api/system.text.json.serialization.referencehandler.preserve?view=net-8.0)\r\n\r\n> - On Serialize:\r\n>   - When writing complex reference types, the serializer also writes metadata properties ($id, $values, and $ref) within them.\r\n>   - The output JSON will contain an extra $id property for every object, and for every enumerable type the JSON array emitted will be nested within a JSON object containing an $id and $values property.\r\n>   - ReferenceEquals(Object, Object) is used to determine whether objects are identical.\r\n>   - When an object is identical to a previously serialized one, a pointer ($ref) to the identifier ($id) of such object is written instead.\r\n>   - No metadata properties are written for value types.\r\n\r\nIn other words it emits metadata so that the object graph can be round tripped even in the presence of cycles.\r\n\r\n> If this is indeed by design, then it's not a very good design :-)\r\n\r\nYou're entitled to that opinion, however it is what got shipped and changing it would be a breaking change.",
          "createdAt": "2024-03-11T11:20:44Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-03-11T11:20:44Z",
          "id": "IC_kwDODI9FZc52gaCF"
        },
        {
          "author": "vivet",
          "body": "Hi\r\n\r\nI understand it might be hard to change now, as it will break stuff.\r\nI hope you will consider changing it in the future.\r\n\r\nThanks for the quick reply\r\n",
          "createdAt": "2024-03-12T06:04:03Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-03-12T06:04:19Z",
          "id": "IC_kwDODI9FZc52qC48"
        }
      ],
      "totalCount": 5,
      "endCursor": "Y3Vyc29yOnYyOpHOdqguPA=="
    },
    "url": "https://github.com/dotnet/runtime/issues/99444",
    "title": "System.Text.Json Serialize when ignoring cycles produces undesired json "
  },
  {
    "author": "hugoqribeiro",
    "labels": [
      "enhancement",
      "area-System.Text.Json"
    ],
    "createdAt": "2024-03-13T09:29:48Z",
    "body": "### Description\r\n\r\nIf you define a serializer context (`JsonSerializerContext`) in 2 partial classes, the source generator fails with errors and a warning like this:\r\n\r\n```\r\nWarning\tCS8785\tGenerator 'JsonSourceGenerator' failed to generate source. It will not contribute to the output and compilation errors may occur as a result. Exception was of type 'ArgumentException' with message 'The hintName 'SerializerContext.MyClass1.g.cs' of the added source file must be unique within a generator.\r\n```\r\n\r\nWe are doing this to support the following scenario:\r\n\r\n- The first partial class is produced by a code generator based on metadata.\r\n- We let developers add the second partial class to include classes in the serializer context that are not known to the code generator.\r\n\r\n### Reproduction Steps\r\n\r\nDefine a set of classes that need to be serialized:\r\n\r\n```\r\npublic class MyClass1\r\n{\r\n    // (...)\r\n}\r\n\r\npublic class MyClass2\r\n{\r\n    // (...)\r\n}\r\n```\r\n\r\nDefine a serializer context in a partial class:\r\n\r\n```\r\n[JsonSerializable(typeof(MyClass1))]\r\ninternal partial class SerializerContext : JsonSerializerContext\r\n{\r\n}\r\n```\r\n\r\nDefine another partial class for the same serializer:\r\n\r\n```\r\n[JsonSerializable(typeof(MyClass2))]\r\ninternal partial class SerializerContext\r\n{\r\n}\r\n```\r\n\r\n> This is easily reproducible in a .NET 8 console app.\r\n\r\n### Expected behavior\r\n\r\nThe source generator should be able to generate without errors.\r\n\r\n### Actual behavior\r\n\r\nThe following errors are produced when building:\r\n\r\n```\r\nwarning CS8785: Generator 'JsonSourceGenerator' failed to generate source. It will not contribute to the output and compilation errors may occur as a result. Exception was of type 'ArgumentException' with message 'The hintName 'SerializerContext.MyClass1.g.cs' of the added source file must be unique within a generator.\r\n\r\nerror CS0534: 'SerializerContext' does not implement inherited abstract member 'JsonSerializerContext.GetTypeInfo(Type)'\r\n\r\nerror CS0534: 'SerializerContext' does not implement inherited abstract member 'JsonSerializerContext.GeneratedSerializerOptions.get'\r\n```\r\n\r\n### Regression?\r\n\r\nThis worked correctly in .NET 7.\r\n\r\n### Known Workarounds\r\n\r\nCan't seam to find one...\r\n\r\n### Configuration\r\n\r\n.NET 8.0.102\r\n\r\n### Other information\r\n\r\n_No response_",
    "number": 99669,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-04-20T22:15:54Z",
          "user": "gldraphael"
        }
      ],
      "totalCount": 1,
      "endCursor": "Y3Vyc29yOnYyOpHODBbJoA=="
    },
    "updatedAt": "2025-05-12T07:19:42Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": "dotnet-policy-service",
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. -->",
          "createdAt": "2024-03-13T09:30:06Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-03-13T09:30:06Z",
          "id": "IC_kwDODI9FZc522MLn"
        },
        {
          "author": "martincostello",
          "body": "Does it work if you only put the attribute on one of the two partial declarations?",
          "createdAt": "2024-03-16T03:40:56Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-03-19T10:43:41Z",
                "user": "eiriktsarpalis"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHODbF2RQ=="
          },
          "updatedAt": "2024-03-16T03:40:56Z",
          "id": "IC_kwDODI9FZc53S-3F"
        },
        {
          "author": "eiriktsarpalis",
          "body": "I would inclined to ascribe this to by-design behavior. The source generator is triggered using `JsonSerializableAttribute` annotations, so if the same class declares attributes in multiple locations then generator would be triggered multiple times for the same context type. It wouldn't be easy to reconcile this without compromising the incremental caching properties of the generator.",
          "createdAt": "2024-03-19T10:47:26Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-03-19T10:47:26Z",
          "id": "IC_kwDODI9FZc53nVq-"
        },
        {
          "author": "hugoqribeiro",
          "body": "Have you considered that this worked in version 7.x?\r\n\r\nAnd that this is done with code generation, which implies having 2 locations (the one generated, and the one added by the developer)?",
          "createdAt": "2024-03-22T09:36:57Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-03-22T17:06:23Z",
          "id": "IC_kwDODI9FZc54Ffl4"
        },
        {
          "author": "eiriktsarpalis",
          "body": "You're correct that this used to work in earlier versions. The current behaviour is a direct result of https://github.com/dotnet/runtime/pull/86616, which compiles separate `JsonSerializerContext` declarations independently. This is motivated out of IDE performance concerns: the source generator should only emit code for the context you are currently editing. The drawback of that approach is that it's not possible to group incremental values by a given type without forcing re-evaluation of the entire graph, so the source generator will generate code twice for the same type if `JsonSerializable` are present in multiple declarations.\r\n\r\nGiven that this is a tooling-side regression impacting a rare use case that has a clear workaround, I don't think we should attempt to service this. At the same time, I'll reopen the issue so that we can try improving the situation in the future. For this though, I believe that we would require grouping functionality for the `IncrementalValuesProvider<T>` type in Roslyn.",
          "createdAt": "2024-03-22T11:44:29Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-03-22T17:06:35Z",
                "user": "hugoqribeiro"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHODbkt5A=="
          },
          "updatedAt": "2024-03-22T11:44:29Z",
          "id": "IC_kwDODI9FZc54GRNc"
        },
        {
          "author": "aries-zhang",
          "body": "In my use case there are mainly 2 groups of types that need to be serialized/deserialized. Group 1 is those built-in types, such as `Dictionary<string, string>`, etc. Group 2 is those classes declared in my assembly, such as Class1, Class2, etc. \n\nIt is cumbersome to having to declare `[JsonSerializable(typeof(Class1))]` for every type that needs to be serde'd in a centralized place. Easier to mark these classes in place where they are declared, so I can have a source generator to generate those attributes, so it ends up in:\n\n```\n[HeyThisNeedsToBeSerialized]\npublic class Class1 {\n    ...\n}\n\n[JsonSerializable(typeof(Dictionary<string, string>))] // <-- Types that can't be modified\ninternal partial class SerializerContext : JsonSerializerContext\n{\n}\n\n[JsonSerializable(typeof(Class1))] // <-- types that can be declared as serializable in-place\n[JsonSerializable(typeof(Class2))] \npartial class SerializerContext\n{\n}\n```\nbut this issue makes it impossible to do this. \n\nAlthough wondering if I'm stupidly missing something and there is an easier way to achieve the same?",
          "createdAt": "2025-05-12T07:19:41Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-05-12T07:19:41Z",
          "id": "IC_kwDODI9FZc6rItgx"
        }
      ],
      "totalCount": 6,
      "endCursor": "Y3Vyc29yOnYyOpHOqyLYMQ=="
    },
    "url": "https://github.com/dotnet/runtime/issues/99669",
    "title": "STJ source generator fails when defining the serializer context in 2 partial classes"
  },
  {
    "author": "cosborne83",
    "labels": [
      "area-System.Text.Json",
      "tenet-performance",
      "help wanted"
    ],
    "createdAt": "2024-03-13T11:27:35Z",
    "body": "### Description\r\n\r\nWhilst testing JSON deserialization performance of moderately-sized (10-15KiB) UTF-8 data with the latest System.Text.Json NuGet package (8.0.3), I found that the `JsonSerializer.Deserialize(ref Utf8JsonReader, ...)` overloads seem to be unexpectedly much slower than those taking the data as `string`. The difference is such that it can be faster to convert the underlying UTF-8 bytes to a `string` first and then use a `JsonSerializer.Deserialize(string, ...)` overload instead.\r\n\r\nThe problem seems most pronounced when the JSON data contains string values with many escape sequences (escaped double-quotes in my testing, but others may also exhibit the issue).\r\n\r\n### Configuration\r\n\r\n```\r\nBenchmarkDotNet v0.13.12, Windows 10 (10.0.19044.4046/21H2/November2021Update)\r\n13th Gen Intel Core i9-13900H, 1 CPU, 20 logical and 14 physical cores\r\n.NET SDK 8.0.100\r\n  [Host]     : .NET 8.0.0 (8.0.23.53103), X64 RyuJIT AVX2\r\n  DefaultJob : .NET 8.0.0 (8.0.23.53103), X64 RyuJIT AVX2\r\n```\r\n\r\n### Regression?\r\n\r\nI don't believe so.\r\n\r\n### Data\r\n\r\nThe following code was used to perform the benchmark. I have omitted the JSON data itself from the snippet below due to its size, but can provide it separately.\r\n\r\n```\r\n[MemoryDiagnoser]\r\npublic partial class JsonDeserializeTests\r\n{\r\n    private static readonly JsonTypeInfo<DataRecord> DataRecordTypeInfo = DataRecordContext.Default.DataRecord;\r\n    private static readonly string JsonString = \"\"\"...[omitted for brevity]...\"\"\";\r\n    private static readonly ReadOnlyMemory<byte> JsonUtf8 = Encoding.UTF8.GetBytes(JsonString).ToArray();\r\n\r\n    [Benchmark(Baseline = true)]\r\n    public DataRecord? DeserializeSpan()\r\n    {\r\n        return JsonSerializer.Deserialize(JsonUtf8.Span, DataRecordTypeInfo);\r\n    }\r\n\r\n    [Benchmark]\r\n    public DataRecord? DeserializeStringFromUtf8()\r\n    {\r\n        return JsonSerializer.Deserialize(Encoding.UTF8.GetString(JsonUtf8.Span), DataRecordTypeInfo);\r\n    }\r\n\r\n    [Benchmark]\r\n    public DataRecord? DeserializeJsonReader()\r\n    {\r\n        var reader = new Utf8JsonReader(JsonUtf8.Span);\r\n        return JsonSerializer.Deserialize(ref reader, DataRecordTypeInfo);\r\n    }\r\n}\r\n\r\n[JsonSerializable(typeof(DataRecord))]\r\npublic partial class DataRecordContext : JsonSerializerContext\r\n{\r\n}\r\n\r\npublic class DataRecord(string? u825587097135, string u30475139121, string c876626645106780540461092564)\r\n{\r\n    public string? U825587097135 { get; } = u825587097135;\r\n    public string? U30475139121 { get; } = u30475139121;\r\n    public string? C876626645106780540461092564 { get; } = c876626645106780540461092564;\r\n}\r\n```\r\n\r\n| Method                    | Mean     | Error    | StdDev   | Ratio | RatioSD | Gen0   | Allocated | Alloc Ratio |\r\n|-------------------------- |---------:|---------:|---------:|------:|--------:|-------:|----------:|------------:|\r\n| DeserializeSpan           | 16.37 μs | 0.155 μs | 0.137 μs |  1.00 |    0.00 | 0.0305 |     664 B |        1.00 |\r\n| DeserializeStringFromUtf8 | 18.30 μs | 0.152 μs | 0.135 μs |  1.12 |    0.01 | 2.0447 |   25712 B |       38.72 |\r\n| DeserializeJsonReader     | 32.05 μs | 0.384 μs | 0.359 μs |  1.96 |    0.03 |      - |     664 B |        1.00 |\r\n\r\n### Analysis\r\n\r\nCursory profiling suggests that the overhead of the `Deserialize(ref Utf8JsonReader, ...)` overloads stems from the calls to [`GetReaderScopedToNextValue()`](https://github.com/dotnet/runtime/blob/8790a2ffd49e9d3b9bf1621525718c753c28d519/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/JsonSerializer.Read.Utf8JsonReader.cs#L335), which performs a `reader.TrySkip()` that would seem to result in essentially parsing the JSON data twice - first while skipping the current array/object in `GetReaderScopedToNextValue`, then again when actually deserializing the data. This perhaps explains why it's approximately twice as slow as the baseline in the above results.\r\n\r\nUnfortunately all `Deserialize(ref Utf8JsonReader, ...)` overloads appear to call `GetReaderScopedToNextValue`, so this overhead cannot be avoided, even if the caller knows that the reader is already appropriately \"scoped\".",
    "number": 99674,
    "reactions": {
      "hasNextPage": false,
      "nodes": [],
      "totalCount": 0,
      "endCursor": null
    },
    "updatedAt": "2024-03-20T09:20:33Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": "dotnet-policy-service",
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. -->",
          "createdAt": "2024-03-13T11:27:53Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-03-13T11:27:53Z",
          "id": "IC_kwDODI9FZc523IYg"
        },
        {
          "author": "steveharter",
          "body": "I believe `GetReaderScopedToNextValue()` along with `TrySkip()` was intended to be resilient for an incorrectly positioned reader or perhaps a bad custom converter for a JSON object or array. It creates a new reader scoped to just the JSON for the current object\\array to prevent any read-after-value issues for example and ensures the reader has enough data.\r\n\r\nThe serializer, for custom converter validation, is done in a performant way: https://github.com/dotnet/runtime/blob/4cf19ee05d3efc5372b8f308240688bacce09208/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/JsonConverterOfT.cs#L503. This logic above does minimal checks for example to ensure when an object is done being read, the current reader is positioned on JsonTokenType.EndObject and the current depth is correct.\r\n\r\nPerhaps the `TrySkip()` can be replaced with logic similar to the custom converter validation above + any existing logic that resets the reader if there is an exception or out-of-data. ",
          "createdAt": "2024-03-13T19:47:06Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-03-19T10:38:08Z",
                "user": "eiriktsarpalis"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHODbFz-w=="
          },
          "updatedAt": "2024-03-13T19:47:06Z",
          "id": "IC_kwDODI9FZc528cGb"
        },
        {
          "author": "eiriktsarpalis",
          "body": "The current behavior is very much intentional, but IIRC this is mostly forced because of assumptions that the serializer is making about input data (must be a self-contained JSON value without trailing data). In principle I think it might be possible to avoid some of that double parsing by reworking the core serialization routines (allowing trailing data, adding extra checks ensuring deserialization does not escape its current scope) but that would require benchmarking to ensure that it does result in net perf improvements.",
          "createdAt": "2024-03-19T10:42:45Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-03-19T10:42:45Z",
          "id": "IC_kwDODI9FZc53nR1H"
        },
        {
          "author": "cosborne83",
          "body": "@eiriktsarpalis - The scenario that caused me to encounter this unexpected performance difference was the need to deserialize from a `ReadOnlySequence<byte>`, for which there are no dedicated `Deserialize()` overloads as there are for e.g. `ReadOnlySpan<byte>`, necessitating first constructing a `Utf8JsonReader` from the sequence, and then using the slower overload instead.\r\n\r\nGiven the apparent difficulty in changing the behaviour of the `Deserialize(ref Utf8JsonReader, ...)` overload to reduce the performance impact, perhaps adding `Deserialize(ReadOnlySequence<byte>, ...)` overloads to `JsonSerializer` analogous to the existing `ReadOnlySpan<byte>` versions would be possible as a simpler/lower-risk alternative?\r\n\r\nUnless perhaps there's already a way to deserialize from a `ReadOnlySequence<byte>` that I've missed that doesn't hit this slower path?",
          "createdAt": "2024-03-19T13:22:24Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-03-19T13:22:24Z",
          "id": "IC_kwDODI9FZc53oum2"
        },
        {
          "author": "eiriktsarpalis",
          "body": "That is one possibility, FWIW ReadOnlySequence was never a first-class citizen in the serializer layer (in many cases converters assume the underlying data is a span) however https://github.com/dotnet/runtime/issues/68586 is going to change this.",
          "createdAt": "2024-03-20T09:20:32Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-03-20T09:20:32Z",
          "id": "IC_kwDODI9FZc53wHRU"
        }
      ],
      "totalCount": 5,
      "endCursor": "Y3Vyc29yOnYyOpHOd8B0VA=="
    },
    "url": "https://github.com/dotnet/runtime/issues/99674",
    "title": "JsonSerializer deserialization using overloads taking Utf8JsonReader are unexpectedly slower than equivalents taking string"
  },
  {
    "author": "bill-poole",
    "labels": [
      "api-suggestion",
      "area-System.Text.Json"
    ],
    "createdAt": "2024-03-20T06:25:11Z",
    "body": "### Background and motivation\n\nThe `System.Text.Json.JsonElement` struct currently provides `ValueEquals` overloads for comparing the value of a `JsonElement` with a string (`string`, `ReadOnlySpan<char>` or `ReadOnlySpan<byte>`) representation of another `JsonElement` instance. However, if we want to compare two `JsonElement` instances, then this requires the following, which requires heap allocations and UTF-8 decoding.\r\n\r\n```csharp\r\njsonElement1.ValueEquals(jsonElement2.GetString());\r\n```\r\n\r\nIt would be presumably much more efficient to be able to do:\r\n\r\n```csharp\r\njsonElement1.ValueEquals(jsonElement2);\r\n```\n\n### API Proposal\n\n```csharp\r\nnamespace System.Text.Json;\r\n\r\npublic readonly struct JsonElement\r\n{\r\n    public bool ValueEquals(JsonElement other);\r\n}\r\n```\n\n### API Usage\n\n```csharp\r\n// Compare jsonElement1 with jsonElement2\r\nConsole.WriteLine($\"Values are equal: {jsonElement1.ValueEquals(jsonElement2)}\");\r\n```\n\n### Alternative Designs\n\n_No response_\n\n### Risks\n\n_No response_",
    "number": 99994,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-03-20T06:42:37Z",
          "user": "gregsdennis"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-03-22T14:28:21Z",
          "user": "martincostello"
        }
      ],
      "totalCount": 2,
      "endCursor": "Y3Vyc29yOnYyOpHOC2t-Iw=="
    },
    "updatedAt": "2024-03-21T21:41:22Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": "dotnet-policy-service",
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. -->",
          "createdAt": "2024-03-20T06:25:34Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-03-20T06:25:34Z",
          "id": "IC_kwDODI9FZc53usA4"
        },
        {
          "author": "gregsdennis",
          "body": "I have this as an extension in _Json.More.Net_.\n\n```c#\nvar isEqual = elt1.IsEquivalentTo(elt2);\n```\n\nThe code is [here](https://github.com/gregsdennis/json-everything/blob/master/Json.More%2FJsonElementExtensions.cs) if you want to inspect.",
          "createdAt": "2024-03-20T06:42:19Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-03-20T06:42:19Z",
          "id": "IC_kwDODI9FZc53uvMn"
        },
        {
          "author": "bill-poole",
          "body": "Thanks @gregsdennis! \r\n\r\nYour implementation still allocates though if the two `JsonElement` instances are `JsonValueKind.String`, `JsonValueKind.Array` or `JsonValueKind.Object`. I'm hoping a `JsonElement.ValueEquals(JsonElement)` overload would be allocation-free.\r\n\r\nAlso, comparing two `JsonElement` instances of type `JsonValueKind.Number` by parsing them both into `Decimal` instances is lossy if the two numbers have more decimal places than supported by the `System.Decimal` type.",
          "createdAt": "2024-03-20T07:04:43Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-03-20T07:04:43Z",
          "id": "IC_kwDODI9FZc53vSef"
        },
        {
          "author": "gregsdennis",
          "body": "> Also, comparing two `JsonElement` instances of type `JsonValueKind.Number` by parsing them both into `Decimal` instances is lossy if the two numbers have more decimal places than supported by the `System.Decimal` type.\n\nThis is true regardless of what .Net numeric type you use.  It's an inherent consequence of a limited practical numeric space vs JSON's unlimited theoretical numeric space.\n\nI chose `decimal` because I think my clients would prefer the extra precision over the extra range of `double`.",
          "createdAt": "2024-03-20T07:10:36Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-03-20T07:10:36Z",
          "id": "IC_kwDODI9FZc53vbpg"
        },
        {
          "author": "bill-poole",
          "body": ">This is true regardless of what .Net numeric type you use.\r\n\r\nYes, but I would imagine a `JsonElement.ValueEquals(JsonElement)` overload would compare the numbers as strings, rather than converting them into a binary floating point type with limited precision/range.",
          "createdAt": "2024-03-20T07:13:38Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-03-20T07:13:38Z",
          "id": "IC_kwDODI9FZc53vco3"
        },
        {
          "author": "gregsdennis",
          "body": "Yeah, that doesn't work, either: #97490.\n\n`4.0` and `4` are both valid JSON representations of the same value, but a string comparison doesn't work.",
          "createdAt": "2024-03-20T10:14:54Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-03-20T10:16:01Z",
          "id": "IC_kwDODI9FZc53wfjj"
        },
        {
          "author": "bill-poole",
          "body": "But isn't that the current behavior of `JsonElement.ValueEquals(String)`, `JsonElement.ValueEquals(ReadOnlySpan<char>)` and `JsonElement.ValueEquals(ReadOnlySpan<byte>)`? I looked at their implementations and they don't deserialize then compare, they just compare the strings.\r\n\r\nI would therefore propose that `JsonElement.ValueEquals(JsonElement)` would behave the exact same way. i.e., `jsonElement1.ValueEquals(jsonElement2)` would do exactly the same thing as `jsonElement1.ValueEquals(jsonElement2.GetString())`, but without the unnecessary allocation/decode.",
          "createdAt": "2024-03-20T10:19:46Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-03-20T10:19:46Z",
          "id": "IC_kwDODI9FZc53whqA"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Duplicate of https://github.com/dotnet/runtime/issues/33388. Note that this has already been implemented in .NET 8 for `JsonNode` via the `JsonNode.DeepEquals` method.",
          "createdAt": "2024-03-20T16:57:27Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-03-20T16:57:27Z",
          "id": "IC_kwDODI9FZc53zwrW"
        },
        {
          "author": "gregsdennis",
          "body": "@eiriktsarpalis I think the ability to do this without allocation on `JsonElement` would be valuable.  I don't think this is the same as that issue you linked.",
          "createdAt": "2024-03-20T18:05:53Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-03-20T18:05:53Z",
          "id": "IC_kwDODI9FZc530nd3"
        }
      ],
      "totalCount": 9,
      "endCursor": "Y3Vyc29yOnYyOpHOd9J3dw=="
    },
    "url": "https://github.com/dotnet/runtime/issues/99994",
    "title": "[API Proposal]: Add JsonElement.ValueEquals(JsonElement)"
  },
  {
    "author": "bill-poole",
    "labels": [
      "api-suggestion",
      "area-System.Text.Json"
    ],
    "createdAt": "2024-04-05T12:12:36Z",
    "body": "### Background and motivation\n\nReading a Base64-encoded string value from a `Utf8JsonReader` currently always allocates. However, in high performance scenarios, we want to be able to possibly stackalloc or the output buffer or rent it from the array pool. A `Utf8JsonReader.TryGetBytesFromBase64(Span<byte> span)` overload would allow the caller to create the buffer in any way.\n\n### API Proposal\n\n```csharp\r\nnamespace System.Text.Json\r\n{\r\n    public ref struct Utf8JsonReader\r\n    {\r\n        public bool TryGetBytesFromBase64(Span<byte> span, out int bytesWritten);\r\n    }\r\n}\r\n```\r\n\n\n### API Usage\n\n```csharp\r\nvar encodedLength = reader.HasValueSequence ? (int)reader.ValueSequence.Length : reader.ValueSpan.Length;\r\nvar buffer = ArrayPool<byte>.Shared.Rent(encodedLength);\r\nif (!reader.TryGetBytesFromBase64(buffer, out var bytesWritten))\r\n{\r\n    throw new JsonException();\r\n}\r\n\r\n// Do something with buffer\r\nvar decoded = buffer.AsSpan()[..bytesWritten];\r\n\r\n// Return the buffer to the array pool\r\nArrayPool<byte>.Shared.Return(buffer);\r\n```\r\n\n\n### Alternative Designs\n\nIt's currently possible to do this if the value is not escaped by writing code that uses `System.Buffers.Text.Base64`, but the logic to do this is already inside the System.Text.Json library and just needs to be exposed.\n\n### Risks\n\n_No response_",
    "number": 100670,
    "reactions": {
      "hasNextPage": false,
      "nodes": [],
      "totalCount": 0,
      "endCursor": null
    },
    "updatedAt": "2024-04-05T19:12:39Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": "dotnet-policy-service",
          "body": "Tagging subscribers to this area: @dotnet/area-system-buffers\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. -->",
          "createdAt": "2024-04-05T12:13:00Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-04-05T12:13:00Z",
          "id": "IC_kwDODI9FZc55kn0J"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Have you tried using one of the `Utf8JsonReader.CopyString` methods? They don't decode to Base64 directly but you can use an intermediate pooled that can then be decoded as appropriate.",
          "createdAt": "2024-04-05T13:30:59Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-04-05T13:30:59Z",
          "id": "IC_kwDODI9FZc55lRcc"
        },
        {
          "author": "bill-poole",
          "body": "No, I didn't think of doing that. But, wouldn't that be at the cost of an additional copy from the `Utf8JsonReader` to that buffer? i.e., instead of Base64 decoding directly from the underlying UTF-8 buffer to the given Span<byte> buffer, we'd be copying (and unescaping if necessary) to a buffer, then Base64 decoding from that buffer into another buffer.\r\n\r\nIf the value needs to be escaped, then perhaps the .NET library will copy twice anyway, but that would only be in the 0.0001% case that a Base64 value actually needs to be unescaped. Base64 values only use ASCII characters, so should never actually be escaped when serialized. But I recognize that the JSON could in theory represent some or all of the Base64 characters with Unicode escaped characters. So we're really talking about an extreme edge case here.\r\n\r\nThe vastly more common scenario is that we have Base64 text inside the UTF-8 JSON text that does not need to be escaped, which we want to decode to a user-provided `Span<byte>` buffer in a single step. The purpose of the proposed API is to decode Base64-encoded property values efficiently. It is inefficient to heap allocate the output buffer, but it is arguably even more inefficient to copy the Base64-encoded string to a buffer, and then decode that to yet another buffer.\r\n\r\nApologies if I've misunderstood something.",
          "createdAt": "2024-04-05T13:55:14Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-04-05T13:55:14Z",
          "id": "IC_kwDODI9FZc55lfWO"
        },
        {
          "author": "eiriktsarpalis",
          "body": "What we do internally for cases like that is only call `CopyString` when the string is found to be escaped or uses ReadOnlySequence:\r\n\r\nhttps://github.com/dotnet/runtime/blob/7def0b725852d55741262f43ed36ed501606f89f/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/Converters/Value/TimeSpanConverter.cs#L40-L51\r\n\r\nThis ensures that you don't make an intermediate copy for the 99% case, ensuring correctness for the remaining 1% and never allocating unpooled buffers.",
          "createdAt": "2024-04-05T14:49:03Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-04-05T14:49:03Z",
          "id": "IC_kwDODI9FZc55l9lY"
        },
        {
          "author": "bill-poole",
          "body": "Okay, good point. So then it is possible to replicate what the System.Text.Json library does with same/similar performance, but there's still a quite bit of tricky code we need to duplicate that already exists inside the System.Text.Json library. An extension method that might do the trick is below. This proposal is then about obviating the need for every user library that needs this to implement the extension method below.\r\n\r\n```csharp\r\ninternal static bool TryGetBytesFromBase64(this ref Utf8JsonReader reader, Span<byte> span, out int bytesWritten)\r\n{\r\n    byte[]? encodedArray = null;\r\n    scoped ReadOnlySpan<byte> encodedSpan;\r\n    if (reader.ValueIsEscaped || reader.HasValueSequence)\r\n    {\r\n        var encodedLength = reader.HasValueSequence ? (int)reader.ValueSequence.Length : reader.ValueSpan.Length;\r\n        encodedSpan = encodedLength <= StackallocByteThreshold\r\n            ? stackalloc byte[StackallocByteThreshold]\r\n            : (encodedArray = ArrayPool<byte>.Shared.Rent(encodedLength));\r\n        encodedSpan = encodedArray.AsSpan()[..reader.CopyString(encodedArray)];\r\n    }\r\n    else\r\n    {\r\n        encodedSpan = reader.ValueSpan;\r\n    }\r\n\r\n    var status = Base64.DecodeFromUtf8(encodedSpan, span, out var bytesConsumed, out bytesWritten);\r\n    if (encodedArray is not null)\r\n    {\r\n        ArrayPool<byte>.Shared.Return(encodedArray);\r\n    }\r\n\r\n    Debug.Assert(bytesConsumed == encodedSpan.Length);\r\n    return status == OperationStatus.Done;\r\n}\r\n```\r\n\r\nThis extension method is quite tricky, so it would be useful if it the functionality were to be exposed directly from the `Utf8JsonReader` struct.",
          "createdAt": "2024-04-05T17:29:46Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-04-05T17:29:46Z",
          "id": "IC_kwDODI9FZc55nJnu"
        },
        {
          "author": "eiriktsarpalis",
          "body": "We might consider it in the future, but it's unlikely we would prioritize it given that there is a workaround.",
          "createdAt": "2024-04-05T19:11:54Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-04-05T19:11:54Z",
          "id": "IC_kwDODI9FZc55n0vd"
        }
      ],
      "totalCount": 6,
      "endCursor": "Y3Vyc29yOnYyOpHOeZ9L3Q=="
    },
    "url": "https://github.com/dotnet/runtime/issues/100670",
    "title": "[API Proposal]: Add `Utf8JsonReader.TryGetBytesFromBase64(Span<byte> span, out int bytesWritten)` overload"
  },
  {
    "author": "Sonic198",
    "labels": [
      "api-suggestion",
      "area-System.Text.Json"
    ],
    "createdAt": "2024-04-23T19:22:08Z",
    "body": "Hello,\r\nI'm using `HttpClient` to integrate with an API which returns data in following format\r\n```json\r\n{\r\n  \"eventList\": [\r\n    {\r\n      \"eventType\": \"RECEIVED\",\r\n      \"houseAirWaybill\": \"AMZ-20240006\",\r\n      \"iataCode\": \"SEA\",\r\n      \"icaoCode\": \"KSEA\",\r\n      \"localDatetime\": \"2024-03-19T10:59:07.908-07:00\",\r\n      \"localTimezone\": \"America/Los_Angeles\",\r\n      \"shipmentType\": \"CONTAINER\",\r\n      \"zuluDatetime\": \"2024-03-19T17:59:07.908Z\"\r\n    }\r\n  ]\r\n}\r\n```\r\nIt is possible to have hundreds or even thousands of events inside `eventList` so since now we can use `ReadFromJsonAsAsyncEnumerable<TValue>` I was wondering if it would be possible to somehow iterate through that objects in `eventList` array without a need of loading all of them into memory? \r\n",
    "number": 101446,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-06-22T20:53:47Z",
          "user": "SerratedSharp"
        },
        {
          "content": "ROCKET",
          "createdAt": "2025-07-25T19:08:36Z",
          "user": "PAR-arajcoomar"
        }
      ],
      "totalCount": 2,
      "endCursor": "Y3Vyc29yOnYyOpHODIkOBQ=="
    },
    "updatedAt": "2024-04-24T14:17:19Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": "Tornhoof",
          "body": "Are you aware of \r\nhttps://learn.microsoft.com/en-us/dotnet/api/system.text.json.jsonserializer.deserializeasyncenumerable\r\n?",
          "createdAt": "2024-04-23T20:01:10Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-04-23T20:01:10Z",
          "id": "IC_kwDODI9FZc57lLQC"
        },
        {
          "author": "Sonic198",
          "body": "@Tornhoof  but how that would be usable in that case?\r\n\r\n\r\n> Are you aware of https://learn.microsoft.com/en-us/dotnet/api/system.text.json.jsonserializer.deserializeasyncenumerable ?\r\n\r\n",
          "createdAt": "2024-04-23T21:39:16Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-04-23T21:39:16Z",
          "id": "IC_kwDODI9FZc57lzG4"
        },
        {
          "author": "Tornhoof",
          "body": "It depends on the exact structure of your json response. If your array is nested inside another object it won't help.\r\n\r\nThe reasoning for only root-level IAsyncEnumerable support is here https://github.com/dotnet/runtime/issues/1570#issuecomment-804355005",
          "createdAt": "2024-04-23T21:58:57Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-04-23T21:58:57Z",
          "id": "IC_kwDODI9FZc57l7pP"
        },
        {
          "author": "dotnet-policy-service",
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. -->",
          "createdAt": "2024-04-24T02:59:23Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-04-24T02:59:23Z",
          "id": "IC_kwDODI9FZc57nXcC"
        },
        {
          "author": "Sonic198",
          "body": "> It depends on the exact structure of your json response. If your array is nested inside another object it won't help.\r\n> \r\n> The reasoning for only root-level IAsyncEnumerable support is here [#1570 (comment)](https://github.com/dotnet/runtime/issues/1570#issuecomment-804355005)\r\n\r\nYeah so as you can see in first post I unfortunately gets one object with nested array of objects in it so I guess there is no easy way of utilizing IAsyncEnumerable to deserialize those data.",
          "createdAt": "2024-04-24T07:42:44Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-04-24T07:42:44Z",
          "id": "IC_kwDODI9FZc57oycV"
        },
        {
          "author": "eiriktsarpalis",
          "body": "This is a known restriction of the `DeserializeAsyncEnumerable` methods. In principle it should be possible to expose new overloads that additionally accept a JSON path value pinpointing an entry point for the streamed array, in your example:\r\n\r\n```C#\r\nJsonSerializer.DeserializeAsyncEnumerable<Event>(utf8Stream, path: \"$.eventList\"); \r\n```\r\n\r\nWe would need to add corresponding overloads to `System.Net.Http.Json` as well.",
          "createdAt": "2024-04-24T14:16:34Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "HEART",
                "createdAt": "2024-04-26T17:51:00Z",
                "user": "Sonic198"
              },
              {
                "content": "HEART",
                "createdAt": "2024-05-15T12:43:35Z",
                "user": "WeihanLi"
              },
              {
                "content": "HEART",
                "createdAt": "2024-06-22T20:53:54Z",
                "user": "SerratedSharp"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-08-06T05:06:26Z",
                "user": "SamWhitby"
              },
              {
                "content": "HEART",
                "createdAt": "2025-05-28T22:18:32Z",
                "user": "bdoeven"
              },
              {
                "content": "ROCKET",
                "createdAt": "2025-07-25T19:09:55Z",
                "user": "PAR-arajcoomar"
              }
            ],
            "totalCount": 6,
            "endCursor": "Y3Vyc29yOnYyOpHOEb-NAg=="
          },
          "updatedAt": "2024-04-24T14:16:34Z",
          "id": "IC_kwDODI9FZc57ruj5"
        }
      ],
      "totalCount": 6,
      "endCursor": "Y3Vyc29yOnYyOpHOe67o-Q=="
    },
    "url": "https://github.com/dotnet/runtime/issues/101446",
    "title": "`JsonSerializer.DeserializeAsyncEnumerable` should support streaming from nested JSON arrays."
  },
  {
    "author": "IEvangelist",
    "labels": [
      "api-suggestion",
      "area-System.Text.Json"
    ],
    "createdAt": "2024-04-25T18:24:47Z",
    "body": "### Background and motivation\n\nAs a follow up to the related API proposal #87577, this aims to include `Post*` APIs to the `HttpClientJsonExtensions` class as extensions methods.\n\n### API Proposal\n\n```csharp\r\nnamespace System.Net.Http.Json;\r\n\r\npublic static partial class HttpClientJsonExtensions\r\n{\r\n    [RequiresUnreferencedCode(HttpContentJsonExtensions.SerializationUnreferencedCodeMessage)]\r\n    [RequiresDynamicCode(HttpContentJsonExtensions.SerializationDynamicCodeMessage)]\r\n    public static IAsyncEnumerable<TBodyValue?> PostAsJsonAsyncEnumerable<TBodyValue, TResponseValue>(\r\n        this HttpClient client,\r\n        [StringSyntax(StringSyntaxAttribute.Uri)] string? requestUri,\r\n        TBodyValue value,\r\n        JsonSerializerOptions? bodyOptions = null,\r\n        JsonSerializerOptions? responseOptions = null,\r\n        CancellationToken cancellationToken = default) { }\r\n\r\n    [RequiresUnreferencedCode(HttpContentJsonExtensions.SerializationUnreferencedCodeMessage)]\r\n    [RequiresDynamicCode(HttpContentJsonExtensions.SerializationDynamicCodeMessage)]\r\n    public static IAsyncEnumerable<TBodyValue?> PostAsJsonAsyncEnumerable<TBodyValue, TResponseValue>(\r\n        this HttpClient client,\r\n        Uri? requestUri,\r\n        TBodyValue value,\r\n        JsonSerializerOptions? bodyOptions = null,\r\n        JsonSerializerOptions? responseOptions = null,\r\n        CancellationToken cancellationToken = default) { }\r\n\r\n    [RequiresUnreferencedCode(HttpContentJsonExtensions.SerializationUnreferencedCodeMessage)]\r\n    [RequiresDynamicCode(HttpContentJsonExtensions.SerializationDynamicCodeMessage)]\r\n    public static Task<HttpResponseMessage> PostAsJsonAsyncEnumerable<TValue>(\r\n        this HttpClient client,\r\n        [StringSyntax(StringSyntaxAttribute.Uri)] string? requestUri,\r\n        TBodyValue value,\r\n        CancellationToken cancellationToken) { }\r\n\r\n    [RequiresUnreferencedCode(HttpContentJsonExtensions.SerializationUnreferencedCodeMessage)]\r\n    [RequiresDynamicCode(HttpContentJsonExtensions.SerializationDynamicCodeMessage)]\r\n    public static IAsyncEnumerable<TBodyValue?> PostAsJsonAsyncEnumerable<TBodyValue, TResponseValue>(\r\n        this HttpClient client,\r\n        Uri? requestUri,\r\n        TBodyValue value,\r\n        CancellationToken cancellationToken) { }\r\n\r\n    public static IAsyncEnumerable<TBodyValue?> PostAsJsonAsyncEnumerable<TBodyValue, TResponseValue>(\r\n        this HttpClient client,\r\n        [StringSyntax(StringSyntaxAttribute.Uri)] string? requestUri,\r\n        TBodyValue value,\r\n        JsonTypeInfo<TBodyValue> jsonBodyTypeInfo,\r\n        JsonTypeInfo<TResponseValue> jsonResponseTypeInfo,\r\n        CancellationToken cancellationToken = default) { }\r\n\r\n    public static IAsyncEnumerable<TBodyValue?> PostAsJsonAsyncEnumerable<TBodyValue, TResponseValue>(\r\n        this HttpClient client,\r\n        Uri? requestUri,\r\n        TBodyValue value,\r\n        JsonTypeInfo<TBodyValue> jsonBodyTypeInfo,\r\n        JsonTypeInfo<TResponseValue> jsonResponseTypeInfo,\r\n        CancellationToken cancellationToken = default) { }\r\n```\n\n### API Usage\n\n```csharp\r\nvar client = httpClientFactory.Create(\"openai\");\r\n\r\nvar prompt = new Prompt();\r\n\r\nawait foreach (var response in client.PostAsJsonAsyncEnumerable<Prompt, ChatResponse>(\r\n    requestUri: \"/openai/chat\",\r\n    bodyValue: prompt,\r\n    bodyJsonTypeInfo: GeneratedSerializerContext.Default.Prompt,\r\n    responseJsonTypeInfo: GeneratedSerializerContext.Default.ChatResponse))\r\n{\r\n    // TODO: handle each response\r\n}\r\n\r\npublic record Prompt /* Omitted for brevity */;\r\npublic record ChatResponse /* Omitted for brevity */;\r\n\r\n[JsonSerializable(typeof(Prompt))]\r\n[JsonSerializable(typeof(ChatResponse))]\r\ninternal sealed partial class GeneratedSerializerContext\r\n    : JsonSerializerContext\r\n{\r\n}\r\n```\r\n\n\n### Alternative Designs\n\n_No response_\n\n### Risks\n\n_No response_",
    "number": 101564,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-05-20T08:29:01Z",
          "user": "WeihanLi"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-06-05T17:14:43Z",
          "user": "marcominerva"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-06-06T10:36:51Z",
          "user": "shahabganji"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-06-06T12:11:29Z",
          "user": "bogdanlbanciu"
        }
      ],
      "totalCount": 4,
      "endCursor": "Y3Vyc29yOnYyOpHOC4bfmQ=="
    },
    "updatedAt": "2024-05-20T14:23:46Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": "dotnet-policy-service",
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. -->",
          "createdAt": "2024-04-25T18:25:13Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-04-25T18:25:13Z",
          "id": "IC_kwDODI9FZc572jzR"
        },
        {
          "author": "eiriktsarpalis",
          "body": "There's no precedent in us using two generic parameters for the request and response types, the [existing POST methods](https://learn.microsoft.com/en-us/dotnet/api/system.net.http.json.httpclientjsonextensions.postasjsonasync?view=net-8.0#system-net-http-json-httpclientjsonextensions-postasjsonasync-1(system-net-http-httpclient-system-string-0-system-text-json-serialization-metadata-jsontypeinfo((-0))-system-threading-cancellationtoken)) simply return an `HttpResponseMessage`. I wasn't involved in that design, but I'm guessing it was done to keep the APIs simple. \r\n\r\nIf I'm honest, I think the existing `HttpContent.ReadFromJsonAsAsyncEnumerable` methods are the ideally suited workaround which work for any request type:\r\n```C#\r\nRequestModel model = ...;\r\nHttpResponseMessage response = await client.PostAsJsonAsync(\"/openai/chat\", model);\r\nawait foreach (ResponseModel item in response.ReadFromJsonAsAsyncEnumerable<ResponseModel>())\r\n{\r\n    ...\r\n}\r\n```",
          "createdAt": "2024-04-25T19:15:40Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-04-25T19:22:27Z",
                "user": "IEvangelist"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHODfkxgA=="
          },
          "updatedAt": "2024-04-25T19:15:40Z",
          "id": "IC_kwDODI9FZc57292a"
        },
        {
          "author": "MihaZupan",
          "body": "On the other hand, that sample demonstrates how easy it is to use it wrong.\r\nThe `PostAsJsonAsync` call will buffer the whole response, meaning you won't actually get streaming semantics.\r\n\r\nThis would preserve the goal of streaming the response, but also with the difference that you now don't enforce the timeout/response size limits.\r\n```c#\r\nvar request = new HttpRequestMessage(HttpMethod.Post, \"/openai/chat\")\r\n{\r\n    Content = JsonContent.Create(model)\r\n};\r\nusing HttpResponseMessage response = await client.SendAsync(request, HttpCompletionOption.ResponseHeadersRead);\r\nawait foreach (ResponseModel item in response.ReadFromJsonAsAsyncEnumerable<ResponseModel>())\r\n{\r\n    ...\r\n}\r\n```\r\n\r\ncc: @dotnet/ncl",
          "createdAt": "2024-04-25T20:41:44Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-04-26T20:55:40Z",
                "user": "IEvangelist"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-05-20T08:30:16Z",
                "user": "WeihanLi"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-06-06T10:36:18Z",
                "user": "shahabganji"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-06-06T12:11:17Z",
                "user": "bogdanlbanciu"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-06-06T13:09:27Z",
                "user": "ricardok1"
              }
            ],
            "totalCount": 5,
            "endCursor": "Y3Vyc29yOnYyOpHODkyhsQ=="
          },
          "updatedAt": "2024-04-25T20:41:44Z",
          "id": "IC_kwDODI9FZc573eBy"
        },
        {
          "author": "JohnGalt1717",
          "body": "Does this help?  It's my shot at it, and it appears to not buffer and stream.\r\n\r\n```csharp\r\npublic static async IAsyncEnumerable<TResponse> PostFromJsonAsAsyncEnumerable<TRequest, TResponse>(\r\n    this HttpClient client,\r\n    string requestUri,\r\n    TRequest request,\r\n    [EnumeratorCancellation] CancellationToken cancellationToken = default) \r\n{\r\n  var requestMessage = new HttpRequestMessage(HttpMethod.Post, requestUri);\r\n  \r\n  using var ms = new MemoryStream();\r\n  await JsonSerializer.SerializeAsync(ms, request, JsonSerializerSettings.Options, cancellationToken: cancellationToken);\r\n  ms.Position = 0;\r\n  \r\n  using var requestContent = new StreamContent(ms);\r\n  requestMessage.Content = requestContent;\r\n  \r\n  requestContent.Headers.ContentType = new System.Net.Http.Headers.MediaTypeHeaderValue(\"application/json\");\r\n  requestMessage.Headers.Add(\"Accept\", \"application/json\");\r\n  \r\n  using var response = await client.SendAsync(requestMessage, HttpCompletionOption.ResponseHeadersRead, cancellationToken);\r\n  \r\n  response.EnsureSuccessStatusCode();\r\n\r\n  var items = response.Content.ReadFromJsonAsAsyncEnumerable<TResponse>(cancellationToken);\r\n\r\n  await foreach (var item in items)\r\n  {\r\n\tif (cancellationToken.IsCancellationRequested)\r\n\t\tthrow new TaskCanceledException();\r\n\tif (item is null)\r\n\t\tcontinue;\r\n\r\n\tyield return item;\r\n  }\r\n}\r\n```",
          "createdAt": "2024-04-25T21:05:17Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-04-26T20:55:15Z",
          "id": "IC_kwDODI9FZc573m3R"
        },
        {
          "author": "eiriktsarpalis",
          "body": "> The `PostAsJsonAsync` call will buffer the whole response, meaning you won't actually get streaming semantics.\r\n\r\nPerhaps then the answer is to expose overloads to the existing `HttpClientJsonExtensions` methods accepting `HttpCompletionOptions`?",
          "createdAt": "2024-04-26T07:44:48Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "EYES",
                "createdAt": "2024-04-26T20:53:33Z",
                "user": "IEvangelist"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHODftksg=="
          },
          "updatedAt": "2024-04-26T07:44:48Z",
          "id": "IC_kwDODI9FZc576EKN"
        },
        {
          "author": "WeihanLi",
          "body": "I'd like to have support for this. \r\n\r\n1. The POST method is widely used for a rest API even the GET method should used, especially in some legacy APIs that did not follow the REST, and sometimes the request parameters may be large so we may use POST instead\r\n2. It's very easy to go in the wrong way like above for a post without verification testing, so maybe it's valuable to add an API to use it easier\r\n\r\n> There's no precedent in us using two generic parameters for the request and response types\r\n\r\nfor one generic parameter, maybe we could add API for \r\n\r\n```c#\r\npublic IAsyncEnumerable<TResponse> PostFromJsonAsAsyncEnumerable<TResponse>(this HttpClient client, HttpContent? content, CancellationToken cancellationToken = default)\r\n```\r\n\r\npossible implementation\r\n\r\n```c#\r\npublic async IAsyncEnumerable<TResponse> PostFromJsonAsAsyncEnumerable<TResponse>(this HttpClient client, HttpContent? content, [EnumeratorCancellation] CancellationToken cancellationToken = default)\r\n{\r\n    using var response = await httpClient.SendAsync(requestMessage, HttpCompletionOption.ResponseHeadersRead, cancellationToken)\r\n            .ConfigureAwait(false);\r\n    response.EnsureSuccessStatusCode();\r\n    await foreach (var item in response.Content\r\n                           .ReadFromJsonAsAsyncEnumerable<TResponse>(cancellationToken).ConfigureAwait(false))\r\n            yield return item;\r\n}\r\n```\r\n\r\nFor two generic parameters, seemed there's a related issue （almost missed \r\nhttps://github.com/dotnet/runtime/issues/34157\r\n\r\n",
          "createdAt": "2024-05-20T09:21:40Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-06-05T15:45:19Z",
                "user": "IEvangelist"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHODkqgBQ=="
          },
          "updatedAt": "2024-05-20T14:23:46Z",
          "id": "IC_kwDODI9FZc5-XT0f"
        }
      ],
      "totalCount": 6,
      "endCursor": "Y3Vyc29yOnYyOpHOfl09Hw=="
    },
    "url": "https://github.com/dotnet/runtime/issues/101564",
    "title": "[API Proposal]: Streaming HTTP POST API for the System.Net.Http.Json extensions"
  },
  {
    "author": "eerhardt",
    "labels": [
      "area-System.Text.Json",
      "area-Extensions-Configuration",
      "source-generator"
    ],
    "createdAt": "2024-04-30T21:04:00Z",
    "body": "### Description\r\n\r\nThis issue is tracking updating the System.Text.Json and ConfigurationBinder source generators to take advantage of https://github.com/dotnet/roslyn/issues/73292 when it is implemented.\r\n\r\n#### Original Description\r\n\r\nWhen the System.Text.Json and ConfigurationBinder source generators generate code against types that have properties with `[Obsolete(\"message\", DiagnosticId = \"ID01\")]` attributes, the generated code is emitting warnings that I can't suppress and can't control. The only thing I can do is suppress the warning globally, which isn't ideal because I still want those warnings for my \"hand written\" code.\r\n\r\nBoth of those generators already suppress \"normal\" obsoletions with `#pragma warning disable CS0612, CS0618`. But since these obsoletion warnings get their own DiagnosticID, those suppressions don't work.\r\n\r\n(Note the case I hit was with the Configuration Binder source generator against a class that had an `X509Certificate2` property - which has 3 properties with different DiagnosticIDs - `SYSLIB0026;SYSLIB0027;SYSLIB0028`.)\r\n\r\n### Reproduction Steps\r\n\r\n`dotnet build` the following project:\r\n\r\n```xml\r\n<Project Sdk=\"Microsoft.NET.Sdk\">\r\n\r\n  <PropertyGroup>\r\n    <OutputType>Exe</OutputType>\r\n    <TargetFramework>net8.0</TargetFramework>\r\n    <Nullable>enable</Nullable>\r\n    <ImplicitUsings>enable</ImplicitUsings>\r\n    <EnableConfigurationBindingGenerator>true</EnableConfigurationBindingGenerator>\r\n  </PropertyGroup>\r\n\r\n  <ItemGroup>\r\n    <PackageReference Include=\"Microsoft.Extensions.Hosting\" Version=\"8.0.0\" />\r\n    <PackageReference Include=\"Microsoft.Extensions.Configuration.Binder\" Version=\"8.0.1\" />\r\n  </ItemGroup>\r\n\r\n</Project>\r\n```\r\n\r\n```C#\r\nusing Microsoft.Extensions.Configuration;\r\nusing Microsoft.Extensions.Hosting;\r\nusing System.Text.Json.Serialization;\r\n\r\nvar builder = Host.CreateApplicationBuilder(args);\r\n\r\nvar c = new MyClass();\r\nbuilder.Configuration.Bind(c);\r\n\r\n[JsonSerializable(typeof(MyClass))]\r\npublic partial class JsonContext : JsonSerializerContext\r\n{\r\n}\r\n\r\npublic class MyClass\r\n{\r\n    [Obsolete(\"message\", DiagnosticId = \"EE01\")]\r\n    public string? Name { get; set; }\r\n}\r\n```\r\n\r\n### Expected behavior\r\n\r\nI shouldn't get warnings that I can't take action against. \r\n\r\n### Actual behavior\r\n\r\nI get the following warnings:\r\n\r\n```\r\n\\ConsoleApp119\\obj\\Debug\\net8.0\\Microsoft.Extensions.Configuration.Binder.SourceGeneration\\Microsoft.Extensions.Configuration.Binder.SourceGeneration.ConfigurationBindingGenerator\\BindingExtensions.g.cs(65,17): warning EE01: 'MyClass.Name' is obsolete: 'message' [C:\\Users\\eerhardt\\source\\repos\\ConsoleApp119\\ConsoleApp119\\ConsoleApp119.csproj]\r\n\\ConsoleApp119\\obj\\Debug\\net8.0\\System.Text.Json.SourceGeneration\\System.Text.Json.SourceGeneration.JsonSourceGenerator\\JsonContext.MyClass.g.cs(53,36): warning EE01: 'MyClass.Name' is obsolete: 'message' [C:\\Users\\eerhardt\\source\\repos\\ConsoleApp119\\ConsoleApp119\\ConsoleApp119.csproj]\r\n\\ConsoleApp119\\obj\\Debug\\net8.0\\System.Text.Json.SourceGeneration\\System.Text.Json.SourceGeneration.JsonSourceGenerator\\JsonContext.MyClass.g.cs(54,45): warning EE01: 'MyClass.Name' is obsolete: 'message' [C:\\Users\\eerhardt\\source\\repos\\ConsoleApp119\\ConsoleApp119\\ConsoleApp119.csproj]\r\n\\ConsoleApp119\\obj\\Debug\\net8.0\\System.Text.Json.SourceGeneration\\System.Text.Json.SourceGeneration.JsonSourceGenerator\\JsonContext.MyClass.g.cs(80,43): warning EE01: 'MyClass.Name' is obsolete: 'message' [C:\\Users\\eerhardt\\source\\repos\\ConsoleApp119\\ConsoleApp119\\ConsoleApp119.csproj]\r\n```\r\n\r\n### Regression?\r\n\r\n_No response_\r\n\r\n### Known Workarounds\r\n\r\nglobally `<NoWarn>` these warnings.\r\n\r\n### Configuration\r\n\r\n_No response_\r\n\r\n### Other information\r\n\r\ncc @ericstj @eiriktsarpalis @tarekgh ",
    "number": 101738,
    "reactions": {
      "hasNextPage": false,
      "nodes": [],
      "totalCount": 0,
      "endCursor": null
    },
    "updatedAt": "2025-07-16T05:58:00Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": "dotnet-policy-service",
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. -->",
          "createdAt": "2024-04-30T21:04:26Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-04-30T21:04:26Z",
          "id": "IC_kwDODI9FZc58ad0D"
        },
        {
          "author": "dotnet-policy-service",
          "body": "Tagging subscribers to this area: @dotnet/area-extensions-configuration\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. -->",
          "createdAt": "2024-04-30T21:23:26Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-04-30T21:23:26Z",
          "id": "IC_kwDODI9FZc58asnv"
        },
        {
          "author": "dotnet-policy-service",
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. -->",
          "createdAt": "2024-04-30T21:23:27Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-04-30T21:23:27Z",
          "id": "IC_kwDODI9FZc58asoT"
        },
        {
          "author": "tarekgh",
          "body": "@eiriktsarpalis I marked this for .NET 9.0. Let me know if you want to change that. Thanks!",
          "createdAt": "2024-04-30T21:23:56Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-04-30T21:23:56Z",
          "id": "IC_kwDODI9FZc58atA0"
        },
        {
          "author": "teo-tsirpanis",
          "body": "Maybe Roslyn would need to add support for `#pragma warning disable obsolete`?",
          "createdAt": "2024-04-30T23:36:04Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-04-30T23:36:04Z",
          "id": "IC_kwDODI9FZc58cBDK"
        },
        {
          "author": "eiriktsarpalis",
          "body": "One possible approach that was considered in the past is exposing a `string[] Suppressions { get; set; }` property in the `JsonSourceGenerationOptionsAttribute` that gives users explicit control over what suppressions should be made.",
          "createdAt": "2024-05-01T16:15:00Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-05-01T16:15:00Z",
          "id": "IC_kwDODI9FZc58fwzA"
        },
        {
          "author": "eerhardt",
          "body": "> exposing a string[] Suppressions { get; set; } property in the JsonSourceGenerationOptionsAttribute\r\n\r\nOne concern about that is we would need to do that for every source generator that gets/sets user defined properties. And also there are some source generators (like the ConfigurationBinder) that don't have an \"Options\" API where these things could be placed.\r\n\r\n> Maybe Roslyn would need to add support for #pragma warning disable obsolete?\r\n\r\nThis seems like an interesting idea. A blanket \"suppress obsoletions\" statement.\r\n\r\ncc @RikkiGibson - who implemented [Customizable Obsolete diagnostics (dotnet/roslyn#42518)](https://github.com/dotnet/roslyn/pull/42518)\r\n\r\nWith other Roslyn analyzers, you can opt-in/out of running the analyzer on generated code. But since this one is built into Roslyn itself, I'm not sure how to tell it stop.",
          "createdAt": "2024-05-01T17:08:17Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-05-09T11:14:06Z",
                "user": "eiriktsarpalis"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHODhRFIw=="
          },
          "updatedAt": "2024-05-01T17:08:17Z",
          "id": "IC_kwDODI9FZc58gEHW"
        },
        {
          "author": "RikkiGibson",
          "body": "A pseudo-diagnostic-id similar to `#pragma warning disable nullable` might be the right thing here. Please file an issue on roslyn.\r\n\r\nOne rather ugly workaround here might be to put the usages of the \"custom obsolete\" members in an obsolete context, which *does* have the effect of blanket suppressing obsolete diagnostics. (seems like this also shows that compiler knows how to blanket suppress the diagnostics already.) [SharpLab](https://sharplab.io/#v2:EYLgtghglgdgNAFxFANnAJiA1AHwAIBMAjALABQ5eAzAASE0CqAzgKYBO5A3uTbzQNoB5YEwD2KFghYAKACJQIAcxiimCKAGMAkuhoBeGgCIAgoYCUAXR59qdIgAYA/DQAKbUQAcanGoskBuGlYEQIBfcnCKMiERcUkWKzJbegBxFhhva15kgBYaAFlpZnYaAFdWNjNMsj5asoqAOjdPfSMAIUN/LJpI0KA=)\r\n\r\n```cs\r\nusing System;\r\n\r\npublic class User\r\n{\r\n    [Obsolete(DiagnosticId = \"A\")]\r\n    public string? Prop { get; set; }\r\n}\r\n\r\n[Obsolete]\r\npublic class Gen {\r\n    public void M(User user) {\r\n        user.Prop = \"B\";\r\n    }\r\n}\r\n```",
          "createdAt": "2024-05-01T17:39:05Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-05-01T17:39:05Z",
          "id": "IC_kwDODI9FZc58gOGU"
        },
        {
          "author": "RikkiGibson",
          "body": "BTW, it's also possible to disable all warnings using `#pragma warning disable`. But, this might be considered undesirable if it hides bugs with the generated code itself.",
          "createdAt": "2024-05-01T19:55:17Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-05-01T20:26:01Z",
                "user": "eiriktsarpalis"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-05-01T20:45:56Z",
                "user": "eerhardt"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-05-01T16:13:33Z",
                "user": "jmprieur"
              }
            ],
            "totalCount": 3,
            "endCursor": "Y3Vyc29yOnYyOpHOEQdq4A=="
          },
          "updatedAt": "2024-05-01T19:55:17Z",
          "id": "IC_kwDODI9FZc58g-EI"
        },
        {
          "author": "dotnet-policy-service",
          "body": "Tagging subscribers to this area: @dotnet/area-extensions-configuration\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. -->",
          "createdAt": "2024-05-03T16:54:34Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-05-03T16:54:34Z",
          "id": "IC_kwDODI9FZc58xqzp"
        },
        {
          "author": "dotnet-policy-service",
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. -->",
          "createdAt": "2024-05-03T16:54:34Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-05-03T16:54:34Z",
          "id": "IC_kwDODI9FZc58xqz6"
        },
        {
          "author": "eerhardt",
          "body": "This issue applies to both the Configuration Binder and the System Text Json source generators.",
          "createdAt": "2024-05-03T16:54:38Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-05-03T17:01:43Z",
                "user": "tarekgh"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHODgiwYw=="
          },
          "updatedAt": "2024-05-03T16:54:38Z",
          "id": "IC_kwDODI9FZc58xq1V"
        },
        {
          "author": "tarekgh",
          "body": "Should we log issue for Roslyn regarding that? ",
          "createdAt": "2024-05-03T17:02:11Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-05-03T17:02:11Z",
          "id": "IC_kwDODI9FZc58xuXz"
        },
        {
          "author": "teo-tsirpanis",
          "body": "[Each issue/PR should only have one label.](https://github.com/dotnet/runtime/blob/main/docs/issues-pr-management.md#common-policies) It might belong to `area-Meta`, I'm letting you (plural) to decide.\r\n\r\n> Should we log issue for Roslyn regarding that?\r\n\r\nI have opened dotnet/roslyn#73292.",
          "createdAt": "2024-05-03T17:04:17Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-05-03T17:06:46Z",
                "user": "tarekgh"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHODgiy3Q=="
          },
          "updatedAt": "2024-05-03T17:04:17Z",
          "id": "IC_kwDODI9FZc58xv9P"
        },
        {
          "author": "tarekgh",
          "body": "Tagging it with `area-Meta` may result in it being overlooked by other area owners for tracking purposes.  ",
          "createdAt": "2024-05-03T17:08:23Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-05-03T17:08:23Z",
          "id": "IC_kwDODI9FZc58xzAo"
        },
        {
          "author": "eiriktsarpalis",
          "body": "> BTW, it's also possible to disable all warnings using `#pragma warning disable`. But, this might be considered undesirable if it hides bugs with the generated code itself.\r\n\r\nSomething I've been thinking about recently is that source generators should be disabling warnings altogether in generated code, since they're not actionable at all when surfaced to users. We could keep them on for debug builds of the source generator to catch bugs at development time. It could be said that this approach will result in bugs not being reported, but I would argue that it's not important unless the warning condition results in actual functional bugs that the users report to us.",
          "createdAt": "2024-05-09T11:23:05Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-05-10T06:58:18Z",
                "user": "gregsdennis"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHODhYP-A=="
          },
          "updatedAt": "2024-05-09T11:23:05Z",
          "id": "IC_kwDODI9FZc59UUNp"
        },
        {
          "author": "tarekgh",
          "body": "> Something I've been thinking about recently is that source generators should be disabling warnings altogether in generated code, since they're not actionable at all when surfaced to users.\r\n\r\nCan't the user utilize `<NoWarn>`  in their project to disable any warning?",
          "createdAt": "2024-05-09T18:38:40Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-05-09T18:39:14Z",
          "id": "IC_kwDODI9FZc59XIDA"
        },
        {
          "author": "jaredpar",
          "body": "> Something I've been thinking about recently is that source generators should be disabling warnings altogether in generated code, since they're not actionable at all when surfaced to users.\r\n\r\nThey're not actionable by users, but they're indicators to the generators that they're using C# incorrectly.",
          "createdAt": "2024-05-09T21:16:46Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-05-09T21:16:46Z",
          "id": "IC_kwDODI9FZc59X9jn"
        },
        {
          "author": "eerhardt",
          "body": "> Can't the user utilize NoWarn in their project to disable any warning?\r\n\r\nI addressed this in the top comment:\r\n\r\n> The only thing I can do is suppress the warning globally, which isn't ideal because I still want those warnings for my \"hand written\" code.\r\n",
          "createdAt": "2024-05-10T02:45:07Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-05-10T02:45:07Z",
          "id": "IC_kwDODI9FZc59ZNRa"
        },
        {
          "author": "eiriktsarpalis",
          "body": "> They're not actionable by users, but they're indicators to the generators that they're using C# incorrectly.\r\n\r\nThe fact that they're not actionable makes it a pretty poor experience from an end-user perspective. Arguably it should only be a SG bug if the incorrect use of C# results in incorrect functional behaviour of the generated code.",
          "createdAt": "2024-05-10T11:20:21Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-05-10T11:20:21Z",
          "id": "IC_kwDODI9FZc59bx10"
        },
        {
          "author": "CyrusNajmabadi",
          "body": "I def do not want generators to be able to suppress warnings automatically. If they're emitting something with a warning I want to know so I can assess the situation. ",
          "createdAt": "2024-05-10T14:35:26Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-05-10T14:35:26Z",
          "id": "IC_kwDODI9FZc59c4YY"
        },
        {
          "author": "stephentoub",
          "body": "> I def do not want generators to be able to suppress warnings automatically. If they're emitting something with a warning I want to know so I can assess the situation.\r\n\r\nYou're referring to:\r\n\"Something I've been thinking about recently is that source generators should be disabling warnings altogether in generated code,\"\r\n?\r\n\r\nWhy shouldn't the source generator be able to disable warnings on things it itself is generating? Just as it can today with a pragma in the generated code. Lots of source generators, including ours, use #pragma warning disable in the generated code.",
          "createdAt": "2024-05-10T14:41:44Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-05-10T14:44:38Z",
          "id": "IC_kwDODI9FZc59c68i"
        },
        {
          "author": "jaredpar",
          "body": "> Why shouldn't the source generator be able to disable warnings on things it itself is generating?\r\n\r\nI don't have any issues with generators suppressing specific warnings. I do have issues with a blanket \"let's automatically suppress all warnings\". That seems like a recipe for letting bad code silently enter generators. ",
          "createdAt": "2024-05-10T16:44:58Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-06-28T18:20:47Z",
                "user": "terrajobst"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHODntHbQ=="
          },
          "updatedAt": "2024-05-10T16:44:58Z",
          "id": "IC_kwDODI9FZc59doXQ"
        },
        {
          "author": "eiriktsarpalis",
          "body": "> That seems like a recipe for letting bad code silently enter generators.\r\n\r\nI think it's reasonable for warnings to be emitted for debug builds of the source generators. I don't see much of a point in production builds -- if emitting a warning helps uncover potential bugs, I think users should just be reporting the bugs themselves assuming they exist.",
          "createdAt": "2024-05-10T17:53:06Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-05-10T17:53:06Z",
          "id": "IC_kwDODI9FZc59eDiQ"
        },
        {
          "author": "jaredpar",
          "body": "> . I don't see much of a point in production builds -\r\n\r\nConsider this exact bug as an example of why we should be emitting in production builds. There is a behavior that the generator author is unaware of. Lacking warnings in production builds the author would never know about it. \r\n\r\nYes in this case the response is \"we could ignore that\". That will not always be the case.",
          "createdAt": "2024-05-10T18:01:48Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-05-10T18:01:56Z",
          "id": "IC_kwDODI9FZc59eH6n"
        },
        {
          "author": "RikkiGibson",
          "body": "Is there a similar issue here when the user types include `ExperimentalAttribute` on members? [SharpLab](https://sharplab.io/#v2:EYLgtghglgdgNAFxBAzggPgAQEwEYCwAUJgAwAEmuAdACJQQDmMA9mlAMYpUDCzAJgFMAgjAgAbAJ4ooKANxFMAZgrYy3MgG8iZHWQDaAeWApmYgQgEBdbbqUUALGQCyACgCUmm7t1Pc7+YTeAL5eZKF6AKIAHgAOAgBOUGACMAjiLgBEThLRcYnJqRlu1oG2ypiOvu6aZCGEQUA)",
          "createdAt": "2024-05-10T18:48:17Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-05-10T18:59:14Z",
                "user": "jaredpar"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHODhcsKw=="
          },
          "updatedAt": "2024-05-10T18:50:42Z",
          "id": "IC_kwDODI9FZc59eV2f"
        },
        {
          "author": "gregsdennis",
          "body": "I have worked for employers who have policies of treating warnings as errors.  Warnings from generated code would absolutely break them, but they would still consider blanket-ignoring even specific warnings a bad idea because they don't want their devs writing code that causes warnings. \n\nI concur that automatically ignoring warnings from generated code is a good thing.\n\nThe only alternative I can see is adding a project property that allows an opt-in or -out for warnings on generated code.",
          "createdAt": "2024-05-11T07:06:32Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-06-28T18:53:28Z",
          "id": "IC_kwDODI9FZc59gP60"
        },
        {
          "author": "jaredpar",
          "body": "Imagine the warning is coming from a security based analyzer. Automatically suppressing that just because it's generated code is almost certainly the wrong move and would result in uncomfortable conversations. ",
          "createdAt": "2024-05-11T19:44:34Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-05-11T19:44:34Z",
          "id": "IC_kwDODI9FZc59hw1B"
        },
        {
          "author": "RikkiGibson",
          "body": "I think warnings in the compiler are fairly keyed toward: if we are reporting this, something is almost certainly wrong, and the generator author should think about what's happening when those warnings occur. It's possible that suppression is the right thing to do, but not necessarily.\r\n\r\nAnalyzer authors have the ability to configure whether the analyzer runs on generated code or not. And it seems to me like if the analyzer is indicating the intention to run on generated code, the generated code should respect that and not attempt to suppress diagnostics in it--at least, again, not without reasoning out why the suppression is the right thing to do.\r\n\r\nIt also feels reasonable to make sure we have a story for users who get a diagnostic in generated code which they don't own and they need to get unblocked. Maybe we should make sure the user can write an editorconfig which refers to the path of the generated code (the generated file has a \"path\" according to the compiler even if it is not written to disk), and adjust behavior of diagnostics that way.\r\n\r\nRoslyn also has a concept of \"diagnostic suppressors\". While it might not be the cleanest, the JSON generator might be able to solve its problem by shipping a suppressor which notices that a diagnostic is for an obsolete/experimental/etc. property that the user is asking us to generate a serializer for, and suppresses the warning on it accordingly.\r\n\r\n(BTW, yet another possibility I didn't see mentioned: It might be possible that the right thing to do is *actually* to attribute the generated methods related to the obsolete/experimental/etc. type with the same obsolete attributes being used on the user members. This suppresses the warnings in the implementation of these methods and forwards the question of how to handle the obsolete-ness/experimental-ness to the user.)",
          "createdAt": "2024-05-11T20:03:22Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-05-11T20:49:05Z",
          "id": "IC_kwDODI9FZc59hxwA"
        },
        {
          "author": "jaredpar",
          "body": "For obsolete / experimental specifically I was mulling over whether we should consider a named group suppression (as detailed in [73292][pragma]). \r\n\r\n```csharp\r\n#pragma warning disable obsolete\r\n#pragma warning disable experimental\r\n```\r\n\r\nGiven how configurable these types of warnings are I understand how that is an attractive idea. There is some symmetry with nullable in the idea there of just want to ignore warnings from this group. At the same time it also means that generators can essentially use `BinaryFormatter` without a diagnostic. Are we okay with that use case? \r\n\r\nThe named group for nullable was done specifically because nullable warnings can't impact code semantics (it's part of the core design principals). Hence suppressing in bulk is not going to have adverse effects on the code. I'm unsure if obsolete falls into the same category because of scenarios like `BinaryFormatter`. Genuinely on the fence about that.\r\n\r\n> It also feels reasonable to make sure we have a story for users who get a diagnostic in generated code which they don't own and they need to get unblocked. Maybe we should make sure the user can write an editorconfig which refers to the path of the generated code (the generated file has a \"path\" according to the compiler even if it is not written to disk), and adjust behavior of diagnostics that way.\r\n\r\nVery much agree with this. It can be done today with .globalconfig but that's a bit clunky. Suppressions there apply to all source, not just generated one. Path based suppressions can be used in .editorconfig to suppress in generated files but it's imprecise. Have to use sections like `[*.Regex.g.cs]` which possibly matches more than you intended.\r\n\r\n> Something I've been thinking about recently is that source generators should be disabling warnings altogether in generated code, since they're not actionable at all when surfaced to user\r\n\r\nI continue to strongly disagree with this viewpoint. \r\n\r\nSource generators need to have the right tools in order to produce code that compiles cleanly. Just like with hand written code that is going to occasionally involve some amount of `#pragma` work (likely more so for generated code because it can't be as easily tuned as hand written code). I'm certainly sympathetic to cases like this where getting it right for generators is burdensome and recognize we may need to find ways to strike a better balance.\r\n\r\nBut I cannot get behind the idea of disabling all warnings in generated code: either implicitly or with a single switch. Warnings exist to alert users to potential issues in code. The design of the language is that such warnings need to be explicitly dealt with: either by fixing the code or by suppressing the warning.\r\n\r\nThis is not just the feelings of the language, it's also part of our general security posture. Over the last few years we've taken several changes to the [SARIF logger][sarif] to better surface what diagnostics ran in a build, and which diagnostics were suppressed and how were they suppressed. This was at the request of various security teams to ensure they can better audit security analyzers in build: making sure they're not disabled entirely, individual suppressions are audited, etc ... Having the compiler silently suppress all warnings does not really fit into that model and I have a hard time seeing it being accepted. \r\n\r\n[pragma]: https://github.com/dotnet/roslyn/issues/73292\r\n[sarif]: https://github.com/dotnet/roslyn/commits/main/src/Compilers/Core/Portable/CommandLine/SarifV2ErrorLogger.cs\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
          "createdAt": "2024-05-11T21:07:26Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-05-11T21:07:48Z",
          "id": "IC_kwDODI9FZc59h33q"
        },
        {
          "author": "CyrusNajmabadi",
          "body": "> Analyzer authors have the ability to configure whether the analyzer runs on generated code or not. And it seems to me like if the analyzer is indicating the intention to run on generated code, the generated code should respect that and not attempt to suppress diagnostics in it-\r\n\r\nI strongly agree with this.  Some analyzers already choose to disable them in generated code. Others continue to run.  I think this should be an analyzer decision.",
          "createdAt": "2024-05-11T21:58:03Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-05-11T21:58:03Z",
          "id": "IC_kwDODI9FZc59h6Dv"
        },
        {
          "author": "stephentoub",
          "body": "> At the same time it also means that generators can essentially use BinaryFormatter without a diagnostic. \r\n\r\nThat's already possible, no? The source generator would just emit `pragma warning disable SYSLIB0011` today. Or it would use a mechanism to access it that the obsolete analyzer can't see, e.g. reflection.",
          "createdAt": "2024-05-13T02:54:45Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-05-13T02:54:45Z",
          "id": "IC_kwDODI9FZc59j0r-"
        },
        {
          "author": "jaredpar",
          "body": "> The source generator would just emit pragma warning disable SYSLIB0011 \r\n\r\nCorrect they can do that. But that is an explicit suppression. That would show up if you were auditing code, looking at a SARIF log, etc ... It gives organizations the capability to make policy decisions around that diagnostic. Where as with `#pragma warning disable obsolete` it's not clear what was suppressed, just anything obsolete related. Can't make inferences as to whether say `BinaryFormatter` was used or not.\r\n\r\n\r\n",
          "createdAt": "2024-05-13T03:45:19Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-05-13T03:45:19Z",
          "id": "IC_kwDODI9FZc59j9p1"
        },
        {
          "author": "stephentoub",
          "body": "> That would show up if you were auditing code, looking at a SARIF log, etc\r\n\r\nI'd expect such code auditing to not include Roslyn source generated code, since it's generally not merged into a repo. \r\n\r\nAnd what stops the C# compiler from logging for `disable obsolete` the actual ids for anything it suppresses rather than a blanket log for the category? It could treat it as if the individual codes actually encountered were suppressed, which the dev can't necessarily do but the compiler can. ",
          "createdAt": "2024-05-13T10:21:43Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-05-13T10:49:40Z",
          "id": "IC_kwDODI9FZc59mUm-"
        },
        {
          "author": "jaredpar",
          "body": "> I'd expect such code auditing to not include Roslyn source generated code, since it's generally not merged into a repo\r\n\r\nAgree that users won't reasonably audit this. Tooling though does perform these audits and they do consider generated code.\r\n\r\n> And what stops the C# compiler from logging for disable obsolete the actual ids for anything it suppresses rather than a blanket log for the category?  It could treat it as if the individual codes actually encountered were suppressed, which the dev can't necessarily do but the compiler can.\r\n\r\nThis is an approach we could take. There are some issues with SARIF we'd need to work out. It's a bit of a twist to the existing use cases: single item suppressing groups of warnings [note 1][nrt] . Should be fine though. \r\n\r\nAgain though, for obsolete / experimental I'm on the fence with whether we should do this. Can also see arguments for this should be a warning. After all the user said \"this obsolete\" and then did an action where we generated code to use it. Was that intentional? What if it wasn't and now we're silently consuming a member they didn't want used. I can convince myself both ways on this one. If we ended up deciding as a group the `#pragma` was the right way I'd probably end up being fine with it.\r\n\r\nThat is not true for other classes of warnings. Bulk suppressing all warnings is not an approach I can see working. \r\n\r\n[nrt]: Yes there is already a group disable for NRT. As I mentioned earlier though these warnings never impact program semantics so it's never come up as a concern for auditing. ",
          "createdAt": "2024-05-13T18:44:56Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-05-13T18:44:56Z",
          "id": "IC_kwDODI9FZc59rhhi"
        },
        {
          "author": "eerhardt",
          "body": "I agree we shouldn't disable **all** warnings in generated code. That seems going too far.\r\n\r\n> Again though, for obsolete / experimental I'm on the fence with whether we should do this. Can also see arguments for this should be a warning. After all the user said \"this obsolete\" and then did an action where we generated code to use it. Was that intentional?\r\n\r\nThe JSON source generator already decided it should disable any \"obsolete\" warnings inside the code it generates. That's why it adds a `#pragma warning disable CS0612, CS0618` line to the top of the generated files:\r\n\r\nhttps://github.com/dotnet/runtime/blob/6c3245ed44e3f205a244d990e50c9510f6e1e9a6/src/libraries/System.Text.Json/gen/JsonSourceGenerator.Emitter.cs#L140-L141\r\n\r\nThis issue is that some obsoletions use their own diagnostic ID, and this list can't be statically known ahead of time. The JSON source generator could inspect every property it is going to reference and keep a list of the obsoletion IDs and then suppress them (either at the top of the file, or around each usage), but that would need to be done for every source generator that needs this behavior.\r\n\r\nThe logical reason why it is OK to suppress these warnings is because the source generator wants to match the reflection based logic. The reflection based logic happily uses Obsolete (and experimental) properties without warnings. The source generator should behave the same.",
          "createdAt": "2024-05-13T19:05:38Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-05-13T19:31:05Z",
                "user": "tarekgh"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHODhp6sA=="
          },
          "updatedAt": "2024-05-13T19:05:38Z",
          "id": "IC_kwDODI9FZc59rrFx"
        },
        {
          "author": "tarekgh",
          "body": "Is it possible we can have a helper method which can get the instances of all obsoletion attribute references in the compilation and from these can get all diagnostics Ids? I don't think this needs to be checked for every property for such attribute. ",
          "createdAt": "2024-05-13T19:31:07Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-05-13T19:31:07Z",
          "id": "IC_kwDODI9FZc59r2s9"
        },
        {
          "author": "RikkiGibson",
          "body": "re: suppressing BinaryFormatter. It seems like if we suppressed these, the SARIF logs will still show that the diagnostic for using it is present but suppressed. Right? In this case, I think anyone auditing will have all the information they need about what is going on.\r\n\r\nre: a helper method to get obsolete attribute usages: I think enumerating the set of obsolete diagnostics that *could* occur, prior to generating source, is going to be more computationally expensive than introducing the ability to blanket-suppress all obsolete diagnostics when they occur, because it may force us to bind attributes which we otherwise wouldn't have bound in the \"primordial compilation\". It also might be tricky to do correctly in all scenarios.\r\n\r\nI paged this area in a little more and recalled that all obsolete diagnostics with a custom ID have a [well-known entry](https://github.com/RikkiGibson/roslyn/blob/b7a9893998197f1d1cac0fb3a287345a88ef8fe6/src/Compilers/Core/Portable/Diagnostic/WellKnownDiagnosticTags.cs#L52) in [CustomTags](https://github.com/dotnet/roslyn/blob/d3ea419bcfddf3d57d68f31a6fd0a10468690ecf/src/Compilers/Core/Portable/Diagnostic/DiagnosticDescriptor.cs#L67).\r\n\r\nI think that writing a DiagnosticSuppressor which suppresses all obsolete diagnostics would be very simple using this.\r\n",
          "createdAt": "2024-05-13T20:11:34Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-05-13T20:11:34Z",
          "id": "IC_kwDODI9FZc59sHGN"
        },
        {
          "author": "terrajobst",
          "body": "It seems there are a couple of approaches (in order of impact):\r\n\r\n1. Ability to turn of all obsoletion warnings which the analyzer can emit\r\n1. Roslyn configuration for suppressions that are only applied to generated code\r\n1. Exposing configuration for source generators to suppress user supplied diagnostic IDs (would be custom for each generator)\r\n1. Do nothing, i.e. the user has to suppress them globally.\r\n\r\nPersonally, I think (1) makes the most sense and has the least amount of moving pieces. @jaredpar's [argument](https://github.com/dotnet/runtime/issues/101738#issuecomment-2105048743) makes sense, but the problem I see is that in practice many developers will simply choose to ignore them anyway. And if their only recourse is to turn it off globally, well, that's what they are going to do. At least that's our experience and originally prompted custom diagnostic IDs to begin with. Personally, I'd rather a source generator turns off all obsoletion warnings for its generated code than developers suppressing specific obsoletion diagnostics globally, just to suppress in generated code.\r\n\r\nHowever, if we truly believe the developer should issue the suppressions, not the generator, then I think we'd want a generalized framework to let the user pass them in. This can either be a global context (`<NoWarnInGeneratedCode>SYSLIB001</<NoWarnInGeneratedCode>`) or as a kind of pairing based on the name the generated syntax tree was given (if we really feel the need for more localization). \r\n\r\nI don't like the idea of handling this in each and every source generator, either by detecting obsoletions and adding suppression or by configuration. Both feel error prone and/or complicate the developer experience around the feature that uses the generator.\r\n\r\nAnd I really don't like the last recourse (4) because it undermines the goal of making the developer aware when they use obsolete members in code they write.",
          "createdAt": "2024-05-14T22:28:16Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-05-14T22:28:44Z",
          "id": "IC_kwDODI9FZc591wXB"
        },
        {
          "author": "jaredpar",
          "body": "> Do nothing, i.e. the user has to suppress them globally.\r\n\r\nI don't really see this as a long term option. Yes today the only way to control diagnostics in generated code is globally through a .globalconfig file. That is not a good answer. The general mentality of the compiler is that if there is a warning in generated code that is likely a bug the generator needs to address and over the long term users shouldn't be suppressing these warnings. In the short term while the generator is working on a fix it would be nice if the diagnostic could be suppressed for the generated code only. @chsienki was going to open an issue for us to track potentially adding that in the future.\r\n\r\n> Roslyn configuration for suppressions that are only applied to generated code\r\n\r\nIf we took action here it would not be to suppress diagnostics only in generated code. It would be geared towards letting diagnostics be suppressed in the generated code for a specific generator. Suppressing in all code leads to cases where you turn off a warning in Generator A, but then Generator B then silently introduces the same bug.\r\n\r\n> Ability to turn of all obsoletion warnings which the analyzer can emit\r\n\r\nIf we take this approach it will be the big hammer style. Basically disable all obsolete diagnostics including ones we'd probably want like `BinaryFormatter`. Don't see us doing a `#pragma warning disable obsolete except ...` style feature. \r\n\r\n> Personally, I think (1) makes the most sense and has the least amount of moving piece\r\n\r\nIt unfortunately has a number of moving pieces as well. Designing the SARIF angle will be interesting and likely a non-trivial amount of work. \r\n",
          "createdAt": "2024-05-14T22:38:18Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-05-14T22:38:18Z",
          "id": "IC_kwDODI9FZc591zQM"
        },
        {
          "author": "terrajobst",
          "body": "Does this mean we agree on the direction (i.e. support `#pragma warning disable obsolete`), that is, an explicit suppression for all obsoletions, akin to experimental and nullable?",
          "createdAt": "2024-06-28T18:27:26Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-06-28T18:29:36Z",
                "user": "stephentoub"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHODntLFw=="
          },
          "updatedAt": "2024-06-28T18:27:26Z",
          "id": "IC_kwDODI9FZc6C-ito"
        },
        {
          "author": "jaredpar",
          "body": "I think it's the most promising path at this point. ",
          "createdAt": "2024-07-03T18:25:06Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-07-03T21:57:43Z",
                "user": "terrajobst"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHODoSwzg=="
          },
          "updatedAt": "2024-07-03T18:25:06Z",
          "id": "IC_kwDODI9FZc6Di1k9"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Moving to 10.0.0, seems unlikely we'll get to a solution in 9.",
          "createdAt": "2024-07-05T12:29:31Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-07-05T12:29:31Z",
          "id": "IC_kwDODI9FZc6DxgQe"
        },
        {
          "author": "terrajobst",
          "body": "@jaredpar @eiriktsarpalis should this issue be moved to dotnet/roslyn? Looks like we concluded this should be a compiler feature.",
          "createdAt": "2024-07-12T21:18:04Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-07-12T22:20:18Z",
                "user": "eiriktsarpalis"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHODpk-Hg=="
          },
          "updatedAt": "2024-07-12T21:18:04Z",
          "id": "IC_kwDODI9FZc6Es6nc"
        },
        {
          "author": "RikkiGibson",
          "body": "It feels reasonable to close this out and track with dotnet/roslyn#73292. (feel free to re-triage if you don't agree.)",
          "createdAt": "2024-07-12T23:32:43Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-07-12T23:33:02Z",
          "id": "IC_kwDODI9FZc6Etg0h"
        },
        {
          "author": "eerhardt",
          "body": "Note that once https://github.com/dotnet/roslyn/issues/73292 is implemented, we will still need to make the small change in the JSON and Config Binder source generators to take advantage of the new feature - by adding `#pragma warning disable obsolete` (or whatever is decided) to the generated code.",
          "createdAt": "2024-07-14T13:31:33Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-07-14T21:22:27Z",
                "user": "jaredpar"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-07-15T10:30:25Z",
                "user": "eiriktsarpalis"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-07-15T17:55:30Z",
                "user": "terrajobst"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-05-01T16:13:55Z",
                "user": "jmprieur"
              }
            ],
            "totalCount": 4,
            "endCursor": "Y3Vyc29yOnYyOpHOEQdrCg=="
          },
          "updatedAt": "2024-07-14T13:31:33Z",
          "id": "IC_kwDODI9FZc6Ewq0-"
        },
        {
          "author": "terrajobst",
          "body": "@eerhardt presumably you're suggesting to use this issue to track the needed changes for that? If so, it would be good to update the title / description to reflect this.",
          "createdAt": "2024-07-15T17:55:28Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-07-15T17:55:50Z",
          "id": "IC_kwDODI9FZc6E3PY6"
        },
        {
          "author": "eerhardt",
          "body": "I've updated the top comment of this issue with:\r\n\r\n> This issue is tracking updating the System.Text.Json and ConfigurationBinder source generators to take advantage of https://github.com/dotnet/roslyn/issues/73292 when it is implemented.",
          "createdAt": "2024-07-15T18:15:19Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-07-15T18:26:47Z",
                "user": "RikkiGibson"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-07-15T18:37:57Z",
                "user": "terrajobst"
              }
            ],
            "totalCount": 2,
            "endCursor": "Y3Vyc29yOnYyOpHODp0HkQ=="
          },
          "updatedAt": "2024-07-15T18:15:19Z",
          "id": "IC_kwDODI9FZc6E3XZk"
        },
        {
          "author": "terrajobst",
          "body": "Thanks man, appreciated!",
          "createdAt": "2024-07-15T18:38:01Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-07-15T18:38:01Z",
          "id": "IC_kwDODI9FZc6E3g1a"
        }
      ],
      "totalCount": 49,
      "endCursor": "Y3Vyc29yOnYyOpHOhN4NWg=="
    },
    "url": "https://github.com/dotnet/runtime/issues/101738",
    "title": "Obsoletions with a DiagnosticId still get warnings in generated code"
  },
  {
    "author": "Tragetaschen",
    "labels": [
      "api-suggestion",
      "area-System.Text.Json"
    ],
    "createdAt": "2024-05-21T12:25:42Z",
    "body": "### Background and motivation\r\n\r\nIn #68223, two overloads for `Utf8JsonWriter` were proposed, one for `ReadOnlySequence<byte>` and one for `ReadOnlySequence<char>`. The latter was rejected due to the necessary surrogate pair state handling while writing the  `ReadOnlySpan<char>` segments.\r\n\r\nHowever, #67337 is currently underway to add the building blocks and state handling for that. Adding the rejected overload now seems like an easy addition.\r\n\r\n### API Proposal\r\n\r\n```diff\r\nnamespace System.Text.Json\r\n{\r\n    public sealed partial class Utf8JsonWriter\r\n    {\r\n+        public void WriteRawValue(ReadOnlySequence<char> json, bool skipInputValidation = false);\r\n    }\r\n}\r\n```\r\n\r\n\r\n### API Usage\r\n\r\nI could avoid building an entire in-memory, contiguous string just to have it written out as JSON. Other proposals like #97570 or #87362 would tie in very nicely as well.\r\n\r\n### Alternative Designs\r\n\r\n_No response_\r\n\r\n### Risks\r\n\r\n_No response_",
    "number": 102491,
    "reactions": {
      "hasNextPage": false,
      "nodes": [],
      "totalCount": 0,
      "endCursor": null
    },
    "updatedAt": "2025-01-06T09:53:21Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": "dotnet-policy-service",
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. -->",
          "createdAt": "2024-05-21T12:26:03Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-05-21T12:26:03Z",
          "id": "IC_kwDODI9FZc5-gxaI"
        },
        {
          "author": "Tragetaschen",
          "body": "#67377 is implemented. Where can I send the cake for bribery?",
          "createdAt": "2025-01-06T09:53:20Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-01-06T09:53:20Z",
          "id": "IC_kwDODI9FZc6ZWSUM"
        }
      ],
      "totalCount": 2,
      "endCursor": "Y3Vyc29yOnYyOpHOmVklDA=="
    },
    "url": "https://github.com/dotnet/runtime/issues/102491",
    "title": "[API Proposal]: Add ReadOnlySequence<char> overload for WriteRawValue"
  },
  {
    "author": "marcinjahn",
    "labels": [
      "enhancement",
      "area-System.Text.Json"
    ],
    "createdAt": "2024-05-23T06:21:31Z",
    "body": "### Description\r\n\r\nIt looks like System.Text.Json cannot deserialize from [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) datetime string to DateOnly, which I find odd, since `DateOnly.Parse(\"2024-05-01T00:00:00\")` works perfectly fine.\r\n\r\n### Reproduction Steps\r\n\r\nHere's the code:\r\n\r\n```cs\r\nrecord MyRecord(DateOnly Date);\r\n\r\nvar serialized = \"{ \\\"Date\\\": \\\"2025-05-01T00:00:00\\\" }\";\r\n\r\nSystem.Text.Json.JsonSerializer.Deserialize<MyRecord>(serialized); // throws\r\n```\r\n\r\n### Expected behavior\r\n\r\nI'd expect no exception to be thrown and an isntance of `MyRecord` to be created.\r\n\r\n### Actual behavior\r\n\r\nAn exception is thrown:\r\n\r\n>  The JSON value could not be converted to Submission#1+MyRecord. Path: $.Date | LineNumber: 0 | BytePositionInLine: 31.\r\n\r\n### Regression?\r\n\r\n_No response_\r\n\r\n### Known Workarounds\r\n\r\nUse `DateTime` instead of `DateOnly`.\r\n\r\n### Configuration\r\n\r\ndotnet: 8.0.204\r\nOS: Fedora 40\r\narch: x64\r\n\r\n### Other information\r\n\r\n_No response_",
    "number": 102594,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-07-09T13:41:49Z",
          "user": "JaimeStill"
        }
      ],
      "totalCount": 1,
      "endCursor": "Y3Vyc29yOnYyOpHOC5Oy2A=="
    },
    "updatedAt": "2024-07-09T17:36:53Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": "dotnet-policy-service",
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. -->",
          "createdAt": "2024-05-23T06:21:49Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-05-23T06:21:49Z",
          "id": "IC_kwDODI9FZc5-vRcN"
        },
        {
          "author": "gregsdennis",
          "body": "Possible duplicate of #85545 (maybe just related)",
          "createdAt": "2024-05-23T07:50:51Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-05-23T07:51:32Z",
          "id": "IC_kwDODI9FZc5-vyo1"
        },
        {
          "author": "eiriktsarpalis",
          "body": "I believe this was a deliberate decision for the built-in to avoid loss of information (same is true for `TimeOnly`). I wouldn't be opposed to a PR that extends this to full ISO dates, if you're willing to put up a PR.\r\n\r\ncc @Jozkee ",
          "createdAt": "2024-05-23T09:16:20Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-05-23T09:16:20Z",
          "id": "IC_kwDODI9FZc5-wbwb"
        },
        {
          "author": "marcinjahn",
          "body": "I think it's expected that the time portion of the datetime string will be lost when you're deserializing to a `DateOnly`. It's kind of similar to how you might have a type:\r\n\r\n```cs\r\nrecord (int PropOne, int PropB);\r\n```\r\n\r\nand then you try to deserialize:\r\n\r\n```json\r\n{\r\n  \"PropOne\": 1,\r\n  \"PropTwo\": 2,\r\n  \"PropThree\": 3\r\n}\r\n```\r\n\r\nThe `PropThree` field gets lots, and it's expected.\r\n\r\nI will try to prepare a PR for it. I will see if I manage to build it locally. If not, I guess I could rely on PR tests.",
          "createdAt": "2024-05-23T19:43:24Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-07-09T13:50:05Z",
                "user": "JaimeStill"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHODo-v7g=="
          },
          "updatedAt": "2024-05-23T19:43:24Z",
          "id": "IC_kwDODI9FZc5-1S3H"
        },
        {
          "author": "JaimeStill",
          "body": "I ran into this issue just yesterday and want to share my experience in hopes of being able to accommodate native deserialization of ISO strings to `DateOnly` properties. I concur with @marcinjahn that the expectation was that the time portion of the ISO string would be lost in the deserialization and that this behavior should be supported.\r\n\r\nOur web apps are written in Angular and make use of the Angular Material library. Our forms use the Datepicker component with the native date adapter. All of this to say that the native date adapter does not support the ability to set the parse format, which would allow us to adjust selected dates to a format that could deserialize to `DateOnly` on the API side. The format that it provides by default is the ISO datetime string. I could use a different date adapter, but that would require adding a whole new unnecessary npm dependency. \r\n\r\n> See the note below the tables in [**Customizing the parse and display formats**](https://material.angular.io/components/datepicker/overview#choosing-a-date-implementation-and-date-format-settings).\r\n\r\nWhat I ultimately ended up doing is creating my own `DateOnly` converter as follows:\r\n\r\n```cs\r\npublic class DateOnlyJsonConverter : JsonConverter<DateOnly>\r\n{\r\n    public override DateOnly Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)\r\n    {\r\n        return DateOnly.FromDateTime(\r\n            DateTime.Parse(\r\n                reader.GetString()\r\n                ?? DateTime.MinValue.ToString()\r\n            )\r\n        );\r\n    }\r\n\r\n    public override void Write(Utf8JsonWriter writer, DateOnly value, JsonSerializerOptions options)\r\n    {\r\n        writer.WriteStringValue(value.ToString());\r\n    }\r\n}\r\n```",
          "createdAt": "2024-07-09T13:41:39Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-07-09T13:41:39Z",
          "id": "IC_kwDODI9FZc6EMKZ5"
        },
        {
          "author": "julealgon",
          "body": "@eiriktsarpalis \r\n> I believe this was a deliberate decision for the built-in to avoid loss of information\r\n\r\nWhat about introducing a setting in the serializer options to allow or prevent loss of information then?\r\n\r\nIt seems to me that both scenarios could be valid: either someone actively wants for it to \"just work\" and trim the data, or they might actively want to block the behavior and make their API more strict.",
          "createdAt": "2024-07-09T17:36:52Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-07-09T17:38:33Z",
                "user": "JaimeStill"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHODpA9gg=="
          },
          "updatedAt": "2024-07-09T17:36:52Z",
          "id": "IC_kwDODI9FZc6EOIVM"
        }
      ],
      "totalCount": 6,
      "endCursor": "Y3Vyc29yOnYyOpHOhDiFTA=="
    },
    "url": "https://github.com/dotnet/runtime/issues/102594",
    "title": "System.Text.Json can't deserialize ISO dateTime to DateOnly"
  },
  {
    "author": "brentschmaltz",
    "labels": [
      "api-suggestion",
      "area-System.Text.Json"
    ],
    "createdAt": "2024-05-30T18:42:53Z",
    "body": "### Background and motivation\r\n\r\nhttps://github.com/dotnet/runtime/blob/1ded19e700f267048a190fd45f949ed492469c1c/src/libraries/System.Text.Json/src/System/Text/Json/Reader/JsonReaderHelper.net8.cs\r\n\r\nJsonReaderHelper is internal, this method could be very helpful when reading a JsonWebToken where property values (claims) must be a specific value.\r\n\r\nThe Uff8JsonReader lets the caller know the value is escaped, but currently to check against the expected value, the user must transcode the uft8 -> utf16 then compare.\r\n\r\nA security policy defines what values are acceptable.\r\nDuring Authorization, the security policy is applied to each security token that arrives (many, many, many to 1)\r\nInstead, if we transcoded the expected values in a security policy utf16 -> utf8 (once on startup), we could fail fast during deserialization OR keep the utf8 bytes around and check later.\r\n\r\nThere is a workaround of wrapping the bytes in a new Utf8JsonReader, but that adds allocations (small for sure) and extra logic.\r\n\r\nI am not sure where the api would logically fit.\r\n\r\n### API Proposal\r\n\r\n```csharp\r\nnamespace System.Text.Json;\r\n\r\npublic static class JsonHelper\r\n{\r\n   public static bool Compare(ReadOnlySpan<byte> utf8Source, ReadOnlySpan<byte> utf8Other)\r\n   {\r\n        ...\r\n   }\r\n```\r\n\r\n\r\n### API Usage\r\n\r\n```csharp\r\n// 'iss' value is available as a span as part of deserialization of a JsonWebToken\r\npublic bool ValidateIssuer(ReadOnlySpan<byte> issuer, SecurityPolicy policy)\r\n{\r\n    return JsonHelper.Compare(issuer, policy.Issuer);\r\n}\r\n\r\n```\r\n\r\n\r\n### Alternative Designs\r\n\r\n_No response_\r\n\r\n### Risks\r\n\r\n_No response_",
    "number": 102890,
    "reactions": {
      "hasNextPage": false,
      "nodes": [],
      "totalCount": 0,
      "endCursor": null
    },
    "updatedAt": "2024-05-31T16:33:55Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": "dotnet-policy-service",
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. -->",
          "createdAt": "2024-05-30T18:43:22Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-05-30T18:43:22Z",
          "id": "IC_kwDODI9FZc5_l6Ie"
        },
        {
          "author": "halter73",
          "body": "I think I like the current `UnescapeAndCompare` over `Compare` as a name since it makes it clear why you want a JSON-specific comparison. It might also make sense to rename `utf8Source` to `escapedUtf8Source` to make it clearer that it is the only parameter that gets unescaped unless we plan to unescape both parameters in the new public API.\r\n\r\nI know we generally don't like to use \"Helper\" in public type names. Maybe @bartonjs has ideas on better names.\r\n\r\nThe current workaround pointed out by @eerhardt is to use Utf8JsonReader which works as long as the escaped source quoted.\r\n\r\n```csharp\r\nvar bytes = \"\\\"Fo\\u006F\\\"\"u8;\r\nvar reader = new Utf8JsonReader(bytes);\r\nreader.Read();\r\nConsole.WriteLine(reader.ValueTextEquals(\"Foo\"u8)); // Prints \"True\"\r\n```",
          "createdAt": "2024-05-31T16:29:30Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-05-31T16:29:30Z",
          "id": "IC_kwDODI9FZc5_tZr1"
        },
        {
          "author": "bartonjs",
          "body": "Lacking a better target identified by people who work on/with the JSON library, I'd say just having it on Utf8JsonReader is better than making a public \"Helper\" type.",
          "createdAt": "2024-05-31T16:33:54Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-05-31T16:34:12Z",
                "user": "eerhardt"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-06-13T05:02:24Z",
                "user": "brentschmaltz"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-08-22T20:29:17Z",
                "user": "pmaytak"
              }
            ],
            "totalCount": 3,
            "endCursor": "Y3Vyc29yOnYyOpHODvXQlA=="
          },
          "updatedAt": "2024-05-31T16:33:54Z",
          "id": "IC_kwDODI9FZc5_tbLR"
        }
      ],
      "totalCount": 3,
      "endCursor": "Y3Vyc29yOnYyOpHOf7Wy0Q=="
    },
    "url": "https://github.com/dotnet/runtime/issues/102890",
    "title": "[API Proposal]: expose funtionality found in: public static bool JsonReaderHelper.UnescapeAndCompare(ReadOnlySpan<byte> utf8Source, ReadOnlySpan<byte> other)"
  },
  {
    "author": "MaceWindu",
    "labels": [
      "bug",
      "area-System.Text.Json"
    ],
    "createdAt": "2024-06-07T09:01:40Z",
    "body": "### Description\n\nJson serializer could throw `IndexOutOfRangeException` exception on large strings serialization. Looks like string should be in 100Mb-160Mb to fail. Larger strings fail with expected `string too big` exception.\n\n### Reproduction Steps\n\n```cs\r\nusing System.Text;\r\nusing System.Text.Json;\r\n\r\ninternal class Program\r\n{\r\n\tstatic void Main(string[] args)\r\n\t{\r\n\t\tvar rnd = new Random();\r\n\t\twhile (true)\r\n\t\t{\r\n\t\t\tvar length = rnd.Next(100_000_000, 160_000_000);\r\n\t\t\tvar sb = new StringBuilder();\r\n\r\n\t\t\twhile (sb.Length < length)\r\n\t\t\t{\r\n\t\t\t\tvar allowSurrogate = length - sb.Length > 1;\r\n\t\t\t\t_ = sb.Append(Char(rnd));\r\n\t\t\t}\r\n\r\n\t\t\ttry\r\n\t\t\t{\r\n\t\t\t\t_ = JsonSerializer.Serialize(sb.ToString(), JsonSerializerOptions.Default);\r\n\t\t\t}\r\n\t\t\tcatch (ArgumentException ex) when (ex.Message.Contains(\"too large and not supported\"))\r\n\t\t\t{\r\n\t\t\t\t// ignore expected errors\r\n\t\t\t\tConsole.WriteLine($\"Too big: {ex.Message}\");\r\n\t\t\t}\r\n\t\t\t//catch (IndexOutOfRangeException)\r\n\t\t\t//{\r\n\t\t\t//\tConsole.WriteLine($\"Crashed!!! String size: {sb.Length}\");\r\n\t\t\t//}\r\n\t\t}\r\n\r\n\t\tstatic string Char(Random rnd)\r\n\t\t{\r\n\t\t\tif (rnd.Next(0, 10) == 0)\r\n\t\t\t{\r\n\t\t\t\twhile (true)\r\n\t\t\t\t{\r\n\t\t\t\t\tvar chr = ((char)(ushort)rnd.Next(0xd800, 0xdbff)).ToString()\r\n\t\t\t\t\t\t+ ((char)(ushort)rnd.Next(0xdc00, 0xdfff)).ToString();\r\n\t\t\t\t\tif (char.IsSurrogatePair(chr, 0))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\treturn chr;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\twhile (true)\r\n\t\t\t{\r\n\t\t\t\tvar chr = (char)(ushort)rnd.Next(ushort.MaxValue);\r\n\r\n\t\t\t\tif (chr is < (char)0xD800 or > (char)0xDFFF)\r\n\t\t\t\t{\r\n\t\t\t\t\treturn chr.ToString();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n```\n\n### Expected behavior\n\nNo exceptions if string size in allowed limits and `ArgumentException` when limit reached (as it happens now for strings > ~160Mb).\n\n### Actual behavior\n\n```\r\nUnhandled exception. System.IndexOutOfRangeException: Index was outside the bounds of the array.\r\n   at System.Text.Json.Utf8JsonWriter.WriteStringMinimized(ReadOnlySpan`1 escapedValue)\r\n   at System.Text.Json.Utf8JsonWriter.WriteStringEscapeValue(ReadOnlySpan`1 value, Int32 firstEscapeIndexVal)\r\n   at System.Text.Json.Utf8JsonWriter.WriteStringEscape(ReadOnlySpan`1 value)\r\n   at System.Text.Json.Utf8JsonWriter.WriteStringValue(ReadOnlySpan`1 value)\r\n   at System.Text.Json.Serialization.Converters.StringConverter.Write(Utf8JsonWriter writer, String value, JsonSerializerOptions options)\r\n   at System.Text.Json.Serialization.JsonConverter`1.TryWrite(Utf8JsonWriter writer, T& value, JsonSerializerOptions options, WriteStack& state)\r\n   at System.Text.Json.Serialization.JsonConverter`1.WriteCore(Utf8JsonWriter writer, T& value, JsonSerializerOptions options, WriteStack& state)\r\n   at System.Text.Json.Serialization.Metadata.JsonTypeInfo`1.Serialize(Utf8JsonWriter writer, T& rootValue, Object rootValueBoxed)\r\n   at System.Text.Json.JsonSerializer.WriteString[TValue](TValue& value, JsonTypeInfo`1 jsonTypeInfo)\r\n   at Program.Main(String[] args)\r\n```\n\n### Regression?\n\n_No response_\n\n### Known Workarounds\n\nAs we actually don't need such large strings serialized, we are using custom string converter which trims them to sane length.\n\n### Configuration\n\nRuntime: 8.0.5\r\nArch: Windows x64\n\n### Other information\n\n_No response_",
    "number": 103155,
    "reactions": {
      "hasNextPage": false,
      "nodes": [],
      "totalCount": 0,
      "endCursor": null
    },
    "updatedAt": "2024-06-07T17:43:37Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": "dotnet-policy-service",
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. -->",
          "createdAt": "2024-06-07T09:01:59Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-06-07T09:01:59Z",
          "id": "IC_kwDODI9FZc6AaaeI"
        },
        {
          "author": "elgonzo",
          "body": "Simplified repro code:\r\n```C#\r\nint strLength = 120_000_000;\r\nvar str = new string((char) 0x07f, strLength);\r\nvar json = JsonSerializer.Serialize(str, JsonSerializerOptions.Default);\r\n```\r\n\r\nThe problem appears to be:\r\n\r\nhttps://github.com/dotnet/runtime/blob/fb1fe7f3481fc88fa477268c18d60d824b83c314/src/libraries/System.Text.Json/src/System/Text/Json/Writer/Utf8JsonWriter.WriteValues.String.cs#L122\r\n\r\nwhich is overflowing for large values of `escapedValue.Length` (as is the case when serializing very large strings with lots of characters to escape), resulting in `maxRequired` either being negative number or a positive number that is possibly smaller than required, thus the internal memory buffer remaining at whatever size it currently is or being resized to a size that's too small and therefore leading to the IndexOutOfRangeException.\r\n\r\nI guess there needs to be a check (somewhere) that ensures that the provided `escapedValue` buffer is not larger than `(int.MaxValue - 3) / JsonConstants.MaxExpansionFactorWhileTranscoding` to be able to fit the serialized value in a maximally sized output buffer (assuming the output buffer isn't able to grow beyond 2 GB and that counting the UTF-8 octets to write for optimally sizing the output buffer is cost-prohibitive).",
          "createdAt": "2024-06-07T12:23:09Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-06-07T17:38:20Z",
                "user": "eiriktsarpalis"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-06-07T18:33:57Z",
                "user": "colejohnson66"
              }
            ],
            "totalCount": 2,
            "endCursor": "Y3Vyc29yOnYyOpHODk-K7g=="
          },
          "updatedAt": "2024-06-07T13:55:39Z",
          "id": "IC_kwDODI9FZc6Abofh"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Can reproduce as well. I suspect we might be able to solve this following a chunking approach, elements of which are being implemented in this PR: https://github.com/dotnet/runtime/pull/101356",
          "createdAt": "2024-06-07T17:43:25Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-06-07T17:43:25Z",
          "id": "IC_kwDODI9FZc6AdrYn"
        }
      ],
      "totalCount": 3,
      "endCursor": "Y3Vyc29yOnYyOpHOgHa2Jw=="
    },
    "url": "https://github.com/dotnet/runtime/issues/103155",
    "title": "`IndexOutOfRangeException` serializing large strings"
  },
  {
    "author": "matouskozak",
    "labels": [
      "area-System.Text.Json",
      "disabled-test"
    ],
    "createdAt": "2024-06-19T10:39:15Z",
    "body": "## Build Information\r\nBuild: https://dev.azure.com/dnceng-public/public/_build/results?buildId=709161\r\nBuild error leg or test failing: System.Text.Json.Tests\r\nAffected CI: `tvos_arm64_release_allsubsets_mono` (`runtime-extra-platforms`)\r\nRange of commits: https://github.com/dotnet/runtime/compare/7e9cab2b...4834a507\r\n<!-- Error message template  -->\r\n## Error Message\r\n\r\nFill the error message using [step by step known issues guidance](https://github.com/dotnet/arcade/blob/main/Documentation/Projects/Build%20Analysis/KnownIssueJsonStepByStep.md).\r\n\r\n<!-- Use ErrorMessage for String.Contains matches. Use ErrorPattern for regex matches (single line/no backtracking). Set BuildRetry to `true` to retry builds with this error. Set ExcludeConsoleLog to `true` to skip helix logs analysis. -->\r\n\r\n```json\r\n{\r\n  \"ErrorMessage\": \"[FAIL] System.Text.Json.Schema.Tests.JsonSchemaExporterTests_Reflection.TestTypes_GeneratesExpectedJsonSchema\",\r\n  \"BuildRetry\": false,\r\n  \"ExcludeConsoleLog\": false\r\n}\r\n```\r\n\r\nFull error message:\r\n```\r\n[17:52:04.8064100] 2024-06-15 14:52:04.854 System.Text.Json.Tests[70857:94526258] \t[FAIL] System.Text.Json.Schema.Tests.JsonSchemaExporterTests_Reflection.TestTypes_GeneratesExpectedJsonSchema(testData: TestData { Value = Left { value = value }, ExpectedJsonSchema = {\r\n[17:52:04.8064470]     \"type\": [\"object\",\"null\"],\r\n[17:52:04.8064550]     \"required\": [\"case\"],\r\n[17:52:04.8064630] 2024-06-15 14:52:04.855 System.Text.Json.Tests[70857:94526258]     \"anyOf\": [\r\n[17:52:04.8064690]         {\r\n[17:52:04.8064760]             \"properties\": {\r\n[17:52:04.8064840]                 \"case\": {\"const\":\"left\"},\r\n[17:52:04.8064910]                 \"value\": {\"type\":\"string\"}\r\n[17:52:04.8064970]             },\r\n[17:52:04.8065030]             \"required\": [\"value\"]\r\n[17:52:04.8065090]         },\r\n[17:52:04.8065140]         {\r\n[17:52:04.8065230]             \"properties\": {\r\n[17:52:04.8065300] 2024-06-15 14:52:04.855 System.Text.Json.Tests[70857:94526258]                 \"case\": {\"const\":\"right\"},\r\n[17:52:04.8065360]                 \"value\": {\"type\":\"integer\"}\r\n[17:52:04.8065420]             },\r\n[17:52:04.8065480]             \"required\": [\"value\"]\r\n[17:52:04.8065540]         }\r\n[17:52:04.8065590]     ]\r\n[17:52:04.8083930] 2024-06-15 14:52:04.856 System.Text.Json.Tests[70857:94526258] }, AdditionalValues = <>z__ReadOnlySingleElementList`1[System.Text.Json.Schema.Tests.JsonSchemaExporterTests+DiscriminatedUnion], Options = , Type = System.Text.Json.Schema.Tests.JsonSchemaExporterTests+DiscriminatedUnion })\r\n[17:52:04.8084520] Generated schema does not match the expected specification.\r\n[17:52:04.8084630] Expected:\r\n[17:52:04.8084720] {\r\n[17:52:04.8084790]   \"type\": [\r\n[17:52:04.8084870]     \"object\",\r\n[17:52:04.8084950]     \"null\"\r\n[17:52:04.8085020]   ],\r\n[17:52:04.8085100]   \"required\": [\r\n[17:52:04.8085170]     \"case\"\r\n[17:52:04.8085240]   ],\r\n[17:52:04.8085310]   \"anyOf\": [\r\n[17:52:04.8085380]     {\r\n[17:52:04.8085570] 2024-06-15 14:52:04.857 System.Text.Json.Tests[70857:94526258]       \"properties\": {\r\n[17:52:04.8085680]         \"case\": {\r\n[17:52:04.8085760]           \"const\": \"left\"\r\n[17:52:04.8085840]         },\r\n[17:52:04.8085920]         \"value\": {\r\n[17:52:04.8086000]           \"type\": \"string\"\r\n[17:52:04.8086070]         }\r\n[17:52:04.8086140]       },\r\n[17:52:04.8086200]       \"required\": [\r\n[17:52:04.8086270]         \"value\"\r\n[17:52:04.8086330]       ]\r\n[17:52:04.8086390]     },\r\n[17:52:04.8086460]     {\r\n[17:52:04.8086520]       \"properties\": {\r\n[17:52:04.8086590]         \"case\": {\r\n[17:52:04.8086660] 2024-06-15 14:52:04.857 System.Text.Json.Tests[70857:94526258]           \"const\": \"right\"\r\n[17:52:04.8086730]         },\r\n[17:52:04.8087880]         \"value\": {\r\n[17:52:04.8087960]           \"type\": \"integer\"\r\n[17:52:04.8088030]         }\r\n[17:52:04.8088090]       },\r\n[17:52:04.8088150]       \"required\": [\r\n[17:52:04.8088220]         \"value\"\r\n[17:52:04.8088280]       ]\r\n[17:52:04.8088340]     }\r\n[17:52:04.8088400]   ]\r\n[17:52:04.8088460] }\r\n[17:52:04.8088740] Actual:\r\n[17:52:04.8088800] {\r\n[17:52:04.8088880]   \"type\": [\r\n[17:52:04.8088930]     \"object\",\r\n[17:52:04.8088990]     \"null\"\r\n[17:52:04.8089050]   ],\r\n[17:52:04.8089110]   \"required\": [\r\n[17:52:04.8089170]     \"case\"\r\n[17:52:04.8089220]   ],\r\n[17:52:04.8089280]   \"anyOf\": [\r\n[17:52:04.8089330]     {\r\n[17:52:04.8089400] 2024-06-15 14:52:04.857 System.Text.Json.Tests[70857:94526258]       \"properties\": {\r\n[17:52:04.8089460]         \"case\": {\r\n[17:52:04.8089520]           \"const\": \"right\"\r\n[17:52:04.8089570]         },\r\n[17:52:04.8089630]         \"value\": {\r\n[17:52:04.8089690]           \"type\": \"integer\"\r\n[17:52:04.8089750]         }\r\n[17:52:04.8089800]       },\r\n[17:52:04.8089860]       \"required\": [\r\n[17:52:04.8089920]         \"value\"\r\n[17:52:04.8089970]       ]\r\n[17:52:04.8090030]     },\r\n[17:52:04.8090080]     {\r\n[17:52:04.8090140]       \"properties\": {\r\n[17:52:04.8090200]         \"case\": {\r\n[17:52:04.8090260]           \"const\": \"left\"\r\n[17:52:04.8090380] 2024-06-15 14:52:04.857 System.Text.Json.Tests[70857:94526258]         },\r\n[17:52:04.8090450]         \"value\": {\r\n[17:52:04.8090510]           \"type\": \"string\"\r\n[17:52:04.8090570]         }\r\n[17:52:04.8090630]       },\r\n[17:52:04.8090690]       \"required\": [\r\n[17:52:04.8090740]         \"value\"\r\n[17:52:04.8090800]       ]\r\n[17:52:04.8090860]     }\r\n[17:52:04.8090910]   ]\r\n[17:52:04.8090970] }\r\n[17:52:04.8091040] 2024-06-15 14:52:04.857 System.Text.Json.Tests[70857:94526258]    at System.Text.Json.Schema.Tests.JsonSchemaExporterTests.AssertValidJsonSchema(Type type, String expectedJsonSchema, JsonNode actualJsonSchema)\r\n[17:52:04.8091110]    at System.Text.Json.Schema.Tests.JsonSchemaExporterTests.TestTypes_GeneratesExpectedJsonSchema(ITestData testData)\r\n[17:52:04.8091180]    at System.Reflection.MethodBaseInvoker.InterpretedInvoke_Method(Object obj, IntPtr* args)\r\n[17:52:04.8091900] 2024-06-15 14:52:04.858 System.Text.Json.Tests[70857:94526258]    at System.Reflection.MethodBaseInvoker.InvokeDirectByRefWithFewArgs(Object obj, Span`1 copyOfArgs, BindingFlags invokeAttr)\r\n[17:52:04.8220480] 2024-06-15 14:52:04.870 System.Text.Json.Tests[70857:94526258] \t[FAIL] System.Text.Json.Schema.Tests.JsonSchemaExporterTests_Reflection.TestTypes_GeneratesExpectedJsonSchema(testData: TestData { Value = System.Text.Json.Schema.Tests.JsonSchemaExporterTests+PocoCombiningPolymorphicTypeAndDerivedTypes, ExpectedJsonSchema = {\r\n[17:52:04.8221240]     \"type\": [\"object\",\"null\"],\r\n[17:52:04.8221410]     \"properties\": {\r\n[17:52:04.8221510]         \"PolymorphicValue\": {\r\n[17:52:04.8221640]             \"anyOf\": [\r\n[17:52:04.8221730]                 {\r\n[17:52:04.8221810]                     \"type\": \"object\",\r\n[17:52:04.8221900]                     \"properties\": {\r\n[17:52:04.8234170] 2024-06-15 14:52:04.872 System.Text.Json.Tests[70857:94526258]                         \"BaseValue\": {\"type\":\"integer\"},\r\n[17:52:04.8234460]                         \"DerivedValue\": {\"type\":[\"string\", \"null\"]}\r\n[17:52:04.8234560]                     }\r\n[17:52:04.8234650]                 },\r\n[17:52:04.8234740]                 {\r\n[17:52:04.8234820]                     \"type\": \"object\",\r\n[17:52:04.8234930]                     \"properties\": {\r\n[17:52:04.8235370] 2024-06-15 14:52:04.872 System.Text.Json.Tests[70857:94526258]                         \"$type\": {\"const\":\"derivedPoco\"},\r\n[17:52:04.8235490]                         \"BaseValue\": {\"type\":\"integer\"},\r\n[17:52:04.8235580]                         \"DerivedValue\": {\"type\":[\"string\",\"null\"]}\r\n[17:52:04.8235670]                     },\r\n[17:52:04.8235750]                     \"required\": [\"$type\"]\r\n[17:52:04.8235830]                 },\r\n[17:52:04.8235910]                 {\r\n[17:52:04.8238080] 2024-06-15 14:52:04.873 System.Text.Json.Tests[70857:94526258]                     \"type\": \"object\",\r\n[17:52:04.8238330]                     \"properties\": {\r\n[17:52:04.8238480]                         \"$type\": {\"const\":42},\r\n[17:52:04.8238570]                         \"BaseValue\": {\"type\":\"integer\"},\r\n[17:52:04.8238660]                         \"DerivedValue\": {\"type\":[\"string\", \"null\"]}\r\n[17:52:04.8238740]                     },\r\n[17:52:04.8246780] 2024-06-15 14:52:04.873 System.Text.Json.Tests[70857:94526258]                     \"required\": [\"$type\"]\r\n[17:52:04.8247020]                 },\r\n[17:52:04.8247130]                 {\r\n[17:52:04.8247220]                     \"type\": \"array\",\r\n[17:52:04.8247300]                     \"items\": {\"type\":\"integer\"}\r\n[17:52:04.8247390]                 },\r\n[17:52:04.8247470]                 {\r\n[17:52:04.8247550]                     \"type\": \"object\",\r\n[17:52:04.8247710] 2024-06-15 14:52:04.874 System.Text.Json.Tests[70857:94526258]                     \"properties\": {\r\n[17:52:04.8247830]                         \"$type\": {\"const\":\"derivedCollection\"},\r\n[17:52:04.8247910]                         \"$values\": {\r\n[17:52:04.8248000]                             \"type\": \"array\",\r\n[17:52:04.8248090]                             \"items\": {\"type\":\"integer\"}\r\n[17:52:04.8248170]                         }\r\n[17:52:04.8248260] 2024-06-15 14:52:04.874 System.Text.Json.Tests[70857:94526258]                     },\r\n[17:52:04.8248350]                     \"required\": [\"$type\"]\r\n[17:52:04.8248430]                 },\r\n[17:52:04.8248500]                 {\r\n[17:52:04.8248590]                     \"type\": \"object\",\r\n[17:52:04.8248670]                     \"additionalProperties\":{\"type\": \"integer\"}\r\n[17:52:04.8248750]                 },\r\n[17:52:04.8248830]                 {\r\n[17:52:04.8248960] 2024-06-15 14:52:04.874 System.Text.Json.Tests[70857:94526258]                     \"type\": \"object\",\r\n[17:52:04.8249040]                     \"properties\": {\r\n[17:52:04.8249130]                         \"$type\": {\"const\":\"derivedDictionary\"}\r\n[17:52:04.8249220]                     },\r\n[17:52:04.8249300]                     \"additionalProperties\":{\"type\": \"integer\"},\r\n[17:52:04.8249390]                     \"required\": [\"$type\"]\r\n[17:52:04.8249470]                 }\r\n[17:52:04.8263210] 2024-06-15 14:52:04.875 System.Text.Json.Tests[70857:94526258]             ]\r\n[17:52:04.8263430]         },\r\n[17:52:04.8263540]         \"DiscriminatedUnion\":{\r\n[17:52:04.8263660]             \"type\": \"object\",\r\n[17:52:04.8263740]             \"required\": [\"case\"],\r\n[17:52:04.8263830]             \"anyOf\": [\r\n[17:52:04.8263910]                 {\r\n[17:52:04.8264000]                     \"properties\": {\r\n[17:52:04.8264090]                         \"case\": {\"const\":\"left\"},\r\n[17:52:04.8264240] 2024-06-15 14:52:04.875 System.Text.Json.Tests[70857:94526258]                         \"value\": {\"type\":\"string\"}\r\n[17:52:04.8264340]                     },\r\n[17:52:04.8264430]                     \"required\": [\"value\"]\r\n[17:52:04.8264520]                 },\r\n[17:52:04.8264600]                 {\r\n[17:52:04.8264690]                     \"properties\": {\r\n[17:52:04.8264770]                         \"case\": {\"const\":\"right\"},\r\n[17:52:04.8264930] 2024-06-15 14:52:04.875 System.Text.Json.Tests[70857:94526258]                         \"value\": {\"type\":\"integer\"}\r\n[17:52:04.8265020]                     },\r\n[17:52:04.8265100]                     \"required\": [\"value\"]\r\n[17:52:04.8265180]                 }\r\n[17:52:04.8265260]             ]\r\n[17:52:04.8265340]         },\r\n[17:52:04.8265430]         \"DerivedValue1\": {\r\n[17:52:04.8265510]             \"type\": \"object\",\r\n[17:52:04.8265590]             \"properties\": {\r\n[17:52:04.8265690] 2024-06-15 14:52:04.875 System.Text.Json.Tests[70857:94526258]                 \"BaseValue\": {\"type\":\"integer\"},\r\n[17:52:04.8265780]                 \"DerivedValue\": {\"type\":[\"string\", \"null\"]}\r\n[17:52:04.8265870]             }\r\n[17:52:04.8265940]         },\r\n[17:52:04.8266030]         \"DerivedValue2\": {\r\n[17:52:04.8266110]             \"type\": \"object\",\r\n[17:52:04.8266190]             \"properties\": {\r\n[17:52:04.8266280]                 \"BaseValue\": {\"type\":\"integer\"},\r\n[17:52:04.8266430] 2024-06-15 14:52:04.875 System.Text.Json.Tests[70857:94526258]                 \"DerivedValue\": {\"type\":[\"string\", \"null\"]}\r\n[17:52:04.8266520]             }\r\n[17:52:04.8266600]         }\r\n[17:52:04.8266680]     }\r\n[17:52:04.8266780] }, AdditionalValues = , Options = , Type = System.Text.Json.Schema.Tests.JsonSchemaExporterTests+PocoCombiningPolymorphicTypeAndDerivedTypes })\r\n[17:52:04.8266870] 2024-06-15 14:52:04.875 System.Text.Json.Tests[70857:94526258] Generated schema does not match the expected specification.\r\n[17:52:04.8266970] Expected:\r\n[17:52:04.8267050] {\r\n[17:52:04.8267130]   \"type\": [\r\n[17:52:04.8267220]     \"object\",\r\n[17:52:04.8267300]     \"null\"\r\n[17:52:04.8267380]   ],\r\n[17:52:04.8267460]   \"properties\": {\r\n[17:52:04.8267540]     \"PolymorphicValue\": {\r\n[17:52:04.8267620]       \"anyOf\": [\r\n[17:52:04.8267700]         {\r\n[17:52:04.8267780]           \"type\": \"object\",\r\n[17:52:04.8267860]           \"properties\": {\r\n[17:52:04.8267940]             \"BaseValue\": {\r\n[17:52:04.8268020]               \"type\": \"integer\"\r\n[17:52:04.8281690] 2024-06-15 14:52:04.877 System.Text.Json.Tests[70857:94526258]             },\r\n[17:52:04.8281880]             \"DerivedValue\": {\r\n[17:52:04.8281960]               \"type\": [\r\n[17:52:04.8282030]                 \"string\",\r\n[17:52:04.8282090]                 \"null\"\r\n[17:52:04.8282150]               ]\r\n[17:52:04.8282210]             }\r\n[17:52:04.8282270]           }\r\n[17:52:04.8282330]         },\r\n[17:52:04.8282390]         {\r\n[17:52:04.8282450]           \"type\": \"object\",\r\n[17:52:04.8282510]           \"properties\": {\r\n[17:52:04.8282570]             \"$type\": {\r\n[17:52:04.8296140] 2024-06-15 14:52:04.878 System.Text.Json.Tests[70857:94526258]               \"const\": \"derivedPoco\"\r\n[17:52:04.8296330]             },\r\n[17:52:04.8296410]             \"BaseValue\": {\r\n[17:52:04.8296480]               \"type\": \"integer\"\r\n[17:52:04.8296550]             },\r\n[17:52:04.8296610]             \"DerivedValue\": {\r\n[17:52:04.8296680]               \"type\": [\r\n[17:52:04.8296750]                 \"string\",\r\n[17:52:04.8296810]                 \"null\"\r\n[17:52:04.8296870]               ]\r\n[17:52:04.8296940]             }\r\n[17:52:04.8297060] 2024-06-15 14:52:04.878 System.Text.Json.Tests[70857:94526258]           },\r\n[17:52:04.8297130]           \"required\": [\r\n[17:52:04.8297200]             \"$type\"\r\n[17:52:04.8297260]           ]\r\n[17:52:04.8297330]         },\r\n[17:52:04.8297410]         {\r\n[17:52:04.8297480]           \"type\": \"object\",\r\n[17:52:04.8297540]           \"properties\": {\r\n[17:52:04.8297610]             \"$type\": {\r\n[17:52:04.8297670]               \"const\": 42\r\n[17:52:04.8297730]             },\r\n[17:52:04.8297790]             \"BaseValue\": {\r\n[17:52:04.8303450] 2024-06-15 14:52:04.880 System.Text.Json.Tests[70857:94526258]               \"type\": \"integer\"\r\n[17:52:04.8303610]             },\r\n[17:52:04.8303680]             \"DerivedValue\": {\r\n[17:52:04.8303740]               \"type\": [\r\n[17:52:04.8303810]                 \"string\",\r\n[17:52:04.8303870]                 \"null\"\r\n[17:52:04.8303950]               ]\r\n[17:52:04.8304020]             }\r\n[17:52:04.8304070]           },\r\n[17:52:04.8304140]           \"required\": [\r\n[17:52:04.8304200]             \"$type\"\r\n[17:52:04.8304260]           ]\r\n[17:52:04.8304320]         },\r\n[17:52:04.8304380]         {\r\n[17:52:04.8309520] 2024-06-15 14:52:04.880 System.Text.Json.Tests[70857:94526258]           \"type\": \"array\",\r\n[17:52:04.8309710]           \"items\": {\r\n[17:52:04.8309790]             \"type\": \"integer\"\r\n[17:52:04.8309850]           }\r\n[17:52:04.8309920]         },\r\n[17:52:04.8309970]         {\r\n[17:52:04.8310030]           \"type\": \"object\",\r\n[17:52:04.8310100]           \"properties\": {\r\n[17:52:04.8310160]             \"$type\": {\r\n[17:52:04.8310220]               \"const\": \"derivedCollection\"\r\n[17:52:04.8310280]             },\r\n[17:52:04.8310350] 2024-06-15 14:52:04.880 System.Text.Json.Tests[70857:94526258]             \"$values\": {\r\n[17:52:04.8310410]               \"type\": \"array\",\r\n[17:52:04.8310470]               \"items\": {\r\n[17:52:04.8310530]                 \"type\": \"integer\"\r\n[17:52:04.8310590]               }\r\n[17:52:04.8310670]             }\r\n[17:52:04.8310720]           },\r\n[17:52:04.8310780]           \"required\": [\r\n[17:52:04.8310840]             \"$type\"\r\n[17:52:04.8310900]           ]\r\n[17:52:04.8310960]         },\r\n[17:52:04.8311020]         {\r\n[17:52:04.8311080]           \"type\": \"object\",\r\n[17:52:04.8331370] 2024-06-15 14:52:04.881 System.Text.Json.Tests[70857:94526258]           \"additionalProperties\": {\r\n[17:52:04.8331530]             \"type\": \"integer\"\r\n[17:52:04.8331600]           }\r\n[17:52:04.8331670]         },\r\n[17:52:04.8331800]         {\r\n[17:52:04.8331870]           \"type\": \"object\",\r\n[17:52:04.8331930]           \"properties\": {\r\n[17:52:04.8332000]             \"$type\": {\r\n[17:52:04.8332060]               \"const\": \"derivedDictionary\"\r\n[17:52:04.8332120]             }\r\n[17:52:04.8332180]           },\r\n[17:52:04.8332310] 2024-06-15 14:52:04.882 System.Text.Json.Tests[70857:94526258]           \"additionalProperties\": {\r\n[17:52:04.8332380]             \"type\": \"integer\"\r\n[17:52:04.8332440]           },\r\n[17:52:04.8332500]           \"required\": [\r\n[17:52:04.8332560]             \"$type\"\r\n[17:52:04.8332630]           ]\r\n[17:52:04.8332690]         }\r\n[17:52:04.8332750]       ]\r\n[17:52:04.8332810]     },\r\n[17:52:04.8333030]     \"DiscriminatedUnion\": {\r\n[17:52:04.8333090]       \"type\": \"object\",\r\n[17:52:04.8333160]       \"required\": [\r\n[17:52:04.8333370]         \"case\"\r\n[17:52:04.8333430]       ],\r\n[17:52:04.8333490]       \"anyOf\": [\r\n[17:52:04.8333710]         {\r\n[17:52:04.8333780] 2024-06-15 14:52:04.882 System.Text.Json.Tests[70857:94526258]           \"properties\": {\r\n[17:52:04.8333840]             \"case\": {\r\n[17:52:04.8333910]               \"const\": \"left\"\r\n[17:52:04.8333980]             },\r\n[17:52:04.8334040]             \"value\": {\r\n[17:52:04.8334110]               \"type\": \"string\"\r\n[17:52:04.8334330]             }\r\n[17:52:04.8334390]           },\r\n[17:52:04.8334450]           \"required\": [\r\n[17:52:04.8334510]             \"value\"\r\n[17:52:04.8334570]           ]\r\n[17:52:04.8334630]         },\r\n[17:52:04.8334690]         {\r\n[17:52:04.8334820] 2024-06-15 14:52:04.882 System.Text.Json.Tests[70857:94526258]           \"properties\": {\r\n[17:52:04.8334890]             \"case\": {\r\n[17:52:04.8334960]               \"const\": \"right\"\r\n[17:52:04.8335020]             },\r\n[17:52:04.8335080]             \"value\": {\r\n[17:52:04.8335140]               \"type\": \"integer\"\r\n[17:52:04.8335200]             }\r\n[17:52:04.8335260]           },\r\n[17:52:04.8335340]           \"required\": [\r\n[17:52:04.8335400]             \"value\"\r\n[17:52:04.8335460]           ]\r\n[17:52:04.8335520]         }\r\n[17:52:04.8335580]       ]\r\n[17:52:04.8335640]     },\r\n[17:52:04.8335710] 2024-06-15 14:52:04.882 System.Text.Json.Tests[70857:94526258]     \"DerivedValue1\": {\r\n[17:52:04.8335770]       \"type\": \"object\",\r\n[17:52:04.8335830]       \"properties\": {\r\n[17:52:04.8335900]         \"BaseValue\": {\r\n[17:52:04.8335960]           \"type\": \"integer\"\r\n[17:52:04.8336020]         },\r\n[17:52:04.8336080]         \"DerivedValue\": {\r\n[17:52:04.8336140]           \"type\": [\r\n[17:52:04.8336200]             \"string\",\r\n[17:52:04.8336260]             \"null\"\r\n[17:52:04.8336320]           ]\r\n[17:52:04.8336380]         }\r\n[17:52:04.8336430]       }\r\n[17:52:04.8336490]     },\r\n[17:52:04.8336560] 2024-06-15 14:52:04.882 System.Text.Json.Tests[70857:94526258]     \"DerivedValue2\": {\r\n[17:52:04.8336620]       \"type\": \"object\",\r\n[17:52:04.8336680]       \"properties\": {\r\n[17:52:04.8336740]         \"BaseValue\": {\r\n[17:52:04.8336800]           \"type\": \"integer\"\r\n[17:52:04.8336860]         },\r\n[17:52:04.8336920]         \"DerivedValue\": {\r\n[17:52:04.8336980]           \"type\": [\r\n[17:52:04.8337040]             \"string\",\r\n[17:52:04.8337100]             \"null\"\r\n[17:52:04.8337160]           ]\r\n[17:52:04.8337220]         }\r\n[17:52:04.8337280]       }\r\n[17:52:04.8337340]     }\r\n[17:52:04.8337400]   }\r\n[17:52:04.8337460] }\r\n[17:52:04.8348820] 2024-06-15 14:52:04.884 System.Text.Json.Tests[70857:94526258] Actual:\r\n[17:52:04.8349010] {\r\n[17:52:04.8349080]   \"type\": [\r\n[17:52:04.8349150]     \"object\",\r\n[17:52:04.8349220]     \"null\"\r\n[17:52:04.8349290]   ],\r\n[17:52:04.8349360]   \"properties\": {\r\n[17:52:04.8349420]     \"PolymorphicValue\": {\r\n[17:52:04.8349480]       \"anyOf\": [\r\n[17:52:04.8349540]         {\r\n[17:52:04.8349600]           \"type\": \"object\",\r\n[17:52:04.8349660]           \"properties\": {\r\n[17:52:04.8349730]             \"DerivedValue\": {\r\n[17:52:04.8349790]               \"type\": [\r\n[17:52:04.8349850]                 \"string\",\r\n[17:52:04.8364930] 2024-06-15 14:52:04.885 System.Text.Json.Tests[70857:94526258]                 \"null\"\r\n[17:52:04.8365120]               ]\r\n[17:52:04.8365200]             },\r\n[17:52:04.8365270]             \"BaseValue\": {\r\n[17:52:04.8365490]               \"type\": \"integer\"\r\n[17:52:04.8365550]             }\r\n[17:52:04.8365630]           }\r\n[17:52:04.8365700]         },\r\n[17:52:04.8365770]         {\r\n[17:52:04.8365990]           \"type\": \"object\",\r\n[17:52:04.8366050]           \"properties\": {\r\n[17:52:04.8366110]             \"$type\": {\r\n[17:52:04.8366440] 2024-06-15 14:52:04.885 System.Text.Json.Tests[70857:94526258]               \"const\": \"derivedPoco\"\r\n[17:52:04.8366510]             },\r\n[17:52:04.8366740]             \"DerivedValue\": {\r\n[17:52:04.8366800]               \"type\": [\r\n[17:52:04.8366860]                 \"string\",\r\n[17:52:04.8366920]                 \"null\"\r\n[17:52:04.8366980]               ]\r\n[17:52:04.8367040]             },\r\n[17:52:04.8367100]             \"BaseValue\": {\r\n[17:52:04.8367160]               \"type\": \"integer\"\r\n[17:52:04.8367220]             }\r\n[17:52:04.8367280]           },\r\n[17:52:04.8367350] 2024-06-15 14:52:04.885 System.Text.Json.Tests[70857:94526258]           \"required\": [\r\n[17:52:04.8367410]             \"$type\"\r\n[17:52:04.8367460]           ]\r\n[17:52:04.8367520]         },\r\n[17:52:04.8367590]         {\r\n[17:52:04.8367810]           \"type\": \"object\",\r\n[17:52:04.8367880]           \"properties\": {\r\n[17:52:04.8367950]             \"$type\": {\r\n[17:52:04.8368020]               \"const\": 42\r\n[17:52:04.8368230]             },\r\n[17:52:04.8368300]             \"DerivedValue\": {\r\n[17:52:04.8368360]               \"type\": [\r\n[17:52:04.8368420] 2024-06-15 14:52:04.886 System.Text.Json.Tests[70857:94526258]                 \"string\",\r\n[17:52:04.8368490]                 \"null\"\r\n[17:52:04.8368540]               ]\r\n[17:52:04.8368600]             },\r\n[17:52:04.8368670]             \"BaseValue\": {\r\n[17:52:04.8368730]               \"type\": \"integer\"\r\n[17:52:04.8368790]             }\r\n[17:52:04.8368850]           },\r\n[17:52:04.8368920]           \"required\": [\r\n[17:52:04.8368970]             \"$type\"\r\n[17:52:04.8369050]           ]\r\n[17:52:04.8369120]         },\r\n[17:52:04.8369180]         {\r\n[17:52:04.8369280] 2024-06-15 14:52:04.886 System.Text.Json.Tests[70857:94526258]           \"type\": \"array\",\r\n[17:52:04.8369360]           \"items\": {\r\n[17:52:04.8369420]             \"type\": \"integer\"\r\n[17:52:04.8369480]           }\r\n[17:52:04.8369540]         },\r\n[17:52:04.8369600]         {\r\n[17:52:04.8369660]           \"type\": \"object\",\r\n[17:52:04.8369720]           \"properties\": {\r\n[17:52:04.8369780]             \"$type\": {\r\n[17:52:04.8369840]               \"const\": \"derivedCollection\"\r\n[17:52:04.8369900]             },\r\n[17:52:04.8369960]             \"$values\": {\r\n[17:52:04.8393750] 2024-06-15 14:52:04.888 System.Text.Json.Tests[70857:94526258]               \"type\": \"array\",\r\n[17:52:04.8393920]               \"items\": {\r\n[17:52:04.8394000]                 \"type\": \"integer\"\r\n[17:52:04.8394060]               }\r\n[17:52:04.8394120]             }\r\n[17:52:04.8394180]           },\r\n[17:52:04.8394240]           \"required\": [\r\n[17:52:04.8394300]             \"$type\"\r\n[17:52:04.8394360]           ]\r\n[17:52:04.8394410]         },\r\n[17:52:04.8394480]         {\r\n[17:52:04.8394540]           \"type\": \"object\",\r\n[17:52:04.8417000] 2024-06-15 14:52:04.890 System.Text.Json.Tests[70857:94526258]           \"additionalProperties\": {\r\n[17:52:04.8417180]             \"type\": \"integer\"\r\n[17:52:04.8417270]           }\r\n[17:52:04.8417330]         },\r\n[17:52:04.8417390]         {\r\n[17:52:04.8417450]           \"type\": \"object\",\r\n[17:52:04.8417510]           \"properties\": {\r\n[17:52:04.8417590]             \"$type\": {\r\n[17:52:04.8417660]               \"const\": \"derivedDictionary\"\r\n[17:52:04.8417720]             }\r\n[17:52:04.8417780]           },\r\n[17:52:04.8417840]           \"required\": [\r\n[17:52:04.8417960] 2024-06-15 14:52:04.891 System.Text.Json.Tests[70857:94526258]             \"$type\"\r\n[17:52:04.8418020]           ],\r\n[17:52:04.8418080]           \"additionalProperties\": {\r\n[17:52:04.8418150]             \"type\": \"integer\"\r\n[17:52:04.8418200]           }\r\n[17:52:04.8418260]         }\r\n[17:52:04.8418320]       ]\r\n[17:52:04.8418380]     },\r\n[17:52:04.8418440]     \"DiscriminatedUnion\": {\r\n[17:52:04.8418500]       \"type\": \"object\",\r\n[17:52:04.8418560]       \"required\": [\r\n[17:52:04.8418620]         \"case\"\r\n[17:52:04.8418680]       ],\r\n[17:52:04.8418740]       \"anyOf\": [\r\n[17:52:04.8418810]         {\r\n[17:52:04.8418870] 2024-06-15 14:52:04.891 System.Text.Json.Tests[70857:94526258]           \"properties\": {\r\n[17:52:04.8418940]             \"case\": {\r\n[17:52:04.8419000]               \"const\": \"right\"\r\n[17:52:04.8419060]             },\r\n[17:52:04.8419120]             \"value\": {\r\n[17:52:04.8419180]               \"type\": \"integer\"\r\n[17:52:04.8419390]             }\r\n[17:52:04.8419450]           },\r\n[17:52:04.8419520]           \"required\": [\r\n[17:52:04.8419580]             \"value\"\r\n[17:52:04.8419790]           ]\r\n[17:52:04.8419850]         },\r\n[17:52:04.8419900]         {\r\n[17:52:04.8420010] 2024-06-15 14:52:04.891 System.Text.Json.Tests[70857:94526258]           \"properties\": {\r\n[17:52:04.8420080]             \"case\": {\r\n[17:52:04.8420140]               \"const\": \"left\"\r\n[17:52:04.8420200]             },\r\n[17:52:04.8420270]             \"value\": {\r\n[17:52:04.8420340]               \"type\": \"string\"\r\n[17:52:04.8420390]             }\r\n[17:52:04.8420450]           },\r\n[17:52:04.8420510]           \"required\": [\r\n[17:52:04.8420570]             \"value\"\r\n[17:52:04.8420630]           ]\r\n[17:52:04.8420690]         }\r\n[17:52:04.8420750]       ]\r\n[17:52:04.8420800]     },\r\n[17:52:04.8420870] 2024-06-15 14:52:04.891 System.Text.Json.Tests[70857:94526258]     \"DerivedValue1\": {\r\n[17:52:04.8420930]       \"type\": \"object\",\r\n[17:52:04.8420990]       \"properties\": {\r\n[17:52:04.8421210]         \"DerivedValue\": {\r\n[17:52:04.8421280]           \"type\": [\r\n[17:52:04.8421340]             \"string\",\r\n[17:52:04.8421550]             \"null\"\r\n[17:52:04.8421610]           ]\r\n[17:52:04.8421660]         },\r\n[17:52:04.8421720]         \"BaseValue\": {\r\n[17:52:04.8421790]           \"type\": \"integer\"\r\n[17:52:04.8421840]         }\r\n[17:52:04.8421900]       }\r\n[17:52:04.8421960]     },\r\n[17:52:04.8440620] 2024-06-15 14:52:04.893 System.Text.Json.Tests[70857:94526258]     \"DerivedValue2\": {\r\n[17:52:04.8440810]       \"type\": \"object\",\r\n[17:52:04.8440890]       \"properties\": {\r\n[17:52:04.8440980]         \"DerivedValue\": {\r\n[17:52:04.8441040]           \"type\": [\r\n[17:52:04.8441100]             \"string\",\r\n[17:52:04.8441160]             \"null\"\r\n[17:52:04.8441220]           ]\r\n[17:52:04.8441280]         },\r\n[17:52:04.8441340]         \"BaseValue\": {\r\n[17:52:04.8441400]           \"type\": \"integer\"\r\n[17:52:04.8441460]         }\r\n[17:52:04.8441520]       }\r\n[17:52:04.8441580]     }\r\n[17:52:04.8441640]   }\r\n[17:52:04.8441700] }\r\n[17:52:04.8491800] 2024-06-15 14:52:04.897 System.Text.Json.Tests[70857:94526258]    at System.Text.Json.Schema.Tests.JsonSchemaExporterTests.AssertValidJsonSchema(Type type, String expectedJsonSchema, JsonNode actualJsonSchema)\r\n[17:52:04.8491970]    at System.Text.Json.Schema.Tests.JsonSchemaExporterTests.TestTypes_GeneratesExpectedJsonSchema(ITestData testData)\r\n[17:52:04.8492380] 2024-06-15 14:52:04.897 System.Text.Json.Tests[70857:94526258]    at System.Reflection.MethodBaseInvoker.InterpretedInvoke_Method(Object obj, IntPtr* args)\r\n[17:52:04.8492550]    at System.Reflection.MethodBaseInvoker.InvokeDirectByRefWithFewArgs(Object obj, Span`1 copyOfArgs, BindingFlags invokeAttr)\r\n```\r\n\r\n<!-- Known issue validation start -->\r\n ### Known issue validation\r\n**Build: :mag_right:** https://dev.azure.com/dnceng-public/public/_build/results?buildId=709161\r\n**Error message validated:** `[[FAIL] System.Text.Json.Schema.Tests.JsonSchemaExporterTests_Reflection.TestTypes_GeneratesExpectedJsonSchema`]\r\n**Result validation:** :x: Known issue did not match with the provided build.\r\n**Validation performed at:** 6/19/2024 10:40:07 AM UTC\r\n<!-- Known issue validation end -->\r\n<!--Known issue error report start -->\r\n\r\n### Report\r\n\r\n|Build|Definition|Test|Pull Request|\r\n|---|---|---|---|\r\n|[733681](https://dev.azure.com/dnceng-public/public/_build/results?buildId=733681)|dotnet/runtime|[WasmTestOnV8-ST-System.Text.Json.Tests.WorkItemExecution](https://dev.azure.com/dnceng-public/public/_build/results?buildId=733681&view=ms.vss-test-web.build-test-results-tab&runId=18471632&resultId=185254)|dotnet/runtime#104575|\r\n#### Summary\r\n|24-Hour Hit Count|7-Day Hit Count|1-Month Count|\r\n|---|---|---|\r\n|0|0|1|\r\n<!--Known issue error report end -->",
    "number": 103694,
    "reactions": {
      "hasNextPage": false,
      "nodes": [],
      "totalCount": 0,
      "endCursor": null
    },
    "updatedAt": "2024-07-23T11:44:34Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": "dotnet-policy-service",
          "body": "Tagging subscribers to 'os-tvos': @vitek-karas, @kotlarmilos, @ivanpovazan, @steveisok, @akoeplinger\nSee info in area-owners.md if you want to be subscribed.\n<!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. -->",
          "createdAt": "2024-06-19T10:39:23Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-06-19T10:39:23Z",
          "id": "IC_kwDODI9FZc6B1vtA"
        },
        {
          "author": "dotnet-policy-service",
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. -->",
          "createdAt": "2024-06-19T10:39:32Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-06-19T10:39:32Z",
          "id": "IC_kwDODI9FZc6B1vwo"
        },
        {
          "author": "matouskozak",
          "body": "Could it be related to https://github.com/dotnet/runtime/pull/103322 @eiriktsarpalis ?",
          "createdAt": "2024-06-19T10:39:53Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-06-19T10:39:53Z",
          "id": "IC_kwDODI9FZc6B1v5f"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Here is the diff between expected and actual documents:\r\n\r\n![image](https://github.com/dotnet/runtime/assets/2813363/885c79c1-65dd-45ca-bc09-6994ff5e6e0d)\r\n\r\nIt would seem that [custom attributes on the declaring type](https://github.com/dotnet/runtime/blob/153296b162f6db9f66e850432569977d74a3e867/src/libraries/System.Text.Json/tests/Common/JsonSchemaExporterTests.TestTypes.cs#L1377-L1378) are being returned in an unexpected order for the case of mono, which is correspondingly changing the order of derived types in the `anyOf` array. This results in a syntactically different JSON document but a semantically equivalent JSON schema.\r\n\r\nI can't think of a good way to fix the test other than temporarily disabling it in mono. @vitek-karas @lewing is the attribute ordering a known issue and do you have any alternative suggestions?",
          "createdAt": "2024-06-19T11:49:46Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-06-21T11:45:03Z",
                "user": "matouskozak"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHODmhrVQ=="
          },
          "updatedAt": "2024-06-19T11:50:51Z",
          "id": "IC_kwDODI9FZc6B2Uub"
        },
        {
          "author": "lambdageek",
          "body": "I don't think the custom attributes APIs guarantee a particular order.  The order could change even for CoreCLR from one release to the next.\r\n\r\nThe Json schema exporter should order the custom attribute values into a deterministic order if that is important.  Otherwise the schema comparison operation in the testsuite should allow for `anyOf` to be unordered when doing its comparison",
          "createdAt": "2024-06-28T15:38:21Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-06-28T15:38:21Z",
          "id": "IC_kwDODI9FZc6C9o1Y"
        },
        {
          "author": "vitek-karas",
          "body": "Removing platform labels - the test failed on tvOS/arm64, but the behavior is undefined by any runtime and the test/product should not rely on it anywhere.",
          "createdAt": "2024-07-17T16:54:43Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-07-17T16:54:43Z",
          "id": "IC_kwDODI9FZc6FJIu_"
        },
        {
          "author": "eiriktsarpalis",
          "body": "The issue fundamentally is that we don't have the tools to check if two schemas are equivalent, so we have to resort to syntactic comparison (related: https://github.com/json-schema-org/json-schema-spec/issues/474). At the same time, enforcing determinism by sorting items on the product side is a step in the wrong direction since it negatively impacts human readability in the majority of runtimes that do happen to report attributes in the order of declaration.\r\n\r\nI would be inclined to just disable the test in the impacted runtime at this stage.",
          "createdAt": "2024-07-18T09:31:06Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-07-18T09:31:06Z",
          "id": "IC_kwDODI9FZc6FR3mA"
        }
      ],
      "totalCount": 7,
      "endCursor": "Y3Vyc29yOnYyOpHOhUd5gA=="
    },
    "url": "https://github.com/dotnet/runtime/issues/103694",
    "title": "[Apple][TvOS][JsonSchemaExporter] Generated schema does not match the expected specification"
  },
  {
    "author": "NonSpicyBurrito",
    "labels": [
      "api-suggestion",
      "area-System.Text.Json"
    ],
    "createdAt": "2024-06-21T19:03:20Z",
    "body": "### Background and motivation\n\nPolymorphic JSON using a boolean discriminator cannot currently be de/serialized, for example:\r\n```ts\r\n// TypeScript definition\r\ntype Content =\r\n    | { isRich: false, text: string }\r\n    | { isRich: true, text: RichText }\r\n```\n\n### API Proposal\n\n```csharp\r\nnamespace System.Text.Json.Serialization.Metadata\r\n{\r\n    public readonly struct JsonDerivedType\r\n    {\r\n        public JsonDerivedType(Type derivedType, bool typeDiscriminator);\r\n    }\r\n}\r\n```\n\n### API Usage\n\n```csharp\r\n[JsonPolymorphic(TypeDiscriminatorPropertyName = \"isRich\")]\r\n[JsonDerivedType(typeof(PlainTextContent), typeDiscriminator: false)]\r\n[JsonDerivedType(typeof(RichTextContent), typeDiscriminator: true)]\r\nabstract record Content;\r\n\r\nrecord PlainTextContent(string Text) : Content;\r\n\r\nrecord RichTextContent(RichText Text) : Content;\r\n```\n\n### Alternative Designs\n\n_No response_\n\n### Risks\n\n_No response_",
    "number": 103834,
    "reactions": {
      "hasNextPage": false,
      "nodes": [],
      "totalCount": 0,
      "endCursor": null
    },
    "updatedAt": "2025-03-31T16:29:44Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": "dotnet-policy-service",
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. -->",
          "createdAt": "2024-06-21T19:03:38Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-06-21T19:03:38Z",
          "id": "IC_kwDODI9FZc6CIouD"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Seems doable in principle, although the use cases seem a bit limited if I'm honest.",
          "createdAt": "2024-06-21T19:58:19Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-06-21T19:58:19Z",
          "id": "IC_kwDODI9FZc6CI5ps"
        },
        {
          "author": "anarian",
          "body": "Here's some use cases I've seen in the wild. Both the Google reCAPTCHA and Cloudflare Turnstile response objects contain a `success` boolean that indicate whether it's successful or not, and the response objects may or may not contain properties depending on the response.\n\nhttps://developers.google.com/recaptcha/docs/verify#api-response\n```\n{\n  \"success\": true|false,\n  \"challenge_ts\": timestamp,  // timestamp of the challenge load (ISO format yyyy-MM-dd'T'HH:mm:ssZZ)\n  \"hostname\": string,         // the hostname of the site where the reCAPTCHA was solved\n  \"error-codes\": [...]        // optional\n}\n```\n\nhttps://developers.cloudflare.com/turnstile/get-started/server-side-validation/#accepted-parameters\n```\n{\n  \"success\": true,\n  \"challenge_ts\": \"2022-02-28T15:14:30.096Z\",\n  \"hostname\": \"example.com\",\n  \"error-codes\": [],\n  \"action\": \"login\",\n  \"cdata\": \"sessionid-123456789\",\n  \"metadata\":{\n    \"ephemeral_id\": \"x:9f78e0ed210960d7693b167e\"\n  }\n}\n```\n\n```\n{\n  \"success\": false,\n  \"error-codes\": [\"invalid-input-response\"]\n}\n```\nUsing `JsonPolymorphic` with a boolean type discriminator could represent the data like this:\n```\n[JsonPolymorphic(TypeDiscriminatorPropertyName = \"success\"),\n JsonDerivedType(typeof(TurnstileVerifySuccess), true),\n JsonDerivedType(typeof(TurnstileVerifyError), false)]\npublic abstract class TurnstileVerifyResponse;\n\npublic class TurnstileVerifySuccess : TurnstileVerifyResponse\n{\n    [JsonPropertyName(\"challenge_ts\")]\n    public DateTimeOffset ChallengeTimestamp { get; set; }\n\n    [JsonPropertyName(\"hostname\")]\n    public string Hostname { get; set; } = string.Empty;\n\n    [JsonPropertyName(\"action\")]\n    public string Action { get; set; } = string.Empty;\n\n    [JsonPropertyName(\"cdata\")]\n    public string CharacterData { get; set; } = string.Empty;\n\n    [JsonPropertyName(\"metadata\")]\n    public Dictionary<string, string> Metadata { get; set; } = new();\n}\n\npublic class TurnstileVerifyError : TurnstileVerifyResponse\n{\n    [JsonPropertyName(\"error-codes\")]\n    public string[] ErrorCodes { get; set; } = [];\n}\n```",
          "createdAt": "2025-03-31T16:29:43Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-03-31T16:29:43Z",
          "id": "IC_kwDODI9FZc6k6X0B"
        }
      ],
      "totalCount": 3,
      "endCursor": "Y3Vyc29yOnYyOpHOpOl9AQ=="
    },
    "url": "https://github.com/dotnet/runtime/issues/103834",
    "title": "[API Proposal]: Support boolean type discriminator in `JsonDerivedType`"
  },
  {
    "author": "dellamonica",
    "labels": [
      "api-suggestion",
      "area-System.Text.Json"
    ],
    "createdAt": "2024-06-24T16:57:21Z",
    "body": "### Background and motivation\n\nUse the new generic number types in the JSON API.\r\nMotivation: we can write higher level methods on top of the JsonWriter, for instance, to write an array of numeric values without having to repeat the same code block for each numeric type.\n\n### API Proposal\n\n```csharp\r\n\r\npublic void WriteNumberValue<TNumber>(TNumber number) where TNumber: INumber<TNumber>\r\n\r\n```\r\n\n\n### API Usage\n\n```csharp\r\n\r\npublic void WriteArray(Utf8JsonWriter jw, ReadOnlySpan<TNumber> values) where TNumber: INumber<TNumber>\r\n{     \r\n        jw.WriteStartArray();\r\n        foreach (TNumber val in values)\r\n        {\r\n            jw.WriteNumberValue(val);\r\n        }\r\n        jw.WriteEndArray();\r\n}\r\n\r\n...\r\n\r\nWriteArray(jw, [3.14f, 2.71f, 0f]);\r\nWriteArray(jw, [1, 2, 3]);\r\n```\r\n\n\n### Alternative Designs\n\n_No response_\n\n### Risks\n\n_No response_",
    "number": 103905,
    "reactions": {
      "hasNextPage": false,
      "nodes": [],
      "totalCount": 0,
      "endCursor": null
    },
    "updatedAt": "2025-07-16T05:53:37Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": "dotnet-policy-service",
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. -->",
          "createdAt": "2024-06-24T16:57:40Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-06-24T16:57:40Z",
          "id": "IC_kwDODI9FZc6CWzSp"
        },
        {
          "author": "eiriktsarpalis",
          "body": "We'd probably also need a `Utf8JsonReader.ReadNumber<T>() where TNumber: INumber<TNumber>` as well. Sounds doable, INumber implements both `IUtf8SpanFormattable` and `IUtf8SpanParsable`.\r\n\r\ncc @tannergooding ",
          "createdAt": "2024-06-24T17:36:19Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-06-24T17:36:19Z",
          "id": "IC_kwDODI9FZc6CXDFu"
        },
        {
          "author": "Clockwork-Muse",
          "body": ".... Some recommendations around currency and JSON often say that such numbers should be serialized as string values, not as \"raw\" JSON numbers (which can silently end up as binary floating point in some circumstances).  Given `decimal` implements `INumber`, that might have some adverse effects.",
          "createdAt": "2024-06-24T17:52:40Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-06-24T17:52:40Z",
          "id": "IC_kwDODI9FZc6CXJbr"
        },
        {
          "author": "elgonzo",
          "body": "> such numbers should be serialized as string values, not as \"raw\" JSON numbers (which can silently end up as binary floating point in some circumstances)\r\n\r\nWriting numbers as string values is not the concern of the existing Utf8JsonWriter.WriteNumber and WriteNumberValue methods, it would be inconsistent and confusing when WriteNumberValue\\<TNumber\\> happens to write a json string and not a json number (not to mention that a method name like \"WriteNumberValue\" would then be a rather misleading name for a method that doesn't write a number value). If you need to workaround poor json reader/deserialization routines or target environments lacking decimal number types other than binary floating points, a custom json converter that writes decimals as json strings is in my opinion a more appropriate choice to address this issue.\r\n\r\n> Given decimal implements `INumber`, that might have some adverse effects.\r\n\r\nConsidering that there are already WriteNumber/WriteNumberValue methods for decimals which write them as json numbers, I fail to see how a generic WriteNumberValue\\<TNumber\\> method writing decimals as a json number would introduce any adverse effects.",
          "createdAt": "2024-06-24T18:40:06Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-06-02T14:12:20Z",
                "user": "paulirwin"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOEU5tSw=="
          },
          "updatedAt": "2024-06-24T18:56:43Z",
          "id": "IC_kwDODI9FZc6CXb9m"
        }
      ],
      "totalCount": 4,
      "endCursor": "Y3Vyc29yOnYyOpHOgl2_Zg=="
    },
    "url": "https://github.com/dotnet/runtime/issues/103905",
    "title": "[API Proposal]: Utf8JsonWriter.WriteNumberValue<TNumber>"
  },
  {
    "author": "boylec",
    "labels": [
      "area-System.Text.Json"
    ],
    "createdAt": "2024-07-01T11:05:02Z",
    "body": "JsonPolymorphicAttribute.UnknownDerivedTypeHandling should handle the case where when deserializing an object there is no discriminator present in the JSON at all (as opposed to simply an unrecognized one).\r\n\r\nI would've expected this to be the case, and it would be useful for various reasons. For me it would allow a much quicker/painless path to start using STJ in projects that have not previously had discriminators on polymorphic serialized objects.",
    "number": 104228,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-07-02T14:24:56Z",
          "user": "mkercheval-tva"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-07-02T14:27:09Z",
          "user": "boylec"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-11-15T10:39:30Z",
          "user": "SkiFire13"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-11-15T10:40:11Z",
          "user": "EduBic"
        }
      ],
      "totalCount": 4,
      "endCursor": "Y3Vyc29yOnYyOpHOC8rkzg=="
    },
    "updatedAt": "2024-07-01T16:50:28Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": "eiriktsarpalis",
          "body": "Could you share a reproduction? This works as expected for me:\r\n\r\n```C#\r\nusing System.Text.Json;\r\nusing System.Text.Json.Serialization;\r\n\r\nstring json = JsonSerializer.Serialize<Base>(new Derived2(1,2,3));\r\nConsole.WriteLine(json); // {\"y\":2,\"x\":1}\r\n\r\n[JsonPolymorphic(UnknownDerivedTypeHandling = JsonUnknownDerivedTypeHandling.FallBackToNearestAncestor)]\r\n[JsonDerivedType(typeof(Derived))]\r\nrecord Base(int x);\r\nrecord Derived(int x, int y) : Base(x);\r\nrecord Derived2(int x, int y, int z) : Derived(x, y);\r\n```\r\n\r\nIf your question concerns deserialization support (i.e. being able to roundtrip a polymorphic value), this is not possible if no discriminator is specified in the payload.",
          "createdAt": "2024-07-01T11:50:46Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-07-01T11:51:46Z",
          "id": "IC_kwDODI9FZc6DIGOA"
        },
        {
          "author": "elgonzo",
          "body": "FYI, there was just recently a similar question in the discussion area also asking about some mechanism to deal with absent type discriminators in json data for polymorphic <em>de</em>serialization scenarios: https://github.com/dotnet/runtime/discussions/104089",
          "createdAt": "2024-07-01T12:35:29Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-07-01T12:35:29Z",
          "id": "IC_kwDODI9FZc6DIcuY"
        },
        {
          "author": "boylec",
          "body": "> Could you share a reproduction? This works as expected for me:\r\n> \r\n> ```cs\r\n> using System.Text.Json;\r\n> using System.Text.Json.Serialization;\r\n> \r\n> string json = JsonSerializer.Serialize<Base>(new Derived2(1,2,3));\r\n> Console.WriteLine(json); // {\"y\":2,\"x\":1}\r\n> \r\n> [JsonPolymorphic(UnknownDerivedTypeHandling = JsonUnknownDerivedTypeHandling.FallBackToNearestAncestor)]\r\n> [JsonDerivedType(typeof(Derived))]\r\n> record Base(int x);\r\n> record Derived(int x, int y) : Base(x);\r\n> record Derived2(int x, int y, int z) : Derived(x, y);\r\n> ```\r\n> \r\n> If your question concerns deserialization support (i.e. being able to roundtrip a polymorphic value), this is not possible if no discriminator is specified in the payload.\r\n\r\nMy apologies Eirik, I think I actually mistook the purpose of this property. I was probably looking more at something along the lines of the IgnoreUnrecognizedTypeDiscriminators property. As per the discussion @elgonzo mentioned.\r\n\r\nWill close this and move to the discussion.",
          "createdAt": "2024-07-01T13:10:46Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-07-01T14:22:50Z",
          "id": "IC_kwDODI9FZc6DIu4k"
        },
        {
          "author": "boylec",
          "body": "Ok I did look at that discussion but it wasn't precisely pertinent to what I was getting at with this issue in my opinion so I'm reopening.\r\n\r\nI'm basically looking to customize what happens if JSON has no discriminator defined. It occurs to me that this would likely be useful to many consumers of STJ.\r\n\r\nSomething along the lines of replacing\r\n\r\n```csharp\r\npublic bool IgnoreUnrecognizedTypeDiscriminators { get; set; }\r\n```\r\n\r\nwith something like\r\n\r\n```csharp\r\npublic Type? UnrecognizedDiscriminatorFallbackType { get; set; }\r\n```\r\n\r\non JsonPolymorphicAttribute and have this control the behavior if there is either an un-matching discriminator or no discriminator at all on the JSON being deserialized.\r\n\r\n* If UnrecognizedDiscriminatorFallbackType were null it would imply the equivalent behavior of how IgnoreUnrecognizedTypeDiscriminators being set to false behaves today.\r\n  * Throw an exception when the JSON has a non-matching type discriminator or no type discriminator at all.\r\n* If UnrecognizedDiscriminatorFallbackType were not null, it would imply what Type should be deserialized to as a fallback.\r\n  * Deserialize to the specified type when un-matching or no type discriminator at all.\r\n\r\nIn my view this would present more granular control for developers than just forcing deserialization to the base type when there is no matching discriminator found. Useful when introducing STJ polymorphism to a project with existing JSON structures that have no discriminators already defined (such as mine).\r\n\r\nFor the time being I've implemented a custom converter to accomplish similar, but this does seem like this (or something similar) could be a useful addition to the built in polymorphism feature of STJ.\r\n\r\nThanks for your time.",
          "createdAt": "2024-07-01T14:13:20Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-07-01T14:19:06Z",
          "id": "IC_kwDODI9FZc6DJWHR"
        },
        {
          "author": "eiriktsarpalis",
          "body": "An \"unrecognized discriminator\" in this context refers to a present discriminator property in the payload that simply does not map to any of the explicitly configured derived types. It does not have any effect on payloads that do not specify a discriminator. I'm not sure I understand the utility of this proposal: if your model explicitly defines types without a discriminator but then you want to have every payload map back to a type other than the base type, it seems to me that it's defeating the purpose of using polymorphism in the first place.\r\n\r\nIn the interest of keeping things simple, I would be inclined to say that we wouldn't want to support such a feature. If you want to be able to round trip values, use type discriminators. If you want to support a nonstandard scenario, write a custom converter.",
          "createdAt": "2024-07-01T14:22:47Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-07-01T14:22:47Z",
          "id": "IC_kwDODI9FZc6DJdKw"
        },
        {
          "author": "boylec",
          "body": "Let me see if I can describe what I think is an example of the value add.\r\n\r\n1. I have a data store with a \"Cart\" collection. At first over the first couple of years of my apps existence this is a non-polymorphic type just a simple shopping cart object. The table builds up data over time.\r\n\r\n```csharp\r\n// no polymorphic JSON attributes\r\npublic record Cart {\r\n  public string CartId { get; init; }\r\n  // ... other cart stuff\r\n}\r\n```\r\n\r\n2. A new use case presents itself a couple years down the road where it would be advantageous to start delineating between guest and member shopping cart objects. The team elects to go with a polymorphic Cart object instead of a \"monomorphic\" Cart. They update their model(s).\r\n\r\n```csharp\r\n[JsonDerivedType(typeof(GuestCart), \"guestCart\")]\r\n[JsonDerivedType(typeof(MemberCart), \"memberCart\")]\r\n[JsonPolymorphic(TypeDiscriminatorPropertyName=\"cartType\")]\r\n// this is abstract because moving forward there is no such thing as a cart which is not a member or guest cart\r\npublic abstract record Cart {\r\n  public string CartId { get; init; }\r\n  // ... other cart stuff\r\n}\r\n\r\npublic record MemberCart : Cart {\r\n  // ... member-cart-specific stuff\r\n}\r\n\r\npublic record GuestCart : Cart {\r\n  // ... guest-cart-specific stuff\r\n}\r\n```\r\n\r\nNow we run in to a problem. Yes, new cart objects will serialize and deserialize correctly, but there is no direct way to enable our \"old\" (non polymorphic) cart JSON to be deserialized correctly by our runtime. It is going to throw a JsonException due to no type discriminator being present. We have to either migrate all of our data and add type discriminators (a risky proposition in production) or write a custom converter any time we want to go from monomorphic to polymorphic.\r\n\r\nEvolving types are a common/expected occurrence no?\r\n\r\nOf course a custom converter can do the trick - but it seems like a common enough occurrence that maybe this ought to be a built in functionality.\r\n",
          "createdAt": "2024-07-01T14:40:32Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-07-01T14:44:01Z",
          "id": "IC_kwDODI9FZc6DJp8L"
        },
        {
          "author": "eiriktsarpalis",
          "body": "That scenario would still work if you didn't mark the base `Cart` type as abstract, right?",
          "createdAt": "2024-07-01T15:24:19Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-07-01T15:24:19Z",
          "id": "IC_kwDODI9FZc6DKDzm"
        },
        {
          "author": "boylec",
          "body": "I think that is correct; making Cart a non-abstract type in this scenario would enable the object to deserialize to Cart, but that would not be a correct state in this particular domain. Obviously this is a contrived example, but it seems suboptimal for lack of a better word to force people to make things non abstract due to limitations of serialization framework - that would otherwise be abstract.",
          "createdAt": "2024-07-01T15:30:01Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-07-01T15:31:23Z",
          "id": "IC_kwDODI9FZc6DKHEx"
        },
        {
          "author": "eiriktsarpalis",
          "body": "> but that would not be a correct state in this particular domain. \r\n\r\nIt better reflects the shape of the data being stored in your database though. If this creates problems with your domain modelling I would suggest extracting that concern to a separate DTO layer.\r\n\r\n> due to limitations of serialization framework\r\n\r\nWhat can be said of serialization libraries in general is that there exists a threshold of customizability after which maintainability and performance begin to suffer. We avoid adding new knobs unless there is demonstrable impact to a large number of users. The built-in polymorphism implementation is an opinionated implementation (to an extent, this is influenced by security concerns ever present in polymorphic serialization) that caters to the 80% of use cases. We fully expect that this won't satisfy every use case, and JsonConverter provides an escape hatch for everything else.",
          "createdAt": "2024-07-01T15:47:51Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-07-01T15:47:51Z",
          "id": "IC_kwDODI9FZc6DKQBJ"
        },
        {
          "author": "boylec",
          "body": "> > but that would not be a correct state in this particular domain.\r\n> \r\n> It better reflects the shape of the data being stored in your database though. If this creates problems with your domain modelling I would suggest extracting that concern to a separate DTO layer.\r\n> \r\n> > due to limitations of serialization framework\r\n> \r\n> What can be said of serialization libraries in general is that there exists a threshold of customizability after which maintainability and performance begin to suffer. We avoid adding new knobs unless there is demonstrable impact to a large number of users. The built-in polymorphism implementation is an opinionated implementation (to an extent, this is influenced by security concerns ever present in polymorphic serialization) that caters to the 80% of use cases. We fully expect that this won't satisfy every use case, and JsonConverter provides an escape hatch for everything else.\r\n\r\nEverything you said makes sense and I appreciate the thoughtful response. 🙏 \r\n\r\nAt the end of the day, as you mentioned, I/we can indeed accomplish what I'm mentioning here with some extra code.\r\n\r\nMy subjective view is that there is a good chance that > 80% of projects that use System.Text.Json are going to have models that evolve from a concrete monomorphic type to an abstract (polymorphic) type over time. I take your point that there is a delicate line drawn in the sand about how much to build in to the lib and how much to leave to the JsonConverter escape hatch.\r\n\r\nThat being said: I am an avid user of serialization libs, and I do wish this were a built in feature! :)\r\n\r\nThank you for hearing my two cents. You guys are doing great. Feel free to close.",
          "createdAt": "2024-07-01T16:02:11Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-07-01T16:16:46Z",
          "id": "IC_kwDODI9FZc6DKYA4"
        },
        {
          "author": "eiriktsarpalis",
          "body": "We can leave this in the back burner for now. Assuming it receives added traction (responses, upvotes, etc.) we could try taking a look at this in the future.",
          "createdAt": "2024-07-01T16:15:32Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "HEART",
                "createdAt": "2024-07-01T16:15:44Z",
                "user": "boylec"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHODn669w=="
          },
          "updatedAt": "2024-07-01T16:15:32Z",
          "id": "IC_kwDODI9FZc6DKeW_"
        }
      ],
      "totalCount": 11,
      "endCursor": "Y3Vyc29yOnYyOpHOgynlvw=="
    },
    "url": "https://github.com/dotnet/runtime/issues/104228",
    "title": "JsonPolymorphicAttribute.IgnoreUnrecognizedTypeDiscriminators doesn't handle \"no discriminator\" use case"
  },
  {
    "author": "nickquednow",
    "labels": [
      "area-System.Text.Json"
    ],
    "createdAt": "2024-07-09T16:16:21Z",
    "body": "### Description\n\nI was doing some testing with default values from JSON to Class conversion, and I found out that when I put a null value in the JSON data, there was an exception that was thrown due to the data type not being nullable (found in #30795, but possibly a separate documentation bug). When looking at the Microsoft documentation, I got to the following link: https://learn.microsoft.com/en-us/dotnet/standard/serialization/system-text-json/ignore-properties#ignore-all-null-value-properties\r\n\r\nI tried that value, and my default value was being overridden with null (which I was hoping would not be the case). Then finding very old articles about the issue, people recommended the now-obsolete (in dotnet 8) option of `IgnoreNullValues=true`, which did work (had the intended effect of keeping the default value of 100).\r\n\r\nThe code provided is not in an array, but was originally found to be broken when trying to deserialize to a `list<HighLowTemps>`.\r\n\r\nTLDR; the `JsonSerializerOptions.IgnoreNullValues=true` kept a default value, while `JsonSerializerOptions.DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull` did not in dotnet 8.\n\n### Reproduction Steps\n\n```c#\r\nusing System.Text.Json;\r\nusing System.Text.Json.Nodes;\r\n\r\npublic class HighLowTemps\r\n{\r\n    public int? High = 100;\r\n    public int? Low = 0;\r\n}\r\n\r\npublic class Mains\r\n{\r\n    public static void Main()\r\n    {\r\n        // modified from: https://learn.microsoft.com/en-us/dotnet/standard/serialization/system-text-json/use-dom\r\n        string jsonString = @\"\r\n{\r\n  \"\"TemperatureRanges\"\": \r\n      {\r\n          \"\"High\"\": null,\r\n          \"\"Low\"\": 20\r\n      }\r\n}\r\n\";\r\n\r\n        JsonNode forecastNode = JsonNode.Parse(jsonString)!;\r\n\r\n        JsonSerializerOptions options = new JsonSerializerOptions();\r\n        options.IncludeFields = true;\r\n        options.DefaultIgnoreCondition = System.Text.Json.Serialization.JsonIgnoreCondition.WhenWritingNull;\r\n        //options.IgnoreNullValues = true;\r\n\r\n        var test = JsonSerializer.Deserialize<HighLowTemps>(forecastNode[\"TemperatureRanges\"]!, options)!;\r\n        // breakpoint here. test shows null for High. switch to IgnoreNullValues, High is 100\r\n    }\r\n}\r\n```\n\n### Expected behavior\n\nFor `IgnoreNullValues`\r\n```c#\r\npublic class HighLowTemps\r\n{\r\n    public int? High = 100;\r\n    public int? Low = 20;\r\n}\r\n```\r\nFor `DefaultIgnoreCondition`\r\n```c#\r\npublic class HighLowTemps\r\n{\r\n    public int? High = 100;\r\n    public int? Low = 20;\r\n}\r\n```\n\n### Actual behavior\n\nFor `IgnoreNullValues`\r\n```c#\r\npublic class HighLowTemps\r\n{\r\n    public int? High = 100;\r\n    public int? Low = 20;\r\n}\r\n```\r\nFor `DefaultIgnoreCondition`\r\n```c#\r\npublic class HighLowTemps\r\n{\r\n    public int? High = null; <--------------- Unexpected behavior\r\n    public int? Low = 20;\r\n}\r\n```\n\n### Regression?\n\n_No response_\n\n### Known Workarounds\n\nUse the deprecated `IgnoreNullValues` property\n\n### Configuration\n\nTested on the following (all versions from the visual studio installer running VS 2022 pro v17.10.1):\r\n - Dotnet 8.0\r\n - Dotnet 7.0\r\n - Dotnet 6.0\r\n - Dotnet Framework 4.6.2 (with the `System.Text.Json` nuget package installed on 8.0.0.4)\r\n \r\nDotnet 5.0 and all Dotnet Core versions do not have JsonNodes, so not tested.\r\n\r\nWindows 11 feature pack 23H2. Running on x86_64\r\n\r\nThis is probably configuration agnostic.\n\n### Other information\n\n_No response_",
    "number": 104614,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-07-14T09:55:10Z",
          "user": "aco-mreble"
        }
      ],
      "totalCount": 1,
      "endCursor": "Y3Vyc29yOnYyOpHODG2lUQ=="
    },
    "updatedAt": "2024-07-09T18:44:58Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": "dotnet-policy-service",
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. -->",
          "createdAt": "2024-07-09T16:16:41Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-07-09T16:16:41Z",
          "id": "IC_kwDODI9FZc6ENdKF"
        },
        {
          "author": "eiriktsarpalis",
          "body": "This is expected behavior. `WhenWritingNull` only governs writing and not reading of  null values. `DefaultIgnoreCondition` never ignores values. What you might be looking for is adding a `JsonIgnoreCondition.WhenNull` case which hasn't been implemented yet.\r\n\r\nAs a temporary workaround, you could try wrapping the `JsonPropertyInfo.Set` delegate so that it only sets the property when the value is not null.",
          "createdAt": "2024-07-09T16:35:28Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-07-09T16:35:28Z",
          "id": "IC_kwDODI9FZc6ENl6Q"
        },
        {
          "author": "nickquednow",
          "body": "Since it seems like I would have to replace the `JsonSerializerOptions.TypeInfoResolver` to a custom class in order to use the `JsonPropertyInfo` setter method, is there a different work around that would be closer to the options?\r\n\r\nIf not then I think I am just going to have to roll the dice on the obsolete property in hopes of `JsonIgnoreCondition` being updated in the future to have the `JsonIgnoreCondition.WhenNull` case.",
          "createdAt": "2024-07-09T18:44:58Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-07-09T18:44:58Z",
          "id": "IC_kwDODI9FZc6EOjta"
        }
      ],
      "totalCount": 3,
      "endCursor": "Y3Vyc29yOnYyOpHOhDo7Wg=="
    },
    "url": "https://github.com/dotnet/runtime/issues/104614",
    "title": "JsonIgnoreCondition.WhenWritingNull appears to be ignored when deserializing data"
  },
  {
    "author": "ezhevita",
    "labels": [
      "bug",
      "area-System.Text.Json",
      "help wanted"
    ],
    "createdAt": "2024-07-10T22:33:32Z",
    "body": "### Description\r\n\r\nWhen trying to deserialize a JSON string into a class containing a property with a collection type (`Dictionary` or `IEnumerable`) serializer throws an exception which says about a property missing a setter despite it being present.\r\n\r\n### Reproduction Steps\r\n\r\n```csharp\r\nJsonSerializer.Deserialize<Test>(\"{\\\"Data\\\":[1]}\");\r\n\r\npublic class Test\r\n{\r\n    [JsonRequired]\r\n    public List<int> Data\r\n    {\r\n        set => FirstValue = value[0];\r\n    }\r\n    \r\n    [JsonIgnore]\r\n    public int FirstValue { get; private set; }\r\n}\r\n```\r\n\r\n### Expected behavior\r\n\r\nJSON is deserialized correctly.\r\n\r\n### Actual behavior\r\n\r\nThe following exception is thrown:\r\n```\r\nSystem.InvalidOperationException: JsonPropertyInfo 'Data' defined in type 'Test' is marked required but does not specify a setter.\r\n   at System.Text.Json.ThrowHelper.ThrowInvalidOperationException_JsonPropertyRequiredAndNotDeserializable(JsonPropertyInfo jsonPropertyInfo)\r\n   at System.Text.Json.Serialization.Metadata.JsonPropertyInfo.Configure()\r\n   at System.Text.Json.Serialization.Metadata.JsonTypeInfo.ConfigureProperties()\r\n   at System.Text.Json.Serialization.Metadata.JsonTypeInfo.Configure()\r\n   at System.Text.Json.Serialization.Metadata.JsonTypeInfo.<EnsureConfigured>g__ConfigureSynchronized|172_0()\r\n   at System.Text.Json.JsonSerializerOptions.GetTypeInfoInternal(Type type, Boolean ensureConfigured, Nullable`1 ensureNotNull, Boolean resolveIfMutable, Boolean fallBackToNearestAncestorType)\r\n   at Program.<Main>$(String[] args)\r\n```\r\n\r\n### Regression?\r\n\r\nNo, this behavior is present at least since .NET 7 when required properties were introduced.\r\n\r\n### Known Workarounds\r\n\r\nAdding a getter to the property, it is allowed for it to return null or just outright to throw an exception.\r\n\r\n### Configuration\r\n\r\n.NET 8.0.6 running on macOS 14.5 ARM64; issue is not specific to the configuration.\r\n\r\n### Other information\r\n\r\nSimilar to (although different scenario): https://github.com/dotnet/runtime/issues/92330",
    "number": 104700,
    "reactions": {
      "hasNextPage": false,
      "nodes": [],
      "totalCount": 0,
      "endCursor": null
    },
    "updatedAt": "2024-10-05T03:52:21Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": "dotnet-policy-service",
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. -->",
          "createdAt": "2024-07-10T22:33:52Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-07-10T22:33:52Z",
          "id": "IC_kwDODI9FZc6Ea4fH"
        },
        {
          "author": "eiriktsarpalis",
          "body": "I can reproduce, thanks. One workaround is to specify a getter it seems.",
          "createdAt": "2024-07-10T22:43:14Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-07-10T22:43:14Z",
          "id": "IC_kwDODI9FZc6Ea657"
        },
        {
          "author": "julien98Qc",
          "body": "Indeed, properties of collection types that only have setters are not supported.\r\n\r\nIn `DetermineSerializationCapabilities()`, `CanDeserialize` is set to false when an Enumerable or Dictionary has no getter. In `Configure()`, we trigger the exception based on `IsRequired` and `CanDeserialize`. The exception message assumes it is a setter problem, but that is not always the case.\r\n\r\nThe resolution might be one of the following:\r\n- Add another verification that throws a separate error for this specific case.\r\n- Change the exception message to a more generic one.\r\n\r\nI would go for the other verification in my humble opinion. I could work on this, just tell me which direction to go.",
          "createdAt": "2024-07-12T00:58:08Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-07-12T12:30:18Z",
          "id": "IC_kwDODI9FZc6Ekxix"
        },
        {
          "author": "julien98Qc",
          "body": "@eiriktsarpalis Just wanted to let you know that I've made a PR for this issue.",
          "createdAt": "2024-07-26T00:56:55Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-07-26T09:58:29Z",
                "user": "eiriktsarpalis"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHODrrb2A=="
          },
          "updatedAt": "2024-07-26T00:56:55Z",
          "id": "IC_kwDODI9FZc6GNxZJ"
        },
        {
          "author": "julien98Qc",
          "body": "The issue is not about a misleading error message anymore but to make it work when required and no getter specified. Since then, I'm really confused as why it was purposefuly dermined not deserializable in `DetermineSerializationCapabilities()`. I don't have enough time to investigate further.\r\n\r\nSee this comment below for more context : https://github.com/dotnet/runtime/pull/104861#pullrequestreview-2204684810",
          "createdAt": "2024-07-30T00:39:14Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-07-30T10:31:14Z",
                "user": "eiriktsarpalis"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHODsGFBQ=="
          },
          "updatedAt": "2024-07-30T00:42:47Z",
          "id": "IC_kwDODI9FZc6GiuHV"
        },
        {
          "author": "ezhevita",
          "body": "I've updated the issue title to reflect that the expected solution is making this scenario work.",
          "createdAt": "2024-07-30T11:42:52Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-07-30T12:30:46Z",
                "user": "julien98Qc"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-07-31T09:58:19Z",
                "user": "eiriktsarpalis"
              }
            ],
            "totalCount": 2,
            "endCursor": "Y3Vyc29yOnYyOpHODsPQUA=="
          },
          "updatedAt": "2024-07-30T11:42:52Z",
          "id": "IC_kwDODI9FZc6GmKKG"
        },
        {
          "author": "devsko",
          "body": "> I don't think this is the correct way to address the problem. A fix should instead try to make the scenario work as expected. If you remove JsonRequired from the repro in #104700 then deserialization works as expected and this should too.\r\n\r\n@eiriktsarpalis are you aware that the setter is not called even when `[JsonRequired]` is removed. No exception but still unexpected.\r\n\r\nThe following\r\n- Throws `InvalidOperationException` with `[JsonRequired]` and  without getter\r\n- Prints '0' without `[JsonRequired]` and without getter\r\n- Prints '1' with getter (even though it is never called)\r\n\r\n``` cs\r\nConsole.WriteLine(JsonSerializer.Deserialize<Test>(\"{\\\"Data\\\":[1]}\")?.FirstValue);\r\n\r\npublic class Test\r\n{\r\n    //[JsonRequired]\r\n    public List<int> Data\r\n    {\r\n        //get => throw new Exception();\r\n        set => FirstValue = value[0]; // Is NOT called as long as no getter is declared\r\n    }\r\n\r\n    [JsonIgnore]\r\n    public int FirstValue { get; private set; }\r\n}\r\n```\r\n",
          "createdAt": "2024-09-30T11:42:49Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-09-30T11:42:49Z",
          "id": "IC_kwDODI9FZc6OCQN2"
        },
        {
          "author": "ShawnWu33",
          "body": "Hi I am trying to looking into this issue as got some time in upcoming few days.\r\n\r\nUpon a shallow investigation, the following logic in `DetermineSerializationCapabilities()` is where the `CanDeserilize` being set false. \r\n```c#\r\nif ((EffectiveConverter.ConverterStrategy & (ConverterStrategy.Enumerable | ConverterStrategy.Dictionary)) != 0)\r\n{\r\n    // Properties of collections types that only have setters are not supported.\r\n    if (Get == null && Set != null && !_isUserSpecifiedSetter)\r\n    {\r\n        CanDeserialize = false;\r\n    }\r\n}\r\n```\r\nThe comment `// Properties of collections types that only have setters are not supported.` is introduced in #72186.\r\n@eiriktsarpalis Could you shed a light on which direction you consider the proper fix should be? Do we want to fix what's underlying to let collection type that only have setters be supported?\r\n\r\nBtw Should `_isUserSpecifiedSetter` being set as `true` in this case? Its `false` when running above case.\r\n",
          "createdAt": "2024-10-05T03:52:19Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-10-05T03:52:19Z",
          "id": "IC_kwDODI9FZc6Ov2_m"
        }
      ],
      "totalCount": 8,
      "endCursor": "Y3Vyc29yOnYyOpHOjr9v5g=="
    },
    "url": "https://github.com/dotnet/runtime/issues/104700",
    "title": "Unable to deserialize JSON into a collection property without a getter (with a misleading error message)"
  },
  {
    "author": "captainsafia",
    "labels": [
      "area-System.Text.Json"
    ],
    "createdAt": "2024-07-31T17:36:58Z",
    "body": "The current implementation of the `JsonSchemaExporter` generates schemas for types based on its on semantics. There's currently not strategy for types/converters to advertise their associated JSON schemas.\r\n\r\nThis gap has presented a blocker for a couple of scenarios in ASP.NET Core's OpenAPI support around JSON schema.\r\n\r\n- gRPC's JSON transcoding layer needs to represent schemas for types based on the underlying protobuf representation instead of the generated C# implementation.\r\n- Types that implement a custom converter are not able to define a schema and are represented by the catch-all `true` schema.\r\n\r\nWhile both System.Text.Json and ASP.NET Core expose APIs for modifying schemas at different layers of the stack, both approaches are _reactive_ and allow mutating the schema that is generated instead of proactively dictating the schema that should be set.\r\n\r\nSolutions that have been discussed in the past includ exposing a new `IJsonSchemaResolver` interface for type owners to implement:\r\n\r\n```csharp\r\npublic interface IJsonSchemaResolver\r\n{\r\n    JsonSchema GetJsonSchema(JsonTypeInfo typeInfo); \r\n    JsonSchema GetJsonSchema(JsonPropertyInfo propertyInfo); \r\n}\r\n```\r\n\r\nOr alternatively including a new virtual method on the JsonConverter to define associated schemas:\r\n\r\n```csharp\r\npublic class JsonConverter\r\n{\r\n    public virtual JsonSchema? GetSchema(JsonSerializerOptions options) => ...\r\n}\r\n```\r\n\r\ncc: @JamesNK @eiriktsarpalis \r\n",
    "number": 105769,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-07-31T20:58:42Z",
          "user": "bachratyg"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-10-11T10:25:00Z",
          "user": "tkvalvik"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-12-17T13:52:14Z",
          "user": "Genteure"
        },
        {
          "content": "EYES",
          "createdAt": "2024-12-17T13:56:25Z",
          "user": "Genteure"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-02-16T16:15:17Z",
          "user": "rabuckley"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-04-09T15:37:07Z",
          "user": "scott-dak"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-05-28T14:45:47Z",
          "user": "grimurd"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-06-14T17:30:29Z",
          "user": "scorpion28"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-07-05T21:20:16Z",
          "user": "StephenHodgson"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-08-04T20:26:00Z",
          "user": "Trivivium"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-08-27T12:57:54Z",
          "user": "akade"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-08-30T17:30:48Z",
          "user": "ulrichb"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-09-10T12:26:39Z",
          "user": "jchoca"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-09-19T01:22:55Z",
          "user": "wu-yafeng"
        }
      ],
      "totalCount": 14,
      "endCursor": "Y3Vyc29yOnYyOpHODRyJoA=="
    },
    "updatedAt": "2025-08-27T13:04:29Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": "dotnet-policy-service",
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. -->",
          "createdAt": "2024-07-31T17:37:19Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-07-31T17:37:19Z",
          "id": "IC_kwDODI9FZc6GxIoD"
        },
        {
          "author": "stephentoub",
          "body": "> This gap has presented a blocker\n\n@captainsafia, as in we need to address this in .NET 9?",
          "createdAt": "2024-07-31T17:41:43Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-07-31T17:41:43Z",
          "id": "IC_kwDODI9FZc6GxKWL"
        },
        {
          "author": "captainsafia",
          "body": "> @captainsafia, as in we need to address this in .NET 9?\r\n\r\nAh, should've been clearer about this.\r\n\r\nNot a blocker for .NET 9, but definitely would be good to slot in for .NET 10.",
          "createdAt": "2024-07-31T17:43:51Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-07-31T17:50:13Z",
                "user": "stephentoub"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-08-02T01:11:38Z",
                "user": "colejohnson66"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-08-02T17:28:18Z",
                "user": "jeffhandley"
              }
            ],
            "totalCount": 3,
            "endCursor": "Y3Vyc29yOnYyOpHODsnKTQ=="
          },
          "updatedAt": "2024-07-31T17:43:51Z",
          "id": "IC_kwDODI9FZc6GxLTR"
        },
        {
          "author": "gregsdennis",
          "body": "> ```c#\n> public interface IJsonSchemaResolver\n> {\n>     JsonSchema GetJsonSchema(JsonTypeInfo typeInfo); \n>     JsonSchema GetJsonSchema(JsonPropertyInfo propertyInfo); \n> }\n> ```\n\nThere is no `JsonSchema` type shipping with .Net 9, and I'm not aware of one planned for 10.  The current implementation for generation simply generates a `JsonNode`.",
          "createdAt": "2024-07-31T18:56:36Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-07-31T18:56:36Z",
          "id": "IC_kwDODI9FZc6GxylG"
        },
        {
          "author": "JamesNK",
          "body": "The problem with the proposed API is JSON schemas exist in the context of a document.\r\n\r\nFor example, schemas in a document reference each other via `$ref`, and schemas are commonly stored together in `$defs` (I don't know if JsonSchemaMapper has a feature to output generated schemas together in `$defs` yet. If you don't, I _guarantee_ that there will be a lot of people asking for this feature. It's the idiomatic way to organize schemas in JSON schema).\r\n\r\nThese things happen beyond the scope of an individual `JsonSchema` instance. Customizations to schema generation for a `JsonTypeInfo` need to flow out and impact the rest of the document. If `JsonTypeInfo` needs to generate its own subschemas based on types in its properties, people will want:\r\n* Those schemas to be output in `$defs`\r\n* Other places that have the same schema, e.g. a schema for `Person` type, to all reference the common schema in `$defs` with `$ref`.\r\n\r\nI think customization must happen before the document is generated and work at the `Type` level. Swashbuckle does this successfully using [`ISerializerDataContractResolver`](https://github.com/domaindrivendev/Swashbuckle.AspNetCore/blob/531c4c00f0fe59534dace984635f71815343bcfb/src/Swashbuckle.AspNetCore.SwaggerGen/SchemaGenerator/ISerializerDataContractResolver.cs).\r\n\r\nUsing Swashbuckle's contract resolver, I can instruct it what the schema output for a type should be at the `Type` level. For example:\r\n\r\nThe `Any` type has a JsonConverter that customizes its output. I can then make its schema match the custom output by saying its [schema is an object, with one known property of `System.String`, and additional properties of type `Google.Protobuf.Value`](https://github.com/dotnet/aspnetcore/blob/42e61729ecee15701ba55f4dbc6dc62d966a2a7f/src/Grpc/JsonTranscoding/src/Microsoft.AspNetCore.Grpc.Swagger/Internal/GrpcDataContractResolver.cs#L84-L89). The Swashbuckle schema generated then uses this custom contract to generate the desired JSON schema. `Google.Protobuf.Value`. is stored in the idiomatic shared location, and other places in the doc that also use `Google.Protobuf.Value` have a `$ref` to that shared location.",
          "createdAt": "2024-07-31T23:07:44Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-09-20T15:02:06Z",
                "user": "CatBraaain"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOEjJgQQ=="
          },
          "updatedAt": "2024-07-31T23:09:06Z",
          "id": "IC_kwDODI9FZc6GzdOB"
        },
        {
          "author": "gregsdennis",
          "body": "The current implementation does not support `$ref`s, despite my arguing for them (see comments in the relevant PRs).  What is currently provided is a stepping stone; just enough to get asp.net over the line.",
          "createdAt": "2024-08-01T01:29:00Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-08-01T01:29:00Z",
          "id": "IC_kwDODI9FZc6Gz9Ze"
        },
        {
          "author": "JamesNK",
          "body": "Yes, what `JsonSchemaMapper` currently does is very rudimentary in .NET 9.\r\n\r\n$ref and $def are needed. They're the idiomatic way to organize schemas in JSON. Without those features, a large amount of work is required to make good output from the type.\r\n\r\nAs evidence of this, see everything that ASP.NET Core needs to do to post-process the output of the mapper to make it usable. The mapper should be the one doing the work to place schemas in definitions and reference them. Some post-processing in ASP.NET Core will still be required to modify the JSON schema syntax to be compatible with OpenAPI, but it will be much less, and simpler, than what is currently done.\r\n\r\nAs soon as you start adding support for these features, you realize that an API to customize schemas individually doesn't work.",
          "createdAt": "2024-08-01T02:03:16Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-11-15T10:13:16Z",
                "user": "Peter-B-"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOD7BogA=="
          },
          "updatedAt": "2024-08-01T02:05:48Z",
          "id": "IC_kwDODI9FZc6G0GrO"
        },
        {
          "author": "eiriktsarpalis",
          "body": "For context, the reason why such an API wasn't added in .NET 9 is due to the lack of a built-in `JsonSchema` type. Building these abstractions around `JsonNode` is plainly not a good idea in the long run. Once a `JsonSchema` type is available building this feature should be relatively straightforward.\r\n\r\n`JsonSchemaExporter` currently does not use `$def` (or `$id`) OOTB in the schemas that it generates. `$ref` schemas using JSON pointer are only generated in case of recursive schemas. The reason is naming: for a general-purpose naming scheme we would need to use identifiers that either encode the FQN of a given type or generate UUIDs neither of which felt like an acceptable solution. If we do add support for `$def` or `$id` in the future this should involve exposing an abstraction for users to define their own naming scheme.",
          "createdAt": "2024-08-02T10:10:11Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-08-02T15:18:53Z",
                "user": "captainsafia"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHODsmTCA=="
          },
          "updatedAt": "2024-08-02T10:12:41Z",
          "id": "IC_kwDODI9FZc6HAbep"
        },
        {
          "author": "Peter-B-",
          "body": "I try to generate a Json schema for some types, which contain simple value objects generated with [Vogen](https://github.com/SteveDunn/Vogen). This makes me run into the issue described here. \n\nIt would be great to have an interface for describing my schema. For the simple use-case it might be sufficient to override `JsonConverter.GetSchema`, even though I definitely see the value of generating and reusing `$ref`.\n\nAnother issue related to this is, that `GetJsonSchemaAsNode` returns `true` for any type with a custom `JsonConverter` defined. \n\n```json\n{\n  \"type\": \"object\",\n  \"properties\": {\n    \"propertyWithCustomConverter\": true\n  }\n}\n```\n\nI think this violates the JsonSchema specification, [which states](https://json-schema.org/draft/2020-12/json-schema-core#section-10.3.2.1)\n> The value of \"properties\" MUST be an object. Each value of this object MUST be a valid JSON Schema.\n\nI'd prefer to receive an `NotSupportedException`, preferably with a flag to ignore that in `JsonSchemaExporterOptions`.\n\nDoes it make sense to raise an issue for that? Or is it too late anyway, with .Net 9 just being released?",
          "createdAt": "2024-11-15T10:33:52Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-11-15T10:33:52Z",
          "id": "IC_kwDODI9FZc6Tuyfs"
        },
        {
          "author": "gregsdennis",
          "body": "> I think this violates the JsonSchema specification\n\n`true` is a valid schema.  It's equivalent to `{}`, which allows all JSON instances.  This was introduced with draft 6.",
          "createdAt": "2024-11-15T11:27:29Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-11-15T12:02:57Z",
                "user": "eiriktsarpalis"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-11-15T12:10:38Z",
                "user": "Peter-B-"
              }
            ],
            "totalCount": 2,
            "endCursor": "Y3Vyc29yOnYyOpHOD7CcJA=="
          },
          "updatedAt": "2024-11-15T11:27:57Z",
          "id": "IC_kwDODI9FZc6TvJa5"
        },
        {
          "author": "eiriktsarpalis",
          "body": "> I think this violates the JsonSchema specification, [which states](https://json-schema.org/draft/2020-12/json-schema-core#section-10.3.2.1)\n> \n> > The value of \"properties\" MUST be an object. Each value of this object MUST be a valid JSON Schema.\n\nThe value of \"properties\" _is_ an object in your example. It's just that the schemas of individual properties can boolean per the spec.",
          "createdAt": "2024-11-15T12:04:04Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-11-15T12:04:04Z",
          "id": "IC_kwDODI9FZc6TvXx_"
        },
        {
          "author": "Peter-B-",
          "body": "Ah. True. Sorry, I didn't get that.\n\nBesides that, I'm not sure if it is a very helpful property description.",
          "createdAt": "2024-11-15T12:11:44Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-11-15T12:11:44Z",
          "id": "IC_kwDODI9FZc6Tvaw7"
        },
        {
          "author": "gregsdennis",
          "body": "@Peter-B- if you think the spec needs to be clarified, please feel free to open an issue in the [JSON Schema spec repo](https://github.com/json-schema-org/json-schema-spec).",
          "createdAt": "2024-11-15T22:58:05Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-11-15T22:59:56Z",
          "id": "IC_kwDODI9FZc6T00cD"
        },
        {
          "author": "Peter-B-",
          "body": "Hi @gregsdennis,\n\nthank you, I will consider this.\n\nSorry for bringing this up in the first place, since this was not my intended contribution to this issue. \n\nI basically want to second this request for JsonConverters to describe their schema, and bring my use case of the (Vogen-generated) value objects to the table. I see the technical problems with designing such an API, but I think it could enable some interesting use cases.\n\nEdit:\nApologies again and as a reference: The [schema documentation](https://json-schema.org/draft/2020-12/json-schema-core#section-4.3.2) says about `true`:\n> true: Always passes validation, as if the empty schema {}\n\nSo this is the correct value for an unknown subschema.",
          "createdAt": "2024-11-16T10:59:51Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-11-16T11:17:08Z",
          "id": "IC_kwDODI9FZc6T2cfY"
        },
        {
          "author": "niemyjski",
          "body": "Any idea when this will be moved forward? Anything the community can do? We are missing a lot of models from OpenAPI generation due to this.",
          "createdAt": "2025-08-11T16:22:37Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-08-11T16:22:37Z",
          "id": "IC_kwDODI9FZc69SgCu"
        },
        {
          "author": "gregsdennis",
          "body": "If you're open to using JSON Schema.Net (and its generation extension package), I've solved supporting JSON Schema request validation in ASP.net.\n\nhttps://blog.json-everything.net/posts/json-schema-aspdotnet/\n\nThis has all the code you need to make it work. \n\nI've been using it at my job for a month, now, and it's really nice.  Soon our entire API (internal and external) will be using it.\n\nGeneration of the OpenAPI is still something I'm working on, though.",
          "createdAt": "2025-08-12T10:12:13Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-08-12T10:13:18Z",
          "id": "IC_kwDODI9FZc69dwRk"
        },
        {
          "author": "akade",
          "body": "Just stumbled across this issue as well and would also appreciate are more integrated way. For anybody interested, I could work around it by `TransformSchemaNode`:\n\n```csharp\nTransformSchemaNode = static (context, node) =>\n{\n    if(context.PropertyInfo?.CustomConverter is YourCustomConverter)\n    {\n        if (node.GetValueKind() != JsonValueKind.Object) // see note below\n        {\n            node = new JsonObject();\n        }\n        ...\n    }\n}\n```\n\nThe passed `node` will switch from being a `JsonObject` to `true` as soon as you put your custom converter on it (my property was of type `DateOnly?`). Unless you have something else on the property, like `[Description]`. \n\nThis confused me, couldn't that be an empty `JsonObject` instead of `true`? I would have found that much more intuitive and ergonomic.",
          "createdAt": "2025-08-27T12:55:48Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-08-27T12:55:48Z",
          "id": "IC_kwDODI9FZc7AaOzx"
        },
        {
          "author": "eiriktsarpalis",
          "body": "> This confused me, couldn't that be an empty `JsonObject` instead of `true`? I would have found that much more intuitive and ergonomic.\n\nThe recommendation from JSON schema spec authors was to favor `true` of empty objects in schema generation. I've found [this helper](https://github.com/dotnet/extensions/blob/da94b6045fef85f78a5eee183579221cee684e51/src/Libraries/Microsoft.Extensions.AI.Abstractions/Utilities/AIJsonUtilities.Schema.Create.cs#L372-L390) to be useful in the context of authoring transformers.",
          "createdAt": "2025-08-27T13:04:29Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-08-27T13:40:35Z",
                "user": "akade"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOEf1_Hw=="
          },
          "updatedAt": "2025-08-27T13:04:29Z",
          "id": "IC_kwDODI9FZc7AaVci"
        }
      ],
      "totalCount": 18,
      "endCursor": "Y3Vyc29yOnYyOpHOwGlXIg=="
    },
    "url": "https://github.com/dotnet/runtime/issues/105769",
    "title": "Provide API to allow JSON converters/types to describe their associated JSON schema"
  },
  {
    "author": "ygoe",
    "labels": [
      "api-suggestion",
      "area-System.Text.Json"
    ],
    "createdAt": "2024-08-06T21:07:39Z",
    "body": "### Background and motivation\n\nI have deserialisation code that reads data from JSON text, usually files on disk. It's using the `Utf8JsonReader` to read the source. It already exists and is somewhat complex so I don't want to duplicate the whole thing to also read from `JsonNode`. Another API that receives JSON-formatted messages from a network connection gives me the payload part as `JsonNode` because it has already read the whole message and needed to process parts of it.\r\n\r\nSo what I'm doing now is this:\r\n\r\n```cs\r\nstring dataJson = message.PayloadData.ToJsonString();\r\nbyte[] dataJsonBytes = Encoding.UTF8.GetBytes(dataJson);\r\nvar reader = new Utf8JsonReader(dataJsonBytes);\r\n```\r\n\r\nThis converts me the already parsed payload from `JsonNode` to serialised text, copies it over a few times for the encoding and finally I have something that `Utf8JsonReader` can read from.\r\n\r\nSince `Utf8JsonReader` is a ref struct, I can't simply derive from it and change the behaviour. It needs to be the exact thing that can read from `JsonNode` as well internally.\n\n### API Proposal\n\n```csharp\r\nusing System.Text.Json.Nodes;\r\n\r\nnamespace System.Text.Json;\r\n\r\npublic ref struct Utf8JsonReader\r\n{\r\n    public Utf8JsonReader(JsonNode source);\r\n}\r\n```\r\n\n\n### API Usage\n\nSave the text work and read tokens from the nodes directly. It should be easy since the tokens are already known. The nodes can simply be iterated and returned in the reader API.\r\n\r\n```cs\r\nvar reader = new Utf8JsonReader(message.PayloadData);\r\n```\r\n\n\n### Alternative Designs\n\nExtra processing and memory allocation through the intermediate serialisation step. This is the current workaround.\n\n### Risks\n\nI don't see any. It's a new API that has never existed before and nobody needs to use it if they don't need to.",
    "number": 106047,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-08-07T02:16:10Z",
          "user": "gregsdennis"
        }
      ],
      "totalCount": 1,
      "endCursor": "Y3Vyc29yOnYyOpHOC5_Vvw=="
    },
    "updatedAt": "2024-08-07T14:20:02Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": "dotnet-policy-service",
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. -->",
          "createdAt": "2024-08-06T21:08:00Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-08-06T21:08:00Z",
          "id": "IC_kwDODI9FZc6HblY7"
        },
        {
          "author": "am11",
          "body": "> So what I'm doing now is this:\r\n\r\nIt can be improved with something like:\r\n\r\n```c#\r\nusing System.Buffers;\r\nusing System.Text.Json;\r\nusing System.Text.Json.Nodes;\r\n\r\nJsonNode node = GetNode();\r\nUtf8JsonReader reader = node.AsUtf8JsonReader();\r\n\r\nUse(reader);\r\n\r\npublic static class JsonNodeExtensions\r\n{\r\n    public static Utf8JsonReader AsUtf8JsonReader(this JsonNode payloadData)\r\n    {\r\n        ArrayBufferWriter<byte> bufferWriter = new();\r\n\r\n        using Utf8JsonWriter writer = new(bufferWriter);\r\n        payloadData.WriteTo(writer);\r\n\r\n        return new(bufferWriter.WrittenMemory.Span);\r\n    }\r\n}\r\n```",
          "createdAt": "2024-08-06T21:25:50Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-08-07T14:13:44Z",
                "user": "ygoe"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHODtIRHA=="
          },
          "updatedAt": "2024-08-06T21:25:50Z",
          "id": "IC_kwDODI9FZc6HbrbO"
        },
        {
          "author": "eiriktsarpalis",
          "body": "> So what I'm doing now is this:\r\n> \r\n> ```cs\r\n> string dataJson = message.PayloadData.ToJsonString();\r\n> byte[] dataJsonBytes = Encoding.UTF8.GetBytes(dataJson);\r\n> var reader = new Utf8JsonReader(dataJsonBytes);\r\n> ```\r\n> \r\n> This converts me the already parsed payload from `JsonNode` to serialised text, copies it over a few times for the encoding and finally I have something that `Utf8JsonReader` can read from.\r\n\r\nThis is a known restriction emanating from `Utf8JsonReader` being a ref struct. In fact, STJ itself is forced to perform this inefficient conversion in many places in its own implementation. \r\n\r\nI don't believe extending the `Utf8JsonReader` type itself to support all possible sources of JSON (UTF-16, `JsonNode`, `JsonDocument`, etc.) is a sustainable solution: it isn't pay-for-play and even the name of the type itself suggests that it's restricted to UTF-8 JSON decoding responsibilities. Longer-term, we need a reader abstraction, e.g. an `IJsonReader` interface akin to the abstract [`JsonReader` class in Json.NET](https://www.newtonsoft.com/json/help/html/t_newtonsoft_json_jsonreader.htm). \r\n\r\nNote that adding such an interface is dependent on the language [adding support for ref struct interface implementations](https://github.com/dotnet/csharplang/issues/7608), but even then this would require duplicating most of the serialization API surface to support polymorphic readers. For starters, `JsonConverter<T>` would need to add a new method:\r\n```C#\r\npublic partial class JsonConverter<T>\r\n{\r\n    public virtual T? Read<TReader>(ref TReader reader, Type type, JsonSerializerOptions options) where TReader : allow ref struct, IJsonReader => throw new NotImplementedException();\r\n}\r\n```\r\nwhich converter authors would then need to implement. Needless to say, this has cost and complexity comparable to implementing a serializer from scratch.\r\n\r\ncc @stephentoub @davidfowl ",
          "createdAt": "2024-08-07T11:20:42Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-08-07T11:20:42Z",
          "id": "IC_kwDODI9FZc6HftQL"
        },
        {
          "author": "stephentoub",
          "body": "> Note that adding such an interface is dependent on the language https://github.com/dotnet/csharplang/issues/7608\n\nFor completeness, this exists now in C# 13 and .NET 9.",
          "createdAt": "2024-08-07T12:44:21Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-08-07T13:07:02Z",
                "user": "eiriktsarpalis"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHODtHpZg=="
          },
          "updatedAt": "2024-08-07T12:44:21Z",
          "id": "IC_kwDODI9FZc6HgR3T"
        },
        {
          "author": "ygoe",
          "body": "> It can be improved with something like:\r\n\r\n@am11 FYI, a `writer.Flush()` call is still needed after the `WriteTo` call, or the written bytes will be incomplete. I know this type of problem already. ;-) But thanks for the suggestion, it looks better than mine and I can live with it for now.",
          "createdAt": "2024-08-07T14:20:01Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-08-07T18:22:27Z",
                "user": "am11"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHODtKTTw=="
          },
          "updatedAt": "2024-08-07T14:20:01Z",
          "id": "IC_kwDODI9FZc6HhE4Q"
        }
      ],
      "totalCount": 5,
      "endCursor": "Y3Vyc29yOnYyOpHOh4ROEA=="
    },
    "url": "https://github.com/dotnet/runtime/issues/106047",
    "title": "[API Proposal]: Utf8JsonReader should read from JsonNode"
  },
  {
    "author": "Drake53",
    "labels": [
      "enhancement",
      "area-System.Text.Json"
    ],
    "createdAt": "2024-09-04T17:53:31Z",
    "body": "### Description\r\n\r\nFor my use case I have the following third party XSD (simplified) for which I generate an enum:\r\n```xml\r\n<xs:schema xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">\r\n    <xs:simpleType name=\"YesOrNoOrEmpty\">\r\n        <xs:restriction base=\"xs:string\">\r\n            <xs:enumeration value=\"y\" />\r\n            <xs:enumeration value=\"n\" />\r\n            <xs:enumeration value=\"\" />\r\n        </xs:restriction>\r\n    </xs:simpleType>\r\n</xs:schema>\r\n```\r\n\r\nI want the generated enum to be serializable in both XML and JSON, so I annotate the members with both XmlEnumAttribute as well as the new JsonStringEnumMemberNameAttribute from System.Text.Json v9-preview.\r\n\r\nFor XML this works fine, but with JSON I get an exception, because empty strings are not allowed. I assume this might have something to do with support for Flags enums? But for enums without FlagsAttribute this restriction should not apply.\r\n\r\n### Reproduction Steps\r\n\r\n```csharp\r\nusing System.Text.Json.Serialization;\r\nusing System.Xml.Serialization;\r\n\r\npublic enum YesOrNoOrEmpty\r\n{\r\n    [JsonStringEnumMemberName(\"y\")]\r\n    [XmlEnum(\"y\")]\r\n    Yes,\r\n\r\n    [JsonStringEnumMemberName(\"n\")]\r\n    [XmlEnum(\"n\")]\r\n    No,\r\n\r\n    [JsonStringEnumMemberName(\"\")]\r\n    [XmlEnum(\"\")]\r\n    Empty,\r\n}\r\n```\r\n\r\n### Expected behavior\r\n\r\n`JsonStringEnumConverter` is able to serialize and deserialize enums where the string representation of one of the enum members is an empty string. This matches behaviour of System.Xml's XmlEnumAttribute, and EnumMemberAttribute which is used by Newtonsoft.Json.\r\n\r\n### Actual behavior\r\n\r\n`JsonStringEnumConverter` (using `EnumConverter` internally) does a `string.IsNullOrEmpty` check and throws an InvalidOperationException: `Enum type '{0}' uses unsupported identifier '{1}'. It must not be null, empty, or containing leading or trailing whitespace. Flags enums must additionally not contain commas.`\r\n\r\n### Regression?\r\n\r\n_No response_\r\n\r\n### Known Workarounds\r\n\r\nImplementing a custom JsonConverter for enums\r\n\r\n### Configuration\r\n\r\n_No response_\r\n\r\n### Other information\r\n\r\n_No response_",
    "number": 107367,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-09-05T18:44:14Z",
          "user": "campersau"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-09-25T17:25:48Z",
          "user": "IvanJosipovic"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-11-03T19:34:02Z",
          "user": "josephcrivello"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-11-28T00:24:26Z",
          "user": "anujgeek"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-01-20T15:05:29Z",
          "user": "yieldOnly"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-01-20T15:13:26Z",
          "user": "Rans4ckeR"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-01-20T16:22:20Z",
          "user": "manandre"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-02-24T10:49:41Z",
          "user": "gwenya"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-02-28T19:48:20Z",
          "user": "scott-dak"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-02-28T19:53:35Z",
          "user": "djtinklenberg"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-06-04T12:41:22Z",
          "user": "0xced"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-06-07T03:08:02Z",
          "user": "Yushu2606"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-06-13T11:16:35Z",
          "user": "Langthjem"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-06-19T11:59:41Z",
          "user": "hurtonypeter"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-06-26T07:50:01Z",
          "user": "JoschkaBC"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-08-08T14:30:40Z",
          "user": "S-Luiten"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-09-03T19:04:01Z",
          "user": "MichalPetryka"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-09-04T08:02:52Z",
          "user": "ElDuderinoBerlin"
        }
      ],
      "totalCount": 18,
      "endCursor": "Y3Vyc29yOnYyOpHODOWEAw=="
    },
    "updatedAt": "2025-09-04T08:02:46Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": "dotnet-policy-service",
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. -->",
          "createdAt": "2024-09-04T17:54:01Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-09-04T17:54:01Z",
          "id": "IC_kwDODI9FZc6K287p"
        },
        {
          "author": "eiriktsarpalis",
          "body": "There's nothing technically preventing the use of empty strings (even in the case of flags, where you might be able to write something like `y, , n`). [It got added intentionally](https://github.com/dotnet/runtime/blob/49bf719618acd3444c0b6b58bc9f7661a8c25708/src/libraries/System.Text.Json/tests/System.Text.Json.Tests/Serialization/EnumConverterTests.cs#L1174-L1209) principally to avoid pathological outputs (like the one mentioned above) and discourage it from being used. \r\n\r\nWe might consider relaxing that restriction in the future, provided there is sufficient demand for it.",
          "createdAt": "2024-09-09T10:41:05Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-09-09T10:41:37Z",
          "id": "IC_kwDODI9FZc6LV3g0"
        },
        {
          "author": "Drake53",
          "body": "> There's nothing technically preventing the use of empty strings (even in the case of flags, where you might be able to write something like `y, , n`).\r\n\r\nIt's true the example you give could work, even though it looks a bit weird, but the problem is that the empty string in json will become ambiguous, because it can be either no flags, or only the empty string member's flag:\r\n```csharp\r\n[Flags]\r\npublic enum FlagsEnum\r\n{\r\n    [JsonStringEnumMemberName(\"\")]\r\n    Empty = 1,\r\n    [JsonStringEnumMemberName(\"1\")]\r\n    One = 2,\r\n}\r\n\r\nJsonSerializer.Serialize(FlagsEnum.Empty); // returns \"\"\r\nJsonSerializer.Serialize((FlagsEnum)0); // returns \"\"\r\n\r\nJsonSerializer.Deserialize<FlagsEnum>(\"\"); // ambiguous\r\n```",
          "createdAt": "2024-09-11T18:23:04Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-09-11T18:25:38Z",
          "id": "IC_kwDODI9FZc6LvGUb"
        },
        {
          "author": "IvanJosipovic",
          "body": "I would also like the library to support [JsonStringEnumMemberName(\"\")] and [JsonStringEnumMemberName(null)]\r\n\r\n```csharp\r\npublic enum EnumMemberedEnum\r\n{\r\n    No = 0,\r\n\r\n    [System.Text.Json.Serialization.JsonStringEnumMemberName(\"goodbye\")]\r\n    Hello = 1,\r\n\r\n    [System.Text.Json.Serialization.JsonStringEnumMemberName(\"\")]\r\n    EmptyValue = 2,\r\n\r\n    [System.Text.Json.Serialization.JsonStringEnumMemberName(null)]\r\n    NullValue = 3\r\n}\r\n```",
          "createdAt": "2024-09-25T17:26:54Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-09-25T17:33:49Z",
          "id": "IC_kwDODI9FZc6Ni2oa"
        },
        {
          "author": "josephcrivello",
          "body": "I also would like `JsonStringEnumMemberName` to support empty and null strings.\n\n> There's nothing technically preventing the use of empty strings (even in the case of flags, where you might be able to write something like `y, , n`). [It got added intentionally](https://github.com/dotnet/runtime/blob/49bf719618acd3444c0b6b58bc9f7661a8c25708/src/libraries/System.Text.Json/tests/System.Text.Json.Tests/Serialization/EnumConverterTests.cs#L1174-L1209) principally to avoid pathological outputs (like the one mentioned above) and discourage it from being used.\n> \n> We might consider relaxing that restriction in the future, provided there is sufficient demand for it.\n\nThis feels like a **bug** to me, or at least a defect in the requirements specification, not an **enhancement**.\n\nIn a perfect world, I understand the desire to discourage cases like the one you outlined. But one of the most common use cases for `System.Text.Json.Serialization` is writing .NET applications and libraries that interact with restful APIs. Typically, the developer or organization responsible for this task has no control over the JSON schema defined by the API, or it cannot be easily changed.\n\nIsn't `System.Text.Json.Serialization` supposed to be able to support the serialization and deserialization of any well-formed JSON?\n\nIf yes, then it seems like this behavior is incorrect. `JsonStringEnumMemberName` is imposing an opinionated limitation on serializing and deserializing well-formed JSON with no technical basis or rationale.",
          "createdAt": "2024-11-03T19:27:55Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "HEART",
                "createdAt": "2024-11-03T19:33:12Z",
                "user": "IvanJosipovic"
              },
              {
                "content": "HEART",
                "createdAt": "2025-01-20T14:32:32Z",
                "user": "yieldOnly"
              },
              {
                "content": "HEART",
                "createdAt": "2025-02-21T19:44:51Z",
                "user": "IvanOliinychenko"
              },
              {
                "content": "HEART",
                "createdAt": "2025-02-24T10:46:56Z",
                "user": "gwenya"
              },
              {
                "content": "HEART",
                "createdAt": "2025-06-13T11:16:53Z",
                "user": "Langthjem"
              },
              {
                "content": "HEART",
                "createdAt": "2025-06-19T12:06:41Z",
                "user": "hurtonypeter"
              }
            ],
            "totalCount": 6,
            "endCursor": "Y3Vyc29yOnYyOpHOEXNI7g=="
          },
          "updatedAt": "2024-11-03T19:29:48Z",
          "id": "IC_kwDODI9FZc6SPjJK"
        },
        {
          "author": "eiriktsarpalis",
          "body": "> Isn't System.Text.Json.Serialization supposed to be able to support the serialization and deserialization of any well-formed JSON?\n\nAny serializer that extracts a JSON contract from types will by definition do so in an opinionated manner that doesn't accommodate every conceivable use case. For any such corner cases the recommended workaround is to employ a custom converter, if and until a particular corner case becomes supported in the built-in converters.",
          "createdAt": "2024-11-03T20:25:05Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-11-03T20:25:05Z",
          "id": "IC_kwDODI9FZc6SPnI9"
        },
        {
          "author": "josephcrivello",
          "body": "> Any serializer that extracts a JSON contract from types will by definition do so in an opinionated manner that doesn't accommodate every conceivable use case. For any such corner cases the recommended workaround is to employ a custom converter, if and until a particular corner case becomes supported in the built-in converters.\n\nOf course, all serializers should make their own opinionated design decisions. This is useful because it helps ensure a cohesive design.\n\nI am under the impression from the documentation that the following are the key \"opinions\" underlying the design of `System.Text.Json`:\n\n> The System.Text.Json library design emphasizes high performance and low memory allocation over an extensive feature set. Built-in UTF-8 support optimizes the process of reading and writing JSON text encoded as UTF-8, which is the most prevalent encoding for data on the web and files on disk.\n> [JSON serialization and deserialization (marshalling and unmarshalling) in .NET - overview](https://learn.microsoft.com/en-us/dotnet/standard/serialization/system-text-json/overview)\n\nI am aware that there are other goals that are not mentioned in this brief description, such as achieving AOT support.\n\nIs preventing the consumer of the library from producing \"pathological outputs\" one of the opinionated design goals for the `System.Text.Json` library?",
          "createdAt": "2024-11-03T21:01:19Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-11-03T21:02:40Z",
          "id": "IC_kwDODI9FZc6SPpfP"
        },
        {
          "author": "eiriktsarpalis",
          "body": "> Is preventing the consumer of the library from producing \"pathological outputs\" one of the opinionated design goals for the System.Text.Json library?\n\nYes. There are a number of things that the library explicitly does not permit _out of the box_ in the interest of performance, security, promoting good practices, and adhering to the principle of least surprise. For example, it doesn't allow unconstrained polymorphism nor does it do implicit type coercion. The reason why whitespace isn't allowed in enum identifiers is because of the ambiguity that it introduces in the context of flag enum serialization.\n\nThat does not mean they're not possible to achieve using customization, and we make sure that the library exposes all the necessary extensibility points in the likely event that the built-in features don't support a specific scenario.",
          "createdAt": "2024-11-03T21:29:20Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-01-25T15:18:41Z",
                "user": "airbreather"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOEEAHZw=="
          },
          "updatedAt": "2024-11-03T21:29:20Z",
          "id": "IC_kwDODI9FZc6SPrVl"
        },
        {
          "author": "josephcrivello",
          "body": "> Yes. There are a number of things that the library explicitly does not permit _out of the box_ in the interest of performance, security, promoting good practices, and adhering to the principle of least surprise. For example, it doesn't allow unconstrained polymorphism nor does it do implicit type coercion. The reason why whitespace isn't allowed in enum identifiers is because of the ambiguity that it introduces in the context of flag enum serialization.\n\nOk, all that seems pretty reasonable. Thank you for taking the time to respond, your response has helped me clarify the nature of my disagreement. Here is my precise objection:\n\nAn empty string is _not_ a pathological output, other than in the noted special case of flags enum serialization.\n\nAn empty string is a common, non-pathological use case for indicating the absence of a meaningful value. In this use case, it makes perfect sense to map the default value of an enum to an empty string. For example:\n\n```csharp\npublic enum CustomerSelection\n{\n    [JsonStringEnumMemberName(\"\")]\n    Undefined = 0,\n\n    [JsonStringEnumMemberName(\"option_1\")]\n    Option1,\n\n    [JsonStringEnumMemberName(\"option_2\")]\n    Option2,\n}\n```\n\nIt seems like the baby is being thrown out with the bathwater.\n\nI understand that no serialization library can address every use case, but it is a pity because so many restful APIs use empty strings in this manner. Integrating .NET applications and libraries with restful APIs is presumably one of the (or the) most common use cases for the serializer. Now, .NET 9 is about to be released, and the die will be cast on the expected behavior for `JsonStringEnumMemberNameAttribute` presumably making it difficult or impossible to change in the future.\n\nI'll stop beating a dead horse now.",
          "createdAt": "2024-11-03T22:01:12Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-11-03T22:04:16Z",
          "id": "IC_kwDODI9FZc6SPth1"
        },
        {
          "author": "eiriktsarpalis",
          "body": "> An empty string is not a pathological output, other than in the noted special case of flags enum serialization.\n\nI don't think we're in disagreement here. As mentioned earlier, it is conceivable that the converter could be made to be more forgiving provided that flags aren't being used. This is why the issue is being kept open; it is something we can consider in the future provided there is necessary traction. However, it isn't something we can change with .NET 9 for which development concluded back in August.",
          "createdAt": "2024-11-04T07:59:45Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-11-04T08:01:42Z",
          "id": "IC_kwDODI9FZc6SRZp5"
        },
        {
          "author": "yieldOnly",
          "body": "> We might consider relaxing that restriction in the future, provided there is sufficient demand for it.\n\nSince you said you might reconsider if there is enough demand, I'll give some feedback on that: I ran into this exact issue earlier today.\n\nI have a third-party defined json schema (I can't influence them) using an enum with the empty string to represent \"none\". There are no flags involved, because this scenario is single choice.\n\nThere is a work-around, so I can make the code work. But I expected .NET to support this :(",
          "createdAt": "2025-01-20T14:34:20Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-01-20T14:34:20Z",
          "id": "IC_kwDODI9FZc6bIEIZ"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Please upvote the OP so that it registers more strongly in our backlog.",
          "createdAt": "2025-01-20T15:01:14Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-01-20T15:01:14Z",
          "id": "IC_kwDODI9FZc6bITto"
        },
        {
          "author": "IvanJosipovic",
          "body": "> > We might consider relaxing that restriction in the future, provided there is sufficient demand for it.\n> \n> Since you said you might reconsider if there is enough demand, I'll give some feedback on that: I ran into this exact issue earlier today.\n> \n> I have a third-party defined json schema (I can't influence them) using an enum with the empty string to represent \"none\". There are no flags involved, because this scenario is single choice.\n> \n> There is a work-around, so I can make the code work. But I expected .NET to support this :(\n\n@yieldOnly, do you mind posting the work-around?",
          "createdAt": "2025-01-20T16:58:52Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-01-20T16:58:52Z",
          "id": "IC_kwDODI9FZc6bJSGa"
        },
        {
          "author": "yieldOnly",
          "body": "> > > We might consider relaxing that restriction in the future, provided there is sufficient demand for it.\n> > \n> > \n> > Since you said you might reconsider if there is enough demand, I'll give some feedback on that: I ran into this exact issue earlier today.\n> > I have a third-party defined json schema (I can't influence them) using an enum with the empty string to represent \"none\". There are no flags involved, because this scenario is single choice.\n> > There is a work-around, so I can make the code work. But I expected .NET to support this :(\n> \n> [@yieldOnly](https://github.com/yieldOnly), do you mind posting the work-around?\n\nWe just declared the property as `string` instead of as an enum. It's not the most beautiful solution and a custom JsonConverter would have been cleaner, but for our needs that would not have been worth the extra code.",
          "createdAt": "2025-01-20T22:42:45Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-01-20T22:42:45Z",
          "id": "IC_kwDODI9FZc6bK4RL"
        },
        {
          "author": "0xced",
          "body": "The [Docker Engine API](https://docs.docker.com/reference/api/engine/) has many empty strings which naturally map onto enums.\n\nFor example, the [SystemInfo Isolation](https://docs.docker.com/reference/api/engine/version/v1.50/#tag/System/operation/SystemInfo)  is documented as Enum: `\"default\"` `\"hyperv\"` `\"process\"` `\"\"` where the empty string is listed as a legitimate value.\n\n> We might consider relaxing that restriction in the future, provided there is sufficient demand for it.\n\nLet's hope that my 11th 👍 will help reach the demand threshold. 🤞",
          "createdAt": "2025-06-04T13:41:11Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-06-04T14:14:48Z",
                "user": "IvanJosipovic"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-06-13T11:16:23Z",
                "user": "Langthjem"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-08-31T15:38:53Z",
                "user": "bunnyi116"
              }
            ],
            "totalCount": 3,
            "endCursor": "Y3Vyc29yOnYyOpHOEgSZkQ=="
          },
          "updatedAt": "2025-06-04T13:41:11Z",
          "id": "IC_kwDODI9FZc6vPjn0"
        },
        {
          "author": "ElDuderinoBerlin",
          "body": "Please implement this feature.",
          "createdAt": "2025-09-04T08:02:46Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-09-04T08:02:46Z",
          "id": "IC_kwDODI9FZc7B28tX"
        }
      ],
      "totalCount": 16,
      "endCursor": "Y3Vyc29yOnYyOpHOwdvLVw=="
    },
    "url": "https://github.com/dotnet/runtime/issues/107367",
    "title": "JsonStringEnumMemberNameAttribute does not support empty strings."
  },
  {
    "author": "mas-sdb",
    "labels": [
      "enhancement",
      "area-System.Text.Json",
      "help wanted"
    ],
    "createdAt": "2024-09-08T11:20:45Z",
    "body": "### Description\r\n\r\nAccording to the JSON Schema specification, enumerations are expected to select a single (possibly null) element from a list of exclusive elements, like System.DayOfWeek, and are not intended to be treated as bit fields like System.IO.FileAccess.\r\n\r\nhttps://json-schema.org/draft/2020-12/json-schema-validation#name-enum\r\n\r\nThe current implementation is as follows:\r\n- By default, enumerations are output as integer type\r\n- If you register JsonStringEnumConverter to JsonSerializerOptions.Converters:\r\n  - For enum types without FlagsAttribute, the list of fields is output with the \"enum\" key. (\"type\" is not output)\r\n  - For enum types with FlagsAttribute, it is output as string type.\r\n\r\nAs the comments in the source code say, it is understandable that some precision is sacrificed for simplicity.\r\n\r\nhttps://github.com/dotnet/runtime/blob/v9.0.0-preview.7.24405.7/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/Converters/Value/EnumConverter.cs#L505\r\n\r\nTreating an enumeration as a bit field is an implementation issue.\r\nIt may be preferable to provide a list of possible values.\r\n\r\nIf you need to pass multiple values, you can define a separate array for example.\r\nAlso, there are some combinations that are not allowed in bit fields, but these are not something that should be defined in a JSON Schema.\r\n\r\nTherefore, I think it should be possible to output the list of fields with the \"enum\" key even for enumerations with FlagsAttribute by configuration.\r\n\r\nRelated issue: #107501\r\n\r\n### Reproduction Steps\r\n\r\nUses System.Text.Json 9.0.0-preview.7.24405.7.\r\nRun the following code:\r\n\r\n```csharp\r\nvar serializerOptions = new JsonSerializerOptions(JsonSerializerDefaults.Web)\r\n{\r\n\tConverters = { new JsonStringEnumConverter() }, // If not defined, it will be output as integer type.\r\n\tPropertyNamingPolicy = JsonNamingPolicy.SnakeCaseLower,\r\n\tRespectNullableAnnotations = true,\r\n\tTypeInfoResolver = new DefaultJsonTypeInfoResolver(),\r\n\tWriteIndented = true\r\n};\r\n\r\nvar exporterOptions = new JsonSchemaExporterOptions\r\n{\r\n\tTreatNullObliviousAsNonNullable = true,\r\n};\r\n\r\nvar schema = serializerOptions.GetJsonSchemaAsNode(typeof(TestModel), exporterOptions);\r\nConsole.WriteLine(schema.ToJsonString(serializerOptions));\r\n\r\npublic class TestModel\r\n{\r\n\tpublic required DayOfWeek? EnumRequiredAllowNull { get; set; }\r\n\tpublic required DayOfWeek EnumRequiredNotNull { get; set; }\r\n\tpublic required FileAccess? EnumWithFlagsRequiredAllowNull { get; set; }\r\n\tpublic required FileAccess EnumWithFlagsRequiredNotNull { get; set; }\r\n}\r\n```\r\n\r\n\r\n### Expected behavior\r\n\r\nThis does not have to be the default behavior, but the configuration should support it.\r\n\r\n```json\r\n{\r\n  \"type\": \"object\",\r\n  \"properties\": {\r\n    \"enum_required_allow_null\": {\r\n      \"enum\": [\r\n        \"Sunday\",\r\n        \"Monday\",\r\n        \"Tuesday\",\r\n        \"Wednesday\",\r\n        \"Thursday\",\r\n        \"Friday\",\r\n        \"Saturday\",\r\n        null\r\n      ]\r\n    },\r\n    \"enum_required_not_null\": {\r\n      \"enum\": [\r\n        \"Sunday\",\r\n        \"Monday\",\r\n        \"Tuesday\",\r\n        \"Wednesday\",\r\n        \"Thursday\",\r\n        \"Friday\",\r\n        \"Saturday\"\r\n      ]\r\n    },\r\n    \"enum_with_flags_required_allow_null\": {\r\n      \"enum\": [\r\n        \"Read\",\r\n        \"Write\",\r\n        \"ReadWrite\",\r\n        null\r\n      ]\r\n    },\r\n    \"enum_with_flags_required_not_null\": {\r\n      \"enum\": [\r\n        \"Read\",\r\n        \"Write\",\r\n        \"ReadWrite\"\r\n      ]\r\n    }\r\n  },\r\n  \"required\": [\r\n    \"enum_required_allow_null\",\r\n    \"enum_required_not_null\",\r\n    \"enum_with_flags_required_allow_null\",\r\n    \"enum_with_flags_required_not_null\"\r\n  ]\r\n}\r\n```\r\n\r\n\r\n### Actual behavior\r\n\r\n- If you register JsonStringEnumConverter to JsonSerializerOptions.Converters:\r\n  - For enum types without FlagsAttribute, the list of fields is output with the \"enum\" key. (\"type\" is not output)\r\n  - For enum types with FlagsAttribute, it is output as string type.\r\n\r\n\r\n```json\r\n{\r\n  \"type\": \"object\",\r\n  \"properties\": {\r\n    \"enum_required_allow_null\": {\r\n      \"enum\": [\r\n        \"Sunday\",\r\n        \"Monday\",\r\n        \"Tuesday\",\r\n        \"Wednesday\",\r\n        \"Thursday\",\r\n        \"Friday\",\r\n        \"Saturday\",\r\n        null\r\n      ]\r\n    },\r\n    \"enum_required_not_null\": {\r\n      \"enum\": [\r\n        \"Sunday\",\r\n        \"Monday\",\r\n        \"Tuesday\",\r\n        \"Wednesday\",\r\n        \"Thursday\",\r\n        \"Friday\",\r\n        \"Saturday\"\r\n      ]\r\n    },\r\n    \"enum_with_flags_required_allow_null\": {\r\n      \"type\": [\r\n        \"string\",\r\n        \"null\"\r\n      ]\r\n    },\r\n    \"enum_with_flags_required_not_null\": {\r\n      \"type\": \"string\"\r\n    }\r\n  },\r\n  \"required\": [\r\n    \"enum_required_allow_null\",\r\n    \"enum_required_not_null\",\r\n    \"enum_with_flags_required_allow_null\",\r\n    \"enum_with_flags_required_not_null\"\r\n  ]\r\n}\r\n```\r\n\r\n\r\n### Regression?\r\n\r\n_No response_\r\n\r\n### Known Workarounds\r\n\r\nUses JsonSchemaExporterOptions.TransformSchemaNode.\r\nI generated the \"Expected behavior\" schema with the code below.\r\n\r\n```csharp\r\nvar serializerOptions = new JsonSerializerOptions(JsonSerializerDefaults.Web)\r\n{\r\n  Converters = { new JsonStringEnumConverter() },\r\n  WriteIndented = true,\r\n  NumberHandling = JsonNumberHandling.Strict,\r\n  PropertyNamingPolicy = JsonNamingPolicy.SnakeCaseLower,\r\n  RespectNullableAnnotations = true,\r\n  TypeInfoResolver = new DefaultJsonTypeInfoResolver()\r\n};\r\n\r\nvar exporterOptions = new JsonSchemaExporterOptions\r\n{\r\n  TreatNullObliviousAsNonNullable = true,\r\n  TransformSchemaNode = OnTransformSchemaNode\r\n};\r\n\r\nvar schema = serializerOptions.GetJsonSchemaAsNode(typeof(TestModel), exporterOptions);\r\nConsole.WriteLine(schema.ToJsonString(serializerOptions));\r\n\r\nJsonNode OnTransformSchemaNode(JsonSchemaExporterContext context, JsonNode node)\r\n{\r\n  if(context.TypeInfo.Kind != JsonTypeInfoKind.Object)\r\n  {\r\n    return node;\r\n  }\r\n\r\n  var current = node.AsObject();\r\n\r\n  if(!current.TryGetPropertyValue(\"properties\", out var properties))\r\n  {\r\n    return current;\r\n  }\r\n\r\n  if(properties is not JsonObject propertiesObject)\r\n  {\r\n    return current;\r\n  }\r\n\r\n  // Searches within \"properties\" and if the property type is enum, removes \"type\" and outputs \"enum\".\r\n  for(int i = 0; i < propertiesObject.Count; i++)\r\n  {\r\n    if(propertiesObject[i] is not JsonObject property)\r\n    {\r\n      continue;\r\n    }\r\n\r\n    if(!IsEnumType(context.TypeInfo, property.GetPropertyName(), out var enumType, out var isNullable))\r\n    {\r\n      continue;\r\n    }\r\n\r\n    TryUpdateEnum(property, enumType, isNullable);\r\n  }\r\n\r\n  return current;\r\n}\r\n\r\nvoid TryUpdateEnum(JsonObject property, Type enumType, bool isNullable)\r\n{\r\n  if(property.TryGetPropertyValue(\"type\", out _))\r\n  {\r\n    property.Remove(\"type\");\r\n  }\r\n\r\n  if(!property.TryGetPropertyValue(\"enum\", out _))\r\n  {\r\n    var values = new JsonArray();\r\n    foreach(var value in Enum.GetNames(enumType))\r\n    {\r\n      values.Add(value);\r\n    }\r\n\r\n    if(isNullable)\r\n    {\r\n      values.Add(null);\r\n    }\r\n\r\n    property.Add(\"enum\", values);\r\n  }\r\n}\r\n\r\nbool IsEnumType(JsonTypeInfo typeInfo, string propertyName, [NotNullWhen(true)] out Type? type, out bool isNullable)\r\n{\r\n  type = null;\r\n  isNullable = false;\r\n\r\n  // Determines if a property is an enum type, including case that it is nullable type.\r\n  var t = typeInfo.Properties.FirstOrDefault(r => r.Name == propertyName);\r\n\r\n  if(t == null)\r\n  {\r\n    return false;\r\n  }\r\n\r\n  var underlyingType = Nullable.GetUnderlyingType(t.PropertyType);\r\n\r\n  type = (t is { PropertyType.IsEnum: true }) ? t.PropertyType :\r\n      (underlyingType is { IsEnum: true }) ? underlyingType : null;\r\n  isNullable = underlyingType is not null;\r\n\r\n  return type != null;\r\n}\r\n\r\npublic class TestModel\r\n{\r\n  public required DayOfWeek? EnumRequiredAllowNull { get; set; }\r\n  public required DayOfWeek EnumRequiredNotNull { get; set; }\r\n  public required FileAccess? EnumWithFlagsRequiredAllowNull { get; set; }\r\n  public required FileAccess EnumWithFlagsRequiredNotNull { get; set; }\r\n}\r\n```\r\n\r\n### Configuration\r\n\r\n_No response_\r\n\r\n### Other information\r\n\r\n_No response_",
    "number": 107508,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-09-20T20:46:47Z",
          "user": "StephenHodgson"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-02-12T18:26:28Z",
          "user": "NicklausBrain"
        }
      ],
      "totalCount": 2,
      "endCursor": "Y3Vyc29yOnYyOpHOC_B5iw=="
    },
    "updatedAt": "2024-09-09T20:21:49Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": "gregsdennis",
          "body": "I [serialize](https://docs.json-everything.net/more/json-more/#more-enums) flags enums as arrays with the selected values. \n\nSo I'd expect a schema that's like this: \n\n```json\n{\n  \"$defs\": {\n    \"enum-values\": {\n      \"enum\": [\"foo\", \"bar\", \"baz\"]\n    }\n  },\n  \"oneOf\": [\n    { \"$ref\": \"#/$defs/enum-values\" },\n    {\n      \"type\": \"array\",\n      \"items\": { \"$ref\": \"#/$defs/enum-values\" },\n      \"uniqueItems\": true\n    }\n  ]\n}\n```\n\nI don't think that `type: string` is sufficient, though maybe you could add a `pattern` in there to describe comma-delimited values.",
          "createdAt": "2024-09-08T19:22:15Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-09-08T22:46:22Z",
                "user": "mas-sdb"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-09-20T20:46:54Z",
                "user": "StephenHodgson"
              }
            ],
            "totalCount": 2,
            "endCursor": "Y3Vyc29yOnYyOpHODzEbKw=="
          },
          "updatedAt": "2024-09-08T19:26:30Z",
          "id": "IC_kwDODI9FZc6LSK0a"
        },
        {
          "author": "eiriktsarpalis",
          "body": "> Expected behavior\r\n\r\n> ```json\r\n>     \"enum_with_flags_required_not_null\": {\r\n>       \"enum\": [\r\n>         \"Read\",\r\n>         \"Write\",\r\n>         \"ReadWrite\"\r\n>       ]\r\n>     }\r\n> ```\r\n\r\nWouldn't this render values such as `Read, Write` invalid? If the intended purpose of the bespoke `ReadWrite` value is to address that problem, why model your enum as a flag?\r\n\r\n> I don't think that `type: string` is sufficient, though maybe you could add a `pattern` in there to describe comma-delimited values.\r\n\r\nI would support a change for .NET 10 that refines `type : string` with a `pattern` keyword that describes all allowable comma-separated values.\r\n",
          "createdAt": "2024-09-09T11:18:58Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-09-09T11:18:58Z",
          "id": "IC_kwDODI9FZc6LWJsh"
        },
        {
          "author": "mas-sdb",
          "body": "The generated JSON schema is intended to be used outside the .NET ecosystem (e.g., OpenAI GPT-4o).\r\nI want to convey that the enumeration has defined values as the structure of the JSON data to be sent and received.\r\n\r\nWhether the enumeration is a bit field or not is a matter for the internal implementation.\r\nValidating the JSON data is a matter outside the schema definition, too.\r\n\r\nI don't plan to directly deserialize the received data, but will do so while validating it using JsonDocument.\r\n\r\nOf course, I think there's no problem in supporting the patterns supported in .NET 10 as the default.\r\nI think it will work effectively within the .NET ecosystem.\r\n\r\nHowever, if I exchange data outside the .NET ecosystem, I would like the option to provide valid value choices even for enumerations with FlagsAttribute.\r\n",
          "createdAt": "2024-09-09T11:49:27Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-09-20T20:47:37Z",
                "user": "StephenHodgson"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHODzEbWw=="
          },
          "updatedAt": "2024-09-09T11:49:27Z",
          "id": "IC_kwDODI9FZc6LWaYz"
        },
        {
          "author": "eiriktsarpalis",
          "body": "> Whether the enumeration is a bit field or not is a matter for the internal implementation.\r\n> Validating the JSON data is a matter outside the schema definition, too.\r\n\r\nI'm not sure what you mean by this, the flags attribute does have impact on things like the type's `ToString()` output and its JSON serialization contract, so it's far from an implementation detail: \r\n\r\n```C#\r\nConsole.WriteLine(Flags.A | Flags.B); // A, B\r\nConsole.WriteLine(NoFlags.A | NoFlags.B); // 3\r\n\r\n[Flags] enum Flags { A = 1, B = 2 }\r\nenum NoFlags { A = 1, B = 2 }\r\n```",
          "createdAt": "2024-09-09T12:17:53Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-09-09T12:17:53Z",
          "id": "IC_kwDODI9FZc6LWpMy"
        },
        {
          "author": "mas-sdb",
          "body": "Let's consider the case where you pass a JSON schema to a service that is not implemented in .NET and receive the created JSON document.\r\nThe external service looks at the JSON schema definition. It doesn't matter if it doesn't know that the enumeration is defined as a bit field in your .NET system. That's why I say it's an internal implementation issue.\r\n\r\nIn this case, if there is an enumeration with FlagsAttribute and it becomes a \"string\" type, it will not be possible to convey the valid values.\r\nIf you want to pass a list of valid values and also convey that multiple values can be defined, you just need to define it as an array of enumerations, too.\r\n\r\nThen, instead of using JsonSerializer.Deserialise, deserialise the received document with JsonDocument while validating it.\r\n\r\nSo, the current behavior is fine as the default for inside .NET ecosystem, but it should have an option to output a list of valid values with or without the FlagsAttribute.\r\nIs there anything that's still unclear?",
          "createdAt": "2024-09-09T12:53:22Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-09-09T12:53:22Z",
          "id": "IC_kwDODI9FZc6LW8Qh"
        },
        {
          "author": "eiriktsarpalis",
          "body": "> The external service looks at the JSON schema definition. It doesn't matter if it doesn't know that the enumeration is defined as a bit field in your .NET system. That's why I say it's an internal implementation issue.\r\n\r\nThis is true, however as mentioned in #107501 the schemas generated by `JsonSchemaExporter` are specifying the behaviour of `JsonSerializer`. `JsonSerializer` being a code-first serializer derives its serialization contracts from corresponding aspects of the .NET type system. As such, even though enums having `FlagsAttribute` is an implementation detail from the perspective of a web API or LLM making a call to a function, that attribute still impacts the semantics of the API.\r\n\r\n> So, the current behavior is fine as the default for inside .NET ecosystem, but it should have an option to output a list of valid values with or without the FlagsAttribute.\r\n\r\nLike I said, I'd be happy to accept a PR that refines the schema to include a pattern keyword.",
          "createdAt": "2024-09-09T13:22:51Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-09-09T13:24:35Z",
          "id": "IC_kwDODI9FZc6LXNHM"
        },
        {
          "author": "gregsdennis",
          "body": "@mas-sdb have a look at my JsonSchema.Net.Generation library ([docs](https://docs.json-everything.net/schema/schemagen/schema-generation/)) as an alternative. \r\n\r\nIt doesn't natively support flag enums like you want, but it's pretty easy to customize, so you could do it yourself.  It's also very much more expressive.",
          "createdAt": "2024-09-09T18:29:29Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-09-09T19:56:34Z",
                "user": "mas-sdb"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHODxkyWA=="
          },
          "updatedAt": "2024-09-09T20:21:49Z",
          "id": "IC_kwDODI9FZc6LZ2v2"
        },
        {
          "author": "mas-sdb",
          "body": "Thank you. I will use the JsonSchema.Net series.\r\nAfter looking into it, it seems possible to generate the JSON schema required for data exchange with OpenAI GPT-4o Structured Outputs feature without errors.\r\n\r\nThese are based on System.Text.Json and have no extra dependencies, so I think they are very nifty libraries.",
          "createdAt": "2024-09-09T19:55:47Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-09-09T20:21:14Z",
                "user": "gregsdennis"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHODxk87g=="
          },
          "updatedAt": "2024-09-09T19:55:47Z",
          "id": "IC_kwDODI9FZc6LabtH"
        }
      ],
      "totalCount": 8,
      "endCursor": "Y3Vyc29yOnYyOpHOi2m7Rw=="
    },
    "url": "https://github.com/dotnet/runtime/issues/107508",
    "title": "JsonSchemaExporter.GetJsonSchemaAsNode cannot output array of fields for enum types with FlagsAttribute"
  },
  {
    "author": "isukces",
    "labels": [
      "enhancement",
      "area-System.Text.Json"
    ],
    "createdAt": "2024-09-13T08:32:36Z",
    "body": "### Description\r\n\r\nUnable to deserialize `ArraySegment<int>` using `System.Text.Json.JsonSerializer`, even when the value was serialized using `System.Text.Json.JsonSerializer`.\r\n\r\n### Reproduction Steps\r\n\r\nUse XUnit test below:\r\n```cs\r\n[Fact]\r\npublic void Should_serialize_with_system_text_json()\r\n{\r\n    int[] src          = [1, 2, 3];\r\n    var   arraySegment = new ArraySegment<int>(src);\r\n    var   json         = System.Text.Json.JsonSerializer.Serialize(arraySegment);\r\n    _testOutputHelper.WriteLine(json);\r\n    var obj = System.Text.Json.JsonSerializer.Deserialize<ArraySegment<int>>(json);\r\n    Assert.Equal(3, obj.Count);\r\n}\r\n```\r\n\r\n### Expected behavior\r\n\r\nThe `System.Text.Json.JsonSerializer` should be able to successfully deserialize an `ArraySegment<int>` object that was serialized using the same or other serializer, without any errors or data loss.\r\n\r\n### Actual behavior\r\n\r\nWhen attempting to deserialize an `ArraySegment<int>` object using `System.Text.Json.JsonSerializer`, a `NotSupportedException` is thrown, indicating that deserialization is not supported for this type, despite it being serialized with the same serializer.\r\n\r\n### Regression?\r\n\r\n_No response_\r\n\r\n### Known Workarounds\r\n\r\nAs a workaround, you can use `Newtonsoft.Json.JsonConvert` for both serialization and deserialization of `ArraySegment<int>`. `JsonConvert` handles this type without throwing exceptions, providing a seamless serialization/deserialization process.\r\n\r\n### Configuration\r\n\r\n### Other information\r\n\r\n_No response_",
    "number": 107783,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-09-13T08:41:30Z",
          "user": "mnowacki"
        }
      ],
      "totalCount": 1,
      "endCursor": "Y3Vyc29yOnYyOpHOC6_kFA=="
    },
    "updatedAt": "2024-09-13T14:16:20Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": "dotnet-policy-service",
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. -->",
          "createdAt": "2024-09-13T08:33:00Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-09-13T08:33:00Z",
          "id": "IC_kwDODI9FZc6L-ScX"
        },
        {
          "author": "huoyaoyuan",
          "body": "It wasn't supported for deserialization. The criteria for serializing and deserializing are different. Serializing requires read access only while deserializing requires way to construct the type.\r\nFor `ArraySegment<T>`, it's serializable because it implements `IList<T>`, but it isn't deserializable because it doesn't implement the common shape for constructable collections. It's not supported by other features like collection expressions in C# either.\r\nMake it deserializable is a feature request that requires explicit recognition of this type.",
          "createdAt": "2024-09-13T08:42:34Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-09-13T08:42:34Z",
          "id": "IC_kwDODI9FZc6L-XIG"
        },
        {
          "author": "eiriktsarpalis",
          "body": "The type doesn't implement one of the standard construction patterns (default constructor with `Add` method, constructor accepting `IEnumerable<T>` or `CollectionBuilderAttribute` annotation). There's a proposal that we add `CollectionBuilderAttribute` support to STJ tracked by https://github.com/dotnet/runtime/issues/82642, at which point adding `CollectionBuilderAttribute` to ArraySegment<T>` would automatically give support to the type.",
          "createdAt": "2024-09-13T10:44:14Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-09-13T10:44:14Z",
          "id": "IC_kwDODI9FZc6L_VAn"
        }
      ],
      "totalCount": 3,
      "endCursor": "Y3Vyc29yOnYyOpHOi_1QJw=="
    },
    "url": "https://github.com/dotnet/runtime/issues/107783",
    "title": "Unable to deserialize ArraySegment<int> with System.Text.Json.JsonSerializer.Deserialize"
  },
  {
    "author": "eiriktsarpalis",
    "labels": [
      "enhancement",
      "area-System.Text.Json"
    ],
    "createdAt": "2024-09-13T11:43:10Z",
    "body": "STJ will today happily serialize any collection type that implements `IEnumerable<T>`, however things are less than ideal when it comes to deserialization support. While the serializer does include [baked-in support for a number of common collection types](https://learn.microsoft.com/en-us/dotnet/standard/serialization/system-text-json/supported-collection-types), we still have a number of unsupported types such as [frozen collections](https://github.com/dotnet/runtime/issues/82642), [`ArraySegment<T>`](https://github.com/dotnet/runtime/issues/107783) or [`IReadOnlySet<T>`](https://github.com/dotnet/runtime/issues/91875). Things become even more difficult when working with user-defined types: unless the type implements the conventions used by [collection initializers](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/object-and-collection-initializers#collection-initializers) users need to write their own custom converters.\r\n\r\nThis issue proposes that we extend generic support for collection type deserialization by detecting the following patterns (in order of preference):\r\n\r\n1. Collection is mutable adhering to the conventions [required by collection initializers](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/object-and-collection-initializers#collection-initializers) or,\r\n2. Collection declares a span factory via `CollectionBuilderAttribute` or,\r\n3. Collection exposes a public constructor accepting a single `IEnumerable<T>` parameter (where the `T` must match the `T` of the implemented `IEnumerable<T>`).\r\n\r\nI have [prototyped an implementation of this approach](https://eiriktsarpalis.github.io/typeshape-csharp/core-abstractions.html#constructing-collections) both for reflection and source gen in the [typeshape-csharp project](https://eiriktsarpalis.github.io/typeshape-csharp). This should add OOTB support for multiple built-in types that aren't supported today, or should make it relatively straightforward to make changes to collections such that they are supported (e.g. by adding `CollectinBuilderAttribute` annotations). For popular types not conforming to any of these patterns, we should consider adding baked-in converters to support them.\r\n\r\n## Related Issues\r\n\r\n- [ ] https://github.com/dotnet/runtime/issues/80688\r\n- [ ] https://github.com/dotnet/runtime/issues/82642\r\n- [ ] https://github.com/dotnet/runtime/issues/107783\r\n- [ ] https://github.com/dotnet/runtime/issues/91875\r\n\r\ncc @stephentoub @CyrusNajmabadi ",
    "number": 107787,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-09-13T14:17:52Z",
          "user": "julealgon"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-09-13T18:13:50Z",
          "user": "martincostello"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-09-14T18:35:30Z",
          "user": "NN---"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-09-14T23:29:03Z",
          "user": "elgonzo"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-09-15T02:44:47Z",
          "user": "WeihanLi"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-12-31T18:39:19Z",
          "user": "YoelDruxman"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-01-01T16:16:18Z",
          "user": "tabberbock"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-01-01T16:24:22Z",
          "user": "nrhoffmann"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-01-01T16:59:03Z",
          "user": "davidmenaged"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-02-01T12:59:31Z",
          "user": "MrAntix"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-05-20T15:02:24Z",
          "user": "HaraldMuehlhoffCC"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-08-01T05:24:17Z",
          "user": "dgioulakis"
        }
      ],
      "totalCount": 12,
      "endCursor": "Y3Vyc29yOnYyOpHODJdlMg=="
    },
    "updatedAt": "2025-07-16T06:53:23Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": "dotnet-policy-service",
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. -->",
          "createdAt": "2024-09-13T11:43:42Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-09-13T11:43:42Z",
          "id": "IC_kwDODI9FZc6L_zWV"
        },
        {
          "author": "CyrusNajmabadi",
          "body": "Hi hi. I see the mention.  How can I help?",
          "createdAt": "2024-09-13T12:39:43Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-09-13T12:39:43Z",
          "id": "IC_kwDODI9FZc6MAMFd"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Was curious to get your thoughts on the proposed use of patterns (and their ordering) when determining a collection construction strategy.",
          "createdAt": "2024-09-13T13:09:34Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-09-13T13:09:34Z",
          "id": "IC_kwDODI9FZc6MAcf2"
        },
        {
          "author": "elgonzo",
          "body": "How about inline arrays?\r\n\r\nI also wonder what would happen if STJ requires a CollectionBuilderAttribute (CBA) for deserialization of inline arrays when (if?) the C# compiler eventually gets built-in support for collection expressions for inline arrays, and i am a bit concerned about that by virtue of STJ requiring CBA for deserializing inline arrays, a very convenient compile-time check of making sure that the collection expression is correctly sized will be again turned into a user-implemented runtime-check (as it is unfortunately currently the case with inline arrays) because the compiler will have to respect the CBA that is only there to satisfy STJ.\r\n\r\n",
          "createdAt": "2024-09-13T16:12:26Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-09-13T16:12:26Z",
          "id": "IC_kwDODI9FZc6MB5zc"
        },
        {
          "author": "silkfire",
          "body": "Does this include the deserialization of `ReadOnlyCollection<T>` too?\n\n![Image](https://github.com/user-attachments/assets/421802b3-ff94-4327-937e-21fb1309d555)\n",
          "createdAt": "2024-11-18T18:52:18Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-11-18T18:52:18Z",
          "id": "IC_kwDODI9FZc6UDKYu"
        }
      ],
      "totalCount": 5,
      "endCursor": "Y3Vyc29yOnYyOpHOlAymLg=="
    },
    "url": "https://github.com/dotnet/runtime/issues/107787",
    "title": "System.Text.Json should support deserializing more collection types"
  },
  {
    "author": "Dreamescaper",
    "labels": [
      "api-suggestion",
      "area-System.Text.Json"
    ],
    "createdAt": "2024-09-16T11:30:17Z",
    "body": "### Background and motivation\r\n\r\nJsonSerializer requires async execution for some types, like IAsyncEnumerable. I would be nice to have a method SerializeAsync, which returns serialized string instead of writing to stream.\r\n\r\n### API Proposal\r\nAdd the following methods:\r\n\r\n```csharp\r\npublic static Task<string> SerializeAsync<TValue>(TValue value, JsonSerializerOptions? options = null);\r\npublic static Task<string> SerializeAsync<TValue>(TValue value, JsonTypeInfo<TValue> jsonTypeInfo);\r\npublic static Task<string> SerializeAsync(object? value, Type inputType, JsonSerializerContext context);\r\npublic static Task<string> SerializeAsync(object? value, Type inputType, JsonSerializerOptions? options = null);\r\npublic static Task<string> SerializeAsync(object? value, JsonTypeInfo jsonTypeInfo);\r\npublic static Task<byte[]> SerializeToUtf8BytesAsync<TValue>(TValue value, JsonTypeInfo<TValue> jsonTypeInfo);\r\npublic static Task<byte[]> SerializeToUtf8BytesAsync<TValue>(TValue value, JsonSerializerOptions? options = null);\r\npublic static Task<byte[]> SerializeToUtf8BytesAsync(object? value, Type inputType, JsonSerializerContext context);\r\npublic static Task<byte[]> SerializeToUtf8BytesAsync(object? value, Type inputType, JsonSerializerOptions? options = null);\r\npublic static Task<byte[]> SerializeToUtf8BytesAsync(object? value, JsonTypeInfo jsonTypeInfo);\r\npublic static Task<JsonNode?> SerializeToNodeAsync<TValue>(TValue value, JsonTypeInfo<TValue> jsonTypeInfo);\r\npublic static Task<JsonNode?> SerializeToNodeAsync<TValue>(TValue value, JsonSerializerOptions? options = null);\r\npublic static Task<JsonNode?> SerializeToNodeAsync(object? value, Type inputType, JsonSerializerContext context);\r\npublic static Task<JsonNode?> SerializeToNodeAsync(object? value, Type inputType, JsonSerializerOptions? options = null);\r\npublic static Task<JsonNode?> SerializeToNodeAsync(object? value, JsonTypeInfo jsonTypeInfo);\r\npublic static Task<JsonElement> SerializeToElementAsync<TValue>(TValue value, JsonTypeInfo<TValue> jsonTypeInfo);\r\npublic static Task<JsonElement> SerializeToElementAsync<TValue>(TValue value, JsonSerializerOptions? options = null);\r\npublic static Task<JsonElement> SerializeToElementAsync(object? value, Type inputType, JsonSerializerContext context);\r\npublic static Task<JsonElement> SerializeToElementAsync(object? value, Type inputType, JsonSerializerOptions? options = null);\r\npublic static Task<JsonElement> SerializeToElementAsync(object? value, JsonTypeInfo jsonTypeInfo);\r\npublic static Task<JsonDocument> SerializeToDocumentAsync<TValue>(TValue value, JsonTypeInfo<TValue> jsonTypeInfo);\r\npublic static Task<JsonDocument> SerializeToDocumentAsync<TValue>(TValue value, JsonSerializerOptions? options = null);\r\npublic static Task<JsonDocument> SerializeToDocumentAsync(object? value, Type inputType, JsonSerializerContext context);\r\npublic static Task<JsonDocument> SerializeToDocumentAsync(object? value, Type inputType, JsonSerializerOptions? options = null);\r\npublic static Task<JsonDocument> SerializeToDocumentAsync(object? value, JsonTypeInfo jsonTypeInfo);\r\n```\r\n\r\n\r\n### API Usage\r\n\r\n```csharp\r\nIAsyncEnumerable<MyType> asyncEnumerable = GetAsyncEnumerable();\r\nvar json = await JsonSerializer.SerializeAsync(asyncEnumerable);\r\n```\r\n\r\n\r\n### Alternative Designs\r\n\r\n_No response_\r\n\r\n### Risks\r\n\r\n_No response_",
    "number": 107860,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-09-16T17:51:09Z",
          "user": "julealgon"
        }
      ],
      "totalCount": 1,
      "endCursor": "Y3Vyc29yOnYyOpHOC7DcGw=="
    },
    "updatedAt": "2024-10-03T21:55:21Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": "dotnet-policy-service",
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. -->",
          "createdAt": "2024-09-16T11:30:39Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-09-16T11:30:39Z",
          "id": "IC_kwDODI9FZc6MOsFL"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Seems reasonable given that async serialization is a prerequisite for IAsyncEnumerable support. For completeness we should also consider accelerators for all the other supported encoding mediums such as `SerializeToNodeAsync`, `SerializeToUtf8Async` and `SerializeToElementAsync`, `SerializeToDocumentAsync`, etc.",
          "createdAt": "2024-09-16T12:21:21Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-09-16T12:21:21Z",
          "id": "IC_kwDODI9FZc6MPFIe"
        },
        {
          "author": "Dreamescaper",
          "body": "@eiriktsarpalis \r\nWould it be fine for me to contribute it?",
          "createdAt": "2024-09-23T10:12:27Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-09-23T10:12:27Z",
          "id": "IC_kwDODI9FZc6NIWoT"
        },
        {
          "author": "eiriktsarpalis",
          "body": "The API proposal needs a bit of work before we can consider it for [API review](https://github.com/dotnet/runtime/blob/main/docs/project/api-review-process.md). Bare minimum it should [scope out all the relevant overloads](https://github.com/dotnet/runtime/issues/107860#issuecomment-2352763422) that need to be included as part of this change. It's not something our team can prioritize right now, but if you want to expedite the process you can try by updating the OP to something that can be easily reviewed. You can take a look at [previously approved proposals](https://github.com/dotnet/runtime/issues?q=is%3Aissue+is%3Aopen+label%3Aapi-approved+) for examples of what this should look like.",
          "createdAt": "2024-09-23T11:07:44Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-09-23T11:07:44Z",
          "id": "IC_kwDODI9FZc6NIz8e"
        },
        {
          "author": "Dreamescaper",
          "body": "@eiriktsarpalis \r\nWould you prefer for me to add  SerializeToNodeAsync, SerializeToUtf8Async and SerializeToElementAsync, SerializeToDocumentAsync, etc. to the proposal? \r\n\r\nOr focus on SerializeAsync, and tackle others separately?",
          "createdAt": "2024-09-23T13:51:14Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-09-23T13:51:14Z",
          "id": "IC_kwDODI9FZc6NKeXE"
        },
        {
          "author": "eiriktsarpalis",
          "body": "I think they should be addressed in tandem. They logically belong to the same set of APIs but they use different names out of disambiguation concerns.",
          "createdAt": "2024-09-23T14:37:13Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-09-23T14:37:13Z",
          "id": "IC_kwDODI9FZc6NLCSD"
        },
        {
          "author": "Dreamescaper",
          "body": "@eiriktsarpalis \r\nI have updated the proposal.\r\nCurrently there are 5 overloads for each of Serialize* methods. I have included Async counterparts for all of them (although I am not sure whether all of them are needed here).",
          "createdAt": "2024-10-03T21:55:20Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-10-07T11:46:48Z",
                "user": "eiriktsarpalis"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOD1FMxw=="
          },
          "updatedAt": "2024-10-03T21:55:20Z",
          "id": "IC_kwDODI9FZc6OmUOe"
        }
      ],
      "totalCount": 7,
      "endCursor": "Y3Vyc29yOnYyOpHOjplDng=="
    },
    "url": "https://github.com/dotnet/runtime/issues/107860",
    "title": "[API Proposal]: Add JsonSerializer.SerializeAsync returning string"
  },
  {
    "author": "DL444",
    "labels": [
      "bug",
      "area-System.Text.Json",
      "source-generator"
    ],
    "createdAt": "2024-09-16T22:52:54Z",
    "body": "### Description\n\nSource generated JSON deserialization fails with `JsonExtensionData` property using `init` accessor:\r\n\r\n```cs\r\nusing System.Text.Json.Serialization;\r\nusing System.Text.Json;\r\n\r\nstring json = \"{\\\"Value\\\":42,\\\"OverflowValue\\\":\\\"42\\\"}\";\r\nDemo demo = JsonSerializer.Deserialize(json, DemoContext.Default.Demo)!;\r\nstring roundtrip = JsonSerializer.Serialize(demo, DemoContext.Default.Demo);\r\nConsole.WriteLine(string.Equals(json, roundtrip, StringComparison.Ordinal));\r\n\r\npublic sealed class Demo\r\n{\r\n    public int Value { get; init; }\r\n\r\n    [JsonExtensionData]\r\n    public Dictionary<string, JsonElement>? ExtensionData { get; init; }\r\n}\r\n\r\n[JsonSourceGenerationOptions(GenerationMode = JsonSourceGenerationMode.Metadata)]\r\n[JsonSerializable(typeof(Demo))]\r\npublic sealed partial class DemoContext : JsonSerializerContext { }\r\n```\n\n### Reproduction Steps\n\n1. Create console application from template with the sample code above\r\n2. Run application\n\n### Expected behavior\n\nApplication completes with no significant problems and prints \"True\".\n\n### Actual behavior\n\nApplication throws exception:\r\n\r\n```\r\nUnhandled exception. System.InvalidOperationException: The extension data property 'ExtensionData' on type 'Demo' cannot bind with a parameter in the deserialization constructor.\r\n   at System.Text.Json.ThrowHelper.ThrowInvalidOperationException_ExtensionDataCannotBindToCtorParam(String propertyName, JsonPropertyInfo jsonPropertyInfo)\r\n   at System.Text.Json.Serialization.Metadata.JsonTypeInfo.ConfigureConstructorParameters()\r\n   at System.Text.Json.Serialization.Metadata.JsonTypeInfo.Configure()\r\n   at System.Text.Json.Serialization.Metadata.JsonTypeInfo.<EnsureConfigured>g__ConfigureSynchronized|172_0()\r\n   at System.Text.Json.JsonSerializerOptions.GetTypeInfoInternal(Type type, Boolean ensureConfigured, Nullable`1 ensureNotNull, Boolean resolveIfMutable, Boolean fallBackToNearestAncestorType)\r\n   at System.Text.Json.JsonSerializerOptions.GetTypeInfo(Type type)\r\n   at DemoContext.get_Demo() in D:\\repos\\SourceGenJsonDemo\\SourceGenJsonDemo\\obj\\Debug\\net8.0\\System.Text.Json.SourceGeneration\\System.Text.Json.SourceGeneration.JsonSourceGenerator\\DemoContext.Demo.g.cs:line 18\r\n   at Program.<Main>$(String[] args) in D:\\repos\\SourceGenJsonDemo\\SourceGenJsonDemo\\Program.cs:line 5\r\n```\n\n### Regression?\n\nProbably not: `init` property deserialization is not supported by System.Text.Json in previous .NET versions.\n\n### Known Workarounds\n\nChange the overflow property to use a public or internal set accessor.\n\n### Configuration\n\n.NET info:\r\n```\r\n.NET SDK:\r\n Version:           9.0.100-rc.1.24452.12\r\n Commit:            81a714c6d3\r\n Workload version:  9.0.100-manifests.67cd1eb6\r\n MSBuild version:   17.12.0-preview-24422-09+d17ec720d\r\n\r\nRuntime Environment:\r\n OS Name:     Windows\r\n OS Version:  10.0.22635\r\n OS Platform: Windows\r\n RID:         win-x64\r\n Base Path:   C:\\Program Files\\dotnet\\sdk\\9.0.100-rc.1.24452.12\\\r\n\r\n.NET workloads installed:\r\nConfigured to use loose manifests when installing new manifests.\r\n [aspire]\r\n   Installation Source: VS 17.11.35303.130, VS 17.12.35309.182\r\n   Manifest Version:    8.2.0/8.0.100\r\n   Manifest Path:       C:\\Program Files\\dotnet\\sdk-manifests\\8.0.100\\microsoft.net.sdk.aspire\\8.2.0\\WorkloadManifest.json\r\n   Install Type:        FileBased\r\n\r\n\r\nHost:\r\n  Version:      9.0.0-rc.1.24431.7\r\n  Architecture: x64\r\n  Commit:       static\r\n\r\n.NET SDKs installed:\r\n  8.0.304 [C:\\Program Files\\dotnet\\sdk]\r\n  8.0.400 [C:\\Program Files\\dotnet\\sdk]\r\n  8.0.401 [C:\\Program Files\\dotnet\\sdk]\r\n  9.0.100-rc.1.24452.12 [C:\\Program Files\\dotnet\\sdk]\r\n\r\n.NET runtimes installed:\r\n  Microsoft.AspNetCore.App 6.0.33 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.AspNetCore.App 8.0.8 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.AspNetCore.App 9.0.0-rc.1.24452.1 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.NETCore.App 6.0.33 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 8.0.8 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 9.0.0-rc.1.24431.7 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.WindowsDesktop.App 6.0.33 [C:\\Program Files\\dotnet\\shared\\Microsoft.WindowsDesktop.App]\r\n  Microsoft.WindowsDesktop.App 8.0.8 [C:\\Program Files\\dotnet\\shared\\Microsoft.WindowsDesktop.App]\r\n  Microsoft.WindowsDesktop.App 9.0.0-rc.1.24452.1 [C:\\Program Files\\dotnet\\shared\\Microsoft.WindowsDesktop.App]\r\n\r\nOther architectures found:\r\n  x86   [C:\\Program Files (x86)\\dotnet]\r\n    registered at [HKLM\\SOFTWARE\\dotnet\\Setup\\InstalledVersions\\x86\\InstallLocation]\r\n\r\nEnvironment variables:\r\n  Not set\r\n\r\nglobal.json file:\r\n  Not found\r\n```\r\n\r\nProject configuration:\r\n```\r\n<Project Sdk=\"Microsoft.NET.Sdk\">\r\n  <PropertyGroup>\r\n    <OutputType>Exe</OutputType>\r\n    <TargetFramework>net8.0</TargetFramework>\r\n    <ImplicitUsings>enable</ImplicitUsings>\r\n    <Nullable>enable</Nullable>\r\n  </PropertyGroup>\r\n  <ItemGroup>\r\n    <PackageReference Include=\"System.Text.Json\" Version=\"8.0.4\" />\r\n  </ItemGroup>\r\n</Project>\r\n```\n\n### Other information\n\n_No response_",
    "number": 107898,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-10-14T21:31:58Z",
          "user": "davidrea-MS"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-11-03T12:01:10Z",
          "user": "rabuckley"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-03-10T19:08:05Z",
          "user": "Zaldos"
        }
      ],
      "totalCount": 3,
      "endCursor": "Y3Vyc29yOnYyOpHOC_6KJw=="
    },
    "updatedAt": "2024-10-16T15:27:19Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": "dotnet-policy-service",
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. -->",
          "createdAt": "2024-09-16T22:53:16Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-09-16T22:53:16Z",
          "id": "IC_kwDODI9FZc6MUb7e"
        },
        {
          "author": "DL444",
          "body": "The problem also reproduces when targeting .NET 9 RC 1 with System.Text.Json 9.0.0-rc.1.24431.7.",
          "createdAt": "2024-09-16T22:56:00Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-10-14T21:32:02Z",
                "user": "davidrea-MS"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOD2Ec4Q=="
          },
          "updatedAt": "2024-09-16T22:56:00Z",
          "id": "IC_kwDODI9FZc6MUcoF"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Supporting JsonExtensionData `init` properties  would require some rework of the extension data implementation, since it currently assumes that it can populate the property lazily. This can be observed if you run the following code using the reflection-based serializer which ignores `init` properties:\r\n\r\n```C#\r\nvar result = JsonSerializer.Deserialize<Demo>(\"{\\\"Value\\\":42}\");\r\nConsole.WriteLine(result.ExtensionData is null); // True\r\n\r\nresult = JsonSerializer.Deserialize<Demo>(\"{\\\"Value\\\":42,\\\"OverflowValue\\\":\\\"42\\\"}\");\r\nConsole.WriteLine(result.ExtensionData is null); // False\r\n```\r\n\r\nThis behaviour is not trivial to replicate in the source generator which cannot ignore `init` semantics. It might be safer if we just decide that this pattern is not supported and emit a better error message. The obvious workaround is making the property settable.",
          "createdAt": "2024-09-17T09:03:51Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-09-17T09:03:51Z",
          "id": "IC_kwDODI9FZc6MXczk"
        },
        {
          "author": "DL444",
          "body": "I was just reading on [UnsafeAccessorAttribute](https://github.com/dotnet/runtime/blob/101a7e961d51f839a3d3e3bcb9f6554976733e82/docs/design/features/unsafeaccessors.md) introduced in .NET 8 and I wonder if it can be used to solve the problem by ignoring the `init` semantics in a reflection-free way. I cobbled up the following code snippet and it seems to be working fine:\n\n```cs\nDemo demo = new();\nSetDemoExtensionData(demo, []);\nConsole.WriteLine(demo.ExtensionData is not null); // Prints \"True\".\n\nstatic void SetDemoExtensionData(Demo demo, Dictionary<string, JsonElement>? value)\n{\n    ref Dictionary<string, JsonElement>? reference = ref GetExtensionDataReference(demo);\n    reference = value;\n\n    [UnsafeAccessor(UnsafeAccessorKind.Field, Name = \"<ExtensionData>k__BackingField\")]\n    extern static ref Dictionary<string, JsonElement>? GetExtensionDataReference(Demo demo);\n}\n\npublic sealed class Demo\n{\n    public int Value { get; init; }\n\n    [JsonExtensionData]\n    public Dictionary<string, JsonElement>? ExtensionData { get; init; }\n}\n```\n\nI imagine the source generator can generate the `SetDemoExtensionData` method in the middle and use it to set `ExtensionData` lazily. Not sure if there are any problems that preclude this solution. Some coming to mind:\n\n- Assembly size can be a risk as the `extern static` method cannot be generic and must be generated per type.\n- Full `init` accessors with custom logic can be a blocker, but I'm not convinced that this is a must-support scenario.\n- `required` overflow property still requires an eager implementation, but required overflow properties sounds questionable.\n- [Generics target type](https://learn.microsoft.com/en-us/dotnet/core/compatibility/core-libraries/9.0/unsafeaccessor-generics) support doesn't come until .NET 9.",
          "createdAt": "2024-10-16T14:44:52Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-10-16T15:24:34Z",
          "id": "IC_kwDODI9FZc6QEU-D"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Unsafe accessors are a useful tool, however System.Text.Json needs to be able to support netstandard2.0 which doesn't have those APIs. We could of course special case newer targets so that they use the feature, however that creates a degree of bifurcation that wouldn't be practical to maintain.",
          "createdAt": "2024-10-16T15:27:17Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-10-16T15:27:56Z",
                "user": "DL444"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOD2ky3g=="
          },
          "updatedAt": "2024-10-16T15:27:17Z",
          "id": "IC_kwDODI9FZc6QEyAq"
        }
      ],
      "totalCount": 5,
      "endCursor": "Y3Vyc29yOnYyOpHOkBMgKg=="
    },
    "url": "https://github.com/dotnet/runtime/issues/107898",
    "title": "Source generated JSON deserialization fails with `JsonExtensionData` property using `init` accessor"
  },
  {
    "author": "ykvelit",
    "labels": [
      "api-suggestion",
      "area-System.Text.Json"
    ],
    "createdAt": "2024-09-17T18:02:02Z",
    "body": "### Background and motivation\n\nThe `JsonSerializer` class exposes deserialization overloads that accept `JsonTypeInfo<T>` and `JsonTypeInfo`. These overloads are generally marked AOT/linker-safe and provide the only entrypoint for serializing using materialized metadata instances. We are however missing non-generic overloads for doing the same thing for `DeserializeAsyncEnumerable`.\r\n\r\nIn my case, firstly we call an Rest API that respond an object schema. Then call another Rest API to get data. In this moment, we receive a response as stream and we use `ExpandoObject` class to deserialize that response. In my study, using a typed deserialization we have an improvement in memory usage compared to the `ExpandoObject`. Considering that the object to be deserialized is dynamic, we are creating a type using the `System.Reflection.Emit.AssemblyBuilder` API using the object schema recovered by first call and try to use `DeserializeAsyncEnumerable`.\r\n\r\nIf we use `DeserializeAsync` we will have to wait for the entire body response complete to interact with data received.\n\n### API Proposal\n\n```csharp\r\nnamespace System.Text.Json;\r\n\r\npublic partial static class JsonSerializer\r\n{\r\n    public static IAsyncEnumerable<object?> DeserializeAsyncEnumerable(Stream utf8Json, JsonTypeInfo jsonTypeInfo, CancellationToken cancellationToken = default);\r\n    public static IAsyncEnumerable<object?> DeserializeAsyncEnumerable(Stream utf8Json, JsonTypeInfo jsonTypeInfo, bool topLevelValues, CancellationToken cancellationToken = default);\r\n    public static IAsyncEnumerable<object?> DeserializeAsyncEnumerable(Stream utf8Json, Type returnType, JsonSerializerOptions? options = default, CancellationToken cancellationToken = default);\r\n    public static IAsyncEnumerable<object?> DeserializeAsyncEnumerable(Stream utf8Json, Type returnType, bool topLevelValues, JsonSerializerOptions? options = default, CancellationToken cancellationToken = default);\r\n}\r\n```\r\n\n\n### API Usage\n\n```csharp\r\n// create any dynamic type using System.Reflection.Emit.AssemblyBuilder\r\nType? returnType = tb.CreateType();\r\n\r\nvar json = \"\"\"\r\n            [\r\n                {\"Number\": 1},\r\n                {\"Number\": 2},\r\n                {\"Number\": 3}\r\n            ]\r\n        \"\"\";\r\n\r\nbyte[] bytes = Encoding.UTF8.GetBytes(json);\r\nvar stream = new MemoryStream(bytes);\r\n\r\nvar result = JsonSerializer.DeserializeAsyncEnumerable(stream, returnType);\r\n\r\nawait foreach (var item in result)\r\n{\r\n    var property = returnType.GetProperty(\"Number\");\r\n    var value = property.GetValue(item, null);\r\n    Console.WriteLine(value); // 1, 2, 3\r\n}\r\n```\r\n\n\n### Alternative Designs\n\n```csharp\r\npublic static IAsyncEnumerable<object> DeserializeAsyncEnumerable(Stream utf8Json, Type returnType, JsonSerializerOptions options = null, CancellationToken cancellationToken = default)\r\n{\r\n    var serializer = typeof(JsonSerializer);\r\n\r\n    var deserializeAsyncEnumerable = serializer\r\n        .GetMethod(\"DeserializeAsyncEnumerable\", BindingFlags.Public | BindingFlags.Static);\r\n\r\n    var typedDeserializeAsyncEnumerable = deserializeAsyncEnumerable.MakeGenericMethod(returnType);\r\n\r\n    var result = typedDeserializeAsyncEnumerable.Invoke(null, new object[] { utf8Json, options, cancellationToken });\r\n\r\n    return result as IAsyncEnumerable<object>;\r\n}\r\n```\n\n### Risks\n\n_No response_",
    "number": 107940,
    "reactions": {
      "hasNextPage": false,
      "nodes": [],
      "totalCount": 0,
      "endCursor": null
    },
    "updatedAt": "2024-09-17T18:38:32Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": "dotnet-policy-service",
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. -->",
          "createdAt": "2024-09-17T18:02:24Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-09-17T18:02:24Z",
          "id": "IC_kwDODI9FZc6Mdn3h"
        },
        {
          "author": "eiriktsarpalis",
          "body": "It sounds like something we could consider, thanks.",
          "createdAt": "2024-09-17T18:38:17Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-09-17T19:33:49Z",
                "user": "ykvelit"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-12-10T11:58:31Z",
                "user": "diogodamiani"
              }
            ],
            "totalCount": 2,
            "endCursor": "Y3Vyc29yOnYyOpHOD-Xnbw=="
          },
          "updatedAt": "2024-09-17T18:38:17Z",
          "id": "IC_kwDODI9FZc6Md3FR"
        }
      ],
      "totalCount": 2,
      "endCursor": "Y3Vyc29yOnYyOpHOjHdxUQ=="
    },
    "url": "https://github.com/dotnet/runtime/issues/107940",
    "title": "[API Proposal]: Add JsonSerializer.DeserializeAsyncEnumerable overloads accepting non-generic JsonTypeInfo and Type"
  },
  {
    "author": "eiriktsarpalis",
    "labels": [
      "enhancement",
      "api-approved",
      "area-System.Text.Json"
    ],
    "createdAt": "2024-09-25T10:55:42Z",
    "body": "## Motivation\r\n\r\nThere's a substantial amount of duplication in the following code:\r\n\r\n```C#\r\nclass MyPoco\r\n{\r\n    [JsonIgnore(JsonIgnoreCondition.WhenWritingNull)]\r\n    public string? PropA { get; set; }\r\n\r\n    [JsonIgnore(JsonIgnoreCondition.WhenWritingNull)]\r\n    public string? PropB { get; set; }\r\n\r\n    [JsonIgnore(JsonIgnoreCondition.WhenWritingNull)]\r\n    public string? PropC { get; set; }\r\n}\r\n```\r\n\r\nthat could be eliminated using a type-level declaration:\r\n\r\n```C#\r\n[JsonIgnore(JsonIgnoreCondition.WhenWritingNull)]\r\nclass MyPoco\r\n{\r\n    public string? PropA { get; set; }\r\n\r\n    public string? PropB { get; set; }\r\n\r\n    public string? PropC { get; set; }\r\n}\r\n```\r\n\r\n## API Proposal\r\n\r\n```diff\r\nnamespace System.Text.Json.Serialization;\r\n\r\n-[AttributeUsage(AttributeTargets.Property | AttributeTargets.Field, AllowMultiple = false)]\r\n+[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Interface | AttributeTargets.AttributeTargets.Property | AttributeTargets.Field, AllowMultiple = false)]\r\npublic partial class JsonIgnoreAttribute;\r\n```\r\n\r\ncc @stephentoub",
    "number": 108231,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-09-25T21:57:04Z",
          "user": "aromaa"
        }
      ],
      "totalCount": 1,
      "endCursor": "Y3Vyc29yOnYyOpHOC7UvVQ=="
    },
    "updatedAt": "2025-01-17T12:10:59Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": "dotnet-policy-service",
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. -->",
          "createdAt": "2024-09-25T10:56:16Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-09-25T10:56:16Z",
          "id": "IC_kwDODI9FZc6NfJiE"
        },
        {
          "author": "terrajobst",
          "body": "[Video](https://www.youtube.com/watch?v=pxItI3kOOJU&t=0h0m0s)\n\n* Looks good as proposed\r\n\r\n```C#\r\nnamespace System.Text.Json.Serialization;\r\n\r\n// Before:\r\n//\r\n// [AttributeUsage(AttributeTargets.Property |\r\n//                 AttributeTargets.Field, AllowMultiple = false)]\r\n//\r\n[AttributeUsage(AttributeTargets.Class |\r\n                AttributeTargets.Struct |\r\n                AttributeTargets.Interface |\r\n                AttributeTargets.Property |\r\n                AttributeTargets.Field, AllowMultiple = false)]\r\npublic partial class JsonIgnoreAttribute;\r\n```",
          "createdAt": "2024-10-01T17:31:42Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-10-01T17:54:49Z",
          "id": "IC_kwDODI9FZc6OQEoj"
        }
      ],
      "totalCount": 2,
      "endCursor": "Y3Vyc29yOnYyOpHOjkBKIw=="
    },
    "url": "https://github.com/dotnet/runtime/issues/108231",
    "title": "It should be possible to specify `JsonIgnoreCondition`'s on the type level"
  },
  {
    "author": "eiriktsarpalis",
    "labels": [
      "api-approved",
      "area-System.Text.Json",
      "partner-impact"
    ],
    "createdAt": "2024-09-25T11:05:23Z",
    "body": "## Motivation\r\n\r\nSystem.Text.Json supports user-defined naming policies for properties/fields which can be specified via the `JsonSerializerOptions.PropertyNamingPolicy`. Today such policies can only be specified globally which removes the ability to apply granular policies on the individual type/property/field level. \r\n\r\n## API Proposal\r\n\r\n```csharp\r\nnamespace System.Text.Json.Serialization;\r\n\r\n[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Interface | AttributeTargets.AttributeTargets.Property | AttributeTargets.Field, AllowMultiple = false)]\r\npublic class JsonNamingPolicyAttribute : JsonAttribute\r\n{\r\n    public JsonNamingPolicy(JsonKnownNamingPolicy namingPolicy);\r\n    protected JsonNamingPolicy(JsonNamingPolicy namingPolicy); // protected ctor for user-defined extensibility\r\n\r\n    public JsonNamingPolicy NamingPolicy { get; }\r\n}\r\n```\r\n\r\n## API Usage\r\n\r\n```C#\r\nJsonSerializerOptions options = new() { PropertyNamingPolicy = JsonNamingPolicy.SnakeCaseLower };\r\nJsonSerializer.Serialize(new MyPoco(), options); // { \"myFirstProperty\" : \"first\", \"my-second-property\": \"second\" }\r\n\r\n[JsonNamingPolicy(JsonKnownNamingPolicy.CamelCase)]\r\npublic class MyPoco\r\n{\r\n    public string MyFirstProperty { get; set; } = \"first\";\r\n\r\n    [JsonNamingPolicy(JsonKnownNamingPolicy.KebabCaseLower)]\r\n    public string MySecondProperty { get; set; } = \"second\";\r\n}\r\n```\r\n\r\ncc @stephentoub",
    "number": 108232,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-09-25T18:39:16Z",
          "user": "martincostello"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-10-16T13:29:25Z",
          "user": "basvanharten"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-10-16T20:01:07Z",
          "user": "cvocvo"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-10-17T01:55:42Z",
          "user": "ms-mayya"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-10-17T06:28:45Z",
          "user": "cplankl"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-10-17T06:38:57Z",
          "user": "John0King"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-10-18T09:07:03Z",
          "user": "WeihanLi"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-10-23T07:42:28Z",
          "user": "NN---"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-10-28T08:42:50Z",
          "user": "andreizhvaleuski"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-11-11T15:02:57Z",
          "user": "pontusdacke"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-01-25T15:16:25Z",
          "user": "airbreather"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-02-21T00:45:51Z",
          "user": "Varorbc"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-02-23T15:14:27Z",
          "user": "avsorokin"
        }
      ],
      "totalCount": 13,
      "endCursor": "Y3Vyc29yOnYyOpHOC_YC5g=="
    },
    "updatedAt": "2025-08-28T06:39:02Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": "dotnet-policy-service",
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. -->",
          "createdAt": "2024-09-25T11:05:54Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-09-25T11:05:54Z",
          "id": "IC_kwDODI9FZc6NfOFF"
        },
        {
          "author": "terrajobst",
          "body": "[Video](https://www.youtube.com/watch?v=pxItI3kOOJU&t=0h23m43s)\n\n* Looks good as proposed\r\n* @eiriktsarpalis should we update `JsonNumberHandlingAttribute` to support  `AttributeTargets.Interface`?\r\n\r\n```C#\r\nnamespace System.Text.Json.Serialization;\r\n\r\n[AttributeUsage(AttributeTargets.Class |\r\n                AttributeTargets.Struct |\r\n                AttributeTargets.Interface |\r\n                AttributeTargets.Property |\r\n                AttributeTargets.Field, AllowMultiple = false)]\r\npublic class JsonNamingPolicyAttribute : JsonAttribute\r\n{\r\n    public JsonNamingPolicy(JsonKnownNamingPolicy namingPolicy);\r\n    protected JsonNamingPolicy(JsonNamingPolicy namingPolicy);\r\n    public JsonNamingPolicy NamingPolicy { get; }\r\n}\r\n```\r\n",
          "createdAt": "2024-10-01T17:39:29Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-10-01T17:54:50Z",
          "id": "IC_kwDODI9FZc6OQH5K"
        },
        {
          "author": "prezaei",
          "body": "FWIW, we really need this :)",
          "createdAt": "2024-11-13T16:28:26Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-11-13T16:28:26Z",
          "id": "IC_kwDODI9FZc6Td_4e"
        },
        {
          "author": "eiriktsarpalis",
          "body": "FYI @jeffhandley @PranavSenthilnathan something to consider for .NET 10.",
          "createdAt": "2024-11-13T16:32:25Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-11-13T16:32:25Z",
          "id": "IC_kwDODI9FZc6TeCzI"
        },
        {
          "author": "gregsdennis",
          "body": "What is the advantage of\n\n```c#\n[JsonNamingPolicy(JsonKnownNamingPolicy.KebabCaseLower)]\npublic string MySecondProperty { get; set; }\n```\n\nover\n\n```c#\n[JsonPropertyName(\"my-second-property\")]\npublic string MySecondProperty { get; set; }\n```\n\n?\n\nThe second seems more explicit, more intentional.",
          "createdAt": "2024-11-13T17:17:39Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-11-13T17:17:39Z",
          "id": "IC_kwDODI9FZc6TejE2"
        },
        {
          "author": "eiriktsarpalis",
          "body": "I personally prefer the explicit approach, ultimately it's a trade-off between writing less boilerplate and having an explicit contract.",
          "createdAt": "2024-11-13T17:29:36Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-11-13T17:29:36Z",
          "id": "IC_kwDODI9FZc6Tep8b"
        },
        {
          "author": "gregsdennis",
          "body": "@prezaei I'm interested in why you think we really need this in light of the current capability I listed above.  What's your use case where listing the policy is better (or more preferred)?\n\n(I find catering to edge cases tends to lead to bloat, and the framework is really not a place to have bloat, IMO.)",
          "createdAt": "2024-11-13T20:22:18Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-11-13T20:22:57Z",
          "id": "IC_kwDODI9FZc6TgROs"
        },
        {
          "author": "stephentoub",
          "body": "If I have a class with 20 members, I'd rather put one attribute on the class then one on each of the 20 properties.\n\nAs Eric says, it's a tradeoff between verbosity and explicitness.",
          "createdAt": "2024-11-13T20:31:21Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-11-13T20:31:21Z",
          "id": "IC_kwDODI9FZc6TgVC1"
        },
        {
          "author": "gregsdennis",
          "body": "@stephentoub I think you make be missing my point about explicitness.  I think using `[JsonPropertyName()]` is more explicit and intentional than applying a policy to an individual property.  My point wasn't about global vs local.",
          "createdAt": "2024-11-14T01:47:16Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-11-14T01:47:16Z",
          "id": "IC_kwDODI9FZc6TiFNf"
        },
        {
          "author": "stephentoub",
          "body": "> @stephentoub I think you make be missing my point about explicitness. I think using [JsonPropertyName()] is more explicit and intentional than applying a policy to an individual property. My point wasn't about global vs local.\n\nIn https://github.com/dotnet/runtime/issues/108232#issuecomment-2474258742, you asked about the advantage of:\n```C#\n[JsonNamingPolicy(JsonKnownNamingPolicy.KebabCaseLower)]\npublic string MySecondProperty { get; set; }\n```\nvs\n```C#\n[JsonPropertyName(\"my-second-property\")]\npublic string MySecondProperty { get; set; }\n```\nThat's not the comparison that's interesting. The comparison that's interesting is:\n```C#\n[JsonNamingPolicy(JsonKnownNamingPolicy.KebabCaseLower)]\nclass MyClass\n{\n    public string MyPropA { get; set; }\n    public string MyPropB { get; set; }\n    public string MyPropC { get; set; }\n    public string MyPropD { get; set; }\n    public string MyPropE { get; set; }\n    public string MyPropF { get; set; }\n    public string MyPropG { get; set; }\n    public string MyPropH { get; set; }\n}\n```\nvs\n```C#\nclass MyClass\n{\n    [JsonPropertyName(\"my-prop-a\")]\n    public string MyPropA { get; set; }\n\n    [JsonPropertyName(\"my-prop-b\")]\n    public string MyPropB { get; set; }\n\n    [JsonPropertyName(\"my-prop-c\")]\n    public string MyPropC { get; set; }\n\n    [JsonPropertyName(\"my-prop-d\")]\n    public string MyPropD { get; set; }\n\n    [JsonPropertyName(\"my-prop-e\")]\n    public string MyPropE { get; set; }\n\n    [JsonPropertyName(\"my-prop-f\")]\n    public string MyPropF { get; set; }\n\n    [JsonPropertyName(\"my-prop-g\")]\n    public string MyPropG { get; set; }\n\n    [JsonPropertyName(\"my-prop-h\")]\n    public string MyPropH { get; set; }\n}\n```\nAnd there there's an obvious advantage of the former, that of brevity, maintenance, etc.\n\nThat advantage is then weighed against the slightly more explicit nature of JsonPropertyName. I say slightly because both are explicit; it's just a question of whether a constant is provided or whether a constant is provided with a formula over it, e.g. \"6\" vs \"x == 3 and the formula is 2 * x\". JsonPropertyName is arguably a bit more explicit, which you see as an advantage.\n\nHence, \"it's a tradeoff between verbosity and explicitness\".\n\nI don't believe I'm missing the point.",
          "createdAt": "2024-11-14T02:09:45Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-12-16T16:26:25Z",
                "user": "johncrim"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOD_MFdw=="
          },
          "updatedAt": "2024-11-14T02:39:42Z",
          "id": "IC_kwDODI9FZc6TiM5f"
        },
        {
          "author": "prezaei",
          "body": "To give you an example, we just had a service outage because someone incorrectly translated the property names when combining a set of classes with different property naming schemes into a single serialization context. (They were before separate contexts). They did not realize that they had to manually add JsonPropertyName on hundreds of property names that were affected by this. Happy to share the PR. ",
          "createdAt": "2024-11-14T03:50:51Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-11-14T08:04:06Z",
                "user": "gregsdennis"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOD61ckw=="
          },
          "updatedAt": "2024-11-14T03:50:51Z",
          "id": "IC_kwDODI9FZc6TivJU"
        },
        {
          "author": "eiriktsarpalis",
          "body": "> Happy to share the PR.\n\nFeel free to create an implementation PR following the [approved API shape](https://github.com/dotnet/runtime/issues/108232#issuecomment-2386591306).",
          "createdAt": "2024-11-14T07:44:06Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-11-14T07:44:06Z",
          "id": "IC_kwDODI9FZc6Tjyit"
        },
        {
          "author": "gregsdennis",
          "body": "@stephentoub I still don't think you've got it.\n\nThe example you posted of comparing a single policy attribute at the class level with multiple property name attributes can be done today, without this proposal.\n\nThis proposal is being able to apply the policy at the property level.  The appropriate comparison is having a global policy applied to the class and then overriding a single property with a different policy.\n\n```c#\n[JsonNamingPolicy(JsonKnownNamingPolicy.KebabCaseLower)]\nclass MyClass\n{\n    public string MyPropA { get; set; }\n    public string MyPropB { get; set; }\n    [JsonNamingPolicy(JsonKnownNamingPolicy.CamelCase)]  // this is the proposal\n    public string MyPropC { get; set; }\n    public string MyPropD { get; set; }\n    public string MyPropE { get; set; }\n    public string MyPropF { get; set; }\n    public string MyPropG { get; set; }\n    public string MyPropH { get; set; }\n}\n```\n\nvs\n\n```\n[JsonNamingPolicy(JsonKnownNamingPolicy.KebabCaseLower)]\nclass MyClass\n{\n    public string MyPropA { get; set; }\n    public string MyPropB { get; set; }\n    [JsonPropertyName(\"myPropC\")]  // this can be done already\n    public string MyPropC { get; set; }\n    public string MyPropD { get; set; }\n    public string MyPropE { get; set; }\n    public string MyPropF { get; set; }\n    public string MyPropG { get; set; }\n    public string MyPropH { get; set; }\n}\n```\n\nThese would produce the same outcome.  Specifically, I'm questioning the value of this from the original post:\n\n> removes the ability to apply granular policies on the individual type/property/field level\n\nHaving typed out the example above, I do see that this is a coder preference scenario; that it gives the coder a choice in how they want to represent the override.  But my question still stands: what is the advantage of specifying a policy at the property level over specifying the json property name with a constant?  If the only advantage is that it gives the coder a choice, that's fine, I'd have my answer.\n\nThis is why I asked about @prezaei's use case.  (Yes, I would like to see the PR if it's publicly available.)  I don't understand how having this functionality would have solved or prevented a problem when a solution already exists, just in a (very slightly) different form.",
          "createdAt": "2024-11-14T08:30:49Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-11-14T08:30:49Z",
          "id": "IC_kwDODI9FZc6TkGRW"
        },
        {
          "author": "eiriktsarpalis",
          "body": "> The example you posted of comparing a single policy attribute at the class level with multiple property name attributes can be done today, without this proposal.\n\nHow? `JsonNamingPolicyAttribute` isn't a type that exists today.",
          "createdAt": "2024-11-14T08:37:05Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-11-14T09:05:11Z",
                "user": "gregsdennis"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOD61_gA=="
          },
          "updatedAt": "2024-11-14T08:37:05Z",
          "id": "IC_kwDODI9FZc6TkJE0"
        },
        {
          "author": "gregsdennis",
          "body": "And thus my misunderstanding has been revealed. I thought the attribute existed but was only available at the type level, and that the proposal was to also allow it at the property level.\n\nMy bad. Please disregard my comments.",
          "createdAt": "2024-11-14T09:05:08Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-11-14T11:02:10Z",
                "user": "stephentoub"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOD63I0Q=="
          },
          "updatedAt": "2024-11-14T09:06:28Z",
          "id": "IC_kwDODI9FZc6TkXM0"
        },
        {
          "author": "dannyd89",
          "body": "Is this one up for grabs? If yes I could try to give it a go",
          "createdAt": "2025-06-26T14:31:16Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-06-26T14:31:16Z",
          "id": "IC_kwDODI9FZc6zVTzL"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Go for it",
          "createdAt": "2025-06-26T14:42:12Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-06-26T14:42:12Z",
          "id": "IC_kwDODI9FZc6zVcpc"
        },
        {
          "author": "John0King",
          "body": "what happend on that pr  eg. #117079  ?",
          "createdAt": "2025-08-28T04:49:31Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-08-28T04:49:31Z",
          "id": "IC_kwDODI9FZc7AonOl"
        },
        {
          "author": "dannyd89",
          "body": "> what happend on that pr  eg. #117079  ?\n\nI'm sorry, I changed jobs and am currently a bit more occupied, will try to continue it when I have some time to spare",
          "createdAt": "2025-08-28T06:39:02Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-08-28T06:39:02Z",
          "id": "IC_kwDODI9FZc7ApqAt"
        }
      ],
      "totalCount": 19,
      "endCursor": "Y3Vyc29yOnYyOpHOwKagLQ=="
    },
    "url": "https://github.com/dotnet/runtime/issues/108232",
    "title": "STJ should allow setting naming policies on the member level."
  },
  {
    "author": "alrz",
    "labels": [
      "area-System.Text.Json"
    ],
    "createdAt": "2024-09-27T10:31:41Z",
    "body": "Currently, you cannot stack Roslyn source generators to operate on generated code. As a workaround I opted into running my own generators in a separate project. That is,  `[JsonSerializable(...)] class MyContext : JsonSerializerContext` is generated elsewhere, however this requires the STJ generator to recognize external context classes.\r\n\r\nProject1:\r\n```cs\r\n// use a custom generator to generate the context, \r\n// note this is only a \"blueprint\" since STJ generator is not yet run.\r\n\r\n// <auto-genreated/>\r\n[JsonSerializable(...)] \r\n[JsonSerializable(...)] \r\npublic class GeneratedContext /* : JsonSerializerContex; */\r\n```\r\n\r\n\r\nProject2 references Project1:\r\n```cs\r\n// STJ generator won't recognize GeneratedContext in scope\r\n// but perhaps we can use something like this to hint on that:\r\n\r\n[JsonSerializerExternalContext(typeof(GeneratedContext))] // use as attribute source\r\npartial class MyContext : JsonSerializerContex;\r\n```\r\nThis way we can stack generators using separate projects but the workaround only works if the final generator can work with external types.\r\n\r\n(PS: this is not a problem specific to STJ though, every time you want to stack generators this can be a blocker, so maybe a more generic solution can be implemented instead)\r\n\r\n",
    "number": 108317,
    "reactions": {
      "hasNextPage": false,
      "nodes": [],
      "totalCount": 0,
      "endCursor": null
    },
    "updatedAt": "2025-04-09T18:18:01Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": "dotnet-policy-service",
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. -->",
          "createdAt": "2024-09-27T10:32:16Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-09-27T10:32:16Z",
          "id": "IC_kwDODI9FZc6NzCoj"
        },
        {
          "author": "elgonzo",
          "body": "Have you already tried using [`JsonTypeInfoResolver.Combine`](https://learn.microsoft.com/en-us/dotnet/api/system.text.json.serialization.metadata.jsontypeinforesolver.combine) to combine the `MyContext.Default` and `GeneratedContext.Default` resolvers?",
          "createdAt": "2024-09-27T11:49:46Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-09-27T11:49:46Z",
          "id": "IC_kwDODI9FZc6NzhTB"
        },
        {
          "author": "alrz",
          "body": "> GeneratedContext.Default\n\nThat doesn't exist, note when you generate the context, STJ generator won't see it. I did elaborate why this is the case in OP.",
          "createdAt": "2024-09-27T12:25:38Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-09-27T12:26:08Z",
          "id": "IC_kwDODI9FZc6NzwQS"
        },
        {
          "author": "eiriktsarpalis",
          "body": "It's something we had considered, but it didn't quite seem to justify the added complexity. What motivates this use case? Size concerns? Design time performance?",
          "createdAt": "2024-09-27T13:30:32Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-09-27T13:30:32Z",
          "id": "IC_kwDODI9FZc6N0SAg"
        },
        {
          "author": "alrz",
          "body": ">What motivates this use case?\r\n\r\nIt's a workaround for stacking generators that roslyn doesn't support. The scenario is being able to generate the context itself.\r\n\r\n>It's something we had considered, but it didn't quite seem to justify the added complexity\r\n\r\nSince something like `JsonSerializerExternalContext` (or maybe [MetadataTypeAttribute](https://learn.microsoft.com/en-us/dotnet/api/system.componentmodel.dataannotations.metadatatypeattribute?view=net-8.0) since the usage is similar) is a direct hint for the generator to know where to look at, I don't think it's necessarily adds too much complexity or perf penalty for this to be considered? \r\n\r\n\r\n",
          "createdAt": "2024-09-27T14:20:03Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-09-27T14:21:35Z",
          "id": "IC_kwDODI9FZc6N0re_"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Oh I see, the context on the first project is generated by a custom generator which you want to take into account in the second project. It seems like a niche scenario if I'm honest, it's very unlikely we would be able to prioritize it in the near future.",
          "createdAt": "2024-09-27T14:25:09Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-09-27T14:25:09Z",
          "id": "IC_kwDODI9FZc6N0uCT"
        },
        {
          "author": "alrz",
          "body": "@eiriktsarpalis If the API is acceptable I can take a stab at it.\r\n\r\nThe following is roughly the only change needed to cover this:\r\n```cs\r\nprivate void ParseJsonSerializerContextAttributes(\r\n        INamedTypeSymbol contextClassSymbol,\r\n        out List<TypeToGenerate>? rootSerializableTypes,\r\n        out SourceGenerationOptionsSpec? options)\r\n{\r\n    Debug.Assert(_knownSymbols.JsonSerializableAttributeType != null);\r\n    Debug.Assert(_knownSymbols.JsonSourceGenerationOptionsAttributeType != null);\r\n\r\n    rootSerializableTypes = null;\r\n    options = null;\r\n\r\n    foreach (AttributeData attributeData in contextClassSymbol.GetAttributes())\r\n    {\r\n        INamedTypeSymbol? attributeClass = attributeData.AttributeClass;\r\n\r\n        if (SymbolEqualityComparer.Default.Equals(attributeClass, _knownSymbols.JsonSerializableAttributeType))\r\n        {\r\n            /* ... */\r\n        }\r\n        else if (SymbolEqualityComparer.Default.Equals(attributeClass, _knownSymbols.JsonSourceGenerationOptionsAttributeType))\r\n        {\r\n             /* ... */\r\n        }\r\n+       else if (SymbolEqualityComparer.Default.Equals(attributeClass, _knownSymbols.MetadataTypeAttributeType))\r\n+       {\r\n+           var typeSymbol = (INamedTypeSymbol?)attributeData.ConstructorArguments[0].Value;\r\n+           ParseJsonSerializerContextAttributes(typeSymbol, out var externalTypes, out var externalOptions);\r\n+           if (externalTypes is not null) \r\n+               rootSerializableTypes.AddRange(externalTypes);\r\n+           if (externalOptions is not null) \r\n+               options = externalOptions;\r\n+       }\r\n    }\r\n}\r\n```",
          "createdAt": "2024-09-27T14:51:44Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-09-27T14:53:35Z",
          "id": "IC_kwDODI9FZc6N07aN"
        },
        {
          "author": "eiriktsarpalis",
          "body": "It's not that simple. You need to API propose a new attribute for including contexts. There's also design challenges. What happens if you specify two contexts and they have conflicting contracts for a given type? What happens if you have a `][sonSerializable(typeof(Foo))]` in the last context and the transitive closure of either of the earlier contexts also includes a conflicting definition for `Foo`? This is not an easy problem.",
          "createdAt": "2024-09-27T15:15:47Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-09-27T15:16:09Z",
          "id": "IC_kwDODI9FZc6N1KSf"
        },
        {
          "author": "alrz",
          "body": "> conflicting definition \r\n\r\nIsn't all that already possible to happen? We're just adding another source for attributes (the \"metadata class\"), the semantics of the sum of the applied attributes remain intact. \r\n\r\nThis definitely needs a design review pass but in any case I could start a prototype for that to happen at some point. For one, I'd like this attribute to be sufficient for the generator to find the type so there's practically two entries, JsonSerializableAttribute and MetadataTypeAttribute (or similar).",
          "createdAt": "2024-09-27T15:24:11Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-10-08T18:28:14Z",
          "id": "IC_kwDODI9FZc6N1OPA"
        },
        {
          "author": "sderunov",
          "body": "We are facing the same problem.\n\nWe have an `ApiClient` that contains a large number of subcategories of Api to external services, like this:\n\n```\nclass ServiceApiClient\n\tProjectCategoryApi\n\tDocumentCategoryApi\n\tFolderCategoryApi\n\tReportCategoryApi\n\t// ... etc\n```\n\nEach category contains dozens of methods that call an external Api. Example:\n\n```\nclass ProjectCategoryApi\n\tTask<ProjectDto> CreateProject(ProjectCreateRequest request)\n\tTask<ProjectDto> UpdateProject(ProjectUpdateRequest request)\n\tTask RemoveProject(string projectId)\n\tTask<ProjectDto> GetProject(string projectId)\n\tTask<ListPaged<ProjectDto>> GetProjectList(ProjectListQuery request)\n\t\nclass DocumentCategoryApi\n\tTask<DocumentDto> CreateProject(DocumentCreateRequest request)\n\tTask<DocumentDto> UpdateProject(DocumentUpdateRequest request)\n\tTask RemoveProject(string documentId)\n\tTask<DocumentDto> GetProject(string documentId)\n\tTask<ListPaged<DocumentDto>> GetDocumentList(DocumentListQuery request)\n\n// ... etc\n```\n\nWe don't want to hand-code context for each model, so we created a `ApiClientSourceGenerator` that automatically generates a `ApiClientJsonSerializerContext`\n\n```\n\t\n// project\n[JsonSerializable(typeof(ProjectDto))]\n[JsonSerializable(typeof(ProjectCreateRequest))]\n[JsonSerializable(typeof(ProjectUpdateRequest))]\n[JsonSerializable(typeof(ListPaged<ProjectDto>))]\n\n// document\n[JsonSerializable(typeof(DocumentDto))]\n[JsonSerializable(typeof(DocumentCreateRequest))]\n[JsonSerializable(typeof(DocumentUpdateRequest))]\n[JsonSerializable(typeof(ListPaged<DocumentDto>))]\n\n// ... etc\n\n[JsonSourceGenerationOptions(GenerationMode = JsonSourceGenerationMode.Default)]\n[JsonSerializable(typeof(object))] // placeholder\npublic partial class ApiClientJsonSerializerContext : JsonSerializerContext;\n```\n\n\nBut the STJ generator does not see types we have generated and does not generate the code we need\nAnd we can't make the STJ generator work after our generator.\n",
          "createdAt": "2025-03-17T12:20:06Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-03-17T12:32:57Z",
          "id": "IC_kwDODI9FZc6irZPs"
        },
        {
          "author": "dferretti",
          "body": "Same issue here - any source generator that generates any sort of DTO might want those types to have source generated serializer contexts.\n\nThe general problem is like OP says, source generators (like STJ) cannot reference outputs of other source generators.\n\nI have not dug too deep in the STJ generator yet and probably _way_ oversimplifying, but would it be possible for STJ to expose its serializer context generation as a library method? Then my source generator could generate the same context classes that STJ would have generated, by referencing STJ as a source generator / compile time dependency.",
          "createdAt": "2025-03-28T20:14:40Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-03-28T20:46:58Z",
          "id": "IC_kwDODI9FZc6kpi65"
        },
        {
          "author": "gregsdennis",
          "body": "> It seems like a niche scenario if I'm honest, it's very unlikely we would be able to prioritize it in the near future. - @eiriktsarpalis \n\nI don't think this is a niche scenario.  As mentioned above, a very common scenario is API client generation, e.g. from an OpenAPI description.  Perhaps more niche is my intent to eventually support generating API (server) code from OpenAPI.",
          "createdAt": "2025-03-29T04:10:20Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-03-29T04:10:20Z",
          "id": "IC_kwDODI9FZc6ksUPa"
        },
        {
          "author": "eiriktsarpalis",
          "body": "> I don't think this is a niche scenario. As mentioned above, a very common scenario is API client generation, e.g. from an OpenAPI description. Perhaps more niche is my intent to eventually support generating API (server) code from OpenAPI.\n\nCould you share more details? What motivates the use of stacking contexts in that scenario over just doing an E2E generation at the application layer? If the concern is application size I believe the linker will do a good job at trimming away contexts generated at the library layer that are not being used.\n\nWe generally recommend doing E2E contract generation at the application layer using the final type graphs. In practice stacking contexts (e.g. as is currently already achievable using `TypeInfoResolverChain`) creates more problems than it solves, especially when generic types come into play.",
          "createdAt": "2025-03-29T11:38:01Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-03-29T11:38:01Z",
          "id": "IC_kwDODI9FZc6ktMmw"
        },
        {
          "author": "gregsdennis",
          "body": "Consider a nuget package that generates API client code.  It provides an attribute that you put on a partial class. \n\n```c#\n[ApiClient(\"https://someserver.com/api/openapi.yml\")]\npublic partial class SomeApiClient;\n```\n\nThis generates all the methods and models needed to interact with the API.\n\nAs the developer of the nuget package, it makes sense to want to add those models to a serializer context. As the consumer of the package, this is a very nice feature.",
          "createdAt": "2025-03-29T18:52:16Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-03-29T18:52:48Z",
          "id": "IC_kwDODI9FZc6kwH-w"
        }
      ],
      "totalCount": 14,
      "endCursor": "Y3Vyc29yOnYyOpHOpMB_sA=="
    },
    "url": "https://github.com/dotnet/runtime/issues/108317",
    "title": "STJ generator with external (generated) context class"
  },
  {
    "author": "mwadams",
    "labels": [
      "api-suggestion",
      "area-System.Text.Json"
    ],
    "createdAt": "2024-10-05T14:45:37Z",
    "body": "### Background and motivation\r\n\r\n`JsonMarshal` has recently been added with APIs to get a raw UTF8 `JsonElement` value, and a raw UTF8 `JsonProperty` name.\r\n\r\n_In the rest of this section, to avoid repetition, I will use the word 'value' to mean either 'raw UTF8 value' or 'raw UTF8 property name', depending on context._\r\n\r\nBuilding on this, in low allocation \"raw value\" processing, the three most common follow-up requirements (in order of usefulness) are:\r\n\r\n1. Unescape the value if it contains any escape sequences into a stack-allocated or rented UTF8 `byte` buffer, before further processing. In the event that unescaping is not required, we would like to avoid the copy to the buffer.\r\n2. Unescape the value if it contains any escape sequences, and transcode into a stack-allocated or rented `char` buffer before further processing.\r\n3. Transcode the escaped value into a stack-allocated or rented `char` buffer before further processing.\r\n\r\nInternally, `JsonReaderHelper` provides these capabilities to e.g. `Utf8JsonReader` but the libraries do not currently expose such functionality.\r\n\r\n*Considerations for the consumer*\r\n\r\nTo unescape (and/or transcode) we need to know:\r\n\r\n1. Is the value escaped?\r\n2. How big a buffer is required for the unescaped/transcoded value?\r\n\r\nConsumers will typically:\r\n\r\n1. Get the information you require to perform the unescape and/or transcode operation\r\n2. Decide whether you still want/need to perform the operation on that basis.\r\n\r\n### API Proposal\r\n\r\n```csharp\r\nnamespace System.Text.Json;\r\n\r\npublic readonly struct JsonElement\r\n{\r\n\r\n        /// <summary>\r\n        ///    Indicates whether the value is escaped.\r\n        /// </summary>\r\n        /// <exception cref=\"ObjectDisposedException\">\r\n        ///   The parent <see cref=\"JsonDocument\"/> has been disposed.\r\n        /// </exception>\r\n        /// <seealso cref=\"CopyString(Span{byte})\"/>\r\n        /// <seealso cref=\"CopyString(Span{char})\"/>\r\n        /// <seealso cref=\"CopyRawString(Span{byte})\"/>\r\n        /// <seealso cref=\"CopyRawString(Span{char})\"/>\r\n        public bool ValueIsEscaped { get; }\r\n\r\n        /// <summary>\r\n        ///   Copies the unescaped string value to the UTF8 string buffer.\r\n        /// </summary>\r\n        /// <param name=\"utf8Destination\">The buffer into which to copy the string.</param>\r\n        /// <returns>The number of bytes written to the output buffer, or 0 if the buffer was too small.</returns>\r\n        /// <exception cref=\"InvalidOperationException\">\r\n        ///   This value's <see cref=\"ValueKind\"/> is not <see cref=\"JsonValueKind.String\"/>.\r\n        /// </exception>\r\n        /// <exception cref=\"ObjectDisposedException\">\r\n        ///   The parent <see cref=\"JsonDocument\"/> has been disposed.\r\n        /// </exception>\r\n        public int CopyString(Span<byte> utf8Destination);\r\n        \r\n        /// <summary>\r\n        ///   Copies the unescaped string value to the string buffer.\r\n        /// </summary>\r\n        /// <param name=\"destination\">The buffer into which to copy the string.</param>\r\n        /// <returns>The number of characters written to the output buffer, or 0 if the buffer was too small.</returns>\r\n        /// <exception cref=\"InvalidOperationException\">\r\n        ///   This value's <see cref=\"ValueKind\"/> is not <see cref=\"JsonValueKind.String\"/>.\r\n        /// </exception>\r\n        /// <exception cref=\"ObjectDisposedException\">\r\n        ///   The parent <see cref=\"JsonDocument\"/> has been disposed.\r\n        /// </exception>\r\n        public int CopyString(Span<char> destination);\r\n\r\n        /// <summary>\r\n        ///   Copies the raw string value to the UTF8 string buffer.\r\n        /// </summary>\r\n        /// <param name=\"utf8Destination\">The buffer into which to copy the UTF8 string.</param>\r\n        /// <returns>The number of bytes written to the output buffer, or 0 if the buffer was too small.</returns>\r\n        /// <exception cref=\"InvalidOperationException\">\r\n        ///   This value's <see cref=\"ValueKind\"/> is not <see cref=\"JsonValueKind.String\"/>.\r\n        /// </exception>\r\n        /// <exception cref=\"ObjectDisposedException\">\r\n        ///   The parent <see cref=\"JsonDocument\"/> has been disposed.\r\n        /// </exception>\r\n        /// <seealso cref=\"ToString\"/>\r\n        public int CopyRawString(Span<byte> utf8Destination)\r\n\r\n        /// <summary>\r\n        ///   Copies the raw string value to the string buffer.\r\n        /// </summary>\r\n        /// <param name=\"destination\">The buffer into which to copy the string.</param>\r\n        /// <returns>The number of characters written to the output buffer, or 0 if the buffer was too small.</returns>\r\n        /// <exception cref=\"InvalidOperationException\">\r\n        ///   This value's <see cref=\"ValueKind\"/> is not <see cref=\"JsonValueKind.String\"/>.\r\n        /// </exception>\r\n        /// <exception cref=\"ObjectDisposedException\">\r\n        ///   The parent <see cref=\"JsonDocument\"/> has been disposed.\r\n        /// </exception>\r\n        /// <seealso cref=\"ToString\"/>\r\n        public int CopyRawString(Span<char> destination)\r\n}\r\n\r\npublic readonly struct JsonProperty\r\n{\r\n        /// <summary>\r\n        ///   Indicates whether the name of this property is escaped.\r\n        /// </summary>\r\n        /// <seealso cref=\"CopyName(Span{byte})\"/>\r\n        /// <seealso cref=\"CopyName(Span{char})\"/>\r\n        /// <seealso cref=\"CopyRawName(Span{byte})\"/>\r\n        /// <seealso cref=\"CopyRawName(Span{char})\"/>\r\n        public bool NameIsEscaped { get; }\r\n\r\n        /// <summary>\r\n        ///   Copies the unescaped property name to the UTF8 string buffer.\r\n        /// </summary>\r\n        /// <param name=\"utf8Destination\">The buffer into which to copy the string.</param>\r\n        /// <returns>The number of bytes written to the output buffer, or 0 if the buffer was too small.</returns>\r\n        /// <exception cref=\"InvalidOperationException\">\r\n        ///   This value's <see cref=\"Type\"/> is not <see cref=\"JsonTokenType.PropertyName\"/>.\r\n        /// </exception>\r\n        /// <exception cref=\"ObjectDisposedException\">\r\n        ///   The parent <see cref=\"JsonDocument\"/> has been disposed.\r\n        /// </exception>\r\n        public int CopyName(Span<byte> utf8Destination);\r\n\r\n        /// <summary>\r\n        ///   Copies the unescaped property name to the string buffer.\r\n        /// </summary>\r\n        /// <param name=\"destination\">The buffer into which to copy the string.</param>\r\n        /// <returns>The number of characters written to the output buffer, or 0 if the buffer was too small.</returns>\r\n        /// <exception cref=\"InvalidOperationException\">\r\n        ///   This value's <see cref=\"Type\"/> is not <see cref=\"JsonTokenType.PropertyName\"/>.\r\n        /// </exception>\r\n        /// <exception cref=\"ObjectDisposedException\">\r\n        ///   The parent <see cref=\"JsonDocument\"/> has been disposed.\r\n        /// </exception>\r\n        public int CopyName(Span<char> destination);\r\n\r\n        /// <summary>\r\n        ///   Copies the raw property name to the string buffer.\r\n        /// </summary>\r\n        /// <param name=\"utf8Destination\">The buffer into which to copy the UTF8 string.</param>\r\n        /// <returns>The number of bytes written to the output buffer, or 0 if the buffer was too small.</returns>\r\n        /// <exception cref=\"InvalidOperationException\">\r\n        ///   This value's <see cref=\"Type\"/> is not <see cref=\"JsonTokenType.PropertyName\"/>.\r\n        /// </exception>\r\n        /// <exception cref=\"ObjectDisposedException\">\r\n        ///   The parent <see cref=\"JsonDocument\"/> has been disposed.\r\n        /// </exception>\r\n        public int CopyRawName(Span<byte> utf8Destination)\r\n\r\n        /// <summary>\r\n        ///   Copies the raw property name to the string buffer.\r\n        /// </summary>\r\n        /// <param name=\"destination\">The buffer into which to copy the string.</param>\r\n        /// <returns>The number of characters written to the output buffer, or 0 if the buffer was too small.</returns>\r\n        /// <exception cref=\"InvalidOperationException\">\r\n        ///   This value's <see cref=\"Type\"/> is not <see cref=\"JsonTokenType.PropertyName\"/>.\r\n        /// </exception>\r\n        /// <exception cref=\"ObjectDisposedException\">\r\n        ///   The parent <see cref=\"JsonDocument\"/> has been disposed.\r\n        /// </exception>\r\n        public int CopyRawName(Span<char> destination)\r\n}\r\n```\r\n\r\n\r\n### API Usage\r\n\r\nThe APIs support the common patterns of working with spans, making it easy to stack allocate, or rent/return value buffers.\r\n\r\nWe avoid throwing exceptions, except for the usual invalid cases.\r\n\r\nWorking with fully unescaped UTF8 `JsonProperty` names\r\n\r\n```csharp\r\nJsonProperty property; // acquired by whatever means\r\nconst int StackAllocThreshold = 1024;\r\n\r\nscoped ReadOnlySpan<byte> nameToProcess = JsonMarshal.GetRawUtf8PropertyName(property);\r\nbyte[]? unescapedArray = null;\r\n\r\nif (property.NameIsEscaped)\r\n{\r\n    // This is the \"slow path\" where we have to unescape\r\n    int bufSize = valueToProcess.Length;\r\n    Debug.Assert(bufSize > 0); // we should never hit this\r\n    Span<byte> utf8Unescaped =\r\n        bufSize <= StackAllocThreshold\r\n            ? stackalloc byte[bufSize]\r\n            : (unescapedArray = ArrayPool<byte>.Shared.Rent(bufSize));\r\n\r\n    written = property.CopyName(utf8Unescaped);\r\n    Debug.Assert(written > 0); // We should never hit this\r\n\r\n    nameToProcess = utf8Unescaped.Slice(0, written);\r\n}\r\n\r\n// Process the unescaped Name however we wish\r\nnameToProcess.SequenceEqual(\"Boo!\"u8);\r\n\r\n// Return the rented buffer (if any)\r\nif (unescapedArray is byte[] ua)\r\n{\r\n    ua.AsSpan(0, nameToProcess.Length).Clear();\r\n    ArrayPool<byte>.Shared.Return(ua);\r\n}\r\n```\r\n\r\nWorking with fully unescaped UTF8 `JsonElement` values\r\n\r\n```csharp\r\nJsonElement element; // obtained by whatever means\r\nscoped ReadOnlySpan<byte> valueToProcess = JsonMarshal.GetRawUtf8Value(element);\r\nbyte[]? unescapedArray = null;\r\n\r\nif (element.ValueIsEscaped)\r\n{\r\n    // This is the \"slow path\" where we have to unescape\r\n    int bufSize = valueToProcess.Length;\r\n    Debug.Assert(bufSize > 0); // we should never hit this\r\n    Span<byte> utf8Unescaped =\r\n        bufSize <= 1024\r\n            ? stackalloc byte[bufSize]\r\n            : (unescapedArray = ArrayPool<byte>.Shared.Rent(bufSize));\r\n\r\n    written = element.CopyString(utf8Unescaped);\r\n    Debug.Assert(written > 0); // we should never hit this\r\n\r\n    valueToProcess = utf8Unescaped.Slice(0, written);\r\n}\r\n\r\n// Process the unescaped value however we wish\r\nvalueToProcess.SequenceEqual(\"Boo!\"u8);\r\n\r\n// Return the rented buffer (if any)\r\nif (unescapedArray is byte[] ua)\r\n{\r\n    ua.AsSpan(0, valueToProcess.Length).Clear();\r\n    ArrayPool<byte>.Shared.Return(ua);\r\n}\r\n```\r\n\r\nTranscoding a raw JSON value, ensuring it is unescaped:\r\n\r\n```csharp\r\nJsonElement element; // obtained by whatever means\r\n\r\nbufSize = JsonMarshal.GetRawUtf8Value(element).Length;\r\nSystem.Diagnostics.Debug.Assert(bufSize > 0); // should never hit this\r\n\r\nchar[]? transcodedArray = null;\r\nSpan<char> transcoded =\r\n    bufSize <= 1024\r\n        ? stackalloc char[bufSize]\r\n        : (transcodedArray = ArrayPool<char>.Shared.Rent(bufSize));\r\n\r\nwritten = element.CopyString(transcoded);\r\nSystem.Diagnostics.Debug.Assert(written > 0); // should never hit this\r\n\r\nReadOnlySpan<char> transcodedValueToProcess = transcoded.Slice(0, written);\r\n\r\n// Process the transcoded, unescaped value however we wish\r\ntranscodedValueToProcess.Equals(\"connectionId\".AsSpan(), StringComparison.Ordinal);\r\n\r\nif (transcodedArray is char[] ta)\r\n{\r\n    ta.AsSpan(0, transcodedValueToProcess.Length).Clear();\r\n    ArrayPool<char>.Shared.Return(ta);\r\n}\r\n```\r\n\r\nTranscoding a raw JSON value, but leaving it escaped.\r\n\r\n```csharp\r\nJsonElement element; // obtained by whatever means\r\n\r\nbufSize = JsonMarshal.GetRawUtf8Value(element).Length;\r\nSystem.Diagnostics.Debug.Assert(bufSize > 0); // should never hit this\r\n\r\nchar[]? transcodedArray = null;\r\nSpan<char> transcoded =\r\n    bufSize <= 1024\r\n        ? stackalloc char[bufSize]\r\n        : (transcodedArray = ArrayPool<char>.Shared.Rent(bufSize));\r\n\r\nwritten = element.CopyRawString(transcoded);\r\nSystem.Diagnostics.Debug.Assert(written > 0); // should never hit this\r\n\r\nReadOnlySpan<char> transcodedValueToProcess = transcoded.Slice(0, written);\r\n\r\n// Process the transcoded, escaped value however we wish\r\ntranscodedValueToProcess.Equals(\"conne\\\\u0063tionId\".AsSpan(), StringComparison.Ordinal);\r\n\r\nif (transcodedArray is char[] ta)\r\n{\r\n    ta.AsSpan(0, transcodedValueToProcess.Length).Clear();\r\n    ArrayPool<char>.Shared.Return(ta);\r\n}\r\n```\r\n\r\n### Alternative Designs\r\n\r\nWe previously discussed adding these methods to `JsonMarshal`, but as they conform to the backing-agnostic requirements of `JsonProperty`/`JsonElement` it seems appropriate to add them here. (See discussion below.)\r\n\r\nIt was suggested in comments that we could just use `JsonMarshal.GetRawUtf8Value(...).Length` to get a suitable buffer length for copying. This works well, especially for efficiency when processing UTF8 strings as you will require the raw UTF8 value anyway.\r\n\r\nAn alternative would be to provide `GetBufferLength()` and `GetNameBufferLength()` APIs on `JsonElement`/`JsonProperty` respectively. While you may not always use them (e.g. in the case where we are already retrieving the raw UTF8 value as part of our processing strategy) it would give a complete API on `JsonElement`/`JsonProperty` which might be more discoverable.\r\n\r\n### Risks\r\n\r\n*Changes to existing APIs*\r\n\r\nThis would mean promoting both `JsonElement.ValueIsEscaped` and `JsonProperty.NameIsEscaped` from `internal` to `public`.\r\n\r\n*General risks*\r\n\r\nI do not believe there are any significant risks to this API, in terms of either performance, or breaking changes.\r\n\r\n*Implementation risks and constraints*\r\n\r\nAs this is intended to be a high-performance, low-allocation API, it is worth considering the influence the API design might have on implementation options.\r\n\r\nExisting JSON reader helper methods can be used to implement the public APIs trivially.",
    "number": 108571,
    "reactions": {
      "hasNextPage": false,
      "nodes": [],
      "totalCount": 0,
      "endCursor": null
    },
    "updatedAt": "2025-03-18T11:18:48Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": "dotnet-policy-service",
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. -->",
          "createdAt": "2024-10-05T14:54:28Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-10-05T14:54:28Z",
          "id": "IC_kwDODI9FZc6OwhJr"
        },
        {
          "author": "eiriktsarpalis",
          "body": "This looks useful, but unlike the existing `JsonMarshal` methods I don't believe it makes sense to unescape arbitrary JsonElements since they often represent complex non-string values. We might want to look to how `Utf8JsonReader` implements its `ValueIsEscaped` and `CopyString` methods for this use case:\r\n\r\n```csharp\r\npublic partial class JsonElement\r\n{\r\n    public bool ValueIsEscaped { get; } // Only returns true if an escaped string, but not if it contains escaped strings\r\n    public int CopyString(Span<byte> utf8Destination); // InvalidOperationException if not string\r\n    public int CopyString(Span<char> destination); // InvalidOperationException if not string\r\n}\r\n\r\npublic partial class JsonProperty\r\n{\r\n    public bool NameIsEscaped { get; }\r\n    public int CopyName(Span<byte> utf8Destination); // InvalidOperationException if not string\r\n    public int CopyName(Span<char> destination); // InvalidOperationException if not string\r\n}\r\n```",
          "createdAt": "2024-10-07T11:45:17Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-10-07T11:45:17Z",
          "id": "IC_kwDODI9FZc6O2r1L"
        },
        {
          "author": "mwadams",
          "body": "That's not unreasonable - my experimental implementation does exactly what Utf8JsonReader does; we can inspect the DbRow to determine if it needs unescaping at all.\n\nAnd I'm all for adding it to JsonProperty and JsonElement in that fashion.\n\n*However* you still need to know (efficiently) a minimum target buffer size and we don't currently have an API for that.",
          "createdAt": "2024-10-07T13:00:06Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-10-07T13:00:06Z",
          "id": "IC_kwDODI9FZc6O3T-7"
        },
        {
          "author": "eiriktsarpalis",
          "body": "> However you still need to know (efficiently) a minimum target buffer size and we don't currently have an API for that.\r\n\r\n`JsonMarshal.GetRawJsonValue(element).Length` should provide a good upper bound for that.",
          "createdAt": "2024-10-07T14:15:44Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-10-07T14:15:44Z",
          "id": "IC_kwDODI9FZc6O4Dez"
        },
        {
          "author": "mwadams",
          "body": "This version of the API requires us to search for the escape character twice (once for the 'requires unescaping' and once for the 'now unescape it into that buffer') *or* not do the test and make an unnecessary copy if it doesn't in fact require escaping.\n\n(Though I guess we could not write anything and return 0 if it didn't require unescaping for the UTF8 case.)",
          "createdAt": "2024-10-07T15:18:04Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-10-07T15:19:37Z",
          "id": "IC_kwDODI9FZc6O4r63"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Not sure I follow, why would it need to do so twice? This information is being precomputed when `JsonDocument`/`JsonElement` is being parsed.",
          "createdAt": "2024-10-07T15:36:03Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-10-07T15:36:03Z",
          "id": "IC_kwDODI9FZc6O42oD"
        },
        {
          "author": "mwadams",
          "body": "> Not sure I follow, why would it need to do so twice? This information is being precomputed when `JsonDocument`/`JsonElement` is being parsed.\n\nDoes it cache the index of the first escaped character seq?",
          "createdAt": "2024-10-07T15:57:29Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-10-07T15:57:29Z",
          "id": "IC_kwDODI9FZc6O5CZ_"
        },
        {
          "author": "eiriktsarpalis",
          "body": "It doesn't, but I don't see why it couldn't. Point being, I don't see how this could impact the proposal from a design perspective.",
          "createdAt": "2024-10-07T16:01:43Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-10-07T16:01:43Z",
          "id": "IC_kwDODI9FZc6O5Es-"
        },
        {
          "author": "mwadams",
          "body": "Ah, ok - I'm fine with that, then. And it is a much cleaner API.\r\n\r\nHowever, you lose the ability to get the escaped, transcoded value. Or rather, you'd have to do it directly using the raw value, and you wouldn't be able to use the pre-configured encoding that the library code uses. ",
          "createdAt": "2024-10-07T16:46:17Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-10-08T07:31:28Z",
          "id": "IC_kwDODI9FZc6O5b8n"
        },
        {
          "author": "mwadams",
          "body": "The client code for this API would look like:\r\n\r\n```csharp\r\nJsonElement element; // obtained by whatever means\r\nscoped ReadOnlySpan<byte> valueToProcess = JsonMarshal.GetRawUtf8Value(element);\r\nbyte[]? unescapedArray = null;\r\n\r\nif (element.ValueIsEscaped)\r\n{\r\n    int bufSize = valueToProcess.Length;\r\n    // This is the \"slow path\" where we have to unescape\r\n    Span<byte> utf8Unescaped =\r\n        bufSize <= 1024\r\n            ? stackalloc byte[bufSize]\r\n            : (unescapedArray = ArrayPool<byte>.Shared.Rent(bufSize));\r\n\r\n    int written = element.CopyString(utf8Unescaped;\r\n    Debug.Assert(written > 0); // we should never hit this\r\n\r\n    valueToProcess = utf8Unescaped.Slice(0, written);\r\n}\r\n\r\n// Process the unescaped value however we wish\r\nvalueToProcess.SequenceEqual(\"Boo!\"u8);\r\n\r\n// Return the rented buffer (if any)\r\nif (unescapedArray is byte[] ua)\r\n{\r\n    ua.AsSpan(0, valueToProcess.Length).Clear();\r\n    ArrayPool<byte>.Shared.Return(ua);\r\n}\r\n```\r\n\r\nThis looks good to me.\r\n\r\nIt still feels a little odd mixing-and-matching `JsonMarshal` and methods that are available on `JsonElement`/`JsonProperty`. Developers will stumble across `CopyString()` because it becomes part of the JsonElement API, but there's no immediately apparent way to determine the buffer size to use. I guess this could be dealt with in the documentation for the method.",
          "createdAt": "2024-10-08T08:13:38Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-10-08T10:05:10Z",
                "user": "eiriktsarpalis"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOD1Os8A=="
          },
          "updatedAt": "2024-10-08T08:16:16Z",
          "id": "IC_kwDODI9FZc6PAEW8"
        },
        {
          "author": "mwadams",
          "body": "> It doesn't, _but I don't see why it couldn't_. Point being, I don't see how this could impact the proposal from a design perspective.\r\n\r\n(To this point - it looks trivial to use one of the 28 spare bits in `DbRow` to cache the `Utf8JsonReader.ValueIsEscaped` property).",
          "createdAt": "2024-10-08T08:40:39Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-10-08T08:40:39Z",
          "id": "IC_kwDODI9FZc6PAUPX"
        },
        {
          "author": "eiriktsarpalis",
          "body": "> It still feels a little odd mixing-and-matching `JsonMarshal` and methods that are available on `JsonElement`/`JsonProperty`. Developers will stumble across `CopyString()` because it becomes part of the JsonElement API, but there's no immediately apparent way to determine the buffer size to use. I guess this could be dealt with in the documentation for the method.\r\n\r\nI think this is acceptable. `JsonElement` and `JsonProperty` by design aren't fixed to a particular underlying encoding and could conceivably target UTF-16 encodings in the future. Apart from being unsafe, returning the raw UTF-8 span breaks that abstraction layer which is why it has been banished to a separate `JsonMarshal` class for advanced users. On the other hand, the proposed `CopyString` methods don't make any assumptions about the underlying encoding.\r\n\r\nWould it be possible to update your proposal in the OP?",
          "createdAt": "2024-10-08T10:09:16Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-10-08T11:50:34Z",
                "user": "mwadams"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOD1PfXQ=="
          },
          "updatedAt": "2024-10-08T10:09:16Z",
          "id": "IC_kwDODI9FZc6PBGHi"
        },
        {
          "author": "mwadams",
          "body": "(Edited; I hadn't realized that `DbRow.HasComplexChildren` is what caches `Utf8JsonReader.ValueIsEscaped`)",
          "createdAt": "2024-10-09T10:11:59Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-10-09T10:12:47Z",
          "id": "IC_kwDODI9FZc6PKiWA"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Looks good, but what's the purpose of the `CopyRaw*` methods? If you needed raw access why not just use `JsonMarshal`?",
          "createdAt": "2024-10-09T10:45:57Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-10-09T10:45:57Z",
          "id": "IC_kwDODI9FZc6PKyfh"
        },
        {
          "author": "mwadams",
          "body": "The `CopyRaw(Span<char>)` methods give you transcoded processing over the raw value/name, which is useful.\n\nThere is no strict need for the `CopyRaw(Span<byte>)` methods today *except* that they are the \"safe\" way of doing what `JsonMarshal` offers; the safety is provided at the cost of an extra blit of the raw value into your buffer.\n\nI am envisioning this to be akin to the `MemoryMarshal` members that give you unsafe operations over assorted structures in memory, v. the Span<T> equivalents where you pay for extra safety. ",
          "createdAt": "2024-10-09T12:42:13Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-10-09T12:46:21Z",
          "id": "IC_kwDODI9FZc6PLusq"
        },
        {
          "author": "mwadams",
          "body": "I have an alternative proposition that will still deliver a significant perf benefit in most use cases where access to the raw property name, and be significantly lower risk / lower surface area.\n\nExpose `NameIsEscaped` and `ValueIsEscaped` through the `JsonMarshal` API e.g.\n\n```csharp\nbool JsonMarshal.ValueIsEscaped(in JsonElement element);\nbool JsonMarshal.ValueIsEscaped(in JsonProperty property);\nbool JsonMarshal.NameIsEscaped(in JsonProperty property);\n```\n\nWhile I would still be required to do my own unescaping in these \"dealing with the raw data\" scenarios, this would be notably better than the current situation of having to repeat the `IndexOf` lookup - an operation that has already been carried out when the `JsonDocument` was built.",
          "createdAt": "2025-03-18T11:17:28Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-03-18T11:17:28Z",
          "id": "IC_kwDODI9FZc6i41Hn"
        }
      ],
      "totalCount": 16,
      "endCursor": "Y3Vyc29yOnYyOpHOouNR5w=="
    },
    "url": "https://github.com/dotnet/runtime/issues/108571",
    "title": "[API Proposal]: Add methods to `JsonElement` and `JsonProperty` to copy both raw and unescaped strings to `Span<byte>` and `Span<char>` buffers."
  },
  {
    "author": "stephentoub",
    "labels": [
      "enhancement",
      "area-System.Text.Json",
      "source-generator"
    ],
    "createdAt": "2024-10-08T18:15:13Z",
    "body": "### Description\n\nIn the repo below, `Exception` should not be serialized as it's defined, but rather only via the ExceptionConverter that treats it as a string. However, the source generator is emitting code to handle all of the properties on Exception. While this is unnecessary code, it also results in trimmer warnings about members of Exception that aren't safe to serialized.\n\n### Reproduction Steps\n```C#\nusing System.Text.Json;\nusing System.Text.Json.Serialization;\n\nConsole.WriteLine(JsonSerializer.Serialize(new MyClass { Error = new Exception(\"error\") } ));\n\nsealed class MyClass\n{\n    [JsonConverter(typeof(ExceptionConverter))]\n    public Exception? Error { get; set; }\n}\n\nsealed class ExceptionConverter : JsonConverter<Exception>\n{\n    public override Exception Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) =>\n        new Exception(reader.GetString());\n\n    public override void Write(Utf8JsonWriter writer, Exception? value, JsonSerializerOptions options) =>\n        writer.WriteStringValue(value?.Message ?? string.Empty);\n}\n\n[JsonSerializable(typeof(MyClass))]\npartial class MyContext : JsonSerializerContext;\n```\n\n### Expected behavior\n\nCode emitted for Exception related to its converter.\n\n### Actual behavior\n\nEmits this:\n```C#\n// <auto-generated/>\n\n#nullable enable annotations\n#nullable disable warnings\n\n// Suppress warnings about [Obsolete] member usage in generated code.\n#pragma warning disable CS0612, CS0618\n\npartial class MyContext\n{\n    private global::System.Text.Json.Serialization.Metadata.JsonTypeInfo<global::System.Exception>? _Exception;\n    \n    /// <summary>\n    /// Defines the source generated JSON serialization contract metadata for a given type.\n    /// </summary>\n    #nullable disable annotations // Marking the property type as nullable-oblivious.\n    public global::System.Text.Json.Serialization.Metadata.JsonTypeInfo<global::System.Exception> Exception\n    #nullable enable annotations\n    {\n        get => _Exception ??= (global::System.Text.Json.Serialization.Metadata.JsonTypeInfo<global::System.Exception>)Options.GetTypeInfo(typeof(global::System.Exception));\n    }\n    \n    private global::System.Text.Json.Serialization.Metadata.JsonTypeInfo<global::System.Exception> Create_Exception(global::System.Text.Json.JsonSerializerOptions options)\n    {\n        if (!TryGetTypeInfoForRuntimeCustomConverter<global::System.Exception>(options, out global::System.Text.Json.Serialization.Metadata.JsonTypeInfo<global::System.Exception> jsonTypeInfo))\n        {\n            var objectInfo = new global::System.Text.Json.Serialization.Metadata.JsonObjectInfoValues<global::System.Exception>\n            {\n                ObjectCreator = () => new global::System.Exception(),\n                ObjectWithParameterizedConstructorCreator = null,\n                PropertyMetadataInitializer = _ => ExceptionPropInit(options),\n                ConstructorParameterMetadataInitializer = null,\n                ConstructorAttributeProviderFactory = static () => typeof(global::System.Exception).GetConstructor(InstanceMemberBindingFlags, binder: null, global::System.Array.Empty<global::System.Type>(), modifiers: null),\n                SerializeHandler = ExceptionSerializeHandler,\n            };\n            \n            jsonTypeInfo = global::System.Text.Json.Serialization.Metadata.JsonMetadataServices.CreateObjectInfo<global::System.Exception>(options, objectInfo);\n            jsonTypeInfo.NumberHandling = null;\n        }\n    \n        jsonTypeInfo.OriginatingResolver = this;\n        return jsonTypeInfo;\n    }\n\n    private static global::System.Text.Json.Serialization.Metadata.JsonPropertyInfo[] ExceptionPropInit(global::System.Text.Json.JsonSerializerOptions options)\n    {\n        var properties = new global::System.Text.Json.Serialization.Metadata.JsonPropertyInfo[8];\n\n        var info0 = new global::System.Text.Json.Serialization.Metadata.JsonPropertyInfoValues<global::System.Collections.IDictionary>\n        {\n            IsProperty = true,\n            IsPublic = true,\n            IsVirtual = true,\n            DeclaringType = typeof(global::System.Exception),\n            Converter = null,\n            Getter = static obj => ((global::System.Exception)obj).Data,\n            Setter = null,\n            IgnoreCondition = null,\n            HasJsonInclude = false,\n            IsExtensionData = false,\n            NumberHandling = null,\n            PropertyName = \"Data\",\n            JsonPropertyName = null,\n            AttributeProviderFactory = static () => typeof(global::System.Exception).GetProperty(\"Data\", InstanceMemberBindingFlags, null, typeof(global::System.Collections.IDictionary), global::System.Array.Empty<global::System.Type>(), null),\n        };\n        \n        properties[0] = global::System.Text.Json.Serialization.Metadata.JsonMetadataServices.CreatePropertyInfo<global::System.Collections.IDictionary>(options, info0);\n        properties[0].IsGetNullable = false;\n\n        var info1 = new global::System.Text.Json.Serialization.Metadata.JsonPropertyInfoValues<string>\n        {\n            IsProperty = true,\n            IsPublic = true,\n            IsVirtual = true,\n            DeclaringType = typeof(global::System.Exception),\n            Converter = null,\n            Getter = static obj => ((global::System.Exception)obj).HelpLink,\n            Setter = static (obj, value) => ((global::System.Exception)obj).HelpLink = value!,\n            IgnoreCondition = null,\n            HasJsonInclude = false,\n            IsExtensionData = false,\n            NumberHandling = null,\n            PropertyName = \"HelpLink\",\n            JsonPropertyName = null,\n            AttributeProviderFactory = static () => typeof(global::System.Exception).GetProperty(\"HelpLink\", InstanceMemberBindingFlags, null, typeof(string), global::System.Array.Empty<global::System.Type>(), null),\n        };\n        \n        properties[1] = global::System.Text.Json.Serialization.Metadata.JsonMetadataServices.CreatePropertyInfo<string>(options, info1);\n\n        var info2 = new global::System.Text.Json.Serialization.Metadata.JsonPropertyInfoValues<int>\n        {\n            IsProperty = true,\n            IsPublic = true,\n            IsVirtual = false,\n            DeclaringType = typeof(global::System.Exception),\n            Converter = null,\n            Getter = static obj => ((global::System.Exception)obj).HResult,\n            Setter = static (obj, value) => ((global::System.Exception)obj).HResult = value!,\n            IgnoreCondition = null,\n            HasJsonInclude = false,\n            IsExtensionData = false,\n            NumberHandling = null,\n            PropertyName = \"HResult\",\n            JsonPropertyName = null,\n            AttributeProviderFactory = static () => typeof(global::System.Exception).GetProperty(\"HResult\", InstanceMemberBindingFlags, null, typeof(int), global::System.Array.Empty<global::System.Type>(), null),\n        };\n        \n        properties[2] = global::System.Text.Json.Serialization.Metadata.JsonMetadataServices.CreatePropertyInfo<int>(options, info2);\n\n        var info3 = new global::System.Text.Json.Serialization.Metadata.JsonPropertyInfoValues<global::System.Exception>\n        {\n            IsProperty = true,\n            IsPublic = true,\n            IsVirtual = false,\n            DeclaringType = typeof(global::System.Exception),\n            Converter = null,\n            Getter = static obj => ((global::System.Exception)obj).InnerException,\n            Setter = null,\n            IgnoreCondition = null,\n            HasJsonInclude = false,\n            IsExtensionData = false,\n            NumberHandling = null,\n            PropertyName = \"InnerException\",\n            JsonPropertyName = null,\n            AttributeProviderFactory = static () => typeof(global::System.Exception).GetProperty(\"InnerException\", InstanceMemberBindingFlags, null, typeof(global::System.Exception), global::System.Array.Empty<global::System.Type>(), null),\n        };\n        \n        properties[3] = global::System.Text.Json.Serialization.Metadata.JsonMetadataServices.CreatePropertyInfo<global::System.Exception>(options, info3);\n\n        var info4 = new global::System.Text.Json.Serialization.Metadata.JsonPropertyInfoValues<string>\n        {\n            IsProperty = true,\n            IsPublic = true,\n            IsVirtual = true,\n            DeclaringType = typeof(global::System.Exception),\n            Converter = null,\n            Getter = static obj => ((global::System.Exception)obj).Message,\n            Setter = null,\n            IgnoreCondition = null,\n            HasJsonInclude = false,\n            IsExtensionData = false,\n            NumberHandling = null,\n            PropertyName = \"Message\",\n            JsonPropertyName = null,\n            AttributeProviderFactory = static () => typeof(global::System.Exception).GetProperty(\"Message\", InstanceMemberBindingFlags, null, typeof(string), global::System.Array.Empty<global::System.Type>(), null),\n        };\n        \n        properties[4] = global::System.Text.Json.Serialization.Metadata.JsonMetadataServices.CreatePropertyInfo<string>(options, info4);\n        properties[4].IsGetNullable = false;\n\n        var info5 = new global::System.Text.Json.Serialization.Metadata.JsonPropertyInfoValues<string>\n        {\n            IsProperty = true,\n            IsPublic = true,\n            IsVirtual = true,\n            DeclaringType = typeof(global::System.Exception),\n            Converter = null,\n            Getter = static obj => ((global::System.Exception)obj).Source,\n            Setter = static (obj, value) => ((global::System.Exception)obj).Source = value!,\n            IgnoreCondition = null,\n            HasJsonInclude = false,\n            IsExtensionData = false,\n            NumberHandling = null,\n            PropertyName = \"Source\",\n            JsonPropertyName = null,\n            AttributeProviderFactory = static () => typeof(global::System.Exception).GetProperty(\"Source\", InstanceMemberBindingFlags, null, typeof(string), global::System.Array.Empty<global::System.Type>(), null),\n        };\n        \n        properties[5] = global::System.Text.Json.Serialization.Metadata.JsonMetadataServices.CreatePropertyInfo<string>(options, info5);\n\n        var info6 = new global::System.Text.Json.Serialization.Metadata.JsonPropertyInfoValues<string>\n        {\n            IsProperty = true,\n            IsPublic = true,\n            IsVirtual = true,\n            DeclaringType = typeof(global::System.Exception),\n            Converter = null,\n            Getter = static obj => ((global::System.Exception)obj).StackTrace,\n            Setter = null,\n            IgnoreCondition = null,\n            HasJsonInclude = false,\n            IsExtensionData = false,\n            NumberHandling = null,\n            PropertyName = \"StackTrace\",\n            JsonPropertyName = null,\n            AttributeProviderFactory = static () => typeof(global::System.Exception).GetProperty(\"StackTrace\", InstanceMemberBindingFlags, null, typeof(string), global::System.Array.Empty<global::System.Type>(), null),\n        };\n        \n        properties[6] = global::System.Text.Json.Serialization.Metadata.JsonMetadataServices.CreatePropertyInfo<string>(options, info6);\n\n        var info7 = new global::System.Text.Json.Serialization.Metadata.JsonPropertyInfoValues<global::System.Reflection.MethodBase>\n        {\n            IsProperty = true,\n            IsPublic = true,\n            IsVirtual = false,\n            DeclaringType = typeof(global::System.Exception),\n            Converter = null,\n            Getter = static obj => ((global::System.Exception)obj).TargetSite,\n            Setter = null,\n            IgnoreCondition = null,\n            HasJsonInclude = false,\n            IsExtensionData = false,\n            NumberHandling = null,\n            PropertyName = \"TargetSite\",\n            JsonPropertyName = null,\n            AttributeProviderFactory = static () => typeof(global::System.Exception).GetProperty(\"TargetSite\", InstanceMemberBindingFlags, null, typeof(global::System.Reflection.MethodBase), global::System.Array.Empty<global::System.Type>(), null),\n        };\n        \n        properties[7] = global::System.Text.Json.Serialization.Metadata.JsonMetadataServices.CreatePropertyInfo<global::System.Reflection.MethodBase>(options, info7);\n\n        return properties;\n    }\n\n    // Intentionally not a static method because we create a delegate to it. Invoking delegates to instance\n    // methods is almost as fast as virtual calls. Static methods need to go through a shuffle thunk.\n    private void ExceptionSerializeHandler(global::System.Text.Json.Utf8JsonWriter writer, global::System.Exception? value)\n    {\n        if (value is null)\n        {\n            writer.WriteNullValue();\n            return;\n        }\n        \n        writer.WriteStartObject();\n\n        writer.WritePropertyName(PropName_Data);\n        global::System.Text.Json.JsonSerializer.Serialize(writer, ((global::System.Exception)value).Data, IDictionary);\n        writer.WriteString(PropName_HelpLink, ((global::System.Exception)value).HelpLink);\n        writer.WriteNumber(PropName_HResult, ((global::System.Exception)value).HResult);\n        writer.WritePropertyName(PropName_InnerException);\n        ExceptionSerializeHandler(writer, ((global::System.Exception)value).InnerException);\n        writer.WriteString(PropName_Message, ((global::System.Exception)value).Message);\n        writer.WriteString(PropName_Source, ((global::System.Exception)value).Source);\n        writer.WriteString(PropName_StackTrace, ((global::System.Exception)value).StackTrace);\n        writer.WritePropertyName(PropName_TargetSite);\n        global::System.Text.Json.JsonSerializer.Serialize(writer, ((global::System.Exception)value).TargetSite, MethodBase);\n\n        writer.WriteEndObject();\n    }\n}\n```\n\n### Regression?\n\nn/a\n\n### Known Workarounds\n\nn/a\n\n### Configuration\n\n.NET 9\n\n### Other information\n\n_No response_",
    "number": 108682,
    "reactions": {
      "hasNextPage": false,
      "nodes": [],
      "totalCount": 0,
      "endCursor": null
    },
    "updatedAt": "2025-01-17T12:08:52Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": "dotnet-policy-service",
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. -->",
          "createdAt": "2024-10-08T18:15:38Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-10-08T18:15:38Z",
          "id": "IC_kwDODI9FZc6PFRF-"
        },
        {
          "author": "eiriktsarpalis",
          "body": "This happens because the source generator will attempt to source generate for every type that is found within the transitive closure of `JsonSerializable` types, even if those types are only defined on properties that  define custom converters:\r\n\r\n```C#\r\n// A JsonTypeInfo<Bar> has been generated even if it isn't being used by Foo\r\nConsole.WriteLine(JsonSerializer.Serialize(new Bar(\"Value\"), MyContext.Default.Bar)); // {\"Value\":\"Value\"}\r\n\r\nclass Foo\r\n{\r\n    [JsonConverter(typeof(CustomBarConverter))]\r\n    public Bar? PropertyWithCustomConverter { get; set; }\r\n\r\n    // Serializes Bar as a plain old string\r\n    public class CustomBarConverter : JsonConverter<Bar>\r\n    {\r\n        public override Bar Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)\r\n            => new Bar(reader.GetString()!);\r\n\r\n        public override void Write(Utf8JsonWriter writer, Bar value, JsonSerializerOptions options) =>\r\n            writer.WriteStringValue(value.Value);\r\n    }\r\n}\r\n\r\nrecord Bar(string Value);\r\n\r\n[JsonSerializable(typeof(Foo))]\r\npartial class MyContext : JsonSerializerContext;\r\n```\r\n\r\nI don't think we could change this today without incurring breaking changes.",
          "createdAt": "2024-10-08T21:08:52Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-10-08T21:09:50Z",
          "id": "IC_kwDODI9FZc6PGa5h"
        },
        {
          "author": "stephentoub",
          "body": "How can trimmer warnings be suppressed just in the generated files? Should the source generator be suppressing them with pragmas? Otherwise, it seems you need to suppress them project-wide. ",
          "createdAt": "2024-10-09T10:57:17Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-10-09T10:57:17Z",
          "id": "IC_kwDODI9FZc6PK5WD"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Pragma suppressions won't prevent the linker from emitting warnings when it encounters unsafe APIs. The generated code must be annotated with attributes.",
          "createdAt": "2024-10-09T10:59:19Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-10-09T10:59:19Z",
          "id": "IC_kwDODI9FZc6PK6Sb"
        },
        {
          "author": "stephentoub",
          "body": "Then what do you recommend? You moved this to future, but that's effectively saying such warnings need to be suppressed at the project level, which then defeats the purpose of such warnings and makes it near impossible to guarantee linker safety. ",
          "createdAt": "2024-10-09T11:09:04Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-10-09T11:09:04Z",
          "id": "IC_kwDODI9FZc6PK-3S"
        },
        {
          "author": "eiriktsarpalis",
          "body": "> but that's effectively saying such warnings need to be suppressed at the project level\n\nI don't believe either pragma suppressions or project level suppressions at the library will prevent the same warnings from being surfaced when running `dotnet publish`. Suppressions must be made using attributes. @vitek-karas should be able to confirm this.\n\n> Then what do you recommend?\n\nI can't think of anything that doesn't involve introducing new API. An ad hoc fix would involve just disabling generation for exception -- the code that it does generate today by default won't work since it has a number of already unsupported property types.",
          "createdAt": "2024-10-09T11:24:44Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-10-09T11:24:44Z",
          "id": "IC_kwDODI9FZc6PLGBv"
        },
        {
          "author": "vitek-karas",
          "body": "Pragma suppressions only work on analyzer. That said, if the generated code is never used, then trimmer or AOT will not produce warnings on it since they'll get rid of it first. So if the discussion is only around the case where the source generator produces code which is never used, pragma suppressions should be enough.\n\nThere's nothing really like \"project level suppressions\" - even if you suppress them via `NoWarn`, if it's in the library, the final app will show them again (because trimmer runs on all IL globally). What is in theory possible is injecting suppression attributes via XML trimmer files, but that's not something we want to do if at all possible.\n\nYou can suppress the warnings on the app level via `NoWarn`, just like any other warning, and that will work for all sources (analyzer, trimmer, AOT).\n\n@sbomer ",
          "createdAt": "2024-10-09T11:55:14Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-10-09T11:55:14Z",
          "id": "IC_kwDODI9FZc6PLVsP"
        }
      ],
      "totalCount": 7,
      "endCursor": "Y3Vyc29yOnYyOpHOjy1bDw=="
    },
    "url": "https://github.com/dotnet/runtime/issues/108682",
    "title": "JSON source generator emitting source for types unexpectedly"
  },
  {
    "author": "angelaki",
    "labels": [
      "enhancement",
      "area-System.Text.Json"
    ],
    "createdAt": "2024-10-09T10:56:23Z",
    "body": "I'd like to be able to run this serialization:\n\n```\nusing System.Text.Json;\nusing System.Text.Json.Serialization;\nusing System.Text.Json.Serialization.Metadata;\n\nnamespace ConsoleApp1;\n\ninternal class Program\n{\n    static void Main(string[] args)\n    {\n        JsonSerializer.Serialize<IFoo>(new Foo());\n        JsonSerializer.Serialize<IFoo>(new Bar());\n        JsonSerializer.Serialize<IFoo>(new FooBar());\n    }\n}\n\n//[JsonPolymorphic(UnknownDerivedTypeHandling = JsonUnknownDerivedTypeHandling.FallBackToNearestAncestor)]\n[JsonDerivedType(typeof(IBar))]\n[JsonDerivedType(typeof(IFooBar))]\npublic interface IFoo { string A { get; set; } }\npublic interface IBar : IFoo { string B { get; set; } }\npublic interface IFooBar : IBar { string C { get; set; } }\n\npublic class Foo : IFoo { public string A { get; set; } }\npublic class Bar : Foo, IBar { public string B { get; set; } }\npublic class FooBar : Bar, IFooBar { public string C { get; set; } }\n\n```\n\nThe first line throws an exception:\n\n> Specified type 'ConsoleApp1.IBar' is not a supported derived type for the polymorphic type 'ConsoleApp1.IFoo'. Derived types must be assignable to the base type, must not be generic and cannot be abstract classes or interfaces unless 'JsonUnknownDerivedTypeHandling.FallBackToNearestAncestor' is specified.\n\nI'm using this in an ASP.Net Core scenario, where the latest release made it pretty possible for me, to work with interfaces in (de-) serialization. Now I'm just struggeling with polymorphism. Is there a reason for this design decision? If I'm not mistaken, this time I'm not able to override / configure something etc.? Maybe I can help support this use-case?\n\nEnabing `JsonUnknownDerivedTypeHandling.FallBackToNearestAncestor` is actually not what I want - I just want these types to be picked / serialized. And even with this option set, I'll get an `diamond ambiguity exception`, if more than one level ist used.",
    "number": 108705,
    "reactions": {
      "hasNextPage": false,
      "nodes": [],
      "totalCount": 0,
      "endCursor": null
    },
    "updatedAt": "2024-10-15T10:58:29Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": "dotnet-policy-service",
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. -->",
          "createdAt": "2024-10-09T10:58:45Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-10-09T10:58:45Z",
          "id": "IC_kwDODI9FZc6PK6Be"
        },
        {
          "author": "eiriktsarpalis",
          "body": "The polymorphism feature by default uses the runtime type of the object you are trying to serialize (e.g. `value.GetType()`) to determine what contract the serializer should be using. The reason why you're seeing this error is because `value.GetType()` can never be an interface -- if you want to match against interfaces you need a different matching algorithm that involves walking up the inheritance hierarchy, which is what `FallBackToNearestAncestor` offers.",
          "createdAt": "2024-10-09T11:17:42Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-10-09T11:17:42Z",
          "id": "IC_kwDODI9FZc6PLC4c"
        },
        {
          "author": "angelaki",
          "body": "Ok, fair. Sure, supporting interfaces here would make things quite complicated. So let's assume the `FallBackToNearestAncestor` strategy: using this, I get this `diamond ambiguity exception` (https://github.com/dotnet/runtime/blob/abde3f9498f09b5016a7a0d7d2e1b81ce5c1b614/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/Metadata/PolymorphicTypeResolver.cs#L239).\n\nI guess that's because `IFooBar` can be of type `IFoo` and `IBar`? How about just taking the top most / first matching? Or be able to implement a custom strategy here? Right now there's no solution for this, right? I'm just thinking about dropping the shipped polimorphism-system at all and just decide what interface to use for serialization.\n\nThank you pretty much for your *super fast* answer!",
          "createdAt": "2024-10-09T12:11:58Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-10-09T12:11:58Z",
          "id": "IC_kwDODI9FZc6PLd7G"
        },
        {
          "author": "eiriktsarpalis",
          "body": "> How about just taking the top most / first matching?\n\nWhat does \"first\" mean in this context? Your example fails for type `FooBar` which separately implements both `IBar` and `IFooBar`. Why should one take precedence over the other?",
          "createdAt": "2024-10-09T16:38:44Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-10-09T16:38:44Z",
          "id": "IC_kwDODI9FZc6PN-9H"
        },
        {
          "author": "angelaki",
          "body": "> > How about just taking the top most / first matching?\n> \n> What does \"first\" mean in this context? Your example fails for type `FooBar` which separately implements both `IBar` and `IFooBar`. Why should one take precedence over the other?\n\nSince they are in a straight, hierarchical order `FooBar` is the top most. If checking this is too loose / complex, supplying a custom solver would be helpful. If I'm not mistaken, I'm in a dead end right now, right?",
          "createdAt": "2024-10-09T20:57:39Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-10-09T20:57:39Z",
          "id": "IC_kwDODI9FZc6PQTeU"
        },
        {
          "author": "eiriktsarpalis",
          "body": "The algorithm could have been implemented in way that checks for subtype relationships between conflicts, but I'm weary of changing it now for fear of subtle breaking changes/unexpected behaviour.",
          "createdAt": "2024-10-09T21:08:29Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-10-09T21:08:29Z",
          "id": "IC_kwDODI9FZc6PQXgG"
        },
        {
          "author": "angelaki",
          "body": "> The algorithm could have been implemented in way that checks for subtype relationships between conflicts, but I'm weary of changing it now for fear of subtle breaking changes/unexpected behaviour.\n\nSo how about a custom solver? Not just for this case but in general?\n\n- no breaking change\n- could support other polymorphic scenarios (dont pass a type map [or just on top for meta infos?] but just a solver function\n- this could even be pretty helpful in DI-scenarios without static type definitions (right now I build my PolymorphicTypeResolver after app start)\n\nBut for now: how to solve it? Ignore build in polymorphism completely and pick the best serialization interface every time on demand?",
          "createdAt": "2024-10-09T21:16:18Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-10-09T21:16:18Z",
          "id": "IC_kwDODI9FZc6PQaN9"
        },
        {
          "author": "eiriktsarpalis",
          "body": "There's no workaround available today other than writing a custom polymorphic converter from scratch.",
          "createdAt": "2024-10-09T22:08:39Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-10-09T22:08:39Z",
          "id": "IC_kwDODI9FZc6PQrxZ"
        },
        {
          "author": "angelaki",
          "body": "Is _writing a custom polymorphic converter from scratch_ somehow supported right now? I was thinking about writing my own `JsonOutputFormatter` where the type to be serialized gets chosen on demand. But I forgot about enumerable scenarions, where the serializer picks the type itself.\n\nE.g. I can say\n\n> serialize this `IFoo` as `IFooBar` (´await JsonSerializer.SerializeAsync(responseStream, context.Object, **jsonTypeInfo**, httpContext.RequestAborted);´\n\nwhere the `context.Object` is an `IFoo` but gets forced to IFooBar via the `jsonTypeInfo`. But I'm not able to decide it for every element of an `IFoo[]`. Is there any hook in the JsonSerializer right now?",
          "createdAt": "2024-10-15T10:58:28Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-10-15T10:58:28Z",
          "id": "IC_kwDODI9FZc6P3Bsa"
        }
      ],
      "totalCount": 9,
      "endCursor": "Y3Vyc29yOnYyOpHOj9wbGg=="
    },
    "url": "https://github.com/dotnet/runtime/issues/108705",
    "title": "System.Text.Json: Improve polymorphism support form Interface-types"
  },
  {
    "author": "blowdart",
    "labels": [
      "api-suggestion",
      "area-System.Text.Json"
    ],
    "createdAt": "2024-10-15T12:52:56Z",
    "body": "When using polymorphic types with `System.Text.Json` and configuring `FallBackToNearestAncestor` and `IgnoreUnrecognizedTypeParameters` to true you cannot tell the Json type discriminator of unrecognized objects.\n\nTo give a real-world example, I talk to a preferences API which returns multiple types of preferences, so I have a base class/record Preference\n\n```c#\n[JsonPolymorphic(UnknownDerivedTypeHandling = \n  JsonUnknownDerivedTypeHandling.FallBackToNearestAncestor,\n  IgnoreUnrecognizedTypeDiscriminators = true)]\n\n[JsonDerivedType(typeof(......)]\npublic record Preference\n{\n    [JsonConstructor]\n    public Preference() {}\n\n    [JsonExtensionData]\n    public Dictionary<string, JsonElement>? ExtensionData {get; set;}\n}\n```\n\nThe idea being that if the api needs a new type of preference I don't have a derived class for then deserialization will still succeed, falling back to create an instance of Preference, with the unknown properties exposed in the `ExtensionData`.\n\nThen in parsing a collection of preferences I can use pattern matching to act on the derived types.\n\nHowever, when deserialization falls back to using the preference class I get everything in the `ExtensionData` except for the type discriminator value. This makes it impossible to make a reasoned decision about what to do with the data.\n\nIf the preferences API added two new types which have the same shape, say\n\n```json\n{\n    \"$type\": \"legume\",\n    \"description\": \"a type of legume\"\n},\n{\n    \"$type\": \"beans\",\n    \"description\" : \"the best type of legume\"\n}\n```\n\nthen after deserialization I would get is the description in the extension data with no way of telling the types apart. So, you need to expose the type property somewhere.\n\nMy suggestion would be if deserialization has fallen back because the type is unknown and there is an extension data property then also insert the type value into that, or, if the fallback class/record has a property of string where the `JsonPropertyName` value matches the `TypeDiscriminatorPropertyName` property on the `JsonPolymorphic` attribute, feed it into that as well.\n\nIf you go the property router then during serialization any `JsonInclude` property which has a `JsonPropertyName` which matches the `TypeDiscriminatorPropertyName` property on the `JsonPolymorphic`attribute could be ignored by default.\n\n\n\n",
    "number": 108885,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "LAUGH",
          "createdAt": "2024-10-15T13:14:28Z",
          "user": "martincostello"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-01-14T22:28:20Z",
          "user": "cdschneider"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-03-07T14:04:57Z",
          "user": "konst-sh"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-03-12T18:32:54Z",
          "user": "srs-adamr"
        },
        {
          "content": "LAUGH",
          "createdAt": "2025-03-12T18:32:55Z",
          "user": "srs-adamr"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-07-09T02:20:16Z",
          "user": "Walkman100"
        }
      ],
      "totalCount": 6,
      "endCursor": "Y3Vyc29yOnYyOpHODGRIlQ=="
    },
    "updatedAt": "2025-03-12T18:25:57Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": "dotnet-policy-service",
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. -->",
          "createdAt": "2024-10-15T12:53:23Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-10-15T12:53:23Z",
          "id": "IC_kwDODI9FZc6P4DQW"
        },
        {
          "author": "eiriktsarpalis",
          "body": "The current behaviour is by design in that type discriminators are a type-level mapping, as such it cannot be mapped from properties or extension data of a particular instance into the wire or vice-versa. We might consider exposing an additional flag on `JsonPolymorphicAttribute` that enables deserialization-only binding of unrecognized discriminators either on properties or extension data dictionaries. The design would be making it explicit that such values would not be roundtripped back into the wire.",
          "createdAt": "2024-10-15T12:58:48Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-10-15T12:58:48Z",
          "id": "IC_kwDODI9FZc6P4GWU"
        },
        {
          "author": "konst-sh",
          "body": "I would support exposing type discriminator as normal object property, this would improve json handling that I'm out of control by far.",
          "createdAt": "2025-03-07T14:04:52Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-03-12T18:01:20Z",
                "user": "srs-adamr"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-07-09T02:21:39Z",
                "user": "Walkman100"
              }
            ],
            "totalCount": 2,
            "endCursor": "Y3Vyc29yOnYyOpHOEZ22gA=="
          },
          "updatedAt": "2025-03-07T14:04:52Z",
          "id": "IC_kwDODI9FZc6hUmkA"
        },
        {
          "author": "srs-adamr",
          "body": "I understand the design philosophy keeping discriminators as type-level mappings. The issue is that we currently can't bind the discriminator to a property without encountering the `Deserialized object contains a duplicate type discriminator metadata property` error.\n\nWhat if we forced making the property read-only during deserialization? For example:\n```\n[JsonPolymorphic(TypeDiscriminatorPropertyName = \"Type\", BindDiscriminatorToProperty = \"Type\")]\npublic abstract class BaseClass\n{\n    public int Id { get; set; }\n    public string Type { get; init; } // Init-only property in C# 9+\n}\n```\n\nAddressing potential concerns:\n\n1. \"This would change serialization behavior\" - Not if implemented correctly. The property would only be populated during deserialization, and during serialization, the property value would be written as normal JSON without affecting the type-level mapping.\n2. \"This creates implementation complexity\" - The discriminator value is already being parsed and used. Binding it to a property would be a minimal addition to the existing logic with negligible performance impact.\n3. \"This confuses the separation of concerns\" - I'd argue the opposite. The confusion exists now because developers expect the discriminator to be both a type marker and an accessible value. This feature would clarify this dual nature rather than forcing workarounds.\n4. \"Init-only properties don't fully protect the value\" - True, but they offer a good balance of protection while working with the existing serialization system. If needed, the feature could support true read-only properties through constructor binding.\n\nThis solution respects the core design while solving the practical issue in a way that's consistent with System.Text.Json's performance and usability goals.",
          "createdAt": "2025-03-12T18:10:48Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-03-12T18:34:06Z",
                "user": "konst-sh"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-07-09T02:23:47Z",
                "user": "Walkman100"
              }
            ],
            "totalCount": 2,
            "endCursor": "Y3Vyc29yOnYyOpHOEZ23Lw=="
          },
          "updatedAt": "2025-03-12T18:25:56Z",
          "id": "IC_kwDODI9FZc6iDEHb"
        }
      ],
      "totalCount": 4,
      "endCursor": "Y3Vyc29yOnYyOpHOogxB2w=="
    },
    "url": "https://github.com/dotnet/runtime/issues/108885",
    "title": "Json deserialization of polymorphic types does not expose the discriminator value"
  },
  {
    "author": "burtonrodman",
    "labels": [
      "area-System.Text.Json",
      "source-generator"
    ],
    "createdAt": "2024-11-15T02:06:28Z",
    "body": "### Description\n\nJson source generator generates invalid code when a property name is a keyword, like @event\n\n### Reproduction Steps\n\n1.  create a class that has a property call @event\n2.  create a JsonSerializerContext class that references above class\n3.  build and notice compiler errors in generated code\n\n```\npublic class ClickEvent {\n  public required string @event { get; set; }\n}\n\n[JsonSerializable(typeof(ClickEvent))]\npublic partial class ClientEventContext : JsonSerializerContext { }\n```\n\n### Expected behavior\n\ngenerated code does not cause compile errors\n\n### Actual behavior\n\n```\n        private global::System.Text.Json.Serialization.Metadata.JsonTypeInfo<global::TwentyTenSolutions.ContentManagement.Editing.ViewModels.ClickEvent> Create_ClickEvent(global::System.Text.Json.JsonSerializerOptions options)\n        {\n            if (!TryGetTypeInfoForRuntimeCustomConverter<global::TwentyTenSolutions.ContentManagement.Editing.ViewModels.ClickEvent>(options, out global::System.Text.Json.Serialization.Metadata.JsonTypeInfo<global::TwentyTenSolutions.ContentManagement.Editing.ViewModels.ClickEvent> jsonTypeInfo))\n            {\n                var objectInfo = new global::System.Text.Json.Serialization.Metadata.JsonObjectInfoValues<global::TwentyTenSolutions.ContentManagement.Editing.ViewModels.ClickEvent>\n                {\n                    ObjectCreator = null,\n                    ObjectWithParameterizedConstructorCreator = static args => new global::TwentyTenSolutions.ContentManagement.Editing.ViewModels.ClickEvent(){ event = (string)args[0] },\n                    PropertyMetadataInitializer = _ => ClickEventPropInit(options),\n                    ConstructorParameterMetadataInitializer = ClickEventCtorParamInit,\n                    SerializeHandler = ClickEventSerializeHandler\n                };\n                \n                jsonTypeInfo = global::System.Text.Json.Serialization.Metadata.JsonMetadataServices.CreateObjectInfo<global::TwentyTenSolutions.ContentManagement.Editing.ViewModels.ClickEvent>(options, objectInfo);\n                jsonTypeInfo.NumberHandling = null;\n            }\n        \n            jsonTypeInfo.OriginatingResolver = this;\n            return jsonTypeInfo;\n        }\n\n```\n\n### Regression?\n\n_No response_\n\n### Known Workarounds\n\n_No response_\n\n### Configuration\n\n_No response_\n\n### Other information\n\n_No response_",
    "number": 109854,
    "reactions": {
      "hasNextPage": false,
      "nodes": [],
      "totalCount": 0,
      "endCursor": null
    },
    "updatedAt": "2025-03-24T19:06:17Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": "dotnet-policy-service",
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. -->",
          "createdAt": "2024-11-15T02:06:54Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-11-15T02:06:54Z",
          "id": "IC_kwDODI9FZc6TsFkw"
        },
        {
          "author": "burtonrodman",
          "body": "```\n *  Executing task in folder MyFirm.ContentManagement: C:\\Program Files\\dotnet\\dotnet.exe build D:\\source\\MyFirm\\Internal\\MyFirm.ContentManagement/MyFirm.ContentManagement.sln /property:GenerateFullPaths=true /consoleloggerparameters:NoSummary;ForceNoAlign \n\n  Determining projects to restore...\n  All projects are up-to-date for restore.\n  MyFirm.ContentManagement.Editing.Domain -> D:\\source\\MyFirm\\Internal\\MyFirm.ContentManagement\\editing\\MyFirm.ContentManagement.Editing.Domain\\bin\\Debug\\net8.0\\MyFirm.ContentManagement.Editing.Domain.dll\n  MyFirm.ContentManagement.Data -> D:\\source\\MyFirm\\Internal\\MyFirm.ContentManagement\\data\\MyFirm.ContentManagement.Data\\bin\\Debug\\net8.0\\MyFirm.ContentManagement.Data.dll\n  MyFirm.ContentManagement.Editing.Api -> D:\\source\\MyFirm\\Internal\\MyFirm.ContentManagement\\editing\\MyFirm.ContentManagement.Editing.Api\\bin\\Debug\\net8.0\\MyFirm.ContentManagement.Editing.Api.dll\n  MyFirm.ContentManagement.Rendering -> D:\\source\\MyFirm\\Internal\\MyFirm.ContentManagement\\rendering\\MyFirm.ContentManagement.Rendering\\bin\\Debug\\net8.0\\MyFirm.ContentManagement.Rendering.dll\n  MyFirm.ContentManagement.Rendering.Tests -> D:\\source\\MyFirm\\Internal\\MyFirm.ContentManagement\\rendering\\MyFirm.ContentManagement.Rendering.Tests\\bin\\Debug\\net8.0\\MyFirm.ContentManagement.Rendering.Tests.dll\n  sampleSite -> D:\\source\\MyFirm\\Internal\\MyFirm.ContentManagement\\samples\\site\\sampleSite\\bin\\Debug\\net8.0\\sampleSite.dll\nD:\\source\\MyFirm\\Internal\\MyFirm.ContentManagement\\editing\\MyFirm.ContentManagement.Editing\\obj\\Debug\\net8.0\\generated\\System.Text.Json.SourceGeneration\\System.Text.Json.SourceGeneration.JsonSourceGenerator\\PickImageEventContext.PickImageEvent.g.cs(36,17): error CS8802: Only one compilation unit can have top-level statements. [D:\\source\\MyFirm\\Internal\\MyFirm.ContentManagement\\editing\\MyFirm.ContentManagement.Editing\\MyFirm.ContentManagement.Editing.csproj]\nD:\\source\\MyFirm\\Internal\\MyFirm.ContentManagement\\editing\\MyFirm.ContentManagement.Editing\\obj\\Debug\\net8.0\\generated\\System.Text.Json.SourceGeneration\\System.Text.Json.SourceGeneration.JsonSourceGenerator\\SlotEditorsInitEventContext.SlotEditorsInitEvent.g.cs(36,17): error CS8802: Only one compilation unit can have top-level statements. [D:\\source\\MyFirm\\Internal\\MyFirm.ContentManagement\\editing\\MyFirm.ContentManagement.Editing\\MyFirm.ContentManagement.Editing.csproj]\nD:\\source\\MyFirm\\Internal\\MyFirm.ContentManagement\\editing\\MyFirm.ContentManagement.Editing\\obj\\Debug\\net8.0\\generated\\System.Text.Json.SourceGeneration\\System.Text.Json.SourceGeneration.JsonSourceGenerator\\SlotInsertBlockEventContext.SlotInsertBlockEvent.g.cs(36,17): error CS8802: Only one compilation unit can have top-level statements. [D:\\source\\MyFirm\\Internal\\MyFirm.ContentManagement\\editing\\MyFirm.ContentManagement.Editing\\MyFirm.ContentManagement.Editing.csproj]\nD:\\source\\MyFirm\\Internal\\MyFirm.ContentManagement\\editing\\MyFirm.ContentManagement.Editing\\obj\\Debug\\net8.0\\generated\\System.Text.Json.SourceGeneration\\System.Text.Json.SourceGeneration.JsonSourceGenerator\\BlockActionMenuClickEventContext.BlockActionMenuClickEvent.g.cs(36,17): error CS8802: Only one compilation unit can have top-level statements. [D:\\source\\MyFirm\\Internal\\MyFirm.ContentManagement\\editing\\MyFirm.ContentManagement.Editing\\MyFirm.ContentManagement.Editing.csproj]\nD:\\source\\MyFirm\\Internal\\MyFirm.ContentManagement\\editing\\MyFirm.ContentManagement.Editing\\obj\\Debug\\net8.0\\generated\\System.Text.Json.SourceGeneration\\System.Text.Json.SourceGeneration.JsonSourceGenerator\\ClientEventContext.ClickEvent.g.cs(36,17): error CS8802: Only one compilation unit can have top-level statements. [D:\\source\\MyFirm\\Internal\\MyFirm.ContentManagement\\editing\\MyFirm.ContentManagement.Editing\\MyFirm.ContentManagement.Editing.csproj]\nD:\\source\\MyFirm\\Internal\\MyFirm.ContentManagement\\editing\\MyFirm.ContentManagement.Editing\\obj\\Debug\\net8.0\\generated\\System.Text.Json.SourceGeneration\\System.Text.Json.SourceGeneration.JsonSourceGenerator\\ClientEventContext.ClickEvent.g.cs(30,168): error CS0065: 'ClientEventContext.': event property must have both add and remove accessors [D:\\source\\MyFirm\\Internal\\MyFirm.ContentManagement\\editing\\MyFirm.ContentManagement.Editing\\MyFirm.ContentManagement.Editing.csproj]\nD:\\source\\MyFirm\\Internal\\MyFirm.ContentManagement\\editing\\MyFirm.ContentManagement.Editing\\obj\\Debug\\net8.0\\generated\\System.Text.Json.SourceGeneration\\System.Text.Json.SourceGeneration.JsonSourceGenerator\\BlockEditableInputEventContext.BlockEditableInputEvent.g.cs(30,214): error CS0065: 'BlockEditableInputEventContext.': event property must have both add and remove accessors [D:\\source\\MyFirm\\Internal\\MyFirm.ContentManagement\\editing\\MyFirm.ContentManagement.Editing\\MyFirm.ContentManagement.Editing.csproj]\nD:\\source\\MyFirm\\Internal\\MyFirm.ContentManagement\\editing\\MyFirm.ContentManagement.Editing\\obj\\Debug\\net8.0\\generated\\System.Text.Json.SourceGeneration\\System.Text.Json.SourceGeneration.JsonSourceGenerator\\PickImageEventContext.PickImageEvent.g.cs(30,172): error CS0065: 'PickImageEventContext.': event property must have both add and remove accessors [D:\\source\\MyFirm\\Internal\\MyFirm.ContentManagement\\editing\\MyFirm.ContentManagement.Editing\\MyFirm.ContentManagement.Editing.csproj]\nD:\\source\\MyFirm\\Internal\\MyFirm.ContentManagement\\editing\\MyFirm.ContentManagement.Editing\\obj\\Debug\\net8.0\\generated\\System.Text.Json.SourceGeneration\\System.Text.Json.SourceGeneration.JsonSourceGenerator\\SlotEditorsInitEventContext.SlotEditorsInitEvent.g.cs(30,178): error CS0065: 'SlotEditorsInitEventContext.': event property must have both add and remove accessors [D:\\source\\MyFirm\\Internal\\MyFirm.ContentManagement\\editing\\MyFirm.ContentManagement.Editing\\MyFirm.ContentManagement.Editing.csproj]  \nD:\\source\\MyFirm\\Internal\\MyFirm.ContentManagement\\editing\\MyFirm.ContentManagement.Editing\\obj\\Debug\\net8.0\\generated\\System.Text.Json.SourceGeneration\\System.Text.Json.SourceGeneration.JsonSourceGenerator\\BlockEditableInputEventContext.BlockEditableInputEvent.g.cs(31,56): error CS1520: Method must have a return type [D:\\source\\MyFirm\\Internal\\MyFirm.ContentManagement\\editing\\MyFirm.ContentManagement.Editing\\MyFirm.ContentManagement.Editing.csproj]\nD:\\source\\MyFirm\\Internal\\MyFirm.ContentManagement\\editing\\MyFirm.ContentManagement.Editing\\obj\\Debug\\net8.0\\generated\\System.Text.Json.SourceGeneration\\System.Text.Json.SourceGeneration.JsonSourceGenerator\\BlockEditableInputEventContext.BlockEditableInputEvent.g.cs(31,56): error CS0501: '<invalid-global-code>.<invalid-global-code>(options)' must declare a body because it is not marked abstract, extern, or partial [D:\\source\\MyFirm\\Internal\\MyFirm.ContentManagement\\editing\\MyFirm.ContentManagement.Editing\\MyFirm.ContentManagement.Editing.csproj]\nD:\\source\\MyFirm\\Internal\\MyFirm.ContentManagement\\editing\\MyFirm.ContentManagement.Editing\\obj\\Debug\\net8.0\\generated\\System.Text.Json.SourceGeneration\\System.Text.Json.SourceGeneration.JsonSourceGenerator\\PickImageEventContext.PickImageEvent.g.cs(31,56): error CS1520: Method must have a return type [D:\\source\\MyFirm\\Internal\\MyFirm.ContentManagement\\editing\\MyFirm.ContentManagement.Editing\\MyFirm.ContentManagement.Editing.csproj]\nD:\\source\\MyFirm\\Internal\\MyFirm.ContentManagement\\editing\\MyFirm.ContentManagement.Editing\\obj\\Debug\\net8.0\\generated\\System.Text.Json.SourceGeneration\\System.Text.Json.SourceGeneration.JsonSourceGenerator\\PickImageEventContext.PickImageEvent.g.cs(31,56): error CS0501: '<invalid-global-code>.<invalid-global-code>(options)' must declare a body because it is not marked abstract, extern, or partial [D:\\source\\MyFirm\\Internal\\MyFirm.ContentManagement\\editing\\MyFirm.ContentManagement.Editing\\MyFirm.ContentManagement.Editing.csproj]\nD:\\source\\MyFirm\\Internal\\MyFirm.ContentManagement\\editing\\MyFirm.ContentManagement.Editing\\obj\\Debug\\net8.0\\generated\\System.Text.Json.SourceGeneration\\System.Text.Json.SourceGeneration.JsonSourceGenerator\\SlotEditorsInitEventContext.SlotEditorsInitEvent.g.cs(31,56): error CS1520: Method must have a return type [D:\\source\\MyFirm\\Internal\\MyFirm.ContentManagement\\editing\\MyFirm.ContentManagement.Editing\\MyFirm.ContentManagement.Editing.csproj]\nD:\\source\\MyFirm\\Internal\\MyFirm.ContentManagement\\editing\\MyFirm.ContentManagement.Editing\\obj\\Debug\\net8.0\\generated\\System.Text.Json.SourceGeneration\\System.Text.Json.SourceGeneration.JsonSourceGenerator\\SlotEditorsInitEventContext.SlotEditorsInitEvent.g.cs(31,56): error CS0501: '<invalid-global-code>.<invalid-global-code>(options)' must declare a body because it is not marked abstract, extern, or partial [D:\\source\\MyFirm\\Internal\\MyFirm.ContentManagement\\editing\\MyFirm.ContentManagement.Editing\\MyFirm.ContentManagement.Editing.csproj]\nD:\\source\\MyFirm\\Internal\\MyFirm.ContentManagement\\editing\\MyFirm.ContentManagement.Editing\\obj\\Debug\\net8.0\\generated\\System.Text.Json.SourceGeneration\\System.Text.Json.SourceGeneration.JsonSourceGenerator\\SlotInsertBlockEventContext.SlotInsertBlockEvent.g.cs(31,56): error CS1520: Method must have a return type [D:\\source\\MyFirm\\Internal\\MyFirm.ContentManagement\\editing\\MyFirm.ContentManagement.Editing\\MyFirm.ContentManagement.Editing.csproj]\nD:\\source\\MyFirm\\Internal\\MyFirm.ContentManagement\\editing\\MyFirm.ContentManagement.Editing\\obj\\Debug\\net8.0\\generated\\System.Text.Json.SourceGeneration\\System.Text.Json.SourceGeneration.JsonSourceGenerator\\SlotInsertBlockEventContext.SlotInsertBlockEvent.g.cs(31,56): error CS0501: '<invalid-global-code>.<invalid-global-code>(options)' must declare a body because it is not marked abstract, extern, or partial [D:\\source\\MyFirm\\Internal\\MyFirm.ContentManagement\\editing\\MyFirm.ContentManagement.Editing\\MyFirm.ContentManagement.Editing.csproj]\nD:\\source\\MyFirm\\Internal\\MyFirm.ContentManagement\\editing\\MyFirm.ContentManagement.Editing\\obj\\Debug\\net8.0\\generated\\System.Text.Json.SourceGeneration\\System.Text.Json.SourceGeneration.JsonSourceGenerator\\BlockActionMenuClickEventContext.BlockActionMenuClickEvent.g.cs(31,56): error CS1520: Method must have a return type [D:\\source\\MyFirm\\Internal\\MyFirm.ContentManagement\\editing\\MyFirm.ContentManagement.Editing\\MyFirm.ContentManagement.Editing.csproj]\nD:\\source\\MyFirm\\Internal\\MyFirm.ContentManagement\\editing\\MyFirm.ContentManagement.Editing\\obj\\Debug\\net8.0\\generated\\System.Text.Json.SourceGeneration\\System.Text.Json.SourceGeneration.JsonSourceGenerator\\BlockActionMenuClickEventContext.BlockActionMenuClickEvent.g.cs(31,56): error CS0501: '<invalid-global-code>.<invalid-global-code>(options)' must declare a body because it is not marked abstract, extern, or partial [D:\\source\\MyFirm\\Internal\\MyFirm.ContentManagement\\editing\\MyFirm.ContentManagement.Editing\\MyFirm.ContentManagement.Editing.csproj]\nD:\\source\\MyFirm\\Internal\\MyFirm.ContentManagement\\editing\\MyFirm.ContentManagement.Editing\\obj\\Debug\\net8.0\\generated\\System.Text.Json.SourceGeneration\\System.Text.Json.SourceGeneration.JsonSourceGenerator\\ClientEventContext.ClickEvent.g.cs(31,56): error CS1520: Method must have a return type [D:\\source\\MyFirm\\Internal\\MyFirm.ContentManagement\\editing\\MyFirm.ContentManagement.Editing\\MyFirm.ContentManagement.Editing.csproj]\nD:\\source\\MyFirm\\Internal\\MyFirm.ContentManagement\\editing\\MyFirm.ContentManagement.Editing\\obj\\Debug\\net8.0\\generated\\System.Text.Json.SourceGeneration\\System.Text.Json.SourceGeneration.JsonSourceGenerator\\ClientEventContext.ClickEvent.g.cs(31,56): error CS0501: '<invalid-global-code>.<invalid-global-code>(options)' must declare a body because it is not marked abstract, extern, or partial [D:\\source\\MyFirm\\Internal\\MyFirm.ContentManagement\\editing\\MyFirm.ContentManagement.Editing\\MyFirm.ContentManagement.Editing.csproj]\nD:\\source\\MyFirm\\Internal\\MyFirm.ContentManagement\\editing\\MyFirm.ContentManagement.Editing\\obj\\Debug\\net8.0\\generated\\System.Text.Json.SourceGeneration\\System.Text.Json.SourceGeneration.JsonSourceGenerator\\BlockActionMenuClickEventContext.BlockActionMenuClickEvent.g.cs(30,209): error CS0065: 'BlockActionMenuClickEventContext.': event property must have both add and remove accessors [D:\\source\\MyFirm\\Internal\\MyFirm.ContentManagement\\editing\\MyFirm.ContentManagement.Editing\\MyFirm.ContentManagement.Editing.csproj]\nD:\\source\\MyFirm\\Internal\\MyFirm.ContentManagement\\editing\\MyFirm.ContentManagement.Editing\\obj\\Debug\\net8.0\\generated\\System.Text.Json.SourceGeneration\\System.Text.Json.SourceGeneration.JsonSourceGenerator\\SlotInsertBlockEventContext.SlotInsertBlockEvent.g.cs(30,206): error CS0065: 'SlotInsertBlockEventContext.': event property must have both add and remove accessors [D:\\source\\MyFirm\\Internal\\MyFirm.ContentManagement\\editing\\MyFirm.ContentManagement.Editing\\MyFirm.ContentManagement.Editing.csproj]  \nD:\\source\\MyFirm\\Internal\\MyFirm.ContentManagement\\editing\\MyFirm.ContentManagement.Editing\\obj\\Debug\\net8.0\\generated\\System.Text.Json.SourceGeneration\\System.Text.Json.SourceGeneration.JsonSourceGenerator\\BlockEditableInputEventContext.BlockEditableInputEvent.g.cs(31,88): error CS0246: The type or namespace name 'options' could not be found (are you missing a using directive or an assembly reference?) [D:\\source\\MyFirm\\Internal\\MyFirm.ContentManagement\\editing\\MyFirm.ContentManagement.Editing\\MyFirm.ContentManagement.Editing.csproj]\nD:\\source\\MyFirm\\Internal\\MyFirm.ContentManagement\\editing\\MyFirm.ContentManagement.Editing\\obj\\Debug\\net8.0\\generated\\System.Text.Json.SourceGeneration\\System.Text.Json.SourceGeneration.JsonSourceGenerator\\PickImageEventContext.PickImageEvent.g.cs(31,79): error CS0246: The type or namespace name 'options' could not be found (are you missing a using directive or an assembly reference?) [D:\\source\\MyFirm\\Internal\\MyFirm.ContentManagement\\editing\\MyFirm.ContentManagement.Editing\\MyFirm.ContentManagement.Editing.csproj]\nD:\\source\\MyFirm\\Internal\\MyFirm.ContentManagement\\editing\\MyFirm.ContentManagement.Editing\\obj\\Debug\\net8.0\\generated\\System.Text.Json.SourceGeneration\\System.Text.Json.SourceGeneration.JsonSourceGenerator\\SlotEditorsInitEventContext.SlotEditorsInitEvent.g.cs(31,85): error CS0246: The type or namespace name 'options' could not be found (are you missing a using directive or an assembly reference?) [D:\\source\\MyFirm\\Internal\\MyFirm.ContentManagement\\editing\\MyFirm.ContentManagement.Editing\\MyFirm.ContentManagement.Editing.csproj]\nD:\\source\\MyFirm\\Internal\\MyFirm.ContentManagement\\editing\\MyFirm.ContentManagement.Editing\\obj\\Debug\\net8.0\\generated\\System.Text.Json.SourceGeneration\\System.Text.Json.SourceGeneration.JsonSourceGenerator\\SlotInsertBlockEventContext.SlotInsertBlockEvent.g.cs(31,85): error CS0246: The type or namespace name 'options' could not be found (are you missing a using directive or an assembly reference?) [D:\\source\\MyFirm\\Internal\\MyFirm.ContentManagement\\editing\\MyFirm.ContentManagement.Editing\\MyFirm.ContentManagement.Editing.csproj]\nD:\\source\\MyFirm\\Internal\\MyFirm.ContentManagement\\editing\\MyFirm.ContentManagement.Editing\\obj\\Debug\\net8.0\\generated\\System.Text.Json.SourceGeneration\\System.Text.Json.SourceGeneration.JsonSourceGenerator\\BlockActionMenuClickEventContext.BlockActionMenuClickEvent.g.cs(31,90): error CS0246: The type or namespace name 'options' could not be found (are you missing a using directive or an assembly reference?) [D:\\source\\MyFirm\\Internal\\MyFirm.ContentManagement\\editing\\MyFirm.ContentManagement.Editing\\MyFirm.ContentManagement.Editing.csproj]\nD:\\source\\MyFirm\\Internal\\MyFirm.ContentManagement\\editing\\MyFirm.ContentManagement.Editing\\obj\\Debug\\net8.0\\generated\\System.Text.Json.SourceGeneration\\System.Text.Json.SourceGeneration.JsonSourceGenerator\\ClientEventContext.ClickEvent.g.cs(31,75): error CS0246: The type or namespace name 'options' could not be found (are you missing a using directive or an assembly reference?) [D:\\source\\MyFirm\\Internal\\MyFirm.ContentManagement\\editing\\MyFirm.ContentManagement.Editing\\MyFirm.ContentManagement.Editing.csproj]\n  sample.Client -> D:\\source\\MyFirm\\Internal\\MyFirm.ContentManagement\\samples\\sample\\sample.Client\\bin\\Debug\\net8.0\\sample.Client.dll\n  sample.Client (Blazor output) -> D:\\source\\MyFirm\\Internal\\MyFirm.ContentManagement\\samples\\sample\\sample.Client\\bin\\Debug\\net8.0\\wwwroot\n  sample -> D:\\source\\MyFirm\\Internal\\MyFirm.ContentManagement\\samples\\sample\\sample\\bin\\Debug\\net8.0\\sample.dll\n\nWorkload updates are available. Run `dotnet workload list` for more information.\n\n *  The terminal process \"C:\\Program Files\\dotnet\\dotnet.exe 'build', 'D:\\source\\MyFirm\\Internal\\MyFirm.ContentManagement/MyFirm.ContentManagement.sln', '/property:GenerateFullPaths=true', '/consoleloggerparameters:NoSummary;ForceNoAlign'\" terminated with exit code: 1. \n *  Terminal will be reused by tasks, press any key to close it. \n```",
          "createdAt": "2024-11-15T02:10:33Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-11-15T02:10:33Z",
          "id": "IC_kwDODI9FZc6TsGdM"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Can confirm this is a bug which impacts all members using keyword identifiers. Here's a more involved example:\n\n```C#\npublic class @class\n{\n    public @class(string @string) \n    {\n        this.@string = @string;\n    }\n\n    public string @string { get; set; }\n}\n\n[JsonSerializable(typeof(@class))]\npublic partial class MyContext : JsonSerializerContext;\n```\n\nWe should eventually try to update the generator so that it handles escaped identifiers more comprehensively. In the meantime, it should be possible to work around the issue by doing something like:\n\n```C#\npublic class ClickEvent\n{\n  [JsonPropertyName(\"event\")]\n  public required string Event { get; set; }\n}\n```",
          "createdAt": "2024-11-15T10:04:55Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-11-15T10:04:55Z",
          "id": "IC_kwDODI9FZc6TulQb"
        },
        {
          "author": "burtonrodman",
          "body": "fortunately i controlled both side of the protocol so i was able to work around by renaming the property.  thanks!",
          "createdAt": "2024-11-15T14:58:28Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-11-15T14:58:28Z",
          "id": "IC_kwDODI9FZc6Tw8ZH"
        }
      ],
      "totalCount": 4,
      "endCursor": "Y3Vyc29yOnYyOpHOk8PGRw=="
    },
    "url": "https://github.com/dotnet/runtime/issues/109854",
    "title": "JsonSerializerContext generated source breaks for property named \"@event\""
  },
  {
    "author": "cpiber",
    "labels": [
      "api-suggestion",
      "area-System.Text.Json"
    ],
    "createdAt": "2024-11-21T13:44:33Z",
    "body": "### Background and motivation\n\n`ReferenceHandler.Preserve` is very useful when references to the same object need to be sent. However, it easily breaks, for example with `Tuple<>`, since it does not have a constructor of the expected form.\n\nIt would be useful, if the user could opt-in to reference preservation only for specific types. I read a little through the implementation, and it seems like `JsonConverter.CanHaveMetadata` could already do what I need, but it is marked as internal and thus cannot be influenced by the user.\n\n### API Proposal\n\n-\n\n\n### API Usage\n\n```csharp\nclass MyReferenceConverter : ObjectConverterFactory {\n  public override JsonConverter CreateConverter(Type typeToConvert, JsonSerializerOptions options) {\n    var converter = base.CreateConverter(typeToConvert, options);\n    converter.CanHaveMetadata = typeToConvert != typeof(Tuple<>);\n    return converter;\n  }\n}\n```\n\n\n### Alternative Designs\n\n_No response_\n\n### Risks\n\nThe property setter should probably only allow setting to `false`, as reference preserving on value types is not supported, and the converter must already support writing metadata, as implemented by `ObjectDefaultConverter`.",
    "number": 110048,
    "reactions": {
      "hasNextPage": false,
      "nodes": [],
      "totalCount": 0,
      "endCursor": null
    },
    "updatedAt": "2024-12-04T12:35:05Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": "dotnet-policy-service",
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. -->",
          "createdAt": "2024-11-21T13:45:00Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-11-21T13:45:00Z",
          "id": "IC_kwDODI9FZc6UfNiI"
        },
        {
          "author": "cpiber",
          "body": "NewtonSoft appears to support this use-case via an attribute: https://www.newtonsoft.com/json/help/html/preserveobjectreferences.htm#IsReference",
          "createdAt": "2024-12-04T12:35:04Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-12-04T12:35:04Z",
          "id": "IC_kwDODI9FZc6WCdwF"
        }
      ],
      "totalCount": 2,
      "endCursor": "Y3Vyc29yOnYyOpHOlgncBQ=="
    },
    "url": "https://github.com/dotnet/runtime/issues/110048",
    "title": "[API Proposal]: System.Json reference handling allow per-type customization"
  },
  {
    "author": "emonino",
    "labels": [
      "bug",
      "area-System.Text.Json"
    ],
    "createdAt": "2024-12-05T19:07:53Z",
    "body": "### Description\n\nSystem.Text.Json.JsonSerializer.DeserializeAsync<T> fails with exception\n**System.Text.Json.JsonException: 'The JSON value could not be converted to STJDeserializationException.DeserializeDto. Path: $[57] | LineNumber: 0 | BytePositionInLine: 19343.'**\n\nDeserializing the same data into the same object works when using the synchronous deserialization method, _JsonSerializer.Deserialize<T>_.\n\nAsynchronous deserialization, _JsonSerializer.DeserializeAsync<T>_, works if the object T does not contain nullable parent types.\n\n### Reproduction Steps\n\nI created a GitHub repo with the minimum classes to fully reproduce the behavior I am seeing - https://github.com/emonino/STJDeserializationException.\n\nWhen we try to deserialize data into a simple object with a nullable parent type, [DeserializeDto](https://github.com/emonino/STJDeserializationException/blob/main/STJDeserializationException/DeserializeDto.cs), deserialization fails with a System.Text.Json.JsonException. For example:  \n**System.Text.Json.JsonException: 'The JSON value could not be converted to STJDeserializationException.DeserializeDto. Path: $[57] | LineNumber: 0 | BytePositionInLine: 19343.'**\n\nThe exact method that throws is `await JsonSerializer.DeserializeAsync<List<DeserializeDto>>(stream, options)`.\n\nHowever, if we deserialize the exact same data into the same object using the synchronous deserialization method, deserialization works as expected. For example, the below method works:  \n`JsonSerializer.Deserialize<List<DeserializeDto>>(dataStr)`\n\nI can also successfully use System.Text.Json if I modify the object I am trying to deserialize into to not include a nullable parent object as seen in [NonNullable.DeserializeDto](https://github.com/emonino/STJDeserializationException/blob/main/STJDeserializationException/NonNullableDeserializeDto.cs). Note that the only difference between [DeserializeDto](https://github.com/emonino/STJDeserializationException/blob/main/STJDeserializationException/DeserializeDto.cs) and [NonNullable.DeserializeDto](https://github.com/emonino/STJDeserializationException/blob/main/STJDeserializationException/NonNullableDeserializeDto.cs) is that the Start parent object is nullable in DeserializeDto.\n\nIn other words, this code also works as expected:  \n`await JsonSerializer.DeserializeAsync<List<STJDeserializationException.NonNullable.DeserializeDto>>(stream, options)`\n\n### Expected behavior\n\nAsynchronous deserialization to nullable objects should succeed\n\n### Actual behavior\n\nAsynchronous deserialization fails with exception similar to  \n**System.Text.Json.JsonException: 'The JSON value could not be converted to STJDeserializationException.DeserializeDto. Path: $[57] | LineNumber: 0 | BytePositionInLine: 19343.'**\n\n### Regression?\n\nWe first noticed this error after upgrading from System.Text.Json 7.0.4 to 8.0.2. We have since upgraded to System.Text.Json 9.0.0. The exception is thrown less often now, but can still occur for large data sets.\n\n### Known Workarounds\n\nUsing JsonSerializer.Deserialize or making parent objects non-nullable.\n\n### Configuration\n\n_No response_\n\n### Other information\n\n_No response_",
    "number": 110450,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "EYES",
          "createdAt": "2025-06-18T12:10:23Z",
          "user": "warappa"
        }
      ],
      "totalCount": 1,
      "endCursor": "Y3Vyc29yOnYyOpHODELs3w=="
    },
    "updatedAt": "2024-12-06T16:04:17Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": "dotnet-policy-service",
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. -->",
          "createdAt": "2024-12-05T19:08:28Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-12-05T19:08:28Z",
          "id": "IC_kwDODI9FZc6WRmYc"
        },
        {
          "author": "eiriktsarpalis",
          "body": "I can reproduce this deterministically in .NET 8. Here's a minimal repro:\n```csharp\nusing System.Text;\nusing System.Text.Json;\n\nstring json = \"\"\"\n    [\n      {\n        \"Start\": {\n          \"Timestamp\": \"2024-12-05T00:00:00-05:00\",\n          \"Value\": 100.8728,\n          \"Questionable\": null,\n          \"Substituted\": null,\n          \"Annotated\": null,\n          \"SystemStateCode\": null,\n          \"DigitalStateName\": null\n        }\n      },\n      {\n        \"Start\": {\n          \"Value\": 100.13499\n        }\n      }\n    ]\n    \"\"\";\n\nJsonSerializerOptions options = new() { DefaultBufferSize = 1 };\nJsonSerializer.Deserialize<List<DeserializeDto>>(json, options); // success\n\nusing MemoryStream stream = new(Encoding.UTF8.GetBytes(json));\nawait JsonSerializer.DeserializeAsync<List<DeserializeDto>>(stream, options);\n// System.Text.Json.JsonException: 'The JSON value could not be converted to DeserializeDto.\n// Path: $[1] | LineNumber: 11 | BytePositionInLine: 3.' \n\npublic class DeserializeDto\n{\n    public Start? Start { get; set; }\n}\n\npublic struct Start // changing to class resolves the issue\n{\n    public float? Value { get; set; }\n}\n```\nAlthough I didn't have any luck reproducing the issue in .NET 9. This is likely a bug with the state machine STJ implements for async deserialization. Although I doubt this meets the bar for servicing in .NET 8 or .NET 9, we should consider examining this reproduction to make sure that the current version of STJ isn't susceptible to other instances of the same bug.",
          "createdAt": "2024-12-06T09:47:45Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-12-06T09:47:45Z",
          "id": "IC_kwDODI9FZc6WXSIL"
        },
        {
          "author": "eiriktsarpalis",
          "body": "I should add that these types of bugs are actually fairly deterministic once you fix the inputs and configuration. If you could provide us with a minimal reproduction like the above that demonstrates the same crash of .NET 9, that would be very helpful.",
          "createdAt": "2024-12-06T10:36:39Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-12-06T10:36:39Z",
          "id": "IC_kwDODI9FZc6WXpUi"
        },
        {
          "author": "emonino",
          "body": "I apologize if my initial post was not clear. I was able to deterministically reproduce and included the models and code in a repo here - https://github.com/emonino/STJDeserializationException. \n\nThe bug is definitely less prevalent in .NET 9, but I can still hit it with a large enough data input. My repo uses .NET 9.",
          "createdAt": "2024-12-06T13:20:14Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-12-06T13:20:14Z",
          "id": "IC_kwDODI9FZc6WZaYT"
        },
        {
          "author": "eiriktsarpalis",
          "body": "For whatever reason I couldn't reproduce the issue with your example, however after a few random runs I was able to condense a minimal reproduction that works with .NET 9:\n\n```C#\nusing System.Text;\nusing System.Text.Json;\n\nstring json = \"\"\"\n    [{\"Start\":{\"Padding1\":\"x\",\"Value\":100.86587,\"Padding2\":null}},{\"Start\":{\"Padding1\":\"xxxxx\",\"Value\":100.08407,\"Padding2\":null}}]\n    \"\"\";\n\n// the following works\nJsonSerializer.Deserialize<List<DeserializeDto>>(json);\n\n// but this fails with System.Text.Json.JsonException: The JSON value could not be converted to DeserializeDto.\nJsonSerializerOptions options = new() { DefaultBufferSize = 1 };\nusing MemoryStream stream = new(Encoding.UTF8.GetBytes(json));\nawait JsonSerializer.DeserializeAsync<List<DeserializeDto>>(stream, options);\n\npublic class DeserializeDto\n{\n    public Start? Start { get; set; }\n}\n\npublic struct Start // Changing to a class removes the error\n{\n    public float? Value { get; set; }\n}\n```",
          "createdAt": "2024-12-06T16:04:14Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-12-06T16:15:56Z",
                "user": "emonino"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-06-18T09:23:11Z",
                "user": "warappa"
              },
              {
                "content": "EYES",
                "createdAt": "2025-08-05T11:48:16Z",
                "user": "warappa"
              }
            ],
            "totalCount": 3,
            "endCursor": "Y3Vyc29yOnYyOpHOEdJkpQ=="
          },
          "updatedAt": "2024-12-06T16:04:14Z",
          "id": "IC_kwDODI9FZc6Watxv"
        }
      ],
      "totalCount": 5,
      "endCursor": "Y3Vyc29yOnYyOpHOlmrcbw=="
    },
    "url": "https://github.com/dotnet/runtime/issues/110450",
    "title": "System.Text.Json.JsonException thrown when deserializing asynchronously to nullable types"
  },
  {
    "author": "ltbyun",
    "labels": [
      "enhancement",
      "area-System.Text.Json",
      "help wanted"
    ],
    "createdAt": "2024-12-12T03:16:22Z",
    "body": "### Description\n\nwhile deserialize Dictionary<string, int> with a custom StringJsonConverter which is used to convert null to empty string , it throws:\n\n_Unhandled exception. System.NotSupportedException: The type 'System.String' is not a supported dictionary key using converter of type 'StringJsonConverter'. Path: $.Pages['Chapter 1'] | LineNumber: 4 | BytePositionInLine: 20.\n ---> System.NotSupportedException: The type 'System.String' is not a supported dictionary key using converter of type 'StringJsonConverter'._\n\nif i remove StringJsonConverter, it works fine.\n\nthe environment is\n```\n.NET SDK:\n Version:           8.0.404\n Commit:            7b190310f2\n Workload version:  8.0.400-manifests.996cfe54\n MSBuild version:   17.11.9+a69bbaaf5\n OS Name:     Windows\n OS Version:  10.0.19044\n OS Platform: Windows\n RID:         win-x64\n Base Path:   C:\\Program Files\\dotnet\\sdk\\8.0.404\\\n```\n\nthe full code is here:\n```C#\nusing System.Text.Json;\nusing System.Text.Json.Serialization;\n\nvar options = new JsonSerializerOptions() { TypeInfoResolver = MyJsonSerializerContext.Default };\n\n// everything works fine if I remove the line below\noptions.Converters.Add(new StringJsonConverter());\n\nvar book = JsonSerializer.Deserialize<Book>(\n    \"\"\"\n    {\n        \"Title\": \"Philosopher's Stone\",\n        \"Author\": \"J.K.Rowling\",\n        \"Pages\": {\n            \"Chapter 1\": 10,\n            \"Chapter 2\": 20\n        }\n    }\n    \"\"\", options);\nConsole.WriteLine(book!.Pages[\"Chapter 1\"]);\n\npublic class Book\n{\n    public string Title { get; set; } = \"\";\n    public string Author { get; set; } = \"\";\n    public Dictionary<string, int> Pages { get; set; } = new Dictionary<string, int>();\n}\n\n/// <summary>\n/// read and write null string as empty string\n/// </summary>\npublic class StringJsonConverter : JsonConverter<string>\n{\n    public override bool HandleNull => true;\n\n    public override string Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)\n    {\n        var s = reader.GetString();\n        return s == null ? string.Empty : s.Trim();\n    }\n\n    public override void Write(Utf8JsonWriter writer, string value, JsonSerializerOptions options)\n    {\n        writer.WriteStringValue(string.IsNullOrEmpty(value) ? string.Empty : value);\n    }\n}\n\n[JsonSerializable(typeof(Book))]\npublic partial class MyJsonSerializerContext : JsonSerializerContext;\n```\n\n### Reproduction Steps\n\n1. create an empty console app\n2. copy the code to the program.cs\n3. run\n\n### Expected behavior\n\nno exception throws\n\n### Actual behavior\n\nthrows System.NotSupportedException\n\n### Regression?\n\n_No response_\n\n### Known Workarounds\n\n_No response_\n\n### Configuration\n\n_No response_\n\n### Other information\n\n_No response_",
    "number": 110634,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-04-11T15:52:12Z",
          "user": "ricardoboss"
        }
      ],
      "totalCount": 1,
      "endCursor": "Y3Vyc29yOnYyOpHODBHcAg=="
    },
    "updatedAt": "2025-01-07T12:33:27Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": "dotnet-policy-service",
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. -->",
          "createdAt": "2024-12-12T03:16:48Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-12-12T03:16:48Z",
          "id": "IC_kwDODI9FZc6XQn5x"
        },
        {
          "author": "eiriktsarpalis",
          "body": "In order to have a custom converter support dictionary key serialization, you need to additional override the [`WriteAsPropertyName`](https://learn.microsoft.com/en-us/dotnet/api/system.text.json.serialization.jsonconverter-1.writeaspropertyname?view=net-9.0) and [`ReadAsPropertyName`](https://learn.microsoft.com/en-us/dotnet/api/system.text.json.serialization.jsonconverter-1.readaspropertyname?view=net-9.0) methods that specialize at serializing to and from JSON property names.",
          "createdAt": "2024-12-12T10:01:40Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-04-18T05:10:47Z",
                "user": "0xfeeddeadbeef"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOEO0W7g=="
          },
          "updatedAt": "2024-12-12T10:01:40Z",
          "id": "IC_kwDODI9FZc6XTUo2"
        },
        {
          "author": "ltbyun",
          "body": "> In order to have a custom converter support dictionary key serialization, you need to additional override the [`WriteAsPropertyName`](https://learn.microsoft.com/en-us/dotnet/api/system.text.json.serialization.jsonconverter-1.writeaspropertyname?view=net-9.0) and [`ReadAsPropertyName`](https://learn.microsoft.com/en-us/dotnet/api/system.text.json.serialization.jsonconverter-1.readaspropertyname?view=net-9.0) methods that specialize at serializing to and from JSON property names.\n\nyou are right, thank you",
          "createdAt": "2024-12-14T00:54:45Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-12-14T00:54:45Z",
          "id": "IC_kwDODI9FZc6XjQPj"
        },
        {
          "author": "eiriktsarpalis",
          "body": "We should improve the error message so that users are made aware of the required overrides.",
          "createdAt": "2024-12-14T09:23:11Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-12-14T09:23:11Z",
          "id": "IC_kwDODI9FZc6Xk2tz"
        },
        {
          "author": "dotnet-policy-service",
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. -->",
          "createdAt": "2025-01-06T17:31:19Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-01-06T17:31:19Z",
          "id": "IC_kwDODI9FZc6ZZbfN"
        }
      ],
      "totalCount": 5,
      "endCursor": "Y3Vyc29yOnYyOpHOmWW3zQ=="
    },
    "url": "https://github.com/dotnet/runtime/issues/110634",
    "title": "Json source generation do not support custom JsonConverter on the key of a Dictionary"
  },
  {
    "author": "akilin",
    "labels": [
      "area-System.Text.Json"
    ],
    "createdAt": "2024-12-16T12:10:34Z",
    "body": "Hi, I would like to ask you to revisit a discussion around `required` properties and `JsonIgnoreCondition.WhenWritingNull` from https://github.com/dotnet/runtime/issues/76527\n\nMy use case is fairly simple.\nI have an optional field `int? ForeignKey`.\nI mark it as `required` so it is always explicitly set in the c# code.\nI want my json to be as small as possible, so I use `DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull`.\n\nTo me, all of the decisions described above seem like very reasonable defaults, which result in the next code:\n\n```cs\nusing System.Text.Json;\nusing System.Text.Json.Serialization;\n\nvar obj = new Foo { ForeignKey = null };\nvar opt = new JsonSerializerOptions { DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull };\n\nvar res = JsonSerializer.Serialize(obj, opt);\nvar obj2 = JsonSerializer.Deserialize<Foo>(res, opt);\n\npublic record Foo\n{\n    public required int? ForeignKey { get; set; }\n}\n```\n\nWhich does not work and fails on the `Deserialize` step with:\n\n```\nSystem.Text.Json.JsonException: 'JSON deserialization for type 'Foo' was missing required properties including: 'ForeignKey'.'\n```\n\n\nIn the issue I linked, a person mentions that this can be made to work by writing some additional code that uses the contract model.\n\n`JsonSerializer` can easily serialize this data, but is unable to deserialize it without writing some additional code, which to me feels like there is some functionality missing.\n\nI would ask you to consider again the addition of an option that will allow specifying the behaviour when working with `required` keyword as was originally proposed by @asleire.\n\nThe solution he proposed was: \n```\nAdding an option in JsonSerializerOptions to control the handling of the required modifier:\n\nOption 1: Make required properties required in the JSON contract (current dotnet behavior)\nOption 2: Make required properties required in the JSON contract for non-nullable properties\nOption 3: Ignore the required modifier, making the properties optional (effectively pre-.NET 7 behavior)\n```\n",
    "number": 110733,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-12-16T22:34:55Z",
          "user": "asleire"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-12-19T18:45:19Z",
          "user": "ohJohny"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2024-12-23T01:48:50Z",
          "user": "LuohuaRain"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-04-04T18:32:54Z",
          "user": "scott-dak"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-04-12T18:03:45Z",
          "user": "dsherret"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-05-19T13:36:03Z",
          "user": "MrAntix"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-05-19T13:55:12Z",
          "user": "Dreamescaper"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-05-29T09:21:50Z",
          "user": "thomaslevesque"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-06-04T15:35:33Z",
          "user": "RMotive"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-06-10T12:04:23Z",
          "user": "Rachvel"
        }
      ],
      "totalCount": 10,
      "endCursor": "Y3Vyc29yOnYyOpHODDjBTA=="
    },
    "updatedAt": "2025-05-31T07:29:41Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": "elgonzo",
          "body": ">Hi, I would like to ask you to revisit a discussion\n\nPlaying devils advocate, what has changed or what are new arguments that would make revisiting the linked discussion possibly lead to a different conclusion?",
          "createdAt": "2024-12-16T14:42:11Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-12-16T15:41:24Z",
                "user": "eiriktsarpalis"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-08-16T22:49:47Z",
                "user": "Donaut"
              }
            ],
            "totalCount": 2,
            "endCursor": "Y3Vyc29yOnYyOpHOEeh3sA=="
          },
          "updatedAt": "2024-12-16T14:42:11Z",
          "id": "IC_kwDODI9FZc6Xvfsk"
        },
        {
          "author": "akilin",
          "body": "I don't think anything has changed, but I do feel like maybe the original issue did not get enough attention.\nIt was a discussion between 2 people. One was for the change, the other against it. The person against was one of the maintainers, so his opinion carried more weight (which is fair) and the issue was closed.\n\n C# 11 was still not out at the time when the original issue was created, so not many people were using `required` keyword/ not many were affected by this. Maybe more people would be interested in the discussion now that this feature has been around for a while.\n\nRegarding new arguments - I don't think I have any new technical ones, that were not covered by the previous issue. \n\nMy main argument (the one I feel like wasn't covered in the first issue) would be that current behavior breaks my internal (possibly wrong) assumption, that given a Serializer & a set of options, I should be able to successfully perform a `c# object => json => c# object` roundtrip arriving back to the original data without having to write any additional code.\n\nOtherwise it feels a lot like:\n![Image](https://github.com/user-attachments/assets/c0917d83-6c68-471f-bac0-4b85e43c8bdf)\n\n\n\n\n\n\n",
          "createdAt": "2024-12-16T15:51:52Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_DOWN",
                "createdAt": "2024-12-16T15:52:08Z",
                "user": "eiriktsarpalis"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-12-16T15:53:43Z",
                "user": "ohJohny"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-12-20T19:29:30Z",
                "user": "mnmr"
              },
              {
                "content": "THUMBS_DOWN",
                "createdAt": "2024-12-31T23:40:19Z",
                "user": "chrisoverzero"
              }
            ],
            "totalCount": 4,
            "endCursor": "Y3Vyc29yOnYyOpHOEAsT3Q=="
          },
          "updatedAt": "2024-12-16T15:51:52Z",
          "id": "IC_kwDODI9FZc6XwMcP"
        },
        {
          "author": "eiriktsarpalis",
          "body": "> I mark it as required so it is always explicitly set in the c# code.\n\nIf it needs to be explicitly set to `null` on the C# side, why should this concern not apply when reading (potentially untrusted) JSON? The deserializer will always try to honor the construction contract of the type, and this includes requiring anything marked `required`.\n\nFundamentally, required nullable properties and `JsonIgnoreCondition.WhenWritingNull` are mutually incompatible settings from a roundtripping perspective. My recommendation would be to model your DTOs differently so that it suits your serialization requirements.\n\n> I would ask you to consider again the addition of an option that will allow specifying the behaviour when working with required keyword as was originally proposed\n\nThere's only so many knobs we can add to a serializer before we lose the battle of complexity. For scenaria that explicitly violate contracts of types we offer customization escape hatches like custom converters or contract customizers. Here's a nice reusable solution that ChatGPT wrote for me when I asked it:\n\n```C#\nusing System.Reflection;\nusing System.Text.Json;\nusing System.Text.Json.Serialization.Metadata;\n\nnamespace CustomJsonAttributes\n{\n    /// <summary>\n    /// Custom attribute to indicate that a property is not required for JSON deserialization.\n    /// </summary>\n    [AttributeUsage(AttributeTargets.Property, AllowMultiple = false)]\n    public class JsonNotRequiredAttribute : Attribute\n    {\n    }\n\n    /// <summary>\n    /// Example model with properties using the JsonNotRequiredAttribute.\n    /// </summary>\n    public class SampleModel\n    {\n        public required string RequiredProperty { get; set; } // This will be required by default\n\n        [JsonNotRequired]\n        public required string OptionalProperty { get; set; } // This will not be required\n\n        [JsonNotRequired]\n        public required int? OptionalInt { get; set; } // This will also not be required\n    }\n\n    /// <summary>\n    /// Example of using the custom contract resolver and deserializing JSON.\n    /// </summary>\n    public class Program\n    {\n        public static void Main(string[] args)\n        {\n            static void ApplyNotRequiredAttribute(JsonTypeInfo typeInfo)\n            {\n                foreach (var property in typeInfo.Properties)\n                {\n                    // Check if the property has the JsonNotRequiredAttribute\n                    var propertyInfo = property.AttributeProvider as PropertyInfo;\n                    if (propertyInfo != null && propertyInfo.GetCustomAttribute<JsonNotRequiredAttribute>() != null)\n                    {\n                        // Disable IsRequired for this property\n                        property.IsRequired = false;\n                    }\n                }\n            }\n\n            var typeInfoResolver = new DefaultJsonTypeInfoResolver().WithAddedModifier(ApplyNotRequiredAttribute);\n            var options = new JsonSerializerOptions { TypeInfoResolver = typeInfoResolver };\n\n            string json = \"{ \\\"RequiredProperty\\\": \\\"Some value\\\" }\"; // Notice OptionalProperty is missing\n\n            try\n            {\n                var model = JsonSerializer.Deserialize<SampleModel>(json, options);\n                Console.WriteLine(\"Deserialization succeeded.\");\n                Console.WriteLine($\"RequiredProperty: {model.RequiredProperty}\");\n                Console.WriteLine($\"OptionalProperty: {model.OptionalProperty}\"); // Should be null\n                Console.WriteLine($\"OptionalInt: {model.OptionalInt}\"); // Should be null\n            }\n            catch (JsonException ex)\n            {\n                Console.WriteLine(\"Deserialization failed: \" + ex.Message);\n            }\n        }\n    }\n}\n```",
          "createdAt": "2024-12-16T15:56:47Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-12-16T15:56:47Z",
          "id": "IC_kwDODI9FZc6XwPrX"
        },
        {
          "author": "eiriktsarpalis",
          "body": "> Otherwise it feels a lot like:\n\nPutting it in a nice meme template doesn't make it true. No serializer can guarantee that every type can be round tripped, and this is doubly true once you start configuring it (especially when `JsonIgnoreCondition` gets involved!).",
          "createdAt": "2024-12-16T15:59:05Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-12-16T15:59:05Z",
          "id": "IC_kwDODI9FZc6XwRDA"
        },
        {
          "author": "akilin",
          "body": "I think everything you said makes a lot of sense.\nI mostly agree with everything you wrote.\nBut only if we are talking about the `JsonRequiredAttribute`.\n\nThe problem is, In my opinion, the `required` keyword should not have been equated to `JsonRequiredAttribute`. But changing this would be a breaking change, and is much less likely to happen, so that is why I am asking for a property to at least allow the users to configure this behavior.\n\nThe `required` keyword, is a way of specifying that a property or field is required to be set during object initialization, forcing the instance creator to provide an initial value for the member in an object initializer at the creation site. [link](https://github.com/dotnet/csharplang/blob/main/proposals/csharp-11.0/required-members.md#summary)\n\nYou use the required keyword to force callers to set the value of a property or field using an object initializer. Required properties don't need to be set as constructor parameters. The compiler ensures all callers initialize those values. [link](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/object-and-collection-initializers#object-initializers-with-the-required-modifier)\n\nIt's about allowing you to provide the property values via object initializer, and compiler ensuring that you do so.\nIt's a compile-time feature.\nIn my opinion, ensuring that a property appears in an object initializer and ensuring that a property is required for JSON deserialization are separate matters. The latter is covered by `JsonRequiredAttribute`.\n\nI think if a different keyword would have been used, like, for example `init` (which is already taken, I know) then the connection with `JsonRequiredAttribute` would have never been made and this problem would not exist. Because apart from having the word `required` in the name - they have nothing in common.\n\nAs an example let's take a look at two classes:\n\n```cs\npublic class Old\n{\n    public int? ForeignKey { get; set; }\n    \n    public Old(int? foreignKey){\n        ForeignKey = foreignKey;\n    }\n}\n\npublic class New\n{\n    public required int? ForeignKey { get; set; }\n}\n```\n\nThis is what in my opinion the `required` keyword was supposed to improve/simplify.\nBoth classes are equivalent from a developer perspective in a sense that they have a single field that is required, and only differ in how you will be providing this required field (ctor vs object initialiser).\nAt compile time both `ForeignKey` properties are required from compiler perspective (as in you can not create an instance of the class without explicitly providing a value). The only thing that differs is how you will be providing this value (ctor vs object initialiser).\n\nYet only one of the two will survive a Serialization/Deserialization process described in this issue.\nThis is the part I don't get. Why is one considered to be more/less required than the other?\nThe only thing changed by the `required` keyword is that it's required via object initialiser instead of a constructor.\nIt is not any more/less required compared to the other. It's just an unfortunate name.\n\n---\n\nI will now try to answer your points one by one\n\n>If it needs to be explicitly set to null on the C# side, why should this concern not apply when reading (potentially untrusted) JSON? The deserializer will always try to honor the construction contract of the type, and this includes requiring anything marked required.\n\nI believe this one is covered above.\n\n\n>Fundamentally, required nullable properties and JsonIgnoreCondition.WhenWritingNull are mutually incompatible settings from a roundtripping perspective.\n\nIf we are talking about `JsonRequiredAttribute` then I mostly agree with you.\nAs the name implies only `ignore when writing null` and has nothing to do with reading.\n`JsonRequiredAttribute` requires you to implicitly mark the property with that attribute, so that would not affect people who don't explicitly mark their properties.\n\nWith introduction of `required` keyword and it currently being equated to `JsonRequiredAttribute`, every time I want to initialize my fields via object initializer I am now opting into them being treated as marked with `JsonRequiredAttribute`. \nDue to this I think there should be a mirror option that allows users you to configure the read behaviour to match the write one.\nIf I can say `if property is null, just skip it` when writing, then I should be able to say `when property not present, set it to null` when reading.\n\n>My recommendation would be to model your DTOs differently so that it suits your serialization requirements.\n\nIt's very common to have a relationship that is optional in the database, which is represented as a nullable numeric property in your c# model. Not much wiggle room here when modeling DTOs, in my opinion.\nWe are living in times where the cloud is king, and you pay for what you use, including the network. So having a smaller JSON payload can be seen on your cloud bill and for some that dictates their serialization requirements.\n\n>There's only so many knobs we can add to a serializer before we lose the battle of complexity. \n\nI understand and agree with the sentiment, but this does not seem like a change that will bring a lot of complexity with it.\n(and if it was up to me - I would stop equating `required` with `JsonRequiredAttribute` which would reduce complexity)\n\n>No serializer can guarantee that every type can be round tripped, and this is doubly true once you start configuring it (especially when JsonIgnoreCondition gets involved!).\n\nI understand and agree with the sentiment, but I would say that this should be reserved for some of the more complex cases. Where you have some weird/complex model, or some rare edge cases.\nIn this case, I just want to initialize the properties via object initializers and want my JSON to be small.\nI think this should just work out of the box, without requiring any additional code.\n",
          "createdAt": "2024-12-16T18:51:39Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-12-16T19:14:25Z",
          "id": "IC_kwDODI9FZc6XxthK"
        },
        {
          "author": "eiriktsarpalis",
          "body": "> The required keyword, is a way of specifying that a property or field is required to be set during object initialization, forcing the instance creator to provide an initial value for the member in an object initializer at the creation site.\n\n> (and if it was up to me - I would stop equating required with JsonRequiredAttribute which would reduce complexity)\n\nHaving the serializer honor the `required` keyword is not simply a matter of convention. `required` members form an essential part of a type's contract, and initializing instances that bypass it can result in unexpected behavior when invoking its methods. BinaryFormatter is famously insecure because it bypasses constructors and directly writes to private fields -- also violating type contracts.\n\nOn the other hand, STJ tries to be secure by default. Which also means that the serializer does not try to interact with user types in ways that you couldn't do if you were writing the serialization logic by hand. There are, of course, ways in which this can be worked around as illustrated previously, but this is not something we're going to be offering out of the box.",
          "createdAt": "2024-12-16T19:24:10Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-12-16T19:24:10Z",
          "id": "IC_kwDODI9FZc6Xx8Gq"
        },
        {
          "author": "akilin",
          "body": ">The required keyword, is a way of specifying that a property or field is required to be set during object initialization, forcing the instance creator to provide an initial value for the member in an object initializer at the creation site.\n\nThe way I understand it, in c# `object initialization` is not a blank term for any object creation.\n[Object initializer](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/object-and-collection-initializers#object-initializers) is a language feature that allows you to assign values to any accessible fields or properties of an object at creation time without having to invoke a constructor followed by lines of assignment statements.\n\nSo when the `required` keywords specification says that \n> a property or field is required to be set during object initialization, forcing the instance creator to provide an initial value for the member in an object initializer at the creation site\n\nThe keyword `required` in c# simply means that you will need to provide the value by using the {} syntax.\n\nIf I am to apply this language to the `Old` class from my code snippet, it would match exactly, just replacing the `object initializer` part to  `constructor`.\n> a single constructor is forcing the instance creator to provide an initial value for the member in an object constructor at the creation site.\n\nThat's it. The presence of the `required` keyword does not make the field any more or less required than having it be a constructor parameter. It simply means that you will need to provide them by using the `{}` syntax.\n\nIn this example\n```cs\npublic class Old\n{\n    public int? ForeignKey { get; set; }\n    \n    public Old(int? foreignKey){\n        ForeignKey = foreignKey;\n    }\n}\n\npublic class New\n{\n    public required int? ForeignKey { get; set; }\n}\n```\nfrom c# language perspective, the `ForeignKey` property in `New` class is no more required than the one from the `Old` class.\n\n* Both properties must be explicitly provided every time you create a new class instance.\n* Both properties allow the same range of values (any integer or null).\n\nThe only difference is how you will be providing this property. \n\nFor `Old` it will be via constructor. For `New` it will be via object initializer.\nNeither of the properties is more or less required than the other.\n\nBut only one of the two will survive a Serialization/Deserialization process described in this issue.\n",
          "createdAt": "2024-12-16T21:45:02Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-12-16T21:58:34Z",
          "id": "IC_kwDODI9FZc6Xzkjg"
        },
        {
          "author": "akilin",
          "body": "I would like to ask you to explain why the `Old` class in my example works while the `New` one does not (when using ignore writing nulls).\nIn my opinion, they have the same instantiation requirements.\nIn c# language you must provide a value for the `ForeignKey` property, or the code won't compile for both classes.\nIn my opinion, they have the same `requiredness` level. The only thing that differs is the way in which this required data will be provided.\nIn my opinion either both should work, or both should be failing. (I lean towards both working).\n\n",
          "createdAt": "2024-12-16T21:52:30Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-12-16T21:52:30Z",
          "id": "IC_kwDODI9FZc6XzpQ_"
        },
        {
          "author": "eiriktsarpalis",
          "body": "> The way I understand it, in c# `object initialization` is not a blank term for any object creation.\n\n> The keyword required in c# simply means that you will need to provide the value by using the {} syntax.\n\nSo? This doesn't mean that if you don't use object initializer syntax you can skip setting required members. It's a mandatory part of the contract.\n\n> I would like to ask you to explain why the `Old` class in my example works while the `New` one does not (when using ignore writing nulls).\n\nSee [this section on non-optional constructor parameters](https://devblogs.microsoft.com/dotnet/system-text-json-in-dotnet-9/#respecting-non-optional-constructor-parameters). TL;DR not treating constructor parameters as required is a historic bug that we unfortunately can't fix outright today.",
          "createdAt": "2024-12-16T22:02:26Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-12-16T22:02:26Z",
          "id": "IC_kwDODI9FZc6XzvwE"
        },
        {
          "author": "asleire",
          "body": "> Having the serializer honor the `required` keyword is not simply a matter of convention. `required` members form an essential part of a type's contract, \n\nI disagree. The `required` keyword is a language feature for enabling compile-time checks on object initializers. It does not affect the contents of the field, and the possible data values remain the same whether `required` is set or not. \n\n> and initializing instances that bypass it can result in unexpected behavior when invoking its methods.\n\nBecause the required property's setter may contain logic that does something even if the passed value is `null`? Ok, pass in the default value if it is not present in the JSON. \n\nJSON objects are not C# objects. That's why we have serializers and a lot of options to configure how the serialization is done. Automatically applying the C# language feature of `required` keywords to JSON objects is in my opinion wrong. It cannot be undone, but you could add an option to opt-out.\n\n\n\n\n",
          "createdAt": "2024-12-16T22:09:19Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-12-16T22:10:39Z",
                "user": "akilin"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-04-12T18:05:14Z",
                "user": "dsherret"
              }
            ],
            "totalCount": 2,
            "endCursor": "Y3Vyc29yOnYyOpHOEN8UTw=="
          },
          "updatedAt": "2024-12-16T22:09:19Z",
          "id": "IC_kwDODI9FZc6Xz0HH"
        },
        {
          "author": "eiriktsarpalis",
          "body": "> > Having the serializer honor the `required` keyword is not simply a matter of convention. `required` members form an essential part of a type's contract,\n> \n> I disagree. The `required` keyword is a language feature for enabling compile-time checks on object initializers. It does not affect the contents of the field, and the possible data values remain the same whether `required` is set or not.\n\nThat is literally what the purpose of a \"required\" contract is. One can make similar arguments about accessibility modifiers or constructors being superficial -- `FormatterServices.GetUninitializedObject` and reflection offering the ultimate flexibility!\n\n> Automatically applying the C# language feature of `required` keywords to JSON objects is in my opinion wrong. It cannot be undone, but you could add an option to opt-out.\n\nYou are of course entitled to your opinion, but from the perspective of what guarantees STJ offers out of the box `required` is going to be honored by the deserializer. Please see my earlier post for a workaround.",
          "createdAt": "2024-12-16T22:19:15Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-12-16T22:21:43Z",
          "id": "IC_kwDODI9FZc6Xz6Hs"
        },
        {
          "author": "asleire",
          "body": "> STJ offers out of the box `required` is going to be honored by the deserializer\n\nSTJ can honor the contract by setting the type's default value if the JSON object does not contain it.\n\n> Please see my earlier post for a workaround.\n\nThanks, but we don't feel that we should need to write our own code to work around this, hence the feature suggestions. \n\nMaybe we are in the wrong though? I was very surprised when I realized how you treated the `required` keyword, and I am surprised no-one else has made an effort to correct it until now. My workaround is to simply not use the `required` keyword in DTOs and then sigh when I realize I've forgotten to set the property in a mapping. I imagine that is what most users keep doing.\n\nPersonally I'd love the opinion of even more people in this thread.",
          "createdAt": "2024-12-16T22:34:37Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-04-24T18:56:10Z",
                "user": "tlunsfordCXP"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOEPkgBA=="
          },
          "updatedAt": "2024-12-16T22:35:22Z",
          "id": "IC_kwDODI9FZc6X0CTu"
        },
        {
          "author": "akilin",
          "body": ">TL;DR not treating constructor parameters as required is a historic bug that we unfortunately can't fix outright today.\n\nAs a thought experiment, if this bug was fixed today and all the constructor properties were treated as required.\nDo I understand correctly that any codebase that uses `DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull` will no longer be able to enforce compile-time guarantees that the fields will be set?\nEffectively making `WhenWritingNull` unusable out of the box if you care about compile-time guarantees.\n\nYou can't use the `required` keyword, as it breaks on deserialization,\nand you can't use a constructor with required parameters, as it will now also break on deserialization.\n\n\n---\n\n>Personally I'd love the opinion of even more people in this thread.\n\nThere is a similar thread located here which I feel is relevant to our discussion: https://github.com/JamesNK/Newtonsoft.Json/issues/2918\n\n\n",
          "createdAt": "2024-12-16T22:40:03Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-12-16T22:56:25Z",
          "id": "IC_kwDODI9FZc6X0FSK"
        },
        {
          "author": "eiriktsarpalis",
          "body": "> > STJ offers out of the box `required` is going to be honored by the deserializer\n> \n> STJ can honor the contract by setting the type's default value if the JSON object does not contain it.\n\nTechnically setting all your required members to`default!` would satisfy the contract, but nothing good can come out of that when using it as a blanket policy.\n\n> As a thought experiment, if this bug was fixed today and all the constructor properties were treated as required.\n> Do I understand correctly that any codebase that uses DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull will no longer be able to enforce compile-time guarantees that the fields will be set?\n\nNot sure what you mean by compile-time guarantees in this context, but yes, having a non-optional parameter conflicts with any policy that sometimes skips the same value on the serialization side.\n\n> There is a similar thread located here which I feel is relevant to our discussion: https://github.com/JamesNK/Newtonsoft.Json/issues/2918\n\nThanks for sharing. I'll point out that apart from a few very vocal people in the thread, the upvotes greatly outnumber the downvotes.",
          "createdAt": "2024-12-16T22:57:04Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-12-16T23:01:12Z",
          "id": "IC_kwDODI9FZc6X0OdH"
        },
        {
          "author": "akilin",
          "body": ">Not sure what you mean by compile-time guarantees in this context\n\nWhen a class is declared like this:\n```cs\npublic class Foo{\n    public Foo(int? ForeignKey){\n    }\n}\n```\nor like this\n```cs\npublic class Bar\n{\n    public required int? ForeignKey { get; set; }\n}\n```\n\nYou can't create a new instance of `Foo` or `Bar` without explicitly providing a `foreignKey` value (it won't compile).\nBoth of those classes would become unusable in our hypothetical situation.",
          "createdAt": "2024-12-16T23:03:23Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-12-16T23:03:23Z",
          "id": "IC_kwDODI9FZc6X0SD_"
        },
        {
          "author": "akilin",
          "body": ">Thanks for sharing. I'll point out that apart from a few very vocal people in the thread, the upvotes greatly outnumber the downvotes.\n\nYes, but I would also like to point out that at the same time out of all the people who participated in the discussion - only the thread author was actually for this feature. \nEverybody else who participated in the discussion either argued against it or asked to at least make it configurable so that people could decide which behavior they wanted.\nOn second look, even the author of the issue said:\n>It can always be optional configuration \n \nSo the full tally is: 2 people for making it configurable, everyone else was against the current STJ behavior.",
          "createdAt": "2024-12-16T23:10:30Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-12-20T13:48:49Z",
          "id": "IC_kwDODI9FZc6X0V2h"
        },
        {
          "author": "eiriktsarpalis",
          "body": "> Both of those classes would become unusable in our hypothetical situation.\n\nI'll focus on the latter case since they're essentially the same and like you say the first is hypothetical. Why do you claim that it is unusable? If it's acceptable to skip a property in the wire format, why is it not acceptable to do the same programmatically?",
          "createdAt": "2024-12-16T23:11:48Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-12-16T23:11:48Z",
          "id": "IC_kwDODI9FZc6X0Wjc"
        },
        {
          "author": "akilin",
          "body": ">Why do you claim that it is unusable? \n\n```cs\npublic class Bar\n{\n    public required int? ForeignKey { get; set; }\n}\n```\n\nBecause it will throw during runtime when trying to deserialize, making it unusable.\nYou would have to modify your code to not have a `required` modifier or to stop using `JsonIgnoreCondition.WhenWritingNull`.\n\n\n>If it's acceptable to skip a property in the wire format, why is it not acceptable to do the same programmatically?\n\nWell, the JsonSerializer currently says it's acceptable to skip a property in the wire format (during writing), as long as I specify `DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull`.\nI am just saying that if `JsonSerializer` is allowing us to skip a required property when writing, at the very least it should allow us to also skip it when reading.\n\n---\n\nIt might also be useful to check how other languages/serializers handle similar situations. \nI think `JsonIgnoreCondition.WhenWritingNull` is a very common optimization.\nWe can't be the first people who have encountered this use-case.\nIt's very late for me, so I can't do this right now. But I will try to find some time in the near future to investigate how others have handled this situation.\n",
          "createdAt": "2024-12-17T00:01:07Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-12-19T23:13:54Z",
          "id": "IC_kwDODI9FZc6X0uth"
        },
        {
          "author": "eiriktsarpalis",
          "body": "> the JsonSerializer currently says it's acceptable to skip a property in the wire format\n\nCan you clarify what you mean by this? The documentation of `JsonIgnoreCondition.WhenWritingNull` simply states:\n\n> Property is ignored if its value is null. This is applied only to reference-type properties and fields.\n\nIt just does what it says. No guarantees are being offered as to what happens when you try to deserialize the same payload. \n\nAs a general rule, serializers offer no guarantees that any type/configuration combination can be roundtripped (because it is not possible). It is the responsibility of the user to model their DTOs in an appropriate way that reflects the desired schema and roundtripping guarantees. In the example that you are citing, I would personally not mark the property as `required` for this reason.",
          "createdAt": "2024-12-17T07:54:07Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-12-17T07:54:07Z",
          "id": "IC_kwDODI9FZc6X2zzk"
        },
        {
          "author": "akilin",
          "body": "> the JsonSerializer currently says it's acceptable to skip a property in the wire format\nCan you clarify what you mean by this? \n\nIf you are using a `JsonSerializer` with `JsonIgnoreCondition.WhenWritingNull` for writing - then the `required` fields will be skipped when writing. If this would not be acceptable for `JsonSerializer` - it would throw a JsonSerializerException.",
          "createdAt": "2024-12-17T08:01:45Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-12-18T18:20:59Z",
          "id": "IC_kwDODI9FZc6X22tP"
        },
        {
          "author": "akilin",
          "body": ">I think it might be also usefull to check how other languages/serializers handle similar situations.\n\nI had some time to look into this.\nUnfortunately not that many languages have a `required` as a language-level keyword. So far I have only found `Dart` and `Swift`\n\nDart is capable of performing this roundtrip without any additional hassle.\nThe code I used (sorry if bad quality, first time using dart): \n```dart\nimport 'dart:convert';\nimport 'package:cli/cli.dart' as cli;\nimport 'package:json_annotation/json_annotation.dart';\nimport 'package:json_serializable/json_serializable.dart';\n\n\npart 'cli.g.dart';\n\nvoid main(List<String> arguments) {\n  Person person = Person(num:null);\n  String json = jsonEncode(person);\n  Person res = Person.fromJson(jsonDecode(json));\n  \n  print(person.num);\n  print(json);\n  print(res.num);\n\n\n  Person person2 = Person(num:2);\n  String json2 = jsonEncode(person2);\n  Person res2 = Person.fromJson(jsonDecode(json2));\n\n  print(person2.num);\n  print(json2);\n  print(res2.num);\n}\n\n\n@JsonSerializable(includeIfNull: false)\nclass Person {\t\n  int? num;\n  \n  Person({required this.num});\n\n  factory Person.fromJson(Map<String, dynamic> json) => _$PersonFromJson(json);\n\n  /// Connect the generated [_$PersonToJson] function to the `toJson` method.\n  Map<String, dynamic> toJson() => _$PersonToJson(this);\n}\n\n```\n\nOutputs:\n```\nPS C:\\Users\\WDAGUtilityAccount\\dart\\cli> dart run\nBuilding package executable... (1.2s)\nBuilt cli:cli.\nnull\n{}\nnull\n2\n{\"num\":2}\n2\n```\n\nKey parts are `required` and `@JsonSerializable(includeIfNull: false)`\n\nI need to go to work now, but will try `Swift` once I am back home.",
          "createdAt": "2024-12-17T08:04:36Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-12-17T08:04:36Z",
          "id": "IC_kwDODI9FZc6X238o"
        },
        {
          "author": "eiriktsarpalis",
          "body": "> > the JsonSerializer currently says it's acceptable to skip a property in the wire format\n> > Can you clarify what you mean by this?\n> \n> The way the data will be sent over the wire is decided by the one doing the writing. If you are using a `JsonSerializer` with `JsonIgnoreCondition.WhenWritingNull` for writing - then the `required` fields will be skipped when writing. If this would not be acceptable for `JsonSerializer` - it would throw a JsonSerializerException.\n\nSTJ doesn't do any kind of enforcement like this. The reason primarily is that not all serialization applications concern themselves with round tripping. Some types are only intended for serialization (think view models) and others only for deserialization (think binding models). It's the same reason why we support abstract and interface types which fundamentally don't support deserialization. But even if we wanted to add this kind of validation today it would be a breaking change.",
          "createdAt": "2024-12-17T08:09:55Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-12-17T08:09:55Z",
          "id": "IC_kwDODI9FZc6X26dc"
        },
        {
          "author": "eiriktsarpalis",
          "body": "> Dart is capable of performing this roundtrip without any additional hassle.\n\nI honestly don't think that's good built-in behavior. The serializer is creating invalid instances of type `Person`.",
          "createdAt": "2024-12-17T08:12:46Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-12-17T08:12:46Z",
          "id": "IC_kwDODI9FZc6X27zL"
        },
        {
          "author": "eiriktsarpalis",
          "body": "I think part of the disagreement might stem from a misunderstanding of what `required` entails for the contract of a type, which might not be entirely evident if you're only applying it to fields or auto properties. Consider the following (somewhat artificial) example:\n\n```C#\npublic class MyPoco\n{\n    private Wrapper<string?> _wrapper;\n    \n    public required string? Value\n    {\n        get => _wrapper.Value;\n        set => _wrapper = new(value);\n    }\n}\n\npublic class Wrapper<T>(T value)\n{\n    public T Value { get; } = value;\n}\n```\n\nBecause a `required` setter can execute arbitrary code, it effectively becomes an integral part of an object's initialization, even if it nomizally isn't executing as part of a regular constructor. A serializer that fails to invoke required setters therefore risks creating invalid instances, in a way that is similar to how calling `FormatterServices.GetUninitializedObject` risks creating invalid instances.",
          "createdAt": "2024-12-17T15:46:48Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-12-17T15:46:48Z",
          "id": "IC_kwDODI9FZc6X68fD"
        },
        {
          "author": "akilin",
          "body": ">Because a required setter can execute arbitrary code, it effectively becomes an integral part of an object's initialization, even if it nomizally isn't executing as part of a regular constructor. A serializer that fails to invoke required setters therefore risks creating invalid instances, in a way that is similar to how calling FormatterServices.GetUninitializedObject risks creating invalid instances.\n\nI would say that the class that you used in your example is a great example of a class that should follow the advice you gave me earlier:\n>My recommendation would be to model your DTOs differently\n\nYou even used the word `DTO`, which to me means you agree that the classes that are used for data transfer should be DTOs. \nThey should only contain the data and should not contain any behavior (like complex setters).",
          "createdAt": "2024-12-17T16:03:42Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-12-17T16:03:42Z",
          "id": "IC_kwDODI9FZc6X7Mof"
        },
        {
          "author": "eiriktsarpalis",
          "body": "> You even used the word `DTO`, which to me means you agree that the classes that are used for data transfer should be DTOs.\n> They should only contain the data and should not contain any behavior (like complex setters).\n\nAs an application author I 100% agree with that approach, however wearing the library maintainer's hat my job is to make sure every scenario permissible by the type system is handled appropriately by the serializer.",
          "createdAt": "2024-12-17T16:10:10Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-12-17T16:10:10Z",
          "id": "IC_kwDODI9FZc6X7Sia"
        },
        {
          "author": "akilin",
          "body": ">will try Swift once I am back home\n\nTurns out that in Swift the `required` keyword is about forcing subclasses to implement a method, sort of similar to `abstract` in c#, so it is not very relevant to our use case.\n\n",
          "createdAt": "2024-12-17T16:19:39Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-12-17T16:19:39Z",
          "id": "IC_kwDODI9FZc6X7Ymv"
        },
        {
          "author": "akilin",
          "body": ">As an application author I 100% agree with that approach, however wearing the library maintainer's hat my job is to make sure every scenario permissible by the type system is handled appropriately by the serializer.\n\nI understand your position, but I still disagree with current behavior being the only default one supported out of the box without writing additional code.\n\nI don't think it necessarily means that one of us is wrong.\nI think it's one of those things where it's not black and white and there is no single solution that would make everyone happy. \nDifferent people have different assumptions about how `required` should function in the context of data serialization/deserialization, and to me, this seems like exactly the case where there should be an option that allows both groups to configure the serializer to match their expectations.\n\nConsidering that:\n\n* This issue exists and has been brought up a second time now\n* Mirror issue exists in Newtonsoft repo and every person participating in the discussion was either against current STJ behaviour or for making it configurable\n* In another language the proposed behavior works out of the box by default\n\nit seems there is some value in the proposed behavior and in my opinion it should be seriously considered.\n",
          "createdAt": "2024-12-17T16:58:45Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-12-19T18:16:47Z",
          "id": "IC_kwDODI9FZc6X70JN"
        },
        {
          "author": "eiriktsarpalis",
          "body": "> I understand your position, but I still disagree with current behavior being the only default one supported out of the box without writing additional code.\n\nAgree to disagree. I think I've demonstrated how bypassing `required` members can result in invalid (and potentially exploitable) instances being created. It is reasonable for a developer to want a way to disable this protection because they know what they are doing, but of course this may not apply to the next developer that inherits the codebase. Putting guardrails on the built-in behavior (even at the expense of functionality) is one of the core design principles that created this library. At the same time, the library does expose customization points for power users that know what they are doing.\n\nWill there be a built-in knob that disables required member enforcement in the future? Very unlikely, in the past few years we've been depriorititizing \"bells and whistles\" type of feature work instead focusing on a small number of high-impact infrastructural work without available workarounds. The fact that it is deliberately bypassing a security feature makes it even less likely that such a proposal would survive API review -- it would probably need to be a property-level opt out instead of a global switch similar to how we have `JsonIncludeAttribute` instead of a setting that wholesale enables private member serialization.\n\nIn the meantime, I encourage you to try out the [suggested workaround](https://github.com/dotnet/runtime/issues/110733#issuecomment-2546006743) -- it is a small amount of code enabling functionality that is on par with using a built-in attribute.\n\nI will keep this issue open in the backlog, in case it receives more traction in the future. But it certainly won't be prioritized for .NET 10.",
          "createdAt": "2024-12-17T17:32:20Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-12-17T17:32:20Z",
          "id": "IC_kwDODI9FZc6X8ISB"
        },
        {
          "author": "akilin",
          "body": ">I will keep this issue open in the backlog, in case it receives more traction in the future. \n\nThank you\n\n>In the meantime, I encourage you to try out the https://github.com/dotnet/runtime/issues/110733#issuecomment-2546006743 -- it is a small amount of code enabling functionality that is on par with using a built-in attribute.\n\nI considered it, but it's not really what I am after. \nI would prefer to specify the default behaviour across the codebase, instead of having to opt-in for each property.\nI ended up using the solution described here:\nhttps://github.com/JamesNK/Newtonsoft.Json/issues/2918#issuecomment-2094350865\n\nIt still respects the `JsonRequiredAttribute`, but unties the `required` keyword from automatically meaning the same.\n\nI am using this for internal communication between services, so for my use case it should be fine to make this behavior a global default.\n",
          "createdAt": "2024-12-18T08:51:00Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-12-18T08:57:50Z",
          "id": "IC_kwDODI9FZc6YCOg_"
        },
        {
          "author": "eiriktsarpalis",
          "body": "> I would prefer to specify the default behaviour across the codebase, instead of having to opt-in for each property.\n> I ended up using the solution described here:\n> [JamesNK/Newtonsoft.Json#2918 (comment)](https://github.com/JamesNK/Newtonsoft.Json/issues/2918#issuecomment-2094350865)\n\nGood to see you've found a workaround, but for the record I wouldn't recommend bypassing `required` as a blanket policy since it could result in unexpected behavior in future types. Consider using type-level or member-level opt out mechanism instead.",
          "createdAt": "2024-12-18T12:59:23Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-12-18T12:59:23Z",
          "id": "IC_kwDODI9FZc6YESzh"
        },
        {
          "author": "akilin",
          "body": "I just saw the linked issue https://github.com/dotnet/runtime/issues/110810\n\nI did not even consider the `JsonIgnoreAttribute` during our discussion.\nI feel like this is another good argument for `required` not being equated to `JsonRequiredAttribute` (or at least allowing people to make it easily configurable).\n\n```cs\nusing System.Text.Json;\nusing System.Text.Json.Serialization;\n\nvar foo = new Foo { Id = null };\nvar bar = new Bar { Id = null };\n\nvar opt = new JsonSerializerOptions { DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull };\n\nConsole.WriteLine(JsonSerializer.Serialize(foo, opt));\nConsole.WriteLine(JsonSerializer.Serialize(bar, opt));\n\npublic class Foo\n{\n    public required int? Id { get; set; }\n}\n\npublic class Bar\n{\n    [JsonIgnore] public required int? Id { get; set; }\n}\n```\n\nI could understand if both would serialize, but throw during deserialization due to our earlier discussion.\nI would still disagree with them throwing during deserialization, but I would understand.\n\nBut how is the `Bar` throwing during serialization, while `Foo` is serializing just fine? \nThat just makes no sense.\n\nIf the presence of the `required` keyword conflicts with `JsonIgnoreAttribute` during serialization, then it's a blanket statement that you can't ignore the `required` properties when writing.\n\nBut then you look at `Foo` and it does just that. It ignores a `required` property when writing and does not throw.\n\n---\n\nSlightly offtopic: if the current issue won't result in any changes, and it is decided to keep the existing behavior, then I think https://github.com/dotnet/runtime/issues/110810 should be reopened but with the goal of improving the error message/documentation/maybe even introducing a compile-time analyzer.\n\nThe current error message from that issue states:\n>System.InvalidOperationException: JsonPropertyInfo 'Id' defined in type 'JsonBugMinimalApp.Program+Contact' is marked required but does not specify a setter\n\nIt's a vague message when the property has a setter, and the problem is due to `JsonIgnoreAttribute`.\n\nI would also suggest adding a hint to `JsonIgnoreAttribute` documentation/xmldoc that it is not compatible with `required` keyword.\nMaybe even introduce a compile-time analyzer that detects `required` properties marked with `JsonIgnore` and results in a build error/warning. Compile-time errors are always preferred to run-time ones.\n\n",
          "createdAt": "2024-12-19T17:39:11Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-12-31T16:46:26Z",
          "id": "IC_kwDODI9FZc6YT0Sx"
        },
        {
          "author": "Dreamescaper",
          "body": "I stumbed across this issue as well.\n\nI have a record like this:\n```\npublic record CalculationResult(\n    string Arguments,\n    decimal? Result,\n    string? Error);\n```\n\nSerializing this record back and forth with `JsonIgnoreCondition.WhenWritingNull` leads to an exception:\n> JSON deserialization for type 'CalculationResult' was missing required properties including: 'error'.\n\nI realize that I can update my record like this to workaround it:\n```\npublic record CalculationResult(\n    string Arguments,\n    decimal? Result = null,\n    string? Error = null);\n```\nBut I don't want to do that, it makes no sense in my case.\n\nI remember only one case in my entire life when I cared whether property is null or absent completely in JSON. And for 99.999% of cases I would like the serializer not to care as well.",
          "createdAt": "2025-01-24T11:31:53Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-01-24T11:31:53Z",
          "id": "IC_kwDODI9FZc6btJuP"
        },
        {
          "author": "MrAntix",
          "body": "I want to tell my colleges (and me when I forget) that a property is required when the model is created so I do this...\n\n```csharp \nrecord M { public required string Name { get; init; } }\n```\n\nM is part of a public API, which is validated to return a nice error message with all validation failures to the caller.\nbut when a caller omits Name, the deserialization throws before it gets to my validator\n\nto allow validation, I have to make my model something this this ...\n\n```csharp \nrecord M { public string Name { get; init; } = default! }\n```\n\nadding a boolean to the options to turn off throwing will allow me to have my cake and eat it",
          "createdAt": "2025-05-19T13:53:32Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-05-19T13:53:32Z",
          "id": "IC_kwDODI9FZc6sUxg9"
        },
        {
          "author": "desjoerd",
          "body": "> I want to tell my colleges (and me when I forget) that a property is required when the model is created so I do this...\n> \n> record M { public required string Name { get; init; } }\n> M is part of a public API, which is validated to return a nice error message with all validation failures to the caller. but when a caller omits Name, the deserialization throws before it gets to my validator\n> \n> to allow validation, I have to make my model something this this ...\n> \n> record M { public string Name { get; init; } = default! }\n> adding a boolean to the options to turn off throwing will allow me to have my cake and eat it\n\nThis is something AspNetCore does with minimal api's at least.\n\nYou can set the below to let it throw, then you can handle the deserialization error in an error handler.\n```csharp\nbuilder.Services.Configure<RouteHandlerOptions>(options =>\n{\n    // set to true to catch JsonSerializer exceptions\n    options.ThrowOnBadRequest = true;\n});\n```",
          "createdAt": "2025-05-19T14:04:22Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-05-19T14:04:22Z",
          "id": "IC_kwDODI9FZc6sU6S7"
        },
        {
          "author": "MrAntix",
          "body": "it will still not get to my validation, you just get the first thrown error not all the rest of the failures, I want it all, I am greedy",
          "createdAt": "2025-05-19T14:10:53Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-05-19T14:10:53Z",
          "id": "IC_kwDODI9FZc6sU_c2"
        },
        {
          "author": "desjoerd",
          "body": "I think you will have the same problem with `null`. Because when you enable `RespectNullableAnnotations` [docs](https://learn.microsoft.com/en-us/dotnet/standard/serialization/system-text-json/nullable-annotations) (which is disabled by default) it will also throw on the first instance.",
          "createdAt": "2025-05-19T15:04:30Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-05-19T15:04:30Z",
          "id": "IC_kwDODI9FZc6sVtPn"
        },
        {
          "author": "thomaslevesque",
          "body": "I have another use case where it would be useful to disable the check for `required` properties: https://github.com/dotnet/aspnetcore/issues/61511\n\nBasically, if you use the `required` keyword on a property, and the property is missing, deserialization throws an exception, and there's never a chance for ASP.NET Core to validate the model to produce a meaningful error response, like it would do if the property just had the `[Required]` attribute. Using the attribute if a valid workaround, of course, but it means having to initialize the property to a dummy value or to `null!` to quell the nullability warning, which is not ideal.",
          "createdAt": "2025-05-29T09:27:04Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-05-29T09:27:04Z",
          "id": "IC_kwDODI9FZc6t-drP"
        },
        {
          "author": "Dreamescaper",
          "body": "IMHO, current behavior makes STJ inconsistent with other parts of .NET ecosystem.\n\nE.g. [optional parameters](https://learn.microsoft.com/en-us/aspnet/core/fundamentals/minimal-apis/parameter-binding?view=aspnetcore-9.0#optional-parameters) in AspNetCore.\nMaking a parameter nullable `(int? pageNumber)` makes it non-mandatory. I don't have to set `null` as default value `(int? pageNumber = null)` explicitly.\n",
          "createdAt": "2025-05-30T13:15:51Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-05-30T13:16:24Z",
          "id": "IC_kwDODI9FZc6uL9ux"
        },
        {
          "author": "elgonzo",
          "body": "> Making a parameter nullable (int? pageNumber) makes it non-mandatory.\n\nSince when?\n```C#\nvoid Foo(int? value) {}\n\nrecord Bar(int? value);\n```\nSince when can i call a method like this without an argument like `Foo();` or create a record like this without an argument like `new Bar();`?\n\nWhy should ASP.NET convention win over C# rules? Doing what you asked makes STJ inconsistent with C# itself, especially when a property/field is being designated as `required`, so it becomes even less consistent with the .NET ecosystem...",
          "createdAt": "2025-05-30T13:56:30Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-05-30T14:05:20Z",
                "user": "eiriktsarpalis"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOEUcqVQ=="
          },
          "updatedAt": "2025-05-30T14:21:23Z",
          "id": "IC_kwDODI9FZc6uMV29"
        },
        {
          "author": "Dreamescaper",
          "body": "> Making a parameter nullable (int? pageNumber) makes it non-mandatory.\n> Since when?\n\nI assume since MinimalAPI was introduced.\n\n> Why should ASP.NET convention win over C# rules? \n\nIn my opinion - because in 90% STJ is used in conjunction with AspNetCore.\nAlso - because personally I like it better :)",
          "createdAt": "2025-05-30T14:20:49Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-05-30T14:25:10Z",
          "id": "IC_kwDODI9FZc6uMlWZ"
        }
      ],
      "totalCount": 41,
      "endCursor": "Y3Vyc29yOnYyOpHOrjJVmQ=="
    },
    "url": "https://github.com/dotnet/runtime/issues/110733",
    "title": "Consider adding a property to `JsonSerializerOptions` that configures behaviour around `required` nullable properties"
  },
  {
    "author": "petterton",
    "labels": [
      "area-System.Text.Json"
    ],
    "createdAt": "2024-12-17T08:22:38Z",
    "body": "### Description\n\nThe behavior of `JsonNumberHandling.AllowReadingFromString` is inconsistent when applied at the class level versus when specified in `JsonSourceGenerationOptions`.\n\nWhen `JsonNumberHandling.AllowReadingFromString` is set as an attribute at the class level, deserialization of a `double[][]` property containing strings fails with a `JsonException`.\n\nHowever, when the same option is set in `JsonSourceGenerationOptions` for a `JsonSerializerContext`, deserialization works as expected.\n\nThis inconsistency violates the principle of least surprise, as developers would expect the attribute and context options to behave similarly.\n\nIf applying the attribute on property level, the deserialization also fails, but with a different error message.\n\n### Reproduction Steps\n\n```\nusing System.Text.Json;\nusing System.Text.Json.Serialization;\n\n// Case 1: JsonSourceGenerationOptions with NumberHandling set at context level (Works)\npublic class TestClassWithContext\n{\n    public double[][] Numbers { get; set; }\n}\n\n// Case 2: Attribute on class level (Fails)\n[JsonNumberHandling(JsonNumberHandling.AllowReadingFromString)]\npublic class TestClassWithAttribute\n{\n    public double[][] Numbers { get; set; }\n}\n\n// JsonSerializerContext for Case 1 (explicitly allows reading from string)\n[JsonSourceGenerationOptions(WriteIndented = true, NumberHandling = JsonNumberHandling.AllowReadingFromString)]\n[JsonSerializable(typeof(TestClassWithContext))]\ninternal partial class JsonContextWithNumberHandling : JsonSerializerContext { }\n\n// JsonSerializerContext for Case 2 (default options, does not allow reading from string)\n[JsonSourceGenerationOptions(WriteIndented = true)]\n[JsonSerializable(typeof(TestClassWithAttribute))]\ninternal partial class JsonContextDefault : JsonSerializerContext { }\n\ninternal class Program\n{\n    private const string Json = \"{\\\"Numbers\\\":[[\\\"1.23\\\",\\\"4.56\\\"],[\\\"7.89\\\",\\\"0.12\\\"]]}\";\n\n    static void Main()\n    {\n        // Case 1: JsonSourceGenerationOptions (Works)\n        Console.WriteLine(\"--- Case 1: JsonSourceGenerationOptions (Works) ---\");\n        var result1 = JsonSerializer.Deserialize<TestClassWithContext>(Json, JsonContextWithNumberHandling.Default.TestClassWithContext);\n        Console.WriteLine(\"Result 1: \" + JsonSerializer.Serialize(result1, JsonContextWithNumberHandling.Default.TestClassWithContext));\n\n        // Case 2: Attribute on Class (Fails)\n        Console.WriteLine(\"\\n--- Case 2: Attribute on Class (Fails) ---\");\n        try\n        {\n            var result2 = JsonSerializer.Deserialize<TestClassWithAttribute>(Json, JsonContextDefault.Default.TestClassWithAttribute);\n            Console.WriteLine(\"Result 2: \" + JsonSerializer.Serialize(result2));\n        }\n        catch (Exception ex)\n        {\n            Console.WriteLine(\"Failed as expected: \" + ex.Message);\n        }\n    }\n}\n\n```\n\n### Expected behavior\n\nDeserialization of a `double[][]` property containing strings should succeed when `JsonNumberHandling.AllowReadingFromString` is applied at the class or property level. At the very least, I would expect `JsonNumberHandling.AllowReadingFromString` to behave consistently when applied as an attribute versus when specified in `JsonSourceGenerationOptions`\n\n### Actual behavior\n\n**Class level:**\nThe JSON value could not be converted to System.Double. Path: $.Numbers[0][0] | LineNumber: 0 | BytePositionInLine: 19.\n**JsonSourceGenerationOptions:**\nDeserialization succeeds as expected.\n\n\n### Regression?\n\n_No response_\n\n### Known Workarounds\n\nUse `JsonSourceGenerationOptions` with `NumberHandling = JsonNumberHandling.AllowReadingFromString` in a `JsonSerializerContext`\n\n### Configuration\n\n**OS**: Windows 10\n**.NET Version**: .NET 9.0\n**Architecture**: x64\n\n### Other information\n\n_No response_",
    "number": 110770,
    "reactions": {
      "hasNextPage": false,
      "nodes": [],
      "totalCount": 0,
      "endCursor": null
    },
    "updatedAt": "2024-12-17T08:34:55Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": "dotnet-policy-service",
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. -->",
          "createdAt": "2024-12-17T08:23:06Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2024-12-17T08:23:06Z",
          "id": "IC_kwDODI9FZc6X3BbV"
        },
        {
          "author": "eiriktsarpalis",
          "body": "This is because the `[JsonNumberHandling(JsonNumberHandling.AllowReadingFromString)]` annotation only applies to first-order properties that are declared on the type. When serializing values like `double[]` or `double[][]` control passes from the converter for `TestClassWithAttribute` to the converter for `double[][]` which is not scoped to the specific declaring type. The global setting works because, well, the global setting also applies to the `JsonConverter<double[][]>`.\n\nWe might consider implementing a dynamic scoping scheme in the future, assuming there is demand for this. It is however going to be complex undertaking that is almost certainly going to count as a breaking change. For now, my recommendation would be to just turn on the global setting.",
          "createdAt": "2024-12-17T08:34:21Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2024-12-17T08:39:33Z",
                "user": "petterton"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOD_SbpA=="
          },
          "updatedAt": "2024-12-17T08:34:21Z",
          "id": "IC_kwDODI9FZc6X3GtT"
        }
      ],
      "totalCount": 2,
      "endCursor": "Y3Vyc29yOnYyOpHOl9xrUw=="
    },
    "url": "https://github.com/dotnet/runtime/issues/110770",
    "title": "JsonNumberHandling.AllowReadingFromString on class-level fails for double[][], but works in JsonSourceGenerationOptions"
  },
  {
    "author": "pingu2k4",
    "labels": [
      "area-System.Text.Json",
      "regression-from-last-release"
    ],
    "createdAt": "2025-01-10T11:09:55Z",
    "body": "### Is there an existing issue for this?\n\n- [x] I have searched the existing issues\n\n### Describe the bug\n\nI randomly started hitting a NullabilityInfoContext_NotSupported exception in live environments with the auth package `Microsoft.Authentication.WebAssembly.Msal` which lives within this repo.\n\nIt might have been due to a recent update to the nuget package, but not entirely sure on that.\n\nOur project is a Blazor wasm standalone app, which we are hosting on azure static sites.\n\nThis was a bug present in our live deployments, but never present on local builds.\n\nAfter a lot of digging into it, we have resolved the issue by adding the following to our csproj:\n```\n<NullabilityInfoContextSupport>true</NullabilityInfoContextSupport>\n```\n\nWe had never previously needed this in the csproj, so am wondering what has changed to suddenly need this now. I also have found no mention of others having the same issue, which worries me that we might have done something unintended as I would expect to see reports regarding this if something had changed beyond our scope.\n\nWhilst I have a fix, I am interested to know why this happened in the first place, and also how we could have possibly known to prevent this in advance etc.\n\n### Expected Behavior\n\n_No response_\n\n### Steps To Reproduce\n\nJust a standard project, but deployed somewhere and using `Microsoft.Authentication.WebAssembly.Msal` for auth.\n\n### Exceptions (if any)\n\n<details>\n<summary>Error</summary>\n```\ncrit: Microsoft.AspNetCore.Components.WebAssembly.Rendering.WebAssemblyRenderer[100]\n      Unhandled exception rendering component: NullabilityInfoContext_NotSupported\nSystem.InvalidOperationException: NullabilityInfoContext_NotSupported\n   at System.Reflection.NullabilityInfoContext.EnsureIsSupported()\n   at System.Reflection.NullabilityInfoContext.Create(PropertyInfo )\n   at System.Text.Json.Serialization.Metadata.DefaultJsonTypeInfoResolver.DeterminePropertyNullability(JsonPropertyInfo , MemberInfo , NullabilityInfoContext )\n   at System.Text.Json.Serialization.Metadata.DefaultJsonTypeInfoResolver.PopulatePropertyInfo(JsonPropertyInfo , MemberInfo , JsonConverter , Nullable`1 , NullabilityInfoContext , Boolean , Boolean )\n   at System.Text.Json.Serialization.Metadata.DefaultJsonTypeInfoResolver.CreatePropertyInfo(JsonTypeInfo , Type , MemberInfo , NullabilityInfoContext , JsonSerializerOptions , Boolean , Boolean )\n   at System.Text.Json.Serialization.Metadata.DefaultJsonTypeInfoResolver.AddMember(JsonTypeInfo , Type , MemberInfo , NullabilityInfoContext , Boolean , Boolean , PropertyHierarchyResolutionState& )\n   at System.Text.Json.Serialization.Metadata.DefaultJsonTypeInfoResolver.AddMembersDeclaredBySuperType(JsonTypeInfo , Type , NullabilityInfoContext , Boolean , PropertyHierarchyResolutionState& )\n   at System.Text.Json.Serialization.Metadata.DefaultJsonTypeInfoResolver.PopulateProperties(JsonTypeInfo , NullabilityInfoContext )\n   at System.Text.Json.Serialization.Metadata.DefaultJsonTypeInfoResolver.CreateTypeInfoCore(Type , JsonConverter , JsonSerializerOptions )\n   at System.Text.Json.Serialization.Metadata.DefaultJsonTypeInfoResolver.CreateJsonTypeInfo(Type , JsonSerializerOptions )\n   at System.Text.Json.Serialization.Metadata.DefaultJsonTypeInfoResolver.GetTypeInfo(Type , JsonSerializerOptions )\n   at System.Text.Json.JsonSerializerOptions.GetTypeInfoNoCaching(Type )\n   at System.Text.Json.JsonSerializerOptions.CachingContext.CreateCacheEntry(Type type, CachingContext context)\n--- End of stack trace from previous location ---\n   at System.Text.Json.JsonSerializerOptions.CachingContext.CacheEntry.GetResult()\n   at System.Text.Json.JsonSerializerOptions.CachingContext.GetOrAddTypeInfo(Type , Boolean )\n   at System.Text.Json.JsonSerializerOptions.GetTypeInfoInternal(Type , Boolean , Nullable`1 , Boolean , Boolean )\n   at System.Text.Json.WriteStackFrame.InitializePolymorphicReEntry(Type , JsonSerializerOptions )\n   at System.Text.Json.Serialization.JsonConverter.ResolvePolymorphicConverter(Object , JsonTypeInfo , JsonSerializerOptions , WriteStack& )\n   at System.Text.Json.Serialization.JsonConverter`1[[System.Object, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].TryWrite(Utf8JsonWriter , Object& , JsonSerializerOptions , WriteStack& )\n   at System.Text.Json.Serialization.Converters.ArrayConverter`2[[System.Object[], System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e],[System.Object, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].OnWriteResume(Utf8JsonWriter , Object[] , JsonSerializerOptions , WriteStack& )\n   at System.Text.Json.Serialization.JsonCollectionConverter`2[[System.Object[], System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e],[System.Object, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].OnTryWrite(Utf8JsonWriter , Object[] , JsonSerializerOptions , WriteStack& )\n   at System.Text.Json.Serialization.JsonConverter`1[[System.Object[], System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].TryWrite(Utf8JsonWriter , Object[]& , JsonSerializerOptions , WriteStack& )\n   at System.Text.Json.Serialization.JsonConverter`1[[System.Object[], System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].WriteCore(Utf8JsonWriter , Object[]& , JsonSerializerOptions , WriteStack& )\n   at System.Text.Json.Serialization.Metadata.JsonTypeInfo`1[[System.Object[], System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].Serialize(Utf8JsonWriter , Object[]& , Object )\n   at System.Text.Json.JsonSerializer.WriteString[Object[]](Object[]& , JsonTypeInfo`1 )\n   at System.Text.Json.JsonSerializer.Serialize[Object[]](Object[] , JsonSerializerOptions )\n   at Microsoft.JSInterop.JSRuntime.InvokeAsync[IJSVoidResult](Int64 , String , CancellationToken , Object[] )\n   at Microsoft.JSInterop.JSRuntime.<InvokeAsync>d__16`1[[Microsoft.JSInterop.Infrastructure.IJSVoidResult, Microsoft.JSInterop, Version=8.0.0.0, Culture=neutral, PublicKeyToken=adb9793829ddae60]].MoveNext()\n   at Microsoft.JSInterop.JSRuntimeExtensions.InvokeVoidAsync(IJSRuntime , String , Object[] )\n   at Microsoft.AspNetCore.Components.WebAssembly.Authentication.RemoteAuthenticationService`3.<EnsureAuthService>d__30[[Microsoft.AspNetCore.Components.WebAssembly.Authentication.RemoteAuthenticationState, Microsoft.AspNetCore.Components.WebAssembly.Authentication, Version=8.0.11.0, Culture=neutral, PublicKeyToken=adb9793829ddae60],[Microsoft.AspNetCore.Components.WebAssembly.Authentication.RemoteUserAccount, Microsoft.AspNetCore.Components.WebAssembly.Authentication, Version=8.0.11.0, Culture=neutral, PublicKeyToken=adb9793829ddae60],[Microsoft.Authentication.WebAssembly.Msal.Models.MsalProviderOptions, Microsoft.Authentication.WebAssembly.Msal, Version=8.0.11.0, Culture=neutral, PublicKeyToken=adb9793829ddae60]].MoveNext()\n   at Microsoft.AspNetCore.Components.WebAssembly.Authentication.RemoteAuthenticationService`3.<GetAuthenticatedUser>d__29[[Microsoft.AspNetCore.Components.WebAssembly.Authentication.RemoteAuthenticationState, Microsoft.AspNetCore.Components.WebAssembly.Authentication, Version=8.0.11.0, Culture=neutral, PublicKeyToken=adb9793829ddae60],[Microsoft.AspNetCore.Components.WebAssembly.Authentication.RemoteUserAccount, Microsoft.AspNetCore.Components.WebAssembly.Authentication, Version=8.0.11.0, Culture=neutral, PublicKeyToken=adb9793829ddae60],[Microsoft.Authentication.WebAssembly.Msal.Models.MsalProviderOptions, Microsoft.Authentication.WebAssembly.Msal, Version=8.0.11.0, Culture=neutral, PublicKeyToken=adb9793829ddae60]].MoveNext()\n   at Microsoft.AspNetCore.Components.WebAssembly.Authentication.RemoteAuthenticationService`3.<GetUser>d__28[[Microsoft.AspNetCore.Components.WebAssembly.Authentication.RemoteAuthenticationState, Microsoft.AspNetCore.Components.WebAssembly.Authentication, Version=8.0.11.0, Culture=neutral, PublicKeyToken=adb9793829ddae60],[Microsoft.AspNetCore.Components.WebAssembly.Authentication.RemoteUserAccount, Microsoft.AspNetCore.Components.WebAssembly.Authentication, Version=8.0.11.0, Culture=neutral, PublicKeyToken=adb9793829ddae60],[Microsoft.Authentication.WebAssembly.Msal.Models.MsalProviderOptions, Microsoft.Authentication.WebAssembly.Msal, Version=8.0.11.0, Culture=neutral, PublicKeyToken=adb9793829ddae60]].MoveNext()\n   at Microsoft.AspNetCore.Components.WebAssembly.Authentication.RemoteAuthenticationService`3.<GetAuthenticationStateAsync>d__19[[Microsoft.AspNetCore.Components.WebAssembly.Authentication.RemoteAuthenticationState, Microsoft.AspNetCore.Components.WebAssembly.Authentication, Version=8.0.11.0, Culture=neutral, PublicKeyToken=adb9793829ddae60],[Microsoft.AspNetCore.Components.WebAssembly.Authentication.RemoteUserAccount, Microsoft.AspNetCore.Components.WebAssembly.Authentication, Version=8.0.11.0, Culture=neutral, PublicKeyToken=adb9793829ddae60],[Microsoft.Authentication.WebAssembly.Msal.Models.MsalProviderOptions, Microsoft.Authentication.WebAssembly.Msal, Version=8.0.11.0, Culture=neutral, PublicKeyToken=adb9793829ddae60]].MoveNext()\n   at Microsoft.AspNetCore.Components.Authorization.AuthorizeViewCore.OnParametersSetAsync()\n   at Microsoft.AspNetCore.Components.ComponentBase.CallStateHasChangedOnAsyncCompletion(Task task)\n   at Microsoft.AspNetCore.Components.ComponentBase.RunInitAndSetParametersAsync()\n```\n</details>\n\n### .NET Version\n\n8\n\n### Anything else?\n\nWe are using version 8.0.11 of the nuget package `Microsoft.Authentication.WebAssembly.Msal`.",
    "number": 118333,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-02-18T13:31:25Z",
          "user": "juliank"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-02-26T13:21:49Z",
          "user": "angularsen"
        }
      ],
      "totalCount": 2,
      "endCursor": "Y3Vyc29yOnYyOpHODJusHg=="
    },
    "updatedAt": "2025-09-01T20:55:36Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": "pplusahorton",
          "body": "I started encountering this on Friday too, your resolution also worked for me.\n\nMy error was regarding `Microsoft.Authentication.WebAssembly.Msal` as well as a few other packages, some of which I don't believe reference MSAL. I'm also hosting on Azure Static Web Apps. \n\nIt's making me suspect a change in the Azure Static Web Apps platform or build tools, or something in their dependency chain.\n\nAs far as preventing it, in my case I make use of Static Web App deployment environments, so I caught it before production at least.",
          "createdAt": "2025-01-13T14:39:25Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "HEART",
                "createdAt": "2025-01-13T15:03:35Z",
                "user": "pingu2k4"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOEc_s6Q=="
          },
          "updatedAt": "2025-01-13T14:39:25Z",
          "id": "IC_kwDODI9FZc67xNsh"
        },
        {
          "author": "pingu2k4",
          "body": "Its good to hear I'm not the only one, it was honestly quite disconcerting finding seemingly nobody else with the same issue... Thanks for letting me know. :) ",
          "createdAt": "2025-01-13T15:04:30Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-01-13T15:04:30Z",
          "id": "IC_kwDODI9FZc67xNs2"
        },
        {
          "author": "justingaffney",
          "body": "I got this exception as well in two Blazor WASM applications, both running in Azure Static Web Apps. One was using version 8.0.8 of `Microsoft.Authentication.WebAssembly.Msal` and the other was using version 8.0.11.\n\nThe exception also went away for both applications after adding\n```\n<NullabilityInfoContextSupport>true</NullabilityInfoContextSupport>\n```",
          "createdAt": "2025-01-15T05:23:32Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-01-15T10:14:31Z",
                "user": "pingu2k4"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-01-17T23:41:02Z",
                "user": "MeTaLiKiD"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-03-10T11:29:13Z",
                "user": "Krosara"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-03-25T15:11:33Z",
                "user": "jcl-aadlab"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-08-04T14:38:07Z",
                "user": "SnakyBeaky"
              }
            ],
            "totalCount": 5,
            "endCursor": "Y3Vyc29yOnYyOpHOEdBPJQ=="
          },
          "updatedAt": "2025-01-15T05:23:32Z",
          "id": "IC_kwDODI9FZc67xNtF"
        },
        {
          "author": "javiercn",
          "body": "@pingu2k4 thanks for contacting us.\n\n@halter73 didn't you fix something related to this a while ago?",
          "createdAt": "2025-01-21T14:39:12Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-01-21T14:39:12Z",
          "id": "IC_kwDODI9FZc67xNto"
        },
        {
          "author": "danroth27",
          "body": "@pingu2k4 Have you tried version 8.0.12 of the package?: https://www.nuget.org/packages/Microsoft.Authentication.WebAssembly.Msal/8.0.12",
          "createdAt": "2025-01-21T14:40:37Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-01-21T14:40:37Z",
          "id": "IC_kwDODI9FZc67xNtx"
        },
        {
          "author": "FLAMESpl",
          "body": "Hi @javiercn , I have encountered it too thrown from intestines of STJ and I do not have dependency on `Msal`.\n\nThe changes I made that caused this error to appear are:\n\n- `SDK`: `8.0.404` -> `8.0.405` (app is built by docker container `mcr.microsoft.com/dotnet/sdk:8.0.405`)\n- `Markdig`: `0.39.1` -> `0.40.0`\n- `Microsoft.AspNetCore.Components`:  `8.0.11` -> `8.0.12`\n- `Microsoft.AspNetCore.Components.Web`: `8.0.11` -> `8.0.12`\n- `Microsoft.AspNetCore.Components.WebAssembly`:  `8.0.11` -> `8.0.12`\n- `Microsoft.AspNetCore.Components.WebAssembly.DevServer`: `8.0.11` -> `8.0.12`\n- `Microsoft.AspNetCore.Routing.Abstractions`:  `2.2.0` -> `2.3.0`\n- `NodaTime.Serialization.SystemTextJson`: `1.2.0` -> `1.3.0`\n- `System.Net.Http.Json`: `8.0.1` -> `9.0.1`\n- `Scrutor`: `5.0.2` -> `6.0.1`\n\nWhole thing is deployed to AWS and server as WASM static files. My project is customized with following MSBuild properties:\n\n```xml\n    <Nullable>enable</Nullable>\n    <PublishTrimmed>true</PublishTrimmed>\n    <InvariantGlobalization>true</InvariantGlobalization>\n    <SatelliteResourceLanguages>en</SatelliteResourceLanguages>\n```\n\nStack trace:\n\n```\nMicrosoft.AspNetCore.Components.WebAssembly.Rendering.WebAssemblyRenderer[100]\n      Unhandled exception rendering component: NullabilityInfoContext_NotSupported\nSystem.InvalidOperationException: NullabilityInfoContext_NotSupported\n   at System.Reflection.NullabilityInfoContext.EnsureIsSupported()\n   at System.Reflection.NullabilityInfoContext.Create(ParameterInfo )\n   at System.Text.Json.Serialization.Metadata.DefaultJsonTypeInfoResolver.DetermineParameterNullability(ParameterInfo , NullabilityInfoContext )\n   at System.Text.Json.Serialization.Metadata.DefaultJsonTypeInfoResolver.PopulateParameterInfoValues(JsonTypeInfo , NullabilityInfoContext )\n   at System.Text.Json.Serialization.Metadata.DefaultJsonTypeInfoResolver.CreateTypeInfoCore(Type , JsonConverter , JsonSerializerOptions )\n   at System.Text.Json.Serialization.Metadata.DefaultJsonTypeInfoResolver.CreateJsonTypeInfo(Type , JsonSerializerOptions )\n   at System.Text.Json.Serialization.Metadata.DefaultJsonTypeInfoResolver.GetTypeInfo(Type , JsonSerializerOptions )\n   at System.Text.Json.JsonSerializerOptions.GetTypeInfoNoCaching(Type )\n   at System.Text.Json.JsonSerializerOptions.CachingContext.CreateCacheEntry(Type type, CachingContext context)\n--- End of stack trace from previous location ---\n   at System.Text.Json.JsonSerializerOptions.CachingContext.CacheEntry.GetResult()\n   at System.Text.Json.JsonSerializerOptions.CachingContext.GetOrAddTypeInfo(Type , Boolean )\n   at System.Text.Json.JsonSerializerOptions.GetTypeInfoInternal(Type , Boolean , Nullable`1 , Boolean , Boolean )\n   at System.Text.Json.JsonSerializerOptions.GetTypeInfoForRootType(Type , Boolean )\n   at System.Text.Json.JsonSerializer.GetTypeInfo(JsonSerializerOptions , Type )\n   at System.Text.Json.JsonSerializer.GetTypeInfo[BusinessContext](JsonSerializerOptions )\n   at System.Text.Json.JsonSerializer.Deserialize[BusinessContext](JsonElement , JsonSerializerOptions )\n```\n\nThrown from method:\n\n```csharp\n    private IJSInProcessRuntime SynchronousJSRuntime => (IJSInProcessRuntime)jsRuntime;\n\n    public T? GetGlobalProperty<[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicConstructors)] T>(string path)\n    {\n        return SynchronousJSRuntime\n            .Invoke<JsonElement>(GetScopedFunctionName(\"getGlobalPropertyByString\"), path)\n            .Deserialize<T>(DefaultInteropJsonSerializerOptions.Instance);\n    }\n```\n\nSimple serializer options:\n\n```csharp\npublic static class DefaultInteropJsonSerializerOptions\n{\n    public static JsonSerializerOptions Instance { get; } = new()\n    {\n        Converters = { new JsonStringEnumConverter() },\n        PropertyNameCaseInsensitive = true\n    };\n}\n```",
          "createdAt": "2025-01-24T12:00:11Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-01-24T12:04:12Z",
          "id": "IC_kwDODI9FZc67xNt9"
        },
        {
          "author": "pingu2k4",
          "body": "> [@pingu2k4](https://github.com/pingu2k4) Have you tried version 8.0.12 of the package?: https://www.nuget.org/packages/Microsoft.Authentication.WebAssembly.Msal/8.0.12\n\nHey, thanks for the response.\n\nI've just tested this by updating to 8.0.12, and removing `<NullabilityInfoContextSupport>true</NullabilityInfoContextSupport>` from the csproj, and the issue returns. It still requires the change to csproj to work in 8.0.12 for me.",
          "createdAt": "2025-01-24T13:12:52Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-01-24T13:12:52Z",
          "id": "IC_kwDODI9FZc67xNuT"
        },
        {
          "author": "pingu2k4",
          "body": "@FLAMESpl - Have you tried adding to your csproj:\n```\n<NullabilityInfoContextSupport>true</NullabilityInfoContextSupport>\n```\nThis seemed to fix things for me, might work in your case also? ",
          "createdAt": "2025-01-24T13:14:07Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-01-24T13:14:07Z",
          "id": "IC_kwDODI9FZc67xNuX"
        },
        {
          "author": "FLAMESpl",
          "body": "Yes, adding `NullabilityInfoContextSupport` fixes it for me.",
          "createdAt": "2025-01-24T15:17:43Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-01-24T17:12:32Z",
                "user": "pingu2k4"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOEc_s8w=="
          },
          "updatedAt": "2025-01-24T15:17:43Z",
          "id": "IC_kwDODI9FZc67xNug"
        },
        {
          "author": "halter73",
          "body": "I fixed an issue related to overtrimming in the last release, but this is different. This appears to be related to https://github.com/dotnet/runtime/issues/102848.\n\nI think the fact that `<NullabilityInfoContextSupport>true</NullabilityInfoContextSupport>` fixes this is a big hint that this is an issue with the BlazorWebAssembly SDK and not `Microsoft.Authentication.WebAssembly.Msal`. `NullabilityInfoContextSupport` should be enabled by default.\n\nI know you changed this in https://github.com/dotnet/sdk/pull/41412 @javiercn. Do you have any idea why manually setting `NullabilityInfoContextSupport` is still necessary? Is it possible the issue is that this wasn't backported to the .NET 8 SDK?",
          "createdAt": "2025-01-29T20:33:26Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-01-29T20:33:26Z",
          "id": "IC_kwDODI9FZc67xNur"
        },
        {
          "author": "javiercn",
          "body": "@pingu2k4 what version of the SDK are you using?",
          "createdAt": "2025-01-30T15:13:50Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-01-30T15:13:50Z",
          "id": "IC_kwDODI9FZc67xNuy"
        },
        {
          "author": "dotnet-policy-service",
          "body": "Hi @pingu2k4. We have added the \"Needs: Author Feedback\" label to this issue, which indicates that we have an open question for you before we can take further action. This issue will be closed automatically in 7 days if we do not hear back from you by then - please feel free to re-open it if you come back to this issue after that time.\n<!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. -->",
          "createdAt": "2025-01-30T15:20:55Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-01-30T15:20:55Z",
          "id": "IC_kwDODI9FZc67xNu6"
        },
        {
          "author": "FLAMESpl",
          "body": "For me, it just happened when upgrading from 8.0.404 to 8.0.405.",
          "createdAt": "2025-01-31T15:45:51Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-01-31T15:46:14Z",
          "id": "IC_kwDODI9FZc67xNvE"
        },
        {
          "author": "dotnet-policy-service",
          "body": "This issue has been automatically marked as stale because it has been marked as requiring author feedback but has not had any activity for **4 days**. It will be closed if no further activity occurs **within 3 days of this comment**. If it *is* closed, feel free to comment when you are able to provide the additional information and we will re-investigate.\n\nSee [our Issue Management Policies](https://aka.ms/aspnet/issue-policies) for more information.\n<!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. -->",
          "createdAt": "2025-02-05T00:05:05Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-02-05T00:05:05Z",
          "id": "IC_kwDODI9FZc67xNvP"
        },
        {
          "author": "lewing",
          "body": "related to servicing of https://github.com/dotnet/runtime/pull/112216 cc @danroth27 ",
          "createdAt": "2025-02-10T18:53:00Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-02-10T18:53:00Z",
          "id": "IC_kwDODI9FZc67xNvX"
        },
        {
          "author": "javiercn",
          "body": "@lewing @danroth27 this seems to already have been addressed in 9.0 and 10.0, but it seems it didn't make it to 8.0.\n",
          "createdAt": "2025-08-04T11:30:53Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-08-04T11:30:53Z",
          "id": "IC_kwDODI9FZc67xNvd"
        },
        {
          "author": "javiercn",
          "body": "Relevant files:\n\nhttps://github.com/dotnet/runtime/blob/release/8.0/src/mono/nuget/Microsoft.NET.Sdk.WebAssembly.Pack/build/Microsoft.NET.Sdk.WebAssembly.Browser.targets\nhttps://github.com/dotnet/runtime/blob/release/9.0/src/mono/nuget/Microsoft.NET.Sdk.WebAssembly.Pack/build/Microsoft.NET.Sdk.WebAssembly.Browser.targets\nhttps://github.com/dotnet/runtime/blob/release/10.0/src/mono/nuget/Microsoft.NET.Sdk.WebAssembly.Pack/build/Microsoft.NET.Sdk.WebAssembly.Browser.targets\n\nI'm moving this to the runtime repo since the fix will have to be done there, we can decide on the backport\n",
          "createdAt": "2025-08-04T11:32:55Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-08-04T11:32:55Z",
          "id": "IC_kwDODI9FZc67xNvk"
        },
        {
          "author": "jeffhandley",
          "body": "@eiriktsarpalis Automated backporting of #102852 to address this failed, and manual backporting is needed. Please prepare a backport to `release/8.0-staging` that brings the fix for #102848 into consideration for 8.0 servicing. The backport will need the template and https://github.com/dotnet/runtime/labels/Servicing-consider label for Tactics discussion. Thank you.",
          "createdAt": "2025-08-31T16:00:46Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-08-31T16:00:46Z",
          "id": "IC_kwDODI9FZc7BIiSh"
        },
        {
          "author": "eiriktsarpalis",
          "body": "@javiercn @jeffhandley what necessitates a backport to .NET 8? STJ only added support for nullable reference type resolution in .NET 9, so it shouldn't try to resolve NullabilityInfo information in versions before that.",
          "createdAt": "2025-08-31T21:16:53Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-08-31T21:17:03Z",
          "id": "IC_kwDODI9FZc7BJN49"
        },
        {
          "author": "dotnet-policy-service",
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. -->",
          "createdAt": "2025-09-01T15:36:22Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-09-01T15:36:22Z",
          "id": "IC_kwDODI9FZc7BSKhx"
        },
        {
          "author": "jeffhandley",
          "body": "@eiriktsarpalis Customers are pulling in the 9.0.x version of System.Text.Json into their dependency graphs while targeting .NET 8. @FLAMESpl captured their package versions in [this comment](https://github.com/dotnet/runtime/issues/118333#issuecomment-3150240637).\n\nI think it's worth considering the backport since customers are updating their packages and/or getting 9.0.x of STJ transitively and getting this strange error that is hard to diagnose and resolve while targeting the .NET 8 LTS version.",
          "createdAt": "2025-09-01T19:11:37Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-09-01T19:11:37Z",
          "id": "IC_kwDODI9FZc7BThuj"
        },
        {
          "author": "jeffhandley",
          "body": "@eiriktsarpalis And after sending that, I just realized that backporting to STF 8.0.x doesn't actually address the issue. We'd need a different mechanism in STJ 9+ to not hit this issue when targeting .NET 8--that makes this a new fix rather than a backport.",
          "createdAt": "2025-09-01T19:15:30Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-09-01T19:15:30Z",
          "id": "IC_kwDODI9FZc7BTi3l"
        },
        {
          "author": "eiriktsarpalis",
          "body": "What is the scenario? Assuming somebody uses STJ v9 on .NET 8 then the fix as introduced in #102852 should still result in the disabled feature switch being handled gracefully.",
          "createdAt": "2025-09-01T20:55:13Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-09-01T20:55:36Z",
          "id": "IC_kwDODI9FZc7BT_Xm"
        }
      ],
      "totalCount": 23,
      "endCursor": "Y3Vyc29yOnYyOpHOwU_15g=="
    },
    "url": "https://github.com/dotnet/runtime/issues/118333",
    "title": "Msal Auth stopped working on live environment - NullabilityInfoContext_NotSupported"
  },
  {
    "author": "carlossanlop",
    "labels": [
      "area-System.Text.Json",
      "os-mac-os-x",
      "arch-x64",
      "blocking-clean-ci",
      "runtime-coreclr",
      "Known Build Error"
    ],
    "createdAt": "2025-01-10T18:10:51Z",
    "body": "@dotnet/area-system-text-json \n\n## Build Information\nBuild: https://dev.azure.com/dnceng-public/cbb18261-c48f-4abb-8651-8cdcb5474649/_build/results?buildId=909335\nBuild error leg or test failing: System.Text.Json.Tests.WorkItemExecution in Libraries Test Run checked coreclr osx x64 Debug\nPull request: https://github.com/dotnet/runtime.git/pull/111171\n<!-- Error message template  -->\n## Error Message\n\nFill the error message using [step by step known issues guidance](https://github.com/dotnet/arcade/blob/main/Documentation/Projects/Build%20Analysis/KnownIssueJsonStepByStep.md).\n\n<!-- Use ErrorMessage for String.Contains matches. Use ErrorPattern for regex matches (single line/no backtracking). Set BuildRetry to `true` to retry builds with this error. Set ExcludeConsoleLog to `true` to skip helix logs analysis. -->\n\n```json\n{\n  \"ErrorMessage\": [\"Stack overflow.\", \"at System.Text.Json.ReadStack\"],\n  \"ErrorPattern\": \"\",\n  \"BuildRetry\": false,\n  \"ExcludeConsoleLog\": false\n}\n```\n\n- Job: https://dev.azure.com/dnceng-public/public/_build/results?buildId=909335&view=logs&j=69b60b53-a417-56e9-d4e0-3a40344d5e67&t=3caa942a-fc58-5e1f-0b98-b7d7725d89c0&l=57\n- Console: https://helixr1107v0xdeko0k025g8.blob.core.windows.net/dotnet-runtime-refs-pull-111171-merge-5bdad9199a664fcbb9/System.Text.Json.Tests/1/console.d1f6b6ec.log?helixlogtype=result\n- Output:\n```\n===========================================================================================================\n/private/tmp/helix/working/B79B0990/w/A538092F/e /private/tmp/helix/working/B79B0990/w/A538092F/e\n  Discovering: System.Text.Json.Tests (method display = ClassAndMethod, method display options = None)\n  Discovered:  System.Text.Json.Tests (found 7235 of 7307 test cases)\n  Starting:    System.Text.Json.Tests (parallel test collections = on, max threads = 12)\nStack overflow.\n   at System.GC.AllocateNewArray(IntPtr, Int32, GC_ALLOC_FLAGS)\n   at System.Text.StringBuilder.ExpandByABlock(Int32)\n   at System.Text.StringBuilder.AppendWithExpansion(Char ByRef, Int32)\n   at System.Text.StringBuilder.Append(System.String)\n   at System.Text.Json.ReadStack.<JsonPath>g__AppendPropertyName|24_2(System.Text.StringBuilder, System.String)\n   at System.Text.Json.ReadStack.<JsonPath>g__AppendStackFrame|24_0(System.Text.StringBuilder, System.Text.Json.ReadStackFrame ByRef)\n   at System.Text.Json.ReadStack.JsonPath()\n   at System.Text.Json.ReadStack.Push()\n   at System.Text.Json.Serialization.JsonConverter`1[[System.__Canon, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].TryRead(System.Text.Json.Utf8JsonReader ByRef, System.Type, System.Text.Json.JsonSerializerOptions, System.Text.Json.ReadStack ByRef, System.__Canon ByRef, Boolean ByRef)\n   at System.Text.Json.Serialization.Metadata.JsonPropertyInfo`1[[System.__Canon, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].ReadJsonAndSetMember(System.Object, System.Text.Json.ReadStack ByRef, System.Text.Json.Utf8JsonReader ByRef)\n   at System.Text.Json.Serialization.Converters.ObjectDefaultConverter`1[[System.__Canon, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].ReadPropertyValue(System.Object, System.Text.Json.ReadStack ByRef, System.Text.Json.Utf8JsonReader ByRef, System.Text.Json.Serialization.Metadata.JsonPropertyInfo, Boolean)\n   at System.Text.Json.Serialization.Converters.ObjectDefaultConverter`1[[System.__Canon, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].PopulatePropertiesFastPath(System.Object, System.Text.Json.Serialization.Metadata.JsonTypeInfo, System.Text.Json.JsonSerializerOptions, System.Text.Json.Utf8JsonReader ByRef, System.Text.Json.ReadStack ByRef)\n   at System.Text.Json.Serialization.Converters.ObjectDefaultConverter`1[[System.__Canon, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].OnTryRead(System.Text.Json.Utf8JsonReader ByRef, System.Type, System.Text.Json.JsonSerializerOptions, System.Text.Json.ReadStack ByRef, System.__Canon ByRef)\n   at System.Text.Json.Serialization.JsonConverter`1[[System.__Canon, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].TryRead(System.Text.Json.Utf8JsonReader ByRef, System.Type, System.Text.Json.JsonSerializerOptions, System.Text.Json.ReadStack ByRef, System.__Canon ByRef, Boolean ByRef)\n   at System.Text.Json.Serialization.JsonCollectionConverter`2[[System.__Canon, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e],[System.__Canon, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].OnTryRead(System.Text.Json.Utf8JsonReader ByRef, System.Type, System.Text.Json.JsonSerializerOptions, System.Text.Json.ReadStack ByRef, System.__Canon ByRef)\n   at System.Text.Json.Serialization.JsonConverter`1[[System.__Canon, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].TryRead(System.Text.Json.Utf8JsonReader ByRef, System.Type, System.Text.Json.JsonSerializerOptions, System.Text.Json.ReadStack ByRef, System.__Canon ByRef, Boolean ByRef)\n...\n...\n   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1[[System.__Canon, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].Start[[Xunit.Sdk.TestCollectionRunner`1+<RunTestClassesAsync>d__28[[System.__Canon, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]], xunit.execution.dotnet, Version=2.4.2.0, Culture=neutral, PublicKeyToken=8d05b1bb7a6fdb6c]](<RunTestClassesAsync>d__28<System.__Canon> ByRef)\n   at Xunit.Sdk.TestCollectionRunner`1[[System.__Canon, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].RunTestClassesAsync()\n   at Xunit.Sdk.TestCollectionRunner`1+<RunAsync>d__27[[System.__Canon, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].MoveNext()\n   at System.Runtime.CompilerServices.AsyncMethodBuilderCore.Start[[Xunit.Sdk.TestCollectionRunner`1+<RunAsync>d__27[[System.__Canon, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]], xunit.execution.dotnet, Version=2.4.2.0, Culture=neutral, PublicKeyToken=8d05b1bb7a6fdb6c]](<RunAsync>d__27<System.__Canon> ByRef)\n   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1[[System.__Canon, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].Start[[Xunit.Sdk.TestCollectionRunner`1+<RunAsync>d__27[[System.__Canon, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]], xunit.execution.dotnet, Version=2.4.2.0, Culture=neutral, PublicKeyToken=8d05b1bb7a6fdb6c]](<RunAsync>d__27<System.__Canon> ByRef)\n   at Xunit.Sdk.TestCollectionRunner`1[[System.__Canon, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].RunAsync()\n   at Xunit.Sdk.XunitTestAssemblyRunner.RunTestCollectionAsync(Xunit.Sdk.IMessageBus, Xunit.Abstractions.ITestCollection, System.Collections.Generic.IEnumerable`1<Xunit.Sdk.IXunitTestCase>, System.Threading.CancellationTokenSource)\n   at Xunit.Sdk.XunitTestAssemblyRunner+<>c__DisplayClass14_2.<RunTestCollectionsAsync>b__2()\n   at System.Threading.Tasks.Task`1[[System.__Canon, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].InnerInvoke()\n   at System.Threading.Tasks.Task+<>c.<.cctor>b__281_0(System.Object)\n   at System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object)\n   at System.Threading.Tasks.Task.ExecuteWithThreadLocal(System.Threading.Tasks.Task ByRef, System.Threading.Thread)\n   at System.Threading.Tasks.Task.ExecuteEntry()\n   at System.Threading.Tasks.SynchronizationContextTaskScheduler+<>c.<.cctor>b__8_0(System.Object)\n   at Xunit.Sdk.MaxConcurrencySyncContext.RunOnSyncContext(System.Threading.SendOrPostCallback, System.Object)\n   at Xunit.Sdk.MaxConcurrencySyncContext+<>c__DisplayClass11_0.<WorkerThreadProc>b__0(System.Object)\n   at System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object)\n   at Xunit.Sdk.ExecutionContextHelper.Run(System.Object, System.Action`1<System.Object>)\n   at Xunit.Sdk.MaxConcurrencySyncContext.WorkerThreadProc()\n   at Xunit.Sdk.XunitWorkerThread+<>c.<QueueUserWorkItem>b__5_0(System.Object)\n   at System.Threading.Tasks.Task.InnerInvoke()\n   at System.Threading.Tasks.Task+<>c.<.cctor>b__281_0(System.Object)\n   at System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object)\n   at System.Threading.Tasks.Task.ExecuteWithThreadLocal(System.Threading.Tasks.Task ByRef, System.Threading.Thread)\n   at System.Threading.Tasks.Task.ExecuteEntryUnsafe(System.Threading.Thread)\n   at System.Threading.Tasks.ThreadPoolTaskScheduler+<>c.<.cctor>b__10_0(System.Object)\n   at System.Threading.Thread+StartHelper.RunWorker()\n   at System.Threading.Thread+StartHelper.Run()\n   at System.Threading.Thread.StartCallback()\n./RunTests.sh: line 168: 72518 Abort trap: 6           \"$RUNTIME_PATH/dotnet\" exec --runtimeconfig System.Text.Json.Tests.runtimeconfig.json --depsfile System.Text.Json.Tests.deps.json xunit.console.dll System.Text.Json.Tests.dll -xml testResults.xml -nologo -nocolor -notrait category=IgnoreForCI -notrait category=OuterLoop -notrait category=failing $RSP_FILE\n/private/tmp/helix/working/B79B0990/w/A538092F/e\n----- end Tue Jan 7 14:31:09 EST 2025 ----- exit code 134 ----------------------------------------------------------\n```\n\r\n<!-- Known issue validation start -->\r\n ### Known issue validation\r\n**Build: :mag_right:** https://dev.azure.com/dnceng-public/public/_build/results?buildId=909335\r\n**Error message validated:** `[Stack overflow. at System.Text.Json.ReadStack`]\r\n**Result validation:** :white_check_mark: Known issue matched with the provided build.\r\n**Validation performed at:** 1/10/2025 6:11:16 PM UTC\r\n<!-- Known issue validation end -->\r\n<!--Known issue error report start -->\r\n\r\n### Report\r\n\r\n|Build|Definition|Test|Pull Request|\r\n|---|---|---|---|\r\n|[1153034](https://dev.azure.com/dnceng-public/public/_build/results?buildId=1153034)|dotnet/runtime|[System.Text.Json.Tests.WorkItemExecution](https://dev.azure.com/dnceng-public/public/_build/results?buildId=1153034&view=ms.vss-test-web.build-test-results-tab&runId=31852650&resultId=202279)|dotnet/runtime#119829|\r\n|[1151410](https://dev.azure.com/dnceng-public/public/_build/results?buildId=1151410)|dotnet/runtime|[System.Text.Json.Tests.WorkItemExecution](https://dev.azure.com/dnceng-public/public/_build/results?buildId=1151410&view=ms.vss-test-web.build-test-results-tab&runId=31807460&resultId=193490)|dotnet/runtime#119829|\r\n|[1148476](https://dev.azure.com/dnceng-public/public/_build/results?buildId=1148476)|dotnet/runtime|[System.Text.Json.Tests.WorkItemExecution](https://dev.azure.com/dnceng-public/public/_build/results?buildId=1148476&view=ms.vss-test-web.build-test-results-tab&runId=31715034&resultId=202279)|dotnet/runtime#119717|\r\n|[1147145](https://dev.azure.com/dnceng-public/public/_build/results?buildId=1147145)|dotnet/runtime|[System.Text.Json.Tests.WorkItemExecution](https://dev.azure.com/dnceng-public/public/_build/results?buildId=1147145&view=ms.vss-test-web.build-test-results-tab&runId=31670690&resultId=211961)|dotnet/runtime#119675|\r\n|[1147155](https://dev.azure.com/dnceng-public/public/_build/results?buildId=1147155)|dotnet/runtime|[System.Text.Json.Tests.WorkItemExecution](https://dev.azure.com/dnceng-public/public/_build/results?buildId=1147155&view=ms.vss-test-web.build-test-results-tab&runId=31665412&resultId=202279)|dotnet/runtime#119676|\r\n|[1146634](https://dev.azure.com/dnceng-public/public/_build/results?buildId=1146634)|dotnet/runtime|[System.Text.Json.Tests.WorkItemExecution](https://dev.azure.com/dnceng-public/public/_build/results?buildId=1146634&view=ms.vss-test-web.build-test-results-tab&runId=31642938&resultId=204279)|dotnet/runtime#118491|\r\n|[1143020](https://dev.azure.com/dnceng-public/public/_build/results?buildId=1143020)|dotnet/runtime|[System.Text.Json.Tests.WorkItemExecution](https://dev.azure.com/dnceng-public/public/_build/results?buildId=1143020&view=ms.vss-test-web.build-test-results-tab&runId=31513978&resultId=202279)|dotnet/runtime#119482|\r\n|[1141860](https://dev.azure.com/dnceng-public/public/_build/results?buildId=1141860)|dotnet/runtime|[System.Text.Json.Tests.WorkItemExecution](https://dev.azure.com/dnceng-public/public/_build/results?buildId=1141860&view=ms.vss-test-web.build-test-results-tab&runId=31474580&resultId=202279)|dotnet/runtime#119454|\r\n#### Summary\r\n|24-Hour Hit Count|7-Day Hit Count|1-Month Count|\r\n|---|---|---|\r\n|0|3|8|\r\n<!--Known issue error report end -->",
    "number": 111280,
    "reactions": {
      "hasNextPage": false,
      "nodes": [],
      "totalCount": 0,
      "endCursor": null
    },
    "updatedAt": "2025-09-21T04:02:47Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": "dotnet-policy-service",
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. -->",
          "createdAt": "2025-01-10T18:11:13Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-01-10T18:11:13Z",
          "id": "IC_kwDODI9FZc6Z_Dha"
        }
      ],
      "totalCount": 1,
      "endCursor": "Y3Vyc29yOnYyOpHOmfw4Wg=="
    },
    "url": "https://github.com/dotnet/runtime/issues/111280",
    "title": "[8.0] System.Text.Json Stack overflow in JsonConverter"
  },
  {
    "author": "rynowak",
    "labels": [
      "area-System.Text.Json",
      "partner-impact"
    ],
    "createdAt": "2025-01-23T18:12:28Z",
    "body": "## Scenario\n\nMy use case is deserializing polymorphic JSON data from an external REST API that's following the well-known discriminator pattern using `$type`. The challenge is that don't control this API and they continue to add new discriminator values.\n\nThis is further complicated because we need to do custom processing on *some* of the types of data returned by the API. So we want to define C# types for *some* of the API data but not all of it.\n\nThis isn't quite an API proposal *per-se* because I'm looking for feedback on the approach and overall idea. If this seems like a good idea, I could turn it into that.\n\nThe code that I want to write looks something like this:\n\n```csharp\nrecord struct Response(IReadOnlyList<IWidget>? widgets);\n\n[JsonPolymorphic(TypeDiscriminatorPropertyName = \"$type\")]\n[JsonDerivedType(typeof(A), \"A\")]\n[JsonDerivedType(typeof(B), \"B\")]\n[JsonDerivedType(typeof(Unknown), Fallback = true)] // This feature doesn't exist\ninterface IWidget;\n\nrecord struct A([property: JsonRequired] IReadOnlyList<DetailsA> details) : IWidget;\nrecord struct B([property: JsonRequired] IReadOnlyList<DetailsB> details) : IWidget;\n\nrecord struct DetailsA(/* omitted */);\nrecord struct DetailsB(/* omitted */);\n\nrecord struct Unknown(\n  [property: JsonRequired, JsonPropertyName(\"$type\")] string widgetType,\n  [property: JsonRequired] IReadOnlyList<Dictionary<string, JsonElement> details) : IWidget;\n\n\n// Then later\nvar widget = JsonSerializer.Deserialize<IWidget>(...);\nreturn widget switch =>\n{\n    A a => ProcessA(a),\n    B b => ProcessB(b),\n    Unknown u => ProcessUnknown(u),\n    _ => throw new NotSupportedException(),\n};\n```\n\nThis is good because we can agnostically \"pass through\" any new widget types returned by the service we're calling. We only need to define new C# types whenever a specific widget type requires some business logic.\n\n*Note: This example uses an interface + record structs. I'm not sure if that's optimal from a performance POV, and it could be somewhat flexible. Unless I'm missing something, whether it's classes or structs doesn't really affect my scenario.*\n\n## What I tried\n\nI can't use `IgnoreUnrecognizedTypeDiscriminators` because I need to read all the data. \n\nTraditional inheritance isn't a good solution for this because both the child and base class need to define `details` with different types. Therefore I can't use `UnknownDerivedTypeHandling`. I'm not sure it applies to deserialization anyway.\n\nI also need to round-trip the data without information loss, so I'd need something like https://github.com/dotnet/runtime/issues/108885 to be addressed.\n\nI'd really like to avoid duplicating the functionality of `[JsonPolymorphic]` by writing or generating our own serialization logic.\n\nIt's also not possible to use both of `JsonConverter` and `JsonPolymorphic` for the same type.\n\n## Why this is valuable\n\nAs C# has added more language features for immutability and sum types (eg: records, pattern matching) we're using these patterns to great success.\n\nSTJ has really excellent support for working with a closed set of polymorphic strong types. This is about a the ability to work with an open set, or partial-typing. \n\nI'm wondering if a lot of the other issues that have been opened on `[JsonPolymorphic]` are asking about workarounds for this scenario.\n\n## An approach that works with drawbacks\n\nI found an approach that works and I'm currently trying to shake out all of the problems with. I'd appreciate any feedback that the experts can share in case this can be improved.\n\nThis works by defining two polymorphic types:\n\n- One with a `JsonConverter` \n- One with `JsonPolymorphic`\n\nThe job of the converter is to detect whether or not the discriminator value is part of the 'known' set. I can do this by using `JsonTypeInfo<>` so I have a single source of truth. Then it calls into the serialize for either `IStronglyTypedWidget` or `Unknown`.\n\nI think the drawbacks of this are:\n\n- It's complicated: we need artificial things like a marker interface.\n- It affects performance: we to run a converter and do things inside like copy the reader. This is a performance sensitive code path that runs at scale. The converter code needs to run for every widget, not just the unknown path.\n\nI'm currently working on a benchmark for the approach below in comparison with static approaches like hand-writing the serializer. Happy to share the results if it's interesting. I remember from the design discussions that converters introduce buffering, and that's the part that most concerns me.\n\n```csharp\nrecord struct Response(IReadOnlyList<IWidget>? widgets);\n\n[JsonConverter(...)]\ninterface IWidget;\n\n[JsonPolymorphic(TypeDiscriminatorPropertyName = \"$type\")]\n[JsonDerivedType(typeof(A), \"A\")]\n[JsonDerivedType(typeof(B), \"B\")]\n[JsonDerivedType(typeof(Unknown), Fallback = true)] // This feature doesn't exist\ninterface IStronglyTypedWidget;\n\nrecord struct A([property: JsonRequired] IReadOnlyList<DetailsA> details) : IStronglyTypedWidget;\nrecord struct B([property: JsonRequired] IReadOnlyList<DetailsB> details) : IStronglyTypedWidget;\n\nrecord struct DetailsA(/* omitted */);\nrecord struct DetailsB(/* omitted */);\n\nrecord struct Unknown(\n  [property: JsonRequired, JsonPropertyName(\"$type\")] string widgetType,\n  [property: JsonRequired] IReadOnlyList<Dictionary<string, JsonElement> details) : IWidget;\n\n// Many details omitted or simplified\nclass WidgetConverter : JsonConverter<IWidget>\n{\n    public override bool CanConvert(Type typeToConvert) => typeToConvert.IsAssignableTo(typeof(IWidget));\n\n    public override IWidget Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)\n    {\n        // Copy reader so we can advance the token stream separately.\n        using var copy = reader;\n        copy.Read();\n\n        var discriminatorProperty = copy.GetString();\n        copy.Read();\n \n        var discriminatorValue = copy.GetString();\n        if (IsKnownDiscriminatorValue(discriminatorValue))\n        {\n          return JsonSerializer.Deserialize<IStronglyTypedWidget>(reader)\n        }\n\n        return JsonSerializer.Deserialize<Unknown>(reader)\n    }\n```",
    "number": 111755,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-01-30T08:45:46Z",
          "user": "blundell89"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-06-21T06:46:07Z",
          "user": "Viincenttt"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-07-02T18:04:32Z",
          "user": "juliancarrivick"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-09-08T14:41:16Z",
          "user": "dil-apfeff"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-09-08T14:45:28Z",
          "user": "dil-jtoth"
        }
      ],
      "totalCount": 5,
      "endCursor": "Y3Vyc29yOnYyOpHODPGeLQ=="
    },
    "updatedAt": "2025-09-12T06:24:49Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": "dotnet-policy-service",
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. -->",
          "createdAt": "2025-01-23T18:12:58Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-01-23T18:12:58Z",
          "id": "IC_kwDODI9FZc6bmuAk"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Hi @rynowak, thanks for the detailed write-up -- this is good feedback. I think it should be possible in principle to implement something that supports your use case (with a few minor tweaks to keep it compatible with the current contract model):\n\n```C#\n[JsonPolymorphic(TypeDiscriminatorPropertyName = \"$type\", Fallback = typeof(Unknown))]\n[JsonDerivedType(typeof(A), \"A\")]\n[JsonDerivedType(typeof(B), \"B\")]\ninterface IWidget;\n```\n\nJudging by your second example, I would infer that you need a way to bind the unrecognized discriminator id to a property of the `Unknown` type? This is not something that STJ polymorphism supports today, discriminators are specified using type-level mappings to ensure opted in derived types are roundtripped correctly. The same concern shouldn't apply to a general-purpose fallback type though and we might be able to make an exception there. It should be possible to either explicitly bind to the discriminator for a given property like in your example, or perhaps collect all unbound properties via the existing extension data mechanism like so:\n```C#\npublic record Unknown : IWidget\n{\n     [JsonExtensionData]\n     public IDictionary<string, object?>? AdditionalProperties { get; set; }\n}\n```\nwhich should accumulate all unbound properties (including the type discriminator). This should ensure that values can be safely roundtripped as well. Any such work should be done in conjunction with https://github.com/dotnet/runtime/issues/72170.\n",
          "createdAt": "2025-01-24T11:53:29Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "EYES",
                "createdAt": "2025-01-24T16:42:06Z",
                "user": "NinoFloris"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOED7LYg=="
          },
          "updatedAt": "2025-01-24T11:53:29Z",
          "id": "IC_kwDODI9FZc6btUD7"
        },
        {
          "author": "rynowak",
          "body": "Thanks @eiriktsarpalis for taking a look at this.\n\n> Judging by your second example, I would infer that you need a way to bind the unrecognized discriminator id to a property of the Unknown type?\n\nYes that's right. I linked https://github.com/dotnet/runtime/issues/108885 because it seems relevant.\n\n> It should be possible to either explicitly bind to the discriminator for a given property\n\nThis is what I ended up doing. \n\nDo you have any feedback on the approach of writing a `JsonConverter` for this? The one I wrote works, but impacts performance. I'm seeing a 1.6x-2.0x increase in execution time compared to \"just\" the source-generated serializer (without support for fallback). The profiles also show very little exclusive time spent in my converter.",
          "createdAt": "2025-01-24T20:47:52Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-01-24T20:47:52Z",
          "id": "IC_kwDODI9FZc6bxJ18"
        },
        {
          "author": "eiriktsarpalis",
          "body": "> Do you have any feedback on the approach of writing a `JsonConverter` for this? The one I wrote works, but impacts performance. I'm seeing a 1.6x-2.0x increase in execution time compared to \"just\" the source-generated serializer (without support for fallback). The profiles also show very little exclusive time spent in my converter.\n\nIt looks like a good solution to me. While it's not entirely clear to me what could be causing the regression, custom converters don't support streaming serialization. So if your converter is deserializing a relatively large payload from a stream, it will prompt the serializer to pre-buffer the entire contents of the upcoming JSON value.",
          "createdAt": "2025-01-26T19:47:50Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-01-26T19:47:50Z",
          "id": "IC_kwDODI9FZc6b1x6e"
        },
        {
          "author": "jeffhandley",
          "body": "Assigning to @eiriktsarpalis for the further triage by way of assessing impact and feasibility to determine if this should be in the 10.0.0 milestone.",
          "createdAt": "2025-02-09T13:00:18Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-02-09T13:00:18Z",
          "id": "IC_kwDODI9FZc6dux8b"
        },
        {
          "author": "jeffhandley",
          "body": "@eiriktsarpalis and I chatted about this. The value is clear, but we're not certain it'll fit within our 10.0.0 plans. I'm going to put it into the milestone and we will try to get to it knowing it's possible that it'll slip.",
          "createdAt": "2025-02-10T18:06:22Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-02-10T18:07:04Z",
                "user": "eiriktsarpalis"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-02-17T22:39:39Z",
                "user": "Rauell"
              }
            ],
            "totalCount": 2,
            "endCursor": "Y3Vyc29yOnYyOpHOEGpS6w=="
          },
          "updatedAt": "2025-02-10T18:06:22Z",
          "id": "IC_kwDODI9FZc6d4i1m"
        },
        {
          "author": "RyanThomas73",
          "body": "For anyone coming across this issue looking for a workaround in the interim - a while ago I was able to work around the issue using a custom attribute + [custom type info resolver](https://github.com/RhinobyteSoftware/dotnet-extensions/blob/91af07ff143aa811259b7ac98b7ec8e85ab56e9c/src/Rhinobyte.Extensions.Json/PolymorphicFallbackTypeResolver.cs#L15) to specify my 'fallback type'. \n\nA caveat compared to Ryan Nowak's converter workaround shown above - I'm not aware of any way the type info resolver approach can capture the $type property as `[JsonExtensionData]` does not treat it as unbound when using `[JsonPolymorphic(IgnoreUnrecognizedTypeDiscriminators = true)]`. But I assume the type info resolver approach would not suffer from the stream pre-buffering problem [that Eirik mentioned in this comment](https://github.com/dotnet/runtime/issues/111755#issuecomment-2614566558)\n\n\n\n\n",
          "createdAt": "2025-06-23T17:45:30Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-06-23T17:45:30Z",
          "id": "IC_kwDODI9FZc6yp9FA"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Sadly, it's unlikely we'll be able to work on this for .NET 10. Moving to 11.",
          "createdAt": "2025-07-17T16:44:00Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-07-17T16:44:00Z",
          "id": "IC_kwDODI9FZc633Um9"
        },
        {
          "author": "bunnyi116",
          "body": "> Hi [@rynowak](https://github.com/rynowak), thanks for the detailed write-up -- this is good feedback. I think it should be possible in principle to implement something that supports your use case (with a few minor tweaks to keep it compatible with the current contract model):\n> \n> [JsonPolymorphic(TypeDiscriminatorPropertyName = \"$type\", Fallback = typeof(Unknown))]\n> [JsonDerivedType(typeof(A), \"A\")]\n> [JsonDerivedType(typeof(B), \"B\")]\n> interface IWidget;\n> Judging by your second example, I would infer that you need a way to bind the unrecognized discriminator id to a property of the `Unknown` type? This is not something that STJ polymorphism supports today, discriminators are specified using type-level mappings to ensure opted in derived types are roundtripped correctly. The same concern shouldn't apply to a general-purpose fallback type though and we might be able to make an exception there. It should be possible to either explicitly bind to the discriminator for a given property like in your example, or perhaps collect all unbound properties via the existing extension data mechanism like so:\n> \n> public record Unknown : IWidget\n> {\n>      [JsonExtensionData]\n>      public IDictionary<string, object?>? AdditionalProperties { get; set; }\n> }\n> which should accumulate all unbound properties (including the type discriminator). This should ensure that values can be safely roundtripped as well. Any such work should be done in conjunction with [#72170](https://github.com/dotnet/runtime/issues/72170).\n\n\n---\n\nI think this is great! However, I believe the `Unknown` class should receive raw JSON data for binding, and the bound content should be a `JsonElement`.\n\n```csharp\n[JsonPolymorphic(TypeDiscriminatorPropertyName = \"$type\", Fallback = typeof(Unknown))]\n[JsonDerivedType(typeof(A), \"A\")]\n[JsonDerivedType(typeof(B), \"B\")]\ninterface IWidget;\n```\n\n```csharp\npublic record Unknown : IWidget\n{\n     [JsonExtensionData] // or [JsonRawData]\n     public JsonElement RawData { get; set; }\n}\n```\n\n---\n",
          "createdAt": "2025-08-31T15:57:13Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-08-31T15:59:44Z",
          "id": "IC_kwDODI9FZc7BIh3S"
        },
        {
          "author": "MarcinJuraszek",
          "body": "We're running into this as well, and do need to be able to access the type discriminator property value in the fallback type that we'd like to create.\n\n**Is there a recommended workaround the .NET team could provide, while we wait for this new functionality to be added in .NET 11?**\n\nWe've tried the custom type info resolver suggested by @RyanThomas73 above, but it doesn't give us access to the `type` property.",
          "createdAt": "2025-09-10T03:23:04Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "EYES",
                "createdAt": "2025-09-11T18:44:55Z",
                "user": "alexhelms"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOEh5WIg=="
          },
          "updatedAt": "2025-09-10T03:23:04Z",
          "id": "IC_kwDODI9FZc7DF5lp"
        },
        {
          "author": "alexhelms",
          "body": "I am also running into what @MarcinJuraszek described. I need access to the discriminator property but it doesn't appear there is a way to get it. I tried using `[JsonExtensionData]` but the discriminator isn't present.",
          "createdAt": "2025-09-11T18:49:12Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-09-11T18:49:12Z",
          "id": "IC_kwDODI9FZc7DovL5"
        },
        {
          "author": "eiriktsarpalis",
          "body": "As things stand, you'd need to write your own custom converter that implements polymorphism to be able to extract the underlying discriminator value.",
          "createdAt": "2025-09-12T06:24:49Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-09-12T06:24:49Z",
          "id": "IC_kwDODI9FZc7DvATU"
        }
      ],
      "totalCount": 12,
      "endCursor": "Y3Vyc29yOnYyOpHOw7wE1A=="
    },
    "url": "https://github.com/dotnet/runtime/issues/111755",
    "title": "Fallback to configurable type for JsonPolymorphic deserialization"
  },
  {
    "author": "MagnusSandgren",
    "labels": [
      "api-suggestion",
      "area-System.Text.Json"
    ],
    "createdAt": "2025-01-27T13:14:31Z",
    "body": "### Background and motivation\n\nCould not find a similar issue - please correct me if this is a duplicate.\n\n### Summary\n\nIt would be extremely useful to have a built-in `JsonAlternativePropertyNameAttribute` in `System.Text.Json` to handle scenarios where a property might have multiple valid names in the JSON payload. This feature would simplify handling backward compatibility, versioning, and schema evolution without requiring extensive custom converters or breaking changes.\n\n---\n\n### Problem Statement\n\nWhen deserializing JSON using `System.Text.Json`, there is currently no straightforward way to map multiple property names in the JSON payload to a single property in a .NET class. This is particularly challenging when dealing with:\n\n1. **Typographical errors**: When legacy systems or earlier versions of an API have properties with incorrect spellings (e.g., `OccuredAt` vs. `OccurredAt`).\n2. **Schema evolution**: When properties are renamed in newer API versions, but backward compatibility must be maintained for older JSON payloads.\n3. **Third-party integrations**: When consuming JSON from external sources where property names may vary or use different conventions.\n\nCurrently, developers must write custom `JsonConverter` implementations to handle such scenarios. This can be verbose, error-prone, and cumbersome, especially when working with large models or frequent schema changes.\n\n---\n\n### Benefits\n\n1. **Simplified Code**: Reduces the need for custom `JsonConverter` implementations to handle alternative property names.\n2. **Backward Compatibility**: Makes it easier to maintain backward compatibility when property names evolve over time.\n3. **Reduced Boilerplate**: Eliminates repetitive code for handling common schema evolution scenarios.\n4. **Improved Developer Experience**: Aligns with the declarative and attribute-based design philosophy of `System.Text.Json`.\n\n---\n\n### Workarounds\n\nCurrently, developers must write custom `JsonConverter` implementations or preprocess JSON manually to handle such cases. While this works, it introduces unnecessary complexity and duplication, especially in larger projects or libraries.\n\n---\n\n### Considerations\n\n1. How will multiple `JsonAlternativePropertyNameAttribute` values interact with each other or with `JsonPropertyName`?\n2. Should deserialization prioritize `JsonPropertyName` over alternative names when multiple matches are found?\n3. How will this work with existing features like polymorphic deserialization or converters?\n\n### API Proposal\n\n### Proposed Solution\n\nIntroduce a `JsonAlternativePropertyNameAttribute` to specify alternative names for a property during deserialization. \n\n```csharp\npublic class MyEvent\n{\n    [JsonPropertyName(\"OccurredAt\")]\n    [JsonAlternativePropertyName(\"OccuredAt\")]\n    public DateTimeOffset OccurredAt { get; set; }\n\n    public string Name { get; set; }\n}\n```\n\nWith this attribute, the `OccurredAt` property would be deserialized correctly from JSON with either `OccurredAt` or `OccuredAt` as the property name.\n\n### API Usage\n\n#### Expected Behavior:\n\nGiven the following JSON payloads:\n\n```json\n{ \"OccuredAt\": \"2025-01-01T12:00:00Z\", \"Name\": \"Event1\" }\n{ \"OccurredAt\": \"2025-01-01T12:00:00Z\", \"Name\": \"Event2\" }\n```\n\nBoth should deserialize into the same object:\n\n```csharp\nvar myEvent = JsonSerializer.Deserialize<MyEvent>(json, options);\nConsole.WriteLine(myEvent.OccurredAt); // Outputs: 1/1/2025 12:00:00 PM\n```\n\nWhen serializing, the primary property name (`JsonPropertyName`) would be used, ensuring consistency:\n\n```csharp\nvar json = JsonSerializer.Serialize(myEvent);\nConsole.WriteLine(json); \n// Outputs: { \"OccurredAt\": \"2025-01-01T12:00:00Z\", \"Name\": \"Event1\" }\n```\n\n### Alternative Designs\n\n_No response_\n\n### Risks\n\n_No response_",
    "number": 111862,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "ROCKET",
          "createdAt": "2025-01-27T13:16:52Z",
          "user": "oskogstad"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-01-27T22:13:26Z",
          "user": "MichalPetryka"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-01-28T09:05:14Z",
          "user": "Xor-el"
        }
      ],
      "totalCount": 3,
      "endCursor": "Y3Vyc29yOnYyOpHOC-hp7g=="
    },
    "updatedAt": "2025-01-30T21:37:14Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": "dotnet-policy-service",
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. -->",
          "createdAt": "2025-01-27T13:14:57Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-01-27T13:14:57Z",
          "id": "IC_kwDODI9FZc6b6PEZ"
        },
        {
          "author": "eiriktsarpalis",
          "body": "I'm guessing though you could achieve the same functionality if you defined a proxy property that simply sets or gets the value from the original property.",
          "createdAt": "2025-01-27T13:19:47Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-01-27T13:19:47Z",
          "id": "IC_kwDODI9FZc6b6Rw9"
        },
        {
          "author": "MagnusSandgren",
          "body": "@eiriktsarpalis that is true. A similar solution could be archived through something like this:\n```csharp\npublic class MyEvent\n{\n    [Obsolete(\"Use OccurredAt instead.\")]\n    public DateTimeOffset OccuredAt { get; set; }\n\n    public DateTimeOffset OccurredAt\n    {\n        get => OccuredAt;\n        set => OccuredAt = value;\n    }\n}\n```\n\nWhich has the added benefit of telling the consumers to switch to OccurredAt through a grace period 🤔 However, I still think there is a place for the proposed attribute. Included, but not limited to the following use-case. Say we evolve `MyEvent` to the above example, give the consumers some time to adjust, then fully transition to the following:\n\n```csharp\npublic class MyEvent\n{\n    public DateTimeOffset OccurredAt { get; set; }\n}\n```\n\nNow when consumers update the contracts again the misspelled \"OccuredAt\" will not be deserialized. If for some reason, some consumers still have an old instance of MyEvent waiting to be consumed, an error will be lurking in the shadows. The author of the contract's library could offer a grace period still by adding the proposed attribute like so:\n\n```csharp\npublic class MyEvent\n{\n    [JsonAlternativePropertyName(\"OccuredAt\")]\n    public DateTimeOffset OccurredAt { get; set; }\n}\n```\n\nIt would offer some flexability beond the current solution. If it is worth a potential performance hit (by searching for yet another attribute) or the extended API surface, I am not sure. But throwing it out there all the same 🙂  ",
          "createdAt": "2025-01-27T14:01:01Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-01-27T14:01:01Z",
          "id": "IC_kwDODI9FZc6b6pYf"
        },
        {
          "author": "eiriktsarpalis",
          "body": "It's unlikely we'd be able to prioritize feature work like this in the near term, if I'm honest. In the meantime though, it should be possible to use [the contract customization APIs](https://learn.microsoft.com/en-us/dotnet/standard/serialization/system-text-json/custom-contracts) to implement support for a custom `JsonAlternativePropertyNameAttribute` with the desired behaviour.",
          "createdAt": "2025-01-27T16:00:11Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-01-27T21:41:08Z",
                "user": "julealgon"
              },
              {
                "content": "EYES",
                "createdAt": "2025-01-28T08:16:25Z",
                "user": "MagnusSandgren"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-02-13T08:55:16Z",
                "user": "MagnusSandgren"
              }
            ],
            "totalCount": 3,
            "endCursor": "Y3Vyc29yOnYyOpHOEGOsAw=="
          },
          "updatedAt": "2025-01-27T16:00:11Z",
          "id": "IC_kwDODI9FZc6b71o6"
        },
        {
          "author": "gregsdennis",
          "body": "Just throwing out a possible alternative API:\n\n```c#\n[JsonPropertyName(\"foo\", IsAlternate: true)]\n```\n",
          "createdAt": "2025-01-28T00:50:06Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-01-28T08:39:52Z",
                "user": "MagnusSandgren"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOEEQteQ=="
          },
          "updatedAt": "2025-01-28T00:50:06Z",
          "id": "IC_kwDODI9FZc6cAWyi"
        },
        {
          "author": "MagnusSandgren",
          "body": "Another potential use case is eliminating the need for a two-step deployment process for internal events. For example, if MyEvent is only produced and consumed by applications within the same CI/CD pipeline—where both consumers and producers are deployed around the same time—there would be no need for an intermediate version of MyEvent that contains both properties.\n\nAt first glance, this might seem like a very niche scenario. However, when adhering to the principle of \"friends don't let friends do dual writes\" and applying the outbox pattern, this use case is more practical than it might initially appear.",
          "createdAt": "2025-01-28T08:37:48Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-01-28T08:37:48Z",
          "id": "IC_kwDODI9FZc6cD7-g"
        }
      ],
      "totalCount": 6,
      "endCursor": "Y3Vyc29yOnYyOpHOnA-_oA=="
    },
    "url": "https://github.com/dotnet/runtime/issues/111862",
    "title": "[API Proposal]: Add Support for JsonAlternativePropertyNameAttribute in System.Text.Json"
  },
  {
    "author": "stephentoub",
    "labels": [
      "api-approved",
      "area-System.Text.Json",
      "help wanted",
      "code-analyzer",
      "code-fixer"
    ],
    "createdAt": "2025-01-29T14:45:53Z",
    "body": "https://github.com/dotnet/runtime/issues/108930 represents an approved API for .NET 10 that adds JsonElement.Parse methods. Before its existence, developers would write things like:\n```csharp\nJsonElement element = JsonDocument.Parse(\"json\").RootElement;\n```\nwhich ends up renting an array from the ArrayPool with the JsonDocument but then never returning it because the JsonDocument isn't disposed.\n\nWe should add an analyzer/fixer that flags common patterns folks have used for getting a JsonElement, as called out in https://github.com/dotnet/runtime/issues/108930, and recommend switching to use the new JsonElement.Parse methods.",
    "number": 111957,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-01-29T15:21:45Z",
          "user": "eiriktsarpalis"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-01-29T15:56:38Z",
          "user": "colejohnson66"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-01-29T17:17:43Z",
          "user": "gregsdennis"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-01-31T06:36:51Z",
          "user": "ArminShoeibi"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-01-31T14:50:34Z",
          "user": "PaulusParssinen"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-02-02T10:17:38Z",
          "user": "martincostello"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-02-05T10:22:41Z",
          "user": "WeihanLi"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-06-06T07:11:33Z",
          "user": "Zagrthos"
        }
      ],
      "totalCount": 8,
      "endCursor": "Y3Vyc29yOnYyOpHODDWoKw=="
    },
    "updatedAt": "2025-07-28T20:28:54Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": "dotnet-policy-service",
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. -->",
          "createdAt": "2025-01-29T14:46:17Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-01-29T14:46:17Z",
          "id": "IC_kwDODI9FZc6cRl6Y"
        },
        {
          "author": "bartonjs",
          "body": "[Video](https://www.youtube.com/watch?v=0v4cLS4stVk&t=0h12m55s)\n\nLooks good as proposed\n\nCategory: Performance\nSeverity: Info",
          "createdAt": "2025-02-04T18:20:23Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-02-04T19:48:15Z",
          "id": "IC_kwDODI9FZc6dCuE0"
        },
        {
          "author": "gregsdennis",
          "body": "> which ends up renting an array from the ArrayPool with the JsonDocument\n\nWhere will the memory live if there's not a `JsonDocument`?\n\nFor static strings like the example you've shown, the memory is basically guaranteed to exist for the lifetime of the application.\n\nHowever, if I create a string dynamically and pass that to `JsonElement.Parse()`, what happens when the string is deallocated?  Or does `JsonElement` hold a reference to the string (I don't think it does currently, which is what `JsonDocument` is for)?\n\nAre we going to also support `JsonElement.Parse(ReadOnlySpan<char>)`?",
          "createdAt": "2025-02-04T22:50:12Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-02-04T22:50:12Z",
          "id": "IC_kwDODI9FZc6dEpxG"
        },
        {
          "author": "stephentoub",
          "body": "> Where will the memory live if there's not a JsonDocument?\n\nStill in an array on the heap... but not allocated from the ArrayPool.",
          "createdAt": "2025-02-04T22:52:45Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-02-04T22:53:08Z",
          "id": "IC_kwDODI9FZc6dEqkF"
        }
      ],
      "totalCount": 4,
      "endCursor": "Y3Vyc29yOnYyOpHOnRKpBQ=="
    },
    "url": "https://github.com/dotnet/runtime/issues/111957",
    "title": "[Analyzer Proposal]: Recommend using JsonElement.Parse"
  },
  {
    "author": "Rand-Random",
    "labels": [
      "api-suggestion",
      "area-System.Text.Json"
    ],
    "createdAt": "2025-01-29T14:51:27Z",
    "body": "### Background and motivation\n\nI would like to rename the type discriminator of a type.\n\nA class in code may change of time, and currently if you simply changed the type discriminator you would break de-serializing of old json files.\n\ne.g. you have this classes\n\n```\n[JsonDerivedType(typeof(DerivedClass1), \"derivedClass1\")]\n[JsonDerivedType(typeof(Foo), \"foo\")]\npublic abstract class BaseClass\n{\n\n}\n\npublic class DerivedClass1 : BaseClass\n{\n\n}\n\npublic class Foo : BaseClass\n{\n\n}\n```\n\nand you want to rename `Foo` to `Bar`, if you don't want backward compatiblity with old json files all you have to do is this\n\n```\n[JsonDerivedType(typeof(DerivedClass1), \"derivedClass1\")]\n//renamed typeof(Foo) to typeof(Bar)\n//adjusted the type discriminator to bar\n[JsonDerivedType(typeof(Bar), \"bar\")]\npublic abstract class BaseClass\n{\n\n}\n\npublic class DerivedClass1 : BaseClass\n{\n\n}\n\n//renamed class Foo to Bar\npublic class Bar : BaseClass\n{\n\n}\n```\n\nbut this breaks any old json files as they will still have `$type: \"Foo\"` and have no knowledge that it was renamed.\n\n### API Proposal\n\nExtend the `JsonDerivedType` with a new property \n\n```\n    [AttributeUsage(AttributeTargets.Class | AttributeTargets.Interface, AllowMultiple = true, Inherited = false)]\n    public class JsonDerivedTypeAttribute : JsonAttribute\n    {\n        public JsonDerivedTypeAttribute(Type derivedType)\n        {\n            DerivedType = derivedType;\n        }\n\n        public JsonDerivedTypeAttribute(Type derivedType, string typeDiscriminator, string?[] oldTypeDiscriminator = null)\n        {\n            DerivedType = derivedType;\n            TypeDiscriminator = typeDiscriminator;\n            OldTypeDiscriminator = oldTypeDiscriminator;\n        }\n        public JsonDerivedTypeAttribute(Type derivedType, int typeDiscriminator, int?[] oldTypeDiscriminator = null)\n        {\n            DerivedType = derivedType;\n            TypeDiscriminator = typeDiscriminator;\n            OldTypeDiscriminator = oldTypeDiscriminator;\n        }\n\n        public Type DerivedType { get; }\n        public object? TypeDiscriminator { get; }\n        public object[]? OldTypeDiscriminator { get; }\n    }\n```\n\nOR\n\nChange type of `TypeDiscriminator` from `object?` to `object[]?`\nthough this would be a breaking change so maybe the first proposal is the more ideal\n\n### API Usage\n\n```\n[JsonDerivedType(typeof(DerivedClass1), \"derivedClass1\")]\n//added the array with the old name\n[JsonDerivedType(typeof(Bar), \"bar\", [\"foo\"])]\npublic abstract class BaseClass\n{\n\n}\n```\n\nOn Serializing it should use `JsonDerivedTypeAttribute`'s `TypeDiscriminator` property.\nOn De-Serializing it should check if `$type` matches either `JsonDerivedTypeAttribute`'s `TypeDiscriminator` property OR the new introduced array `OldTypeDiscriminator`.\n\n### Alternative Designs\n\n_No response_\n\n### Risks\n\n_No response_",
    "number": 111958,
    "reactions": {
      "hasNextPage": false,
      "nodes": [],
      "totalCount": 0,
      "endCursor": null
    },
    "updatedAt": "2025-03-21T14:49:07Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": "dotnet-policy-service",
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. -->",
          "createdAt": "2025-01-29T14:51:52Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-01-29T14:51:52Z",
          "id": "IC_kwDODI9FZc6cRptv"
        },
        {
          "author": "eiriktsarpalis",
          "body": "If I'm understanding this correctly, you're looking for a way to specify alternate type discriminator id's for a given derived type? It should be possible to do in principle.",
          "createdAt": "2025-01-29T19:46:56Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-01-29T19:46:56Z",
          "id": "IC_kwDODI9FZc6cUxTz"
        },
        {
          "author": "Rand-Random",
          "body": "@eiriktsarpalis \n\nyes, alternate names, though only for deserializing for serializing it should use the main name \n\nin my original post\nmain name = new name\nalternate names = old name(s)",
          "createdAt": "2025-01-29T19:59:51Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-01-29T19:59:51Z",
          "id": "IC_kwDODI9FZc6cU3jn"
        },
        {
          "author": "RonaldoBueno16",
          "body": "No, they are not the same thing. \n\nWhile both issues involve multiple discriminators, they have distinct purposes:\n\nIssue #111958 deals with backward compatibility with older versions, where there is a current primary discriminator and legacy secondary discriminators.\n\n**Issue #113744 (our focus) seeks to allow multiple active discriminators simultaneously for the same type, all with equal importance, to represent different functional variants using the same class.**\n\nThe first is about code migration, the second about design flexibility.",
          "createdAt": "2025-03-21T14:23:18Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-03-21T14:49:06Z",
          "id": "IC_kwDODI9FZc6jhtcw"
        },
        {
          "author": "eiriktsarpalis",
          "body": "What is the difference, functionally speaking?",
          "createdAt": "2025-03-21T14:28:21Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-03-21T14:49:03Z",
          "id": "IC_kwDODI9FZc6jhwp9"
        },
        {
          "author": "RonaldoBueno16",
          "body": "What I'm trying to do here is multiple discriminators for the same type of object.\n",
          "createdAt": "2025-03-21T14:31:23Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-03-21T14:49:00Z",
          "id": "IC_kwDODI9FZc6jhysm"
        },
        {
          "author": "RonaldoBueno16",
          "body": "Because I have several events of different types, which in my context, can be of the same type.\n\nIn order to avoid creating several classes with the same properties, I would like to have multiple discriminators for the same type.",
          "createdAt": "2025-03-21T14:32:15Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-03-21T14:48:57Z",
          "id": "IC_kwDODI9FZc6jhzNo"
        },
        {
          "author": "eiriktsarpalis",
          "body": "> I would like to have multiple discriminators for the same type.\n\nDo you mean emitting multiple discriminators on the wire for a given object?",
          "createdAt": "2025-03-21T14:34:38Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-03-21T14:48:54Z",
          "id": "IC_kwDODI9FZc6jh0w3"
        },
        {
          "author": "RonaldoBueno16",
          "body": "> Você quer dizer emitir vários discriminadores no fio para um determinado objeto?\n\nYes, multiple discriminators pointing to the same type\n\nBut I refer to the issue [https://github.com/dotnet/runtime/issues/113744](url)",
          "createdAt": "2025-03-21T14:36:54Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-03-21T14:48:50Z",
          "id": "IC_kwDODI9FZc6jh2KU"
        }
      ],
      "totalCount": 9,
      "endCursor": "Y3Vyc29yOnYyOpHOo4dilA=="
    },
    "url": "https://github.com/dotnet/runtime/issues/111958",
    "title": "[API Proposal]: JsonDerivedType add ability to rename type discriminator"
  },
  {
    "author": "spydacarnage",
    "labels": [
      "area-System.Text.Json",
      "code-analyzer"
    ],
    "createdAt": "2025-02-06T20:49:16Z",
    "body": "### Description\n\nCA1869 is caused by a local instance of `JsonSerializerOptions` being created and used once as the `options` argument of a Serialize or Deserialize call as this can cause performance degradation if the code is executed multiple times.\n\nI initially found this bug in a top-level program where there was only a single Deserialize call in the whole file, so I thought it was a little strange, but upon further investigation found that this bug extends to other situations.\n \n\n### Reproduction Steps\n\nThere are 3 versions, all very similar, but each with potentially different solutions.\n\nVersion 1 - Top-level program\n```cs\nJsonSerializerOptions options = new()\n{\n    PropertyNameCaseInsensitive = true,\n    ReadCommentHandling = JsonCommentHandling.Skip\n};\n\nvar output = JsonSerializer.Deserialize<int[]>(\"[1,2,3]\", options);\n```\n\n![Image](https://github.com/user-attachments/assets/d5365ae7-288e-457f-9e84-97bf868ad082)\n\nVersion 2 - In a class constructor:\n```cs\n    public Test()\n    {\n        JsonSerializerOptions options = new()\n        {\n            PropertyNameCaseInsensitive = true,\n            ReadCommentHandling = JsonCommentHandling.Skip\n        };\n\n        var output = JsonSerializer.Deserialize<int[]>(\"[1,2,3]\", options);\n    }\n```\n\nVersion 3 - In a loop inside a standard method:\n```cs\n    public void M()\n    {\n        for (int i = 0; i < 10; i++)\n        {\n            JsonSerializerOptions options = new()\n            {\n                PropertyNameCaseInsensitive = true,\n                ReadCommentHandling = JsonCommentHandling.Skip\n            };\n\n            var output = JsonSerializer.Deserialize<int[]>(\"[1,2,3]\", options);\n        }\n    }\n```\n\n### Expected behavior\n\nFor version 1, I'm honestly not sure what should happen - maybe nothing, as the fix appears to make the code worse, not better.\nFor version 2, I could see the fixer creating a static variable to hold the options for use in each construction.\nFor version 3, I would hope the fixer would, at the very least, move the instance creation outside the loop, as duplicating it inside the loop doesn't improve the performance at all.\n\n### Actual behavior\n\nAfter using the provided fixer, the following was produced:\n\nVersion 1 - Top-level program\n```cs\nJsonSerializerOptions jsonSerializerOptions = new()\n{\n    PropertyNameCaseInsensitive = true,\n    ReadCommentHandling = JsonCommentHandling.Skip\n};\nJsonSerializerOptions options = jsonSerializerOptions;\n\nvar output = JsonSerializer.Deserialize<int[]>(\"[1,2,3]\", options);\n```\n\nVersion 2 - In a class constructor:\n```cs\n    public Test()\n    {\n        JsonSerializerOptions jsonSerializerOptions = new()\n        {\n            PropertyNameCaseInsensitive = true,\n            ReadCommentHandling = JsonCommentHandling.Skip\n        };\n        JsonSerializerOptions options = jsonSerializerOptions;\n\n        var output = JsonSerializer.Deserialize<int[]>(\"[1,2,3]\", options);\n```\n\nVersion 3 - In a loop inside a standard method:\n```cs\n    public void M()\n    {\n        for (int i = 0; i < 10; i++)\n        {\n            JsonSerializerOptions jsonSerializerOptions = new()\n            {\n                PropertyNameCaseInsensitive = true,\n                ReadCommentHandling = JsonCommentHandling.Skip\n            };\n            JsonSerializerOptions options = jsonSerializerOptions;\n\n            var output = JsonSerializer.Deserialize<int[]>(\"[1,2,3]\", options);\n        }\n    }\n```\n\nVersion 3 does also have an extra option, although after the one above, which alters the method to allow a `JsonSerializerOptions` instance to be passed in as a parameter, which is much better.\n\n### Regression?\n\nThe problem seems to also be in NET8, but not in NET7.\n\n### Known Workarounds\n\nIgnore or suppress the rule.\n\n### Configuration\n\nUsing VS 17.13.0 Preview 4 in a NET9 console application, running on Windows 11 x64.\n\n### Other information\n\n_No response_",
    "number": 112247,
    "reactions": {
      "hasNextPage": false,
      "nodes": [],
      "totalCount": 0,
      "endCursor": null
    },
    "updatedAt": "2025-02-07T17:00:16Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": "dotnet-policy-service",
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. -->",
          "createdAt": "2025-02-06T20:49:42Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-02-06T20:49:42Z",
          "id": "IC_kwDODI9FZc6dajHq"
        },
        {
          "author": "eiriktsarpalis",
          "body": "> After using the provided fixer\n\nI'm pretty sure the analyzer in question doesn't come with a fixer. Can you clarify which suggestion you applied that resulted in these changes? The recommendations I'm seeing are unrelated to the analyzer per se:\n\n![Image](https://github.com/user-attachments/assets/2f89b633-4c3c-47f6-a3a6-0fc31046aac5)",
          "createdAt": "2025-02-07T12:26:08Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-02-07T12:26:08Z",
          "id": "IC_kwDODI9FZc6dhbS1"
        },
        {
          "author": "spydacarnage",
          "body": "I used the \"Introduce local for ...\" option.  I assumed that it was part of the analyser because of this:\n\n![Image](https://github.com/user-attachments/assets/1e9d5951-c545-45e7-8325-31ac5d29e7e4)",
          "createdAt": "2025-02-07T13:15:16Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-02-07T13:15:16Z",
          "id": "IC_kwDODI9FZc6dhxog"
        },
        {
          "author": "eiriktsarpalis",
          "body": "It's unrelated. We intentionally didn't include a fixer because caching instances is highly context-specific and would be hard to automate meaningfully.\n\nThat being said, the analyzer firing in top-level programs is a known false positive and we should try to detect it. Leaving the issue open to track that.",
          "createdAt": "2025-02-07T13:18:40Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-03-19T12:03:37Z",
                "user": "nalka0"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOEKhyYg=="
          },
          "updatedAt": "2025-02-07T17:00:16Z",
          "id": "IC_kwDODI9FZc6dh0lZ"
        },
        {
          "author": "spydacarnage",
          "body": "The false positives aren't just in top-level programs - it fires in methods in fully constructed classes, too.",
          "createdAt": "2025-02-07T13:35:15Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-02-07T13:35:15Z",
          "id": "IC_kwDODI9FZc6diHEr"
        },
        {
          "author": "eiriktsarpalis",
          "body": "> The false positives aren't just in top-level programs - it fires in methods in fully constructed classes, too.\n\nCan you clarify? The other examples that you cite are almost certainly inappropriate use of JsonSerializerOptions and the analyzer is correct to highlight them. In both cases they should have been lifted to statics.",
          "createdAt": "2025-02-07T13:47:25Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-02-07T13:47:25Z",
          "id": "IC_kwDODI9FZc6diOMD"
        },
        {
          "author": "spydacarnage",
          "body": "The only fixer offered is the same one as you've stated is nothing to do with this analyser.\n\nAnd, as shown in the original issue, on both occasions, it just creates useless additional locals in the same scope.  I would have expected it to be raised to a static, but that doesn't appear to be an option.",
          "createdAt": "2025-02-07T13:56:28Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-02-07T13:56:28Z",
          "id": "IC_kwDODI9FZc6diTNb"
        },
        {
          "author": "eiriktsarpalis",
          "body": "But, like I said, these suggestions are unrelated to the analyzer. Providing a fixer has never been a goal of this analyzer for the reasons stated above.",
          "createdAt": "2025-02-07T15:02:28Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-02-07T15:02:28Z",
          "id": "IC_kwDODI9FZc6di9kG"
        },
        {
          "author": "spydacarnage",
          "body": "So, if they're not related, why does the hover have the \"Show potential fixes\" shown under the analyser output?\n\nBut if CA1869 isn't triggered, there is no indication of a fixer being available, so there must be some connection between the scenarios.",
          "createdAt": "2025-02-07T15:10:31Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-02-07T15:10:31Z",
          "id": "IC_kwDODI9FZc6djCUK"
        },
        {
          "author": "eiriktsarpalis",
          "body": "@CyrusNajmabadi might know what triggers recommendations for analyzers that don't ship with fixers.",
          "createdAt": "2025-02-07T15:15:39Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-02-07T15:15:39Z",
          "id": "IC_kwDODI9FZc6djFLL"
        },
        {
          "author": "CyrusNajmabadi",
          "body": "> why does the hover have the \"Show potential fixes\" shown under the analyser output?\n\n\nIs just text saying that we'll go run everything to see if any fixes were reported. ",
          "createdAt": "2025-02-07T16:06:18Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-02-07T16:06:18Z",
          "id": "IC_kwDODI9FZc6djj5V"
        },
        {
          "author": "spydacarnage",
          "body": "Fair enough - it just feels really misleading.  At least the top-level program issue is going to be looked at...",
          "createdAt": "2025-02-07T16:22:28Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-02-07T16:59:43Z",
                "user": "eiriktsarpalis"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOEFp_FQ=="
          },
          "updatedAt": "2025-02-07T16:22:28Z",
          "id": "IC_kwDODI9FZc6djvrI"
        }
      ],
      "totalCount": 12,
      "endCursor": "Y3Vyc29yOnYyOpHOnY76yA=="
    },
    "url": "https://github.com/dotnet/runtime/issues/112247",
    "title": "CA1869: \"Cache and reuse 'JsonSerializerOptions' instances\" - false positives in top-level programs"
  },
  {
    "author": "eiriktsarpalis",
    "labels": [
      "api-suggestion",
      "area-System.Text.Json",
      "partner-impact"
    ],
    "createdAt": "2025-02-26T08:36:41Z",
    "body": "> Would exposing `JsonSerializer.Serialize` accepting `IBufferWriter<byte>` overloads help in this case?\r\n\r\n_Originally posted by @eiriktsarpalis in https://github.com/dotnet/aspnetcore/pull/60616#discussion_r1971154993_\r\n            ",
    "number": 112943,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-05-22T08:58:29Z",
          "user": "bill-poole"
        }
      ],
      "totalCount": 1,
      "endCursor": "Y3Vyc29yOnYyOpHODCrXpA=="
    },
    "updatedAt": "2025-07-16T07:33:35Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": "huoyaoyuan",
          "body": "Is it covered by #68586?",
          "createdAt": "2025-02-27T08:00:53Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-02-27T08:00:53Z",
          "id": "IC_kwDODI9FZc6gKx2r"
        },
        {
          "author": "huoyaoyuan",
          "body": "Well, the approved (implemented) was changed from `IBufferWriter<byte>` to `PipeWriter`.",
          "createdAt": "2025-02-27T08:15:10Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-02-27T08:15:10Z",
          "id": "IC_kwDODI9FZc6gK42i"
        },
        {
          "author": "eiriktsarpalis",
          "body": "PipeWriter is necessary for driving the `SerializerAsync` since it has flushing capability. `IBufferWriter<T>` does not so we would only be able to use it for the non-async methods.",
          "createdAt": "2025-02-27T12:33:35Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-02-27T12:33:35Z",
          "id": "IC_kwDODI9FZc6gNQ52"
        }
      ],
      "totalCount": 3,
      "endCursor": "Y3Vyc29yOnYyOpHOoDUOdg=="
    },
    "url": "https://github.com/dotnet/runtime/issues/112943",
    "title": "Consider adding `IBufferWriter<byte>` overloads to `JsonSerializer`"
  },
  {
    "author": "frederik-hoeft",
    "labels": [
      "area-System.Text.Json"
    ],
    "createdAt": "2025-03-02T17:15:35Z",
    "body": "### Description\n\nI recently started using the source generation features of System.Text.Json for AOT-friendly JSON deserialization. Since I need to deserialize a rather large JSON blob that uses `snake_case` for property names, I decided to simply add `[JsonSourceGenerationOptions(PropertyNamingPolicy = JsonKnownNamingPolicy.SnakeCaseLower)]` to my JsonSerializerContext (rather than having to annotate every property with its snake case name). However the following minimal reproducible example fails to deserialize:\n\n### Reproduction Steps\n\nCompile and run:\n\n```csharp\nusing System.Text.Json;\nusing System.Text.Json.Serialization;\n\nstring json =\n    \"\"\"\n    {\n        \"first_name\": \"Foo\",\n        \"last_name\": \"Bar\"\n    }\n    \"\"\";\n\nPerson person = (Person)JsonSerializer.Deserialize(json, typeof(Person), new MyJsonSerializerContext())!;\nConsole.WriteLine(person);\n\n[JsonSourceGenerationOptions(PropertyNamingPolicy = JsonKnownNamingPolicy.SnakeCaseLower)]\n[JsonSerializable(typeof(Person))]\ninternal partial class MyJsonSerializerContext : JsonSerializerContext;\n\ninternal record Person(string FirstName, string LastName);\n```\n\n### Expected behavior\n\nGiven that I specified `JsonKnownNamingPolicy.SnakeCaseLower` as the PropertyNamingPolicy I expected the following output:\n\n```plaintext\nPerson { FirstName = Foo, LastName = Bar }\n```\n\n### Actual behavior\n\nHowever, the actual output is:\n\n```plaintext\nPerson { FirstName = , LastName =  }\n```\n\nIt seems the deserializer was unable to match the snake case JSON properties to their C# counterparts.\n\n### Regression?\n\n_No response_\n\n### Known Workarounds\n\nA workaround would be to annotate the entire JSON model with appropriate `JsonPropertyName` attributes. However, as far as my interpretation of the corresponding [documentation](https://learn.microsoft.com/en-us/dotnet/api/system.text.json.serialization.jsonsourcegenerationoptionsattribute.propertynamingpolicy?view=net-9.0) goes, that would sort of miss the point of having a PropertyNamingPolicy in the JsonSourceGenerationOptions alltogether.\n\n### Configuration\n\n.NET version: 9.0.200\nOS: reproduced on `Windows 10 Pro 22H2 19045.5487 (x64)` and `Linux XEON-debian 6.1.0-31-amd64 #1 SMP PREEMPT_DYNAMIC Debian 6.1.128-1 (2025-02-07) x86_64 GNU/Linux`\n\n### Other information\n\n_No response_",
    "number": 113045,
    "reactions": {
      "hasNextPage": false,
      "nodes": [],
      "totalCount": 0,
      "endCursor": null
    },
    "updatedAt": "2025-03-04T09:45:12Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": "dotnet-policy-service",
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. -->",
          "createdAt": "2025-03-02T17:16:01Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-03-02T17:16:01Z",
          "id": "IC_kwDODI9FZc6ggTjV"
        },
        {
          "author": "huoyaoyuan",
          "body": "It works correctly if you use `MyJsonSerializerContext.Default`, instead of `new MyJsonSerializerContext()`:\n\n```csharp\nPerson person = (Person)JsonSerializer.Deserialize(json, typeof(Person), MyJsonSerializerContext.Default)!;\nPerson person = JsonSerializer.Deserialize<Person>(json, MyJsonSerializerContext.Default.Person)!;\n```\n\nInspecting the initializer of `MyJsonSerializerContext.Default`, it's initialized with `JsonSerializerOptions(s_defaultOptions)`, not parameter-less constructor. Not sure why the incorrect one is not blocked by generator.",
          "createdAt": "2025-03-02T17:22:18Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-03-03T00:59:29Z",
                "user": "chrisoverzero"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOEIMcpA=="
          },
          "updatedAt": "2025-03-02T17:22:18Z",
          "id": "IC_kwDODI9FZc6ggUHk"
        },
        {
          "author": "frederik-hoeft",
          "body": "> It works correctly if you use `MyJsonSerializerContext.Default`, instead of `new MyJsonSerializerContext()`:\n> \n> Person person = (Person)JsonSerializer.Deserialize(json, typeof(Person), MyJsonSerializerContext.Default)!;\n> Person person = JsonSerializer.Deserialize<Person>(json, MyJsonSerializerContext.Default.Person)!;\n> Inspecting the initializer of `MyJsonSerializerContext.Default`, it's initialized with `JsonSerializerOptions(s_defaultOptions)`, not parameter-less constructor. Not sure why the incorrect one is not blocked by generator.\n\nThanks for your reply! I guess it was my mistake then, although this could have been stated more clearly somewhere in the docs, or as you suggested, warned of by an analyzer. In the actual project I registered the JsonSerializerContext with DI, which encapsulated the parameterless constructor call, making it even more difficult to see where the actual issue was 😅 \n\nIf you're not supposed to call the constructor directly, wouldn't it be a good idea to mark it as obsolete? as is done with so many of the legacy Crypto-APIs, for example?",
          "createdAt": "2025-03-03T09:17:29Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-03-03T09:17:29Z",
          "id": "IC_kwDODI9FZc6gjvgN"
        },
        {
          "author": "eiriktsarpalis",
          "body": "I'm actually surprised that the default constructor doesn't create an instance that is equivalent to `Default`. I would probably just update codegen so that it does that, although it could technically be considered a breaking change. Let's leave open for now and see if this gets traction.",
          "createdAt": "2025-03-04T09:45:03Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-03-04T18:10:00Z",
                "user": "frederik-hoeft"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-03-10T19:55:22Z",
                "user": "rhuijben"
              }
            ],
            "totalCount": 2,
            "endCursor": "Y3Vyc29yOnYyOpHOEJPceA=="
          },
          "updatedAt": "2025-03-04T09:45:03Z",
          "id": "IC_kwDODI9FZc6gvr-W"
        }
      ],
      "totalCount": 4,
      "endCursor": "Y3Vyc29yOnYyOpHOoL6_lg=="
    },
    "url": "https://github.com/dotnet/runtime/issues/113045",
    "title": "JsonSerializerContext source generator ignores PropertyNamingPolicy"
  },
  {
    "author": "chuckries",
    "labels": [
      "bug",
      "area-System.Text.Json",
      "regression-from-last-release"
    ],
    "createdAt": "2025-03-07T17:58:11Z",
    "body": "### Description\n\nThe following snippet succeeds when compiled and run against net8.0, but throws an exception when compiled and run against net9.0\n\n```csharp\nusing System.Text.Json;\nusing System.Text.Json.Nodes;\n\nstring json = \"\"\"\n    { \"names\": [\"Chuck\"] }\n    \"\"\";\n\nvar dict = JsonSerializer.Deserialize<Dictionary<string, JsonValue>>(json);\n```\n\n### Reproduction Steps\n\n1. create a new net8.0 console app and add the following code:\n```csharp\nusing System.Text.Json;\nusing System.Text.Json.Nodes;\n\nstring json = \"\"\"\n    { \"names\": [\"Chuck\"] }\n    \"\"\";\n\nvar dict = JsonSerializer.Deserialize<Dictionary<string, JsonValue>>(json);\n```\n\n2. run the app\n3. change net8.0 to net9.0 \n4. run the app\n\n### Expected behavior\n\nThe serializaiton succeeds\n\n### Actual behavior\n\nin net9.0, the deserialization throws an exception:\n`System.InvalidOperationException: 'The element cannot be an object or array.'`\n\n### Regression?\n\nYes, this works in net8 but not in net9\n\n### Known Workarounds\n\nDeserializing to `Dictionary<string, JsonNode>` appears to work.\n\n### Configuration\n\n>dotnet --list-sdks\n8.0.406 [C:\\Program Files\\dotnet\\sdk]\n9.0.200 [C:\\Program Files\\dotnet\\sdk]\n9.0.300-preview.0.25127.19 [C:\\Program Files\\dotnet\\sdk]\n\n>dotnet --list-runtimes\nMicrosoft.AspNetCore.App 6.0.36 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\nMicrosoft.AspNetCore.App 8.0.13 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\nMicrosoft.AspNetCore.App 9.0.2 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\nMicrosoft.NETCore.App 6.0.36 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\nMicrosoft.NETCore.App 8.0.13 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\nMicrosoft.NETCore.App 9.0.2 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\nMicrosoft.WindowsDesktop.App 6.0.36 [C:\\Program Files\\dotnet\\shared\\Microsoft.WindowsDesktop.App]\nMicrosoft.WindowsDesktop.App 8.0.13 [C:\\Program Files\\dotnet\\shared\\Microsoft.WindowsDesktop.App]\nMicrosoft.WindowsDesktop.App 9.0.2 [C:\\Program Files\\dotnet\\shared\\Microsoft.WindowsDesktop.App]\n\n### Other information\n\n_No response_",
    "number": 113268,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "EYES",
          "createdAt": "2025-05-21T12:51:02Z",
          "user": "Copilot"
        },
        {
          "content": "EYES",
          "createdAt": "2025-09-01T03:35:10Z",
          "user": "rampaa"
        }
      ],
      "totalCount": 2,
      "endCursor": "Y3Vyc29yOnYyOpHODNnMeg=="
    },
    "updatedAt": "2025-05-21T12:50:58Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": "dotnet-policy-service",
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. -->",
          "createdAt": "2025-03-07T17:58:39Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-03-07T17:58:39Z",
          "id": "IC_kwDODI9FZc6hWpxU"
        },
        {
          "author": "bbartels",
          "body": "Looks like it was a deliberate breaking change: https://github.com/dotnet/runtime/blob/8a9d492444f06df20fcc5dfdcf7a6395af18361f/src/libraries/System.Text.Json/src/System/Text/Json/Nodes/JsonValue.cs#L189",
          "createdAt": "2025-03-07T20:30:26Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-03-07T20:30:26Z",
          "id": "IC_kwDODI9FZc6hX21d"
        },
        {
          "author": "bbartels",
          "body": "Actually, probably not deliberate. Issue introduced here here: https://github.com/dotnet/runtime/commit/d9b967646acbe6a3c19561c737a3ba954c0f26ba#diff-31898f08cdb2d11dc917abf3e66c4ac11e6ec296091977b22e22a8bb21542537R31",
          "createdAt": "2025-03-07T20:47:11Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-03-07T20:47:11Z",
          "id": "IC_kwDODI9FZc6hX-bt"
        },
        {
          "author": "eiriktsarpalis",
          "body": "FYI @jeffhandley @PranavSenthilnathan ",
          "createdAt": "2025-05-20T15:19:45Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-05-20T15:19:45Z",
          "id": "IC_kwDODI9FZc6si7JW"
        }
      ],
      "totalCount": 4,
      "endCursor": "Y3Vyc29yOnYyOpHOrIuyVg=="
    },
    "url": "https://github.com/dotnet/runtime/issues/113268",
    "title": "JsonSerializer.Deserialize failing for some types in net9.0 that worked in net8.0."
  },
  {
    "author": "jamesmcroft",
    "labels": [
      "enhancement",
      "area-System.Text.Json"
    ],
    "createdAt": "2025-03-19T15:54:22Z",
    "body": "### Description\n\nWhen using the `AIJsonUtilities.CreateJsonSchema` method with OpenAI's `ChatResponseFormat.CreateJsonSchemaFormat` (with `jsonSchemaIsStrict` set to true), complex objects that contain nested objects and lists are not handled correctly. The generated JSON schema creates internal references that are not defined at the top level, which violates the requirements for the OpenAI schema.\n\n### Reproduction Steps\n\n1. Define the following C# models with nesting and lists:\n   ```csharp\n   namespace ConsoleTests.Models;\n\n   public class SimpleObject\n   {\n       public string? Name { get; set; }\n       public List<SimpleItem>? Items { get; set; }\n   }\n\n   public class SimpleItem\n   {\n       public int Id { get; set; }\n       public float? Value { get; set; }\n       public SimpleItem SubItem { get; set; }\n   }\n   ```\n2. Call the `ChatResponseFormat.CreateJsonSchemaFormat<T>` method with the above model, ensuring `jsonSchemaIsStrict` is set to true:\n   ```csharp\n   public static ChatResponseFormat CreateJsonSchemaFormat<T>(\n           string jsonSchemaFormatName,\n           string? jsonSchemaFormatDescription = null,\n           bool? jsonSchemaIsStrict = null)\n   {\n       var formatObjectType = typeof(T);\n       var type = formatObjectType.IsGenericType && formatObjectType.GetGenericTypeDefinition() == typeof(Nullable<>) ? Nullable.GetUnderlyingType(formatObjectType)! : formatObjectType;\n\n       var jsonSchema = AIJsonUtilities.CreateJsonSchema(type, jsonSchemaFormatDescription, serializerOptions: JsonSerializerOptions.Default, inferenceOptions: new AIJsonSchemaCreateOptions()\n       {\n           IncludeSchemaKeyword = false,\n           IncludeTypeInEnumSchemas = true,\n           DisallowAdditionalProperties = true,\n           RequireAllProperties = true\n       }).ToString();\n\n       return ChatResponseFormat.CreateJsonSchemaFormat(\n           jsonSchemaFormatName,\n           jsonSchema: BinaryData.FromString(jsonSchema),\n           jsonSchemaFormatDescription: jsonSchemaFormatDescription,\n           jsonSchemaIsStrict: jsonSchemaIsStrict\n       );\n   }\n   ```\n3. Notice the generated JSON schema contains nested `$ref` pointers, e.g.:\n   ```json\n   {\n     \"type\": \"object\",\n     \"properties\": {\n       \"Name\": { \"type\": [\"string\", \"null\"] },\n       \"Items\": {\n         \"type\": [\"array\", \"null\"],\n         \"items\": {\n           \"type\": \"object\",\n           \"properties\": {\n             \"Id\": { \"type\": \"integer\" },\n             \"Value\": { \"type\": [\"number\", \"null\"] },\n             \"SubItem\": {\n               \"type\": \"object\",\n               \"properties\": {\n                 \"Id\": { \"type\": \"integer\" },\n                 \"Value\": { \"type\": [\"number\", \"null\"] },\n                 \"SubItem\": {\n                   \"$ref\": \"#/properties/Items/items/properties/SubItem\"\n                 }\n               },\n               \"additionalProperties\": false,\n               \"required\": [\"Id\", \"Value\", \"SubItem\"]\n             }\n           },\n           \"additionalProperties\": false,\n           \"required\": [\"Id\", \"Value\", \"SubItem\"]\n         }\n       }\n     },\n     \"additionalProperties\": false,\n     \"required\": [\"Name\", \"Items\"]\n   }\n   ```\n4. Use the generated schema with the OpenAI SDK's ChatCompletionOptions. The following error is thrown:\n   ```\n   System.ClientModel.ClientResultException: 'HTTP 400 (invalid_request_error: )\n   Parameter: response_format\n\n   Invalid schema for response_format 'simpleObject': In context=('properties', 'Items', 'type', '0', 'items', 'properties', 'SubItem', 'properties', 'SubItem'), reference can only point to definitions defined at the top level of the schema.'\n   ```\n\n### Expected behavior\n\nThe output JSON schema should define complex objects, such as `SimpleItem`, at the top level (using a `$defs` section) so that all `$ref` pointers are valid. For instance, the schema should be structured similar to:\n```json\n{\n    \"type\": \"object\",\n    \"$defs\": {\n        \"SimpleItem\": {\n            \"type\": \"object\",\n            \"properties\": {\n                \"Id\": { \"type\": \"integer\" },\n                \"Value\": {\n                    \"anyOf\": [\n                        { \"type\": \"number\" },\n                        { \"type\": \"null\" }\n                    ]\n                },\n                \"SubItem\": {\n                    \"$ref\": \"#/$defs/SimpleItem\"\n                }\n            },\n            \"additionalProperties\": false,\n            \"required\": [\"Id\", \"Value\", \"SubItem\"]\n        }\n    },\n    \"properties\": {\n        \"Name\": {\n            \"anyOf\": [\n                { \"type\": \"string\" },\n                { \"type\": \"null\" }\n            ]\n        },\n        \"Items\": {\n            \"anyOf\": [\n                {\n                    \"items\": { \"$ref\": \"#/$defs/SimpleItem\" },\n                    \"type\": \"array\"\n                },\n                { \"type\": \"null\" }\n            ]\n        }\n    },\n    \"additionalProperties\": false,\n    \"required\": [\"Name\", \"Items\"]\n}\n```\nThis format correctly places the definitions at the top level and adheres to the restrictions of the OpenAI SDK.\n\n\n### Actual behavior\n\nThe generated schema places nested `$ref` references within the property hierarchy rather than in a top-level definitions section. This leads to an invalid schema error when used with the ChatCompletionOptions in the OpenAI SDK, which only allows `$ref` pointers that reference definitions at the top level of the schema.\n\n### Regression?\n\nI don't believe this has ever worked.\n\n### Known Workarounds\n\nThe workaround for this is challenging to implement, requiring developers to override the `TransformSchemaNode` to resolve the invalid JSON schema.\n\n### Configuration\n\n.NET SDK:\n Version:           9.0.200\n Commit:            90e8b202f2\n Workload version:  9.0.200-manifests.a3a1a094\n MSBuild version:   17.13.8+cbc39bea8\n\nRuntime Environment:\n OS Name:     Windows\n OS Version:  10.0.26100\n OS Platform: Windows\n RID:         win-x64\n Base Path:   C:\\Program Files\\dotnet\\sdk\\9.0.200\\\n\nI don't believe this is OS or .NET version specific. \n\n### Other information\n\n_No response_",
    "number": 113698,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-06-02T15:17:37Z",
          "user": "justintoth"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-07-05T21:11:31Z",
          "user": "StephenHodgson"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-09-16T10:32:17Z",
          "user": "tombiddulph"
        }
      ],
      "totalCount": 3,
      "endCursor": "Y3Vyc29yOnYyOpHODQ457A=="
    },
    "updatedAt": "2025-07-05T21:17:39Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": "stephentoub",
          "body": "cc: @eiriktsarpalis ",
          "createdAt": "2025-03-19T16:03:12Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-03-19T16:03:12Z",
          "id": "IC_kwDODI9FZc6jKGv_"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Using `$defs` sections is something that got cut from the underlying schema exporter in System.Text.Json back when it was being developed. Addressing this would require a change in STJ itself and not MEAI.\n\nI should point out though that JSON schema spec does technically support nested references, even if it's not considered good style.",
          "createdAt": "2025-03-19T16:14:03Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-03-19T16:24:52Z",
                "user": "jamesmcroft"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOEKkg2Q=="
          },
          "updatedAt": "2025-03-19T16:14:03Z",
          "id": "IC_kwDODI9FZc6jKGwF"
        },
        {
          "author": "jamesmcroft",
          "body": "@eiriktsarpalis thanks for the heads up. I had assumed that the issue may stem from STJ. I have been trying to wrap my head around this for a few hours going between STJ and the extensions to try and resolve it, without much success.\n\nIt is possible to get around this by not enabling strict mode in OpenAI's SDK, but this defeats the objective of ensuring that the models adhere to the defined schema.",
          "createdAt": "2025-03-19T16:30:53Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-03-19T16:30:53Z",
          "id": "IC_kwDODI9FZc6jKGwP"
        },
        {
          "author": "dotnet-policy-service",
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. -->",
          "createdAt": "2025-03-19T16:40:17Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-03-19T16:40:17Z",
          "id": "IC_kwDODI9FZc6jKHGt"
        },
        {
          "author": "RufusJWB",
          "body": "> ### Known Workarounds\n> The workaround for this is challenging to implement, requiring developers to override the `TransformSchemaNode` to resolve the invalid JSON schema.\n\nWould you have an example of how to do this?",
          "createdAt": "2025-05-09T10:49:01Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-05-09T10:49:01Z",
          "id": "IC_kwDODI9FZc6q1RF1"
        },
        {
          "author": "gregsdennis",
          "body": "Use JsonSchema.Net.Generation. It will refactor all definitions to a `$defs` keyword by default. You also have a lot more control over the schema it generates. [Docs](https://docs.json-everything.net/schema/schemagen/schema-generation/)",
          "createdAt": "2025-05-09T18:52:53Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-06-02T17:39:32Z",
                "user": "justintoth"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOEU8Fug=="
          },
          "updatedAt": "2025-05-09T18:52:53Z",
          "id": "IC_kwDODI9FZc6q7E4B"
        },
        {
          "author": "jamesmcroft",
          "body": "> > ### Known Workarounds\n> > The workaround for this is challenging to implement, requiring developers to override the `TransformSchemaNode` to resolve the invalid JSON schema.\n> \n> Would you have an example of how to do this?\n\nNot a complete example, as manipulating the `TransformSchemaNode` to achieve this is not straightforward.\n\nIn the end, I built a custom workaround to generate valid OpenAI schemas for structure outputs - https://github.com/jamesmcroft/openai-structured-outputs-with-dotnet/blob/main/src/StructuredOutputs/OpenAIJsonSchema.cs",
          "createdAt": "2025-05-30T05:13:50Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-05-30T05:14:55Z",
          "id": "IC_kwDODI9FZc6uHsmn"
        },
        {
          "author": "justintoth",
          "body": "@gregsdennis Can you expand on how you used JsonSchema.Net.Generation to generate the JSON structured output for a passed in C# type? Here is what I have so far, but it's unclear how to retrieve the JSON structured output string from the jsonSchema object.\n\n```\nvar schemaBuilder = new JsonSchemaBuilder();\nvar schema = schemaBuilder.FromType(args.OutputSchemaType).Build();\nvar jsonSchemaText = schema....?\ncompletionOptions.ResponseFormat = ChatResponseFormat.CreateJsonSchemaFormat(\n\t\t\t\tjsonSchemaFormatName: args.OutputSchemaName,\n\t\t\t\tjsonSchema: BinaryData.FromBytes(Encoding.UTF8.GetBytes(jsonSchema)),\n\t\t\t\tjsonSchemaIsStrict: true);\n```",
          "createdAt": "2025-06-02T15:40:34Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-06-02T15:40:34Z",
          "id": "IC_kwDODI9FZc6uuCu-"
        },
        {
          "author": "justintoth",
          "body": "I got it all sorted, I just had to serialize the schema object to JSON.",
          "createdAt": "2025-06-02T17:39:21Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-06-02T17:39:21Z",
          "id": "IC_kwDODI9FZc6uvsIx"
        },
        {
          "author": "StephenHodgson",
          "body": "I ended up doing having to roll my own [schema generator impl](https://github.com/RageAgainstThePixel/OpenAI-DotNet/blob/d752670b3f2050306f8058709da88c24cc129754/OpenAI-DotNet/Extensions/TypeExtensions.cs#L16) as well due to this limitation as well.\nOne of the few edge cases preventing me from moving my library up to net 9.",
          "createdAt": "2025-07-05T21:16:59Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-07-05T21:17:39Z",
          "id": "IC_kwDODI9FZc61NqC4"
        }
      ],
      "totalCount": 10,
      "endCursor": "Y3Vyc29yOnYyOpHOtTaguA=="
    },
    "url": "https://github.com/dotnet/runtime/issues/113698",
    "title": "AIJsonUtilities.CreateJsonSchema does not support complex objects with nested references"
  },
  {
    "author": "mkArtakMSFT",
    "labels": [
      "bug",
      "area-System.Text.Json"
    ],
    "createdAt": "2025-03-26T16:23:33Z",
    "body": "### Description\n\nI'm working on converting the Microsoft.AspNetCore.JsonPatch to System.Text.Json.\nAs I was doing this, I came across an issue, where deserializing a string value from within a JsonObject instance throws an error:\n\n```\nSystem.InvalidCastException: 'Unable to cast object of type 'System.Text.Json.Nodes.JsonValueOfElement' to type 'System.Text.Json.Nodes.JsonValuePrimitive`1[System.String]'.'\n\nThis exception was originally thrown at this call stack:\n    System.Text.Json.ThrowHelper.ThrowInvalidCastException_DeserializeUnableToAssignValue(System.Type, System.Type)\n    System.Text.Json.JsonSerializer.UnboxOnRead.__ThrowUnableToCastValue|50_0<T>(object)\n    System.Text.Json.JsonSerializer.UnboxOnRead<T>(object)\n    System.Text.Json.Serialization.JsonConverter<T>.TryRead(ref System.Text.Json.Utf8JsonReader, System.Type, System.Text.Json.JsonSerializerOptions, ref System.Text.Json.ReadStack, out T, out bool)\n    System.Text.Json.Serialization.JsonConverter<T>.ReadCore(ref System.Text.Json.Utf8JsonReader, out T, System.Text.Json.JsonSerializerOptions, ref System.Text.Json.ReadStack)\nv\n```\n\nI discussed this with @eiriktsarpalis and he confirmed that this is not an expected behavior and suggested me to file this issue.\n\nPlease note, that the first thought that came up was to not use `node.GetType()` and specify the type explicitly using a generic Deserialize method instead. However, that isn't an option in my scenario as I dynamically get to the property that needs to be acted on, and there is no static type information available at that point.\n\n### Reproduction Steps\n\n```csharp\n[Fact]\npublic void Test()\n{\n    var model = new JsonObject([new(\"Email\", \"foo@bar.com\")]);\n\n    _ = model.TryGetPropertyValue(\"Email\", out var node);\n\n    var serialized = JsonSerializer.Serialize(node);\n    var deserialized = JsonSerializer.Deserialize(serialized, node.GetType());\n}\n```\n\n### Expected behavior\n\nThe deserialization should succeed (most probably by using JsonNode type instead? - not sure about this though).\n\n### Actual behavior\n\nAn exception shared above is thrown.\n\n### Regression?\n\n_No response_\n\n### Known Workarounds\n\nIf I try to use the Deserialize<JsonNode>() overload, things work, but that's not the scenario I can utilize.\n\n### Configuration\n\n.NET current (aspnetcore main branch).\nOS: Windows x64\nI don't think this is related to the environment by any means.\n\n### Other information\n\n_No response_",
    "number": 113926,
    "reactions": {
      "hasNextPage": false,
      "nodes": [],
      "totalCount": 0,
      "endCursor": null
    },
    "updatedAt": "2025-03-26T19:01:24Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": "dotnet-policy-service",
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. -->",
          "createdAt": "2025-03-26T16:23:59Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-03-26T16:23:59Z",
          "id": "IC_kwDODI9FZc6kNh_j"
        },
        {
          "author": "eiriktsarpalis",
          "body": "> Please note, that the first thought that came up was to not use node.GetType() and specify the type explicitly using a generic Deserialize method instead. However, that isn't an option in my scenario as I dynamically get to the property that needs to be acted on, and there is no static type information available at that point.\n\nNote that using the generic deserialization method isn't strictly speaking necessary. My recommendation was to avoid using `object.GetType()` as the source for the contract since this could end up exposing private implementation details. If you're retrieving a value from a property you can just use the type from `PropertyInfo.PropertyInfo` instead.",
          "createdAt": "2025-03-26T19:01:08Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-03-26T19:01:08Z",
          "id": "IC_kwDODI9FZc6kPTe8"
        }
      ],
      "totalCount": 2,
      "endCursor": "Y3Vyc29yOnYyOpHOpD03vA=="
    },
    "url": "https://github.com/dotnet/runtime/issues/113926",
    "title": "Deserialization of a JsonNode with string value fails"
  },
  {
    "author": "elringus",
    "labels": [
      "area-System.Text.Json",
      "needs-further-triage"
    ],
    "createdAt": "2025-03-26T21:10:24Z",
    "body": "### Description\n\nSetting `GenerationMode = JsonSourceGenerationMode.Serialization` results in `error: NoMetadataForTypeProperties, SourceGenerationContext` exception in browser-wasm taget.\n\n```\nat System.Text.Json.Serialization.Converters.ObjectDefaultConverter`1[[Data, DotNet, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null]].OnTryRead(Utf8JsonReader& , Type , JsonSerializerOptions , ReadStack& , Data& )\\n' +\n    '   at System.Text.Json.Serialization.JsonConverter`1[[Data, DotNet, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null]].ReadCore(Utf8JsonReader& , Data& , JsonSerializerOptions , ReadStack& )\\n' +\n    '   at System.Text.Json.JsonSerializer.ReadFromSpan[Data](ReadOnlySpan`1 , JsonTypeInfo`1 )\\n' +\n    '   at Program.__Wrapper_Mutate_1171346831(JSMarshalerArgument* __arguments_buffer)\\n' +\n    'Error: NoMetadataForTypeProperties, SourceGenerationContext, Data\\n' +\n```\n\n### Reproduction Steps\n\n## .csproj\n\n```xml\n<Project Sdk=\"Microsoft.NET.Sdk\">\n    <PropertyGroup>\n        <TargetFramework>net9.0</TargetFramework>\n        <Configuration>Release</Configuration>\n        <AllowUnsafeBlocks>true</AllowUnsafeBlocks>\n        <RuntimeIdentifier>browser-wasm</RuntimeIdentifier>\n        <WasmEnableLegacyJsInterop>false</WasmEnableLegacyJsInterop>\n        <Nullable>enable</Nullable>\n        <RunAOTCompilation>true</RunAOTCompilation>\n        <OptimizationPreference>Speed</OptimizationPreference>\n\n        <PublishTrimmed>true</PublishTrimmed>\n        <TrimMode>full</TrimMode>\n        <InvariantTimezone>true</InvariantTimezone>\n        <InvariantGlobalization>true</InvariantGlobalization>\n        <PredefinedCulturesOnly>true</PredefinedCulturesOnly>\n    </PropertyGroup>\n\n    <ItemGroup>\n        <AssemblyAttribute Include=\"System.Runtime.Versioning.SupportedOSPlatform\">\n            <_Parameter1>browser</_Parameter1>\n        </AssemblyAttribute>\n    </ItemGroup>\n</Project>\n```\n\n## Program.cs\n\n```cs\nusing System.Runtime.InteropServices.JavaScript;\nusing System.Text.Json;\nusing System.Text.Json.Serialization;\n\npublic struct Data\n{\n    public string Info;\n    public bool Ok;\n    public int Revision;\n    public string[] Messages;\n}\n\n[JsonSerializable(typeof(Data))]\n[JsonSourceGenerationOptions(GenerationMode = JsonSourceGenerationMode.Serialization)]\ninternal partial class SourceGenerationContext : JsonSerializerContext;\n\npublic static partial class Program\n{\n    public static void Main () { }\n\n    [JSExport]\n    public static string Mutate (string json)\n    {\n        var data = JsonSerializer.Deserialize<Data>(json,\n            SourceGenerationContext.Default.Data);\n\n        data.Info = \"000\";\n        data.Ok = !data.Ok;\n        data.Revision += 1;\n\n        return JsonSerializer.Serialize(data,\n            SourceGenerationContext.Default.Data);\n    }\n}\n```\n\n## main.mjs\n\n```js\nimport { dotnet } from \"./bin/Release/net9.0/browser-wasm/AppBundle/_framework/dotnet.js\";\n\nconst { setModuleImports, getAssemblyExports, getConfig } = await dotnet\n  .withDiagnosticTracing(false)\n  .create();\nconst exports = await getAssemblyExports(getConfig().mainAssemblyName);\n\nlet data = {\n    Info: \"info\",\n    Ok: true,\n    Revision: 1,\n    Messages: [\"1\", \"2\", \"3\", \"4\"]\n};\n\nconst startTime = performance.now();\n\nfor (let i = 0; i < 100000; i++)\n    data = JSON.parse(exports.Program.Mutate(JSON.stringify(data)));\n\nconst endTime = performance.now();\nconst totalTime = endTime - startTime;\n\nconsole.log(`Result: ${totalTime.toFixed(2)} ms`);\n```\n\n## run\n\n```sh\ndotnet publish\nnode main.mjs\n```\n\n### Expected behavior\n\nNo errors.\n\n### Actual behavior\n\nError is thrown.\n\n### Regression?\n\n_No response_\n\n### Known Workarounds\n\n_No response_\n\n### Configuration\n\n```\n.NET SDK:\n Version:           9.0.104\n Commit:            2750432faa\n Workload version:  9.0.100-manifests.163bd6d0\n MSBuild version:   17.12.27+e0b90a9a8\n\nRuntime Environment:\n OS Name:     Windows\n OS Version:  10.0.19045\n OS Platform: Windows\n RID:         win-x64\n\n.NET workloads installed:\n [wasm-tools]\n   Installation Source: SDK 9.0.100\n   Manifest Version:    9.0.3/9.0.100\n\nHost:\n  Version:      9.0.3\n  Architecture: x64\n  Commit:       831d23e561\n```\n\nNode v22.12.0\n\n### Other information\n\n_No response_",
    "number": 113946,
    "reactions": {
      "hasNextPage": false,
      "nodes": [],
      "totalCount": 0,
      "endCursor": null
    },
    "updatedAt": "2025-07-26T02:15:53Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": "dotnet-policy-service",
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. -->",
          "createdAt": "2025-03-26T21:10:52Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-03-26T21:10:52Z",
          "id": "IC_kwDODI9FZc6kQX_s"
        }
      ],
      "totalCount": 1,
      "endCursor": "Y3Vyc29yOnYyOpHOpEF_7A=="
    },
    "url": "https://github.com/dotnet/runtime/issues/113946",
    "title": "[Text.Json] Error: NoMetadataForTypeProperties, SourceGenerationContext"
  },
  {
    "author": "warappa",
    "labels": [
      "enhancement",
      "area-System.Text.Json"
    ],
    "createdAt": "2025-03-27T14:03:16Z",
    "body": "### Description\n\nAssigning a `JsonNode` to the **_same_ parent _again_** throws an exception stating that the node already has a parent. If it would be re-parented then this would be expected. But if the new parent is old parent, then this should not fail but treat it as a no-op.\n\nIn local code this is no problem, because then you just refactor the assignment. But if you do a library and let the developer return a transformed **_or_** - as in our case - the original `JsonNode`, then this is problematic, because now you have to check for reference equality and avoid the assignment.\n\n### Investigation\nThis is the involved code:\nhttps://github.com/dotnet/runtime/blob/be6d8d01a848a1de0674e51c6d243b65404f2e0f/src/libraries/System.Text.Json/src/System/Text/Json/Nodes/JsonArray.cs#L234-L239\ncalling `AssignParent` which throws an exception if parent has any value (even if it is the same):\nhttps://github.com/dotnet/runtime/blob/be6d8d01a848a1de0674e51c6d243b65404f2e0f/src/libraries/System.Text.Json/src/System/Text/Json/Nodes/JsonNode.cs#L346-L349\n\nFor properties of `JsonObject` this seems to be no problem as the following code does not throw:\n```csharp\nvar obj = new JsonObject();\nvar node = JsonValue.Create(1);\nobj[\"child\"] = node;\nobj[\"child\"] = node; // no exception 👍\n```\nThose two behaviors are different but the `JsonObject` property no-op assignment behavior makes sense.\n\n### Reproduction Steps\n\n```csharp\nvar array = new JsonArray();\nvar node= JsonValue.Create(1); // or new JsonObject();\narray.Add(node);\narray[0] = node; // throws \"System.InvalidOperationException: 'The node already has a parent.'\"\n```\n\n### Expected behavior\n\nNo exception should be thrown - effectivly a no-op.\n\n### Actual behavior\n\nThrows exception\n```\nSystem.InvalidOperationException: 'The node already has a parent.'\n```\n\n\n### Regression?\n\nUnknown\n\n### Known Workarounds\n\nThis is a undesirable workaround. Instead of just writing\n```csharp\nvar array = new JsonArray();\nvar node = new JsonObject();\narray.Add(node);\n...\n// somewhere later on\narray[0] = SomeCodeReturningANewOrSameJsonNode(node);\n```\none needs to carefully write\n```csharp\nvar array = new JsonArray();\nvar node = new JsonObject();\narray.Add(node);\n...\n// somewhere later on\nvar temp = SomeCodeReturningANewOrSameJsonNode(array[0]);\nif (!ReferenceEquals(array[0], temp))\n{\n    array[0] = temp;\n}\n```\n\n\n### Configuration\n\n.NET 9\nWindows 11\n\n### Other information\n\n_No response_",
    "number": 113966,
    "reactions": {
      "hasNextPage": false,
      "nodes": [],
      "totalCount": 0,
      "endCursor": null
    },
    "updatedAt": "2025-03-27T14:26:55Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": "dotnet-policy-service",
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. -->",
          "createdAt": "2025-03-27T14:03:54Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-03-27T14:03:54Z",
          "id": "IC_kwDODI9FZc6kZm0z"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Seems we could look at making this idempotent at some point.",
          "createdAt": "2025-03-27T14:26:41Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "HEART",
                "createdAt": "2025-03-27T14:59:12Z",
                "user": "warappa"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOELvwgg=="
          },
          "updatedAt": "2025-03-27T14:26:41Z",
          "id": "IC_kwDODI9FZc6kZ64Q"
        }
      ],
      "totalCount": 2,
      "endCursor": "Y3Vyc29yOnYyOpHOpGeuEA=="
    },
    "url": "https://github.com/dotnet/runtime/issues/113966",
    "title": "[S.T.J] Setting same JsonNode in an JsonArray on same position again throws exception"
  },
  {
    "author": "John0King",
    "labels": [
      "area-System.Text.Json"
    ],
    "createdAt": "2025-03-31T01:34:06Z",
    "body": "## background\n\ncurrently the real big problem for people to switch from Newtonsoft.json to System.Text.json  is that the S.T.J to too strict on deserialzing.\n\nthe bigest problem for me is the `string <===> number` ,  currently there is a `JsonNumberHandling.AllowReadingFromString`  option for `string ==> json`,   but not  reverse,   and `WriteAsString` is for serializing.\n\n### why you read a json number to a string property?\nthe user case for this is primary for 3rd  party  interface or compatibility.\n1.  the remote 3rd party has a week languge, and  use  `string|number` for a json property\n2.  or a system begin as `number` type , and then add `string` type , and for compatibility,   the  model for receive the json change from `int` => 'string'\n\nusing newtonsoft.json this is very simple , because newtonsoft.json allow string to accept any type in json,   but for System.Text.Json, this must change type from `int` => `JsonNode`  and involve  json framework type\n\n## suggestion\n\n`JsonNumberHandling.AllowReadingFromString`  should also allow  read number to string",
    "number": 114054,
    "reactions": {
      "hasNextPage": false,
      "nodes": [],
      "totalCount": 0,
      "endCursor": null
    },
    "updatedAt": "2025-07-23T08:58:49Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": "gregsdennis",
          "body": "Taking the opportunity to repost this: https://blog.json-everything.net/posts/numbers-are-numbers-not-strings/\n\nAlso, this is definitely a duplicate request, but I don't have the specific issue(s).",
          "createdAt": "2025-03-31T07:27:05Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-03-31T07:27:05Z",
          "id": "IC_kwDODI9FZc6k0_B6"
        },
        {
          "author": "John0King",
          "body": "@gregsdennis  \n> Also, this is definitely a duplicate request, but I don't have the specific issue(s).\n\nall issues related to this was been closed.\n\nand this issue is not about convert `\"11\"`  => `11`  , this case should use `JsonNumberHandling.AllowReadingFromString`\n\nthis issue is about  typescript type  `string|number`  to  C#  string type \n\neg. \n\n```json\n\n[\n   { \"a\":1 },\n   { \"a\":2},\n   { \"a\":\"ABC\"}\n]\n\n```",
          "createdAt": "2025-03-31T08:22:26Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-03-31T08:22:26Z",
          "id": "IC_kwDODI9FZc6k1eCI"
        },
        {
          "author": "gregsdennis",
          "body": "Yes I see the difference now.",
          "createdAt": "2025-03-31T08:47:49Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-03-31T08:47:49Z",
          "id": "IC_kwDODI9FZc6k1xf3"
        },
        {
          "author": "dannyd89",
          "body": "You could write a `JsonConverter` for that and add it to the properties where this behavior should be supported?",
          "createdAt": "2025-03-31T15:19:07Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-03-31T15:19:07Z",
          "id": "IC_kwDODI9FZc6k5oJ6"
        },
        {
          "author": "John0King",
          "body": "> You could write a JsonConverter for that and add it to the properties where this behavior should be supported?\n\nyes,  but I still think this case should has build in support in S.T.J",
          "createdAt": "2025-04-02T03:29:33Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-04-02T03:29:33Z",
          "id": "IC_kwDODI9FZc6lLfOz"
        }
      ],
      "totalCount": 5,
      "endCursor": "Y3Vyc29yOnYyOpHOpS3zsw=="
    },
    "url": "https://github.com/dotnet/runtime/issues/114054",
    "title": "System.Text.Json should support has buildin support read json number to string property"
  },
  {
    "author": "eiriktsarpalis",
    "labels": [
      "enhancement",
      "area-System.Text.Json"
    ],
    "createdAt": "2025-04-01T14:32:11Z",
    "body": "Consider the following console application:\n```C#\nConsole.WriteLine(JsonSerializer.Serialize(new MyPoco()));\n\npublic class MyPoco\n{\n    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]\n    public JsonElement Foo { get; set; } = JsonDocument.Parse(\"null\").RootElement;\n}\n```\nEven though `JsonElement` is capable of representing null instances, the serializer will reject this configuration with the message\n\n```\nSystem.InvalidOperationException: 'The ignore condition 'JsonIgnoreCondition.WhenWritingNull' is not valid on value-type member 'Foo' on type 'MyPoco'. Consider using 'JsonIgnoreCondition.WhenWritingDefault'.'\n```\n\nEven though `WhenWritingDefault` works, `default(JsonElement)` is an invalid value that is unfortunately different than the `JsonElement` `null` representation. This means that there currently is no mechanism for naturally serializing optional `JsonElement` properties and you're forced to use `JsonElement?` instead.",
    "number": 114102,
    "reactions": {
      "hasNextPage": false,
      "nodes": [],
      "totalCount": 0,
      "endCursor": null
    },
    "updatedAt": "2025-04-01T14:33:13Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [],
      "totalCount": 0,
      "endCursor": null
    },
    "url": "https://github.com/dotnet/runtime/issues/114102",
    "title": "`JsonElement` properties do not support `JsonIgnoreCondition.WhenWritingNull`"
  },
  {
    "author": "Swimburger",
    "labels": [
      "area-System.Text.Json",
      "discussion"
    ],
    "createdAt": "2025-04-01T15:35:38Z",
    "body": "We're experimenting with how we can provide the most intuitive, developer friendly experience for reading and writing additional properties for OpenAPI and are struggling to use `[JsonExtensionData]`.\n\nThe ideal experience for end users would be \n* As intuitive as creating an anonymous object or `Dictionary<string, object?>`\n* Symmetrical, in both the signature of the property, but ideally also the concrete types\n* The output is consistent whether the JSON number is short or big.\n\nAs it is today, there are three signatures to use with `[JsonExtensionData]`:\n* `IDictionary<string, JsonElement>`:\n  * **Positive**: This is great for reading properties and forcing the end user to very explicitly and verbosely pick the data type. For example, from a JSON number, you can't really predict whether a property will consistently return an int, double, decimal, float, etc, and the `JsonElement` forces the user to explicitly make that decision, fe `JsonElement.GetUInt16()`. \n  * **Negative**: To set the value you have to create a JsonElement which isn't intuitively created and I assume has poor performance characteristics, fe: `recordForReading.AdditionalProperties[\"author\"] = JsonDocument.Parse(\"\\\"J.R.R. Tolkien\\\"\").RootElement`\n* `IDictionary<string, object?>`:\n  * **Positive**: This is as intuitive as it can possibly be in .NET to write additional properties without needing to create JsonNode's or JsonElement's. Just put in data into the value and the JSON serializer takes care of properly writing it.\n  * **Negative**: \n    * When you're creating the additional properties, and immediately read them, the values have the original types you gave them, but when it is serialized and deserialized, the values are `JsonElement`'s. Maybe this isn't actually a problem, but I'm worried this will surprise our users.\n    * When deserializing JSON, the user sees `object` but the concrete type is always `JsonElement` which seems unintuive/deceiving. I would personally naively check for `is string` or `is int` etc.\n* `JsonObject`:\n  * **Positive**: \n    * It's almost as intiutive as `Dictionary<string, object?>` because simple values are implicitly cast to `JsonNode`'s, fe: `recordSymmetrical.AdditionalProperties[\"author\"] = \"J.R.R. Tolkien\"`.\n    * The property is consistent and predictable a `JsonObject`.\n  * **Negative**: \n    * Some types can't be implicitly casted, fe: \n      ```csharp\n      string[] tags = [\"fantasy\", \"adventure\"];\n      recordSymmetrical.AdditionalProperties[\"tags\"] = JsonValue.Create(tags);\n      ```\n    * `JsonObject` with `ExtensionData` cannot be used to write values currently, because of [an open bug](https://github.com/dotnet/runtime/issues/97225).\n\nIMO, the best experience for reading is `IDictionary<string, JsonElement>` and `JsonObject`, while the best writing experience is `IDictionary<string, object?>`, and the best of both worlds is `JsonObject` if the [bug were to be resolved](https://github.com/dotnet/runtime/issues/97225).\n\n`additionalProperties` in OpenAPI, the equivalent of `ExtensionData` is becoming more common needed with us gaining traction in the AI and embedding space (we work with [Pinecone on their .NET SDK](https://github.com/pinecone-io/pinecone-dotnet-client)).\n\n---\n\nFYI, [I wrote a little sample that plays with these different signatures here](https://github.com/Swimburger/AdditionalProperties/blob/main/AdditionalProperties/Program.cs), and they have indexers to make it more intuitive.\n\nFor context, we generate code based on multiple spec formats (OpenAPI/AsyncAPI/proto) and merge them into intuitive SDKs, and I am personally invested in giving .NET devs the best SDKs possible balancing developer experience and performance. How would you recommend providing intuitive classes with extension data that can be used for both writing and reading?",
    "number": 114106,
    "reactions": {
      "hasNextPage": false,
      "nodes": [],
      "totalCount": 0,
      "endCursor": null
    },
    "updatedAt": "2025-07-23T09:01:44Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": "dotnet-policy-service",
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. -->",
          "createdAt": "2025-04-01T15:36:13Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-04-01T15:36:13Z",
          "id": "IC_kwDODI9FZc6lF47B"
        },
        {
          "author": "jeremyfiel",
          "body": "Something to consider is the specification you are generating for may have different requirements for the underlying JSON Schema draft version and the behavior of the keyword used. \n\n- OAS 3.0.x uses a subset/superset of JSON Schema Draft-04 and `additionalProperties`\n- Async 2/3 use JSON Schema Draft-07 and `additionalProperties`\n- OAS 3.1.x uses JSON Schema Draft 2020-12 and `unevaluatedProperties` which has slightly different behavior than `additionalProperties`.\n\nI suppose the use of the different keyword for creating types has a different expectation than data validation where the behavior difference may be more pronounced, but it's something to be aware of. ",
          "createdAt": "2025-04-01T18:46:15Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "EYES",
                "createdAt": "2025-04-01T19:28:07Z",
                "user": "Swimburger"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOEMcaIg=="
          },
          "updatedAt": "2025-04-01T18:46:15Z",
          "id": "IC_kwDODI9FZc6lILlJ"
        },
        {
          "author": "Swimburger",
          "body": "> * OAS 3.1.x uses JSON Schema Draft 2020-12 and `unevaluatedProperties` which has slightly different behavior than `additionalProperties`.\n\nWe're not concerned with validation at the moment, but that is good to know, thank you for bringing it up.",
          "createdAt": "2025-04-01T19:30:44Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-04-01T19:30:44Z",
          "id": "IC_kwDODI9FZc6lIkPH"
        },
        {
          "author": "Swimburger",
          "body": "I can provide my own class and provide some helper methods which could make this more intuitive.\n\n```csharp\npublic record AdditionalProperties : AdditionalProperties<object?>;\n\npublic record AdditionalProperties<T> : IDictionary<string, T>\n{\n    private readonly Dictionary<string, T> _dictionary = new();\n\n    public IDictionary<string, JsonElement> ToJsonElementDictionary(){...}\n}\n```\n\nI kinda like this better, but still feel unsure if this is the best DX users should be getting.",
          "createdAt": "2025-04-01T22:18:58Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-04-01T22:18:58Z",
          "id": "IC_kwDODI9FZc6lJ0AJ"
        },
        {
          "author": "eiriktsarpalis",
          "body": "> When you're creating the additional properties, and immediately read them, the values have the original types you gave them, but when it is serialized and deserialized, the values are JsonElement's. Maybe this isn't actually a problem, but I'm worried this will surprise our users.\n\nThis is by design. TL;DR roundtripping `object` while preserving full type fidelity requires unchecked polymorphic deserialization which is a vector for remote code execution. While we could bake in shape recognition for basic primitives like `int`, `bool` or `string` it becomes hard to draw the line (e.g. why not extend to `int[]`, or `bool[][]`). If you try throw in other common types like `DateTimeOffset`,  `double`, or `Guid` it opens up a whole new can of worms. Who's to say if the JSON value 42 was intended to be handled as `decimal`, `short`, or `double`? Was that `\"2025-04-04\"` JSON string supposed to be `DateTime`, `DateTimeOffset`, `DateOnly` or just `string`? Json.NET has been doing quite a lot of that inference and it is known to create problems. The team decided at the time that it's best to keep things simple.\n\nThere are a few ways behaviour can be configured: either change the underlying representation using the [`JsonSerializerOptions.UnknownTypeHandling`](https://learn.microsoft.com/en-us/dotnet/api/system.text.json.jsonserializeroptions.unknowntypehandling?view=net-9.0#system-text-json-jsonserializeroptions-unknowntypehandling) property or introduce a custom `JsonConverter<object>` that handles object deserialization in a desired manner.\n\n> JsonObject with ExtensionData cannot be used to write values currently, because of https://github.com/dotnet/runtime/issues/97225.\n\nHave you tried using `Dictionary<string, JsonNode?>` instead? This is the recommended way for attaching additional properties using `JsonNode` representations.",
          "createdAt": "2025-04-04T11:43:31Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-04-04T11:44:34Z",
          "id": "IC_kwDODI9FZc6lm9gg"
        },
        {
          "author": "Swimburger",
          "body": "That's good to know. Thank you for clarifying that angle.\nI'll try to figure out a way to make writing and reading a different experience so writing is as flexible as possible, but reading forces you to use `JsonElement` and the type is explicit and clear.\nI think a custom converter may be necessary. Is there an example for replicating extension data in a custom converter? Does it play well with `JsonExtensionData`?\n\nWhen I try using `Dictionary<string, JsonNode?>` or `Dictionary<string, JsonNode>`, I get this exception when trying to serialize:\n\n    The extension data property 'System.Collections.Generic.IDictionary`2[System.String,System.Text.Json.Nodes.JsonNode].AdditionalProperties' is invalid. It must implement 'IDictionary<string, JsonElement>' or 'IDictionary<string, object>', or be 'JsonObject'.",
          "createdAt": "2025-04-04T16:28:43Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-04-04T16:28:43Z",
          "id": "IC_kwDODI9FZc6lp8ny"
        },
        {
          "author": "gregsdennis",
          "body": "@Swimburger I've written a POC project called Graeae to model OpenAPI descriptions using my JsonSchema.Net.  it may not do exactly what you're looking for, but maybe you can find some inspiration there.",
          "createdAt": "2025-04-04T18:36:32Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "EYES",
                "createdAt": "2025-04-04T18:57:16Z",
                "user": "Swimburger"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOEM9-GQ=="
          },
          "updatedAt": "2025-04-04T18:36:32Z",
          "id": "IC_kwDODI9FZc6lq6e7"
        },
        {
          "author": "Swimburger",
          "body": "We figured out a pretty good solution, but we would love to get some feedback on it. Hopefully, this will help folks who are facing the same challenges working with OAS.\n\nWe have to generic classes, `AdditionalProperties` and `ReadOnlyAdditionalProperties`.\nFor unknown types, the type would be `AdditionalProperties<object?>` and `ReadOnlyAdditionalProperties<JsonElement>`.\nFor known types, it'll look like `AdditionalProperties<int>` and `ReadOnlyAdditionalProperties<int>`\n\nThe writeable additional properties are optimized for the writing experience, but `AdditionalProperties` has helper methods to help with making reading easier like\n- `ToJsonObject()`\n- `ToJsonNode()`\n- `ToJsonElement()`\n- `ToJsonDocument()`\n- `ToJsonElementDictionary()`\n\nThese helper methods convert the extensions data directly to the respective types without making unnecessary conversions that target type (type param).\nI could see us adding a `Get<T>(string key)` and `TryGet<T>(string key)` in the future, but we're leaving that out for now.\n\nBoth classes implement `IDictionary<string, T>` so users can interact with it as if it is a dictionary.\n\nOur generated classes look like this:\n\n```csharp\npublic record RecordWithAdditionalPropertiesInts : IJsonOnDeserialized, IJsonOnSerializing\n{\n    // ... normal props ...\n    \n    [JsonExtensionData]\n    private readonly IDictionary<string, object?> _extensionData = new Dictionary<string, object?>();\n\n    [JsonIgnore] public AdditionalProperties<int> AdditionalProperties { get; } = new();\n\n    void IJsonOnDeserialized.OnDeserialized()\n    {\n        AdditionalProperties.CopyFromExtensionData(_extensionData);\n    }\n\n    void IJsonOnSerializing.OnSerializing()\n    {\n        AdditionalProperties.CopyToExtensionData(_extensionData);\n    }\n}\n\npublic record RecordWithReadonlyAdditionalPropertiesInts : IJsonOnDeserialized\n{\n    // ... normal props ...\n    \n    [JsonExtensionData]\n    private readonly IDictionary<string, JsonElement> _extensionData = new Dictionary<string, JsonElement>();\n\n    [JsonIgnore] public ReadOnlyAdditionalProperties<int> AdditionalProperties { get; } = new();\n\n    void IJsonOnDeserialized.OnDeserialized()\n    {\n        AdditionalProperties.CopyFromExtensionData(_extensionData);\n    }\n}\n\n```\n\nTo avoid said security vector\n\n> TL;DR roundtripping object while preserving full type fidelity requires unchecked polymorphic deserialization which is a vector for remote code execution.\n\nWe avoid roundtripping by only converting to the desired type when the user requests it but not actually modifying the JSON extension data. This makes the implementation of `AdditionalProperties` and `ReadOnlyAdditionalProperties` a little more complicated, but it gives the user the optimal DX IMO. There's probably a performance hit, but we tried to minimize it.\n\nHere's some examples of the usage:\n\n```csharp\nvar recordOfUnknown = new RecordOfUnknown\n{\n    // AdditionalProperties<object?>\n    AdditionalProperties =\n    {\n        [\"extra1\"] = new { value = 42 },\n        [\"extra2\"] = DateTime.Now,\n        [\"extra3\"] = 99\n    }\n};\n\nvar recordOfBoolDictionaries = new RecordOfBoolDictionaries\n{\n    // AdditionalProperties<Dictionary<string, bool>>\n    AdditionalProperties =\n    {\n        [\"extra1\"] = new Dictionary<string, bool>\n        {\n            [\"key1\"] = true,\n            [\"key2\"] = false\n        },\n        [\"extra2\"] = new Dictionary<string, bool>\n        {\n            [\"key1\"] = true,\n            [\"key2\"] = false\n        },\n    }\n};\n\nvar recordOfInts = new RecordOfInts\n{\n    // AdditionalProperties<int>\n    AdditionalProperties =\n    {\n        [\"extra1\"] = 42,\n        [\"extra2\"] = 99\n    }\n};\n\nobject? extra1Value = recordOfUnknown.AdditionalProperties[\"extra1\"]; // is an anonymous object, but on deserialization will be JsonElement\nobject? extra2Value = recordOfUnknown.AdditionalProperties[\"extra2\"]; // is DateTime, but on deserialization will be JsonElement\nobject? extra3Value = recordOfUnknown.AdditionalProperties[\"extra3\"]; // is 99, but on deserialization will be JsonElement\nvar jsonElements = recordOfUnknown.AdditionalProperties.ToJsonElementDictionary();\nJsonElement extra1Element = jsonElements[\"extra1\"];\nJsonElement extra2Element = jsonElements[\"extra2\"];\nJsonElement extra3Element = jsonElements[\"extra3\"];\n\nbool extra1Key1 = recordOfBoolDictionaries.AdditionalProperties[\"extra1\"][\"key1\"];\nbool extra1Key2 = recordOfBoolDictionaries.AdditionalProperties[\"extra1\"][\"key2\"];\nbool extra2Key1 = recordOfBoolDictionaries.AdditionalProperties[\"extra2\"][\"key1\"];\n\nint extra1Int = recordOfInts.AdditionalProperties[\"extra1\"];\nint extra2Int = recordOfInts.AdditionalProperties[\"extra2\"];\n```\n\nHere's the implementation of the additional properties classes: \nhttps://github.com/Swimburger/AdditionalProperties/blob/54ef0ecc5a48822b62ecc6353fc12c871396cd0a/AdditionalProperties/AdditionalProperties.cs\n\nIt'd be great if we could tighten the code up more with a converter rather than using the JSON serialization callbacks, but this will do for now.",
          "createdAt": "2025-04-09T23:14:42Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-04-09T23:20:03Z",
          "id": "IC_kwDODI9FZc6mXep0"
        },
        {
          "author": "eiriktsarpalis",
          "body": "> We avoid roundtripping by only converting to the desired type when the user requests it but not actually modifying the JSON extension data.\n\nThat should be fine. It only becomes a security problem when you start embedding type information on the JSON payload. For more information see https://github.com/pwntester/ysoserial.net.",
          "createdAt": "2025-04-10T07:40:44Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-04-10T16:40:01Z",
                "user": "Swimburger"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOENuwZA=="
          },
          "updatedAt": "2025-04-10T07:40:44Z",
          "id": "IC_kwDODI9FZc6maCSj"
        }
      ],
      "totalCount": 9,
      "endCursor": "Y3Vyc29yOnYyOpHOpmgkow=="
    },
    "url": "https://github.com/dotnet/runtime/issues/114106",
    "title": "How to create a symmetrical JSON class for reading and writing that is intuitive with [JsonExtensionData]?"
  },
  {
    "author": "Harpush",
    "labels": [
      "api-suggestion",
      "area-System.Text.Json"
    ],
    "createdAt": "2025-04-04T14:52:16Z",
    "body": "### Background and motivation\n\nCurrently `IAsyncEnumerable` is only supported for top level (root) arrays. The problem is many APIs return json data structured with a wrapper object. For example: `{ \"data\": [/* Huge array here */] }`. This kind of jsons eliminate the ability to use `IAsyncEnumerable` without manual parsing.\nThe expected support is parsing the array inside the `data` property as if it was a root array. \n\n### API Proposal\n\nThere are actually two cases for the API - one for simple cases and one for more control albeit more low level.\n\nFor the high level extend deserialize of `IAsyncEnumerable` to accept a root json path or even a property name.\n```csharp\nJsonSerializer.DeserializeAsyncEnumerable(stream, \"data\");\n```\nThis should also apply to http client methods regarding `IAsyncEnumerable`.\n\nFor the low level - the idea is giving an easier json token parser that allows control on how to deserialize.\nFor example given the json `{ \"data1\": [/* Huge array here */], \"data2\": [/* Huge array here */]}` and the requirement to create an `IAsyncEnumerable` from `data1` concatenated with `data2` the api could allow:\n```csharp\nusing var jsonStreamReader = new JsonStreamReader(stream, bufferSize /* Maybe? */);\n\nawait jsonStreamReader.ReadAsync(); // skip object start\nawait jsonStreamReader.ReadAsync(); // skip data1\n\nvar data1AsyncEnumerable = jsonStreamReader.DeserializeAsyncEnumerable<DataItem>(options);\n\nawait foreach (var item in data1AsyncEnumerable)\n{\n    yield return item;\n}\n\nawait jsonStreamReader.ReadAsync(); // skip data2\n\nvar data2AsyncEnumerable = jsonStreamReader.DeserializeAsyncEnumerable<DataItem>(options);\n\nawait foreach (var item in data2AsyncEnumerable)\n{\n    yield return item;\n}\n```\nHere `JsonStreamReader` is the new API that allows much more control.\n\n### API Usage\n\nMentioned above in API proposal\n\n\n### Alternative Designs\n\nCurrently the only way is writing my own parser with low level APIs which isn't trivial at all\n\n### Risks\n\nNone (probably?)",
    "number": 114265,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-04-04T18:11:18Z",
          "user": "joelverhagen"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-04-05T13:54:00Z",
          "user": "omariom"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-09-04T08:10:35Z",
          "user": "austinw-fineart"
        }
      ],
      "totalCount": 3,
      "endCursor": "Y3Vyc29yOnYyOpHODOWKEw=="
    },
    "updatedAt": "2025-04-05T22:11:35Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": "dotnet-policy-service",
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. -->",
          "createdAt": "2025-04-04T14:52:52Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-04-04T14:52:52Z",
          "id": "IC_kwDODI9FZc6lo6T2"
        },
        {
          "author": "eiriktsarpalis",
          "body": "It's unlikely we would add a \"JsonStreamReader\" just to enable this feature. The more likely outcome is introducing an overload to the existing `JsonSerializer.DeserializeAsyncEnumerable` methods that takes a JSON pointer/JSON path parameter pinpointing the nested array that requires streaming.",
          "createdAt": "2025-04-04T15:11:58Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-04-04T15:11:58Z",
          "id": "IC_kwDODI9FZc6lpG6D"
        },
        {
          "author": "Harpush",
          "body": "That's fine too. The idea of the reader is to allow any combination of read tokens and deserialize. I would expect a regular deserialize (non IAsyncEnumerable) method too",
          "createdAt": "2025-04-04T15:17:55Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-04-04T15:17:55Z",
          "id": "IC_kwDODI9FZc6lpMFE"
        },
        {
          "author": "brantburnett",
          "body": "I have a nested array streaming use case in the Couchbase SDK which requires maintaining the other context. It's implemented using a custom wrapper around `Stream` using `Utf8JsonReader` and `JsonReaderState`. Unfortunately, the example is complicated a bit because it's abstracted to also support Newtonsoft. I share it in case it gives insight into other use cases. \n\nhttps://github.com/couchbase/couchbase-net-client/blob/master/src/Couchbase/Query/StreamingQueryResult.cs\nhttps://github.com/couchbase/couchbase-net-client/blob/master/src/Couchbase/Core/IO/Serializers/SystemTextJson/SystemTextJsonStreamReader.cs",
          "createdAt": "2025-04-04T15:50:41Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "HOORAY",
                "createdAt": "2025-04-05T07:15:39Z",
                "user": "Harpush"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOENAR4Q=="
          },
          "updatedAt": "2025-04-04T15:50:41Z",
          "id": "IC_kwDODI9FZc6lporX"
        },
        {
          "author": "Harpush",
          "body": "Just to add some more examples to why `JsonStreamReader` is a good idea:\n1. Can allow custom json processing (for example json: `{metadata: {...}, data: [/*huge json*/]}`):\n```csharp\nawait jsonReader.SkipAsync(JsonTokenType.StartObject);\nawait jsonReader.SkipAsync(JsonTokenType.PropertyName);\n\nMetadata metadata = await jsonReader.DeserializeAsync<Metadata>();\n\nawait jsonReader.SkipAsync(JsonTokenType.PropertyName);\n\nawait foreach (ArrayItem arrItem in jsonReader.DeserializeAsyncEnumerable<ArrayItem>())\n{\n    // Use it\n}\n``` \n2. Can allow the path based deserialize mentioned in the post\n3. Can allow `IAsyncEnumerable` of dictionary (`{a: {...}, b: {...}, c: {...}}`) with `KeyValuePair`:\n```csharp\nawait jsonReader.SkipAsync(JsonTokenType.StartObject);\n\nwhile (true)\n{\n    JsonTokenType token = await jsonReader.PeekAsync();\n\n    if (token == JsonTokenType.EndObject)\n    {\n        yield break;\n    }\n\n    string prop = await jsonReader.ReadPropertyNameAsync(); // Or similar API\n    Item item = await jsonReader.DeserializeAsync<Item>();\n\n    var pair = new KeyValuePair<string, Item>(prop, item);\n\n    yield return pair;\n}\n```",
          "createdAt": "2025-04-05T22:11:34Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-04-05T22:11:34Z",
          "id": "IC_kwDODI9FZc6lxGlw"
        }
      ],
      "totalCount": 5,
      "endCursor": "Y3Vyc29yOnYyOpHOpcRpcA=="
    },
    "url": "https://github.com/dotnet/runtime/issues/114265",
    "title": "[API Proposal]: Add support for nested data streaming in `JsonSerializer.DeserializeAsyncEnumerable`."
  },
  {
    "author": "blowdart",
    "labels": [
      "area-System.Text.Json",
      "linkable-framework"
    ],
    "createdAt": "2025-04-06T10:05:43Z",
    "body": "### Description\n\nWhen attempting to run an aot/trimming test program I get unexpected trim analysis errors around enums, and around a suppressed line of code.dotnet \n\n### Reproduction Steps\n\nSee https://github.com/blowdart/idunno.Bluesky/tree/il2070-2090-issue\n\nClone and run .\\trimTest.ps1\n\n### Expected behavior\n\nCode compiles, links (respecting suppressions in JsonOptions.cs) and produces trimmed AOT executable.\n\n### Actual behavior\n\nErrors on linking\n\n```\n  idunno.TrimmingTest failed with 5 error(s) (9.5s) → trimming\\bin\\Release\\net8.0\\win-x64\\idunno.TrimmingTest.dll\n    Optimizing assemblies for size. This process might take a while.\n    G:\\idunno.Bluesky\\src\\idunno.AtProto\\JsonOptions.cs(42,13): Trim analysis error IL2026: idunno.AtProto.JsonOptions.CreateDefaultTypeResolver(): Using member 'System.Text.Json.Serialization.Metadata.DefaultJsonTypeInfoResolver.DefaultJsonTypeInfoResolver()' which has 'RequiresUnreferencedCodeAttribute' can break functionality when trimming application code. JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.\n    ILLink : Trim analysis error IL2090: System.Text.Json.Serialization.Converters.EnumConverter<T>.ResolveEnumFields(JsonNamingPolicy): 'this' argument does not satisfy 'DynamicallyAccessedMemberTypes.PublicFields' in call to 'System.Type.GetFields(BindingFlags)'. The generic parameter 'T' of 'System.Text.Json.Serialization.Converters.EnumConverter<T>' does not have matching annotations. The source value must declare at least the same requirements as those declared on the target location it is assigned to.\n    ILLink : Trim analysis error IL2070: System.Text.Json.Serialization.Converters.EnumConverterFactory.Create(Type, EnumConverterOptions, JsonNamingPolicy, JsonSerializerOptions): 'this' argument does not satisfy 'DynamicallyAccessedMemberTypes.PublicParameterlessConstructor' in call to 'System.Type.MakeGenericType(Type[])'. The parameter 'enumType' of method 'System.Text.Json.Serialization.Converters.EnumConverterFactory.Create(Type, EnumConverterOptions, JsonNamingPolicy, JsonSerializerOptions)' does not have matching annotations. The source value must declare at least the same requirements as those declared on the target location it is assigned to.\n    ILLink : Trim analysis error IL2070: System.Text.Json.Serialization.Converters.NullableConverterFactory.GetNullableConverterType(Type): 'this' argument does not satisfy 'DynamicallyAccessedMemberTypes.PublicParameterlessConstructor' in call to 'System.Type.MakeGenericType(Type[])'. The parameter 'valueTypeToConvert' of method 'System.Text.Json.Serialization.Converters.NullableConverterFactory.GetNullableConverterType(Type)' does not have matching annotations. The source value must declare at least the same requirements as those declared on the target location it is assigned to.\n    G:\\Users\\BarryDorrans\\.nuget\\packages\\microsoft.net.illink.tasks\\8.0.14\\build\\Microsoft.NET.ILLink.targets(87,5): error NETSDK1144: Optimizing assemblies for size failed.\n\nBuild failed with 5 error(s) and 1 warning(s) in 14.1s\n```\n\n### Regression?\n\n_No response_\n\n### Known Workarounds\n\n_No response_\n\n### Configuration\n\n```\n.NET SDK:\n Version:           9.0.201\n Commit:            071aaccdc2\n Workload version:  9.0.200-manifests.5c4e24dc\n MSBuild version:   17.13.13+1c2026462\n\nRuntime Environment:\n OS Name:     Windows\n OS Version:  10.0.26100\n OS Platform: Windows\n RID:         win-x64\n Base Path:   C:\\Program Files\\dotnet\\sdk\\9.0.201\\\n\nHost:\n  Version:      9.0.3\n  Architecture: x64\n  Commit:       831d23e561\n\n.NET SDKs installed:\n  7.0.302 [C:\\Program Files\\dotnet\\sdk]\n  9.0.201 [C:\\Program Files\\dotnet\\sdk]\n\n.NET runtimes installed:\n  Microsoft.AspNetCore.App 3.1.32 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\n  Microsoft.AspNetCore.App 6.0.36 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\n  Microsoft.AspNetCore.App 8.0.14 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\n  Microsoft.AspNetCore.App 9.0.3 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\n  Microsoft.NETCore.App 3.1.32 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\n  Microsoft.NETCore.App 6.0.36 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\n  Microsoft.NETCore.App 8.0.14 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\n  Microsoft.NETCore.App 9.0.3 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\n  Microsoft.WindowsDesktop.App 3.1.32 [C:\\Program Files\\dotnet\\shared\\Microsoft.WindowsDesktop.App]\n  Microsoft.WindowsDesktop.App 6.0.36 [C:\\Program Files\\dotnet\\shared\\Microsoft.WindowsDesktop.App]\n  Microsoft.WindowsDesktop.App 8.0.14 [C:\\Program Files\\dotnet\\shared\\Microsoft.WindowsDesktop.App]\n  Microsoft.WindowsDesktop.App 9.0.3 [C:\\Program Files\\dotnet\\shared\\Microsoft.WindowsDesktop.App]\n\nOther architectures found:\n  arm64 [C:\\Program Files\\dotnet]\n    registered at [HKLM\\SOFTWARE\\dotnet\\Setup\\InstalledVersions\\arm64\\InstallLocation]\n  x86   [C:\\Program Files (x86)\\dotnet]\n    registered at [HKLM\\SOFTWARE\\dotnet\\Setup\\InstalledVersions\\x86\\InstallLocation]\n\nEnvironment variables:\n  Not set\n\nglobal.json file:\n  Not found\n\n```\n\n### Other information\n\n@eiriktsarpalis Here's the pared back repo :)",
    "number": 114307,
    "reactions": {
      "hasNextPage": false,
      "nodes": [],
      "totalCount": 0,
      "endCursor": null
    },
    "updatedAt": "2025-07-23T08:42:35Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": "dotnet-policy-service",
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. -->",
          "createdAt": "2025-04-06T10:06:06Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-04-06T10:06:06Z",
          "id": "IC_kwDODI9FZc6lx-0i"
        },
        {
          "author": "eiriktsarpalis",
          "body": "For the trimmer you need to use UnconditionalSuppressedMessage instead of SuppressMessage.",
          "createdAt": "2025-04-07T08:05:28Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-04-07T08:05:28Z",
          "id": "IC_kwDODI9FZc6l172V"
        },
        {
          "author": "blowdart",
          "body": "Hah, that solves that part of it, but the IL2090 / IL2070 on the enums remains, or do I supress those over every enum as well?",
          "createdAt": "2025-04-07T08:49:34Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-04-07T08:49:34Z",
          "id": "IC_kwDODI9FZc6l2ZWW"
        },
        {
          "author": "MichalStrehovsky",
          "body": "The problem is that this ends up using a .NET 8 ILLink against a .NET 9 System.Text.Json. The .NET 8 ILLink doesn't consider the .NET 9 System.Text.Json trim safe due to the problems I break down below. There's not much the user can do: the warnings only go away if the idunno.TrimmingTest project is updated to .NET 9 (except for the one warning in iDunno, which needs to be fixed in iDunno).\n\nLooks like we don't analyze assemblies that ship OOB in .NET vCurrent with vPrevious ILLink when we build them for vPrevious in dotnet/runtime. Maybe we accidentally override the trim analyzer with the live ILLink analyzer instead of just using the ILLink analyzer that ships with the respective framework version? Cc @dotnet/illink \n\nThe issues are:\n* `System.Text.Json.Serialization.Converters.EnumConverter<T>.ResolveEnumFields` requires #100814 to not warn and that feature only exists in .NET 9+. The code would be trim safe before that PR too, but that PR is the thing that makes this not warn. Would be fixable by just suppressing the warning under `!NET9_0_OR_GREATER` in the S.T.Json source (the justification is that public static fields on enums are always preserved).\n* The `System.Text.Json.Serialization.Converters.EnumConverterFactory.Create` and `System.Text.Json.Serialization.Converters.NullableConverterFactory.GetNullableConverterType` warnings are from #104921. We did a mild breaking change in what warning code is generated. That PR also updated the suppression in S.T.Json. We'd also need an ifdef to use the old warning code for < .NET 9.0.\n",
          "createdAt": "2025-04-11T06:06:12Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-04-11T06:06:12Z",
          "id": "IC_kwDODI9FZc6mplJB"
        },
        {
          "author": "blowdart",
          "body": "Well, I can't update the projects to 9, as I specifically want to support 8.\n\nSo no trimming it is then.",
          "createdAt": "2025-04-21T18:04:05Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-04-21T18:04:05Z",
          "id": "IC_kwDODI9FZc6oCMfh"
        },
        {
          "author": "MichalStrehovsky",
          "body": "> Well, I can't update the projects to 9, as I specifically want to support 8.\n\nTo be clear only the `idunno.TrimmingTest` project needs to be updated to 9.0 work around this.",
          "createdAt": "2025-04-22T04:15:02Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-04-22T04:15:02Z",
          "id": "IC_kwDODI9FZc6oFgqt"
        },
        {
          "author": "eiriktsarpalis",
          "body": "@MichalStrehovsky is there anything actionable we can do w.r.t. .NET 8 servicing? Or should I just close this?",
          "createdAt": "2025-04-23T08:16:57Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-04-23T08:16:57Z",
          "id": "IC_kwDODI9FZc6oSm6n"
        },
        {
          "author": "MichalStrehovsky",
          "body": "> [@MichalStrehovsky](https://github.com/MichalStrehovsky) is there anything actionable we can do w.r.t. .NET 8 servicing? Or should I just close this?\n\nThis is fixable, the instructions are in my previous comment. But the shiproom is going to ask whether we're sure that's all that's needed to fix and the answer will be we don't know unless the other fix (on the side of how we run illinker analyzer) is also done. I CC'd @dotnet/illink because that's where the expertise is. I can help if needed.",
          "createdAt": "2025-04-23T10:17:19Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-04-23T10:17:19Z",
          "id": "IC_kwDODI9FZc6oT9rU"
        },
        {
          "author": "agocke",
          "body": "@sbomer can you take a look as well?",
          "createdAt": "2025-04-23T17:05:14Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-04-23T17:05:14Z",
          "id": "IC_kwDODI9FZc6oYZoL"
        },
        {
          "author": "sbomer",
          "body": "Based on @MichalStrehovsky's analysis I think we should fix this by suppressing the warnings as mentioned. I'm looking into fixing the analyzer version used for OOBs in https://github.com/dotnet/runtime/pull/114983.",
          "createdAt": "2025-04-24T00:36:39Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-04-24T00:36:39Z",
          "id": "IC_kwDODI9FZc6obx90"
        },
        {
          "author": "jeffhandley",
          "body": "@sbomer Is this issue and the #114983 PR still on your radar for .NET 10? For now, I'm moving the issue to Future, but feel free to pull it back into .NET 10 if you plan to drive that to a close.",
          "createdAt": "2025-07-23T08:42:21Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-07-23T08:42:21Z",
          "id": "IC_kwDODI9FZc65Khw0"
        }
      ],
      "totalCount": 11,
      "endCursor": "Y3Vyc29yOnYyOpHOuSocNA=="
    },
    "url": "https://github.com/dotnet/runtime/issues/114307",
    "title": "IL206/ IL2070/IL2090 Linker errors when trimming/AOTing around enums"
  },
  {
    "author": "mwadams",
    "labels": [
      "api-suggestion",
      "area-System.Text.Json"
    ],
    "createdAt": "2025-04-15T10:01:01Z",
    "body": "### Background and motivation\n\nIt is currently disproportionately difficult to write (performance sensitive) code equivalent to that in `public static JsonDocument ParseValue(ref Utf8JsonReader reader)`, because we cannot get the slice of the underlying Sequence or Span for an entire complex value (e.g. an array or object). \n\nThe existing `ValueSpan` and `ValueSequence` entities only give us the span for the current token, and `OriginalSpan` and `OriginalSequence` are not available to us.\n\nOn the assumption that it is \"too dangerous\" simply to make those APIs available publicly, I would like to see them available via `JsonMarshal`.\n\n\n### API Proposal\n\n```csharp\n    /// <summary>\n    /// An unsafe class that provides a set of methods to access the underlying data representations of JSON types.\n    /// </summary>\n    public static class JsonMarshal\n    {\n        /// <summary>\n        /// Gets the original sequence backing the reader.\n        /// </summary>\n        /// <param name=\"reader\">The Utf8JsonReader to inspect.\n        /// <returns>\n        /// The sequence backing the reader, or <c>ReadOnlySequence&lt;byte&gt;.Empty</c> if no sequence backs the reader.\n        /// </returns>\n        public static ReadOnlySequence<byte> GetOriginalSequence(ref Utf8JsonReader reader);\n\n        /// <summary>\n        /// Gets the original span backing the reader.\n        /// </summary>\n        /// <param name=\"reader\">The Utf8JsonReader to inspect.\n        /// <returns>\n        /// The span backing the reader, or <c>ReadOnlySpan&lt;byte&gt;.Empty</c> if no span backs the reader.\n        /// </returns>\n        public static ReadOnlySpan<byte> GetOriginalSpan(ref Utf8JsonReader reader);\n    }\n```\n\n### API Usage\n\n```csharp\nUtf8JsonReader reader; // Obtained from somewhere\nDebug.Assert(reader.TokenType == JsonTokenType.StartArray || reader.TokenType == JsonTokenType.StartObject);\nscoped ReadOnlySpan<byte> valueSpan;\nReadOnlySequence<byte> valueSequence;\n\nlong startingOffset = reader.TokenStartIndex;\n\nif (!reader.TrySkip())\n{\n        throw new Exception(\"Couldn't read that...\");\n}\n\nlong totalLength = reader.BytesConsumed - startingOffset;\nReadOnlySequence<byte> sequence = JsonMarshal.OriginalSequence(ref reader);\n\nif (sequence.IsEmpty)\n{\n    valueSpan = JsonMarshal.OriginalSpan(ref reader).Slice(\n        checked((int)startingOffset),\n        checked((int)totalLength));\n}\nelse\n{\n    valueSequence = sequence.Slice(startingOffset, totalLength);\n}\n\n// continue processing\n```\n\n\n### Alternative Designs\n\nWe could expose `OriginalSpan` and `OriginalSequence` as public members. While we already expose ValueSpan and ValueSequence in this way, it feels like a step too far to let people play on the underlying data without a `JsonMarshal` indirection.\n\n### Risks\n\nThere seems to be no significant risk beyond the usual issues of giving people access to underlying UTF8 data. This is less significant for Utf8JsonReader because it really is a reader of underlying UTF8 bytes. There is no question of this being replaced in future with some alternate backing representation such as UTF16.",
    "number": 114679,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-04-17T05:33:11Z",
          "user": "HowardvanRooijen"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-04-22T08:40:05Z",
          "user": "jongeorge1"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-08-04T15:58:41Z",
          "user": "bbartels"
        }
      ],
      "totalCount": 3,
      "endCursor": "Y3Vyc29yOnYyOpHODJxS8Q=="
    },
    "updatedAt": "2025-04-23T11:48:33Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": "dotnet-policy-service",
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. -->",
          "createdAt": "2025-04-15T12:49:14Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-04-15T12:49:14Z",
          "id": "IC_kwDODI9FZc6nMArk"
        },
        {
          "author": "grbell-ms",
          "body": "The real risk of exposing the original Span/Sequence is that it hasn't been unescaped. If a developer used this API without handling escaping themselves, they might open their app up to XSS or other injection attacks. \n\nAn alternative might be an API that gets the _unescaped_ bytes between two offsets within the reader. (Similar to the `CopyString()` methods)",
          "createdAt": "2025-04-15T21:12:57Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-04-15T21:13:33Z",
          "id": "IC_kwDODI9FZc6nV4ej"
        },
        {
          "author": "mwadams",
          "body": "> The real risk of exposing the original Span/Sequence is that it hasn't been unescaped. If a developer used this API without handling escaping themselves, they might open their app up to XSS or other injection attacks.\n> \n> An alternative might be an API that gets the _unescaped_ bytes between two offsets within the reader. (Similar to the `CopyString()` methods)\n\nThat's why I'm suggesting putting the new APIs in `JsonMarshal` which is where we have put the similarly risky methods to access the underlying spans of property names, and element values.\n\n(It's also worth pointing out that the existing `Utf8JsonReader.ValueSpan` and `Utf8JsonReader.ValueSequence` are the unescaped UTF8 backing data; it would probably have been better for those to have been exposed through a similar `JsonMarshal` API, but it would be a significant breaking change to move them now.) ",
          "createdAt": "2025-04-16T10:14:30Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-04-16T10:22:57Z",
          "id": "IC_kwDODI9FZc6nb2TX"
        }
      ],
      "totalCount": 3,
      "endCursor": "Y3Vyc29yOnYyOpHOp29k1w=="
    },
    "url": "https://github.com/dotnet/runtime/issues/114679",
    "title": "[API Proposal]: Add APIs to `JsonMarshal` to get the underlying sequence/span from the Utf8JsonReader."
  },
  {
    "author": "S-Luiten",
    "labels": [
      "enhancement",
      "area-System.Text.Json"
    ],
    "createdAt": "2025-04-15T15:06:41Z",
    "body": "### Description\n\nSystem.Text.Json cannot deserialize JSON which contains the `$schema` metadata property.\n\n### Reproduction Steps\n\nFrom https://github.com/dotnet/runtime/issues/79059#issuecomment-1995919754:\n\n```csharp\n[JsonDerivedType(typeof(DerivedType), typeDiscriminator: nameof(DerivedType))]\npublic abstract class BaseType\n{\n}\n\npublic sealed class DerivedType : BaseType\n{\n}\n\ninternal class Program\n{\n    static void Main()\n    {\n        var text =\n        \"\"\"\n        {\n            \"$type\": \"DerivedType\",\n            \"$schema\": \"http://example.org/myschema.json\",\n        }\n        \"\"\";\n        var baseObj = JsonSerializer.Deserialize<BaseType>(text);\n    }\n}\n```\n\n### Expected behavior\n\nDeserialization should succeed without throwing an exception.\n\n### Actual behavior\n\n`JsonSerializer.Deserialize` throws an exception: `System.Text.Json.JsonException: Properties that start with '$' are not allowed in types that support metadata. Either escape the character or disable reference preservation and polymorphic deserialization.`\n\n### Regression?\n\n_No response_\n\n### Known Workarounds\n\n_No response_\n\n### Configuration\n\n_No response_\n\n### Other information\n\n_No response_",
    "number": 114691,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-04-23T12:36:16Z",
          "user": "samsosa"
        }
      ],
      "totalCount": 1,
      "endCursor": "Y3Vyc29yOnYyOpHODBltOg=="
    },
    "updatedAt": "2025-04-24T07:05:56Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": "dotnet-policy-service",
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. -->",
          "createdAt": "2025-04-15T15:07:21Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-04-15T15:07:21Z",
          "id": "IC_kwDODI9FZc6nP3Cv"
        },
        {
          "author": "eiriktsarpalis",
          "body": "It's a restriction we could relax in the future.",
          "createdAt": "2025-04-23T11:49:37Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-04-23T12:36:09Z",
                "user": "samsosa"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOEPYAyA=="
          },
          "updatedAt": "2025-04-23T11:49:37Z",
          "id": "IC_kwDODI9FZc6oUzDT"
        },
        {
          "author": "gregsdennis",
          "body": "@eiriktsarpalis why does my serializer work for JsonSchema.Net?  I handle `$schema` necessarily.  Is it because I have a custom converter?",
          "createdAt": "2025-04-24T07:05:30Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-04-24T07:05:56Z",
          "id": "IC_kwDODI9FZc6oelqh"
        }
      ],
      "totalCount": 3,
      "endCursor": "Y3Vyc29yOnYyOpHOqHpaoQ=="
    },
    "url": "https://github.com/dotnet/runtime/issues/114691",
    "title": "System.Text.Json should recognize $schema as a metadata property."
  },
  {
    "author": "mwadams",
    "labels": [
      "api-suggestion",
      "area-System.Text.Json"
    ],
    "createdAt": "2025-04-16T21:48:20Z",
    "body": "### Background and motivation\n\nThere is currently no safe way of writing a raw UTF8-formatted JSON number using `Utf8JsonWriter`.\n\nYou can use `Utf8JsonWriter.WriteRawValue()` but this does not perform any validation, and does not participate in indentation etc.\n\nYou could also create a `Utf8JsonReader` instance, and round trip the value via a JsonElement but this is very inefficient.\n\nHowever, there is an existing API that *does* perform all the necessary validation - `Utf8JsonWriter.WriteNumberValue()`\n\nUnfortunately, it is `internal`.\n\n### API Proposal\n\n```csharp\n    public sealed partial class Utf8JsonWriter\n    {\n        /// <summary>\n        /// Writes the value (as a JSON number) as an element of a JSON array.\n        /// </summary>\n        /// <param name=\"utf8FormattedNumber\">The value to write.</param>\n        /// <exception cref=\"ArgumentException\">\n        /// Thrown when <paramref name=\"utf8FormattedNumber\"/> does not represent a valid JSON number.\n        /// </exception>\n        /// <exception cref=\"InvalidOperationException\">\n        /// Thrown if this would result in invalid JSON being written (while validation is enabled).\n        /// </exception>\n        /// <remarks>\n        /// Validates that the formatted number represents a valid JSON number, and writes it to the output.\n        /// </remarks>\n        public void WriteNumberValue(ReadOnlySpan<byte> utf8FormattedNumber);\n    }\n```\n\n(Note that this documentation differs slightly from the XML docs in the dotnet runtime repo, as the original `<remarks/` are not quite accurate.)\n\n### API Usage\n\n```csharp\nUtf8JsonWriter writer;\n\nReadOnlySpan<byte> utf8Json = \"{\\\"prop1\\\":123.45}\"u8;\n\nint offset = 9;\nint length = 6;\n\ntry\n{\n    writer.WriteNumberValue(utf8Json.Span.Slice(offset, length));\n}\ncatch(ArgumentException ex)\n{\n    // invalid number format\n}\ncatch(InvalidOPerationException ex2)\n{\n    // Invalid JSON\n}\n```\n\n\n### Alternative Designs\n\nNote that this is not a new API - it exposes an existing API that is well-covered by existing tests.\n\n### Risks\n\nI don't see any significant risks with this API. It is already designed defensively.",
    "number": 114753,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-04-17T05:31:52Z",
          "user": "HowardvanRooijen"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-04-22T08:38:37Z",
          "user": "jongeorge1"
        }
      ],
      "totalCount": 2,
      "endCursor": "Y3Vyc29yOnYyOpHODBgDrQ=="
    },
    "updatedAt": "2025-04-24T13:30:37Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": "dotnet-policy-service",
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. -->",
          "createdAt": "2025-04-16T21:48:46Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-04-16T21:48:46Z",
          "id": "IC_kwDODI9FZc6nisjW"
        },
        {
          "author": "gregsdennis",
          "body": "Does this warrant exposing other `.Write*Value()` methods?  Seems silly to expose just one.",
          "createdAt": "2025-04-17T00:34:45Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-04-17T08:01:41Z",
                "user": "elgonzo"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-04-17T12:44:02Z",
                "user": "mwadams"
              }
            ],
            "totalCount": 2,
            "endCursor": "Y3Vyc29yOnYyOpHOEOt_tw=="
          },
          "updatedAt": "2025-04-17T00:34:45Z",
          "id": "IC_kwDODI9FZc6nkZEZ"
        },
        {
          "author": "mwadams",
          "body": "> Does this warrant exposing other `.Write*Value()` methods? Seems silly to expose just one.\n\nWell you already have all the public `.WriteStringValue()` methods (which include e.g. Guid and DateTime etc).\n\nI guess there is an argument for `boolean` and `null` - although I don't personally have a use-case for those as it is almost always quicker to work from a tokenized value for those.",
          "createdAt": "2025-04-17T12:56:54Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-04-23T10:57:48Z",
                "user": "eiriktsarpalis"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOEPXRCA=="
          },
          "updatedAt": "2025-04-17T12:56:54Z",
          "id": "IC_kwDODI9FZc6np5tw"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Sounds reasonable, although I'm not sure how I feel about disabling validation for this particular method.",
          "createdAt": "2025-04-23T10:57:49Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-04-23T10:57:49Z",
          "id": "IC_kwDODI9FZc6oUVDj"
        },
        {
          "author": "mwadams",
          "body": "> Sounds reasonable, although I'm not sure how I feel about disabling validation for this particular method.\n\nI think we should *not* disable validation. A key benefit is that it is validated.",
          "createdAt": "2025-04-24T12:35:25Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-04-24T12:35:25Z",
          "id": "IC_kwDODI9FZc6oh6Ku"
        },
        {
          "author": "eiriktsarpalis",
          "body": "That's what I mean. I was specifically responding to this comment:\n\n> Thrown if this would result in invalid JSON being written (while validation is enabled).\n\nI don't think we should predicate JSON number validation on `SkipValidation` being enabled, since that concerns structural validation. OTOH validating that a string is a valid JSON number is trivial and should be kept.",
          "createdAt": "2025-04-24T13:30:36Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-05-03T13:35:50Z",
                "user": "mwadams"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOEQqysQ=="
          },
          "updatedAt": "2025-04-24T13:30:36Z",
          "id": "IC_kwDODI9FZc6oimzU"
        }
      ],
      "totalCount": 6,
      "endCursor": "Y3Vyc29yOnYyOpHOqIps1A=="
    },
    "url": "https://github.com/dotnet/runtime/issues/114753",
    "title": "[API Proposal]: Expose `Utf8JstonWriter.WriteNumberValue(ReadOnlySpan<byte> utf8FormattedNumber)` publically"
  },
  {
    "author": "S-Luiten",
    "labels": [
      "api-suggestion",
      "area-System.Text.Json"
    ],
    "createdAt": "2025-04-22T15:02:49Z",
    "body": "### Background and motivation\n\nI apply DataAnnotations attributes (migrating from Newtonsoft.Json.Schema) to the JSON generated schema through `JsonSchemaExporterOptions.TransformSchemaNode`. However, the built-in generator transforms part of the schema into a `$ref` before I can apply my own transformations, resulting in an incorrect schema because the values of the attributes are not the same. Here's an example:\n\n```csharp\n[TypeArgumentRegularExpression(\"[A-Za-z]+\", 0)]\n[TypeArgumentRegularExpression(\"[0-9]+\", 1)]\npublic Dictionary<string, string[]>? Dict { get; set; }\n\n[TypeArgumentRegularExpression(\"[A-Z]+\", 0)]\n[TypeArgumentRegularExpression(\"[a-z]+\", 1)]\n[TypeArgumentRegularExpression(\"[0-9]+\", 2)]\npublic Dictionary<string, Dictionary<string, string[]>>? Dict2 { get; set; }\n```\n\nNote that `TypeArgumentRegularExpression` is a custom attribute based on `System.ComponentModel.DataAnnotations.RegularExpressionAttribute` which allows me to specify to which TKey/TValue the regex pattern should be applied. The resulting schema looks like:\n\n```json\n\"properties\": {\n  \"Dict\": {\n    \"type\": \"object\",\n    \"additionalProperties\": false,\n    \"patternProperties\": {\n      \"[A-Za-z]\\u002B\": {\n        \"type\": \"array\",\n        \"items\": {\n          \"type\": \"string\",\n          \"pattern\": \"[0-9]\\u002B\"\n        }\n      }\n    }\n  },\n  \"Dict2\": {\n    \"type\": \"object\",\n    \"additionalProperties\": false,\n    \"patternProperties\": {\n      \"[A-Z]\\u002B\": {\n        \"$ref\": \"#/properties/Dict\"\n      }\n    }\n  }\n}\n```\n\nAs you can see, the TValue of the second dictionary has been turned into a $ref to the first dictionary, even though it has a different regex pattern for TKey (Dict's TKey is `[A-Za-z]+`, but Dict2-TValue's TKey only allows `[a-z]+`).\n\nI think the easiest solution for this would be an option to disable generating $refs.\n\n### API Proposal\n\n```csharp\nnamespace System.Text.Json.Schema;\n\npublic sealed class JsonSchemaExporterOptions\n{\n    public bool GenerateRefs { get; init; }\n}\n```\n\n\n### API Usage\n\n```csharp\nvar transformer = new MyJsonSchemaTransformer();\n\nvar jsonSchemaExporterOptions = new JsonSchemaExporterOptions\n{\n    TreatNullObliviousAsNonNullable = true,\n    TransformSchemaNode = transformer.TransformSchemaNode,\n    GenerateRefs = false,\n};\n\nvar result = jsonSerializerOptions.GetJsonSchemaAsNode(typeof(MyObject), jsonSchemaExporterOptions).ToString();\n```\n\n\n### Alternative Designs\n\n_No response_\n\n### Risks\n\n_No response_",
    "number": 114916,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-06-09T21:56:15Z",
          "user": "scott-dak"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-09-19T11:44:43Z",
          "user": "tombiddulph"
        }
      ],
      "totalCount": 2,
      "endCursor": "Y3Vyc29yOnYyOpHODR42KQ=="
    },
    "updatedAt": "2025-04-23T08:32:48Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": "dotnet-policy-service",
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. -->",
          "createdAt": "2025-04-22T15:03:18Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-04-22T15:03:18Z",
          "id": "IC_kwDODI9FZc6oLq0T"
        }
      ],
      "totalCount": 1,
      "endCursor": "Y3Vyc29yOnYyOpHOqC6tEw=="
    },
    "url": "https://github.com/dotnet/runtime/issues/114916",
    "title": "[API Proposal]: System.Text.Json.Schema: option to disable generating $refs"
  },
  {
    "author": "eiriktsarpalis",
    "labels": [
      "api-suggestion",
      "area-System.Text.Json"
    ],
    "createdAt": "2025-04-23T14:38:37Z",
    "body": "> Would be interesting to have a equality comparer in the `JsonElement` so, do we have an issue tackling this scenario?\n> \n> Possibly, although deep equality comparison is a potentially expensive operation so I'm not certain we want to make this the default for `.Equals()`. We went for using an explicitly named `DeepEquals` instead so that users understand the costs involved (and potentially use that to implement their own `IEqualityComparer<JsonElement>`). \n\n _Originally posted by @eiriktsarpalis in [#6305](https://github.com/dotnet/extensions/issues/6305#issuecomment-2824506720)_",
    "number": 114959,
    "reactions": {
      "hasNextPage": false,
      "nodes": [],
      "totalCount": 0,
      "endCursor": null
    },
    "updatedAt": "2025-04-24T07:33:46Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": "dotnet-policy-service",
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. -->",
          "createdAt": "2025-04-23T14:39:22Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-04-23T14:39:22Z",
          "id": "IC_kwDODI9FZc6oWxnZ"
        },
        {
          "author": "gregsdennis",
          "body": "I agree that deep equality can be expensive, but of what use is shallow equality for JSON?",
          "createdAt": "2025-04-24T02:54:25Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-04-24T02:54:25Z",
          "id": "IC_kwDODI9FZc6oc4yF"
        },
        {
          "author": "eiriktsarpalis",
          "body": "It should either be reference equality (the current default) or deep equality comparison.",
          "createdAt": "2025-04-24T07:33:45Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-04-24T13:17:57Z",
                "user": "gregsdennis"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOEPh0LA=="
          },
          "updatedAt": "2025-04-24T07:33:45Z",
          "id": "IC_kwDODI9FZc6oe0yf"
        }
      ],
      "totalCount": 3,
      "endCursor": "Y3Vyc29yOnYyOpHOqHtMnw=="
    },
    "url": "https://github.com/dotnet/runtime/issues/114959",
    "title": "Consider having `JsonElement` implement `IEquatable<T>`"
  },
  {
    "author": "vasicvuk",
    "labels": [
      "area-System.Text.Json",
      "tenet-performance",
      "discussion"
    ],
    "createdAt": "2025-05-21T07:41:45Z",
    "body": "\n### Description\n\nWe have a scenario to load a large JSON file into .NET but noticed that the memory usage went high when using System.Text, we also tried to use Newtonsoft.JSON then and it shows way less memory usage for the same 200mb file JSON.\n\nCode for Newtonsoft JSON:\n\n```csharp\nDefaultContractResolver contractResolver = new DefaultContractResolver\n{\n    NamingStrategy = new CamelCaseNamingStrategy()\n};\nusing StreamReader r = new(stream);\nusing JsonReader readerData = new JsonTextReader(r);\nNewtonsoft.Json.JsonSerializer serializer = new()\n{\n    ContractResolver = contractResolver,\n};\nserializer.Converters.Add(new StringEnumConverter());\nreturn serializer.Deserialize<ExecutionModelDTO>(readerData);\n```\n\n![Image](https://github.com/user-attachments/assets/40fef041-d315-472d-ac2c-c84965f02054)\n\nCode for System.Text.Json:\n\n```csharp\nvar options = new JsonSerializerOptions\n{\n    PropertyNamingPolicy = JsonNamingPolicy.CamelCase,\n    UnmappedMemberHandling = System.Text.Json.Serialization.JsonUnmappedMemberHandling.Skip,\n    Converters =\n{\n    new JsonStringEnumMemberConverter(KebabCaseNamingPolicy),\n    }\n};\nreturn  await System.Text.Json.JsonSerializer.DeserializeAsync<ExecutionModelDTO>(stream, options)\n    .ConfigureAwait(false);\n```\n\n![Image](https://github.com/user-attachments/assets/da8b85a2-a72a-46ff-be85-d0501bdb983d)\n\nWe tried also using Deserialize with ReadToEnd but this causes ram to go up to 1.2gb usage and it is not released.\n\n### Configuration\n\nDotnet: 8.0.116\nBoth on Windows and Linux Container\n\n\n",
    "number": 115816,
    "reactions": {
      "hasNextPage": false,
      "nodes": [],
      "totalCount": 0,
      "endCursor": null
    },
    "updatedAt": "2025-07-23T07:35:56Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": "eiriktsarpalis",
          "body": "Your repro is missing information (including the data source and the DTO it's being deserialized to). That being said, this looks similar to https://github.com/dotnet/runtime/issues/96559, have you tried running this using .NET 9?",
          "createdAt": "2025-05-21T08:18:31Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-05-21T08:18:31Z",
          "id": "IC_kwDODI9FZc6srVNO"
        },
        {
          "author": "vasicvuk",
          "body": "@eiriktsarpalis It is the same with .NET 9 as well—identical behavior.\n\nHi, this is the DTOs used, but they are very simple. I anonymized models\n\n```\npublic class GenericDefinitionDto\n{\n    public string Field1 { get; set; }\n    public string Field2 { get; set; }\n    public string Field3 { get; set; }\n    public string Field4 { get; set; }\n    public string Field5 { get; set; }\n    public object Field6 { get; set; }\n    public List<string> Field7 { get; set; }\n    public List<string> Field8 { get; set; }\n}\n\npublic class GenericBenefitDto\n{\n    public string? Field1 { get; set; }\n    public string Field2 { get; set; }\n    public string Field3 { get; set; }\n    public string? Field4 { get; set; }\n    public string Field5 { get; set; }\n    public object Field6 { get; set; }\n    public object Field7 { get; set; }\n    public object Field8 { get; set; }\n    public decimal Field9 { get; set; }\n    public object Field10 { get; set; }\n    public bool Field11 { get; set; }\n    public decimal? Field12 { get; set; }\n    public decimal? Field13 { get; set; }\n}\n\npublic class GenericConditionDto\n{\n    public string Field1 { get; set; }\n    public string Field2 { get; set; }\n    public string Field3 { get; set; }\n    public object Field4 { get; set; }\n    public string Field5 { get; set; }\n    public object Field6 { get; set; }\n    public decimal? Field7 { get; set; }\n    public decimal? Field8 { get; set; }\n    public decimal? Field9 { get; set; }\n    public long Field10 { get; set; }\n}\n\npublic class GenericVariationDto\n{\n    public string Field1 { get; set; }\n    public string Field2 { get; set; }\n    public string Field3 { get; set; }\n    public string Field4 { get; set; }\n    public object Field5 { get; set; }\n    public object Field6 { get; set; }\n    public object Field7 { get; set; }\n    public decimal? Field8 { get; set; }\n    public bool Field9 { get; set; }\n    public decimal? Field10 { get; set; }\n    public decimal? Field11 { get; set; }\n    public string Field12 { get; set; }\n}\n\npublic class GenericEligibilityDto\n{\n    public string Field1 { get; set; }\n    public object Field2 { get; set; }\n    public IEnumerable<string> Field3 { get; set; }\n}\n\npublic class ExecutionModelDTO\n{\n    public string Field1 { get; set; }\n    public IEnumerable<GenericDefinitionDto> Field2 { get; set; } = [];\n    public IEnumerable<GenericConditionDto> Field3 { get; set; } = [];\n    public IEnumerable<GenericVariationDto> Field4 { get; set; } = [];\n    public IEnumerable<GenericBenefitDto> Field5 { get; set; } = [];\n    public IEnumerable<GenericEligibilityDto> Field6 { get; set; } = [];\n}\n```\n\nI do the deserialization of ExecutionModelDTO. All non-defined types are just simple enumerations.",
          "createdAt": "2025-05-21T09:08:59Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-05-22T17:15:14Z",
          "id": "IC_kwDODI9FZc6sr7Zl"
        },
        {
          "author": "eiriktsarpalis",
          "body": "And what data did you use to run both apps? We'd need a full repro of both to evaluate.",
          "createdAt": "2025-05-21T09:18:30Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-05-21T09:18:30Z",
          "id": "IC_kwDODI9FZc6ssCwl"
        },
        {
          "author": "vasicvuk",
          "body": "I would have to create such mock with anonymized data since I cannot share real data here, I will update the issue once i do it.",
          "createdAt": "2025-05-21T11:28:56Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-05-21T11:28:56Z",
          "id": "IC_kwDODI9FZc6std9A"
        },
        {
          "author": "vasicvuk",
          "body": "I've build a similar repro (not the same):\n\nNewtonsoft\n![Image](https://github.com/user-attachments/assets/d394cbf8-9da8-44d8-95b3-c79709fa4e89)\nSystem.Text.Json\n![Image](https://github.com/user-attachments/assets/736576be-a18e-41fc-b65e-a5d0a0b954df)\n\nit is larger definitel,y but seems to depend on the model. Code for test:\n\n```\n// See https://aka.ms/new-console-template for more information\nusing Newtonsoft.Json.Converters;\nusing Newtonsoft.Json.Serialization;\nusing Newtonsoft.Json;\nusing ConsoleApp2;\nusing System.Text.Json;\n\npublic class Program\n{\n\n    public static async Task Main(string[] args)\n    {\n        var zipFilePath = \"performance-testing-execution-model.zip\";\n        var jsonFileName = \"execution-model.json\";\n        using var zip = System.IO.Compression.ZipFile.OpenRead(zipFilePath);\n        var entry = zip.GetEntry(jsonFileName) ?? throw new FileNotFoundException($\"Could not find {jsonFileName} in {zipFilePath}\");\n        using var stream = entry.Open();\n        await ParseFromStreamSystemText(stream);\n\n        Console.ReadLine();\n    }\n    public static ExecutionModelDTO ParseFromStream(Stream stream)\n    {\n        DefaultContractResolver contractResolver = new()\n        {\n            NamingStrategy = new CamelCaseNamingStrategy()\n        };\n        using StreamReader r = new(stream);\n        using JsonReader readerData = new JsonTextReader(r);\n        Newtonsoft.Json.JsonSerializer serializer = new()\n        {\n            ContractResolver = contractResolver,\n        };\n        serializer.Converters.Add(new StringEnumConverter());\n        return serializer.Deserialize<ExecutionModelDTO>(readerData);\n\n    }\n    public static async Task<ExecutionModelDTO> ParseFromStreamSystemText(Stream stream)\n    {\n        var options = new JsonSerializerOptions\n        {\n            PropertyNamingPolicy = JsonNamingPolicy.CamelCase,\n            UnmappedMemberHandling = System.Text.Json.Serialization.JsonUnmappedMemberHandling.Skip,\n            Converters =\n            {\n             }\n        };\n        return await System.Text.Json.JsonSerializer.DeserializeAsync<ExecutionModelDTO>(stream, options)\n            .ConfigureAwait(false);\n\n    }\n}\n```\n\nThe ZIP file used attached:\nhttps://we.tl/t-bbPdKlcvpm\n",
          "createdAt": "2025-05-21T11:52:21Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-05-21T11:57:11Z",
                "user": "eiriktsarpalis"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOES_ajw=="
          },
          "updatedAt": "2025-05-21T11:52:21Z",
          "id": "IC_kwDODI9FZc6sttSx"
        },
        {
          "author": "vasicvuk",
          "body": ".NET 9\n\nNewtonsoft:\n\n![Image](https://github.com/user-attachments/assets/3eb1f165-9b72-4125-8b0c-0e74829d2e1a)\n\nSystem Text:\n\n![Image](https://github.com/user-attachments/assets/e841eb71-174e-4b33-b308-6843da32deda)",
          "createdAt": "2025-05-21T11:53:50Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-05-21T11:53:50Z",
          "id": "IC_kwDODI9FZc6stuRG"
        },
        {
          "author": "vasicvuk",
          "body": "Hi @eiriktsarpalis, someone should download the file, because it will be removed from WeTransfer.",
          "createdAt": "2025-05-22T17:14:37Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-05-22T17:14:37Z",
          "id": "IC_kwDODI9FZc6s-OTY"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Hi, I don't have time to take a deeper look at this right now. If the download link is due to expire, please consider hosting it elsewhere or otherwise share code used for generating the data. Any changes you could make to narrow down the reproduction to something as simple as possible would also help.\n\nThanks",
          "createdAt": "2025-05-23T09:13:20Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-05-23T09:13:20Z",
          "id": "IC_kwDODI9FZc6tFIdE"
        },
        {
          "author": "vasicvuk",
          "body": "Okey here is a generator in JS:\n\n```\n// generate.js\n\nconst fs = require('fs');\nconst path = require('path');\n\n// Helpers\nconst randomEnum = (arr) => arr[Math.floor(Math.random() * arr.length)];\nconst randomString = () => Math.random().toString(36).substring(2, 10);\nconst randomDecimal = () => parseFloat((Math.random() * 100).toFixed(2));\nconst randomInt = (max) => Math.floor(Math.random() * max);\n\n// Sample enum values (adjust as needed)\nconst attributeCategoryKinds = ['CategoryA','CategoryB','CategoryC'];\nconst conditionTypes         = ['ConditionX','ConditionY','ConditionZ'];\nconst booleanExpressions     = ['x > 5','y < z','a && b'];\nconst benefitTypes           = ['BenefitA','BenefitB','BenefitC'];\nconst adjustmentTypes        = ['Add','Subtract','Multiply'];\nconst priceTypes             = ['Fixed','Percentage'];\nconst planTypes              = ['PlanBasic','PlanPremium','PlanEnterprise'];\n\n// Output file\nconst outPath = path.join(__dirname, 'execution-model.json');\nconst ws = fs.createWriteStream(outPath, { encoding: 'utf8' });\n\n// Begin root object\nws.write('{');\nws.write(`\"field1\":\"${randomString()}\",`);\n\n// GenericDefinitionDto[] (1 000 items)\nws.write(`\"field2\":[`);\nfor (let i = 0; i < 1000; i++) {\n  const dto = {\n    field1: randomString(),\n    field2: randomString(),\n    field3: randomString(),\n    field4: randomString(),\n    field5: randomString(),\n    field6: randomEnum(attributeCategoryKinds),\n    field7: [ randomString(), randomString(), randomString() ],\n    field8: [ randomString(), randomString() ]\n  };\n  ws.write(JSON.stringify(dto) + (i < 999 ? ',' : ''));\n}\nws.write('],');\n\n// GenericConditionDto[] (1 000 items)\nws.write(`\"field3\":[`);\nfor (let i = 0; i < 1000; i++) {\n  const maybePriceType = Math.random() < 0.8 ? randomEnum(priceTypes) : null;\n  const dto = {\n    field1: randomString(),\n    field2: randomString(),\n    field3: randomString(),\n    field4: randomEnum(conditionTypes),\n    field5: randomString(),\n    field6: maybePriceType,\n    field7: Math.random() < 0.7 ? randomDecimal() : null,\n    field8: Math.random() < 0.7 ? randomDecimal() : null,\n    field9: Math.random() < 0.7 ? randomDecimal() : null,\n    field10: randomInt(1e6)\n  };\n  ws.write(JSON.stringify(dto) + (i < 999 ? ',' : ''));\n}\nws.write('],');\n\n// GenericVariationDto[] (1 000 items)\nws.write(`\"field4\":[`);\nfor (let i = 0; i < 1000; i++) {\n  const dto = {\n    field1: randomString(),\n    field2: randomString(),\n    field3: randomString(),\n    field4: randomString(),\n    field5: randomEnum(booleanExpressions),\n    field6: Math.random() < 0.5 ? randomEnum(adjustmentTypes) : null,\n    field7: Math.random() < 0.5 ? randomEnum(priceTypes) : null,\n    field8: Math.random() < 0.5 ? randomDecimal() : null,\n    field9: Math.random() < 0.5,\n    field10: Math.random() < 0.5 ? randomDecimal() : null,\n    field11: Math.random() < 0.5 ? randomDecimal() : null,\n    field12: randomString()\n  };\n  ws.write(JSON.stringify(dto) + (i < 999 ? ',' : ''));\n}\nws.write('],');\n\n// GenericBenefitDto[] (500 000 items)\nws.write(`\"field5\":[`);\nfor (let i = 0; i < 1000000; i++) {\n  const dto = {\n    field1: Math.random() < 0.3 ? randomString() : null,\n    field2: randomString(),\n    field3: randomString(),\n    field4: Math.random() < 0.3 ? randomString() : null,\n    field5: randomString(),\n    field6: randomEnum(booleanExpressions),\n    field7: randomEnum(benefitTypes),\n    field8: randomEnum(adjustmentTypes),\n    field9: randomDecimal(),\n    field10: randomEnum(priceTypes),\n    field11: Math.random() < 0.5,\n    field12: Math.random() < 0.5 ? randomDecimal() : null,\n    field13: Math.random() < 0.5 ? randomDecimal() : null\n  };\n  ws.write(JSON.stringify(dto) + (i < 999999 ? ',' : ''));\n}\nws.write('],');\n\n// GenericEligibilityDto[] (20 000 items)\nws.write(`\"field6\":[`);\nfor (let i = 0; i < 20000; i++) {\n  const dto = {\n    field1: randomString(),\n    field2: randomEnum(planTypes),\n    field3: [ randomString(), randomString(), randomString() ]\n  };\n  ws.write(JSON.stringify(dto) + (i < 19999 ? ',' : ''));\n}\nws.write(']');\n\n// End root object\nws.write('}');\nws.end(() => console.log(`Wrote ${outPath}`));\n```",
          "createdAt": "2025-05-24T12:03:37Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-05-24T12:03:37Z",
          "id": "IC_kwDODI9FZc6tQja8"
        },
        {
          "author": "PranavSenthilnathan",
          "body": "This is because of how deserialization into properties with `object` type is handled. Newtonsoft will infer the type for primitives while `System.Text.Json` will leave them as `JsonElement`. If you want the implicit conversion behavior, then you can implement a custom converter for it. See [these docs](https://learn.microsoft.com/en-us/dotnet/standard/serialization/system-text-json/converters-how-to#deserialize-inferred-types-to-object-properties) for more details. When I ran your sample with this custom converter both Newtonsoft and System.Text.Json had the same memory usage.",
          "createdAt": "2025-05-29T01:25:00Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-05-29T07:25:42Z",
                "user": "eiriktsarpalis"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-06-02T13:46:21Z",
                "user": "colejohnson66"
              }
            ],
            "totalCount": 2,
            "endCursor": "Y3Vyc29yOnYyOpHOEU5VVg=="
          },
          "updatedAt": "2025-05-29T01:25:00Z",
          "id": "IC_kwDODI9FZc6t7Ksz"
        },
        {
          "author": "vasicvuk",
          "body": "Hi @PranavSenthilnathan thanks for explaining, any idea why the memory is not clean up afterwards, we tried both Workstation and Server GC, seems like only calling GC.Collect() after some time does something but still not cleaning up everything. Will this converter also solve this?",
          "createdAt": "2025-06-07T16:23:30Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-06-07T16:23:30Z",
          "id": "IC_kwDODI9FZc6v_wkq"
        },
        {
          "author": "PranavSenthilnathan",
          "body": "> any idea why the memory is not clean up afterwards\n\nThe memory is being used, which is why it's not being cleaned up. For example, your `GenericDefinitionDto.Field6` is typed as `object` so a `JsonElement` will be stored for it. There's some overhead to `JsonElement` which is fine in most cases, but for small primitive values it adds up.\n\n> Will this converter also solve this?\n\nMy recommendation would be first to strongly type properties instead of using `object` where possible. For example, I don't know what your object model is, but based on the variable names in your JavaScript script, some of the `object` properties are actually nullable enums. So in the DTOs, you can use the C# enum type instead of `object`. [This page](https://learn.microsoft.com/en-us/dotnet/standard/serialization/system-text-json/customize-properties#enums-as-strings) describes how to handle serializing from their string name (specifically, using the [JsonStringEnumConverter](https://learn.microsoft.com/en-us/dotnet/api/system.text.json.serialization.jsonstringenumconverter?view=net-9.0)).\n\nIf, after doing the above, you still have remaining `object` properties, you can write a custom converter like the one I shared in my previous post. That one is just an example which you can customize for your scenario.\n\nThese suggestions should reduce your memory usage.",
          "createdAt": "2025-06-07T19:31:44Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-06-07T19:31:44Z",
          "id": "IC_kwDODI9FZc6wAf7R"
        },
        {
          "author": "vasicvuk",
          "body": "In my scenario i really don't use object at all, those are enums but for simplicity of the issue i change it to reproduce it quickly. I stil don't understand why there is so much difference in memory usage between Async and non async deserialization. Since for same scenario the non async one uses 500mb more which is not released that is why I asked.",
          "createdAt": "2025-06-07T19:36:18Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-06-07T19:36:18Z",
          "id": "IC_kwDODI9FZc6wAg9f"
        },
        {
          "author": "PranavSenthilnathan",
          "body": "The 2 scenarios you're comparing are (1) non-async deserialization using Newtonsoft with enum convertor and (2) async deserialization using System.Text.Json without an enum converter. There are too many variables changing to determine the cause. If you believe it's sync vs async, then try benchmarking only with System.Text.Json in both cases with the same converter strategy. I'm not aware of any reason the async System.Text.Json version would hold more resources that the sync System.Text.Json version.",
          "createdAt": "2025-06-07T19:58:31Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-06-07T19:59:30Z",
          "id": "IC_kwDODI9FZc6wAmKK"
        },
        {
          "author": "vasicvuk",
          "body": "Hi @PranavSenthilnathan sorry for misunderstanding, i am not comparing with Newtonsoft JSON, I am comparing both System Text with async and non async approach. The difference is that for non async the stream is loaded to string with ReadToEnd (withing using) and then deserialize to object",
          "createdAt": "2025-06-07T20:02:03Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-06-07T20:02:34Z",
          "id": "IC_kwDODI9FZc6wAoM_"
        }
      ],
      "totalCount": 15,
      "endCursor": "Y3Vyc29yOnYyOpHOsAKDPw=="
    },
    "url": "https://github.com/dotnet/runtime/issues/115816",
    "title": "Newtonsoft JSON uses less ram then System.Text.Json on same large JSON"
  },
  {
    "author": "rynowak",
    "labels": [
      "area-System.Text.Json"
    ],
    "createdAt": "2025-05-31T07:36:39Z",
    "body": "### Description\n\n`JsonSchemaExporer.GetJsonSchemaAsNode` has an [extra heuristic](https://github.com/dotnet/runtime/blob/main/src/libraries/System.Text.Json/src/System/Text/Json/Schema/JsonSchemaExporter.cs#L247) that will mark constructor parameters of classes as `required` in the schema it creates.\n\nThis means that it does not match the runtime behavior. Properties are marked as required that are not required at runtime. \n\nHowever, this heuristic does not apply to structs. Switching the same definition between `record class` and `record struct` results in different schemas but the same deserialization behavior. (See repro).\n\n\nThis is similar to the discussion here: https://github.com/dotnet/extensions/issues/6080 \n\nThe `JsonTypeInfo` is different for `record struct` and `record` because the `record struct` will have a parameterless constructor. As a result there are behavior differences when constructor parameter definitions/attributes result in different schemas for classes and structs.\n\n--\n\nThis heuristic is unhelpful for my scenario 😢  and in an ideal world I could turn it off entirely. \n\nI'm using the schemas to understand what the serializer will accept, and to diff changes to our code over time for breaking change detection. Any place where the schema generation is adding additional heuristics or assumptions that don't match the runtime behavior is another thing I have to work around. \n\n\nI discovered this as part of a change where someone flipped a class to a struct, and the properties became non-required in the schema.\n\n### Reproduction Steps\n\n```csharp\nusing System.Text.Json;\nusing System.Text.Json.Schema;\nusing System.Text.Json.Serialization.Metadata;\n\n\nvar opts = new JsonSerializerOptions(JsonSerializerDefaults.Web)\n{\n    PropertyNamingPolicy = JsonNamingPolicy.CamelCase,\n    WriteIndented = true,\n};\n\nvoid Test<T>(string json)\n{\n    JsonTypeInfo info = JsonSerializerOptions.Default.GetTypeInfo(typeof(T));\n    foreach (var property in info.Properties)\n    {\n        if (property.IsRequired)\n        {\n            Console.WriteLine($\"Property {property.Name} in {typeof(T).Name} is required.\");\n        }\n        else\n        {\n            Console.WriteLine($\"Property {property.Name} in {typeof(T).Name} is optional.\");\n        }\n    }\n\n    var schema = info.GetJsonSchemaAsNode();\n    Console.WriteLine($\"JSON Schema for {typeof(T).Name}:\\n{schema.ToJsonString(opts)}\");\n\n    try\n    {\n        var obj = JsonSerializer.Deserialize<T>(json);\n        Console.WriteLine($\"Deserialized {typeof(T).Name} successfully: {obj}\");\n    }\n    catch (JsonException ex)\n    {\n        Console.WriteLine($\"Failed to deserialize {typeof(T).Name}: {ex.Message}\");\n    }\n}\n\nvar json = \"{}\";\nTest<AClass>(json);\nTest<AStruct>(json);\n\npublic sealed record AClass(string Name, DateTimeOffset Birthday);\npublic readonly record struct AStruct(string Name, DateTimeOffset Birthday);\n```\n\n### Expected behavior\n\nI'd really like the schema output to match the runtime behavior. In this example that would be `AClass` having no `required` properties.\n\n### Actual behavior\n\n```txt\nProperty Name in AClass is optional.\nProperty Birthday in AClass is optional.\nJSON Schema for AClass:\n{\n  \"type\": [\n    \"object\",\n    \"null\"\n  ],\n  \"properties\": {\n    \"Name\": {\n      \"type\": \"string\"\n    },\n    \"Birthday\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    }\n  },\n  \"required\": [\n    \"Name\",\n    \"Birthday\"\n  ]\n}\nDeserialized AClass successfully: AClass { Name = , Birthday = 1/1/0001 12:00:00 AM +00:00 }\nProperty Name in AStruct is optional.\nProperty Birthday in AStruct is optional.\nJSON Schema for AStruct:\n{\n  \"type\": \"object\",\n  \"properties\": {\n    \"Name\": {\n      \"type\": \"string\"\n    },\n    \"Birthday\": {\n      \"type\": \"string\",\n      \"format\": \"date-time\"\n    }\n  }\n}\nDeserialized AStruct successfully: AStruct { Name = , Birthday = 1/1/0001 12:00:00 AM +00:00 }\n```\n\n### Regression?\n\n_No response_\n\n### Known Workarounds\n\nI could `TransformSchemaNode` and re-implement my own version of `required`. \n\n### Configuration\n\n```txt\n.NET SDK:\n Version:           9.0.300\n Commit:            15606fe0a8\n Workload version:  9.0.300-manifests.c678e91b\n MSBuild version:   17.14.5+edd3bbf37\n```\n\n### Other information\n\n_No response_",
    "number": 116172,
    "reactions": {
      "hasNextPage": false,
      "nodes": [],
      "totalCount": 0,
      "endCursor": null
    },
    "updatedAt": "2025-07-23T06:56:16Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": "rynowak",
          "body": "@eiriktsarpalis ",
          "createdAt": "2025-05-31T07:36:53Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-05-31T07:36:53Z",
          "id": "IC_kwDODI9FZc6uUd1D"
        },
        {
          "author": "dotnet-policy-service",
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. -->",
          "createdAt": "2025-05-31T07:37:23Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-05-31T07:37:23Z",
          "id": "IC_kwDODI9FZc6uUd8H"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Hey, as you might have already guessed the current behavior was chosen intentionally. We regard the default behavior of treating every constructor parameter as optional to be a bug, since the serializer effectively violates the contract of unmarshalled type by jamming `default` values in unspecified constructor parameters. This was addressed in .NET 9, however because of the huge potential for breaking changes the fix is actually opt-in via the [`RespectRequiredConstructorParameters` flag](https://devblogs.microsoft.com/dotnet/system-text-json-in-dotnet-9/#respecting-non-optional-constructor-parameters). We strongly recommend that every new application turns on this flag.\n\nWhen it comes to schema generation, this is something we had debated with the ASP.NET Core team when OpenAPI support was being worked on. The decision was made to invariably report required constructor parameters as required in the schema for two reasons:\n\n1. It produces a richer schema that avoids violating the contract of the unmarshalled class and\n2. Restricting the schema to a subset of what the serializer accepts is sound from a validation perspective: any valid JSON per the generated schema is guaranteed to be accepted by the serializer.\n\nWhile we _could_ recalibrate the schema to honor the setting of `RespectRequiredConstructorParameters`, I don't think this would be desirable from the perspective of the team owning the OpenAPI components. cc @captainsafia\n\nMy recommendation would be to always turn on `RespectRequiredConstructorParameters` (together with its sibling `RespectNullableAnnotations` flag), if possible. This should ensure a 1:1 correspondence between the C# type system, the STJ serializer, and the schema generator. If not, you might want to consider marking your constructor parameters as optional since the schema exporter will never surface these as required.",
          "createdAt": "2025-06-02T10:04:21Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-06-02T10:04:21Z",
          "id": "IC_kwDODI9FZc6uoT3d"
        },
        {
          "author": "rynowak",
          "body": "> Restricting the schema to a subset of what the serializer accepts is sound from a validation perspective: any valid JSON per the generated schema is guaranteed to be accepted by the serializer.\n\nThis part feels really misleading to me. Unless they added something schema based, ASP.NET Core validation doesn't work this way. So the schema will say that fields are required, and unless you set `RespectRequiredConstructorParameters`, nothing validates them.\n\n> My recommendation would be to always turn on RespectRequiredConstructorParameters (together with its sibling RespectNullableAnnotations flag), \n\nThis is actually how we got here 😢. Doing a risky migration like this across a large multi-team codebase requires tooling and the ability to understand deltas in behavior. I was hoping that the schemas could help provide visibility about changes in behavior - intended or not. ",
          "createdAt": "2025-06-03T19:30:59Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-06-03T19:30:59Z",
          "id": "IC_kwDODI9FZc6vDQ-A"
        },
        {
          "author": "eiriktsarpalis",
          "body": "> > Restricting the schema to a subset of what the serializer accepts is sound from a validation perspective: any valid JSON per the generated schema is guaranteed to be accepted by the serializer.\n> \n> This part feels really misleading to me. Unless they added something schema based, ASP.NET Core validation doesn't work this way. So the schema will say that fields are required, and unless you set `RespectRequiredConstructorParameters`, nothing validates them.\n\nEven if ASP.NET Core doesn't insert server side validation on the basis of the generated OpenAPI contract (@captainsafia or @mikekistler might be able to confirm), a restricted schema is still helpful from the perspective of generating accurate clients.",
          "createdAt": "2025-06-10T10:09:18Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-06-10T10:09:18Z",
          "id": "IC_kwDODI9FZc6wV1nc"
        },
        {
          "author": "mikekistler",
          "body": "I encountered this same problem some time back. I think the solution is to supply default values on any primary constructor parameters that you actually want to be optional, e.g.\n```\npublic sealed record AClass(string Name = default, DateTimeOffset Birthday = default);\n```\n\nI believe the schema for `AClass` when defined this way will be the same whether it is `record class` or `record struct`.\n\nBut I don't disagree that having an option to disable the heuristic would also be nice.",
          "createdAt": "2025-06-10T14:08:23Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-06-10T14:08:23Z",
          "id": "IC_kwDODI9FZc6wZQEO"
        },
        {
          "author": "jeffhandley",
          "body": "Penciling this into the .NET 11 milestone as I anticipate a theme of JSON/schema related enhancements during that release.",
          "createdAt": "2025-07-23T06:56:09Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-07-23T06:56:09Z",
          "id": "IC_kwDODI9FZc65I1bS"
        }
      ],
      "totalCount": 7,
      "endCursor": "Y3Vyc29yOnYyOpHOuSNW0g=="
    },
    "url": "https://github.com/dotnet/runtime/issues/116172",
    "title": "JsonSchemaExporter.GetJsonSchemaAsNode is inconsistent with required properties + constructors + record structs"
  },
  {
    "author": "agocke",
    "labels": [
      "area-System.Text.Json"
    ],
    "createdAt": "2025-06-03T21:30:30Z",
    "body": "While converting projects to be compatible with AOT, I've been converting JSON serialization to use the source generator. I've run into some challenges, that I want to record here:\n\n1. **Worse API**. This is pretty simple: the reflection API is different from the source generation API. The reflection API generally uses the `JsonSerializer.Serialize<T>(T value)`. The source generator API is `JsonSerializer.Serialize<T>(T value, JsonTypeInfo<T> info)`. If these APIs were very similar and easy to use, I don't think this would be much of a problem. In practice though, you also have to define a JsonSerializeContext with attributes for each type. This is a lot more work than the serialization API. It also makes changing over laborious, because you have to write a lot more code. If we could solve this with an interceptor, that might be helpful.\n2. **Unclear JsonSerializerContext organization**. It's unclear how to actually organize `JsonSerializerContext` types. Should you use one per type? One per area? What are the consequences or benefits from having one context? Multiple contexts? Put simply, converting to source generation is often a performance decision. Introducing code organization questions makes conversion projects complicated. Ideally, there would be one easy mechanical refactoring, and any further organizational questions would be an advanced scenario.\n3. **JsonSerializerOptions**. The docs aren't clear about how to deal with the `JsonSerializer.Serialize<T>(T value, JsonSerializerOptions options)` overload. There are ways to pass options to a context and pass the context to options. There are also attributes to put the options on the context itself. It's not clear what the best thing is in any given circumstance.\n4. **Internal converters**. When trying to serialize a type that is attributed with an internal `JsonConverter` attribute, it will produce a generation failure and a warning that's not resolvable, even if you specify your own custom converter on the member with the given type.",
    "number": 116280,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-06-04T10:26:58Z",
          "user": "DL444"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-06-04T13:37:47Z",
          "user": "reflectronic"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-06-04T13:49:19Z",
          "user": "austindrenski"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-06-04T13:50:42Z",
          "user": "NinoFloris"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-06-04T15:18:23Z",
          "user": "neon-sunset"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-06-04T15:37:32Z",
          "user": "rampaa"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-06-04T16:23:42Z",
          "user": "rabuckley"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-06-10T10:43:15Z",
          "user": "eiriktsarpalis"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-06-10T14:23:54Z",
          "user": "WeihanLi"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-06-14T22:50:02Z",
          "user": "rgroenewoudt"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-06-19T16:03:54Z",
          "user": "captainsafia"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-06-23T09:15:47Z",
          "user": "MitchRazga"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-06-23T12:31:08Z",
          "user": "Tan90909090"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-06-23T15:09:36Z",
          "user": "ReubenBond"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-06-25T03:43:07Z",
          "user": "RenderMichael"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-07-18T22:01:05Z",
          "user": "Athari"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-08-05T08:17:59Z",
          "user": "dartasen"
        }
      ],
      "totalCount": 17,
      "endCursor": "Y3Vyc29yOnYyOpHODJ4C_Q=="
    },
    "updatedAt": "2025-06-23T19:37:22Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": "dotnet-policy-service",
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. -->",
          "createdAt": "2025-06-03T21:31:14Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-06-03T21:31:14Z",
          "id": "IC_kwDODI9FZc6vEv43"
        },
        {
          "author": "DL444",
          "body": "On sharing `JsonSerializerContext` type: you risk naming conflicts for generated code that produce obscure runtime exceptions down the road. Using separated context types is better in this regard but adds significant organizational overhead.",
          "createdAt": "2025-06-04T14:42:38Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-06-04T14:43:48Z",
          "id": "IC_kwDODI9FZc6vQbh5"
        },
        {
          "author": "neon-sunset",
          "body": "Sharing a single context also prevents the types from being trimmed. If a library or an application has distinct \"features\" which are subject to trimming, json serializer contexts need to follow.",
          "createdAt": "2025-06-04T15:12:28Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-06-04T16:37:11Z",
                "user": "DL444"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-06-06T16:16:50Z",
                "user": "colejohnson66"
              }
            ],
            "totalCount": 2,
            "endCursor": "Y3Vyc29yOnYyOpHOEVtPuA=="
          },
          "updatedAt": "2025-06-04T15:12:28Z",
          "id": "IC_kwDODI9FZc6vQzCF"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Re: points 1) and 2) the `JsonSerializerContext` type is an artifact from when the team was still learning how to build source generators and had fewer tools at its disposal when doing so (e.g. interceptors). Ultimately it's a matter of us investing in better APIs that remove many of the current pain points source gen users have been experiencing. Naturally I think this would also involve obsoleting many APIs, including the `JsonSerializerContext` type in its entirety. \n\nRe: point 3) I presume you mean that the relationship between `JsonSerializerContext` and `JsonSerializerOptions` is unclear, and it's not about the [more general usability problems](https://github.com/dotnet/runtime/issues/74492) with this subset of APIs.\n\nRe: point 4) I don't think there is much that we could do, other than perhaps provide improved diagnostics. The source generator needs to be able to instantiate the converter type being specified.\n\nI agree with the general sentiment that using the STJ source generator today is painful, however bold changes and investment are necessary for this to be improved.\n\nTagging @AArnott who has done a lot of experimentation with the PolyType source generator.",
          "createdAt": "2025-06-10T10:46:43Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-06-10T10:46:43Z",
          "id": "IC_kwDODI9FZc6wWTN_"
        },
        {
          "author": "agocke",
          "body": "> Re: point 3) I presume you mean that the relationship between JsonSerializerContext and JsonSerializerOptions is unclear, and it's not about the https://github.com/dotnet/runtime/issues/74492 with this subset of APIs.\n\nRight, I'm basically stating: if I have a call to this method, it's not clear what to replace it with. There are a number of different options that somehow take JsonSerializerOptions as a parameter, but it's not clear which pattern to use.",
          "createdAt": "2025-06-10T23:00:02Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-06-12T11:06:15Z",
                "user": "eiriktsarpalis"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOEWWwfA=="
          },
          "updatedAt": "2025-06-10T23:00:02Z",
          "id": "IC_kwDODI9FZc6weca5"
        },
        {
          "author": "agocke",
          "body": "> Re: point 4) I don't think there is much that we could do, other than perhaps provide improved diagnostics. The source generator needs to be able to instantiate the converter type being specified.\n\nCan you elaborate on this? I would have assumed that providing there are two potential options:\n\n1. Ignore inaccessible converters\n2. When the converter would be overridden by an option that has higher priority, generate only using the overridden converter.",
          "createdAt": "2025-06-10T23:01:41Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-06-10T23:01:41Z",
          "id": "IC_kwDODI9FZc6wec7p"
        },
        {
          "author": "eiriktsarpalis",
          "body": "> > Re: point 4) I don't think there is much that we could do, other than perhaps provide improved diagnostics. The source generator needs to be able to instantiate the converter type being specified.\n> \n> Can you elaborate on this? I would have assumed that providing there are two potential options:\n> \n> 1. Ignore inaccessible converters\n> 2. When the converter would be overridden by an option that has higher priority, generate only using the overridden converter.\n\nThe problem is that reflection does honor inaccessible converters, so keeping the source generator compatible means we need to warn as opposed to silently falling back to the next available option.",
          "createdAt": "2025-06-12T11:14:54Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-06-12T11:14:54Z",
          "id": "IC_kwDODI9FZc6wzNJl"
        },
        {
          "author": "agocke",
          "body": "Sure, but the warning is in the generated code, so it’s not suppressible. If we want to warn, we should do so in the user source code. ",
          "createdAt": "2025-06-12T16:43:22Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-06-12T16:43:22Z",
          "id": "IC_kwDODI9FZc6w4Q2f"
        },
        {
          "author": "eiriktsarpalis",
          "body": "> Sure, but the warning is in the generated code, so it’s not suppressible. If we want to warn, we should do so in the user source code.\n\nYep, I agree we should try to improve the diagnostic there. But I think that would warrant creating a dedicated issue for better tracking.",
          "createdAt": "2025-06-12T16:46:27Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-06-12T16:46:27Z",
          "id": "IC_kwDODI9FZc6w4SyS"
        },
        {
          "author": "ReubenBond",
          "body": "Regarding 4. (Internal converters), perhaps generated code could side-step visibility rules. We had opened an issue on this in the past: https://github.com/dotnet/roslyn/issues/11149",
          "createdAt": "2025-06-23T15:14:00Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-06-23T15:14:10Z",
          "id": "IC_kwDODI9FZc6yoMi8"
        },
        {
          "author": "agocke",
          "body": "I think that solution has been discussed and rejected. Roslyn doesn’t have a strong distinction between generated and non-generated code, so this isn’t likely to be a significant modification of the earlier proposals.  We should focus on other areas. ",
          "createdAt": "2025-06-23T15:24:13Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-06-23T15:38:50Z",
                "user": "ReubenBond"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOEXmT1Q=="
          },
          "updatedAt": "2025-06-23T15:24:13Z",
          "id": "IC_kwDODI9FZc6yoVRT"
        },
        {
          "author": "reflectronic",
          "body": "The JSON source generator should be able to use UnsafeAccessor with the new `UnsafeAccessorTypeAttribute` to instantiate internal converter types. ",
          "createdAt": "2025-06-23T17:39:15Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-06-23T17:39:15Z",
          "id": "IC_kwDODI9FZc6yp5Tx"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Except we also need to support netstandard2.0, which doesn't have `UnsafeAccessor` support.",
          "createdAt": "2025-06-23T17:47:12Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-06-23T17:47:12Z",
          "id": "IC_kwDODI9FZc6yp-Lw"
        },
        {
          "author": "DamianEdwards",
          "body": ">Except we also need to support netstandard2.0, which doesn't have UnsafeAccessor support.\n\nCould be multi-targeted if this is deemed important though, no?",
          "createdAt": "2025-06-23T18:08:31Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-06-23T18:08:31Z",
          "id": "IC_kwDODI9FZc6yqNz5"
        },
        {
          "author": "reflectronic",
          "body": "I agree it seems fine to only support internal converters on net10.0+. Trimming and AOT, which are the premier use-cases for the JSON source generator, can't be enabled on netstandard2.0 targets. If your aim is to write trim- and AOT-safe code, you must have a netX target anyway.",
          "createdAt": "2025-06-23T18:40:05Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-06-23T18:40:05Z",
          "id": "IC_kwDODI9FZc6yq2KW"
        },
        {
          "author": "eiriktsarpalis",
          "body": "> > Except we also need to support netstandard2.0, which doesn't have UnsafeAccessor support.\n> \n> Could be multi-targeted if this is deemed important though, no?\n\nWe'd need to use reflection in the case of ns2.0 to ensure consistency across targets. This is something we've been explicitly avoiding so far.",
          "createdAt": "2025-06-23T18:51:34Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-06-23T18:51:34Z",
          "id": "IC_kwDODI9FZc6yq_Ag"
        },
        {
          "author": "DamianEdwards",
          "body": ">We'd need to use reflection in the case of ns2.0 to ensure consistency across targets. This is something we've been explicitly avoiding so far.\n\nAre we against having features of S.T.J that only light-up in specific TFMs or in specific scenarios like native AOT?",
          "createdAt": "2025-06-23T18:53:33Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-06-23T18:53:33Z",
          "id": "IC_kwDODI9FZc6yrAKX"
        },
        {
          "author": "eiriktsarpalis",
          "body": "I think we would be, if it results in silently divergent behaviors. Most libraries consuming STJ use multi-targeting.",
          "createdAt": "2025-06-23T19:05:55Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-06-23T19:05:55Z",
          "id": "IC_kwDODI9FZc6yrHyu"
        },
        {
          "author": "agocke",
          "body": "I don’t see why falling back to reflection for ns2.0 is a problem. \n\nAlthough abstractly I think accessing internals is undesirable and I’d rather keep the client src gen design where you can’t depend on internals. I think we should just fix the warning behavior. ",
          "createdAt": "2025-06-23T19:37:22Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-06-23T19:38:26Z",
                "user": "rabuckley"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-06-23T20:47:54Z",
                "user": "eiriktsarpalis"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-07-02T09:48:23Z",
                "user": "WeihanLi"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-07-18T22:09:47Z",
                "user": "Athari"
              }
            ],
            "totalCount": 4,
            "endCursor": "Y3Vyc29yOnYyOpHOEbJ_XQ=="
          },
          "updatedAt": "2025-06-23T19:37:22Z",
          "id": "IC_kwDODI9FZc6yrags"
        }
      ],
      "totalCount": 19,
      "endCursor": "Y3Vyc29yOnYyOpHOsq2oLA=="
    },
    "url": "https://github.com/dotnet/runtime/issues/116280",
    "title": "Rough edges in JSON source generation"
  },
  {
    "author": "johnwc",
    "labels": [
      "area-System.Text.Json"
    ],
    "createdAt": "2025-06-16T08:02:23Z",
    "body": "### Description\n\nTrying to figure out why my code keeps failing, and it when looking further into the generated code, there seems to be no converter being added to the `Default` context property. It has a count of 0 no matter how I try to use it.\n\n```c#\n[JsonSourceGenerationOptions(\n    GenerationMode = JsonSourceGenerationMode.Default,\n    DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull,\n    Converters = [\n        typeof(AccountId.AccountIdSystemTextJsonConverter)\n        ])]\n[JsonSerializable(typeof(AccountMembership))]\n[JsonSerializable(typeof(AccountId))]\npublic partial class SourceGenerationContext : JsonSerializerContext\n{\n}\n```\n\n### Reproduction Steps\n\nCreate SourceGenerationContext using the shared code above.\nView that the Default.Optons.Converters is empty.\n\n### Expected behavior\n\nThe list of converters given in the JsonSourceGenerationOptions attribute be set within the Default options. for the context\n\n### Actual behavior\n\nNo converters added.\n\n### Regression?\n\n_No response_\n\n### Known Workarounds\n\n_No response_\n\n### Configuration\n\n.Net 9.0.6\n\n### Other information\n\n_No response_",
    "number": 116684,
    "reactions": {
      "hasNextPage": false,
      "nodes": [],
      "totalCount": 0,
      "endCursor": null
    },
    "updatedAt": "2025-07-23T06:30:49Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": "dotnet-policy-service",
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. -->",
          "createdAt": "2025-06-16T08:03:06Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-06-16T08:03:06Z",
          "id": "IC_kwDODI9FZc6xWn7Z"
        },
        {
          "author": "elgonzo",
          "body": "Please check your `AccountId.AccountIdSystemTextJsonConverter` converter declaration, particularly what base type it derives from.\n\nThe only situation i know of where the specified converter type isn't taken into the options is when that converter type doesn't derive from `System.Text.Json.Serialization.JsonConverter<T>` or `System.Text.Json.Serialization.JsonConverterFactory`. <strike>(That particular situation would still count as a bug, i guess. The STJ source generator should emit a warning or error and not silently ignore non-JsonConverter types specified in the JsonSourceGenerationOptions.Attribute.Converters parameter.)</strike> _EDIT_: The STJ source generator does emit a warning if a non-JsonConverter type is being specified in JsonSourceGenerationOptionsAttribute.Converters.",
          "createdAt": "2025-06-16T08:52:47Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-06-16T11:33:00Z",
          "id": "IC_kwDODI9FZc6xXN3D"
        },
        {
          "author": "johnwc",
          "body": "It does inherit from System.Text.Json.Serialization.JsonConverter<T>\n\n```c#\npublic class AccountIdSystemTextJsonConverter : global::System.Text.Json.Serialization.JsonConverter<AccountId>\n{\n...\n}\n```",
          "createdAt": "2025-06-16T10:50:58Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-06-16T10:50:58Z",
          "id": "IC_kwDODI9FZc6xY03V"
        },
        {
          "author": "elgonzo",
          "body": "I cannot reproduce. Neither with STJ 9.0.4 nor with the newest STJ 10.0.0-preview.5.25277.114 pre-release versions.\n\nThe presence of the `global::` namespace prefix there in the declaration makes me think that this declaration is generated by some other source generator. If that is true, it might be that the STJ source generator cannot see the output of that other source generator and hence being unable to verify AccountIdSystemTextJsonConverter being really a JsonConverter\\<T\\> type (see also here: https://github.com/dotnet/roslyn/discussions/48358).",
          "createdAt": "2025-06-16T11:09:00Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-06-16T11:14:58Z",
          "id": "IC_kwDODI9FZc6xZBG8"
        },
        {
          "author": "johnwc",
          "body": "It's a public class, nothing is being hidden. It is being generated using Vogen nuget package.",
          "createdAt": "2025-06-16T11:30:27Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-06-16T11:30:27Z",
          "id": "IC_kwDODI9FZc6xZPOV"
        },
        {
          "author": "elgonzo",
          "body": "Vogen a source generator, right? As i said in my previous comment: \"_it might be that the STJ source generator cannot see the output of that other source generator and hence being unable to verify AccountIdSystemTextJsonConverter being really a JsonConverter<T> type (see also here: https://github.com/dotnet/roslyn/discussions/48358)._\".\n\nIt's not about types being public or not. It's about the inability of one source generator seeing the output of another source generator. It's a roslyn limitation. It has to be fixed in roslyn; nothing that the STJ source generator can fix.\n\nUntil this roslyn limitation has been solved, you might be able to workaround this by creating a partial class stub including it inheriting from `JsonConverter<T>` in a real .cs file in the project that the STJ source generator can see and process:\n```C#\npublic partial class AccountIdSystemTextJsonConverter : JsonConverter<AccountId>\n{ }\n```\n(whether you need some additional attribute annotation for the partial declaration or not and for anything further, i don't know as i am not experienced with Vogen in particular. Please consult the Vogen documentation about such.)",
          "createdAt": "2025-06-16T11:40:43Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-06-16T11:41:40Z",
          "id": "IC_kwDODI9FZc6xZWGC"
        },
        {
          "author": "elgonzo",
          "body": "If for whatever reason Vogen does not allow you to create partial class stubs for the JsonConverters it generates, or you simply don't like creating such stubs, there is another alternative workaround.\n\nInstead of using the `SourceGenerationContext.Default` and the `[JsonSourceGenerationOptions]` for the (de)serialization settings, you can create a `SourceGenerationContext` instance with a `JsonSerializerOptions` instance (thus not requiring the STJ source generator to see/inspect the JsonConverter types) in a similar manner to this:\n\n```C#\n[JsonSourceGenerationOptions(GenerationMode = JsonSourceGenerationMode.Default)]\n[JsonSerializable(typeof(AccountMembership))]\n[JsonSerializable(typeof(AccountId))]\npublic partial class SourceGenerationContext : JsonSerializerContext\n{\n    //\n    // Use this instead of the Default property\n    //\n    public static SourceGenerationContext UseThis {get; } = CreateMyContextWithOptions();\n\n    private static SourceGenerationContext CreateMyContextWithOptions()\n    {\n        var opts = new JsonSerializerOptions\n        {\n            DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull\n        };\n\n        opts.Converters.Add(new AccountId.AccountIdSystemTextJsonConverter());\n        return new SourceGenerationContext(opts);\n    }\n}\n```",
          "createdAt": "2025-06-16T11:55:56Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-06-16T12:11:22Z",
          "id": "IC_kwDODI9FZc6xZoF2"
        },
        {
          "author": "huoyaoyuan",
          "body": "> It is being generated using Vogen nuget package.\n\nDo you mean the converter is generated? Source generators can't see each other. Is there a partial declaration in your code?",
          "createdAt": "2025-06-16T12:14:04Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-06-16T12:14:04Z",
          "id": "IC_kwDODI9FZc6xaI_T"
        },
        {
          "author": "elgonzo",
          "body": "By the way, are the data models you want to de/serialize also entirely created by Vogen source-generator without a (partial) declaration in your project code? If so, the STJ source generator would also not be able to see the shape of these model types either and not be able to synthesize appropriate de/serialization code. If that's the case, you might need to create partial declarations in \"real\" .cs files in your project code (containing the (partial) member declarations of those members that should participate in de/serialization); or it might perhaps just be easier to use the default reflection-based serializer instead.\n\nIf all you are going to de/serialize are Vogen-generated data models which are entirely and completely handled by Vogen-generated JsonConverters, you might not really benefit from the STJ source generator and could use the default reflection-based serializer, because in that situation the de/serialization would be entirely handled by the Vogen-generated JsonConverters. Heck, since Vogen is apparently able to generate JsonConverters, it is not too far fetched to believe that Vogen might also be able to offer an already \"pre-generated\" (and properly configured) JsonSerializerContext-based serializer. But please consult the Vogen documentation about that and don't mistake my assumption here as fact.",
          "createdAt": "2025-06-16T12:25:21Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-06-16T17:21:55Z",
                "user": "eiriktsarpalis"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOEWyCBQ=="
          },
          "updatedAt": "2025-06-16T12:44:08Z",
          "id": "IC_kwDODI9FZc6xaSo0"
        },
        {
          "author": "johnwc",
          "body": "I see, so this is the chicken before the egg type of scenario. Where the source generators are not aware of the source created by other generators at the type of generation? Even if I was able to create a partial class in my own code, I do not think the source generator would be able to see that it is inherited from JsonConverter, as the inheritance is added via the source generator.\n\nHow about doing something like this then, where you add a JsonSourceGenerationOptionsConverter attribute to the JsonSerializerContext. Then the source generator looks for those attributes added to the class and use them to populate the Converters.\n\n```c#\n[AttributeUsage(AttributeTargets.Class, AllowMultiple = true, Inherited = false)]\npublic class JsonSourceGenerationOptionsConverterAttribute<T> : System.Attribute where T : JsonConverter\n{\n    /// <summary>\n    /// Constructs a new <see cref=\"JsonSourceGenearationConverterOptionsAttribute{T}\"/> instance.\n    /// </summary>\n    public JsonSourceGenerationOptionsConverterAttribute() { }\n\n    /// <summary>\n    /// Gets the type of the converter.\n    /// </summary>\n    public Type ConverterType => typeof(T);\n}\n\n[JsonSourceGenerationOptions(\n    GenerationMode = JsonSourceGenerationMode.Default,\n    DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull,\n    UnknownTypeHandling = JsonUnknownTypeHandling.JsonNode)]\n[JsonSerializable(typeof(AccountMembership))]\n[JsonSerializable(typeof(AccountId))]\n[JsonSourceGenerationOptionsConverter<AccountId.AccountIdSystemTextJsonConverter>()]\npublic partial class SourceGenerationContext : JsonSerializerContext\n{\n}\n```\n",
          "createdAt": "2025-06-16T18:06:56Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-06-16T18:06:56Z",
          "id": "IC_kwDODI9FZc6xedbY"
        },
        {
          "author": "johnwc",
          "body": "@huoyaoyuan @elgonzo any thoughts?",
          "createdAt": "2025-06-19T15:50:04Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-06-19T15:50:04Z",
          "id": "IC_kwDODI9FZc6yIcSF"
        },
        {
          "author": "huoyaoyuan",
          "body": "Creating a dedicated attribute for this certain intersection of scenario is not extensible.\n\n> Even if I was able to create a partial class in my own code, I do not think the source generator would be able to see that it is inherited from JsonConverter, as the inheritance is added via the source generator.\n\nYou can specify the inheritance in your code:\n\n```csharp\npartial class MyConverter : JsonConverter<MyType>;\n```",
          "createdAt": "2025-07-19T13:36:49Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-07-19T13:36:49Z",
          "id": "IC_kwDODI9FZc64UZw8"
        },
        {
          "author": "johnwc",
          "body": "> Creating a dedicated attribute for this certain intersection of scenario is not extensible.\n> \n> > Even if I was able to create a partial class in my own code, I do not think the source generator would be able to see that it is inherited from JsonConverter, as the inheritance is added via the source generator.\n> \n> You can specify the inheritance in your code:\n> \n> partial class MyConverter : JsonConverter<MyType>;\n\n@huoyaoyuan We never mentioned anything about a converter not having an inheritance, as I showed you the code that it does. Also, if you notice in the code I shared, it is not marked as partial from the other code generator, so I cannot do your hack and add it to my project's code. Your code generator is ignoring the types I am putting into the `Converters` options. The reason for this is that the types used in this option is also coming from a code generator. My proposal allows all of this to work by placing the `Converter` option as an attribute instead, allowing the attribute to have generic type with constraints. This allows the convert to not have to attempt to check an array of `Types`. What exactly is not extensible?",
          "createdAt": "2025-07-19T20:37:03Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-07-19T20:47:44Z",
          "id": "IC_kwDODI9FZc64VLaJ"
        }
      ],
      "totalCount": 13,
      "endCursor": "Y3Vyc29yOnYyOpHOuFS2iQ=="
    },
    "url": "https://github.com/dotnet/runtime/issues/116684",
    "title": "JsonSerializerContext source generator ignores Converters"
  },
  {
    "author": "DvdKhl",
    "labels": [
      "enhancement",
      "area-System.Text.Json"
    ],
    "createdAt": "2025-06-17T14:34:52Z",
    "body": "### Is there an existing issue for this?\n\n- [x] I have searched the existing issues\n\n### Describe the bug\n\nIf the base class is empty no polymorphism information is included in the document.\n\n### Expected Behavior\n\nInclude polymorphism information even if the base class is empty.\n\n### Steps To Reproduce\n\nMinimal Repo:\n\n```csharp\nusing System.Text.Json.Serialization;\n\nvar builder = WebApplication.CreateBuilder(args);\nbuilder.Services.AddOpenApi();\n\nvar app = builder.Build();\napp.MapOpenApi();\n\napp.MapGet(\"/Pet\", () => Enumerable.Empty<Pet>).WithName(\"Pet\").Produces<Pet[]>();\napp.MapGet(\"/Shape\", () => Enumerable.Empty<Shape>).WithName(\"Shape\").Produces<Shape[]>();\n\napp.Run();\n\n[JsonPolymorphic]\n[JsonDerivedType(typeof(Cat), \"cat\")]\n[JsonDerivedType(typeof(Dog), \"dog\")]\npublic record Pet(string Name);\npublic record Dog(string Name, string? Breed) : Pet(Name);\npublic record Cat(string Name, int? Lives) : Pet(Name);\n\n[JsonPolymorphic]\n[JsonDerivedType(typeof(Rectangle), \"Rectangle\")]\n[JsonDerivedType(typeof(Circle), \"Circle\")]\npublic record Shape();\npublic record Rectangle(int Width, int Height) : Shape();\npublic record Circle(int Radius) : Shape();\n```\n\nGenerated document:\n```json\n{\n  \"openapi\": \"3.0.1\",\n  \"info\": {\n    \"title\": \"OpenApiPolyEmptyBase | v1\",\n    \"version\": \"1.0.0\"\n  },\n  \"servers\": [\n    {\n      \"url\": \"http://localhost:5129/\"\n    }\n  ],\n  \"paths\": {\n    \"/Pet\": {\n      \"get\": {\n        \"tags\": [\n          \"OpenApiPolyEmptyBase\"\n        ],\n        \"operationId\": \"Pet\",\n        \"responses\": {\n          \"200\": {\n            \"description\": \"OK\",\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"type\": \"array\",\n                  \"items\": {\n                    \"$ref\": \"#/components/schemas/Pet\"\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    },\n    \"/Shape\": {\n      \"get\": {\n        \"tags\": [\n          \"OpenApiPolyEmptyBase\"\n        ],\n        \"operationId\": \"Shape\",\n        \"responses\": {\n          \"200\": {\n            \"description\": \"OK\",\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"type\": \"array\",\n                  \"items\": {\n                    \"$ref\": \"#/components/schemas/Shape\"\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  },\n  \"components\": {\n    \"schemas\": {\n      \"Pet\": {\n        \"type\": \"object\",\n        \"anyOf\": [\n          {\n            \"$ref\": \"#/components/schemas/PetCat\"\n          },\n          {\n            \"$ref\": \"#/components/schemas/PetDog\"\n          },\n          {\n            \"$ref\": \"#/components/schemas/PetBase\"\n          }\n        ]\n      },\n      \"PetBase\": {\n        \"required\": [\n          \"name\"\n        ],\n        \"properties\": {\n          \"name\": {\n            \"type\": \"string\"\n          }\n        }\n      },\n      \"PetCat\": {\n        \"required\": [\n          \"$type\",\n          \"lives\",\n          \"name\"\n        ],\n        \"properties\": {\n          \"$type\": {\n            \"enum\": [\n              \"cat\"\n            ],\n            \"type\": \"string\"\n          },\n          \"lives\": {\n            \"type\": \"integer\",\n            \"format\": \"int32\",\n            \"nullable\": true\n          },\n          \"name\": {\n            \"type\": \"string\"\n          }\n        }\n      },\n      \"PetDog\": {\n        \"required\": [\n          \"$type\",\n          \"breed\",\n          \"name\"\n        ],\n        \"properties\": {\n          \"$type\": {\n            \"enum\": [\n              \"dog\"\n            ],\n            \"type\": \"string\"\n          },\n          \"breed\": {\n            \"type\": \"string\",\n            \"nullable\": true\n          },\n          \"name\": {\n            \"type\": \"string\"\n          }\n        }\n      },\n      \"Shape\": {\n        \"type\": \"object\"\n      }\n    }\n  },\n  \"tags\": [\n    {\n      \"name\": \"OpenApiPolyEmptyBase\"\n    }\n  ]\n}\n```\n\n### Exceptions (if any)\n\n_No response_\n\n### .NET Version\n\n9.0.300\n\n### Anything else?\n\nMicrosoft.AspNetCore.OpenApi: 9.0.5",
    "number": 117824,
    "reactions": {
      "hasNextPage": false,
      "nodes": [],
      "totalCount": 0,
      "endCursor": null
    },
    "updatedAt": "2025-07-21T08:31:38Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": "mikekistler",
          "body": "This looks like an issue in the STJ schema generation logic.\n\n```csharp\nvar schema = options.GetJsonSchemaAsNode(typeof(Shape));\n\nConsole.WriteLine(schema);\n\n[JsonPolymorphic]\n[JsonDerivedType(typeof(Rectangle), \"Rectangle\")]\n[JsonDerivedType(typeof(Circle), \"Circle\")]\npublic record Shape();\npublic record Rectangle(int Width, int Height) : Shape();\npublic record Circle(int Radius) : Shape();\n```\n\nproduces\n\n```json\n{\n  \"type\": [\n    \"object\",\n    \"null\"\n  ]\n}\n```\n\nTransferring to runtime to investigate.",
          "createdAt": "2025-07-18T17:00:30Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-07-18T17:00:30Z",
          "id": "IC_kwDODI9FZc64LzNq"
        },
        {
          "author": "dotnet-policy-service",
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. -->",
          "createdAt": "2025-07-20T15:50:56Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-07-20T15:50:56Z",
          "id": "IC_kwDODI9FZc64dBG2"
        },
        {
          "author": "eiriktsarpalis",
          "body": "This appears to be caused by a schema simplification transformation that is applied overly aggressively in this case. Because the base type is trivial, it admits _any_ JSON object so the generated schema correspondingly reflects that. I think we could apply tweaks to the transform so that at the very least type discriminator metadata isn't being lost.\n\nA simple workaround is to mark the base class as abstract:\n```C#\n[JsonPolymorphic]\n[JsonDerivedType(typeof(Rectangle), \"Rectangle\")]\n[JsonDerivedType(typeof(Circle), \"Circle\")]\npublic abstract record Shape();\npublic record Rectangle(int Width, int Height) : Shape();\npublic record Circle(int Radius) : Shape();\n```\nYielding\n```json\n{\n  \"type\": [\n    \"object\",\n    \"null\"\n  ],\n  \"required\": [\n    \"$type\"\n  ],\n  \"anyOf\": [\n    {\n      \"properties\": {\n        \"$type\": {\n          \"const\": \"Rectangle\"\n        },\n        \"Width\": {\n          \"type\": \"integer\"\n        },\n        \"Height\": {\n          \"type\": \"integer\"\n        }\n      },\n      \"required\": [\n        \"Width\",\n        \"Height\"\n      ]\n    },\n    {\n      \"properties\": {\n        \"$type\": {\n          \"const\": \"Circle\"\n        },\n        \"Radius\": {\n          \"type\": \"integer\"\n        }\n      },\n      \"required\": [\n        \"Radius\"\n      ]\n    }\n  ]\n}\n```",
          "createdAt": "2025-07-21T08:31:04Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-07-21T08:31:04Z",
          "id": "IC_kwDODI9FZc64hPqz"
        }
      ],
      "totalCount": 3,
      "endCursor": "Y3Vyc29yOnYyOpHOuIT6sw=="
    },
    "url": "https://github.com/dotnet/runtime/issues/117824",
    "title": "OpenApi - Polymorphism information missing when the base class is empty"
  },
  {
    "author": "agocke",
    "labels": [
      "enhancement",
      "area-System.Text.Json",
      "source-generator",
      "partner-impact"
    ],
    "createdAt": "2025-06-23T15:26:51Z",
    "body": "Internal converters. When trying to serialize a type that is attributed with an internal JsonConverter attribute, it will produce a generation failure and a warning that's not resolvable, even if you specify your own custom converter on the member with the given type. Also, the warning is in the generated code, so it’s not suppressible. If we want to warn, we should do so in the user source code.",
    "number": 116921,
    "reactions": {
      "hasNextPage": false,
      "nodes": [],
      "totalCount": 0,
      "endCursor": null
    },
    "updatedAt": "2025-06-23T18:40:44Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": "dotnet-policy-service",
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. -->",
          "createdAt": "2025-06-23T15:35:25Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-06-23T15:35:25Z",
          "id": "IC_kwDODI9FZc6yofAb"
        },
        {
          "author": "agocke",
          "body": "Split out from https://github.com/dotnet/runtime/issues/116280",
          "createdAt": "2025-06-23T18:39:55Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-06-23T18:40:10Z",
          "id": "IC_kwDODI9FZc6yq1-7"
        }
      ],
      "totalCount": 2,
      "endCursor": "Y3Vyc29yOnYyOpHOsqtfuw=="
    },
    "url": "https://github.com/dotnet/runtime/issues/116921",
    "title": "JSON source gen produces unactionable warnings with internal converters"
  },
  {
    "author": "marekott",
    "labels": [
      "enhancement",
      "api-suggestion",
      "area-System.Text.Json"
    ],
    "createdAt": "2025-06-26T09:58:18Z",
    "body": "### Background and motivation\n\nWhen trying to migrate from Newtonsoft.Json.Schema to pure JsonSchemaExporter (without any third party libraries) I have noticed that at least two features are missing.\n1. Respecting data annotations (for example including in schema min and max of given type)\n2. Possibility to select schema draft version \n\nWould you guys consider adding them so the transition would be possible without taking dependency on external libraries? \n\nNewtonsoft.Json.Schema: \n```json\n{\n  \"$schema\" : \"http://json-schema.org/draft-07/schema#\",\n  \"definitions\" : {\n    \"Nested<UInt16>\" : {\n      \"type\" : \"object\",\n      \"properties\" : {\n        \"required\" : {\n          \"type\" : \"integer\",\n          \"minimum\" : 0.0,\n          \"maximum\" : 65535.0\n        },\n        \"nullable\" : {\n          \"type\" : [ \"integer\", \"null\" ],\n          \"minimum\" : 0.0,\n          \"maximum\" : 65535.0\n        }\n      },\n      \"required\" : [ \"required\" ]\n    }\n  },\n  \"type\" : \"object\",\n  \"properties\" : {\n    \"required\" : {\n      \"type\" : \"integer\",\n      \"minimum\" : 0.0,\n      \"maximum\" : 65535.0\n    },\n    \"nullable\" : {\n      \"type\" : [ \"integer\", \"null\" ],\n      \"minimum\" : 0.0,\n      \"maximum\" : 65535.0\n    },\n    \"nested\" : {\n      \"$ref\" : \"#/definitions/Nested<UInt16>\"\n    }\n  },\n  \"required\" : [ \"required\", \"nested\" ]\n}\n```\n\n\nSTJ:\n```json\n{\n  \"type\" : [ \"object\", \"null\" ],\n  \"properties\" : {\n    \"required\" : {\n      \"type\" : \"integer\"\n    },\n    \"nullable\" : {\n      \"type\" : [ \"integer\", \"null\" ]\n    },\n    \"nested\" : {\n      \"type\" : \"object\",\n      \"properties\" : {\n        \"required\" : {\n          \"type\" : \"integer\"\n        },\n        \"nullable\" : {\n          \"type\" : [ \"integer\", \"null\" ]\n        }\n      },\n      \"required\" : [ \"required\", \"nullable\" ]\n    }\n  },\n  \"required\" : [ \"required\", \"nullable\", \"nested\" ]\n}\n```\n\n### API Proposal\n\n```csharp\nJsonSerializerOptions options = new(JsonSerializerOptions.Default)\n{\n    RespectDataAnnotations= true,\n    Version = \"draft-07\"\n};\n```\n\n\n### API Usage\n\n```csharp\nJsonSerializerOptions options = new(JsonSerializerOptions.Default)\n{\n    PropertyNamingPolicy = JsonNamingPolicy.KebabCaseUpper,\n    NumberHandling = JsonNumberHandling.WriteAsString,\n    UnmappedMemberHandling = JsonUnmappedMemberHandling.Disallow,\n    RespectDataAnnotations= true,\n    Version = \"draft-07\"\n};\n\nJsonNode schema = options.GetJsonSchemaAsNode(typeof(MyPoco));\nConsole.WriteLine(schema.ToString());\n```\n\n\n### Alternative Designs\n\n_No response_\n\n### Risks\n\n_No response_",
    "number": 117043,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-06-27T09:05:20Z",
          "user": "KrzysztofBranicki"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-06-27T09:11:06Z",
          "user": "plachor"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-08-05T12:18:47Z",
          "user": "saithis"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-08-14T02:44:33Z",
          "user": "naratteu"
        }
      ],
      "totalCount": 4,
      "endCursor": "Y3Vyc29yOnYyOpHODLJyXw=="
    },
    "updatedAt": "2025-06-26T13:27:49Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": "dotnet-policy-service",
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. -->",
          "createdAt": "2025-06-26T11:49:24Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-06-26T11:49:24Z",
          "id": "IC_kwDODI9FZc6zTaLX"
        },
        {
          "author": "eiriktsarpalis",
          "body": "For data annotations support specifically, it is something we have been intentionally avoiding so far because we didn't want System.Text.Json to take a dependency on System.ComponentModel.DataAnnotations. Components depending on `JsonSchemaExporter` such as ASP.NET OpenAPI and Microsoft.Extensions.AI typically incorporate support for data annotations by implementing custom transformer delegates.\n\nIt does make me wonder if we could make the `JsonSchemaExporter` read those attributes without depending on them using reflection. We already do this in STJ for `System.Collections.Immutable` and `FSharp.Core`. @stephentoub @captainsafia thoughts?",
          "createdAt": "2025-06-26T12:05:13Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-06-26T12:05:13Z",
          "id": "IC_kwDODI9FZc6zTkqD"
        },
        {
          "author": "stephentoub",
          "body": "> read those attributes without depending on them using reflection\n\nHow, and specifically how for the ones where it's not just the presence of the attribute that matters but specific properties on it? ",
          "createdAt": "2025-06-26T12:11:25Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-06-26T12:11:25Z",
          "id": "IC_kwDODI9FZc6zTo_T"
        },
        {
          "author": "eiriktsarpalis",
          "body": "The contract model already exposes `ICustomAttributeProvider` instances that report attributes for types and properties in a trim-safe manner. Getting to actual properties within attributes is an open question from a trimmability perspective, but maybe there are tricks we can use to get it to work.",
          "createdAt": "2025-06-26T12:18:44Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-06-26T12:18:44Z",
          "id": "IC_kwDODI9FZc6zTuAR"
        },
        {
          "author": "eiriktsarpalis",
          "body": "For example, we can use `DynamicDependencyAttribute` to instruct the linker to not trim specific [members identified by string](https://grep.app/search?case=true&regexp=true&q=%5C%5BDynamicDependency%5C%28%22.%2B%22%2C+%22.%2B%22%2C+%22.%2B%22%5C%29%5C%5D).",
          "createdAt": "2025-06-26T12:30:07Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-06-26T12:30:07Z",
          "id": "IC_kwDODI9FZc6zT18L"
        },
        {
          "author": "stephentoub",
          "body": "If we can make it work reliably and safely, I'm for it.",
          "createdAt": "2025-06-26T12:36:31Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-06-26T12:36:31Z",
          "id": "IC_kwDODI9FZc6zT6f2"
        }
      ],
      "totalCount": 6,
      "endCursor": "Y3Vyc29yOnYyOpHOs0-n9g=="
    },
    "url": "https://github.com/dotnet/runtime/issues/117043",
    "title": "[JsonSchemaExporter]: Respecting data annotations + schema version"
  },
  {
    "author": "ydogus",
    "labels": [
      "api-suggestion",
      "area-System.Text.Json"
    ],
    "createdAt": "2025-07-03T13:50:12Z",
    "body": "Hello,\n\nI'm creating a new API based on ASP.NET Core. While I was configuring the standard error results, I've encountered an issue:\n\nAs you know, ASP.NET facilitates our life by deserializing the JSON payload sent in the body of a HTTP request. But we have an issue when there is a parameter with `required` keyword, and if it is not provided in the payload, the deserializer throws an exception. That is expected as the property is `required`. But we don't have a proper error result which should provide us the list of parameters failed (and some other errors maybe?). Due to the lack of detailed error information, the web framework doesn't know what really happened and can't generate a proper error result.\n\nLet me explain: Here is an example of error result generated with the default validators:\n```json\n{\n    \"statusCode\": 400,\n    \"message\": \"One or more errors occurred!\",\n    \"errors\": {\n        \"parameter1\": [\n            \"Parameter1 is required.\"\n        ],\n        \"parameter2\": [\n            \"Parameter2 is required.\"\n        ]\n    }\n}\n```\n\nUnfortunately when the request fails with a JsonException because of missing required properties, the validators don't even have the chance to validate because no instance has been created from the payload. I accept that part. No instance no validation! Anyway, here is the error message received from the library:\n\n> JSON deserialization for type 'SampleApi+SampleRequest' was missing required properties including: 'parameter1', 'parameter2'.\n\nSo I decided to intercept the error handling to customize the error when a JsonException is occured to format it the same as above. But unfortunately the exception doesn't contain the parameter list or any other useful information. And I won't try to parse the Exception.Message just to extract the property list—like any sane person wouldn't.\n\nAm I missing something here? Is there a way to access to a structured error? If not, I'm afraid people will have difficulties with error handling while using `System.Text.Json` in ASP.NET Core.",
    "number": 117271,
    "reactions": {
      "hasNextPage": false,
      "nodes": [],
      "totalCount": 0,
      "endCursor": null
    },
    "updatedAt": "2025-07-04T10:22:37Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": "dotnet-policy-service",
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. -->",
          "createdAt": "2025-07-03T15:39:06Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-07-03T15:39:06Z",
          "id": "IC_kwDODI9FZc60w_KV"
        },
        {
          "author": "eiriktsarpalis",
          "body": "What do you propose? An exception deriving from JsonException perhaps that surfaces the full list of missing required parameters?",
          "createdAt": "2025-07-03T16:12:24Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-07-03T20:45:45Z",
                "user": "ydogus"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOEZLpjg=="
          },
          "updatedAt": "2025-07-03T16:12:24Z",
          "id": "IC_kwDODI9FZc60xVo2"
        },
        {
          "author": "ydogus",
          "body": "@eiriktsarpalis, yes that would solve the problem described above. An exception with a list of missing required parameters would definitly allow us to manage deserializations properly.\n\nI was also wondering, if `JsonException.Path` could be used here without introducing any breaking change to avoid a new type?",
          "createdAt": "2025-07-03T16:34:41Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-07-03T16:34:41Z",
          "id": "IC_kwDODI9FZc60xjFd"
        },
        {
          "author": "eiriktsarpalis",
          "body": "> I was also wondering, if JsonException.Path could be used here without introducing any breaking change to avoid a new type?\n\nHow? `Path` serves a specific purpose and even if we repurposed it (which we shouldn't) it's of type `string` meaning that you still need to parse the missing properties as with `Message`.",
          "createdAt": "2025-07-04T09:21:10Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-07-04T09:21:10Z",
          "id": "IC_kwDODI9FZc606Jdh"
        },
        {
          "author": "ydogus",
          "body": "> it's of type `string` meaning that you still need to parse\n\nYou are right. I should have thought of that.\n\nAnyway, if you are OK for throwing a new exception type for this case, I'm willing to make a PR.\n\nWe can have a new exception named as `MissingRequiredPropertyJsonException` with a property of `ReadOnlyCollection<string> MissingProperties` or `PropertyNames`.",
          "createdAt": "2025-07-04T10:08:42Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-07-04T10:08:42Z",
          "id": "IC_kwDODI9FZc6066L1"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Any new API needs to be reviewed and approved before creating a PR.\n\nhttps://github.com/dotnet/runtime/blob/main/docs/project/api-review-process.md",
          "createdAt": "2025-07-04T10:22:37Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-07-04T10:22:37Z",
          "id": "IC_kwDODI9FZc607Jsg"
        }
      ],
      "totalCount": 6,
      "endCursor": "Y3Vyc29yOnYyOpHOtOybIA=="
    },
    "url": "https://github.com/dotnet/runtime/issues/117271",
    "title": "System.Text.Json: Provide failed parameter list in exception"
  },
  {
    "author": "StephenHodgson",
    "labels": [
      "area-System.Text.Json"
    ],
    "createdAt": "2025-07-05T21:23:00Z",
    "body": "## Summary\n\nIntroduce a built-in mechanism in .NET (System.Text.Json or a related package) to generate strongly-typed .NET classes (POCOs) from JSON Schema definitions. This should include both a developer tool/CLI and a source generator that integrates with the build process.\n\n## Motivation\n\n- **Interoperability:** Many APIs, data contracts, and ML/data workflows publish schemas as JSON Schema. Consuming these in .NET requires manual model creation or using third-party tools.\n- **Productivity:** Manual translation of complex JSON Schemas to C# types is tedious, error-prone, and difficult to maintain when schemas evolve.\n- **Modern Workflow:** Source generators are now a first-class extensibility point in .NET, enabling seamless, compile-time codegen scenarios.\n- **Consistency:** Having this feature as part of the .NET ecosystem would ensure alignment with System.Text.Json serialization and improve developer experience.\n\n## Goals\n\n- Allow developers to generate C# classes from a JSON Schema file (or document).\n- Support both design-time generation (e.g., via CLI, MSBuild target) and compile-time generation (via source generator).\n- Provide configuration options for namespace, output path, partial class usage, and property annotation (e.g., with [JsonPropertyName]).\n- Ensure high fidelity to JSON Schema: types, required/optional, enums, arrays, nested objects, default values, etc.\n- Integrate with System.Text.Json for serialization compatibility.\n\n## Non-Goals\n\n- Supporting every edge-case of JSON Schema draft specifications (focus on practical subset).\n- Generating code for non-C# languages.\n- Direct runtime code generation (focus on build-time).\n\n## Detailed Design\n\n### API/Tooling\n\n1. **CLI Tool**\n   - Command: dotnet jsonschema-codegen\n   - Arguments: input schema file(s), output directory, namespace, options for customization.\n\n2. **Source Generator**\n   - Attribute-based: [JsonSchemaType(\"path/to/schema.json\")]\n   - Generates types as part of the compilation.\n   - Supports incremental builds and IDE tooling.\n\n3. **MSBuild Target (Optional)**\n   - Integrate code generation into build pipelines for larger projects/solutions.\n\n### Features\n\n- Map JSON Schema types to C# types (string, int, bool, arrays, objects, etc.).\n- Handle required vs. optional (nullable reference types, required attributes).\n- Generate inheritance, enums, and default values where applicable.\n- Support schema references ($ref), allOf, anyOf, oneOf for common patterns.\n- Optionally annotate properties with [JsonPropertyName] for exact serialization alignment.\n- Allow customizations via configuration (e.g., naming conventions, base classes, partial classes).\n\n### Example\n\nGiven a schema:\n```json\n{\n  \"title\": \"Person\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"firstName\": { \"type\": \"string\" },\n    \"age\": { \"type\": \"integer\" },\n    \"email\": { \"type\": \"string\" }\n  },\n  \"required\": [\"firstName\", \"email\"]\n}\n```\n\nGenerated C#:\n```csharp\npublic class Person\n{\n    [JsonPropertyName(\"firstName\")]\n    public string FirstName { get; set; }\n\n    [JsonPropertyName(\"age\")]\n    public int? Age { get; set; }\n\n    [JsonPropertyName(\"email\")]\n    public string Email { get; set; }\n}\n```\n\n### Extensibility\n\n- Plugin model for custom type mappings or advanced schema features.\n- Hooks for validation or additional code annotation.\n\n## Alternatives\n\n- Continue using third-party libraries (e.g., Corvis.Json, NJsonSchema) — but these are external and may not align perfectly with System.Text.Json.\n- Manual model creation — error-prone and not scalable.\n\n## Risks\n\n- JSON Schema is a flexible standard with many edge cases. The first-party tool should focus on the most common patterns, with clear documentation on limitations.\n- Maintaining feature parity as JSON Schema standards evolve.\n\n## Community Libraries\n\n- Corvis.Json\n- NJsonSchema\n\n## Conclusion\n\nAdding official, first-party code generation from JSON Schema to .NET would significantly improve developer productivity, interoperability, and maintainability in modern, data-driven .NET applications—including APIs, AI/ML pipelines, and beyond.\n",
    "number": 117338,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "CONFUSED",
          "createdAt": "2025-07-08T09:02:26Z",
          "user": "iamkisly"
        }
      ],
      "totalCount": 1,
      "endCursor": "Y3Vyc29yOnYyOpHODGIpdg=="
    },
    "updatedAt": "2025-07-07T20:26:42Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": "dotnet-policy-service",
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. -->",
          "createdAt": "2025-07-05T21:23:42Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-07-05T21:23:42Z",
          "id": "IC_kwDODI9FZc61NtIn"
        },
        {
          "author": "gregsdennis",
          "body": "You should try @mwadams' excellent Corvus.JsonSchema for this.",
          "createdAt": "2025-07-06T06:43:56Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "HEART",
                "createdAt": "2025-07-06T06:46:03Z",
                "user": "mwadams"
              },
              {
                "content": "HEART",
                "createdAt": "2025-07-06T07:02:53Z",
                "user": "StephenHodgson"
              },
              {
                "content": "HEART",
                "createdAt": "2025-07-07T06:19:26Z",
                "user": "eiriktsarpalis"
              }
            ],
            "totalCount": 3,
            "endCursor": "Y3Vyc29yOnYyOpHOEZiTWA=="
          },
          "updatedAt": "2025-07-06T06:43:56Z",
          "id": "IC_kwDODI9FZc61Qj9j"
        },
        {
          "author": "StephenHodgson",
          "body": "I have been diving into this, but there are some restrictions to relying 3rd party libraries and dependencies in the sort of work I'm currently doing.\n\nIdeally all would be integrated into the dotnet runtime. Also seems fitting to complete the circle.\nIf you can export to JsonSchema, one would predict you could also generate from JsonSchema.",
          "createdAt": "2025-07-06T07:04:18Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-07-06T07:06:18Z",
          "id": "IC_kwDODI9FZc61QtXT"
        },
        {
          "author": "eiriktsarpalis",
          "body": "It seems unlikely that we'd invest in such a generator at the STJ layer, it's more probable we'd want to create an E2E OpenAPI generator at the ASP.NET Core layer.",
          "createdAt": "2025-07-07T06:22:58Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-07-07T06:22:58Z",
          "id": "IC_kwDODI9FZc61ae0M"
        },
        {
          "author": "gregsdennis",
          "body": "The functionality to generate schemas is, as you've pointed out elsewhere, quite limited and doesn't follow best practices as recommended by the specification and JSON Schema TSC (myself included).  It needs work.\n\nWhen it was being developed initially, the goal was to get something operational for the OpenAI team.  Its current state (e.g. outputting to a JSON DOM instead of a dedicated model) is definitely not intended to be final.  A lot more work will need to be done to have something more robust: validation, annotation, generation (both ways), ... other things. It needs design.\n\nMoreover, we (JSON Schema) are getting pretty close to releasing the next version of the specification.  Although we consider the existing specs to be production-ready, they are still technically IETF draft. This will be effectively a v1.0.",
          "createdAt": "2025-07-07T06:24:45Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "ROCKET",
                "createdAt": "2025-07-07T18:27:37Z",
                "user": "StephenHodgson"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOEZpQJw=="
          },
          "updatedAt": "2025-07-07T11:04:22Z",
          "id": "IC_kwDODI9FZc61af1K"
        },
        {
          "author": "gregsdennis",
          "body": "I'd push for a JSON Schema implementation that's independent of OpenAPI.  It's useful in so many more places that just APIs.",
          "createdAt": "2025-07-07T11:03:25Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-07-07T18:28:30Z",
                "user": "StephenHodgson"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOEZpQnQ=="
          },
          "updatedAt": "2025-07-07T11:03:25Z",
          "id": "IC_kwDODI9FZc61d5_O"
        },
        {
          "author": "StephenHodgson",
          "body": "> When it was being developed initially, the goal was to get something operational for the OpenAI team.\n\nExactly since I have been [maintaining one of the first C# libraries](https://github.com/RageAgainstThePixel/OpenAI-DotNet) since before the official one was released. I've been trying to get source generator working to make the maintenance easier. I am continuing to maintain because of my Unity game engine package extends it.\n\n> it's more probable we'd want to create an E2E OpenAPI generator at the ASP.NET Core layer.\n\nI disagree, since we would would also want these objects to be generated in the API clients as well (which ironically is what has lead me down this path). It's an important piece of the whole puzzle.\n\nAlso, one critical concern I have atm is that the dotnet ecosystem is gonna lag behind in the AI space specifically because of this limitation, since most of the other languages already have native support for code generators of this caliber.\n\nWithout this the dotnet ecosystem just won't be as useful for developers who want to use it.\n\n",
          "createdAt": "2025-07-07T18:39:48Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-07-07T18:39:48Z",
          "id": "IC_kwDODI9FZc61kQhy"
        }
      ],
      "totalCount": 7,
      "endCursor": "Y3Vyc29yOnYyOpHOtZEIcg=="
    },
    "url": "https://github.com/dotnet/runtime/issues/117338",
    "title": "Proposal: Add Code Generation from JsonSchema to System.Text.Json.JsonSchema"
  },
  {
    "author": "John0King",
    "labels": [
      "area-System.Text.Json"
    ],
    "createdAt": "2025-07-08T02:45:58Z",
    "body": "### Description\n\ncurrently , S.T.J  allow read `\"123\"` to number type like `Nullable<int>`/`Nullable<decimal>`  ,  but it doesn't allow `\"\"` (eg. empty string)  to `null`\n<img width=\"1722\" height=\"525\" alt=\"Image\" src=\"https://github.com/user-attachments/assets/fa8d7079-6ffa-444a-a47a-8cb021670630\" />\n\nsince  the number is using string format,  so it might be `null | \"\"`  when there is no number ,  so  `null` or `\"\"` both should be deserialize as `null`\nfor example :   a html `input`  bind a value of string ,  when user type  a number and delete\n\n### Reproduction Steps\n\n```C#\nvar op = new System.Text.Json.JsonSerializerOptions(System.Text.Json.JsonSerializerDefaults.Web)\n  {                                                                                                                           NumberHandling = System.Text.Json.Serialization.JsonNumberHandling.AllowReadingFromString | System.Text.Json.Seria\n  lization.JsonNumberHandling.AllowNamedFloatingPointLiterals\n  };\n System.Text.Json.JsonSerializer.Deserialize<decimal?>(\"\\\"\\\"\", op)\n```\n\n### Expected behavior\n\n\"\"  => null (decimal?)  \n\n\n### Actual behavior\n\nthow exception : The JSON value could not be converted to System.Nullable`1[System.Decimal]\n\n### Regression?\n\n_No response_\n\n### Known Workarounds\n\n_No response_\n\n### Configuration\n\n_No response_\n\n### Other information\n\n_No response_",
    "number": 117404,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-07-15T01:00:55Z",
          "user": "Varorbc"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-08-15T01:20:08Z",
          "user": "ddombrowsky"
        },
        {
          "content": "EYES",
          "createdAt": "2025-08-15T01:20:11Z",
          "user": "ddombrowsky"
        }
      ],
      "totalCount": 3,
      "endCursor": "Y3Vyc29yOnYyOpHODLUhcg=="
    },
    "updatedAt": "2025-08-15T02:32:41Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": "dotnet-policy-service",
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. -->",
          "createdAt": "2025-07-08T02:46:42Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-07-08T02:46:42Z",
          "id": "IC_kwDODI9FZc61oDnE"
        },
        {
          "author": "ddombrowsky",
          "body": "I agree that an empty string should be treated as `null` for an integer, if the field is nullable.  It looks like at least angular will default to blank strings when sending these API calls, making it hard to handle.\n\nAnyone know how to work around this in the code?",
          "createdAt": "2025-08-15T01:21:35Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-08-15T01:21:35Z",
          "id": "IC_kwDODI9FZc6-KN3P"
        },
        {
          "author": "John0King",
          "body": "@ddombrowsky  currently ,  I create my own convert  for  `datetime`/`datetimeoffset`/`decimal`/`nullable<decimal>`  \nand still using newtonsfot.json in some project.  and I still think newtonsoft.json is much easier for use. \n S.T.J is so strict 😣, and I have to implement a JsonConverter for nearly every primitive type for daily use.",
          "createdAt": "2025-08-15T02:06:11Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-08-15T02:06:11Z",
          "id": "IC_kwDODI9FZc6-Kaeg"
        },
        {
          "author": "ddombrowsky",
          "body": "I didn't want to do it system wide, but fortunately you don't have to.  The workaround is something like:\n```\n[JsonConverter(typeof(SNullConverter))]\npublic int? OptionalInteger { get; set; }\n```\n\nand then define the read-only converter:\n```\npublic class SNullConverter : JsonConverter<int?>\n{\n    public override int? Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) {\n        var s = reader.GetString();\n        if (s.IsNullOrEmpty()) {\n            return null;\n        }\n        return int.Parse(s);\n    }\n\n    public override void Write(Utf8JsonWriter writer, int? value, JsonSerializerOptions options) {\n        throw new NotImplementedException();\n    }\n}\n```\nAnnoying that such a simple thing is 15 lines of code, but whatareyagonnado, eh?\n",
          "createdAt": "2025-08-15T02:32:05Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-08-15T02:32:41Z",
          "id": "IC_kwDODI9FZc6-KjNS"
        }
      ],
      "totalCount": 4,
      "endCursor": "Y3Vyc29yOnYyOpHOviozUg=="
    },
    "url": "https://github.com/dotnet/runtime/issues/117404",
    "title": "JsonNumberHandling.AllowReadingFromString should support read empty string to null/default"
  },
  {
    "author": "performanceautofiler",
    "labels": [
      "area-System.Text.Json",
      "os-windows",
      "arch-x64",
      "runtime-coreclr"
    ],
    "createdAt": "2025-07-29T09:00:23Z",
    "body": "<!-- DATA: {\"RunType\":{\"Repo\":\"dotnetruntime\",\"Branch\":\"refs/heads/main\",\"Arch\":\"x64\",\"Os\":\"Windows1022621\",\"Queue\":\"TigerWindows\",\"Frequency\":\"Weekly\",\"CoreClr\":true,\"Mono\":false,\"Wasm\":false,\"Maui\":false,\"Configs\":[\"CompilationMode:tiered\",\"RunKind:micro\"]},\"RegressionDate\":\"2025-07-21T23:54:44\",\"IsRegression\":true} -->\r\n\r\n### Run Information\r\n\r\nName | Value\r\n-- | --\r\nArchitecture | x64\r\nOS | Windows 10.0.22621\r\nQueue | TigerWindows\r\nBaseline | [959c2a7a782b4e9e698e0f00cb06afe859d16829](https://github.com/dotnet/runtime/commit/959c2a7a782b4e9e698e0f00cb06afe859d16829)\r\nCompare | [0b2f272204ea0cb7d22d329a684c06cec412f736](https://github.com/dotnet/runtime/commit/0b2f272204ea0cb7d22d329a684c06cec412f736)\r\nDiff | [Diff](https://github.com/dotnet/runtime/compare/959c2a7a782b4e9e698e0f00cb06afe859d16829...0b2f272204ea0cb7d22d329a684c06cec412f736)\r\nConfigs | CompilationMode:tiered, RunKind:micro\r\n\r\n\r\n### Regressions in System.Text.Json.Serialization.Tests.ReadJson&lt;Int32&gt;\r\n\r\nBenchmark | Baseline | Test | Test/Base | Test Quality | Edge Detector | Baseline IR | Compare IR | IR Ratio\r\n-- | -- | -- | -- | -- | -- | -- | -- | --\r\n|<ul><li>[DeserializeFromStream - Duration of single invocation](<https://pvscmdupload.z22.web.core.windows.net/reports/allTestHistory/refs/heads/main_x64_Windows 10.0.22621/System.Text.Json.Serialization.Tests.ReadJson(Int32).DeserializeFromStream(Mode%3a%20SourceGen).html>)</li><li>📝 - [Benchmark Source](<https://github.com/dotnet/performance/blob/main/src/benchmarks/micro/libraries/System.Text.Json/Serializer/ReadJson.cs#L82-#L89>)</li><li>[ADX - Test Multi Config Graph](<https://dataexplorer.azure.com/clusters/dotnetperf.westus/databases/PerformanceData?query=H4sIAAAAAAAACl1RTXPTMBC9Zyb/YclFzuDaHpfQYhADtKV8TC9JBs7CXsdiZCkjrWkC5b+zip0Ll9VIevv2vbcGCQgDgYR3YnMMhH22xQNlX4Kz2Qa9Vkb/VqT5tmVcyNaomvj55rOly/JtdothQuFH7/oNeVR98uAarGDjBl/jPdqleD2fGZ6lWkLPwxpFSLrHpCzK1UWxuihfbYvranVVXV5nq9XLF0V59bwoqqJYTp0e944bRePIIuV+sLH/zPvDK1t38d9jG/KORYa8V9qeAbWzrd7FyUerel0nf8SN6/fanLxFuaICQRo9NiIFsR7sV22b+Mho78TfKOQe6ZMO5LyulblVpL5r6iKP8pozCUnMUsaSjlblqaYn9TKWdJIqxyOdhMnxWM5nT7D37ifWBDF9DCl8GLRptmx2Q6rfp/BNmQFl3MaN4xTQrzEMht7/Qq92OJ/l+RM8dmxkYoBnTE6cRYDFgtzdoTZDg4sF5DncHZjSILgWWm2YS9sduIEXBXGtGKIgj7bhrcW86055gkd2DckIkGeZh9qZobfyf7nH8T3Ik27GkSaDUnB8yEkfp+sDqjB47NGSWP4DB/BncZcCAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=>)</li></ul> | 212.45 ns | 243.45 ns | 1.15 | 0.06 | False | | |\r\n|<ul><li>[DeserializeFromStream - Duration of single invocation](<https://pvscmdupload.z22.web.core.windows.net/reports/allTestHistory/refs/heads/main_x64_Windows 10.0.22621/System.Text.Json.Serialization.Tests.ReadJson(Int32).DeserializeFromStream(Mode%3a%20Reflection).html>)</li><li>📝 - [Benchmark Source](<https://github.com/dotnet/performance/blob/main/src/benchmarks/micro/libraries/System.Text.Json/Serializer/ReadJson.cs#L82-#L89>)</li><li>[ADX - Test Multi Config Graph](<https://dataexplorer.azure.com/clusters/dotnetperf.westus/databases/PerformanceData?query=H4sIAAAAAAAACl1RTXPTMBC9Zyb/YclFzuDaJjQ0NYgB2vI5vSQZOAt7HYuRpYy0bhMo/51V7Fy4rEbS27fvvTVIQBgIJLwTm2Mg7LItHij7GpzNNui1Mvq3Is23LeNCtkZVx883Xyy9XLzNbjGMKPzoXbchj6pL7l2NJayxMVjF5rl4PZ0YHqYaQs/TakVIusNkUSyWF8XyYnG9LVbl8qq8XGWvLlfFi+ur50VRFsV87PS4d9woakcWKfe9jf1n3p9e2aqN/x6bkLesMuSd0vYMqJxt9C5OPlrV6Sr5I25ct9fmZC7qFSUI0uixFimIdW+/aVvHR0Z7J/5GIZ+QPutAzutKmVtF6oemNvIorzmUkMQwZSzpYFWeanpSL2NJR6lyONJRmByO+XTyBHvvfnFsEOPHkMKHXpt6y2Y3pLp9Ct+V6VHGddw4TgH9GkNv6P0DerXD6STPn+CxZSMjAzxjcuIsAsxm5O4OlelrnM0gz+HuwJQGwTXQaMNc2u7A9bwoiHvFEAV5tDVvLeZdtcoTPLJrSAaAPMs8VM70nZX/yz0O70GedDOONBmUguNDTvo4Xu9Rhd5jh5bE/B8u4T61mAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=>)</li></ul> | 211.55 ns | 239.08 ns | 1.13 | 0.05 | False | | |\r\n\r\n![graph](<https://pvscmdupload.z22.web.core.windows.net/autofilereport/autofilereports/07_29_2025/refs/heads/main_x64_Windows%2010.0.22621_Regression/System.Text.Json.Serialization.Tests.ReadJson%28Int32%29_001.png>)\r\n![graph](<https://pvscmdupload.z22.web.core.windows.net/autofilereport/autofilereports/07_29_2025/refs/heads/main_x64_Windows%2010.0.22621_Regression/System.Text.Json.Serialization.Tests.ReadJson%28Int32%29_002.png>)\r\n[Test Report](<https://pvscmdupload.z22.web.core.windows.net/autofilereport/autofilereports/07_29_2025/refs/heads/main_x64_Windows%2010.0.22621_Regression/System.Text.Json.Serialization.Tests.ReadJson%28Int32%29.html>)\r\n\r\n### Repro\r\nGeneral Docs link: https://github.com/dotnet/performance/blob/main/docs/benchmarking-workflow-dotnet-runtime.md\r\n\r\n```cmd\r\ngit clone https://github.com/dotnet/performance.git\r\npy .\\performance\\scripts\\benchmarks_ci.py -f net8.0 --filter 'System.Text.Json.Serialization.Tests.ReadJson&lt;Int32&gt;*'\r\n```\r\n\r\n<details>\r\n\r\n### System.Text.Json.Serialization.Tests.ReadJson&lt;Int32&gt;.DeserializeFromStream(Mode: SourceGen)\r\n\r\n#### ETL Files\r\n\r\n#### Histogram\r\n\r\n#### JIT Disasms\r\n\r\n### System.Text.Json.Serialization.Tests.ReadJson&lt;Int32&gt;.DeserializeFromStream(Mode: Reflection)\r\n\r\n#### ETL Files\r\n\r\n#### Histogram\r\n\r\n#### JIT Disasms\r\n\r\n\r\n\r\n### Docs\r\n\r\n[Profiling workflow for dotnet/runtime repository](https://github.com/dotnet/performance/blob/master/docs/profiling-workflow-dotnet-runtime.md)\r\n[Benchmarking workflow for dotnet/runtime repository](https://github.com/dotnet/performance/blob/master/docs/benchmarking-workflow-dotnet-runtime.md)\r\n\r\n</details>\r\n\r\n\r\n---\r\n\r\n\r\n### Run Information\r\n\r\nName | Value\r\n-- | --\r\nArchitecture | x64\r\nOS | Windows 10.0.22621\r\nQueue | TigerWindows\r\nBaseline | [959c2a7a782b4e9e698e0f00cb06afe859d16829](https://github.com/dotnet/runtime/commit/959c2a7a782b4e9e698e0f00cb06afe859d16829)\r\nCompare | [0b2f272204ea0cb7d22d329a684c06cec412f736](https://github.com/dotnet/runtime/commit/0b2f272204ea0cb7d22d329a684c06cec412f736)\r\nDiff | [Diff](https://github.com/dotnet/runtime/compare/959c2a7a782b4e9e698e0f00cb06afe859d16829...0b2f272204ea0cb7d22d329a684c06cec412f736)\r\nConfigs | CompilationMode:tiered, RunKind:micro\r\n\r\n\r\n### Regressions in System.Text.Json.Serialization.Tests.ReadJson&lt;Nullable&lt;DateTimeOffset&gt;&gt;\r\n\r\nBenchmark | Baseline | Test | Test/Base | Test Quality | Edge Detector | Baseline IR | Compare IR | IR Ratio\r\n-- | -- | -- | -- | -- | -- | -- | -- | --\r\n|<ul><li>[DeserializeFromStream - Duration of single invocation](<https://pvscmdupload.z22.web.core.windows.net/reports/allTestHistory/refs/heads/main_x64_Windows 10.0.22621/System.Text.Json.Serialization.Tests.ReadJson(Nullable(DateTimeOffset)).DeserializeFromStream(Mode%3a%20SourceGen).html>)</li><li>📝 - [Benchmark Source](<https://github.com/dotnet/performance/blob/main/src/benchmarks/micro/libraries/System.Text.Json/Serializer/ReadJson.cs#L82-#L89>)</li><li>[ADX - Test Multi Config Graph](<https://dataexplorer.azure.com/clusters/dotnetperf.westus/databases/PerformanceData?query=H4sIAAAAAAAACl1SwW7bMAy9B8g/cLkowVzbSxcgzapiW9t12NANiIPtrNp0okGWAolqk63991KJc9mFgijy8fE9GSQgDAQSPopqHwi7fIU7yr8FZ/MKvVZG/1Wk+bbiupAvUTXp8fJHNEY9GLy8UYQr3eHPtg1IV1f5DYa+Eb9411XkUXXje9fgAioXfY13aCfiw3BgeLxqCT3PbxiGGGY8Laezs3J2Nr1YlfPFbL4o3+XleTk/v3j/tiwXZTnpOz1uHTeKxpFFKny0qf+E++CVrTfp3WMbig3zDkWntD0V1M62ep0m763qdD3+J65dt9XmsG6iKxYgSKPHRmQgltF+17ZJSa72TrwkIndIX3Ug53WtDEuhfmvaJBzlNcsUxklemUJ2XFUeYnZgL1PIeqryeGQ9MXk8JsPBM2y9+4M1QTIEQwafozZN0rwi1W0z+KVMRJkMunasAvolhmjo0yN6tcbhoCie4WnDi/QI8IbBibUIMBqRu93VJjY4GkFRwO2OIQ2Ca6HVhrG0XYOLbBQkWzEkQh5tw64lveuN8gRPvDWMjwXyRHNXOxM7K/+nuz/mgzzw5jrSZFCK9JNY6X1/vUcVoscOLYnJKxQHW4eqAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=>)</li></ul> | 276.53 ns | 292.65 ns | 1.06 | 0.05 | False | | |\r\n\r\n![graph](<https://pvscmdupload.z22.web.core.windows.net/autofilereport/autofilereports/07_29_2025/refs/heads/main_x64_Windows%2010.0.22621_Regression/System.Text.Json.Serialization.Tests.ReadJson%28Nullable%28DateTimeOffset%29%29_001.png>)\r\n[Test Report](<https://pvscmdupload.z22.web.core.windows.net/autofilereport/autofilereports/07_29_2025/refs/heads/main_x64_Windows%2010.0.22621_Regression/System.Text.Json.Serialization.Tests.ReadJson%28Nullable%28DateTimeOffset%29%29.html>)\r\n\r\n### Repro\r\nGeneral Docs link: https://github.com/dotnet/performance/blob/main/docs/benchmarking-workflow-dotnet-runtime.md\r\n\r\n```cmd\r\ngit clone https://github.com/dotnet/performance.git\r\npy .\\performance\\scripts\\benchmarks_ci.py -f net8.0 --filter 'System.Text.Json.Serialization.Tests.ReadJson&lt;Nullable&lt;DateTimeOffset&gt;&gt;*'\r\n```\r\n\r\n<details>\r\n\r\n### System.Text.Json.Serialization.Tests.ReadJson&lt;Nullable&lt;DateTimeOffset&gt;&gt;.DeserializeFromStream(Mode: SourceGen)\r\n\r\n#### ETL Files\r\n\r\n#### Histogram\r\n\r\n#### JIT Disasms\r\n\r\n\r\n\r\n### Docs\r\n\r\n[Profiling workflow for dotnet/runtime repository](https://github.com/dotnet/performance/blob/master/docs/profiling-workflow-dotnet-runtime.md)\r\n[Benchmarking workflow for dotnet/runtime repository](https://github.com/dotnet/performance/blob/master/docs/benchmarking-workflow-dotnet-runtime.md)\r\n\r\n</details>\r\n\r\n\r\n---\r\n\r\n\r\n### Run Information\r\n\r\nName | Value\r\n-- | --\r\nArchitecture | x64\r\nOS | Windows 10.0.22621\r\nQueue | TigerWindows\r\nBaseline | [88f2361c958affeaaa24122780fecb680365b558](https://github.com/dotnet/runtime/commit/88f2361c958affeaaa24122780fecb680365b558)\r\nCompare | [0b2f272204ea0cb7d22d329a684c06cec412f736](https://github.com/dotnet/runtime/commit/0b2f272204ea0cb7d22d329a684c06cec412f736)\r\nDiff | [Diff](https://github.com/dotnet/runtime/compare/88f2361c958affeaaa24122780fecb680365b558...0b2f272204ea0cb7d22d329a684c06cec412f736)\r\nConfigs | CompilationMode:tiered, RunKind:micro\r\n\r\n\r\n### Regressions in MicroBenchmarks.Serializers.Json_FromStream&lt;LoginViewModel&gt;\r\n\r\nBenchmark | Baseline | Test | Test/Base | Test Quality | Edge Detector | Baseline IR | Compare IR | IR Ratio\r\n-- | -- | -- | -- | -- | -- | -- | -- | --\r\n|<ul><li>[SystemTextJson_SourceGen_ - Duration of single invocation](<https://pvscmdupload.z22.web.core.windows.net/reports/allTestHistory/refs/heads/main_x64_Windows 10.0.22621/MicroBenchmarks.Serializers.Json_FromStream(LoginViewModel).SystemTextJson_SourceGen_.html>)</li><li>[ADX - Test Multi Config Graph](<https://dataexplorer.azure.com/clusters/dotnetperf.westus/databases/PerformanceData?query=H4sIAAAAAAAACl2RT2/TQBDF75HyHZZcNhFubFkYpYFF0FKKCrk0UTlWiz1JBvZPNDtuElq+O7t2cuEyK6/fvPnNWwMsGAILJT7KBdbkr8DVW6vpd5gugVAb/AMUpnfBu8cv5O2SCbR9/91v0D0g7Be+AfNhujwGBruCA3fKpW+phltwj/LdcGDiFL1moDim0QyMFsZlUVYXRXVRXq6K2byazcs309nbsiovq9dFMS+KyamTYOdjo2w8O+CcWpf6z74/SUfg9J9gHfIt6CbkVqM7C2rv1rhJk49OW6zHz/La2x0azehdwpdzIRmBoJGZkPet+4auSZdRTV7+TSC3wF8xsCestfmsWf9A3iYfTRgXDuOUokol61dVXc06epVKdkJV/ZGdwFR/TIaDF7Ej/wtqFil4CJm4atE0q7jskrXdZeJBmxbUKg659jEFoHsIreFPT0B6A8NBnr+I/TYucnIQr6I5xyyCGI3Y3xxq0zYwGok8FzeHaGlA+LVYo4le6DbCt/GhROiaExCBa+KrpbzrrSYW+7i1GPcCdcY81N601qn/cY/9fVAdd9QxsgElY3wQkz6ePhegQ0tgwbGc/AOZp8dHkQIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=>)</li></ul> | 359.87 ns | 382.93 ns | 1.06 | 0.01 | False | | |\r\n\r\n![graph](<https://pvscmdupload.z22.web.core.windows.net/autofilereport/autofilereports/07_29_2025/refs/heads/main_x64_Windows%2010.0.22621_Regression/MicroBenchmarks.Serializers.Json_FromStream%28LoginViewModel%29_001.png>)\r\n[Test Report](<https://pvscmdupload.z22.web.core.windows.net/autofilereport/autofilereports/07_29_2025/refs/heads/main_x64_Windows%2010.0.22621_Regression/MicroBenchmarks.Serializers.Json_FromStream%28LoginViewModel%29.html>)\r\n\r\n### Repro\r\nGeneral Docs link: https://github.com/dotnet/performance/blob/main/docs/benchmarking-workflow-dotnet-runtime.md\r\n\r\n```cmd\r\ngit clone https://github.com/dotnet/performance.git\r\npy .\\performance\\scripts\\benchmarks_ci.py -f net8.0 --filter 'MicroBenchmarks.Serializers.Json_FromStream&lt;LoginViewModel&gt;*'\r\n```\r\n\r\n<details>\r\n\r\n### MicroBenchmarks.Serializers.Json_FromStream&lt;LoginViewModel&gt;.SystemTextJson_SourceGen_\r\n\r\n#### ETL Files\r\n\r\n#### Histogram\r\n\r\n#### JIT Disasms\r\n\r\n\r\n\r\n### Docs\r\n\r\n[Profiling workflow for dotnet/runtime repository](https://github.com/dotnet/performance/blob/master/docs/profiling-workflow-dotnet-runtime.md)\r\n[Benchmarking workflow for dotnet/runtime repository](https://github.com/dotnet/performance/blob/master/docs/benchmarking-workflow-dotnet-runtime.md)\r\n\r\n</details>\r\n",
    "number": 118173,
    "reactions": {
      "hasNextPage": false,
      "nodes": [],
      "totalCount": 0,
      "endCursor": null
    },
    "updatedAt": "2025-08-30T22:25:04Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": "LoopedBard3",
          "body": "Likely due to https://github.com/dotnet/runtime/pull/116947 in range https://github.com/dotnet/runtime/compare/a6a3475ea34d84262a9dee41b027c4de35ecc84f...4314b63e2faed4e3f6639f48894810193b94f0c9. FYI @BrennanConroy. Related Regressions:\n* https://github.com/dotnet/perf-autofiling-issues/issues/59776",
          "createdAt": "2025-07-29T16:31:35Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "EYES",
                "createdAt": "2025-07-30T21:09:45Z",
                "user": "BrennanConroy"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOEcjh1w=="
          },
          "updatedAt": "2025-07-29T16:31:35Z",
          "id": "IC_kwDODI9FZc66wZvm"
        },
        {
          "author": "dotnet-policy-service",
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. -->",
          "createdAt": "2025-07-29T16:32:46Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-07-29T16:32:46Z",
          "id": "IC_kwDODI9FZc66waQx"
        },
        {
          "author": "jeffhandley",
          "body": "@BrennanConroy I assigned this to you for evaluation before we close down .NET 10. Please connect with @eiriktsarpalis to make sure the tradeoff is acceptable here or consider ways to mitigate the regression if caused by #116947.",
          "createdAt": "2025-08-04T07:28:15Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-08-04T08:01:31Z",
                "user": "eiriktsarpalis"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOEc-Grg=="
          },
          "updatedAt": "2025-08-04T07:28:15Z",
          "id": "IC_kwDODI9FZc67uLIv"
        },
        {
          "author": "jeffhandley",
          "body": "The reports are still showing the regression; it doesn't look like #118408 addressed this.",
          "createdAt": "2025-08-30T22:25:04Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-08-30T22:25:04Z",
          "id": "IC_kwDODI9FZc7BGBRL"
        }
      ],
      "totalCount": 4,
      "endCursor": "Y3Vyc29yOnYyOpHOwRgUSw=="
    },
    "url": "https://github.com/dotnet/runtime/issues/118173",
    "title": "[Perf] System.Text.Json.Serialization Regressions on 7/21/2025 11:54:44 PM +00:00"
  },
  {
    "author": "lilinus",
    "labels": [
      "enhancement",
      "area-System.Text.Json"
    ],
    "createdAt": "2025-07-30T10:55:39Z",
    "body": "### Description\n\nDeserializing `Version` does not allow leading nor trailing whitespace bug. But there are some wierd behaviours since the \"components\" of the version are parsed with NumberStyles.Integer:\n- `+` plus sign is allowed for second/third/fourth components.\n- Arbitrary amount of whitespace is allowed between the components and the `.` dot-separateor.\n\n### Reproduction Steps\n\n```\nusing System.Text.Json;\nJsonSerializer.Deserialize<Version>($\"\\\"+1.1\\\"\"); // Throws \nJsonSerializer.Deserialize<Version>($\"\\\"1.+1\\\"\"); // Success\nJsonSerializer.Deserialize<Version>($\"\\\" 1.1\\\"\"); // Throws\nJsonSerializer.Deserialize<Version>($\"\\\"1 .1\\\"\"); // Success\nJsonSerializer.Deserialize<Version>($\"\\\"1. 1\\\"\"); // Success\nJsonSerializer.Deserialize<Version>($\"\\\"1.1 \\\"\"); // Throws \nJsonSerializer.Deserialize<Version>($\"\\\"1 . +1\\\"\"); // Success\nJsonSerializer.Deserialize<Version>($\"\\\"1.{new string(' ', 255)}1\\\"\"); // Success\nJsonSerializer.Deserialize<Version>($\"\\\"1.{new string(' ', 256)}1\\\"\"); // Throws - string is too long (>258 chars)\n```\n\n### Expected behavior\n\nNot sure, but given the other JSON converters are a bit \"strict\" perhaps all of the above should throw?\n\n### Actual behavior\n\nSee repro steps\n\n### Regression?\n\n_No response_\n\n### Known Workarounds\n\n_No response_\n\n### Configuration\n\n_No response_\n\n### Other information\n\n_No response_",
    "number": 118201,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "EYES",
          "createdAt": "2025-07-30T13:01:31Z",
          "user": "Copilot"
        }
      ],
      "totalCount": 1,
      "endCursor": "Y3Vyc29yOnYyOpHODJJcpg=="
    },
    "updatedAt": "2025-07-30T15:45:19Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": "dotnet-policy-service",
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. -->",
          "createdAt": "2025-07-30T10:56:37Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-07-30T10:56:37Z",
          "id": "IC_kwDODI9FZc666IIY"
        },
        {
          "author": "eiriktsarpalis",
          "body": "This appears to be intentional behavior inherited from `Version.{Try}Parse`. I don't think we could change this now for fear of breaking users.",
          "createdAt": "2025-07-30T11:55:55Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-07-30T11:56:01Z",
          "id": "IC_kwDODI9FZc666vtN"
        },
        {
          "author": "lilinus",
          "body": "> This appears to be intentional behavior inherited from `Version.{Try}Parse`. I don't think we could change this now for fear of breaking users.\n\nFair, then limit on the string-length is a bit unexpected in this case.\n```\nJsonSerializer.Deserialize<Version>($\"\\\"1.{new string(' ', 255)}1\\\"\"); // Success\nJsonSerializer.Deserialize<Version>($\"\\\"1.{new string(' ', 256)}1\\\"\"); // Throws - json string is too long (>258 chars)\n```",
          "createdAt": "2025-07-30T12:54:17Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-07-30T12:54:25Z",
          "id": "IC_kwDODI9FZc667sY6"
        },
        {
          "author": "eiriktsarpalis",
          "body": "That's true. The downside of making it more permissive is that the implementation would no longer be able to rely on a stack allocated buffer:\n\nhttps://github.com/dotnet/runtime/blob/123627ba0f80c268cbde5beb6db42dc5c12d150d/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/Converters/Value/VersionConverter.cs#L45-L47",
          "createdAt": "2025-07-30T13:01:23Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-07-30T13:01:23Z",
          "id": "IC_kwDODI9FZc6671Cn"
        },
        {
          "author": "dotnet-policy-service",
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. -->",
          "createdAt": "2025-07-30T15:45:19Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-07-30T15:45:19Z",
          "id": "IC_kwDODI9FZc66-THW"
        }
      ],
      "totalCount": 5,
      "endCursor": "Y3Vyc29yOnYyOpHOuvkx1g=="
    },
    "url": "https://github.com/dotnet/runtime/issues/118201",
    "title": "Deserializing Version edge case in JSON"
  },
  {
    "author": "bbartels",
    "labels": [
      "api-suggestion",
      "area-System.Text.Json"
    ],
    "createdAt": "2025-08-03T02:34:31Z",
    "body": "### Background and motivation\n\nI have a scenario where I am trying to find the value of a single top-level property in a json payload that I am processing in chunks. I don't care about the other values. The internal `TrySkipPartial(int)` method does exactly what I need. Unfortunately, as the public `TrySkip` resets the state of the reader back to the state before skipping it doesn't allow for partial skipping. \nWhy was `TrySkipPartial(int)` not made a public API?\n\n### API Proposal\n\n```csharp\npublic class Utf8JsonReader\n{\n    public bool TrySkipPartial(int targetDepth);\n}\n```\n\n\n### API Usage\n\nhttps://github.com/dotnet/runtime/blob/3f25a276772b8d0e54452321e7525b7a176aa4a7/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/Converters/Object/ObjectWithParameterizedConstructorConverter.cs#L520\n\n### Alternative Designs\n\n_No response_\n\n### Risks\n\n_No response_",
    "number": 118310,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-08-03T20:06:36Z",
          "user": "PaulusParssinen"
        }
      ],
      "totalCount": 1,
      "endCursor": "Y3Vyc29yOnYyOpHODJqkig=="
    },
    "updatedAt": "2025-08-04T20:33:34Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": "dotnet-policy-service",
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. -->",
          "createdAt": "2025-08-03T02:35:16Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-08-03T02:35:16Z",
          "id": "IC_kwDODI9FZc67kkua"
        },
        {
          "author": "MihuBot",
          "body": "Possible related and/or duplicate issues:\n- https://github.com/dotnet/runtime/issues/96559\n- https://github.com/dotnet/runtime/pull/96856",
          "createdAt": "2025-08-03T02:36:36Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-08-03T02:36:36Z",
          "id": "IC_kwDODI9FZc67kk1e"
        },
        {
          "author": "bbartels",
          "body": "@eiriktsarpalis Just to check, presumably there isn't any easy alternatives you are aware of? I am thinking of just using reflection to call this api, but would rather not do that 😅 ",
          "createdAt": "2025-08-04T16:13:52Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-08-04T16:13:52Z",
          "id": "IC_kwDODI9FZc671qgp"
        },
        {
          "author": "eiriktsarpalis",
          "body": "The implementation is fairly simple and uses public APIs, so it can easily be expressed as an extension method:\n\nhttps://github.com/dotnet/runtime/blob/e205daec03f5056e70f8e18d6d0e12e128530331/src/libraries/System.Text.Json/src/System/Text/Json/Reader/Utf8JsonReader.cs#L396-L431",
          "createdAt": "2025-08-04T17:05:58Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-08-04T17:05:58Z",
          "id": "IC_kwDODI9FZc672d2y"
        },
        {
          "author": "bbartels",
          "body": "Oh hang on, maybe this doesn't even do what I want it to do. Just looking at the implementation of [ConsumeNextTokenOrRollback](https://github.com/dotnet/runtime/blob/e205daec03f5056e70f8e18d6d0e12e128530331/src/libraries/System.Text.Json/src/System/Text/Json/Reader/Utf8JsonReader.cs#L1696) `Read` will also rollback if an incomplete value was found, is that right?\n\nWhat I specifically want is to be able to Skip over an entire value that is (potentially) partially in the buffer and not rollback if its termination wasn't found and allow for continuation during the next buffer segment. This is in the case of a big value not having to keep the entire buffer around.\n`TrySkipPartial` presumably doesn't accomplish that?\n\nEDIT: Actually i presume `ConsumeValue` is actually called. While it doesn't rollback, I imagine it will still require the buffer up until the start of the value as I am getting an exception when I only pass in the next buffer segment.\n\nJust to illustrate, this is the payloads i am processing:\n```\n{\n    \"somevalue\": \"<large_value>\",\n    \"propertyIActuallyCareAbout: \"value\"\n}\n```\n\nI want the fastest way of getting the value associated with the `propertyIActuallyCareAbout` and can discard any other properties.",
          "createdAt": "2025-08-04T17:22:46Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-08-04T17:30:58Z",
          "id": "IC_kwDODI9FZc6723Jq"
        },
        {
          "author": "Clockwork-Muse",
          "body": "Do you really need to write this parsing yourself?  What about just creating a single-purpose domain type with only the property you care about?  It will ignore \"unknown\" properties by default, so the parser would just skip it, and (assumedly) not even create any buffer to read it into.\n\nAlternatively, do something like create a custom deserializer.  This unfortunately still creates the slice over the buffer (so you can't ditch it early/entirely), but it would allow you to skip any further processing on it.",
          "createdAt": "2025-08-04T19:31:25Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-08-04T19:31:25Z",
          "id": "IC_kwDODI9FZc674QfE"
        },
        {
          "author": "bbartels",
          "body": "> Do you really need to write this parsing yourself?\n\nI wish I didn't, but both JsonDocument.Parse() and JsonSerializer.DeserializeAsync() mention that they read the stream to completion. I can terminate as soon as I found the property, which in the optimal case is available within the first 100 bytes of the payload.\nSadly the worst case where it is after the long property is unoptimised at the moment due to the lack of being able to partially skip a value.\n\n> but it would allow you to skip any further processing on it.\n\nMy current implementation already allows for this. The parsing is pretty straightforward",
          "createdAt": "2025-08-04T20:33:34Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-08-04T20:33:34Z",
          "id": "IC_kwDODI9FZc675MKC"
        }
      ],
      "totalCount": 7,
      "endCursor": "Y3Vyc29yOnYyOpHOu-TCgg=="
    },
    "url": "https://github.com/dotnet/runtime/issues/118310",
    "title": "[API Proposal]: Expose Utf8JsonReader TrySkipPartial"
  },
  {
    "author": "rampaa",
    "labels": [
      "bug",
      "area-System.Text.Json"
    ],
    "createdAt": "2025-08-04T16:17:00Z",
    "body": "### Description\n\nWhen deserializing a JSON stream, `JsonSerializer.DeserializeAsyncEnumerable<T>` throws a `System.Text.Json.JsonException` on data that appears to be perfectly valid. However, using the `JsonSerializer.DeserializeAsync<T>` method on the exact same stream succeeds without error.\n\nThe failure does not appear to be inherent to the JSON content itself; a minified version of the same data, or a smaller subset of the records, parses correctly with `DeserializeAsyncEnumerable`.\n\n### Reproduction Steps\n\n1. Download [Test.json](https://github.com/user-attachments/files/21580896/Test.json).\n\n2. Try deserializing it using the following code:\n\n    ```csharp\n    FileStream fileStream = File.OpenRead(jsonFilePath);\n    await using (fileStream.ConfigureAwait(false))\n    {\n        IAsyncEnumerable<ReadOnlyMemory<JsonElement>> jsonElementsEnumerable =\n            JsonSerializer.DeserializeAsyncEnumerable<ReadOnlyMemory<JsonElement>>(fileStream);\n    }\n    ```\n\n    You'll see the following exception:\n\n    ```\n    System.Text.Json.JsonException: 'The JSON value could not be converted to System.ReadOnlyMemory`1[System.Text.Json.JsonElement]. Path: $[1] | LineNumber: 2950 | BytePositionInLine: 10.'\n    ```\n\n3. Now try deserializing it using the following code:\n\n    ```csharp\n    FileStream fileStream = File.OpenRead(jsonFilePath);\n    await using (fileStream.ConfigureAwait(false))\n    {\n        ReadOnlyMemory<ReadOnlyMemory<JsonElement>> jsonElementsRom =\n            await JsonSerializer\n                .DeserializeAsync<ReadOnlyMemory<ReadOnlyMemory<JsonElement>>>(fileStream)\n                .ConfigureAwait(false);\n    }\n    ```\n\n    This time, it works without any errors.\n\n4. Finally, try deserializing the minified version of the same JSON file ([TestMinified.json](https://github.com/user-attachments/files/21581298/TestMinified.json)) using the same code as in step 2. Notice that it also works without any errors.\n\n\n### Expected behavior\n\n`DeserializeAsyncEnumerable` should successfully parse the JSON without throwing any exceptions. Whether the JSON file is minified or not should not affect the behavior of `DeserializeAsyncEnumerable`.\n\n### Actual behavior\n\n`DeserializeAsyncEnumerable` fails to parse the JSON file with the following exception, and its behavior is affected by whether the JSON file is minified:\n\n    ```\n    System.Text.Json.JsonException: 'The JSON value could not be converted to System.ReadOnlyMemory`1[System.Text.Json.JsonElement]. Path: $[1] | LineNumber: 2950 | BytePositionInLine: 10.'\n    ```\n\n### Regression?\n\n_No response_\n\n### Known Workarounds\n\nUsing `DeserializeAsync` instead of `DeserializeAsyncEnumerable`\n\n### Configuration\n\n> Which version of .NET is the code running on?\n\n.NET 9\n\n> What OS and version, and what distro if applicable?\n\nWindows 10 22H2\n\n> What is the architecture (x64, x86, ARM, ARM64)?\n\nx64\n\n### Other information\n\n_No response_",
    "number": 118346,
    "reactions": {
      "hasNextPage": false,
      "nodes": [],
      "totalCount": 0,
      "endCursor": null
    },
    "updatedAt": "2025-08-17T15:12:58Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": "eiriktsarpalis",
          "body": "I can't reproduce using .NET 9 and your sample data. Note that your repro isn't actually consuming the IAE so I updated it to this:\n```C#\nstring jsonFilePath = \"Test.json\";\nFileStream fileStream = File.OpenRead(jsonFilePath);\nawait using (fileStream.ConfigureAwait(false))\n{\n    IAsyncEnumerable<ReadOnlyMemory<JsonElement>> jsonElementsEnumerable =\n        JsonSerializer.DeserializeAsyncEnumerable<ReadOnlyMemory<JsonElement>>(fileStream);\n\n    int i = 0;\n    await foreach (ReadOnlyMemory<JsonElement> jsonElement in jsonElementsEnumerable.ConfigureAwait(false))\n    {\n        i++;\n    }\n\n    Console.WriteLine($\"Total JSON elements processed: {i}\");\n}\n```\nYielding\n```\nTotal JSON elements processed: 51\n```",
          "createdAt": "2025-08-05T08:56:00Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-08-05T08:56:00Z",
          "id": "IC_kwDODI9FZc68APIe"
        },
        {
          "author": "rampaa",
          "body": "@eiriktsarpalis sorry for the incomplete code example. Here's a repro project that should hopefully allow you to repro it:\n[IAsyncEnumerableBug.zip](https://github.com/user-attachments/files/21601970/IAsyncEnumerableBug.zip)\n\nHere's the dump file in case it's helpful:\nhttps://limewire.com/d/iBmD7#sIjtQFBpFX\n",
          "createdAt": "2025-08-05T14:33:04Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-08-05T14:33:04Z",
          "id": "IC_kwDODI9FZc68FN8l"
        },
        {
          "author": "eiriktsarpalis",
          "body": "I can reproduce. It seems to impact all async deserialization methods and not just IAsyncEnumerable. Minimal repro:\n```C#\nusing System.Text;\nusing System.Text.Json;\n\nstring json = File.ReadAllText(\"Test.json\");\nusing MemoryStream fileStream = new(Encoding.UTF8.GetBytes(json));\nvar result = await JsonSerializer.DeserializeAsync<List<Memory<JsonElement>>>(fileStream);\n\nint i = 0;\nforeach (var element in result!)\n{\n    i++;\n}\n\nConsole.WriteLine($\"Total JSON elements processed: {i}\");\n```\n\nWhat's weird is that I can only reproduce when the inner collection is either of type `Memory<JsonElement>` or `ReadOnlyMemory<JsonElement>`. It doesn't seem to repro with other collection types. I also wasn't able to create a smaller JSON payload reproducing the issue, nor was I able to induce the error using synthetic data.\n\n[Test.json](https://github.com/user-attachments/files/21603148/Test.json)",
          "createdAt": "2025-08-05T15:42:40Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-08-05T15:42:40Z",
          "id": "IC_kwDODI9FZc68GGVP"
        },
        {
          "author": "rampaa",
          "body": "Unfortunately, I have several JSON files that trigger this error. Test.json was my best attempt at isolating and minimizing the issue. I'm happy to share the other files as well if that would help in resolving the problem.",
          "createdAt": "2025-08-05T15:55:25Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-08-05T15:55:25Z",
          "id": "IC_kwDODI9FZc68GJ5J"
        },
        {
          "author": "eiriktsarpalis",
          "body": "If you could somehow share anything that is smaller, that would be very helpful.",
          "createdAt": "2025-08-05T15:59:14Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-08-05T15:59:14Z",
          "id": "IC_kwDODI9FZc68GK1Q"
        },
        {
          "author": "rampaa",
          "body": "Unfortunately, I wasn’t able to create a smaller JSON file that reproduces the issue.\n\nYou’ve probably already noticed this, but interestingly, even just changing the line endings in Test.json from LF to CRLF prevents the issue from occurring. I'm not sure if that helps narrow down the root cause, but I thought it was worth mentioning.",
          "createdAt": "2025-08-05T21:15:47Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-08-05T21:15:47Z",
          "id": "IC_kwDODI9FZc68JxUb"
        },
        {
          "author": "rampaa",
          "body": "I've just tried running the repro project with .NET 8 and I can't reproduce the problem with it. So this seems to be a regression introduced in .NET 9.",
          "createdAt": "2025-08-05T22:30:34Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-08-05T22:30:34Z",
          "id": "IC_kwDODI9FZc68KWGP"
        },
        {
          "author": "rampaa",
          "body": "Shouldn't this issue be marked as `regression-from-last-release`? I'm not sure if that would help to raise its priority, but I figured it was worth mentioning just in case.",
          "createdAt": "2025-08-17T15:12:58Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-08-17T15:12:58Z",
          "id": "IC_kwDODI9FZc6-Z2xi"
        }
      ],
      "totalCount": 8,
      "endCursor": "Y3Vyc29yOnYyOpHOvmdsYg=="
    },
    "url": "https://github.com/dotnet/runtime/issues/118346",
    "title": "JsonSerializer.DeserializeAsyncEnumerable fails on a valid JSON stream that DeserializeAsync handles correctly"
  },
  {
    "author": "m-nash",
    "labels": [
      "api-suggestion",
      "area-System.Text.Json",
      "needs-further-triage"
    ],
    "createdAt": "2025-08-04T22:17:15Z",
    "body": "### Background and motivation\n\nIn certain circumstances you may want to partially deserialize a json byte[] or pull out a slice of the json byte[].  If you know the object you can write a routine that can use Utf8JsonReader.Read to advance through the json structure until you get the spot you need but it would be nice if this was a generic routine.\n\nI would imagine we would have to adopt a specific format to indicate where in the json you want to advance to and [JsonPath](https://datatracker.ietf.org/doc/rfc9535/) seems like a good candidate.  The main drawbacks to this is this Advance method implies a single item you are finding so JsonPaths like `$.x.y[?(@.z<10)]` wouldn't necessarily work.  Single target JsonPaths would work though like `$.x.y[0].z`.\n\n\n### API Proposal\n\nThe API would be a new method / extension on Utf8JsonReader like this.\n\n```csharp\npublic ref struct Utf8JsonReader\n{\n    public bool Advance(string jsonPath)\n}\n```\n\nWe could have overloads that take ReadOnlySpan<byte> since this encoding to utf8 bytes will need to be done regardless to efficiently compare property name value spans between the JsonPath and the Utf8JsonReader.  We could also consider a new JsonPathReader as an overload.\n\n```csharp\npublic ref struct JsonPathReader\n{\n    public bool Read();\n    public JsonPathToken Current { get; }\n    \n}\n\npublic ref struct JsonPathToken\n{\n    public int TokenStartIndex { get; }\n    public JsonPathTokenType TokenType { get; }\n    public ReadOnlySpan<byte> ValueSpan { get; }\n\n    public JsonPathToken(JsonPathTokenType tokenType, int tokenStartIndex, ReadOnlySpan<byte> valueSpan = default)\n}\n```\n\n\n### API Usage\n\nSimple usage would be\n\n```csharp\nbyte[] json = GetJson();\nUtf8JsonReader reader = new(json);\nreader.Advance(\"$.x.y\");\n// reader is now at the PropertyName token of y\n```\n\nThe Advance method would have no opinion on what the user can / should do after it advances but some usages would be.\n\n## Get sub json to partial deserialize\n```csharp\nbyte[] json = GetJson();\nUtf8JsonReader reader = new(json);\nreader.Advance(\"$.x.y\");\n\n// skip the PropertyName token for y\nreader.Read();\n\n// I can now partially deserialize this value only\nMyModel model = JsonSerializer.Deserialize<MyModel>(ref reader);\n```\n\n## Get the raw bytes of the json represented by the jsonPath\n```csharp\nbyte[] json = GetJson();\nUtf8JsonReader reader = new(json);\nreader.Advance(\"$.x.y\");\n\n// skip the PropertyName token for y\nreader.Read();\n\nlong start = jsonReader.TokenStartIndex;\nreader.Skip();\nlong end = jsonReader.BytesConsumed;\n\n// I can now do things like send these raw bytes to a stream without ever needing to instantiate any objects\nReadOnlySpan<byte> partialJson = json.AsSpan((int)start, (int)(end - start));\n```\n\n## Remove an item from a json byte array\n```csharp\nbyte[] json = GetJson();\nUtf8JsonReader reader = new(json);\nreader.Advance(\"$.x.y\");\n\nlong endLeft = jsonReader.TokenStartIndex;\nreader.Skip();\nreader.Read();\nlong startRight = jsonReader.TokenStartIndex;\n\nbyte[] newJson = [.. json.AsSpan(0, (int)endLeft), .. json.AsSpan((int)startRight)];\n```\n\nThere are many more scenarios these are just a couple that my projects have.\n\n### Alternative Designs\n\nI think the tricky part here is the JsonPath.  We can hide the implementation of JsonPathReader by just taking in string, byte[], ReadOnlySpan<byte> which might allow for some flexibility on implementation in the future.\n\nNot sure if JsonPath is the right format to use given the fact that Advance is intended to work with single target JsonPath's but it is a well known format and it should be easy enough to convey in documentation / summary xml docs that its intended to work with single target only and if a multi-target is passed in it will stop on the first one and if you wanted to iterate through them all you could do.\n\n```csharp\nbyte[] json = GetJson();\nUtf8JsonReader reader = new(json);\nJsonPathReader pathReader = new(\"$.x.y[?(@.z<10)]\");\nwhile(reader.Advance(ref pathReader))\n{\n    //do something with each occurrence\n}\n```\n\nAn alternative to a new Advance method would be an overload to Read which took the JsonPath, but I feel like this makes the concept of Read more confusing.\n\n```csharp\npublic ref struct Utf8JsonReader\n{\n    public bool Read(string jsonPath)\n}\n```\n\n### Risks\n\n_No response_",
    "number": 118364,
    "reactions": {
      "hasNextPage": false,
      "nodes": [],
      "totalCount": 0,
      "endCursor": null
    },
    "updatedAt": "2025-08-31T16:22:34Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": "dotnet-policy-service",
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. -->",
          "createdAt": "2025-08-04T22:17:58Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-08-04T22:17:58Z",
          "id": "IC_kwDODI9FZc676E7v"
        },
        {
          "author": "eiriktsarpalis",
          "body": "One potential issue I'm seeing is that it will be difficult to reconcile absolute JSON paths with the relative, forward-only nature of `Utf8JsonReader`.  In order to be able to advance to an absolute JSON path, the reader must be able to know its current path which it currently does not. If we did add it to support this feature, it would necessarily need to be stored as a heap allocated reference which would break `Utf8JsonReader`'s copy-by-value checkpointing semantics.\n\nWe could alternatively consider a path scheme that works relatively to the current position of the reader. That would work better with `Utf8JsonReader` is designed, but it creates design questions w.r.t. partial/resumable deserialization: if `Advance` returns false because it ran out of data, then the relative path that was originally supplied now points to a different location.\n\nThis all makes me think that schemes like JSON path or JSON pointer are better suited for self-contained documents such as `JsonDocument` or `JsonNode`, and not forward-only readers.",
          "createdAt": "2025-08-05T08:47:01Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-08-05T08:47:01Z",
          "id": "IC_kwDODI9FZc68AHOr"
        },
        {
          "author": "m-nash",
          "body": "In my internal implementation I went a different route and I let the JsonPath drive the search so that Utf8JsonReader doesn't need to know.\n\nBasically scan tokens in the JsonPath and for each token you find, you advance the utf8jsonreader accordingly when you get to the end of the jsonpath you have reached the point that you were after.\n\nA prototype I was playing with as an internal extension method can be seen [here](https://github.com/Azure/azure-sdk-for-net/blob/additionalProperties/sdk/core/System.ClientModel/src/ModelReaderWriter/JsonPathReaderExtensions.cs#L195).\n\nIt only supports a subset of JsonPath syntax but the basic single target paths work with this implementation.",
          "createdAt": "2025-08-05T15:17:52Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-08-12T18:26:58Z",
                "user": "KrzysztofCwalina"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOEeCSmw=="
          },
          "updatedAt": "2025-08-05T22:41:08Z",
          "id": "IC_kwDODI9FZc68F1g7"
        }
      ],
      "totalCount": 3,
      "endCursor": "Y3Vyc29yOnYyOpHOvBdYOw=="
    },
    "url": "https://github.com/dotnet/runtime/issues/118364",
    "title": "[API Proposal]: Add Advance method on Utf8JsonReader"
  },
  {
    "author": "vsfeedback",
    "labels": [
      "bug",
      "area-System.Text.Json"
    ],
    "createdAt": "2025-08-05T10:31:12Z",
    "body": "_This issue has been moved from [a ticket on Developer Community](https://developercommunity.visualstudio.com/t/JsonSerializerSerialize-throws-StackOve/10935999)._\n\n---\n[severity:It's more difficult to complete my work]\nHaving a custom \"generic\" serializer that handles multiple types (including string) and then serializing a dictionary with string key makes the Serialize call to get stuck in a forever loop (with stack overflow exception as result). Perhaps a bit odd use case but I stumbled on it after converting from Newtonsoft to .NET so I just let you know in any case. My real use case is a bit more complicated as usual but this is what I could boil it down to:\n\n```C#\nusing System.Text.Json;\nusing System.Text.Json.Serialization;\n\nnamespace JsonSerializationTest\n{\n    // example minimal \"generic\" converter\n    public class GenericJsonConverter : JsonConverter<object> // using string here works but that is not an option for my real usecase\n    {\n        public override bool CanConvert(Type typeToConvert) => typeToConvert == typeof(string);\n        public override object Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => reader.GetString();\n        public override void Write(Utf8JsonWriter writer, object value, JsonSerializerOptions options) => writer.WriteStringValue(value.ToString());\n    }\n\n    public class Tests\n    {\n        [Test]\n        public void DoesNotWork()\n        {\n            var options = new JsonSerializerOptions();\n            options.Converters.Add(new GenericJsonConverter());\n            var value = new Dictionary<string, int> { { \"key\", 123 } };\n            Assert.That(() => JsonSerializer.Serialize(value, options), Throws.InstanceOf<StackOverflowException>());\n        }\n\n        [Test]\n        public void Works()\n        {\n            var options = new JsonSerializerOptions();\n            var value = new Dictionary<string, int> { { \"key\", 123 } };\n            Assert.DoesNotThrow(() => JsonSerializer.Serialize(value, options));\n        }\n    }\n}\n```\n\n\n---\n### Original Comments\n\n#### Feedback Bot on 14/07/2025, 09:07 AM: \n\n<p>We have directed your feedback to the appropriate engineering team for further evaluation. The team will review the feedback and notify you about the next steps.</p>\n",
    "number": 118381,
    "reactions": {
      "hasNextPage": false,
      "nodes": [],
      "totalCount": 0,
      "endCursor": null
    },
    "updatedAt": "2025-08-05T10:38:33Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": "dotnet-policy-service",
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. -->",
          "createdAt": "2025-08-05T10:31:52Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-08-05T10:31:52Z",
          "id": "IC_kwDODI9FZc68B-l6"
        },
        {
          "author": "eiriktsarpalis",
          "body": "I can reproduce, it appears to be an issue with how dictionary key serialization interacts with converters whose generic type doesn't match that of the serialized type. You could work around the issue either by making the converter be of type string, a[dopt the `JsonConverterFactory` pattern](https://learn.microsoft.com/en-us/dotnet/standard/serialization/system-text-json/converters-how-to#sample-factory-pattern-converter) for generic converters, or manually override the `WriteAsPropertyName` method:\n```C#\npublic class GenericJsonConverter : JsonConverter<object> // using string here works but that is not an option for my real usecase\n{\n    public override bool CanConvert(Type typeToConvert) => typeToConvert == typeof(string);\n    public override object Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) => reader.GetString();\n    public override void Write(Utf8JsonWriter writer, object value, JsonSerializerOptions options) => writer.WriteStringValue(value.ToString());\n    public override void WriteAsPropertyName(Utf8JsonWriter writer, [DisallowNull] object value, JsonSerializerOptions options) => writer.WritePropertyName(value.ToString());\n}\n```",
          "createdAt": "2025-08-05T10:38:23Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-08-05T10:38:23Z",
          "id": "IC_kwDODI9FZc68CD32"
        }
      ],
      "totalCount": 2,
      "endCursor": "Y3Vyc29yOnYyOpHOvAg99g=="
    },
    "url": "https://github.com/dotnet/runtime/issues/118381",
    "title": "JsonSerializer.Serialize throws StackOverflowException serializing dictionary with string key and object-converter that handles string"
  },
  {
    "author": "JulianRooze",
    "labels": [
      "api-suggestion",
      "area-System.Text.Json",
      "needs-further-triage"
    ],
    "createdAt": "2025-08-06T13:20:41Z",
    "body": "### Background and motivation\n\nWe'd like the ability to subscribe to an event upon encountering a property in the JSON that does not exist on the target type (for any arbitrary target type, generically). The motivation behind this is that we want to emit a warning that you're calling our API with unknown properties and are likely making a mistake somewhere. This is currently doable but very cumbersome with unnecessary overhead and bookkeeping. The only way to currently do this (unless I'm mistaken) is to register an extension data property and to let the runtime set the missing properties and their values into a dictionary. In practice this means keeping a `ConditionalWeakTable` of dictionaries that the unknown properties get stored into, and then I subscribe to the `OnDeserialized` event and check if the weak table has any missing properties for the object that was just deserialized and then we add a warning.\n\nThe current code that is required for this to the best of my knowledge:\n\n```csharp\npublic class CustomTypeResolver : IJsonTypeInfoResolver\n{\n  private readonly IJsonTypeInfoResolver _defaultResolver = new DefaultJsonTypeInfoResolver();\n\n  public JsonTypeInfo? GetTypeInfo(Type type, JsonSerializerOptions options)\n  {\n    var typeInfo = _defaultResolver.GetTypeInfo(type, options);\n\n    if (typeInfo?.Kind == JsonTypeInfoKind.Object)\n    {\n      if (!HasExtensionDataProperty(typeInfo))\n      {\n        AddWarningExtensionDataProperty(typeInfo, type);\n      }\n    }\n\n    return typeInfo;\n  }\n\n  \n  private static bool HasExtensionDataProperty(JsonTypeInfo typeInfo)\n  {\n    foreach (var prop in typeInfo.Properties)\n    {\n      if (prop.IsExtensionData)\n        return true;\n    }\n    return false;\n  }\n\n  private static void AddWarningExtensionDataProperty(JsonTypeInfo typeInfo, Type objectType)\n  {\n    var extensionDataProperty = typeInfo.CreateJsonPropertyInfo(\n      typeof(Dictionary<string, object>),\n      \"__extensionData\"\n    );\n\n    extensionDataProperty.Get = obj =>\n    {\n      GetExtensionDataDictionary(obj, out var dict);\n      return dict;\n    };\n\n    extensionDataProperty.Set = (obj, value) =>\n    {\n      if (value is Dictionary<string, object> dict)\n      {\n        _extensionDataStorage.AddOrUpdate(obj, dict);\n      }\n    };\n\n    extensionDataProperty.IsExtensionData = true;\n    typeInfo.Properties.Add(extensionDataProperty);\n    typeInfo.OnDeserialized = (obj) =>\n    {\n      if (GetExtensionDataDictionary(obj, out var dict) && dict.Count > 0)\n      {\n        foreach (var kvp in dict)\n        {\n          ExecutionEnvironment.Current.ExecutionContext.AddWarning(\n            $\"unknown_property:{kvp.Key}\",\n            $\"Property '{kvp.Key}' is not valid for type '{objectType.Name}'\"\n          );\n        }\n      }\n    };\n  }\n\n  private static readonly ConditionalWeakTable<object, Dictionary<string, object>> _extensionDataStorage = new();\n\n  private static bool GetExtensionDataDictionary(object obj, out Dictionary<string, object>? dict)\n  {\n    if (!_extensionDataStorage.TryGetValue(obj, out dict))\n    {\n        return false;\n    }\n\n    return true;\n  }\n}\n```\n\nThis has additional overhead in the 99.99% case where there's no unknown properties in always calling the OnDeserialized event and checking the weak table.\n\nFor our purpose we'd like to be able to just do this:\n\n```csharp\npublic class CustomTypeResolver : IJsonTypeInfoResolver\n{\n  private readonly IJsonTypeInfoResolver _defaultResolver = new DefaultJsonTypeInfoResolver();\n\n  public JsonTypeInfo? GetTypeInfo(Type type, JsonSerializerOptions options)\n  {\n    var typeInfo = _defaultResolver.GetTypeInfo(type, options);\n\n    typeInfo.OnSkippedProperty = static (obj, propertyName, propertyValue) =>\n    {\n      ExecutionEnvironment.Current.ExecutionContext.AddWarning(\n            $\"unknown_property:{propertyName}\",\n            $\"Property '{propertyName}' is not valid for type '{obj.GetType()}'\"\n          );\n    };\n\n    return typeInfo;\n  }\n}\n```\n\nThis event would be fired only in the case where `UnmappedMemberHandling == JsonUnmappedMemberHandling.Skip` and no extension data was used. \n\n\n### API Proposal\n\n```csharp\npublic class JsonTypeInfo\n{\n  //...\n  public Action<object, string, object>? OnSkippedProperty { get; set; }\n}\n```\n\n### API Usage\n\n```csharp\ntypeInfo.OnSkippedProperty = static (obj, propertyName, propertyValue) =>\n{\n  ExecutionEnvironment.Current.ExecutionContext.AddWarning(\n        $\"unknown_property:{propertyName}\",\n        $\"Property '{propertyName}' is not valid for type '{obj.GetType()}'\"\n      );\n};\n```\n\n### Alternative Designs\n\nIt doesn't have to be defined on the JsonTypeInfo, but could also be a property on `JsonSerializerOptions`. And for our purpose we don't actually need the value of the property in the callback, we only need the name, but I suspect that for other purposes it would be useful to have.\n\n### Risks\n\nDepending on how this is implemented, you would likely need to update the current state with a new property in `JsonSerializer.LookupProperty` whenever a skipped property is encountered like this:\n\n```csharp\nstate.Current.IsSkippedProperty = true;\n```\n\nAnd this flag would then need to be checked when the property's value is deserialized, adding an if-branch. If only the property's name is emitted in the event (not the value) then all logic can be more contained inside the `JsonSerializer.LookupProperty` method and have a lower overhead. ",
    "number": 118444,
    "reactions": {
      "hasNextPage": false,
      "nodes": [],
      "totalCount": 0,
      "endCursor": null
    },
    "updatedAt": "2025-08-31T17:27:42Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": "dotnet-policy-service",
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. -->",
          "createdAt": "2025-08-06T13:23:25Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-08-06T13:23:25Z",
          "id": "IC_kwDODI9FZc68XEcL"
        }
      ],
      "totalCount": 1,
      "endCursor": "Y3Vyc29yOnYyOpHOvFxHCw=="
    },
    "url": "https://github.com/dotnet/runtime/issues/118444",
    "title": "[API Proposal]: Add OnSkippedProperty event to System.Text.Json's JsonTypeInfo class"
  },
  {
    "author": "agocke",
    "labels": [
      "api-approved",
      "area-System.Text.Json"
    ],
    "createdAt": "2025-08-06T22:07:21Z",
    "body": "### Background and motivation\n\nThere's already a `GetTypeInfo` method that takes a System.Type, but a really common case is to downcast to the generic version. This API makes it simple to perform the same operation without introducing potential errors.\n\n### API Proposal\n\n```csharp\nnamespace System.Text.Json;\n\npublic static class JsonSerializerOptionsExtensions\n{\n    public static System.Text.Json.Serialization.Metadata.JsonTypeInfo<T> GetTypeInfo<T>(this JsonSerializerOptions options) { throw null; }\n}\n```\n\n\n### API Usage\n\nSee, for example, https://github.com/dotnet/runtime/blob/8b082658f770e88f4383d332803799015d5c7836/src/libraries/System.Text.Json/src/System/Text/Json/Nodes/JsonNode.cs#L391\n\n```csharp\n// Old use\nvar info = (JsonTypeInfo<string>)options.GetTypeInfo(typeof(string));\n\n// New use\nvar info = options.GetTypeInfo<string>();\n```\n\n\n### Alternative Designs\n\n_No response_\n\n### Risks\n\n_No response_",
    "number": 118468,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "ROCKET",
          "createdAt": "2025-08-06T23:47:16Z",
          "user": "RenderMichael"
        },
        {
          "content": "ROCKET",
          "createdAt": "2025-08-07T06:21:25Z",
          "user": "nil4"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-08-07T15:38:44Z",
          "user": "martincostello"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-08-09T19:22:15Z",
          "user": "rabuckley"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-08-12T18:35:37Z",
          "user": "halter73"
        },
        {
          "content": "ROCKET",
          "createdAt": "2025-08-22T21:04:29Z",
          "user": "ArminShoeibi"
        },
        {
          "content": "ROCKET",
          "createdAt": "2025-08-28T01:11:24Z",
          "user": "AlgorithmsAreCool"
        }
      ],
      "totalCount": 7,
      "endCursor": "Y3Vyc29yOnYyOpHODM9rpA=="
    },
    "updatedAt": "2025-08-12T19:01:26Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": "dotnet-policy-service",
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. -->",
          "createdAt": "2025-08-06T22:08:17Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-08-06T22:08:17Z",
          "id": "IC_kwDODI9FZc68dPTV"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Why not just make it an instance method on the class directly?",
          "createdAt": "2025-08-07T06:40:38Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-08-07T06:40:38Z",
          "id": "IC_kwDODI9FZc68gxrz"
        },
        {
          "author": "agocke",
          "body": "Avoids taking any dependencies on internals, which shouldn't be needed.",
          "createdAt": "2025-08-07T21:36:37Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-08-07T21:36:37Z",
          "id": "IC_kwDODI9FZc68sq5A"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Not sure I follow, what internals do you have in mind?",
          "createdAt": "2025-08-08T08:19:50Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-08-08T08:19:50Z",
          "id": "IC_kwDODI9FZc68xDPs"
        },
        {
          "author": "agocke",
          "body": "Nothing specific. I don’t feel strongly about it, I just thought that convenience helpers are best placed as extensions, not regular members. The primary reason to use a regular member is to access private fields. If there is no access to private fields, extension members avoid introducing such a dependency. It’s also easier to move from extension member to regular member than vice versa. ",
          "createdAt": "2025-08-08T15:13:09Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-08-08T16:24:58Z",
                "user": "eiriktsarpalis"
              },
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-08-22T21:05:24Z",
                "user": "ArminShoeibi"
              }
            ],
            "totalCount": 2,
            "endCursor": "Y3Vyc29yOnYyOpHOEfUb2Q=="
          },
          "updatedAt": "2025-08-08T15:13:09Z",
          "id": "IC_kwDODI9FZc681-_w"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Sounds good, I'm sure it will be debated extensively during API review.",
          "createdAt": "2025-08-08T16:25:16Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-08-08T17:19:52Z",
                "user": "agocke"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOEdpdKg=="
          },
          "updatedAt": "2025-08-08T16:25:16Z",
          "id": "IC_kwDODI9FZc683A48"
        },
        {
          "author": "bartonjs",
          "body": "I'm pretty sure it's going to be an instance member :smile:",
          "createdAt": "2025-08-12T00:04:48Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-08-12T00:04:48Z",
          "id": "IC_kwDODI9FZc69YQSV"
        },
        {
          "author": "bartonjs",
          "body": "[Video](https://www.youtube.com/watch?v=BeoDUMLNAFw&t=1h14m21s)\n\n* The method should be an instance method instead of an extension method.\n* Let's go ahead and approve the Try at the same time.\n\n```c#\nnamespace System.Text.Json;\n\npublic partial class JsonSerializerOptions\n{\n    public JsonTypeInfo<T> GetTypeInfo<T>();\n    public bool TryGetTypeInfo<T>([NotNullWhen(true)] out JsonTypeInfo<T>? typeInfo);\n}\n```",
          "createdAt": "2025-08-12T18:36:19Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-08-12T19:01:26Z",
          "id": "IC_kwDODI9FZc69kyXy"
        }
      ],
      "totalCount": 8,
      "endCursor": "Y3Vyc29yOnYyOpHOvZMl8g=="
    },
    "url": "https://github.com/dotnet/runtime/issues/118468",
    "title": "[API Proposal]: JsonSerializerOptions.GetTypeInfo<T>"
  },
  {
    "author": "jamescourtney",
    "labels": [
      "api-suggestion",
      "area-System.Text.Json",
      "needs-further-triage"
    ],
    "createdAt": "2025-08-19T19:54:26Z",
    "body": "### Background and motivation\n\nMy project is maintained by ~1500 developers with over 200 C# projects. We rely heavily on:\n\n- System.Text.Json (with extensive use of polymorphism and source generators)\n- Immutable data types with primary constructors\n- ASP.NET Core\n- HttpClient\n- Nullable static analysis\n\nWe have recently become aware of `RespectNullableAnnotations` and `RespectRequiredConstructorParameters` in STJ. Our codebase predates .NET 9. Since we do not have these flags turned on today, our nullable analysis is suspect since we cannot trust the annotations on types we deserialize with STJ.\n\nWe would like to have a gradual migration to enable `RespectNullableAnnotations` and `RespectRequiredConstructorParameters`. Simply enabling them globally is not a good option as this is a production service. Further complicating this is that some of our dependencies such as MVC and CosmosDb simply want a single `JsonSerializerOptions` without the ability to toggle per-request or per-JSON operation.\n\nOur initial approach for this was to define a `RampUpJsonConverter<T> : JsonConverter<T>` that used a RNG to try strict serialization/deserialization options at a rate that wouldn't impact our SLA while emitting telemetry on failures. This is appealing because:\n- It allows different owners of different parts of the code to migrate at their own pace\n- It avoids us having to duplicate our code and contracts for both \"permissive\" and \"strict\" cases.\n\nHowever, it seems we are completely blocked by STJ with polymorphic types because `JsonConverter.CanHaveMetadata` is an internal property that gives us no way to override. The exception in STJ is thrown from [here](https://github.com/dotnet/runtime/blob/026b064ff4ab6f9ceff6aa417b0106b763437bb9/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/JsonConverter.MetadataHandling.cs#L38C41-L38C106).\n\nThe current stack also does not permit any workarounds or other hacks. The current implementation of `CanHaveMetadata` is just: `internal virtual bool CanHaveMetadata => false;`. This does not permit any reflection twiddling of a backing field or other workaround to unblock ourselves.\n\n### API Proposal\n\nThe simplest change is to change `CanHaveMetadata` from `internal` to `public`.\n\n### API Usage\n\n```csharp\npublic class MyConverter : JsonConverter<PolymorphicType>\n{\n     public override bool CanHaveMetadata => true;\n}\n```\n\n\n### Alternative Designs\n\nAlternatively, STJ could expose a new property on `JsonConverterFactory` that disables caching of the returned converter instances. \n\n```csharp\npublic abstract class JsonConverterFactory\n{\n    public virtual bool EnableCaching => true;\n   \n    public abstract JsonConverter? GetConverter(...);\n}\n```\n\nThis would allow a custom factory to implement a delegation pattern while owning caching itself internally. This doesn't work today because the output from JsonConverterFactory is always cached, which forces the RNG and strict/loose decision to be made in a custom `JsonConverter`, which then hits the blocker around `CanHaveMetadata`.\n\n### Risks\n\n_No response_",
    "number": 118900,
    "reactions": {
      "hasNextPage": false,
      "nodes": [],
      "totalCount": 0,
      "endCursor": null
    },
    "updatedAt": "2025-08-31T17:55:10Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": "dotnet-policy-service",
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. -->",
          "createdAt": "2025-08-19T19:55:17Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-08-19T19:55:17Z",
          "id": "IC_kwDODI9FZc6-2yF7"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Note that the `CanHaveMetadata` property is simply an internal marker meant for validation; changing it value has no bearing on whether the underlying converter actually supports polymorphism.\n\nToday, user-defined converters do not support polymorphism because the publicly available `Write` and `Read` methods do not accept serialization state parameters. Sharing serialization state is important in the context of polymorphism because you have two converters writing or reading from the same JSON object, so coordination becomes essential. Built-in converters work because they implement internal APIs to achieve this, however this capability is lost when these converters are wrapped inside a custom converter. There's an issue tracking support for making [state-passing converter methods accessible to users](https://github.com/dotnet/runtime/issues/63795), however we had the chance to prioritise this work so far.\n\n> Our initial approach for this was to define a RampUpJsonConverter<T> : JsonConverter<T> that used a RNG to try strict serialization/deserialization options at a rate that wouldn't impact our SLA while emitting telemetry on failures. \n\nWhy not create two separate `JsonSerializerOptions` instances with separate configurations and use an RNG to pick one of those? It sounds like it might achieve the same effect without faffing about with custom converters.",
          "createdAt": "2025-08-20T10:18:16Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-08-20T10:19:38Z",
          "id": "IC_kwDODI9FZc6_Dnnv"
        },
        {
          "author": "PranavSenthilnathan",
          "body": "I think the issue that @jamescourtney wants to avoid is having to change all the places where they currently cache a `JsonSerializerOptions` to store some other `JsonSerializerOptionsFactory` (which may not even be effective if someone then tries to cache the option they get from it instead of getting a randomized option every time).\n\nIs it possible for us to just remove the polymorphism restriction during configuration time and make it throw when it's used in an unsupported way? In the mentioned use case, since you're just forwarding to an internal converter at the top level, the wrapping converter won't ever need to support the internal stack based calls. But if someone does try to use it to serialize a nested polymorphic type then we can throw at that point.",
          "createdAt": "2025-08-20T19:00:37Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-08-20T19:00:37Z",
          "id": "IC_kwDODI9FZc6_MS7f"
        },
        {
          "author": "eiriktsarpalis",
          "body": "> I think the issue that @jamescourtney wants to avoid is having to change all the places where they currently cache a `JsonSerializerOptions` to store some other `JsonSerializerOptionsFactory` (which may not even be effective if someone then tries to cache the option they get from it instead of getting a randomized option every time).\n\nI still think that it's a less risky solution compared to injecting custom converters when previously built-in converters were being used. Because of how STJ works, changing from a built-in converter to a custom converter that wraps said built-in converter changes serialization behavior in subtle and multi-faceted ways. The `CanHaveMetadata` issue being cited here is just the tip of the iceberg.\n\n",
          "createdAt": "2025-08-21T07:12:27Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-08-21T07:12:27Z",
          "id": "IC_kwDODI9FZc6_ShOx"
        }
      ],
      "totalCount": 4,
      "endCursor": "Y3Vyc29yOnYyOpHOv0oTsQ=="
    },
    "url": "https://github.com/dotnet/runtime/issues/118900",
    "title": "[API Proposal]: Expose `JsonConverter.CanHaveMetadata`"
  },
  {
    "author": "Charlieface",
    "labels": [
      "api-suggestion",
      "area-System.Text.Json"
    ],
    "createdAt": "2025-08-27T19:50:23Z",
    "body": "### Description\n\nThe set of overloads for `JsonSerializer.DeserializeAsyncEnumerable` do not dispose the provided `Stream`, nor provide a way of configuring this. This should be classed as a bug (or at least very unexpected), as all other uses of `IEnumerable` and `IAsyncEnumerable` do dispose the inner collection or stream. The only example I could find that doesn't do this by default is `XmlSerializer`, although that is configurable, and `StreamReader` and many other classes that take a `Stream` offer a `bool leaveOpen` option as well, with `false` the default.\n\n### Reproduction Steps\n\nThe following code reproduces the issue, with a custom stream class that logs whether `Dispose` was called.\n```cs\nasync Task Main()\n{\n    await foreach (var i in GetStrings())\n        Console.WriteLine(i);\n}\n\nIAsyncEnumerable<string> GetStrings()\n{\n    var s = new MyStream(@\"[\"\"a\"\",\"\"b\"\"]\"u8.ToArray());\n    return JsonSerializer.DeserializeAsyncEnumerable<string>(s);\n}\n\nclass MyStream : MemoryStream\n{\n    public MyStream(byte[] array) : base(array)\n    {\n    }\n    \n    protected override void Dispose(bool disposing)\n    {\n        Console.WriteLine(\"Disposed\");\n        base.Dispose(disposing);\n    }\n\n    public override ValueTask DisposeAsync()\n    {\n        Console.WriteLine(\"Dispose async\");\n        return base.DisposeAsync();\n    }\n}\n```\n\n### Expected behavior\n\n\"Disposed\" should be logged to console\n\n### Actual behavior\n\nIt wasn't logged.\n\n### Regression?\n\n_No response_\n\n### Known Workarounds\n\nThis significantly complicates passing along an `IAsyncEnumerable`, it means you need to write a separate iterator function to safely dispose the stream, with all the extra compiler magic to make that happen.\n```cs\nasync IAsyncEnumerable<string> GetStrings2()\n{\n    using var s = new MyStream(@\"[\"\"a\"\",\"\"b\"\"]\"u8.ToArray());\n    await foreach (var str in JsonSerializer.DeserializeAsyncEnumerable<string>(s))\n        yield return str;\n}\n```\n\n### Configuration\n\n.NET 9 x64\n\n### Other information\n\nInside `JsonSerializer.DeserializeAsyncEnumerableCore` there is a local function `CreateAsyncEnumerableFromArray`, which finishes with:\n```cs\n                }\n                finally\n                {\n                    bufferState.Dispose();\n                }\n```\nThe `finally` just needs an extra line added\n```cs\n                    await utf8Json.DisposeAsync();\n```\nWhether this feature should be available only via an extra `bool` parameter, to keep the existing behaviour, is an open question. Arguably at least the default should be to dispose, because `JsonSerializer` eagerly reads beyond the end of the JSON, so makes little sense to keep it open any more.",
    "number": 119151,
    "reactions": {
      "hasNextPage": false,
      "nodes": [],
      "totalCount": 0,
      "endCursor": null
    },
    "updatedAt": "2025-08-29T13:29:20Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": "eiriktsarpalis",
          "body": "This is intentional: components should not try to dispose resources they do not own as is the case here. This leaves the option of disposing with the caller(s), in the most appropriate scope. Some older classes like `StreamReader` are disposing their underlying streams by default, but this was rectified by exposing the `leaveOpen` parameter in new constructor overloads. \n\nChanging the `JsonSerializer` behavior today would be a breaking change.",
          "createdAt": "2025-08-28T07:18:40Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-08-28T07:18:40Z",
          "id": "IC_kwDODI9FZc7AqC5m"
        },
        {
          "author": "Charlieface",
          "body": "@eiriktsarpalis \n\nDoes it at least make sense to at least offer `leaveOpen` as an option?\n\nMy point is: very often you *do* want the component to own the `Stream`, because disposing elsewhere is very difficult. Examples include returning `ActionResult` (you don't control when the server reads the content). And any case where you want to abstract out the creation of the containing class (eg `StreamReader` or `ZipArchive` which already offer `leaveOpen`), you would need to create an extra containing class just to hand around the stream to be disposed.\n\nAnd in this case, having to create the whole async state machine again just to dispose the stream seems pointless. So offering `leaveOpen` seems like a good idea, even if the default is unchanged.",
          "createdAt": "2025-08-28T11:54:58Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-08-28T11:54:58Z",
          "id": "IC_kwDODI9FZc7AtqdZ"
        },
        {
          "author": "eiriktsarpalis",
          "body": "I suppose it is something we could be exposing for the case `DeserializeAsyncEnumerable` only (but not the other `DeserializeAsync` methods). It would have to default to `true` though.",
          "createdAt": "2025-08-28T12:04:53Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-08-28T12:04:53Z",
          "id": "IC_kwDODI9FZc7Atyu4"
        },
        {
          "author": "Charlieface",
          "body": "@eiriktsarpalis \n\nI'm trying to find examples of constructors or functions which return a wrapper class, where `leaveOpen` would default to `true` (or not configurable) and I really can't find any.\n\n`TarReader`, `PipeReader` and `BrotliStream` are all relatively recent additions and do not leave open by default. The only examples I can find which do are functions which read the stream immediately and return, such as `XDocument.Load`, `NonCryptographicHashAlgorithm.Append`, `XPathDocument.ctor`, `AssemblyLoadContext.LoadFromStream`.\n\nCould you please give some examples of *wrapping* classes/functions which leave open by default?",
          "createdAt": "2025-08-29T12:49:38Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-08-29T12:49:38Z",
          "id": "IC_kwDODI9FZc7A77oj"
        },
        {
          "author": "eiriktsarpalis",
          "body": "We need have this default to true, because otherwise it would be a breaking change.",
          "createdAt": "2025-08-29T13:22:18Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-08-29T13:22:18Z",
          "id": "IC_kwDODI9FZc7A8R-1"
        }
      ],
      "totalCount": 5,
      "endCursor": "Y3Vyc29yOnYyOpHOwPEftQ=="
    },
    "url": "https://github.com/dotnet/runtime/issues/119151",
    "title": "JsonSerializer.DeserializeAsyncEnumerable does not dispose the stream"
  },
  {
    "author": "stephentoub",
    "labels": [
      "enhancement",
      "area-System.Text.Json",
      "source-generator"
    ],
    "createdAt": "2025-09-08T04:06:42Z",
    "body": "You have a base type that you serialize/deserialize with JsonSerializer.\nYou also use the JSON source generator.\nNow you add a new derived type from that base class and you mark the derived type as [Experimental].\n\nAnyone using your base class, even if they don't use the derived experimental type, now gets compilation errors stemming from the source generator emitting use of the derived [Experimental] type.",
    "number": 119451,
    "reactions": {
      "hasNextPage": false,
      "nodes": [],
      "totalCount": 0,
      "endCursor": null
    },
    "updatedAt": "2025-09-08T14:22:56Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": "dotnet-policy-service",
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. -->",
          "createdAt": "2025-09-08T04:11:25Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-09-08T04:11:25Z",
          "id": "IC_kwDODI9FZc7ClKf8"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Seems like it belongs in the same class of issues as https://github.com/dotnet/runtime/issues/101738 or https://github.com/dotnet/runtime/issues/76829? I wouldn't say this is an issue specific to polymorphism, it's a matter of the source generator walking a type graph and hitting a node that emits warnings. One possible solution we were debating in the past is letting the source generator emit user-defined suppressions, which would at least address any warnings that the generator induces.",
          "createdAt": "2025-09-08T06:42:18Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-09-08T06:42:18Z",
          "id": "IC_kwDODI9FZc7CmWNI"
        },
        {
          "author": "stephentoub",
          "body": "Have we considered just having the source generator emit `#pragma warning disable` at the top of every file?",
          "createdAt": "2025-09-08T13:24:07Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-09-08T13:24:07Z",
          "id": "IC_kwDODI9FZc7Cr74j"
        },
        {
          "author": "eiriktsarpalis",
          "body": "We could. We've been disabling them on an individual diagnostic id basis on account of potential source generator bugs going unnoticed, but I suppose one could argue that such warnings only matter if they translate to observable bugs when executing the code.",
          "createdAt": "2025-09-08T13:40:05Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-09-08T13:40:05Z",
          "id": "IC_kwDODI9FZc7CsSCQ"
        },
        {
          "author": "stephentoub",
          "body": "For the regex source generator, we now use individual suppressions when the source generator is built as debug and use the suppress-everything approach when it's built for release. I don't think there's anything meaningful about such warnings that a developer can do any more than they could for other bugs in the source generator; in release, they would seem to only serve as blocking noise. I think of them like asserts.",
          "createdAt": "2025-09-08T13:44:46Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-09-08T14:22:22Z",
                "user": "eiriktsarpalis"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOEhUVQw=="
          },
          "updatedAt": "2025-09-08T13:44:46Z",
          "id": "IC_kwDODI9FZc7CsXwW"
        },
        {
          "author": "eiriktsarpalis",
          "body": "Sounds good. We should probably do the same with CB.",
          "createdAt": "2025-09-08T14:22:50Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [
              {
                "content": "THUMBS_UP",
                "createdAt": "2025-09-08T14:23:47Z",
                "user": "stephentoub"
              }
            ],
            "totalCount": 1,
            "endCursor": "Y3Vyc29yOnYyOpHOEhUWSQ=="
          },
          "updatedAt": "2025-09-08T14:22:50Z",
          "id": "IC_kwDODI9FZc7Cs_7x"
        }
      ],
      "totalCount": 6,
      "endCursor": "Y3Vyc29yOnYyOpHOwrP-8Q=="
    },
    "url": "https://github.com/dotnet/runtime/issues/119451",
    "title": "[Experimental], JSON polymorphism, and the JSON source generator don't play well together"
  },
  {
    "author": "KrzysztofBranicki",
    "labels": [
      "api-suggestion",
      "area-System.Text.Json"
    ],
    "createdAt": "2025-09-19T13:10:44Z",
    "body": "### Background and motivation\n\nMy team stumbled on the similar issue which is described here [106392](https://github.com/dotnet/runtime/issues/106392), discussion under this issue is pretty lengthy so I won't be repeating every detail. What we want to achieve basically is to use nullability in our API contracts to express both the fact that certain parameter accepts null as a valid value and that it is optional (client should be able to omit it in his JSON request). Opposite is also true if the parameter is not marked as nullable, null value is not valid and it is required (can't be omitted in JSON request). By nullable parameters I mean both value types wrapped in `Nullable<T>` and reference types annotated with `?`.\n\nIt means that deserializing below class from empty JSON (`{}`) should succeed.\n```csharp\npublic class User\n{\n    public string? Name { get; }\n    \n    public User(string? name)\n    {\n        Name = name;\n    }\n}\n```\nand below should fail\n```csharp\npublic class User\n{\n    public string Name { get; }\n    \n    public User(string name)\n    {\n        Name = name;\n    }\n}\n```\n\nBased on what we can read [here](https://github.com/dotnet/runtime/issues/106392#issuecomment-2288863358) I understand that you don't want to fix the bug in `RespectNullableAnnotations` setting due to breaking change, even though this behavior may be misleading to many (to how many it is hard to know because this issue was closed so it can't be upvoted). In that context is it possible to add new setting `TreatNullableConstructorParametersAsOptional` which we would be able to use in combination with existing settings (`RespectNullableAnnotations` and `RespectRequiredConstructorParameters`) to achieve desired behavior? \n\n\n### API Proposal\n\n```csharp\nnew JsonSerializerOptions\n{\n    RespectNullableAnnotations = true,\n    RespectRequiredConstructorParameters = true,\n    TreatNullableConstructorParametersAsOptional = true //new setting\n}\n```\n\n### Alternative Designs\n\n_No response_\n\n### Risks\n\n_No response_",
    "number": 119892,
    "reactions": {
      "hasNextPage": false,
      "nodes": [
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-09-19T13:17:24Z",
          "user": "plachor"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-09-19T13:20:18Z",
          "user": "grsw92"
        },
        {
          "content": "THUMBS_UP",
          "createdAt": "2025-09-19T13:34:31Z",
          "user": "marekott"
        }
      ],
      "totalCount": 3,
      "endCursor": "Y3Vyc29yOnYyOpHODR6d-g=="
    },
    "updatedAt": "2025-09-19T18:23:29Z",
    "comments": {
      "hasNextPage": false,
      "nodes": [
        {
          "author": "dotnet-policy-service",
          "body": "Tagging subscribers to this area: @dotnet/area-system-text-json, @gregsdennis\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n<!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. -->",
          "createdAt": "2025-09-19T16:04:47Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-09-19T16:04:47Z",
          "id": "IC_kwDODI9FZc7FdOgC"
        },
        {
          "author": "eiriktsarpalis",
          "body": "FWIW you can already achieve this today using a [contract customizer](https://learn.microsoft.com/en-us/dotnet/standard/serialization/system-text-json/custom-contracts) that toggles off `JsonPropertyInfo.IsRequired` every time a parameter is found to be nullable (per the definition of nullable you are describing).",
          "createdAt": "2025-09-19T18:23:22Z",
          "reactions": {
            "hasNextPage": false,
            "nodes": [],
            "totalCount": 0,
            "endCursor": null
          },
          "updatedAt": "2025-09-19T18:23:22Z",
          "id": "IC_kwDODI9FZc7FfS0b"
        }
      ],
      "totalCount": 2,
      "endCursor": "Y3Vyc29yOnYyOpHOxX0tGw=="
    },
    "url": "https://github.com/dotnet/runtime/issues/119892",
    "title": "[API Proposal]: System.Text.Json new setting TreatNullableConstructorParametersAsOptional"
  }
]
