[
    {
        "url":  "https://github.com/dotnet/runtime/issues/14721",
        "createdAt":  "2015-06-15T23:58:00Z",
        "number":  14721,
        "author":  "tmat",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2024-07-25T17:04:41Z",
        "body":  "InitializeTableReaders method contains the following code:\n\n``` C#\n// Compute ref sizes for tables that can have pointer tables\n            int fieldRefSizeSorted = GetReferenceSize(rowCounts, TableIndex.FieldPtr) \u003e SmallIndexSize ? LargeIndexSize : GetReferenceSize(rowCounts, TableIndex.Field);\n            int methodRefSizeSorted = GetReferenceSize(rowCounts, TableIndex.MethodPtr) \u003e SmallIndexSize ? LargeIndexSize : GetReferenceSize(rowCounts, TableIndex.MethodDef);\n            int paramRefSizeSorted = GetReferenceSize(rowCounts, TableIndex.ParamPtr) \u003e SmallIndexSize ? LargeIndexSize : GetReferenceSize(rowCounts, TableIndex.Param);\n            int eventRefSizeSorted = GetReferenceSize(rowCounts, TableIndex.EventPtr) \u003e SmallIndexSize ? LargeIndexSize : GetReferenceSize(rowCounts, TableIndex.Event);\n            int propertyRefSizeSorted = GetReferenceSize(rowCounts, TableIndex.PropertyPtr) \u003e SmallIndexSize ? LargeIndexSize : GetReferenceSize(rowCounts, TableIndex.Property);\n```\n\nIt\u0027s not clear if any of these conditions are ever true. I\u0027d think that the size of XxxPtr table is always the same as the corresponding Xxx table, since the Ptr table is used as an index. It might make sense that XxxPtr table is smaller than the Xxx table. But I don\u0027t see how it can have more rows.\n\nDo we have tests that cover these?\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOhitzHw==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDI2MDAyMjI0Ng==",
                                           "createdAt":  "2016-11-11T18:25:56Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "karelz",
                                           "body":  "As next step: We need someone to look at the ECMA Metadata spec and compare to implementation, identify missing pieces and propose a list for review. More steps will follow (e.g. test coverage).\n",
                                           "updatedAt":  "2016-11-11T18:25:56Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5MLvrq",
                                           "createdAt":  "2022-10-13T20:31:14Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "steveharter",
                                           "body":  "@tmat do you have any more information on this? It should be investigated.",
                                           "updatedAt":  "2022-10-13T20:31:14Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6GK3Mf",
                                           "createdAt":  "2024-07-25T17:04:21Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "steveharter",
                                           "body":  "For reference, [here\u0027s a link to the code in question](https://github.com/dotnet/runtime/blob/07e95aab4583113dbdd80c26bbec3d535a6a554d/src/libraries/System.Reflection.Metadata/src/System/Reflection/Metadata/MetadataReader.cs#L576-L581).",
                                           "updatedAt":  "2024-07-25T17:04:21Z"
                                       }
                                   ],
                         "totalCount":  3
                     },
        "title":  "[MetadataReader] document format and constrains of -Ptr tables",
        "labels":  [
                       "investigate",
                       "enhancement",
                       "area-System.Reflection.Metadata",
                       "help wanted"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/16552",
        "createdAt":  "2016-03-01T01:12:49Z",
        "number":  16552,
        "author":  "nguerrera",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2022-08-03T23:59:46Z",
        "body":  "Currently, due to lack of time, some tests just check that we don\u0027t throw. A better approach would probably be to generically compare reflection CustomAttributeData to S.R.M CustomAttributeValue for every test attribute applied.\n\nAlso, there needs to be test cases for malformed custom attributes. Test coverage is at ~70% now with only positive cases.\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOR8ysxA==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDMyOTA3NTc4Mg==",
                                           "createdAt":  "2017-09-13T06:52:09Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "YongseopKim",
                                           "body":  "Anyone has worked for this issue? I\u0027m facing the wrong tc in System.Reflection.Metadata.Tests. (https://github.com/dotnet/corefx/issues/23937).\r\nIn short, the tc `System.Reflection.Metadata.Decoding.Tests.CustomAttributeDecoderTests.TestCustomAttributeDecoder` supposes that the first elem of `reader.GetCustomAttributes(typeDefHandle)` is `[Test]` which has no arguments. Contents of CustomAttributes are same to each other but orders of CustomAttributes are different. Therefore, I think the tc should be fixed to care unsorted CustomAttributes.\r\n\r\nThis [question](https://stackoverflow.com/questions/20582506/type-getcustomattributestattribute-returns-custom-attributes-in-random-order) has related the problem.",
                                           "updatedAt":  "2017-09-13T06:54:17Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5HzKzE",
                                           "createdAt":  "2022-08-03T23:59:46Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "buyaa-n",
                                           "body":  "Updated tests with https://github.com/dotnet/runtime/pull/72561. There is some inconsistency when Enum type used for constructor argument or named parameter. Most likely related to: https://github.com/dotnet/runtime/blob/bb3be81976a9c62289a4ff813f2407a7a1ab40e3/src/libraries/System.Reflection.Metadata/tests/Metadata/Decoding/CustomAttributeDecoderTests.cs#L357\r\nBecause sometimes it produces `System.Reflection.Metadata.Decoding.Tests.CustomAttributeDecoderTests+SByteEnum` or sometimes `System.Reflection.Metadata.Decoding.Tests.CustomAttributeDecoderTests/SByteEnum`\r\n\r\nLeaving this issue open to investigate that, some of the test attributes that causing this issue are commented out with reference to this issue.",
                                           "updatedAt":  "2022-08-03T23:59:46Z"
                                       }
                                   ],
                         "totalCount":  2
                     },
        "title":  "Improve custom attribute decoding tests",
        "labels":  [
                       "area-System.Reflection.Metadata",
                       "test-enhancement",
                       "help wanted"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/16724",
        "createdAt":  "2016-03-16T00:28:39Z",
        "number":  16724,
        "author":  "MichalStrehovsky",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-01-26T02:06:28Z",
        "body":  "The custom attribute parser allocates an ImmutableArray for FixedArguments and NamedArguments.\n\nWe should explore options to parse these lazily and avoid the array allocation.\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOm9EhKg==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDIyMzg0ODc0Nw==",
                                           "createdAt":  "2016-06-06T00:51:30Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "joshfree",
                                           "body":  "@tmat \n",
                                           "updatedAt":  "2016-06-06T00:51:30Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDI2MDAyNDYxOA==",
                                           "createdAt":  "2016-11-11T18:37:36Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "karelz",
                                           "body":  "Next step: We need real scenario demonstrating the perf issue, so that we can measure the improvement and if it is worth the effort.\r\nSteps afterword: Design API.\r\n\r\nNote: Roslyn scenario probably doesn\u0027t care says @tmat.\r\n",
                                           "updatedAt":  "2021-08-17T06:51:32Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDI2MDA0OTAyOQ==",
                                           "createdAt":  "2016-11-11T20:32:04Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "MichalStrehovsky",
                                           "body":  "\u003e We need real scenario demonstrating the perf issue\n\nThis is about API consistency. The rest of the APIs in S.R.Metadata tries hard to avoid allocations (which is why we chose to use it in the CoreRT compiler) and this one doesn\u0027t even try.\n\nIf it\u0027s not fixed, we might end up just not using S.R.Metadata\u0027s parser in CoreRT and roll our own. It\u0027s not rocket science and other people can do it too. It\u0027s a question of whether S.R.Metadata wants to be a one stop solution for people who want to read metadata without allocations or not.\n",
                                           "updatedAt":  "2016-11-11T20:32:04Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc41o3JN",
                                           "createdAt":  "2021-08-17T00:26:34Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOB2jyOA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "MichalStrehovsky",
                                                                               "createdAt":  "2021-08-17T01:35:45Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "joelverhagen",
                                           "body":  "\u003e Next step: We need real scenario demonstrating the perf issue, so that we can measure the improvement and if it is worth the effort.\r\nSteps afterword: Design API.\r\n\r\nRegarding this comment, I think an additional factor is not just performance but also edge case handling. There exists badly formatting DLLs (I have found several on NuGet.org) that have corrupted array length attributes causing one of these allocations to exceed many GBs of memory, per https://github.com/dotnet/runtime/issues/57531.\r\n\r\nI have been using System.Reflection.Metadata as a high performance DLL analysis tool and in nearly all places it processes DLLs with very low memory consumption. This problem appears to be an outlier from an API consistency standpoint.",
                                           "updatedAt":  "2021-08-17T00:26:34Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5NjrY5",
                                           "createdAt":  "2022-11-02T20:37:25Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "steveharter",
                                           "body":  "\u003e There exists badly formatting DLLs (I have found several on NuGet.org) that have corrupted array length attributes causing one of these allocations to exceed many GBs of memory, per https://github.com/dotnet/runtime/issues/57531.\r\n\r\nIn https://github.com/dotnet/runtime/issues/57531 I don\u0027t believe that the length was corrupted in the various assemblies, but that the code parsing the assemblies using S.R.Metadata did not properly look up the underlying Enum types (int, long, etc). Enum references are not expressed in metadata in a nice way where you can easily get the length -- you have to load the referenced type and inspect it.",
                                           "updatedAt":  "2022-11-02T20:37:25Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Njstu",
                                           "createdAt":  "2022-11-02T20:40:04Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "steveharter",
                                           "body":  "\u003e If it\u0027s not fixed, we might end up just not using S.R.Metadata\u0027s parser in CoreRT and roll our own\r\n\r\n@MichalStrehovsky I realize this is a super old issue, but do have any updates on its usage (NativeAOT)?",
                                           "updatedAt":  "2022-11-02T20:40:04Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5NkHaE",
                                           "createdAt":  "2022-11-02T21:32:22Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "MichalStrehovsky",
                                           "body":  "\u003e @MichalStrehovsky I realize this is a super old issue, but do have any updates on its usage (NativeAOT)?\r\n\r\nWe use the existing APIs that allocate ImmutableArrays",
                                           "updatedAt":  "2022-11-02T21:32:22Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6b0SEq",
                                           "createdAt":  "2025-01-26T02:06:27Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "teo-tsirpanis",
                                           "body":  "One possible API would be this:\n\n### API proposal\n\n```csharp\nnamespace System.Reflection.Metadata;\n\npublic readonly partial struct CustomAttribute\n{\n    public void DecodeValue\u003cTType, TArg\u003e(\n        ICustomAttributeTypeProvider\u003cTType\u003e provider,\n        Action\u003cCustomAttributeTypedArgument\u003cT\u003e, TArg\u003e fixedArgumentAction,\n        Action\u003cCustomAttributeNamedArgument\u003cT\u003e, TArg\u003e namedArgumentAction,\n        TArg arg) /* Wherever supported */ where TArg : allows ref struct;\n}\n```\n\n### API usage\n\n```csharp\nCustomAttribute attr;\nattr.DecodeValue(myProvider,\n    x =\u003e Console.WriteLine($\"Fixed argument {x.Name}: {x.Value}\"),\n    x =\u003e Console.WriteLine($\"Named {x.Kind} argument {x.Name}: {x.Value}\"));\n```\n\n### Alternative Designs\n\n* Make the delegates optional if a user doesn\u0027t care about fixed or named arguments?\n* Use an `ICustomAttributeValueVisitor\u003cTType\u003e` interface instead of delegates?\n* Have the delegates return a boolean and stop the traversal if it returns false?\n\n### Risks\n\nWill this solve the performance problems? This API still allocates for the arguments\u0027 name and value, and also note that this [is not the only API in SRM](https://learn.microsoft.com/en-us/dotnet/api/system.reflection.metadata.iconstructedtypeprovider-1.getgenericinstantiation) that allocates immutable arrays.\n\nA more comprehensive solution to this would be an object model API for custom attribute arguments and signatures that would obviate the need for the `I***TypeProvider` interfaces, but that would be quite more work.\n\nAs a workaround, those with higher performance requirements can copy the code of [`CustomAtributeDecoder`](https://github.com/dotnet/runtime/blob/1084c54e1668f199a93d1f4bab5162ee3ea48c8e/src/libraries/System.Reflection.Metadata/src/System/Reflection/Metadata/Ecma335/CustomAttributeDecoder.cs) and adapt it to their needs; the file uses public APIs almost everywhere.",
                                           "updatedAt":  "2025-01-26T02:06:27Z"
                                       }
                                   ],
                         "totalCount":  8
                     },
        "title":  "System.Reflection.Metadata: Avoid allocations in custom attribute parser",
        "labels":  [
                       "enhancement",
                       "area-System.Reflection.Metadata",
                       "tenet-performance",
                       "help wanted"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/23234",
        "createdAt":  "2017-08-17T23:16:14Z",
        "number":  23234,
        "author":  "nguerrera",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOAebK7Q==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "safern",
                                            "createdAt":  "2017-08-17T23:17:55Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "jnm2",
                                            "createdAt":  "2017-08-18T00:24:48Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "jp2masa",
                                            "createdAt":  "2018-07-08T23:11:37Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Misiu",
                                            "createdAt":  "2018-11-05T09:05:23Z"
                                        }
                                    ],
                          "totalCount":  4
                      },
        "updatedAt":  "2025-03-01T23:04:36Z",
        "body":  "The metadata reader does not currently provide an easy way to get at the content of an embedded resource.\r\n\r\n# First draft API proposal\r\n``` C#\r\nnamespace System.Reflection.Metadata\r\n{\r\n    public static class PEReaderExtensions // existing class\r\n    {\r\n       // new API\r\n       Stream GetEmbeddedResourceStream(this PEReader peReader, ManifestResource resource);\r\n    }\r\n}\r\n```\r\n\r\n# Sample implementation \r\n\r\nhttps://gist.github.com/nguerrera/6864d2a907cb07d869be5a2afed8d764\r\n\r\n* DISCLAIMER: I wrote that a long time ago against pre-release API and did not re-test after simply fixing compilation errors. \r\n  * Update: @safern got it working for him after one fix he sent me that I\u0027ve applied to the gist.\r\n* InvalidDataException should be BadImageFormatException as should any arithmetic overflow caused by bad data.\r\n* We can make the code safer by using BlobReader for more than just the length. It was written before there was `PEMemoryBlock.GetReader()` and the use of BlobReader used to be direct pointer indirection, and I just changed it locally to fix an endianness bug (at the time S.R.M threw on big endian).\r\n\r\n# See also\r\nhttps://github.com/Microsoft/msbuild/pull/2254#discussion_r129891209\r\n\r\n# Open questions \r\n\r\n#* Is `Stream` the right return type? That is what msbuild asked for and was also most convenient for me when I wrote that code a while ago. Should we have other overloads, PEMemoryBlock, ImmutableArray\u003cbyte\u003e, byte[], BlobReader? We have a mix for other similar things and don\u0027t directly provide Streams. Maybe we just need ToStream() helper on PEMemoryBlock or BlobReader instead?\r\n\r\ncc @rainersigwald @ericstj @tmat\r\n\r\n\r\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOoHsJtw==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDMyMzIyMDM4Mg==",
                                           "createdAt":  "2017-08-17T23:25:12Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "nguerrera",
                                           "body":  "Re question: Actually, these API are all begging to be `ReadOnlySpan\u003cbyte\u003e`, aren\u0027t they? cc @stephentoub",
                                           "updatedAt":  "2017-08-17T23:28:03Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDMyMzIyNDQwMQ==",
                                           "createdAt":  "2017-08-17T23:54:45Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tmat",
                                           "body":  "@nguerrera Wouldn\u0027t that require targeting netstandard2.0? Perhaps we could have 2 reference assemblies...",
                                           "updatedAt":  "2017-08-17T23:54:45Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDMyMzIyNTI0NA==",
                                           "createdAt":  "2017-08-18T00:01:10Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOAMYZEA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "tmat",
                                                                               "createdAt":  "2017-08-18T00:01:49Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "nguerrera",
                                           "body":  "@tmat I don\u0027t actually know what the implications of that dependency are. I thought there was going to be a slower implementation of spans for down-level. We should come up with a way to use them in S.R.M though, it would be helpful in both the public API and the implementation if possible.",
                                           "updatedAt":  "2017-08-18T00:01:10Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDMyMzIyNTI4Nw==",
                                           "createdAt":  "2017-08-18T00:01:30Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "nguerrera",
                                           "body":  "We should probably use a different tracking issue for Spans in S.R.M",
                                           "updatedAt":  "2017-08-18T00:01:30Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDMyMzIyNTM4OA==",
                                           "createdAt":  "2017-08-18T00:02:17Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tmat",
                                           "body":  "We might need ifdefs though :(",
                                           "updatedAt":  "2017-08-18T00:02:17Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQzNjAwMzU3NA==",
                                           "createdAt":  "2018-11-05T19:27:03Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Misiu",
                                           "body":  "@nguerrera I know this is a bit old issue, but it looks like this is needed to support Icons for controls that are distributed via NuGet (https://github.com/NuGet/Home/issues/6440#issuecomment-435424507). Any plans to add this to .NET Framework?",
                                           "updatedAt":  "2018-11-05T19:27:03Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ4NDQyNjI4MA==",
                                           "createdAt":  "2019-04-18T09:31:59Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Misiu",
                                           "body":  "@tmat  @nguerrera any updates on this?\r\nI think that not only I will be happy to be able to share my user controls via NuGet and have icons displayed.\r\n.NET Core 3.0 supports Winforms so this will be also very useful.",
                                           "updatedAt":  "2019-04-18T09:31:59Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ4NDQ4MTU3NA==",
                                           "createdAt":  "2019-04-18T12:19:19Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "nguerrera",
                                           "body":  "@misiu do you know where the code that would read this is and exactly how the icons are specified? If they\u0027re usually obtained via ResourceManager at runtime, there can be a security concern in that reading from .resources can deserialize arbitrary types. And if they\u0027re in win32 resources, then this api wouldn\u0027t be the starting point.",
                                           "updatedAt":  "2019-04-18T12:19:19Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ4NDQ4ODk3NA==",
                                           "createdAt":  "2019-04-18T12:39:47Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Misiu",
                                           "body":  "@nguerrera unfortunately not.\r\nBut I\u0027m wondering what would be the difference from choosing toolbox items inside VS (right click-\u003eChoose items...) and doing the same thing on runtime (after installing package from NuGet).\r\n\r\nMy main goal is to have icons displayed in toolbox when installing custom controls as NuGet packages.\r\nThis issue was referred here: https://github.com/NuGet/Home/issues/6440#issuecomment-435424507\r\n",
                                           "updatedAt":  "2019-04-18T12:39:47Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ4NDUwNDc5MQ==",
                                           "createdAt":  "2019-04-18T13:19:56Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ericstj",
                                           "body":  "So Toolbox items  in winforms define their icon with [ToolboxBitmapAttribute](https://docs.microsoft.com/en-us/dotnet/api/system.drawing.toolboxbitmapattribute?view=netframework-4.7.2).   If a control uses the Type overload than it indicates the image is in resources.  In desktop that means binary-formatted resources.  If VS wanted to make this work then it would have to use BF to deserialize those, which could result in loading user code.  Though VS could carry a copy of ResourceReader that constrained that behavior.  \r\n\r\nHere\u0027s a bit of code I wrote a year or so ago (I believe inspired by a sample you shared) https://gist.github.com/ericstj/b0e8537f29dabdd73f726e8fee0f49d6.  This demonstrates how to perform resource enumeration and it avoids instantiating types by just pulling the blob out.  Now VS could use that blob and pass it to a BinaryFormatter that will only instantiate a small set of types that would work for the ToolBox.\r\n\r\n@nguerrera with respect to your question around return value: stream is what would be needed to feed into ResourceReader.  It could be an UnmanagedMemoryStream or some internal stream that you have which points to memory and avoids unnecessary allocations.\r\n\r\n/cc @mgoertz-msft ",
                                           "updatedAt":  "2019-04-18T13:19:56Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ4NDU4ODQ4NA==",
                                           "createdAt":  "2019-04-18T16:47:29Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "mgoertz-msft",
                                           "body":  "Interesting, that\u0027s certainly worth trying out at some point. @Misiu I would suggest that you create a feedback ticket for this through VS so it gets tracked in our work item tracking system in VS. That way it can also get upvoted, which would increase the priority of this investigation. Please mention my name somewhere in the description or add the link here so I can find it and make sure it ends up in the right spot.",
                                           "updatedAt":  "2019-04-18T16:47:29Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY1MTMyMDM0NA==",
                                           "createdAt":  "2020-06-29T19:41:57Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ericstj",
                                           "body":  "Moving to future.  This is not blocking and it can be implemented with samples provided.",
                                           "updatedAt":  "2020-06-29T19:41:57Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc43GkeA",
                                           "createdAt":  "2021-09-21T23:50:12Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jnm2",
                                           "body":  "Does the existence of MetadataLoadContext (https://github.com/dotnet/runtime/issues/15033) change anything? I just used it to load an assembly and successfully call GetManifestResourceNames+GetManifestResourceStream.",
                                           "updatedAt":  "2021-09-21T23:50:12Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc43IxvN",
                                           "createdAt":  "2021-09-22T15:38:28Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOB7ZG3Q==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "jnm2",
                                                                               "createdAt":  "2021-09-22T18:22:40Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "ericstj",
                                           "body":  "The premise of this issue is about a convenience API.  MLC is an alternative but it requires some additional setup since it needs a type-universe.  Nothing about fetching a resource stream requires a type universe so I think it\u0027s valuable to have a convenience method at the SRM level.",
                                           "updatedAt":  "2021-09-22T15:38:28Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5lf8uC",
                                           "createdAt":  "2023-09-01T14:47:24Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ilCosmico",
                                           "body":  "I am attempting to create a NuGet package for a custom control on Net Framework 4.7.2. However, I am facing issues with the [ToolboxBitmapAttribute](https://docs.microsoft.com/en-us/dotnet/api/system.drawing.toolboxbitmapattribute?view=netframework-4.7.2) suggested by @ericstj , as it is not being displayed despite my attempts. I have also tried using the latest version of VS 2022 (v. 17.7.2) and specifying the file path but no luck on this. Any idea?\r\n![image](https://github.com/dotnet/runtime/assets/8678145/76954c45-8709-43a2-a9e0-0a0540971c90)\r\n",
                                           "updatedAt":  "2023-09-02T00:48:25Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5litGr",
                                           "createdAt":  "2023-09-02T00:47:50Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ericstj",
                                           "body":  "@ilCosmico it sounds like you\u0027re reporting some unrelated issue with ToolboxBitmapAttribute.  It would be better to open that as a new issue along with a repro project that demonstrates the problem.  I\u0027m going to mark this discussion as off-topic for this issue.",
                                           "updatedAt":  "2023-09-02T00:48:34Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6gewm3",
                                           "createdAt":  "2025-03-01T21:02:14Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "teo-tsirpanis",
                                           "body":  "I was thinking about this API:\n\n```csharp\nnamespace System.Reflection.PortableExecutable;\n\npublic class PEReader\n{\n   BlobReader GetEmbeddedResourceData(int offset);\n}\n```\n\nThe changes from the original proposal are:\n\n* Switched from extension method to instance method on `PEReader`.\n  * IIRC the framework design guidelines recommend against having extension methods on the same assembly as the type they are extending.\n* Changed return type from `Stream` to `BlobReader`.\n  * I think this is the best option for performance, flexibility and parity with the rest of SRM.\n    * If users want a stream, they can create an `UnmanagedMemoryStream` from the blob reader themselves, which will remind them that they have to deal with memory lifetime themselves.\n* Changed parameter from `ManifestResource` to `int`.\n  * Matches `PEReaderExtensions.GetMethodBody`.\n\n@dotnet/area-system-reflection-metadata thoughts?",
                                           "updatedAt":  "2025-03-01T23:04:36Z"
                                       }
                                   ],
                         "totalCount":  17
                     },
        "title":  "MetadataReader API for getting content of embedded resources",
        "labels":  [
                       "api-needs-work",
                       "area-System.Reflection.Metadata",
                       "help wanted"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/24568",
        "createdAt":  "2018-01-04T16:20:57Z",
        "number":  24568,
        "author":  "jnm2",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-07-26T10:32:39Z",
        "body":  "While rewriting PDBs (cloning a `MetadataReader` to a `MetadataBuilder`), I need to map old DocumentHandles to new DocumentHandles for each `SequencePoint.Document` in `MethodDebugInformation.GetSequencePoints()`.\r\n\r\nI need some way to serialize the modified SequencePoints back into a blob. Right now the only implementation of this is internal and part of Roslyn: https://github.com/dotnet/roslyn/blob/c273b6a9f19570a344c274ae89185b3a2b64d93d/src/Compilers/Core/Portable/PEWriter/MetadataWriter.PortablePdb.cs#L610-L687\r\n\r\nRather than forcing everyone to maintain their own implementation of the spec, please provide an API. \r\n\r\nSince I don\u0027t need access to the resulting blob except for the purposes of using it with `AddMethodDebugInformation`, this is the bare minimum I\u0027d need:\r\n\r\n```diff\r\nnamespace System.Reflection.Metadata.Ecma335\r\n{\r\n    public sealed class MetadataBuilder\r\n    {\r\n        public MethodDebugInformationHandle AddMethodDebugInformation(\r\n            DocumentHandle document, BlobHandle sequencePoints);\r\n\r\n+       public MethodDebugInformationHandle AddMethodDebugInformation(\r\n+           DocumentHandle document, IEnumerable\u003cSequencePoint\u003e sequencePoints);\r\n    }\r\n}\r\n```\r\n\r\nI\u0027d also need the `internal` SequencePoint constructors to become public.\r\n\r\nPerhaps an API that returns or writes a blob would be more flexible though. In that cause, I\u0027d simply add the blob to the builder myself and pass the resulting handle to `AddMethodDebugInformation` myself.\r\n  \r\n  ",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOpEtXbw==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY2NTc3MjIwNg==",
                                           "createdAt":  "2020-07-29T16:37:36Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ericstj",
                                           "body":  "cc @tmat \r\n\r\n@jnm2 do you still have interest in this feature?  It\u0027s too late for 5.0 but something that can be considered for 6.0.  If there\u0027s still interest would you mind filling out a formal [API proprosal](https://github.com/dotnet/runtime/blob/125dfe7ab4c0a93c48f94e2691b72d87288b86c7/docs/project/api-review-process.md#steps)? ",
                                           "updatedAt":  "2020-07-29T16:37:57Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY2NzI4MjY5Nw==",
                                           "createdAt":  "2020-07-31T18:20:47Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jnm2",
                                           "body":  "@ericstj Yes. Should I edit it into the original post or comment below?",
                                           "updatedAt":  "2020-07-31T18:20:47Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY2NzMwMTQ4NA==",
                                           "createdAt":  "2020-07-31T18:59:38Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ericstj",
                                           "body":  "Please edit original post.  Thanks!",
                                           "updatedAt":  "2020-07-31T18:59:38Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5xrJoY",
                                           "createdAt":  "2024-01-24T00:21:30Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "wasabii",
                                           "body":  "I would like this as well. Encoder and decoder.",
                                           "updatedAt":  "2024-01-24T00:21:30Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6kGw-X",
                                           "createdAt":  "2025-03-26T04:50:04Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "reflectronic",
                                           "body":  "System.Reflection.Metadata is missing encoders for all of the PPDB blob formats, not just sequence points: https://github.com/dotnet/runtime/blob/8be8425ce2a3e236bb647b59e29577e95cf571a3/src/libraries/System.Reflection.Metadata/src/System/Reflection/Metadata/Ecma335/Encoding/BlobEncoders.cs#L8\n\nIt would be best to propose encoders for all of the missing blob formats at once. \n\nA design that\u0027s more consistent with the spirit of System.Reflection.Metadata would expose a non-allocating `SequencePointsEncoder` hanging off of `BlobEncoder`, something like this:\n\n```cs\nnamespace System.Reflection.Metadata.Ecma335;\n\npublic partial readonly struct BlobEncoder\n{\n    public SequencePointsEncoder SequencePointsBlob(...);\n}\n\npublic readonly struct SequencePointsEncoder\n{\n    public SequencePointsEncoder(BlobEncoder encoder);\n\n    public void SequencePoint(...);\n    public void HiddenSequencePoint(...);\n    public void Document(...);\n}\n```\n\nUnfortunately, this design probably wouldn\u0027t be too nice to use. The sequence point blob format stores line/column/offset values as deltas from the previous sequence point. Since the encoders are stateless, they can\u0027t calculate these deltas automatically for the consumer. \n\n@tmat maybe you have ideas?",
                                           "updatedAt":  "2025-03-26T04:50:04Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6kMewn",
                                           "createdAt":  "2025-03-26T14:59:04Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tmat",
                                           "body":  "\u003e Unfortunately, this design probably wouldn\u0027t be too nice to use. \n\nGenerally, System.Reflection.Metadata design prefers high-performance, non-allocating APIs over convenience. Any convenience API can be implemented on top of SRM.\n\nThe encoder can have state if needed (in which case it wouldn\u0027t be `readonly`).\n\nC# compiler publishes source package with C# specific custom debug information encoders/decoders: \nhttps://www.nuget.org/packages/Microsoft.CodeAnalysis.Debugging/3.9.0-5.21120.8\n\nThe code comes from https://github.com/dotnet/roslyn/tree/main/src/Dependencies/CodeAnalysis.Debugging\n\nWhat is the use case for rewriting PDB?",
                                           "updatedAt":  "2025-03-26T14:59:04Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6kS1dv",
                                           "createdAt":  "2025-03-27T03:08:16Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "wasabii",
                                           "body":  "I am not the person who needs to REwrite PDBs, but I am one that needs to write them. So the encoder would be useful for me.\n\nhttps://github.com/ikvmnet/ikvm/blob/2df8f2cd485d6abba08c510b85f5902c0467e179/src/IKVM.Reflection/Emit/SequencePointEncoder.cs#L12",
                                           "updatedAt":  "2025-03-27T03:08:16Z"
                                       }
                                   ],
                         "totalCount":  7
                     },
        "title":  "SR.Metadata API to serialize sequence points as well as deserialize",
        "labels":  [
                       "api-suggestion",
                       "area-System.Reflection.Metadata"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/26096",
        "createdAt":  "2018-05-07T21:27:36Z",
        "number":  26096,
        "author":  "MichalStrehovsky",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-04-07T21:59:58Z",
        "body":  "Use System.Reflection.Metadata to emit the following:\r\n\r\n* A module with exactly 0xFFFF methods\r\n* The last type in the module has no methods\r\n\r\nThis will hit a corner case in the ECMA-335 spec where the TypeDef record for the last type should end up with a `MethodList` value of 0x10000, but per the spec, the `MethodList` column is only 2 bytes wide (because the method count fits in 2 bytes), making the value fall out of range.\r\n\r\nThis also affects other similar columns, such as TypeDef.FieldList, and MethodDef.ParamList.\r\n\r\nPer the spec, null might be a legal value to put there in that case.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOpfuM8Q==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5ML09y",
                                           "createdAt":  "2022-10-13T20:55:03Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "steveharter",
                                           "body":  "Edge case - 0xFFFF methods and then a type with no methods. I assume the current implementation detects this special case.",
                                           "updatedAt":  "2022-10-13T20:55:03Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5M49sg",
                                           "createdAt":  "2022-10-25T05:25:15Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "MichalStrehovsky",
                                           "body":  "\u003e Edge case - 0xFFFF methods and then a type with no methods. I assume the current implementation detects this special case.\r\n\r\nIt is not detected in the metadata emitters of desktop CLR or CoreCLR. It\u0027s how the deficiency was found by customers there. I would be pleasantly surprised if S.R.Metadata had a check for this.",
                                           "updatedAt":  "2022-10-25T05:25:15Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6b0QTt",
                                           "createdAt":  "2025-01-26T01:42:15Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "teo-tsirpanis",
                                           "body":  "Duplicate of #94892?",
                                           "updatedAt":  "2025-01-26T01:42:15Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6l-4zx",
                                           "createdAt":  "2025-04-07T21:59:57Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jzabroski",
                                           "body":  "\u003e Per the spec, null might be a legal value to put there in that case.\n\nSo, is this:\n\n1. a community request to add test coverage\n2. authority to then hard-pencil in the behavior to add a null byte here?\n\nA little interest from me. This is an annoying bug that crops up with CastleProxy every so often, particularly when using libraries like Moq and AutoMoq with AutoFixture.  Unless of course we take Miguel de Icaza\u0027s suggestion to throw out ECMA-335 and replace it with a sqlite database :-)",
                                           "updatedAt":  "2025-04-07T21:59:57Z"
                                       }
                                   ],
                         "totalCount":  4
                     },
        "title":  "Add test coverage for ECMA-335 corner around non-optional Lists",
        "labels":  [
                       "area-System.Reflection.Metadata",
                       "test-enhancement",
                       "help wanted"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/26440",
        "createdAt":  "2018-06-11T06:08:22Z",
        "number":  26440,
        "author":  "danmoseley",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2022-10-13T20:58:04Z",
        "body":  "During execution of my test, it attempted to execute invalid ref-emitted code. XUnit invoked Exception.GetStackTrace. This hit this assert\r\n```c#\r\n        internal MethodDebugInformation(MetadataReader reader, MethodDebugInformationHandle handle)\r\n        {\r\n            Debug.Assert(reader != null);\r\n            Debug.Assert(!handle.IsNil); // \u003c\u003c\u003c\u003c\u003c\u003c\r\n```\r\nwith the callstack below. this is because `MetadataTokens.Handle(methodToken);` returned a `Handle` with `IsNil` set to true. Perhaps this is because the methodToken is generated in memory, so there is no source information to read.\r\n\r\n```\r\n\u003e\tSystem.Private.CoreLib.dll!System.Diagnostics.Debug.Assert(bool condition, string message, string detailMessage) Line 107\tC#\tSymbols loaded.\r\n \tSystem.Reflection.Metadata.dll!System.Reflection.Metadata.MethodDebugInformation.MethodDebugInformation(System.Reflection.Metadata.MetadataReader reader, System.Reflection.Metadata.MethodDebugInformationHandle handle) Line 25\tC#\tSymbols loaded.\r\n \tSystem.Reflection.Metadata.dll!System.Reflection.Metadata.MetadataReader.GetMethodDebugInformation(System.Reflection.Metadata.MethodDebugInformationHandle handle) Line 1371\tC#\tSymbols loaded.\r\n \tSystem.Diagnostics.StackTrace.dll!System.Diagnostics.StackTraceSymbols.GetSourceLineInfo(string assemblyPath, System.IntPtr loadedPeAddress, int loadedPeSize, System.IntPtr inMemoryPdbAddress, int inMemoryPdbSize, int methodToken, int ilOffset, out string sourceFile, out int sourceLine, out int sourceColumn) Line 67\tC#\tSymbols loaded.\r\n \tSystem.Private.CoreLib.dll!System.Diagnostics.StackFrameHelper.InitializeSourceInfo(int iSkip, bool fNeedFileInfo, System.Exception exception) Line 135\tC#\tSymbols loaded.\r\n \tSystem.Private.CoreLib.dll!System.Diagnostics.StackTrace.CaptureStackTrace(int iSkip, bool fNeedFileInfo, System.Threading.Thread targetThread, System.Exception e) Line 203\tC#\tSymbols loaded.\r\n \tSystem.Private.CoreLib.dll!System.Diagnostics.StackTrace.StackTrace(System.Exception e, bool fNeedFileInfo) Line 110\tC#\tSymbols loaded.\r\n \tSystem.Private.CoreLib.dll!System.Environment.GetStackTrace(System.Exception e, bool needFileInfo) Line 346\tC#\tSymbols loaded.\r\n \tSystem.Private.CoreLib.dll!System.Exception.GetStackTrace(bool needFileInfo) Line 335\tC#\tSymbols loaded.\r\n \txunit.execution.dotnet.dll!Xunit.Sdk.ExceptionUtility.ConvertExceptionToFailureInformation(System.Exception ex, int parentIndex, System.Collections.Generic.List\u003cstring\u003e exceptionTypes, System.Collections.Generic.List\u003cstring\u003e messages, System.Collections.Generic.List\u003cstring\u003e stackTraces, System.Collections.Generic.List\u003cint\u003e indices) Line 175\tC#\tSymbols loaded.\r\n\r\n```\r\nIf I comment out the assert, I can get a stack:\r\n```\r\n   System.InvalidProgramException : JIT Compiler encountered an internal limitation.\r\n        Stack Trace:\r\n              at FindFirstChar282(RegexRunner )\r\n              at System.Text.RegularExpressions.CompiledRegexRunner.FindFirstChar()\r\n              at System.Text.RegularExpressions.RegexRunner.Scan(Regex regex, String text, Int32 textbeg, Int32 textend, Int32 textstart, Int32 prevlen, Boolean quick, TimeSpan timeout)\r\n```\r\n\r\nIf the code in System.Diagnostics.StackTrace and System.Reflection.Metadata is all working correctly here, then can we remove the assert? CoreFX tests are typically run with100% debug binaries.\r\n\r\n@tmat",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOTC9ZPA==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDM5NjEzMjcxOQ==",
                                           "createdAt":  "2018-06-11T06:11:54Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "danmoseley",
                                           "body":  "I am not sure why the line numbers don\u0027t appear for the non-ref-emit methods in the xunit output pasted above. In VS, they appear:\r\n```\r\n \t[Lightweight Function]\t\tAnnotated Frame\r\n\u003e\tSystem.Text.RegularExpressions.dll!System.Text.RegularExpressions.CompiledRegexRunner.FindFirstChar() Line 29\tC#\tSymbols loaded.\r\n \tSystem.Text.RegularExpressions.dll!System.Text.RegularExpressions.RegexRunner.Scan(System.Text.RegularExpressions.Regex regex, string text, int textbeg, int textend, int textstart, int prevlen, bool quick, System.TimeSpan timeout) Line 140\tC#\tSymbols loaded.\r\n \tSystem.Text.RegularExpressions.dll!System.Text.RegularExpressions.Regex.Run(bool quick, int prevlen, string input, int beginning, int length, int startat) Line 465\tC#\tSymbols loaded.\r\n \tSystem.Text.RegularExpressions.dll!System.Text.RegularExpressions.Regex.Match(string input, int startat) Line 115\tC#\tSymbols loaded.\r\n```\r\n\r\nSomething is not quite right though, because \"View Details\" on the exception popup gives me nothing:\r\n```\r\nSystem.InvalidProgramException\r\n  HResult=0x8013153A\r\n  Message=JIT Compiler encountered an internal limitation.\r\n  Source=\u003cCannot evaluate the exception source\u003e\r\n  StackTrace:\r\n\u003cCannot evaluate the exception stack trace\u003e\r\n```\r\n\r\nThe fact remains however that removing the assert gets me in a better state.",
                                           "updatedAt":  "2018-06-11T06:11:54Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDM5NjEzNTU3OQ==",
                                           "createdAt":  "2018-06-11T06:28:07Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tmat",
                                           "body":  "I agree the Asserts should be removed from constructors of all structs that represent metadata entities:\r\n\r\nAssemblyFile, AssemblyReference (`Debug.Assert(treatmentAndRowId != 0);`), Constant (`Debug.Assert(rowId != 0);`), CustomAttribute, ...\r\n\r\nUnit tests should be added that pass nil handles to factory methods on MetadataReader that call create the structs.\r\n\r\nThe methods on the structs created with nil handles should throw `BadImageFormatException`.",
                                           "updatedAt":  "2018-06-11T06:28:21Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDM5NjQxMDE2NQ==",
                                           "createdAt":  "2018-06-11T22:44:02Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "danmoseley",
                                           "body":  "@tmat just to clarify, is this something you plan to do or should it up for grabs?",
                                           "updatedAt":  "2018-06-11T22:44:02Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDM5NjQxMDM3Mg==",
                                           "createdAt":  "2018-06-11T22:45:07Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "danmoseley",
                                           "body":  "Also any thoughts about the missing line numbers after I removed the assert - which VS does show - and why the exception popup has `\u003cCannot evaluate the exception stack trace\u003e`? ",
                                           "updatedAt":  "2018-06-11T22:45:17Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDM5NjQxMzU3MQ==",
                                           "createdAt":  "2018-06-11T23:02:16Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tmat",
                                           "body":  "It could be \"up for grabs\". It\u0027s easy.\r\n\r\n`\u003cCannot evaluate the exception stack trace\u003e` not sure about that one. Is that evaluation in VS Watch Window? If you have a simple repro please file a bug on http://github.com/dotnet/roslyn/issues. \r\n\r\nThe line numbers might not appear due to this: https://github.com/dotnet/designs/blob/master/accepted/diagnostics/debugging-with-symbols-and-sources.md#stack-traces",
                                           "updatedAt":  "2018-06-11T23:02:27Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDM5NjQyMDMwOA==",
                                           "createdAt":  "2018-06-11T23:41:57Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "danmoseley",
                                           "body":  "thanks",
                                           "updatedAt":  "2018-06-11T23:41:57Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQxODQxNTM4Nw==",
                                           "createdAt":  "2018-09-04T15:38:35Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "IcanBENCHurCAT",
                                           "body":  "Watching this issue. I see jbhensley has a code change for this. Interested to see feedback on the code change, if there is any.",
                                           "updatedAt":  "2018-09-04T15:38:35Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQzNTQyOTY1OQ==",
                                           "createdAt":  "2018-11-02T16:05:42Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "karelz",
                                           "body":  "@jbhensley did you flow your changes back into CoreFX repo?",
                                           "updatedAt":  "2018-11-02T16:05:42Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQzNTQzNzMyNQ==",
                                           "createdAt":  "2018-11-02T16:31:45Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOAeXc1Q==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "karelz",
                                                                               "createdAt":  "2018-11-02T17:46:47Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "jbhensley",
                                           "body":  "No. I looked at this briefly, but went on to something else. Still an open issue.",
                                           "updatedAt":  "2018-11-02T16:31:45Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQzNTQ1NzY2MA==",
                                           "createdAt":  "2018-11-02T17:46:44Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "karelz",
                                           "body":  "Thanks for confirmation @jbhensley!",
                                           "updatedAt":  "2018-11-02T17:46:44Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDUzNjkyNDI5Mg==",
                                           "createdAt":  "2019-10-01T08:18:10Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "eugenesmlv",
                                           "body":  "Hi! I would like to take this issue as my first contribution. Is it still open?",
                                           "updatedAt":  "2019-10-01T08:18:10Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5ML1k8",
                                           "createdAt":  "2022-10-13T20:58:03Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "steveharter",
                                           "body":  "This still appears to be a valid issue, so open for contribution.",
                                           "updatedAt":  "2022-10-13T20:58:03Z"
                                       }
                                   ],
                         "totalCount":  12
                     },
        "title":  "Assert in MethodDebugInformation ctor when generating stack in invalid generated code",
        "labels":  [
                       "bug",
                       "area-System.Reflection.Metadata",
                       "good first issue",
                       "help wanted"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/27197",
        "createdAt":  "2018-08-22T18:48:33Z",
        "number":  27197,
        "author":  "tmat",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOAbA2yQ==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "nguerrera",
                                            "createdAt":  "2018-08-22T19:17:12Z"
                                        }
                                    ],
                          "totalCount":  1
                      },
        "updatedAt":  "2022-10-13T22:44:03Z",
        "body":  "```C#\r\npublic struct CustomAttribute \r\n{\r\n   public CustomAttributeValue\u003cobject\u003e DecodeValue()\r\n}\r\n```\r\n\r\nCommon use case for attribute value decoding is to retrieve a literal, e.g. a string. To do so the `ICustomAttributeTypeProvider\u003cTType\u003e provider` parameter is not necessary. Currently the user of the API has to define a dummy provider, which clutters the code. We can define and use the dummy provider internally and return CustomAttributeValue without type information. The dummy type provider can also throw if it encounters a type, to signal to the user that they need to pass a type provider.\r\n\r\n\r\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOTDCebA==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQxNTEzOTEwNQ==",
                                           "createdAt":  "2018-08-22T18:48:43Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tmat",
                                           "body":  "@nguerrera ",
                                           "updatedAt":  "2018-08-22T18:48:43Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQxNTE0Nzk3Mw==",
                                           "createdAt":  "2018-08-22T19:17:29Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "nguerrera",
                                           "body":  "I like this idea.",
                                           "updatedAt":  "2018-08-22T19:17:29Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQxNTE1NzUxNA==",
                                           "createdAt":  "2018-08-22T19:50:30Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "nguerrera",
                                           "body":  "Actually, the type provider is also used to specify the type of arguments, not just the value of arguments of type `Type`. So it can\u0027t just throw or you won\u0027t even be able to get string literals.\r\n\r\nAnother issue is that you can\u0027t read anything with an enum value in it unless the provider resolves the enum underlying type to determine how many bytes to read.",
                                           "updatedAt":  "2018-08-22T19:50:30Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQxNzczMzg0Mg==",
                                           "createdAt":  "2018-08-31T17:20:17Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jnm2",
                                           "body":  "\u003e Another issue is that you can\u0027t read anything with an enum value in it unless the provider resolves the enum underlying type to determine how many bytes to read.\r\n\r\nThis is something I have to solve over and over in every project that uses SR.Metadata. Would you consider adding an API which parses serialized type names into a type provider, and an API which resolves enum metadata in external assemblies given a user-implemented assembly file resolver?",
                                           "updatedAt":  "2018-08-31T17:21:39Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQxNzc3MDMzOA==",
                                           "createdAt":  "2018-08-31T19:42:59Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tmat",
                                           "body":  "\u003e an API which parses serialized type names into\r\n\r\nYes, decoding and encoding serialized type names would be useful. Could you file an issue?\r\n\r\n\u003e an API which resolves enum metadata in external assemblies given a user-implemented assembly file resolver\r\n\r\nNo, such API does not belong to System.Reflection.Metadata. \r\nhttps://github.com/dotnet/corefx/issues/2800 might be what you are looking for.",
                                           "updatedAt":  "2018-08-31T19:42:59Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQxNzg4MzIzMQ==",
                                           "createdAt":  "2018-09-01T19:51:47Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jnm2",
                                           "body":  "@tmat \r\n\r\n\u003e Yes, decoding and encoding serialized type names would be useful. Could you file an issue?\r\n\r\n opened: https://github.com/dotnet/corefx/issues/32067\r\n\r\n\u003e No, such API does not belong to System.Reflection.Metadata. dotnet/runtime#15033 might be what you are looking for.\r\n\r\nOkay, probably. dotnet/runtime#15033 seems like a heavyweight way to deal with a narrow problem, but it could be more widely useful too.",
                                           "updatedAt":  "2018-09-01T19:51:47Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQxNzg4MzU3MQ==",
                                           "createdAt":  "2018-09-01T19:57:25Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jnm2",
                                           "body":  "@nguerrera \r\n\r\n\u003e Another issue is that you can\u0027t read anything with an enum value in it unless the provider resolves the enum underlying type to determine how many bytes to read.\r\n\r\nIt just sunk in that changing the underlying type of an enum is one of the worst possible binary breaking changes for a library author. Attribute decoders will have no option but to read too much or too little and mess up everything that follows!\r\n\r\nChanging the underlying type of an enum doesn\u0027t get a mention at https://github.com/dotnet/corefx/blob/master/Documentation/coding-guidelines/breaking-change-rules.md. Should it?",
                                           "updatedAt":  "2018-09-01T19:57:47Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQxODQ2MTc5MA==",
                                           "createdAt":  "2018-09-04T17:58:34Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "nguerrera",
                                           "body":  "It should get a mention, yes. Attribute underlying types must not be changed.",
                                           "updatedAt":  "2018-09-04T17:58:34Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5ML4AU",
                                           "createdAt":  "2022-10-13T21:09:06Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "steveharter",
                                           "body":  "\u003e It just sunk in that changing the underlying type of an enum is one of the worst possible binary breaking changes for a library author. Attribute decoders will have no option but to read too much or too little and mess up everything that follows!\r\n\r\nThis has been updated in https://github.com/dotnet/runtime/blob/57bfe474518ab5b7cfe6bf7424a79ce3af9d6657/docs/coding-guidelines/breaking-change-rules.md#source-and-binary-compatibility-changes\r\n",
                                           "updatedAt":  "2022-10-13T21:09:06Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5MMJ5s",
                                           "createdAt":  "2022-10-13T22:44:03Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCuJnkg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "steveharter",
                                                                               "createdAt":  "2022-10-19T21:43:21Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "jnm2",
                                           "body":  "Yes, that was me in https://github.com/dotnet/corefx/pull/32123.",
                                           "updatedAt":  "2022-10-13T22:44:03Z"
                                       }
                                   ],
                         "totalCount":  10
                     },
        "title":  "Make type provider optional in CustomAttribute.DecodeValue",
        "labels":  [
                       "area-System.Reflection.Metadata"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/29511",
        "createdAt":  "2019-05-10T14:18:23Z",
        "number":  29511,
        "author":  "javiercn",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2022-10-17T18:13:15Z",
        "body":  "As part of building a feature in ASP.NET Core I was using System.Reflection.Metadata to crack an assembly and extract an embedded resource to validate its contents (in a test).\r\n\r\nI was using a snippet from https://github.com/dotnet/corefx/issues/23372 to do so, and I kept seeing a test fail intermittently on debug build on OS X in our CI build.\r\n\r\nIt seemed like sometimes it extracted the resource correctly and some other times it produced garbage. I was able to capture one of the generated assemblies that caused a test failure and I was able to produce a minimal repro (see below).\r\n\r\n[resourceextractor.zip](https://github.com/dotnet/corefx/files/3166808/resourceextractor.zip)\r\n\r\nUpon debugging the repro a bit, I could see that the code used to calculate the offset to the resources was not correct and it was pointing past the resources directory. I can think one of 3 things are happening:\r\n* **There is a bug in peReader.TryGetDirectoryOffset.**\r\n* **The generated assembly on Mac OS is somehow malformed.****\r\n* The code snippet I used is not correct in all cases. (I can\u0027t tell for sure because it\u0027s the first time I use the API).\r\n\r\n![image](https://user-images.githubusercontent.com/6995051/57533201-0d29b500-72f2-11e9-9959-32c43e4664a9.png)\r\n\r\nAny ideas?",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOTF7RqQ==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5MXtGp",
                                           "createdAt":  "2022-10-17T18:13:15Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "steveharter",
                                           "body":  "We need to see if this issue still occurs on OSX",
                                           "updatedAt":  "2022-10-17T18:13:15Z"
                                       }
                                   ],
                         "totalCount":  1
                     },
        "title":  "Problems reading embedded resources using system.reflection.metadata",
        "labels":  [
                       "area-System.Reflection.Metadata",
                       "help wanted"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/30443",
        "createdAt":  "2019-07-31T22:35:40Z",
        "number":  30443,
        "author":  "jnm2",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOCwt_fw==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "DRKV333",
                                            "createdAt":  "2023-06-15T15:19:58Z"
                                        }
                                    ],
                          "totalCount":  1
                      },
        "updatedAt":  "2022-06-16T23:06:10Z",
        "body":  "Rewriting IL using System.Reflection.Metadata seems to bit a bit of a mind-melting endeavor. Due to the order-dependent relations between the tables, and most binary blobs needing row references to be patched, I haven\u0027t been able to find a scalable pattern for a single-pass read and write. It feels like something like this should be in theory possible. Maybe with something like a visitor pattern?\r\n\r\nI\u0027d like to do some things that are purely additive, such as inserting a module initializer, and others that subtract or modify rows, like generating ref assemblies from third party framework implementation assemblies. Some of these things will slow down every build because I want to put them in post-processing NuGet packages, so one goal is absolutely minimal overhead.\r\n\r\nDoes this sound like something that can be made generally useful and that you\u0027d be willing to accept in SR.Metadata and keep up to date?",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHORQln3w==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDUxNzA2MjAxOQ==",
                                           "createdAt":  "2019-07-31T23:41:19Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "nguerrera",
                                           "body":  "This feels like the domain of a higher level API that can offer you a sort of DOM that you can read/edit/write. I think Mono.Cecil would be more appropriate.",
                                           "updatedAt":  "2019-07-31T23:41:19Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDUxNzA2MjgyNw==",
                                           "createdAt":  "2019-07-31T23:45:06Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOAym6Bw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "nguerrera",
                                                                               "createdAt":  "2019-07-31T23:46:34Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "weltkante",
                                                                               "createdAt":  "2019-10-13T19:12:19Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "tmat",
                                           "body":  "I agree with Nick\u0027s Mono.Cecil recommendation.\r\n\r\nThat said I have a prototype for a low-level code that efficiently hydrates PEBuilder from PEReader. It\u0027s however more complicated than it looks. The blocker at this point is the lack of representation for native resources on `PEReader`, which is needed in order to be able to round-trip assemblies. \r\n\r\n@jnm2 If you\u0027d like to help move it forward I would be happy to accept PR with support for native resource reading and serialization. This is also something that multiple other systems could use (e.g. we could remove the native resource serialization logic from Roslyn, F#, etc.). Just fair warning - it\u0027s likely quite a bit of work (including public API design).\r\n\r\nOnce the hydration is done there is of course the question of additions/updates. I don\u0027t think we want to support arbitrary metadata updates. That\u0027d mean building a DOM etc. and Mono.Cecil already does that. What would be potentially useful though would be the ability to apply EnC delta metadata after the MetadataBuilder has been hydrated from the reader. That might have some quite interesting applications.\r\n\r\n\r\n",
                                           "updatedAt":  "2019-07-31T23:46:18Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDUxNzA2NTM1NA==",
                                           "createdAt":  "2019-07-31T23:57:34Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jnm2",
                                           "body":  "Would you expect Mono.Cecil to be slower than hydrating a MetadataBuilder from a MetadataReader in one pass, skipping parts you want to remove?\r\n\r\nI don\u0027t think I want a DOM for this. If additions, modifications and deletions can be done in a general single-pass way with no intermediate representation between MetadataReader and MetadataBuilder, that\u0027s what I\u0027m after. Could that converge with your prototype, @tmat?",
                                           "updatedAt":  "2019-07-31T23:57:34Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDUxNzA2Njc2Nw==",
                                           "createdAt":  "2019-08-01T00:04:34Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tmat",
                                           "body":  "\u003e Would you expect Mono.Cecil to be slower than hydrating a MetadataBuilder from a MetadataReader in one pass, skipping parts you want to remove\r\n\r\nYes.\r\n\r\n\u003e If additions, modifications and deletions can be done in a general single-pass way with no intermediate representation between MetadataReader and MetadataBuilder, that\u0027s what I\u0027m after. \r\n\r\nI understand. Some operations can be done without DOM. It also depends what kind of APIs do you expect to be exposed for these operations. As I said, I can imagine an efficient API that applies EnC delta to a fully hydrated MetadataBuilder. I\u0027m guessing most of the operations you want to do could be encoded as an EnC delta.\r\n\r\nFirst step is to implement round-tripping. That\u0027s what my prototype is trying to do. And that itself is non-trivial.\r\n\r\n",
                                           "updatedAt":  "2019-08-01T00:04:34Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDUxNzA2OTU3OQ==",
                                           "createdAt":  "2019-08-01T00:18:59Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOC-DGBQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "DRKV333",
                                                                               "createdAt":  "2023-06-15T15:30:12Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "jnm2",
                                           "body":  "Could something like this be both generally useful and efficient? (uses Dictionary, could be swapped for a more efficient map)\r\n\r\n\u003cdetails\u003e\r\n\r\n```cs\r\npublic class MetadataVisitor\r\n{\r\n    private readonly Dictionary\u003cHandle, Handle\u003e handleMap = new Dictionary\u003cHandle, Handle\u003e();\r\n\r\n    protected MetadataVisitor(MetadataReader reader, MetadataBuilder builder)\r\n    {\r\n        Reader = reader;\r\n        Builder = builder ?? throw new ArgumentNullException(nameof(builder));\r\n    }\r\n\r\n    protected MetadataReader Reader { get; }\r\n    protected MetadataBuilder Builder { get; }\r\n\r\n    public void VisitAll()\r\n    {\r\n        VisitAssemblyDefinition();\r\n\r\n        foreach (var handle in Reader.AssemblyFiles)\r\n            VisitAssemblyFile(handle);\r\n\r\n        foreach (var handle in Reader.AssemblyReferences)\r\n            VisitAssemblyReference(handle);\r\n\r\n        foreach (var handle in Reader.CustomDebugInformation)\r\n            VisitCustomDebugInformation(handle);\r\n\r\n        // ...\r\n    }\r\n\r\n    private Handle MapHandle(Handle readerHandle, Func\u003cHandle, Handle\u003e visitor)\r\n    {\r\n        if (readerHandle.IsNil) return default;\r\n\r\n        if (!handleMap.TryGetValue(readerHandle, out var mappedHandle))\r\n            handleMap.Add(readerHandle, mappedHandle = visitor.Invoke(mappedHandle));\r\n\r\n        return mappedHandle;\r\n    }\r\n\r\n    public StringHandle MapString(StringHandle readerHandle)\r\n    {\r\n        return (StringHandle)MapHandle(readerHandle, h =\u003e\r\n            Builder.GetOrAddString(Reader.GetString((StringHandle)h)));\r\n    }\r\n\r\n    public GuidHandle MapGuid(GuidHandle readerHandle)\r\n    {\r\n        return (GuidHandle)MapHandle(readerHandle, h =\u003e\r\n            Builder.GetOrAddGuid(Reader.GetGuid((GuidHandle)h)));\r\n    }\r\n\r\n    public BlobHandle MapBlob(BlobHandle readerHandle)\r\n    {\r\n        return (BlobHandle)MapHandle(readerHandle, h =\u003e\r\n            Builder.GetOrAddBlob(Reader.GetBlobBytes((BlobHandle)h)));\r\n    }\r\n\r\n    public EntityHandle MapEntityHandle(EntityHandle readerHandle)\r\n    {\r\n        return readerHandle.Kind switch\r\n        {\r\n            HandleKind.AssemblyDefinition =\u003e EntityHandle.AssemblyDefinition,\r\n            HandleKind.AssemblyFile =\u003e (EntityHandle)MapAssemblyFile((AssemblyFileHandle)readerHandle),\r\n            HandleKind.AssemblyReference =\u003e MapAssemblyReference((AssemblyReferenceHandle)readerHandle),\r\n            HandleKind.CustomDebugInformation =\u003e MapCustomDebugInformation((CustomDebugInformationHandle)readerHandle),\r\n            _ =\u003e throw new NotImplementedException()\r\n        };\r\n    }\r\n\r\n    protected virtual AssemblyDefinitionHandle VisitAssemblyDefinition()\r\n    {\r\n        var assemblyDefinition = Reader.GetAssemblyDefinition();\r\n\r\n        return Builder.AddAssembly(\r\n            MapString(assemblyDefinition.Name),\r\n            assemblyDefinition.Version,\r\n            MapString(assemblyDefinition.Culture),\r\n            MapBlob(assemblyDefinition.PublicKey),\r\n            assemblyDefinition.Flags,\r\n            assemblyDefinition.HashAlgorithm);\r\n    }\r\n\r\n    public AssemblyFileHandle MapAssemblyFile(AssemblyFileHandle readerHandle)\r\n    {\r\n        return (AssemblyFileHandle)MapHandle(readerHandle, h =\u003e VisitAssemblyFile((AssemblyFileHandle)h));\r\n    }\r\n\r\n    protected virtual AssemblyFileHandle VisitAssemblyFile(AssemblyFileHandle readerHandle)\r\n    {\r\n        var assemblyFile = Reader.GetAssemblyFile(readerHandle);\r\n\r\n        return Builder.AddAssemblyFile(\r\n            MapString(assemblyFile.Name),\r\n            MapBlob(assemblyFile.HashValue),\r\n            assemblyFile.ContainsMetadata);\r\n    }\r\n\r\n    public AssemblyReferenceHandle MapAssemblyReference(AssemblyReferenceHandle readerHandle)\r\n    {\r\n        return (AssemblyReferenceHandle)MapHandle(readerHandle, h =\u003e VisitAssemblyReference((AssemblyReferenceHandle)h));\r\n    }\r\n\r\n    protected virtual AssemblyReferenceHandle VisitAssemblyReference(AssemblyReferenceHandle readerHandle)\r\n    {\r\n        var assemblyReference = Reader.GetAssemblyReference(readerHandle);\r\n\r\n        return Builder.AddAssemblyReference(\r\n            MapString(assemblyReference.Name),\r\n            assemblyReference.Version,\r\n            MapString(assemblyReference.Culture),\r\n            MapBlob(assemblyReference.PublicKeyOrToken),\r\n            assemblyReference.Flags,\r\n            MapBlob(assemblyReference.HashValue));\r\n    }\r\n\r\n    public CustomDebugInformationHandle MapCustomDebugInformation(CustomDebugInformationHandle readerHandle)\r\n    {\r\n        return (CustomDebugInformationHandle)MapHandle(readerHandle, h =\u003e VisitCustomDebugInformation((CustomDebugInformationHandle)h));\r\n    }\r\n\r\n    protected virtual CustomDebugInformationHandle VisitCustomDebugInformation(CustomDebugInformationHandle readerHandle)\r\n    {\r\n        var customDebugInformation = Reader.GetCustomDebugInformation(readerHandle);\r\n\r\n        return Builder.AddCustomDebugInformation(\r\n            MapEntityHandle(customDebugInformation.Parent),\r\n            MapGuid(customDebugInformation.Kind),\r\n            MapBlob(customDebugInformation.Value)); // Maybe this becomes invalid and should be dropped if not parsed?\r\n    }\r\n}\r\n```\r\n\r\n\u003c/details\u003e",
                                           "updatedAt":  "2019-08-01T00:20:15Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDUxNzA3MTAzNA==",
                                           "createdAt":  "2019-08-01T00:26:59Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tmat",
                                           "body":  "Copying the rows from reader to builder is the easy part. I already have very efficient code for that. It\u0027s not useful on its own though without the rest of the re-hydration code all the way up to PEReader, which includes native resources. ",
                                           "updatedAt":  "2019-08-01T00:26:59Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDUxNzA3MTQ3Ng==",
                                           "createdAt":  "2019-08-01T00:29:09Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tmat",
                                           "body":  "See https://github.com/tmat/corefx/tree/PERewriter",
                                           "updatedAt":  "2019-08-01T00:29:09Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDUxNzA3MTc5MA==",
                                           "createdAt":  "2019-08-01T00:30:41Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jnm2",
                                           "body":  "@tmat It sounds like your prototype starts by copying everything rather than planning for some things to be added, modified or skipped in the initial copy. I\u0027m not sure I see that as the most efficient way to add and modify and delete. How does deleting rows work when row handles are already serialized in blobs? Let\u0027s say for example that I want to strip out private types, modify private fields, and leave most tables uncopied altogether, but preserve attributes which are referencing many of the remaining types in the now-smaller table.\r\n\r\nDoes calculating an EnC diff solve this problem? Is calculating and applying that diff close enough in efficiency to only copying what is needed in the first place?\r\nYou know a lot more than I do. Sorry if these are dumb questions!",
                                           "updatedAt":  "2019-08-01T00:42:35Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDUxNzA3Mzc2OA==",
                                           "createdAt":  "2019-08-01T00:41:52Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tmat",
                                           "body":  "It\u0027s an early prototype :) Obviously, this requires more work. I started with the goal to roundtrip any assembly without modifying the metadata. Already turned out to be non-trivial problem.\r\n\r\n ",
                                           "updatedAt":  "2019-08-01T00:42:06Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5FCWff",
                                           "createdAt":  "2022-06-16T23:06:10Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "wasabii",
                                           "body":  "@tmat  Did anything become of your rewriter? I\u0027ve found myself in need of similar.",
                                           "updatedAt":  "2022-06-16T23:06:10Z"
                                       }
                                   ],
                         "totalCount":  10
                     },
        "title":  "Efficient API to stream from a MetadataReader to a MetadataBuilder with modifications",
        "labels":  [
                       "area-System.Reflection.Metadata",
                       "help wanted"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/34895",
        "createdAt":  "2020-04-13T11:38:17Z",
        "number":  34895,
        "author":  null,
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOBBBUEA==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "PaulusParssinen",
                                            "createdAt":  "2020-04-13T13:16:14Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "DaZombieKiller",
                                            "createdAt":  "2020-04-14T12:49:19Z"
                                        }
                                    ],
                          "totalCount":  2
                      },
        "updatedAt":  "2025-01-12T21:24:39Z",
        "body":  "## Background and Motivation\r\n\r\nThe PEReader class currently only supports Streams and ImmutableArray\u003cByte\u003e in a safe context and a   Byte* in an unsafe context. If working with the new API\u0027s (Span\u003cT\u003e / Memory\u003cT\u003e) you are required to make an unnecessary copy into an array of bytes before creating a Stream or ImmutableArray over the array to initialise a PEReader. It would be nice to see support for the new API\u0027s to avoid these unnecessary copies in modern code bases.\r\n\r\nNote that this stems from the fact that there isn\u0027t an existing overload for a standard array (rather, only an immutable array.)\r\n\r\n## Proposed API\r\n\r\n```csharp\r\npublic PEReader (System.ReadOnlyMemory\u003cbyte\u003e peImage);\r\n``` \r\n\r\n## Usage Examples\r\n\r\nAssume there exists an array of bytes in a code base that represents a portable executable. Then the following could be used to create a PEReader over the array of bytes without performing an unnecessary copy of the array (via an implicit cast.)\r\n\r\n\r\n```csharp\r\n\r\nbyte[] peBytes;\r\n\r\nPEReader peReader = new PeReader(peBytes);\r\n```\r\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOmiIIgQ==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDYxMzQyMjYzMA==",
                                           "createdAt":  "2020-04-14T12:48:52Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "DaZombieKiller",
                                           "body":  "I imagine that since `PEReader` is a reference type, it wouldn\u0027t be able to take a `Span\u003cbyte\u003e` without copying, but `Memory\u003cbyte\u003e` would probably be fine. In the absence of a built-in constructor taking a `Memory\u003cbyte\u003e` you can at least make use of the pointer constructor, if you manage the `MemoryHandle` as well:\r\n\r\n```cs\r\nunsafe void ReadPEFromMemory(ReadOnlyMemory\u003cbyte\u003e memory)\r\n{\r\n    using var handle = memory.Pin();\r\n    using var reader = new PEReader((byte*)handle.Pointer, memory.Length);\r\n    // do stuff\r\n}\r\n```",
                                           "updatedAt":  "2020-04-14T12:48:52Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDYxMzc0ODcwNQ==",
                                           "createdAt":  "2020-04-15T00:32:32Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "\u003e I imagine that since `PEReader` is a reference type, it wouldn\u0027t be able to take a `Span\u003cbyte\u003e` without copying, but `Memory\u003cbyte\u003e` would probably be fine. In the absence of a built-in constructor taking a `Memory\u003cbyte\u003e` you can at least make use of the pointer constructor, if you manage the `MemoryHandle` as well:\r\n\u003e \r\n\u003e ```cs\r\n\u003e unsafe void ReadPEFromMemory(ReadOnlyMemory\u003cbyte\u003e memory)\r\n\u003e {\r\n\u003e     using var handle = memory.Pin();\r\n\u003e     using var reader = new PEReader((byte*)handle.Pointer, memory.Length);\r\n\u003e     // do stuff\r\n\u003e }\r\n\u003e ```\r\n\r\nI understand it would be possible using unsafe code, but in my many cases, consumers may not want to compile their code bases with the unsafe flag, hence, they would need to perform the copy if they were using Memory\u003cT\u003e instead of a regular array (or immutable array) to represent the PE in question.",
                                           "updatedAt":  "2020-04-15T00:32:32Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY4MTE2ODU0OQ==",
                                           "createdAt":  "2020-08-26T23:06:33Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ericstj",
                                           "body":  "cc @tmat \r\n\r\nAs was mentioned this cannot work with Span unless the constructor copies, at which point it probably negates the value.  From where would you get a ReadOnlyMemory\u003cbyte\u003e that you could pass to this without actually writing the unsafe code typically needed to implement this.\r\n\r\nIOW, what scenario are you envisioning benefits from this API?  We don\u0027t usually add an API unless there is a clear end-to-end scenario that would benefit from its addition.",
                                           "updatedAt":  "2020-08-26T23:06:33Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY4MTE5OTQ2OQ==",
                                           "createdAt":  "2020-08-27T00:56:03Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "There are many scenarios that yield a regular byte array i.e. `WebClient.DownloadData` that could represent the bytes of a portable executable. Currently, if you have a regular byte array and want to use the `PEReader` class, you need to perform a copy as mentioned above. If there was an overload for a `ReadOnlyMemory`, an implicit cast could be used to avoid this copy.\r\n\r\nFurthermore, going forward with .Net, would it not make sense to support the newer API\u0027s such as `ReadOnlyMemory`?",
                                           "updatedAt":  "2020-08-27T00:56:03Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY4MzQ0MTA4MA==",
                                           "createdAt":  "2020-08-30T16:29:28Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ericstj",
                                           "body":  "I see, I missed that we didn\u0027t have any overloads that take an Array today.  Sure this seems like a reasonable request.  Care to turn this into an API proposal?  ",
                                           "updatedAt":  "2020-08-30T16:29:28Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY4MzQ4MjM0OQ==",
                                           "createdAt":  "2020-08-30T23:06:28Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "As in create a new issue and reference this one?",
                                           "updatedAt":  "2020-08-30T23:06:35Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY4MzQ4MzkwMw==",
                                           "createdAt":  "2020-08-30T23:19:52Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "davidfowl",
                                           "body":  "Edit the original text to contain the specific API you want and some usage examples (there\u0027s an issue template you can use)",
                                           "updatedAt":  "2020-08-30T23:19:52Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY4MzY0NjY0Mw==",
                                           "createdAt":  "2020-08-31T08:36:23Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "@ericstj @davidfowl I\u0027ve performed the edits, can you let me know if any additional information needs to be provided?",
                                           "updatedAt":  "2020-08-31T08:36:23Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5MvGsR",
                                           "createdAt":  "2022-10-21T20:40:41Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "steveharter",
                                           "body":  "Still considering this for 8.0 - we may create a \"Spanify more APIs\" theme.",
                                           "updatedAt":  "2022-10-21T20:40:41Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6aIgiB",
                                           "createdAt":  "2025-01-12T21:24:29Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "teo-tsirpanis",
                                           "body":  "For completeness we also need these APIs:\n\n```csharp\nnamespace System.Reflection.Metadata;\n\npublic partial class MetadataReaderProvider\n{\n    public static MetadataReaderProvider FromMetadataImage(ReadOnlyMemory\u003cbyte\u003e image);\n    public static MetadataReaderProvider FromPortablePdbImage(ReadOnlyMemory\u003cbyte\u003e image);\n}\n```",
                                           "updatedAt":  "2025-01-12T21:24:39Z"
                                       }
                                   ],
                         "totalCount":  10
                     },
        "title":  "Add support for Span\u003cT\u003e and/or Memory\u003cT\u003e to PEReader",
        "labels":  [
                       "api-suggestion",
                       "area-System.Reflection.Metadata"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/50714",
        "createdAt":  "2021-04-05T03:08:50Z",
        "number":  50714,
        "author":  "radical",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2021-08-05T18:29:53Z",
        "body":  "https://helixre8s23ayyeko0k025g8.blob.core.windows.net/dotnet-runtime-refs-pull-50657-merge-fbdd385f15244375b3/System.Reflection.Metadata.Tests/console.8b65fc74.log?sv=2019-07-07\u0026se=2021-04-25T01%3A56%3A12Z\u0026sr=c\u0026sp=rl\u0026sig=wYlbyPPmVwzBZv0VHWKKRXKSpRm%2FWQqGnMqpIrN0%2BEQ%3D\r\n\r\n```\r\n[02:19:20] fail: [FAIL] System.Reflection.Metadata.Decoding.Tests.CustomAttributeDecoderTests.TestCustomAttributeDecoder\r\n[02:19:20] info: System.ArgumentOutOfRangeException : Specified argument was out of the range of valid values.\r\n[02:19:20] info:    at System.Reflection.Metadata.Decoding.Tests.CustomAttributeDecoderTests.CustomAttributeTypeProvider.GetUnderlyingEnumType(String type)\r\n[02:19:20] info:    at System.Reflection.Metadata.Ecma335.CustomAttributeDecoder`1[[System.String, System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].DecodeFixedArgumentType(BlobReader\u0026 signatureReader, Boolean isElementType)\r\n[02:19:20] info:    at System.Reflection.Metadata.Ecma335.CustomAttributeDecoder`1[[System.String, System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].DecodeFixedArguments(BlobReader\u0026 signatureReader, BlobReader\u0026 valueReader, Int32 count)\r\n[02:19:20] info:    at System.Reflection.Metadata.Ecma335.CustomAttributeDecoder`1[[System.String, System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].DecodeValue(EntityHandle constructor, BlobHandle value)\r\n[02:19:20] info:    at System.Reflection.Metadata.CustomAttribute.DecodeValue[String](ICustomAttributeTypeProvider`1 provider)\r\n[02:19:20] info:    at System.Reflection.Metadata.Decoding.Tests.CustomAttributeDecoderTests.TestCustomAttributeDecoder()\r\n[02:19:20] info:    at System.Reflection.RuntimeMethodInfo.Invoke(Object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture)\r\n[02:19:20] fail: [FAIL] System.Reflection.Metadata.Decoding.Tests.SignatureDecoderTests.SimpleSignatureProviderCoverage\r\n[02:19:20] info: Assert.Equal() Failure\r\n[02:19:20] info:                                  â†“ (pos 21)\r\n[02:19:20] info: Expected: Â·Â·Â·nt32 modreq([System.Runtime]System.Runtime.CompilerServices.IÂ·Â·Â·\r\n[02:19:20] info: Actual:   Â·Â·Â·nt32 modreq([System.Private.CoreLib]System.Runtime.CompilerSeÂ·Â·Â·\r\n[02:19:20] info:                                  â†‘ (pos 21)\r\n[02:19:20] info:    at System.Reflection.Metadata.Decoding.Tests.SignatureDecoderTests.SimpleSignatureProviderCoverage()\r\n[02:19:20] info:    at System.Reflection.RuntimeMethodInfo.Invoke(Object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture)\r\n[02:19:21] fail: [FAIL] System.Reflection.Metadata.Tests.TagToTokenTests.ValidateTagToTokenConversion\r\n[02:19:21] info: System.NullReferenceException : Object reference not set to an instance of an object.\r\n[02:19:21] info:    at System.Reflection.Metadata.Tests.TagToTokenTests.\u003c\u003ec__DisplayClass1_0.\u003cGetTags\u003eb__3()\r\n[02:19:21] info:    at System.Reflection.Metadata.Tests.TagToTokenTests.ValidateTagToTokenConversion()\r\n[02:19:21] info:    at System.Reflection.RuntimeMethodInfo.Invoke(Object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture)\r\n```",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOMxvtgg==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgxMzE1NjkwOA==",
                                           "createdAt":  "2021-04-05T03:08:53Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to \u0027arch-wasm\u0027: @lewing\nSee info in area-owners.md if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nhttps://helixre8s23ayyeko0k025g8.blob.core.windows.net/dotnet-runtime-refs-pull-50657-merge-fbdd385f15244375b3/System.Reflection.Metadata.Tests/console.8b65fc74.log?sv=2019-07-07\u0026se=2021-04-25T01%3A56%3A12Z\u0026sr=c\u0026sp=rl\u0026sig=wYlbyPPmVwzBZv0VHWKKRXKSpRm%2FWQqGnMqpIrN0%2BEQ%3D\r\n\r\n```\r\n[02:19:20] fail: [FAIL] System.Reflection.Metadata.Decoding.Tests.CustomAttributeDecoderTests.TestCustomAttributeDecoder\r\n[02:19:20] info: System.ArgumentOutOfRangeException : Specified argument was out of the range of valid values.\r\n[02:19:20] info:    at System.Reflection.Metadata.Decoding.Tests.CustomAttributeDecoderTests.CustomAttributeTypeProvider.GetUnderlyingEnumType(String type)\r\n[02:19:20] info:    at System.Reflection.Metadata.Ecma335.CustomAttributeDecoder`1[[System.String, System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].DecodeFixedArgumentType(BlobReader\u0026 signatureReader, Boolean isElementType)\r\n[02:19:20] info:    at System.Reflection.Metadata.Ecma335.CustomAttributeDecoder`1[[System.String, System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].DecodeFixedArguments(BlobReader\u0026 signatureReader, BlobReader\u0026 valueReader, Int32 count)\r\n[02:19:20] info:    at System.Reflection.Metadata.Ecma335.CustomAttributeDecoder`1[[System.String, System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].DecodeValue(EntityHandle constructor, BlobHandle value)\r\n[02:19:20] info:    at System.Reflection.Metadata.CustomAttribute.DecodeValue[String](ICustomAttributeTypeProvider`1 provider)\r\n[02:19:20] info:    at System.Reflection.Metadata.Decoding.Tests.CustomAttributeDecoderTests.TestCustomAttributeDecoder()\r\n[02:19:20] info:    at System.Reflection.RuntimeMethodInfo.Invoke(Object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture)\r\n[02:19:20] fail: [FAIL] System.Reflection.Metadata.Decoding.Tests.SignatureDecoderTests.SimpleSignatureProviderCoverage\r\n[02:19:20] info: Assert.Equal() Failure\r\n[02:19:20] info:                                  â†“ (pos 21)\r\n[02:19:20] info: Expected: Â·Â·Â·nt32 modreq([System.Runtime]System.Runtime.CompilerServices.IÂ·Â·Â·\r\n[02:19:20] info: Actual:   Â·Â·Â·nt32 modreq([System.Private.CoreLib]System.Runtime.CompilerSeÂ·Â·Â·\r\n[02:19:20] info:                                  â†‘ (pos 21)\r\n[02:19:20] info:    at System.Reflection.Metadata.Decoding.Tests.SignatureDecoderTests.SimpleSignatureProviderCoverage()\r\n[02:19:20] info:    at System.Reflection.RuntimeMethodInfo.Invoke(Object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture)\r\n[02:19:21] fail: [FAIL] System.Reflection.Metadata.Tests.TagToTokenTests.ValidateTagToTokenConversion\r\n[02:19:21] info: System.NullReferenceException : Object reference not set to an instance of an object.\r\n[02:19:21] info:    at System.Reflection.Metadata.Tests.TagToTokenTests.\u003c\u003ec__DisplayClass1_0.\u003cGetTags\u003eb__3()\r\n[02:19:21] info:    at System.Reflection.Metadata.Tests.TagToTokenTests.ValidateTagToTokenConversion()\r\n[02:19:21] info:    at System.Reflection.RuntimeMethodInfo.Invoke(Object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture)\r\n```\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eradical\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`arch-wasm`, `disabled-test`, `trimming-for-aot`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2021-04-05T03:08:53Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgyNjA1NTQ3Nw==",
                                           "createdAt":  "2021-04-24T08:11:48Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "radical",
                                           "body":  "One failure left:\r\n\r\n```\r\n[07:29:18] fail: [FAIL] System.Reflection.Metadata.Tests.TagToTokenTests.ValidateTagToTokenConversion\r\n[07:29:18] info: System.NullReferenceException : Object reference not set to an instance of an object.\r\n[07:29:18] info:    at System.Reflection.Metadata.Tests.TagToTokenTests.\u003c\u003ec__DisplayClass1_0.\u003cGetTags\u003eb__3()\r\n[07:29:18] info:    at System.Reflection.Metadata.Tests.TagToTokenTests.ValidateTagToTokenConversion()\r\n[07:29:18] info:    at System.Reflection.RuntimeMethodInfo.Invoke(Object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture)\r\n```",
                                           "updatedAt":  "2021-04-24T08:11:48Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg1NzQ2ODI5MA==",
                                           "createdAt":  "2021-06-09T07:45:16Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "MaximLipnin",
                                           "body":  "\u003e One failure left:\r\n\u003e \r\n\u003e ```\r\n\u003e [07:29:18] fail: [FAIL] System.Reflection.Metadata.Tests.TagToTokenTests.ValidateTagToTokenConversion\r\n\u003e [07:29:18] info: System.NullReferenceException : Object reference not set to an instance of an object.\r\n\u003e [07:29:18] info:    at System.Reflection.Metadata.Tests.TagToTokenTests.\u003c\u003ec__DisplayClass1_0.\u003cGetTags\u003eb__3()\r\n\u003e [07:29:18] info:    at System.Reflection.Metadata.Tests.TagToTokenTests.ValidateTagToTokenConversion()\r\n\u003e [07:29:18] info:    at System.Reflection.RuntimeMethodInfo.Invoke(Object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture)\r\n\u003e ```\r\n\r\nI\u0027ve seen the same error on Android AOT",
                                           "updatedAt":  "2021-06-09T07:45:16Z"
                                       }
                                   ],
                         "totalCount":  3
                     },
        "title":  "[mono][tests][eat] System.Reflection.Metadata.Tests.dll",
        "labels":  [
                       "arch-wasm",
                       "area-System.Reflection.Metadata",
                       "disabled-test",
                       "os-android",
                       "trimming-for-aot"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/51839",
        "createdAt":  "2021-04-25T20:29:55Z",
        "number":  51839,
        "author":  "gsuberland",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOBwQi_A==",
                          "nodes":  [
                                        {
                                            "content":  "EYES",
                                            "user":  "veikkoeeva",
                                            "createdAt":  "2021-06-26T07:40:35Z"
                                        }
                                    ],
                          "totalCount":  1
                      },
        "updatedAt":  "2025-03-23T18:20:51Z",
        "body":  "## Background and Motivation\r\n\r\nThe [PE file format](https://docs.microsoft.com/en-us/windows/win32/debug/pe-format#debug-type) may include a debug directory entry of the type `IMAGE_DEBUG_TYPE_EX_DLLCHARACTERISTICS`, which contains characteristic flags in addition to those included in the `DllCharacteristics` field of the optional header. This extension allows for more characteristic bits to be set than can be reasonably stored in the original field.\r\n\r\nAt current the only defined bit in there is `IMAGE_DLLCHARACTERISTICS_EX_CET_COMPAT` (0x0001), which specifies that the binary has been compiled with support for Intel Control-flow Enforcement Technology (CET), also known as Shadow Stacks, which is used in the [Hardware-enforced Stack Protection (HSP)](https://techcommunity.microsoft.com/t5/windows-kernel-internals/understanding-hardware-enforced-stack-protection/ba-p/1247815) security feature.\r\n\r\nWhile the documentation of this particular debug structure is somewhat lacking, with no information about the exact structure of this entry beyond the supported flags, it appears to begin with a 16-bit extended flags field, with contents as documented in the PE file format document linked above. This tallies with my practical investigation of executables built with this particular feature. The MSVC compiler uses the [`/CETCOMPAT`](https://docs.microsoft.com/en-us/cpp/build/reference/cetcompat?view=msvc-160) flag to turn support on, which in turn sets this flag. I believe there may be more structures added to the binary when this feature is turned on, to define exception handler continuation targets, CET enforced ranges, and dynamic ranges, but I have not studied the feature in sufficient detail to fully understand the details. Ideally the documentation would be expanded to include this. Anyway, this is rather orthogonal to this issue.\r\n\r\nThe `PEReader` class currently has support for parsing certain types of debug records, but not this one. As the extended characteristics field is likely to see more use in the future, particularly in relation to security features, it would be helpful to add support for reading it.\r\n\r\nI\u0027ve opened this issue as it relates to some ongoing research I\u0027m doing into the interoperability and compatibility of Windows exploit mitigation features and .NET Core / .NET 5 executables. I believe it may make sense to take greater advantage over these features when executables are being run on a supported platform, particularly via opt-in flags in app configs / manifests. @blowdart asked that I tag him in these issues - hi, Barry! I believe that having greater visibility of these features\u0027 associated PE structures is a good place to lay the groundwork.\r\n\r\n## Proposed API\r\n\r\nThe API would mirror that of the CodeView debug data API, for example:\r\n\r\n```csharp\r\npublic ExtendedDllCharacteristicsDebugDirectoryData ReadExtendedDllCharacteristics(DebugDirectoryEntry entry);\r\n```\r\n\r\nThe `ExtendedDllCharacteristicsDebugDirectoryData` class would be implemented in much the same was as `CodeViewDebugDirectoryData`. The exact contents of the class would be dependent on any internal Microsoft documentation regarding the complete structure of this entry, but it would at minimum include a flags enum for the defined extended characteristics - probably just CET Compatible for now.\r\n\r\nA new enum value would be added to `DebugDirectoryEntryType`, matching `IMAGE_DEBUG_TYPE_EX_DLLCHARACTERISTICS`.\r\n\r\n## Usage Examples\r\n\r\nUsage should be fairly self-evident, but here is an example for completeness:\r\n\r\n```csharp\r\nbool IsImageCetCompatible(PeReader peReader)\r\n{\r\n  var extendedCharacteristicsDirectory = \r\n    peReader.ReadDebugDirectory()\r\n      .FirstOrDefault(dd =\u003e dd.Type == DebugDirectoryEntryType.ExtendedDllCharacteristics);\r\n  if (extendedCharacteristicsDirectory != null)\r\n  {\r\n    var extendedCharacteristics = peReader.ReadExtendedDllCharacteristics(extendedCharacteristicsDirectory);\r\n    return extendedCharacteristics.CetCompatible;\r\n  }\r\n  return false;\r\n}\r\n```\r\n\r\n## Risks\r\n\r\nNo risks that I can think of - this does not make any modifications that would affect code already in production.\r\n\r\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOo7IAXA==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgyNjM4NTMyMQ==",
                                           "createdAt":  "2021-04-25T20:29:58Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "I couldn\u0027t figure out the best area label to add to this issue. If you have write-permissions please help me learn by adding exactly one [area label](https://github.com/dotnet/runtime/blob/master/docs/area-owners.md).",
                                           "updatedAt":  "2021-04-25T20:29:58Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgyNjM5MTk3Nw==",
                                           "createdAt":  "2021-04-25T21:21:50Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "blowdart",
                                           "body":  "@jaredpar @GrabYourPitchforks for thoughts on this defence in depth in a future version.",
                                           "updatedAt":  "2021-04-25T21:21:50Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgyNjQ0NjgzNA==",
                                           "createdAt":  "2021-04-26T01:41:07Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "We have work in progress on making CoreCLR compatible with CET. This work is tracked by https://github.com/dotnet/runtime/issues/47309 . cc @kouvel \r\n\r\nAdding convenience System.Reflection.Metadata APIs for `IMAGE_DEBUG_TYPE_EX_DLLCHARACTERISTICS` should not be needed to make CoreCLR work well with CET.",
                                           "updatedAt":  "2021-04-26T01:41:07Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgyNjc4ODY5NQ==",
                                           "createdAt":  "2021-04-26T12:17:09Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "gsuberland",
                                           "body":  "\u003e Adding convenience System.Reflection.Metadata APIs for `IMAGE_DEBUG_TYPE_EX_DLLCHARACTERISTICS` should not be needed to make CoreCLR work well with CET.\r\n\r\nMy thought with this specific issue wasn\u0027t as much about getting CoreCLR to work with CET, although it\u0027s excellent to hear that this is in the pipeline, but more so that .NET applications that utilise the PE metadata API could conveniently and reliably access the extended characteristics flags in order to identify CET support (and other feature flags in future). This is applicable in tooling such as [binskim](https://github.com/microsoft/binskim), which I plan to open a PR for (to add CET coverage) if this API enhancement is accepted.",
                                           "updatedAt":  "2021-04-26T12:17:09Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgyNjgzNTI5Nw==",
                                           "createdAt":  "2021-04-26T13:27:59Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "The PE reader in System.Reflection.Metadata has the convenience helper methods to decode the small subset of PE file structuctures that are relevant for managed binaries.\r\n\r\nbinskim has a decoder for whatever additional it needs. For example, it has a wrapper for `IMAGE_LOAD_CONFIG_DIRECTORY32` in https://github.com/microsoft/binskim/blob/main/src/BinaryParsers/PEBinary/PortableExecutable/ImageLoadConfigDirectory32.cs . It can have wrapper just like this one for `IMAGE_DEBUG_TYPE_EX_DLLCHARACTERISTICS` flags. We can still add this API if we decided that it belongs to System.Reflection.Metadata. I am just saying that this API should not be required for binskim to make progress.\r\n\r\nI believe @eddynaka is working on adding support for CET right now. @eddynaka do you believe that you can fix https://github.com/microsoft/binskim/issues/277 without any new APIs in System.Reflection.Metadata?",
                                           "updatedAt":  "2022-11-07T22:01:28Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgyNjgzOTI0OQ==",
                                           "createdAt":  "2021-04-26T13:33:12Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "eddynaka",
                                           "body":  "@jkotas , yes. I\u0027m working on that. Now, I\u0027m not sure how similar the `IMAGE_LOAD_CONFIG_DIRECTORY32` is to `IMAGE_DEBUG_TYPE_EX_DLLCHARACTERISTICS`.\r\n\r\nDo you know how that works?",
                                           "updatedAt":  "2021-04-26T13:33:12Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgyNjg0MDgyMA==",
                                           "createdAt":  "2021-04-26T13:35:33Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "`IMAGE_DEBUG_TYPE_EX_DLLCHARACTERISTICS` is much simpler. It is just a single Int16.",
                                           "updatedAt":  "2021-04-26T13:35:33Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgyNzIwNDUwNQ==",
                                           "createdAt":  "2021-04-26T23:25:23Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "gsuberland",
                                           "body":  "From what I\u0027ve read, the two structures have separate functions in terms of indicating CET support.\r\n\r\nThe lowest bit of the `IMAGE_DEBUG_TYPE_EX_DLLCHARACTERISTICS` Int16 specifies whether CET is supported by the binary at all. This is set when `/CETCOMPAT` is specified as an MSVC linker flag.\r\n\r\nThe image load config directory contains, among other things, a lot of RVAs and counts for tables relating to CFG. The `GuardFlags` field has a number of flags to indicate support for various CFG features, including `IMAGE_GUARD_EH_CONTINUATION_TABLE_PRESENT` (0x200000) which specifies that CET EHCont was enabled via the `/guard:ehcont` flag. The config directory also contains the RVA and count fields that describe the exception handling continuation metadata table - `GuardEHContinuationTable` and `GuardEHContinuationCount`.\r\n\r\nAs I understand it, an image may have the `IMAGE_DLLCHARACTERISTICS_EX_CET_COMPAT` flag set without EHCont being enabled, if only `/CETCOMPAT` is set but `/guard:ehcont` is not (in MSVC, at least), so just checking for EH continuation table presence is not a complete check for an image\u0027s CET support.\r\n\r\nEDIT: I have experimentally verified this. Setting `/CETCOMPAT` alone does not force the EH continuation table to be generated. I haven\u0027t fully nailed down the behaviour, since there are some edge cases with partial builds, but this is at least true for full rebuilds.",
                                           "updatedAt":  "2021-04-27T00:29:01Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5N2yDF",
                                           "createdAt":  "2022-11-07T21:19:02Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "steveharter",
                                           "body":  "This doesn\u0027t seem necessary -- above [binskim](https://github.com/microsoft/binskim) is recommended.",
                                           "updatedAt":  "2022-11-07T21:19:02Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5N2yGm",
                                           "createdAt":  "2022-11-07T21:19:11Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Due to lack of recent activity, this issue has been marked as a candidate for backlog cleanup.  It will be closed if no further activity occurs within 14 more days. Any new comment (by anyone, not necessarily the author) will undo this process.\n\nThis process is part of our [issue cleanup automation](https://github.com/dotnet/runtime/blob/main/docs/issue-cleanup.md).",
                                           "updatedAt":  "2022-11-07T21:19:11Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5N24yD",
                                           "createdAt":  "2022-11-07T21:40:24Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "gsuberland",
                                           "body":  "@steveharter The point of me mentioning binskim was that this feature would be useful _in_ binskim, not that binskim is a useful replacement for this feature.",
                                           "updatedAt":  "2022-11-07T21:40:24Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5N3Gwt",
                                           "createdAt":  "2022-11-07T22:10:17Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCvLXiA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "buyaa-n",
                                                                               "createdAt":  "2022-11-08T00:00:53Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "jkotas",
                                           "body":  "\u003e The point of me mentioning binskim was that this feature would be useful in binskim\r\n\r\nI agree with that, but it is not the right justification for adding this decoder to System.Reflection.Metadata.\r\n\r\nMany other datastructures from PE file format spec are not in System.Reflection.Metadata either. System.Reflection.Metadata contains only the small subset of PE file format spec that is directly relevant to managed code. Extended DLL characteristics are not directly relevant to managed code.",
                                           "updatedAt":  "2022-11-07T22:10:54Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5N4zlC",
                                           "createdAt":  "2022-11-08T07:14:35Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "gsuberland",
                                           "body":  "I can see your point, but the other side of the coin is that Microsoft sets the PE standard, so who better than to provide the appropriate parsing functionality within .NET? One could also make the point that C++/IL binaries and related compiler \u0026 test code would benefit from being able to parse the native structures.\r\n\r\nGiven that Microsoft\u0027s security team are actively producing tooling for scanning binaries and encourage developers to integrate them into CI pipelines for improved appsec - a task that requires parsing both managed and native PE structures - I don\u0027t think it\u0027s unreasonable to suggest that binary parsing of the PE format should be considered in .NET.",
                                           "updatedAt":  "2022-11-08T07:18:05Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5N75BV",
                                           "createdAt":  "2022-11-08T17:07:28Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "\u003e Microsoft sets the PE standard, so who better than to provide the appropriate parsing functionality within .NET?\r\n\r\nNothing says that there has to be fully featured PE file parser included in the core .NET libraries. There is not a standard PE file parser library for C++ either. Parsing of native unmanaged binary formats is a very niche scenario. It does not make sense to include it in the core .NET libraries.\r\n\r\n\u003e Microsoft\u0027s security team are actively producing tooling for scanning binaries\r\n\r\nThis tooling has been adding their own local parser for additional PE file structures as needed without problems: https://github.com/microsoft/binskim/tree/main/src/BinaryParsers/PEBinary ",
                                           "updatedAt":  "2022-11-08T17:07:48Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6jsZaT",
                                           "createdAt":  "2025-03-23T17:27:52Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "teo-tsirpanis",
                                           "body":  "Here\u0027s a concrete proposal, if we want to move this forward. I\u0027m not asking for this API myself.\n\n```csharp\nnamespace System.Reflection.PortableExecutable;\n\npublic class DebugDirectoryBuilder\n{\n    public void AddExtendedDllCharacteristicsEntry(ExtendedDllCharacteristics characteristics);\n}\n\npublic enum DebugDirectoryEntryType\n{\n    ExtendedDllCharacteristics = 20,\n}\n\n[Flags]\npublic enum ExtendedDllCharacteristics : ushort\n{\n    None = 0,\n    CetCompatible = 0x0001,\n    ForwardCfiCompatible = 0x0040,\n}\n\npublic readonly struct ExtendedDllCharacteristicsDebugDirectoryData\n{\n    public ExtendedDllCharacteristics ExtendedDllCharacteristics { get; }\n}\n\npublic class PEReader\n{\n    public ExtendedDllCharacteristicsDebugDirectoryData ReadExtendedDllCharacteristicsDebugDirectoryData(DebugDirectoryEntry entry);\n}\n```",
                                           "updatedAt":  "2025-03-23T17:27:52Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6jsgBc",
                                           "createdAt":  "2025-03-23T18:20:50Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "My suggestion is to close this issue. I do not think that this surface belongs to System.Reflection.Metadata.",
                                           "updatedAt":  "2025-03-23T18:20:50Z"
                                       }
                                   ],
                         "totalCount":  16
                     },
        "title":  "Add support for reading extended DLL characteristics to PEReader",
        "labels":  [
                       "enhancement",
                       "api-suggestion",
                       "area-System.Reflection.Metadata",
                       "os-windows"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/60165",
        "createdAt":  "2021-10-08T11:01:34Z",
        "number":  60165,
        "author":  "MaximLipnin",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2021-10-09T02:18:19Z",
        "body":  "```\r\n\u003ctest name=\"System.Reflection.Metadata.Decoding.Tests.CustomAttributeDecoderTests.TestCustomAttributeDecoder\" type=\"System.Reflection.Metadata.Decoding.Tests.CustomAttributeDecoderTests\" method=\"TestCustomAttributeDecoder\" time=\"0.0222742\" result=\"Fail\"\u003e\r\n    \u003cfailure exception-type=\"System.BadImageFormatException\"\u003e\r\n        \u003cmessage\u003e\u003c![CDATA[System.BadImageFormatException : Invalid serialized string.]]\u003e\u003c/message\u003e\r\n        \u003cstack-trace\u003e\u003c![CDATA[   at System.Reflection.Throw.InvalidSerializedString()\r\n        at System.Reflection.Metadata.BlobReader.ReadSerializedString()\r\n        at System.Reflection.Metadata.Ecma335.CustomAttributeDecoder`1[[System.String, System.Private.CoreLib, Version=7.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].DecodeArgument(BlobReader\u0026 valueReader, ArgumentTypeInfo info)\r\n        at System.Reflection.Metadata.Ecma335.CustomAttributeDecoder`1[[System.String, System.Private.CoreLib, Version=7.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].DecodeArrayArgument(BlobReader\u0026 blobReader, ArgumentTypeInfo info)\r\n        at System.Reflection.Metadata.Ecma335.CustomAttributeDecoder`1[[System.String, System.Private.CoreLib, Version=7.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].DecodeArgument(BlobReader\u0026 valueReader, ArgumentTypeInfo info)\r\n        at System.Reflection.Metadata.Ecma335.CustomAttributeDecoder`1[[System.String, System.Private.CoreLib, Version=7.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].DecodeFixedArguments(BlobReader\u0026 signatureReader, BlobReader\u0026 valueReader, Int32 count)\r\n        at System.Reflection.Metadata.Ecma335.CustomAttributeDecoder`1[[System.String, System.Private.CoreLib, Version=7.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].DecodeValue(EntityHandle constructor, BlobHandle value)\r\n        at System.Reflection.Metadata.CustomAttribute.DecodeValue[String](ICustomAttributeTypeProvider`1 provider)\r\n        at System.Reflection.Metadata.Decoding.Tests.CustomAttributeDecoderTests.TestCustomAttributeDecoder()\r\n        at System.Reflection.RuntimeMethodInfo.Invoke(Object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture)]]\u003e\u003c/stack-trace\u003e\r\n    \u003c/failure\u003e\r\n\u003c/tes\r\n```\r\nhttps://helixre8s23ayyeko0k025g8.blob.core.windows.net/dotnet-runtime-refs-pull-59503-merge-82a08e0bf78247ad85/System.Reflection.Metadata.Tests/1/testResults.xml?sv=2019-07-07\u0026se=2021-10-27T21%3A20%3A15Z\u0026sr=c\u0026sp=rl\u0026sig=l6x81ojLuccAHXezeNAnngaxlFWwA%2FvquAUqBhREPyM%3D\r\n\r\nhttps://github.com/dotnet/runtime/pull/59503\r\n\r\ncc @steveisok ",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  null,
                         "nodes":  [

                                   ],
                         "totalCount":  0
                     },
        "title":  "[tvOS] \"System.BadImageFormatException : Invalid serialized string\" in System.Reflection.Metadata.Decoding.Tests.CustomAttributeDecoderTests.TestCustomAttributeDecoder",
        "labels":  [
                       "area-System.Reflection.Metadata",
                       "test-bug",
                       "os-tvos",
                       "needs-further-triage"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/60579",
        "createdAt":  "2021-10-18T21:09:05Z",
        "number":  60579,
        "author":  "steveisok",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2022-08-03T17:21:50Z",
        "body":  "This [test](https://github.com/dotnet/runtime/blob/1c949ace34b913e3d5e3070f132c87b670cac8c9/src/libraries/System.Reflection.Metadata/tests/Metadata/Decoding/CustomAttributeDecoderTests.cs#L17-L87) fails with:\r\n\r\n```\r\nSystem.BadImageFormatException : Invalid serialized string.\r\nat System.Reflection.Throw.InvalidSerializedString()\r\n   at System.Reflection.Metadata.BlobReader.ReadSerializedString()\r\n   at System.Reflection.Metadata.Ecma335.CustomAttributeDecoder`1[[System.String, System.Private.CoreLib, Version=7.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].DecodeArgument(BlobReader\u0026 valueReader, ArgumentTypeInfo info)\r\n   at System.Reflection.Metadata.Ecma335.CustomAttributeDecoder`1[[System.String, System.Private.CoreLib, Version=7.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].DecodeArrayArgument(BlobReader\u0026 blobReader, ArgumentTypeInfo info)\r\n   at System.Reflection.Metadata.Ecma335.CustomAttributeDecoder`1[[System.String, System.Private.CoreLib, Version=7.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].DecodeArgument(BlobReader\u0026 valueReader, ArgumentTypeInfo info)\r\n   at System.Reflection.Metadata.Ecma335.CustomAttributeDecoder`1[[System.String, System.Private.CoreLib, Version=7.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].DecodeFixedArguments(BlobReader\u0026 signatureReader, BlobReader\u0026 valueReader, Int32 count)\r\n   at System.Reflection.Metadata.Ecma335.CustomAttributeDecoder`1[[System.String, System.Private.CoreLib, Version=7.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].DecodeValue(EntityHandle constructor, BlobHandle value)\r\n   at System.Reflection.Metadata.CustomAttribute.DecodeValue[String](ICustomAttributeTypeProvider`1 provider)\r\n   at System.Reflection.Metadata.Decoding.Tests.CustomAttributeDecoderTests.TestCustomAttributeDecoder()\r\n   at System.Reflection.RuntimeMethodInfo.Invoke(Object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture)\r\n```",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOR8csNQ==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc44ZWAT",
                                           "createdAt":  "2021-10-18T21:09:10Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @buyaa-n\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nThis [test](https://github.com/dotnet/runtime/blob/1c949ace34b913e3d5e3070f132c87b670cac8c9/src/libraries/System.Reflection.Metadata/tests/Metadata/Decoding/CustomAttributeDecoderTests.cs#L17-L87) fails with:\r\n\r\n```\r\nSystem.BadImageFormatException : Invalid serialized string.\r\nat System.Reflection.Throw.InvalidSerializedString()\r\n   at System.Reflection.Metadata.BlobReader.ReadSerializedString()\r\n   at System.Reflection.Metadata.Ecma335.CustomAttributeDecoder`1[[System.String, System.Private.CoreLib, Version=7.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].DecodeArgument(BlobReader\u0026 valueReader, ArgumentTypeInfo info)\r\n   at System.Reflection.Metadata.Ecma335.CustomAttributeDecoder`1[[System.String, System.Private.CoreLib, Version=7.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].DecodeArrayArgument(BlobReader\u0026 blobReader, ArgumentTypeInfo info)\r\n   at System.Reflection.Metadata.Ecma335.CustomAttributeDecoder`1[[System.String, System.Private.CoreLib, Version=7.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].DecodeArgument(BlobReader\u0026 valueReader, ArgumentTypeInfo info)\r\n   at System.Reflection.Metadata.Ecma335.CustomAttributeDecoder`1[[System.String, System.Private.CoreLib, Version=7.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].DecodeFixedArguments(BlobReader\u0026 signatureReader, BlobReader\u0026 valueReader, Int32 count)\r\n   at System.Reflection.Metadata.Ecma335.CustomAttributeDecoder`1[[System.String, System.Private.CoreLib, Version=7.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].DecodeValue(EntityHandle constructor, BlobHandle value)\r\n   at System.Reflection.Metadata.CustomAttribute.DecodeValue[String](ICustomAttributeTypeProvider`1 provider)\r\n   at System.Reflection.Metadata.Decoding.Tests.CustomAttributeDecoderTests.TestCustomAttributeDecoder()\r\n   at System.Reflection.RuntimeMethodInfo.Invoke(Object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture)\r\n```\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003esteveisok\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Reflection.Metadata`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2021-10-18T21:09:10Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Gn9YE",
                                           "createdAt":  "2022-07-14T20:43:59Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "steveharter",
                                           "body":  "@steveisok was this failing in normal CI simulators like for `runtime (Build tvOSSimulator x64 Debug AllSubsets_Mono)` or only on physical devices?",
                                           "updatedAt":  "2022-07-14T20:43:59Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Gn9lp",
                                           "createdAt":  "2022-07-14T20:45:12Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "steveisok",
                                           "body":  "I believe it was only devices",
                                           "updatedAt":  "2022-07-14T20:45:12Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Gxzch",
                                           "createdAt":  "2022-07-18T13:40:47Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "steveharter",
                                           "body":  "Per the test PR at https://github.com/dotnet/runtime/pull/72224/files that test is passing on simulators so it must be devices then.\r\n\r\nThe current test hard-codes \"System.Runtime\" as the module which since it works in CI should be fine unless these perhaps use single-file executables on the device?",
                                           "updatedAt":  "2022-07-18T13:40:47Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Hxyw1",
                                           "createdAt":  "2022-08-03T17:02:57Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "steveharter",
                                           "body":  "Moving to 8.0; lower-priority and need to verify on devices.",
                                           "updatedAt":  "2022-08-03T17:02:57Z"
                                       }
                                   ],
                         "totalCount":  5
                     },
        "title":  "[iOS/tvOS] CustomAttributeDecoderTests.TestCustomAttributeDecoder failing on devices",
        "labels":  [
                       "area-System.Reflection.Metadata",
                       "os-ios",
                       "os-tvos"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/72908",
        "createdAt":  "2022-07-27T05:00:17Z",
        "number":  72908,
        "author":  "MichalStrehovsky",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHODDNqfQ==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "ericstj",
                                            "createdAt":  "2025-06-03T15:40:48Z"
                                        }
                                    ],
                          "totalCount":  1
                      },
        "updatedAt":  "2025-07-26T10:39:15Z",
        "body":  "MetadataLoadContext test has a clever trick to map runtime types to their MetadataLoadContext version by using Assembly.Location, opening them in a metadata context and finding the corresponding type. This doesn\u0027t work in single-file testing in general and NativeAOT in particular.\r\n\r\nhttps://github.com/dotnet/runtime/blob/57bfe474518ab5b7cfe6bf7424a79ce3af9d6657/src/libraries/System.Reflection.MetadataLoadContext/tests/src/TestUtils/TestUtils.JittedRuntimes.cs#L11-L26\r\n\r\nThe best way forward would probably be to introduce a test assembly that will have all the types we need to project and to include it as Content. Like so:\r\n\r\nhttps://github.com/dotnet/runtime/blob/8abc2519948afb07ecb41489a012d0546d15aa17/src/libraries/System.Diagnostics.FileVersionInfo/tests/System.Diagnostics.FileVersionInfo.Tests/System.Diagnostics.FileVersionInfo.Tests.csproj#L46-L49\r\n\r\nWe can have the test types in both the test project and in the Content assembly - the projection would be updated to look in the Content assembly instead of Assembly.Location.\r\n\r\nWe\u0027ll probably need another Content assembly that will be a simulated CoreLib with whatever dummy content we need to make the test assembly build. It wouldn\u0027t be the first fake CoreLib in the runtime repo.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOrwHXiQ==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5HTZlc",
                                           "createdAt":  "2022-07-27T05:00:28Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-reflection\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nMetadataLoadContext test has a clever trick to map runtime types to their MetadataLoadContext version by using Assembly.Location, opening them in a metadata context and finding the corresponding type. This doesn\u0027t work in single-file testing in general and NativeAOT in particular.\r\n\r\nhttps://github.com/dotnet/runtime/blob/57bfe474518ab5b7cfe6bf7424a79ce3af9d6657/src/libraries/System.Reflection.MetadataLoadContext/tests/src/TestUtils/TestUtils.JittedRuntimes.cs#L11-L26\r\n\r\nThe best way forward would probably be to introduce a test assembly that will have all the types we need to project and to include it as Content. Like so:\r\n\r\nhttps://github.com/dotnet/runtime/blob/8abc2519948afb07ecb41489a012d0546d15aa17/src/libraries/System.Diagnostics.FileVersionInfo/tests/System.Diagnostics.FileVersionInfo.Tests/System.Diagnostics.FileVersionInfo.Tests.csproj#L46-L49\r\n\r\nWe can have the test types in both the test project and in the Content assembly - the projection would be updated to look in the Content assembly instead of Assembly.Location.\r\n\r\nWe\u0027ll probably need another Content assembly that will be a simulated CoreLib with whatever dummy content we need to make the test assembly build. It wouldn\u0027t be the first fake CoreLib in the runtime repo.\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eMichalStrehovsky\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Reflection`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-07-27T05:00:28Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5HTljP",
                                           "createdAt":  "2022-07-27T06:29:01Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-reflection-metadata\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nMetadataLoadContext test has a clever trick to map runtime types to their MetadataLoadContext version by using Assembly.Location, opening them in a metadata context and finding the corresponding type. This doesn\u0027t work in single-file testing in general and NativeAOT in particular.\r\n\r\nhttps://github.com/dotnet/runtime/blob/57bfe474518ab5b7cfe6bf7424a79ce3af9d6657/src/libraries/System.Reflection.MetadataLoadContext/tests/src/TestUtils/TestUtils.JittedRuntimes.cs#L11-L26\r\n\r\nThe best way forward would probably be to introduce a test assembly that will have all the types we need to project and to include it as Content. Like so:\r\n\r\nhttps://github.com/dotnet/runtime/blob/8abc2519948afb07ecb41489a012d0546d15aa17/src/libraries/System.Diagnostics.FileVersionInfo/tests/System.Diagnostics.FileVersionInfo.Tests/System.Diagnostics.FileVersionInfo.Tests.csproj#L46-L49\r\n\r\nWe can have the test types in both the test project and in the Content assembly - the projection would be updated to look in the Content assembly instead of Assembly.Location.\r\n\r\nWe\u0027ll probably need another Content assembly that will be a simulated CoreLib with whatever dummy content we need to make the test assembly build. It wouldn\u0027t be the first fake CoreLib in the runtime repo.\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eMichalStrehovsky\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Reflection.Metadata`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-07-27T06:29:01Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5NuWK-",
                                           "createdAt":  "2022-11-04T18:44:55Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "steveharter",
                                           "body":  "Linking https://github.com/dotnet/runtime/pull/72917 and https://github.com/dotnet/runtime/issues/27803",
                                           "updatedAt":  "2022-11-04T18:44:55Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5jHxUv",
                                           "createdAt":  "2023-08-02T21:23:04Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "steveharter",
                                           "body":  "Moving to v9 based on priority+resources.",
                                           "updatedAt":  "2023-08-02T21:23:04Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6GCzsZ",
                                           "createdAt":  "2024-07-24T20:55:48Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "steveharter",
                                           "body":  "@MichalStrehovsky is this still a valid scenario and is the possible implementation below still valid?\r\n\r\n\u003e The best way forward would probably be to introduce a test assembly that will have all the types we need to project and to include it as Content.\r\n\r\n",
                                           "updatedAt":  "2024-07-24T20:55:48Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6GGKVg",
                                           "createdAt":  "2024-07-25T08:29:29Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "MichalStrehovsky",
                                           "body":  "\u003e @MichalStrehovsky is this still a valid scenario and is the possible implementation below still valid?\r\n\u003e \r\n\u003e \u003e The best way forward would probably be to introduce a test assembly that will have all the types we need to project and to include it as Content.\r\n\r\nYes, it\u0027s still a test gap and including as Content should work. E.g. the System.Diagnostics.FileVersionInfo.Tests test does that to include System.Diagnostics.FileVersionInfo.TestAssembly (a test assembly file that is loaded to check its version).",
                                           "updatedAt":  "2024-07-25T08:29:29Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6vALDT",
                                           "createdAt":  "2025-06-03T15:46:18Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ericstj",
                                           "body":  "\u003e We\u0027ll probably need another Content assembly that will be a simulated CoreLib with whatever dummy content we need to make the test assembly build. It wouldn\u0027t be the first fake CoreLib in the runtime repo.\n\nWhat about just including `System.Runtime.dll` with the test assembly.  @jkotas and I were discussing improving the test coverage with more behavior diffing in https://github.com/dotnet/runtime/pull/116080#discussion_r2116717994 and we have other reasons to include it.\n\nSo we could build a test assembly of interesting types, and include it as content, along with the minimal set of references it required to build.\n\nI guess including the test assembly itself as content could also solve this, but I like the better factoring of having an assembly of only interesting test types.",
                                           "updatedAt":  "2025-06-03T15:48:14Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6vAdeJ",
                                           "createdAt":  "2025-06-03T16:05:44Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "\u003e What about just including System.Runtime.dll\n\nYes, including System.Runtime ref assembly should be enough.",
                                           "updatedAt":  "2025-06-03T16:05:44Z"
                                       }
                                   ],
                         "totalCount":  8
                     },
        "title":  "Refactor System.Reflection.MetadataLoadContext tests to work for single file",
        "labels":  [
                       "area-System.Reflection.Metadata",
                       "wasm-aot-test"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/85280",
        "createdAt":  "2023-04-24T23:11:11Z",
        "number":  85280,
        "author":  "teo-tsirpanis",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOC5Cclg==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Wraith2",
                                            "createdAt":  "2023-04-25T00:13:53Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "DaZombieKiller",
                                            "createdAt":  "2023-04-25T06:04:01Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "reflectronic",
                                            "createdAt":  "2023-04-25T16:49:14Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "PaulusParssinen",
                                            "createdAt":  "2023-04-25T17:23:00Z"
                                        },
                                        {
                                            "content":  "HEART",
                                            "user":  "PaulusParssinen",
                                            "createdAt":  "2024-06-01T16:47:41Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "AArnott",
                                            "createdAt":  "2024-06-08T15:14:53Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "omariom",
                                            "createdAt":  "2024-07-01T10:36:34Z"
                                        }
                                    ],
                          "totalCount":  7
                      },
        "updatedAt":  "2025-03-08T21:33:22Z",
        "body":  "### Background and motivation\n\n`System.Reflection.Metadata` is a pretty perormance-oriented library but its API lacks methods that accept spans or facilitate zero-copy memory access for some scenarios. I propose additional span overloads for methods that work with memory buffers. Some of these APIs can now be implemented efficiently thanks to the work started in #81059.\n\n### API Proposal\n\n```csharp\nnamespace System.Reflection.Metadata;\n\npublic class BlobContentId\n{\n    public BlobContentId(ReadOnlySpan\u003cbyte\u003e id);\n    public static BllobContentId FromHash(ReadOnlySpan\u003cbyte\u003e hashCode);\n}\n\npublic struct BlobReader\n{\n    public ReadOnlySpan\u003cbyte\u003e RemainingSpan { get; }\n    public ReadOnlySpan\u003cbyte\u003e Span { get; }\n}\n\npublic struct BlobWriter\n{\n    public void WriteBytes(ReadOnlySpan\u003cbyte\u003e buffer);\n}\n\npublic struct MetadataReader\n{\n    public BlobReader GetBlobBuilder(UserStringHandle handle);\n    // Taken from #103169 and expanded\n    public bool TryGetBlob(BlobHandle handle, Span\u003cbyte\u003e span, out int length);\n    public bool TryGetString(StringHandle handle, Span\u003cchar\u003e span, out int length);\n    public bool TryGetString(DocumentNameBlobHandle handle, Span\u003cchar\u003e span, out int length);\n    public bool TryGetString(NamespaceDefinitionHandle handle, Span\u003cchar\u003e span, out int length);\n    public bool TryGetString(UserStringHandle handle, Span\u003cchar\u003e span, out int length);\n}\n\nnamespace System.Reflection.Metadata.Ecma335;\n\npublic struct ArrayShapeEncoder\n{\n    public void Shape(int rank, ReadOnlySpan\u003cint\u003e sizes, ReadOnlySpan\u003cint\u003e lowerBounds) { }\n}\n\npublic sealed class MetadataBuilder\n{\n    // These APIs will not allocate if the blob/string already exists.\n    public BlobHandle GetOrAddBlob(ReadOnlySpan\u003cbyte\u003e value);\n    public BlobHandle GetOrAddBlobUTF8(ReadOnlySpan\u003cchar\u003e value, bool allowUnpairedSurrogates = true);\n    public BlobHandle GetOrAddBlobUTF16(ReadOnlySpan\u003cchar\u003e value);\n    public BlobHandle GetOrAddDocumentName(ReadOnlySpan\u003cchar\u003e value);\n    public StringHandle GetOrAddString(ReadOnlySpan\u003cchar\u003e value);\n    public UserStringHandle GetOrAddUserString(ReadOnlySpan\u003cchar\u003e value);\n}\n\npublic readonly partial struct PermissionSetEncoder\n{\n    public PermissionSetEncoder AddPermission(string typeName, ReadOnlySpan\u003cbyte\u003e encodedArguments);\n}\n\nnamespace System.Reflection.PortableExecutable;\n\npublic sealed partial class DebugDirectoryBuilder\n{\n    public void AddEntry(DebugDirectoryEntryType type, uint version, uint stamp, ReadOnlySpan\u003cbyte\u003e data);\n    // Existing API, add allows ref struct to TData on supported frameworks\n    public void AddEntry\u003cTData\u003e(DebugDirectoryEntryType type, uint version, uint stamp, TData data, System.Action\u003cBlobBuilder, TData\u003e dataSerializer)\n#if NET9_0_OR_HIGHER\n        where TData : allows ref struct\n#endif\n    ;\n    public void AddPdbChecksumEntry(string algorithmName, ReadOnlySpan\u003cbyte\u003e checksum);\n}\n```\n\n### API Usage\n\nThe proposed APIs correspond to existing ones that work with strings and (immutable) byte arrays. Their usage will be similar.\n\n### Alternative Designs\n\n* The APIs in `ArrayShapeEncoder` and `PermissionSetEncoder` are not strictly necessary (especially the latter) and could be omitted.\n* The `TryGet***` APIs are not necessary either; a user can call `GetBlobReader` and have zero-copy access to the raw bytes.\n  * However, when called on virtual blob and string handles (used for WinRT projections), `GetBlobReader` returns a buffer pointing to newly allocated and pinned memory, which is not the best for performance, but there is room for improvement.\n  * Namespace definition and document name blob handles don\u0027t have a raw byte representation, so the `TryGet***` APIs will be needed to avoid allocations.\n* A previous iteration of this proposal suggested some additional APIs for `BlobReader` to read byte buffers and strings into spans, but I removed them because this is something users can already do by getting the reader\u0027s underlying pointer or span.\n\n### Risks\n\nAPIs to get a span from a `BlobReader` might be considered unsafe because `BlobReader` wraps unmanaged memory and the span will not ensure the memory is kept alive. But this is a problem with SRM in general.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOoXBbpQ==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5ap6_z",
                                           "createdAt":  "2023-04-24T23:11:45Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-reflection-metadata\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Background and motivation\n\n`System.Reflection.Metadata` is a pretty perormance-oriented library but its API lacks methods that accept spans. I propose additional span overloads for methods that work with memory buffers. Some of these APIs can now be implemented efficiently thanks to the work started in #81059.\n\n### API Proposal\n\n```csharp\r\nnamespace System.Reflection.Metadata;\r\n\r\npublic class BlobBuilder\r\n{\r\n    public void WriteBytes(ReadOnlySpan\u003cbyte\u003e buffer);\r\n}\r\n\r\npublic class BlobContentId\r\n{\r\n    public BlobContentId(ReadOnlySpan\u003cbyte\u003e id);\r\n    public static BllobContentId FromHash(ReadOnlySpan\u003cbyte\u003e hashCode);\r\n}\r\n\r\npublic struct BlobReader\r\n{\r\n    public void ReadBytes(Span\u003cbyte\u003e buffer);\r\n    public void ReadUTF8(int byteCount, Span\u003cchar\u003e buffer);\r\n    public bool TryReadUTF8(int byteCount, Span\u003cchar\u003e buffer, out int charsWritten);\r\n    public void ReadUTF16(int byteCount, Span\u003cchar\u003e buffer);\r\n    public bool TryReadUTF16(int byteCount, Span\u003cchar\u003e buffer, out int charsWritten);\r\n}\r\n\r\npublic struct BlobWriter\r\n{\r\n    public void WriteBytes(ReadOnlySpan\u003cbyte\u003e buffer);\r\n}\r\n\r\npublic struct MetadataReader\r\n{\r\n    public int GetBlobLength(BlobHandle handle);\r\n    public void GetBlobBytes(BlobHandle handle, Span\u003cbyte\u003e buffer, out int bytesWritten);\r\n    public int GetStringLength(StringHandle handle);\r\n    public void GetStringBytes(StringHandle handle, Span\u003cchar\u003e buffer, out int bytesWritten);\r\n    public int GetStringLength(NamespaceDefinitionHandle handle);\r\n    public void GetStringBytes(NamespaceDefinitionHandle handle, Span\u003cchar\u003e buffer, out int bytesWritten);\r\n    public int GetStringLength(DocumentNameBlobHandle handle);\r\n    public void GetStringBytes(DocumentNameBlobHandle handle, Span\u003cchar\u003e buffer, out int bytesWritten);\r\n    public int GetUserStringLength(UserStringHandle handle);\r\n    public void GetUserStringBytes(UserStringHandle handle, Span\u003cchar\u003e buffer, out int bytesWritten);\r\n\r\n    // Or what about we add the following APIs instead of the above?\r\n    // The memory the span points to can be freed under our feet but\r\n    // this is an existing problem with many SRM APIs that safely wrap pointers.\r\n    // The library is expert-level either way.\r\n    public ReadOnlySpan\u003cbyte\u003e GetBlobSpan(BlobHandle handle);\r\n    public ReadOnlySpan\u003cbyte\u003e GetRawStringBytes(StringHandle handle);\r\n    public ReadOnlySpan\u003cbyte\u003e GetRawStringBytes(NamespaceDefinitionHandle handle);\r\n    public ReadOnlySpan\u003cbyte\u003e GetRawStringBytes(DocumentNameBlobHandle handle);\r\n    public ReadOnlySpan\u003cbyte\u003e GetRawUserStringBytes(UserStringHandle handle);\r\n}\r\n\r\nnamespace System.Reflection.Metadata.Ecma335;\r\n\r\npublic sealed class MetadataBuilder\r\n{\r\n    // These APIs will not allocate if the blob/string already exists.\r\n    public BlobHandle GetOrAddBlob(ReadOnlySpan\u003cbyte\u003e value);\r\n    public BlobHandle GetOrAddBlobUTF8(ReadOnlySpan\u003cbyte\u003e value);\r\n    public BlobHandle GetOrAddBlobUTF16(ReadOnlySpan\u003cbyte\u003e value);\r\n    public BlobHandle GetOrAddDocumentName(ReadOnlySpan\u003cchar\u003e value);\r\n    public StringHandle GetOrAddString(ReadOnlySpan\u003cchar\u003e value);\r\n    public UserStringHandle GetOrAddUserString(ReadOnlySpan\u003cchar\u003e value);\r\n}\r\n```\n\n### API Usage\n\nThe proposed APIs correspond to existing APIs that work with strings and (immutable) byte arrays. Their usage will be similar.\n\n### Alternative Designs\n\nDo nothing and either let users implement the span APIs on top of pointers if they are available, or accept the memory allocations if they aren\u0027t.\r\n\r\nThere are also more possible APIs to be spanified (such as methods in the `System.Reflection.Metadata.Ecma335.***Encoder`s), but the proposed APIs are the most foundational; the rest can be implemented by user code on top of these with little effort.\n\n### Risks\n\n_No response_\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eteo-tsirpanis\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`api-suggestion`, `area-System.Reflection.Metadata`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-04-24T23:11:45Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5a0vHE",
                                           "createdAt":  "2023-04-26T17:08:22Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "steveharter",
                                           "body":  "\u003e  I propose additional span overloads for methods that work with memory buffers\r\n\r\n@teo-tsirpanis can you provider an example of the caller using buffers (not backed by a simple array) where these APIs are advantageous? Thanks",
                                           "updatedAt":  "2023-04-26T17:08:22Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5a1D1b",
                                           "createdAt":  "2023-04-26T18:20:02Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "teo-tsirpanis",
                                           "body":  "One use case would be https://github.com/dotnet/runtime/pull/84580#discussion_r1169306517.",
                                           "updatedAt":  "2023-04-26T18:20:22Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5dcX01",
                                           "createdAt":  "2023-05-30T03:47:22Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "buyaa-n",
                                           "body":  "@teo-tsirpanis the API proposals for BlobBuilder, BlobContentId, BlobWriter and MetadataBuilder looks good to me, for others more info needed,  I left some questions as a comment. In general, a usage scenarios for them would be helpful for review. Also, I would prefer to split the proposals for `BlobReader` and `MetadataReader` into another issue if that makes sense to you\r\n```diff\r\npublic struct BlobReader\r\n{\r\n    public byte[] ReadBytes(int byteCount)\r\n    public void ReadBytes(int byteCount, byte[] buffer, int bufferOffset)\r\n+   public void ReadBytes(Span\u003cbyte\u003e buffer);\r\n    public string ReadUTF8(int byteCount)\r\n+   public void ReadUTF8(int byteCount, Span\u003cchar\u003e buffer); // Why this passes byteCount but ReadBytes(Span\u003cbyte\u003e buffer) not?\r\n+   public bool TryReadUTF8(int byteCount, Span\u003cchar\u003e buffer, out int charsWritten); // A uage scenarios will be helpful\r\n    public string ReadUTF16(int byteCount)\r\n+   public void ReadUTF16(int byteCount, Span\u003cchar\u003e buffer);\r\n+   public bool TryReadUTF16(int byteCount, Span\u003cchar\u003e buffer, out int charsWritten); // Usage scenarios will be helpful\r\n}\r\n```\r\n```diff\r\npublic struct MetadataReader\r\n{\r\n+   public int GetBlobLength(BlobHandle handle); // Why this needed? I guess for determining span size, anyway a user scenario will be useful\r\n    public byte[] GetBlobBytes(BlobHandle handle);\r\n+   public void GetBlobBytes(BlobHandle handle, Span\u003cbyte\u003e buffer, out int bytesWritten); // why do you need bytesWritten?\r\n    public string GetString(StringHandle handle);\r\n+   public int GetStringLength(StringHandle handle); // usage scenarios\r\n+   public void GetStringBytes(StringHandle handle, Span\u003cchar\u003e buffer, out int bytesWritten);\r\n+   public int GetStringLength(NamespaceDefinitionHandle handle);\r\n+   public void GetStringBytes(NamespaceDefinitionHandle handle, Span\u003cchar\u003e buffer, out int bytesWritten);\r\n+   public int GetStringLength(DocumentNameBlobHandle handle);\r\n+   public void GetStringBytes(DocumentNameBlobHandle handle, Span\u003cchar\u003e buffer, out int bytesWritten);\r\n+   public int GetUserStringLength(UserStringHandle handle);\r\n+   public void GetUserStringBytes(UserStringHandle handle, Span\u003cchar\u003e buffer, out int bytesWritten);\r\n\r\n    // Or what about we add the following APIs instead of the above?\r\n    // The memory the span points to can be freed under our feet but\r\n    // this is an existing problem with many SRM APIs that safely wrap pointers.\r\n    // The library is expert-level either way.\r\n+    public ReadOnlySpan\u003cbyte\u003e GetBlobSpan(BlobHandle handle);\r\n+    public ReadOnlySpan\u003cbyte\u003e GetRawStringBytes(StringHandle handle);\r\n+    public ReadOnlySpan\u003cbyte\u003e GetRawStringBytes(NamespaceDefinitionHandle handle);\r\n+    public ReadOnlySpan\u003cbyte\u003e GetRawStringBytes(DocumentNameBlobHandle handle);\r\n+    public ReadOnlySpan\u003cbyte\u003e GetRawUserStringBytes(UserStringHandle handle);\r\n}\r\n```\r\n``` diff\r\npublic sealed class MetadataBuilder\r\n{\r\n    public BlobHandle GetOrAddBlob(byte[] value) \r\n    // These APIs will not allocate if the blob/string already exists.\r\n+   public BlobHandle GetOrAddBlob(ReadOnlySpan\u003cbyte\u003e value);\r\n    public BlobHandle GetOrAddBlobUTF8(string value, bool allowUnpairedSurrogates = true);\r\n+   public BlobHandle GetOrAddBlobUTF8(ReadOnlySpan\u003cbyte\u003e value); // should it have allowUnpairedSurrogates parameter too?\r\n    public System.Reflection.Metadata.BlobHandle GetOrAddBlobUTF16(string value);\r\n+   public BlobHandle GetOrAddBlobUTF16(ReadOnlySpan\u003cbyte\u003e value);\r\n    public BlobHandle GetOrAddDocumentName(string value);\r\n+   public BlobHandle GetOrAddDocumentName(ReadOnlySpan\u003cchar\u003e value);\r\n    public StringHandle GetOrAddString(string value);\r\n+   public StringHandle GetOrAddString(ReadOnlySpan\u003cchar\u003e value);\r\n    public UserStringHandle GetOrAddUserString(string value);\r\n+   public UserStringHandle GetOrAddUserString(ReadOnlySpan\u003cchar\u003e value);\r\n}\r\n```\r\nAdding future milestone for now, I don\u0027t think all of these APIs ready for 8.0, we could change milestone if `BlobReader` and `MetadataReader` proposals moved to an another issue/proposal",
                                           "updatedAt":  "2023-05-30T04:19:07Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5p4z-5",
                                           "createdAt":  "2023-10-24T03:56:42Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "fowl2",
                                           "body":  "Missing the simplest one :)\r\n``` diff\r\npublic sealed class MetadataReader\r\n{\r\n    public unsafe byte* MetadataPointer { get; }\r\n    public int MetadataLength { get; }\r\n+   public ReadOnlySpan\u003cbyte\u003e MetadataSpan { get; }\r\n}\r\n```\r\n\r\nNot sure if this is that useful given the whole type is unsafe, but perhaps:\r\n\r\n``` diff\r\npublic unsafe struct BlobReader\r\n{\r\n+   public BlobReader(ReadOnlySpan\u003cbyte\u003e buffer);\r\n}\r\n```",
                                           "updatedAt":  "2023-10-24T03:56:42Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5_w2O9",
                                           "createdAt":  "2024-06-01T16:49:56Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "PaulusParssinen",
                                           "body":  "ILCompiler and its components could benefit from more `(RO)Span\u003cT\u003e` overloads in the S.R.M. In many places ILC has to go through various hoops to cache values that it reads from metadata because lack of modern Span APIs. ",
                                           "updatedAt":  "2024-06-01T17:04:43Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6AfJzB",
                                           "createdAt":  "2024-06-07T22:25:37Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "teo-tsirpanis",
                                           "body":  "@buyaa-n\r\n\r\n\u003e `public int GetBlobLength(BlobHandle handle); // Why this needed? I guess for determining span size, anyway a user scenario will be useful`\r\n\r\nMy thought was that it would allow the users to get the buffer\u0027s size and prepare an appropriately sized buffer to pass to `GetBlob`.\r\n\r\n\u003e `public void ReadUTF8(int byteCount, Span\u003cchar\u003e buffer); // Why this passes byteCount but ReadBytes(Span\u003cbyte\u003e buffer) not?`\r\n\u003e `public bool TryReadUTF8(int byteCount, Span\u003cchar\u003e buffer, out int charsWritten); // A uage scenarios will be helpful`\r\n\r\nOn second thought `byteCount` is not needed; it can be inferred from the span. I updated the proposal to fix this and other mistakes. I also am not sure if the `BlobReader.TryRead***` methods are needed.\r\n",
                                           "updatedAt":  "2024-06-07T22:25:37Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6AgxBf",
                                           "createdAt":  "2024-06-08T15:16:59Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AArnott",
                                           "body":  "```cs\r\npublic void GetStringChars(NamespaceDefinitionHandle handle, Span\u003cchar\u003e buffer, out int bytesWritten);\r\n```\r\n\r\nThe out parameter should be named `charsWritten` instead. For this, and all other char-based spans with out length parameters.",
                                           "updatedAt":  "2024-06-08T15:16:59Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6AgxLX",
                                           "createdAt":  "2024-06-08T15:18:57Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "teo-tsirpanis",
                                           "body":  "Updated, thanks.",
                                           "updatedAt":  "2024-06-08T15:18:57Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6AgxUN",
                                           "createdAt":  "2024-06-08T15:20:40Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODlAuyA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "teo-tsirpanis",
                                                                               "createdAt":  "2024-06-08T15:26:39Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "AArnott",
                                           "body":  "IMO I prefer the single `TryGetString` method pattern I proposed in #103169 over _two_ methods (`GetStringLength` and `GetStringChars`). Besides being one method instead of two, it means I can reuse a buffer for many get-string calls without fear of it throwing an exception just because the length is too short. With the two method pattern, I _must_ make an extra `GetStringLength` call _before_ trying to obtain the string just to avoid the exception.",
                                           "updatedAt":  "2024-06-08T15:20:40Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6hcFul",
                                           "createdAt":  "2025-03-08T21:33:21Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "teo-tsirpanis",
                                           "body":  "I updated my proposal to fill all gaps in the API surface of SRM and add span overloads when it makes sense, and to incorporate @AArnott\u0027s proposals. Let me know what you think.",
                                           "updatedAt":  "2025-03-08T21:33:21Z"
                                       }
                                   ],
                         "totalCount":  11
                     },
        "title":  "[API Proposal]: Embrace spans in System.Reflection.Metadata.",
        "labels":  [
                       "api-suggestion",
                       "area-System.Reflection.Metadata"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/94892",
        "createdAt":  "2023-06-24T01:33:16Z",
        "number":  94892,
        "author":  "jbevain",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOC8ChDw==",
                          "nodes":  [
                                        {
                                            "content":  "EYES",
                                            "user":  "UlyssesWu",
                                            "createdAt":  "2023-06-24T02:25:35Z"
                                        },
                                        {
                                            "content":  "EYES",
                                            "user":  "NijomonJoseM",
                                            "createdAt":  "2023-06-24T06:46:20Z"
                                        },
                                        {
                                            "content":  "EYES",
                                            "user":  "Sergio0694",
                                            "createdAt":  "2023-06-24T15:58:42Z"
                                        },
                                        {
                                            "content":  "EYES",
                                            "user":  "PaulusParssinen",
                                            "createdAt":  "2023-06-24T19:40:37Z"
                                        },
                                        {
                                            "content":  "EYES",
                                            "user":  "alexey-zakharov",
                                            "createdAt":  "2024-10-22T13:47:18Z"
                                        }
                                    ],
                          "totalCount":  5
                      },
        "updatedAt":  "2025-07-26T10:40:47Z",
        "body":  "**Version Used**: \r\n.NET 7.0.400-preview.23225.8\r\n\r\n**Steps to Reproduce**:\r\n\r\nStarted as an investigation of https://github.com/jbevain/cecil/issues/913\r\n\r\n1. Compile this absolute unit of a compilation unit as the single file of a library project: https://gist.github.com/jbevain/9599e655adad445a6ee447add305a8bc\r\n2. Reference the library in a console project:\r\n\r\n```csharp\r\nusing System.Reflection;\r\n\r\nvar a = Assembly.LoadFile(typeof(P3).Assembly.Location);\r\nforeach (var t in a.GetTypes())\r\n{\r\n    Console.WriteLine(t.FullName);\r\n    foreach (var m in t.GetMethods(BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Instance | BindingFlags.Static))\r\n    {\r\n        Console.WriteLine(m.Name);\r\n        foreach (var p in m.GetParameters())\r\n        {\r\n            Console.WriteLine(p.Name);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n3. `dotnet run` the console project:\r\n\r\n**Expected Behavior**:\r\nShould print:\r\n\r\n```\r\n...\r\nF_65534\r\na\r\n```\r\n\r\n**Actual Behavior**:\r\n\r\n```\r\n...\r\nF_65534\r\nUnhandled exception. System.BadImageFormatException: File is corrupt. (0x8013110E)\r\n   at System.Reflection.MetadataImport._Enum(IntPtr scope, Int32 type, Int32 parent, MetadataEnumResult\u0026 result)\r\n   at System.Reflection.RuntimeParameterInfo.GetParameters(IRuntimeMethodInfo methodHandle, MemberInfo member, Signature sig, ParameterInfo\u0026 returnParameter, Boolean fetchReturnParameter)\r\n   at System.Reflection.RuntimeMethodInfo.GetParameters()\r\n   at Program.\u003cMain\u003e$(String[] args) in C:\\tmp\\ReproFFFF\\exe\\Program.cs:line 10\r\n```\r\n\r\nNote that the last row of the `Method` table has a `Param` of `0x80000000` which is unexpected:\r\n\r\n\u003cimg width=\"790\" alt=\"Screenshot 2023-06-23 at 5 50 21 PM\" src=\"https://github.com/dotnet/roslyn/assets/79284/faef24a0-1107-4bce-a71e-1e7c130e95bd\"\u003e\r\n\r\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOrFK2rA==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5sOEr0",
                                           "createdAt":  "2023-06-24T15:28:19Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jbevain",
                                           "body":  "Michal pointed at the similarity with his old issue: https://github.com/dotnet/coreclr/pull/20865\r\n\r",
                                           "updatedAt":  "2023-06-24T21:05:05Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5sOEr2",
                                           "createdAt":  "2023-11-16T16:11:31Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "FSDKO",
                                           "body":  "I found a similar error but with fields: dotnet/runtime#94890",
                                           "updatedAt":  "2023-11-16T16:11:31Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5sOEr4",
                                           "createdAt":  "2023-11-16T19:18:46Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jbevain",
                                           "body":  "@FSDKO yes, everything that is represented as a “range” in metadata (Fields, Methods, Parameters) has this issue.",
                                           "updatedAt":  "2023-11-16T19:18:46Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5sOEt0",
                                           "createdAt":  "2023-11-17T02:01:14Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-reflection\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n**Version Used**: \r\n.NET 7.0.400-preview.23225.8\r\n\r\n**Steps to Reproduce**:\r\n\r\nStarted as an investigation of https://github.com/jbevain/cecil/issues/913\r\n\r\n1. Compile this absolute unit of a compilation unit as the single file of a library project: https://gist.github.com/jbevain/9599e655adad445a6ee447add305a8bc\r\n2. Reference the library in a console project:\r\n\r\n```csharp\r\nusing System.Reflection;\r\n\r\nvar a = Assembly.LoadFile(typeof(P3).Assembly.Location);\r\nforeach (var t in a.GetTypes())\r\n{\r\n    Console.WriteLine(t.FullName);\r\n    foreach (var m in t.GetMethods(BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Instance | BindingFlags.Static))\r\n    {\r\n        Console.WriteLine(m.Name);\r\n        foreach (var p in m.GetParameters())\r\n        {\r\n            Console.WriteLine(p.Name);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n3. `dotnet run` the console project:\r\n\r\n**Expected Behavior**:\r\nShould print:\r\n\r\n```\r\n...\r\nF_65534\r\na\r\n```\r\n\r\n**Actual Behavior**:\r\n\r\n```\r\n...\r\nF_65534\r\nUnhandled exception. System.BadImageFormatException: File is corrupt. (0x8013110E)\r\n   at System.Reflection.MetadataImport._Enum(IntPtr scope, Int32 type, Int32 parent, MetadataEnumResult\u0026 result)\r\n   at System.Reflection.RuntimeParameterInfo.GetParameters(IRuntimeMethodInfo methodHandle, MemberInfo member, Signature sig, ParameterInfo\u0026 returnParameter, Boolean fetchReturnParameter)\r\n   at System.Reflection.RuntimeMethodInfo.GetParameters()\r\n   at Program.\u003cMain\u003e$(String[] args) in C:\\tmp\\ReproFFFF\\exe\\Program.cs:line 10\r\n```\r\n\r\nNote that the last row of the `Method` table has a `Param` of `0x80000000` which is unexpected:\r\n\r\n\u003cimg width=\"790\" alt=\"Screenshot 2023-06-23 at 5 50 21 PM\" src=\"https://github.com/dotnet/roslyn/assets/79284/faef24a0-1107-4bce-a71e-1e7c130e95bd\"\u003e\r\n\r\n\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003ejbevain\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`bug`, `area-System.Reflection`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-11-17T02:01:14Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5sOEvg",
                                           "createdAt":  "2023-11-17T02:01:25Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-reflection-metadata\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n**Version Used**: \r\n.NET 7.0.400-preview.23225.8\r\n\r\n**Steps to Reproduce**:\r\n\r\nStarted as an investigation of https://github.com/jbevain/cecil/issues/913\r\n\r\n1. Compile this absolute unit of a compilation unit as the single file of a library project: https://gist.github.com/jbevain/9599e655adad445a6ee447add305a8bc\r\n2. Reference the library in a console project:\r\n\r\n```csharp\r\nusing System.Reflection;\r\n\r\nvar a = Assembly.LoadFile(typeof(P3).Assembly.Location);\r\nforeach (var t in a.GetTypes())\r\n{\r\n    Console.WriteLine(t.FullName);\r\n    foreach (var m in t.GetMethods(BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Instance | BindingFlags.Static))\r\n    {\r\n        Console.WriteLine(m.Name);\r\n        foreach (var p in m.GetParameters())\r\n        {\r\n            Console.WriteLine(p.Name);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n3. `dotnet run` the console project:\r\n\r\n**Expected Behavior**:\r\nShould print:\r\n\r\n```\r\n...\r\nF_65534\r\na\r\n```\r\n\r\n**Actual Behavior**:\r\n\r\n```\r\n...\r\nF_65534\r\nUnhandled exception. System.BadImageFormatException: File is corrupt. (0x8013110E)\r\n   at System.Reflection.MetadataImport._Enum(IntPtr scope, Int32 type, Int32 parent, MetadataEnumResult\u0026 result)\r\n   at System.Reflection.RuntimeParameterInfo.GetParameters(IRuntimeMethodInfo methodHandle, MemberInfo member, Signature sig, ParameterInfo\u0026 returnParameter, Boolean fetchReturnParameter)\r\n   at System.Reflection.RuntimeMethodInfo.GetParameters()\r\n   at Program.\u003cMain\u003e$(String[] args) in C:\\tmp\\ReproFFFF\\exe\\Program.cs:line 10\r\n```\r\n\r\nNote that the last row of the `Method` table has a `Param` of `0x80000000` which is unexpected:\r\n\r\n\u003cimg width=\"790\" alt=\"Screenshot 2023-06-23 at 5 50 21 PM\" src=\"https://github.com/dotnet/roslyn/assets/79284/faef24a0-1107-4bce-a71e-1e7c130e95bd\"\u003e\r\n\r\n\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003ejbevain\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`bug`, `area-System.Reflection`, `area-System.Reflection.Metadata`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-11-17T02:01:25Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5sOFFF",
                                           "createdAt":  "2023-11-17T02:03:18Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AlekseyTs",
                                           "body":  "Probably the same as #94890, but with parameters.",
                                           "updatedAt":  "2023-11-17T02:03:18Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5sU-R9",
                                           "createdAt":  "2023-11-18T08:21:29Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "MichalStrehovsky",
                                           "body":  "@AlekseyTs There was in the past interest to work around this in the Roslyn compiler itself by generating a dummy field/method. If we do a file format change to fix this file format bug, it would very likely _not_ be backported to desktop CLR.\r\n\r\nRef: https://github.com/dotnet/coreclr/pull/20865#issuecomment-437552363",
                                           "updatedAt":  "2023-11-18T08:21:29Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5sVlTx",
                                           "createdAt":  "2023-11-18T18:59:36Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AlekseyTs",
                                           "body":  "@MichalStrehovsky \r\n\r\n\u003e There was in the past interest to work around this in the Roslyn compiler itself by generating a dummy field/method.\r\n\r\nI do not think compilers would want to do that. In my opinion, if ```System.Reflection.Metadata``` is required to use 2bytes size for scenarios that it cannot represent correctly, then it should be responsible for adding those dummy rows to overcome the 2byte requirement. It has all the information necessary to detect the edge cases. ",
                                           "updatedAt":  "2023-11-18T18:59:36Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5sVlkZ",
                                           "createdAt":  "2023-11-18T19:02:40Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AlekseyTs",
                                           "body":  "It would also be interesting to see how native metadata writer was dealing with the situation.",
                                           "updatedAt":  "2023-11-18T19:02:40Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5sWOfZ",
                                           "createdAt":  "2023-11-19T06:48:15Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "MichalStrehovsky",
                                           "body":  "\u003e It would also be interesting to see how native metadata writer was dealing with the situation.\r\n\r\nIt doesn\u0027t.\r\n\r\nThe linked PR (https://github.com/dotnet/coreclr/pull/20865) that didn\u0027t merge has the details. The file format spec has allowance to represent this situation but neither the writers nor the readers implement it. If we fix this bug by implementing the spec, it would be netcore only. That\u0027s why the referenced comment from Tomas calls for a separate Roslyn issue to emit a workaround method/field instead.",
                                           "updatedAt":  "2023-11-19T06:48:15Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5scYPi",
                                           "createdAt":  "2023-11-20T16:18:41Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AlekseyTs",
                                           "body":  "\u003e That\u0027s why the referenced comment from Tomas calls for a separate Roslyn issue to emit a workaround method/field instead.\r\n\r\nImplementing the workaround in ```System.Reflection.Metadata``` will have the same effect, and, I think, it will be a much better place to do that.  ",
                                           "updatedAt":  "2023-11-20T16:22:02Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5seE5M",
                                           "createdAt":  "2023-11-20T21:22:59Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "MichalStrehovsky",
                                           "body":  "All of our metadata writers give callers full control over emitted tokens. Emitting extra tokens behind user\u0027s back would likely just replace a bug with a new bug. The ECMA-335 metadata formats are used for things that are not .NET programs (winmd, toc files, IBC profile data, coff object files to be used with link.exe and metadata merging etc.). The metadata writer doesn\u0027t know what it\u0027s s actually emitting and how legal a dummy would be. I don\u0027t think it can emit a dummy.\r\n\r\nEmitting a dummy set of tokens from S.R.Metadata behind the back may even break Roslyn\u0027s EnC scenarios (but I\u0027m not authoritave on EnC).",
                                           "updatedAt":  "2023-11-20T21:22:59Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5seTIw",
                                           "createdAt":  "2023-11-20T22:07:32Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AlekseyTs",
                                           "body":  "\u003e The metadata writer doesn\u0027t know what it\u0027s s actually emitting and how legal a dummy would be. I don\u0027t think it can emit a dummy.\r\n\r\nIsn\u0027t not emitting the dummy definitely wrong, for any kind of output? I am specifically talking about scenarios when there is a need to refer past the end of the table.\r\n\r\nDo we know of any scenario for which not emitting a dummy is desired? BTW, EnC scenario, is compiler scenario as well. ",
                                           "updatedAt":  "2023-11-20T22:14:45Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5seWL_",
                                           "createdAt":  "2023-11-20T22:18:00Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "MichalStrehovsky",
                                           "body":  "\u003e \u003e The metadata writer doesn\u0027t know what it\u0027s s actually emitting and how legal a dummy would be. I don\u0027t think it can emit a dummy.\r\n\u003e \r\n\u003e Isn\u0027t not emitting the dummy definitely wrong, for any kind of output? I am specifically talking about scenarios when there is a need to refer past the end of the table.\r\n\r\nThe proper fix is to implement the file format spec which allows representing this situation differently. It is what the linked PR was trying to do in the native writer. There would be a similar fix for S.R.Metadata reader and writer. It would be netcore only. Roslyn would need to emit a workaround token if it still cares about desktop because desktop is very unlikely to get a fix in its reader.\r\n\r\nFor desktop CLR, such netcore-only fix wouldn\u0027t make things any worse than they are now because without the fix, we would have a record that is not readable, and with the fix, we would have a record that is not readable either. (See the PR description on how that\u0027s achieved.)",
                                           "updatedAt":  "2023-11-20T22:21:18Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5seXz7",
                                           "createdAt":  "2023-11-20T22:23:31Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AlekseyTs",
                                           "body":  "It looks like we are going in circle. The questions that I am asking are not getting answered. At the moment, I am not convinced that pushing the fix to compilers is the right thing to do. And the fix in S.R.Metadata looks like a viable alternative to me. I am happy to continue discussion off-line (Teams meeting/call, etc).  ",
                                           "updatedAt":  "2023-11-20T22:25:28Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5seaH9",
                                           "createdAt":  "2023-11-20T22:32:01Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "MichalStrehovsky",
                                           "body":  "I know what you mean - you want to replace a bug in S.R.Metadata (emitting assemblies that are not readable) with another bug (emitting assemblies that have tokens the user didn\u0027t ask for). You are asking for this because Roslyn doesn\u0027t care about the other bug (if we rule out EnC is not affected, which I\u0027m not sure about). S.R.Metadata does care about the other bug too. Such fix would not be acceptable for the other non-Roslyn scenarios where S.R.Metadata is used.\r\n\r\nWe could consider a flag to metadata writer called \"EmitWorkaroundTokensThereMaybeBugs\" to allow emitting workaround tokens. If Roslyn opts into this and runs into bugs due to that (netmodules generated like that might not be mergable with link.exe due to duplicate workaround methods, for example), it will be Roslyn bugs. I don\u0027t think it fixes much.",
                                           "updatedAt":  "2023-11-20T22:32:01Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5seaLy",
                                           "createdAt":  "2023-11-20T22:32:15Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AlekseyTs",
                                           "body":  "If you are proposing going with a format change instead and compilers emitting a dummy token only for the benefit a legacy desktop metadata reader, That is probably an option. But, then, I think the S.R.Metadata should be fixed first, and then we in Compilers can decide if we care about the legacy case, which is broken today anyway.  ",
                                           "updatedAt":  "2023-11-20T23:13:18Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5sekCc",
                                           "createdAt":  "2023-11-20T23:10:04Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AlekseyTs",
                                           "body":  "\u003e you want to replace a bug in S.R.Metadata (emitting assemblies that are not readable) with another bug (emitting assemblies that have tokens the user didn\u0027t ask for). \r\n\r\nI do not think I agree with this interpretation. Or, if we call the workaround \"another bug\". I do not see why \"another bug\" in Compilers is better than \"another bug\" in S.R.Metadata.\r\n\r\n\u003e Such fix would not be acceptable for the other non-Roslyn scenarios where S.R.Metadata is used.\r\n\r\nI asked for a single concrete example that would support this statement. So far, none were given. Until then, I remain very skeptical that this is actually the case and assume that the statement is false. \r\n\r\n",
                                           "updatedAt":  "2023-11-20T23:14:27Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5sgCCo",
                                           "createdAt":  "2023-11-21T06:53:04Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "MichalStrehovsky",
                                           "body":  "\u003e I do not see why \"another bug\" in Compilers is better than \"another bug\" in S.R.Metadata.\r\n\r\nI don\u0027t believe the contract of the C# compiler is to generate 1:1 type/method mapping with the input C# source code or there would be no `RefSafetyRulesAttribute` type injected into Roslyn outputs, for example. It is however the contract of System.Reflection.Metadata because the API is a low level API operating on tokens.\r\n\r\n\u003e I asked for a single concrete example that would support this statement. So far, none were given.\r\n\r\nI gave concrete examples where the ECMA-335 file format is used for purposes that are not \".NET program\" above (\"winmd, toc files, IBC profile data, coff object files\"). The file format is a convenient way to represent various things that are not \"executable .NET programs\" and we cannot make an assumption that adding an extra type would be harmless. We already have uses within Microsoft where this is invalid or requires special care and that doesn\u0027t count customer uses that we don\u0027t know about.\r\n\r\nWinMD is a file format based on ECMA-335. A dummy that is valid to emit in a WinMD looks different from a dummy for a .NET program (I don\u0027t actually know a dummy would look so that it doesn\u0027t upset tools that read WinMD). S.R.Metadata writer doesn\u0027t have much awareness about whether it\u0027s emitting WinMD. WinMD is just an example where someone took a .NET file format and used it for non-.NET things.\r\n\r\nA TOC file looks like an assembly, but it\u0027s an input to a compiler, not a runnable thing. It provides information about how an assembly got compiled into a shared native library. It contains a subset of an existing assembly that got compiled to native code. If this subset happens to hit the 0xFFFF case and the metadata writer inserts a type/method that didn\u0027t exist in the original assembly (original that had more than 0xFFFF methods and didn\u0027t need a dummy), the TOC no longer matches the input assembly. Whether the reader will be able to handle it or crash is up to chance.",
                                           "updatedAt":  "2023-11-21T06:53:04Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5sizCx",
                                           "createdAt":  "2023-11-21T14:43:57Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODNOxoQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_DOWN",
                                                                               "user":  "MichalStrehovsky",
                                                                               "createdAt":  "2023-11-21T14:47:29Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "AlekseyTs",
                                           "body":  "None of these are concrete examples. A concrete example is a specific scenario. This is what we do today and it works great. This is how it would look like with the dummy and this is how it breaks. With details where it breaks and why that part cannot be adjusted to not break. ",
                                           "updatedAt":  "2023-11-21T14:44:30Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5si-Os",
                                           "createdAt":  "2023-11-21T15:08:28Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AlekseyTs",
                                           "body":  "Even if we decide that the behavior of `S.R.Metadata` cannot be changed unconditionally, there is always an option to make it conditional and be controllable by a client. One of the purposes of this reusable component is to shield clients from internal details of column sizes, etc. I think that it is not appropriate for compilers to worry about such things and be responsible for duplicating internal logic of that reusable component. In my opinion this complexity doesn\u0027t belong in compilers.\r\n\r\nNote, at the moment, I am not even convinced that the suggested workaround (with the dummy) is appropriate for compiler scenarios. That is another reason why I am not comfortable with implementing it in compilers. For example, when a .NET module is produced, compiler is constrained in terms of what extra types it embeds. Presence of those can cause unexpected failures when multimodule assemblies are produced, or multiple modules are merged into a single assembly.",
                                           "updatedAt":  "2023-11-21T15:08:28Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5tKQzr",
                                           "createdAt":  "2023-11-29T08:09:33Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "MichalStrehovsky",
                                           "body":  "Another example where S.R.Metadata injecting random things into the output would likely break is the https://github.com/microsoft/win32metadata project. It\u0027s another example of a project using ECMA-335 file format to store things that are not executable .NET programs and have its own rules (like visibility/accessibility being meaningless because this format pretty much encodes a C header file).",
                                           "updatedAt":  "2023-11-29T08:09:33Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5tOnQB",
                                           "createdAt":  "2023-11-29T19:14:27Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AlekseyTs",
                                           "body":  "\u003e Another example where S.R.Metadata injecting random things into the output would likely break is ...\r\n\r\nI guess what I am still having a hard time to understand is how already broken scenarios (one cannot read the metadata back) can be broken by a fix. The proposed workaround might not be considered as a \"fix\" for them (i.e. they remain broken, but in a different way), that I can understand.",
                                           "updatedAt":  "2023-11-29T19:19:58Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5tPQQT",
                                           "createdAt":  "2023-11-29T21:18:32Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "MichalStrehovsky",
                                           "body":  "\u003e The proposed workaround might not be considered as a \"fix\" for them (i.e. they remain broken, but in a different way), that I can understand.\r\n\r\nThey may not be broken. The ECMA-335 file format does have a provision for this, it\u0027s just S.R.Metadata and the native reader/writer in CoreCLR wasn\u0027t implemented to support what the spec says. Win32Metadata is used by multiple other projects. E.g. one of them is a Rust repo that has a metadata reader written in Rust. Maybe that one implements the spec and would handle it. If a reader implements the spec, it would work. Spec has a provision for it (put 0 for the method list instead of num_methods+1).\r\n\r\nWe\u0027d need to update our readers to support this because they failed to implement the spec.",
                                           "updatedAt":  "2023-11-29T21:18:32Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5tPmUx",
                                           "createdAt":  "2023-11-29T22:32:37Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AlekseyTs",
                                           "body":  "\u003e Spec has a provision for it (put 0 for the method list instead of num_methods+1).\r\n\r\nCould you provide a specific quote and where the provision can be found? For example, I was able to find the following in ECMA-335 \"II.22.37 TypeDef : 0x02\" section. And it looks like putting 0 would be a violation of the spec.\r\n\u003e - FieldList (an index into the Field table; it marks the first of a contiguous run of Fields owned by this Type). The run continues to the smaller of:\r\n\u003e    - the last row of the Field table\r\n\u003e    - the next run of Fields, found by inspecting the FieldList of the next row in this TypeDef table\r\n\u003e - MethodList (an index into the MethodDef table; it marks the first of a continguous run of Methods owned by this Type). The run continues to the smaller of:\r\n\u003e     - the last row of the MethodDef table\r\n\u003e     - the next run of Methods, found by inspecting the MethodList of the next row in this TypeDef table",
                                           "updatedAt":  "2023-11-29T22:32:37Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5tPoE7",
                                           "createdAt":  "2023-11-29T22:39:34Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "MichalStrehovsky",
                                           "body":  "\"Indexes to tables begin at 1, so index 1 means the first row in any given metadata table. (An index \r\nvalue of zero denotes that it does not index a row at all; that is, it behaves like a null reference.)\"",
                                           "updatedAt":  "2023-11-29T22:39:34Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5tPpT7",
                                           "createdAt":  "2023-11-29T22:44:10Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "MichalStrehovsky",
                                           "body":  "Combined with \"18. MethodList can be null or non-null\"",
                                           "updatedAt":  "2023-11-29T22:44:10Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5tPvgs",
                                           "createdAt":  "2023-11-29T23:07:56Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AlekseyTs",
                                           "body":  "Thank you for the quotes. Well, I am not surprised that we ended up with the current implementation. Different sections of the spec are, essentially, contradict each other. Or, perhaps, some of the sections are incomplete, while they could easily be interpreted as specifying complete set of possible values. ",
                                           "updatedAt":  "2023-11-29T23:07:56Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5wQNHl",
                                           "createdAt":  "2024-01-09T15:44:50Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "steveharter",
                                           "body":  "Since the issue with 0xFFFF applies to parameters, fields and methods we should just use this issue.\r\n\r\nOther issues:\r\n- Fields (https://github.com/dotnet/runtime/issues/94890)\r\n- Methods (repro at https://gist.github.com/steveharter/a4a03fe43720913e9a7ba6f1b7787e71)",
                                           "updatedAt":  "2024-01-09T15:44:50Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6sUras",
                                           "createdAt":  "2025-05-19T13:47:14Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOESuw8Q==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "EYES",
                                                                               "user":  "yaakov-h",
                                                                               "createdAt":  "2025-05-20T01:30:16Z"
                                                                           },
                                                                           {
                                                                               "content":  "EYES",
                                                                               "user":  "Dane-Dai",
                                                                               "createdAt":  "2025-05-20T02:02:01Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "dj-wtg",
                                           "body":  "We seem to be affected by this or a similar issue with Ngen on .NET Framework 4.8.1.\n\nAn assembly is compiled with .NET 8 SDK targeting net48, and then passed to Ngen.exe to create a native image.\n\nWhen the compiled assembly has a final Blob Heap entry with offset 0xFFFF, ngen generates a native image DLL that is corrupt. Ngen runs successfully with no error messages at the time of generating the image. However when a process tries to load the native image, it throws a BadImageFormatException.",
                                           "updatedAt":  "2025-05-19T13:47:14Z"
                                       }
                                   ],
                         "totalCount":  30
                     },
        "title":  "Compiler can silently generate a bad image when there\u0027s 0xFFFF parameters in the module",
        "labels":  [
                       "bug",
                       "design-discussion",
                       "area-System.Reflection.Metadata"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/99244",
        "createdAt":  "2024-03-04T16:22:44Z",
        "number":  99244,
        "author":  "jaredpar",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-07-26T10:47:03Z",
        "body":  "### Description\r\n\r\nThe `BlobBuilder.ReserveBytes` method allows for callers to observe the backing `byte[]` before any data is written to it. Normally that is fine because `BlobBuilder` instances newly allocate the `byte[]` on construction so the data is zero\u0027d out. In the case the `BlobBuilder` is created via pooling (the type supports pooling) then the data is whatever was written by the last consumer of the instance. \r\n\r\n\r\n### Reproduction Steps\r\n\r\nCan observe using the following steps: \r\n\r\n```csharp \r\n// Using PooledBlobBuilder from the SMR code base. Put used content \r\n// into the pool\r\nvar builder = PooledBlobBuilder.GetInstance();\r\nbuilder.WriteBytes(42, 4);\r\nbuilder.Free();\r\n\r\n// Now grab a builder from the pool\r\nbuilder = PooledBlobBuilder.GetInstance();\r\nvar blob = builder.ReserveBytes(4);\r\nConsole.WriteLine(blob.GetBytes()[0]); // prints 42\r\n```\r\n\r\n### Expected behavior\r\n\r\nThe consumer should not be able to meaningfully observe the content from the previous writer. \r\n\r\n### Actual behavior\r\n\r\nThe consumer can observe the content from the previous writer\r\n\r\n### Regression?\r\n\r\nThis makes it more difficult for roslyn to widely use pooled `BlobBuilder` instances in our code base. Consider for example the code in [PEBuilder.WriteCoffHeader][writecoffheader]: \r\n\r\n```csharp\r\nstampFixup = builder.ReserveBytes(sizeof(uint));\r\n```\r\n\r\nThis means that the `BlobBuilder` used for writing out the COFF header has four bytes that are uninitialized / non-zero. That means the underlying `Blob` for the COFF header is non-deterministic in the face of a pooled `BlobBuilder`. That non-determinism is then passed to `PEBuilder.IdProvider` resulting in non-deterministic MVID + timestamps being generated for the PE.\r\n\r\n\r\n\r\n[writecoffheader]: https://source.dot.net/#System.Reflection.Metadata/System/Reflection/PortableExecutable/PEBuilder.cs,201\r\n\r\n### Known Workarounds\r\n\r\nRoslyn can work around this by force zero-ing `BlobBuilder` that are used in COFF generation but it\u0027s better to fix the underlying bug. \r\n\r\n### Configuration\r\n\r\n_No response_\r\n\r\n### Other information\r\n\r\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOmiMojg==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc511kKV",
                                           "createdAt":  "2024-03-04T16:26:48Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-reflection-metadata\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Description\n\nThe `BlobBuilder.ReserveBytes` method allows for callers to observe the backing `byte[]` before any data is written to it. Normally that is fine because `BlobBuilder` instances newly allocate the `byte[]` on construction so the data is zero\u0027d out. In the case the `BlobBuilder` is created via pooling (the type supports pooling) then the data is whatever was written by the last consumer of the instance. \r\n\n\n### Reproduction Steps\n\nCan observe using the following steps: \r\n\r\n```csharp \r\n// Using PooledBlobBuilder from the SMR code base. Put used content \r\n// into the pool\r\nvar builder = PooledBlobBuilder.GetInstance();\r\nbuilder.WriteBytes(42, 4);\r\nbuilder.Free();\r\n\r\n// Now grab a builder from the pool\r\nbuilder = PooledBlobBuilder.GetInstance();\r\nvar blob = builder.ReserveBytes(4);\r\nConsole.WriteLine(blob.GetBytes()[0]); // prints 42\r\n```\n\n### Expected behavior\n\nThe consumer should not be able to meaningfully observe the content from the previous writer. \n\n### Actual behavior\n\nThe consumer can observe the content from the previous writer\n\n### Regression?\n\nThis makes it more difficult for roslyn to widely use pooled `BlobBuilder` instances in our code base. Consider for example the code in [PEBuilder.WriteCoffHeader][writecoffheadeer]: \r\n\r\n```csharp\r\nstampFixup = builder.ReserveBytes(sizeof(uint));\r\n```\r\n\r\nThis means that the `BlobBuilder` used for writing out the COFF header has four bytes that are uninitialized / non-zero. That means the underlying `Blob` for the COFF header is non-deterministic in the face of a pooled `BlobBuilder`. That non-determinism is then passed to `PEBuilder.IdProvider` resulting in non-deterministic MVID + timestamps being generated for the PE.\r\n\r\n\r\n\r\n[writecoffheader]: https://source.dot.net/#System.Reflection.Metadata/System/Reflection/PortableExecutable/PEBuilder.cs,201\n\n### Known Workarounds\n\nRoslyn can work around this by force zero-ing `BlobBuilder` that are used in COFF generation but it\u0027s better to fix the underlying bug. \n\n### Configuration\n\n_No response_\n\n### Other information\n\n_No response_\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003ejaredpar\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Reflection.Metadata`, `untriaged`, `needs-area-label`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2024-03-04T16:26:48Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6GTpiI",
                                           "createdAt":  "2024-07-26T18:51:34Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "buyaa-n",
                                           "body":  "@jaredpar is this needed for 9.0?",
                                           "updatedAt":  "2024-07-26T18:51:34Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6Gw0zf",
                                           "createdAt":  "2024-07-31T16:47:27Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODsWEaA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "buyaa-n",
                                                                               "createdAt":  "2024-07-31T22:02:05Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "ericstj",
                                           "body":  "I think this is valuable to fix, but I can also imagine some callers caring about the performance hit of zeroing the memory.  I wonder if we need API around it to allow callers to express that?\r\n\r\nI see @jaredpar likely opened this while working on https://github.com/dotnet/roslyn/pull/72383 and implemented zero-ing there (with an API, presumably for similar concerns).\r\n\r\nAs a result I don\u0027t think Roslyn is blocked on this, and we should take this as a good API suggestion to evaluate in the next release.",
                                           "updatedAt":  "2024-07-31T16:47:27Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6HKXs6",
                                           "createdAt":  "2024-08-04T19:22:23Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jaredpar",
                                           "body":  "\u003e As a result I don\u0027t think Roslyn is blocked on this, and we should take this as a good API suggestion to evaluate in the next release.\r\n\r\nIt\u0027s true that we found a work around but it\u0027s definitely not optimal. Instead of directly clearing the memory using a fast span primitive as the implementation of `ReserveBytes` can do we have to do a `WriteBytes` which is less efficient.\r\n\r\n\u003e I wonder if we need API around it to allow callers to express that?\r\n\r\nI\u0027m fine with a different API that did this. Even a simple `Zero` method is enough as it can efficiently clear the memory. ",
                                           "updatedAt":  "2024-08-04T19:22:35Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6aIyiO",
                                           "createdAt":  "2025-01-13T00:37:17Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "teo-tsirpanis",
                                           "body":  "Will implement alongside #100418.",
                                           "updatedAt":  "2025-01-13T00:37:17Z"
                                       }
                                   ],
                         "totalCount":  5
                     },
        "title":  "BlobBuilder.ReserveBytes needs to zero the memory",
        "labels":  [
                       "area-System.Reflection.Metadata",
                       "help wanted"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/100418",
        "createdAt":  "2024-03-28T19:10:14Z",
        "number":  100418,
        "author":  "jaredpar",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHODR9VgQ==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Wraith2",
                                            "createdAt":  "2024-03-29T01:49:14Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "PaulusParssinen",
                                            "createdAt":  "2024-03-29T08:10:02Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "am11",
                                            "createdAt":  "2024-04-29T18:43:07Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "0xfeeddeadbeef",
                                            "createdAt":  "2025-09-19T16:14:32Z"
                                        }
                                    ],
                          "totalCount":  4
                      },
        "updatedAt":  "2025-07-26T10:47:05Z",
        "body":  "### Background and motivation\r\n\r\nThe `BlobBuilder` type is a mix between: \r\n\r\n1. Trying to emulate the underlying mechanics and allocation profile of `StringBuilder` \r\n2. Extensible so that consumers of System.Reflection.Metadata can control allocations of `BlobBuilder` (with pooling) \r\n\r\nIn its current configuration it doesn\u0027t fully achieve either of these goals due the following reasons:\r\n\r\n1. `BlobBuilder` has no enforced maximum internal chunk size. Instead during write operations it has a much simpler strategy of use rest of current `BlobBuilder` then allocate a single `BlobBuilder` to hold the rest. That results in lots of LOH allocations during build. \r\n2. There are many types in `System.Reflection.Metadata` has no mechanism for consumers to provide derived `BlobBuilder` instances and instead allocate `BlobBuilder` types directly. This subverts attempts by consumers to pool allocations.\r\n3. The `LinkSuffix / LinkPrefix` APIs can end up silently mixing the types of `BlobBuilder` instances in a chain. That makes advanced caching like pooling array allocations impossible because types with different caching strategies get silently inserted into the chain. When these insertions happen the `byte[]` underlying the instances are swapped.\r\n4. There is to mechanism to control the underlying `byte[]` allocation which prevents these from being pooled. Only the `BlobBuilder` instances can be pooled which means their underlying `byte[]` is inefficiently managed because it can\u0027t be re-used when the containing `BlobBuilder` is at rest. This is in contrast to `StringBuilder` which leverages the `ArrayPool\u003cchar\u003e` for allocations.\r\n5. There is no easy mechanism for derived types to control zeroing of underlying `byte[]` when a `BlobBuilder` instance from a pool is re-used. Can lead to difficult issues like [99244](#99244).\r\n\r\nThe below proposed changes are meant to address these problems such that consumers of `System.Reflection.Metadata` can do the following: \r\n\r\n1. Control the allocation of all `BlobBuilder` instances used in a emit pass.\r\n2. Control and manage the underlying `byte[]` in the `BlobBuilder`.\r\n3. Detect when `BlobBuilder` instances are linked with `BlobBuilder` instances of a different type. \r\n\r\nUsing the below changes I\u0027ve been able to significantly improve the allocation profile of VBCSCompiler. For building a solution the scale of [compilers.slnf][compilers-slnf] (~500 compilation events, large, small and medium projects) I\u0027ve been able to remove ~200MB of LOH for `byte[]` and reduce GC pause time by 1.5%. \r\n\r\n[compilers-slnf]: https://github.com/dotnet/roslyn/blob/main/Compilers.slnf\r\n\r\n\r\n### API Proposal\r\n\r\n```diff\r\nnamespace System.Reflection.Metadata;\r\n\r\npublic class BlobBuilder\r\n{\r\n+    /// \u003csummary\u003e\r\n+    /// The byte array underpinning the \u003csee cref=\"BlobBuilder\"/\u003e. This can only be called on\r\n+    /// the head of a chain of \u003csee cref=\"BlobBuilder\"/\u003e instances. Calling the setter will reset\r\n+    /// the \u003csee cref=\"Length\"\u003e to zero.\r\n+    /// \u003c/summary\u003e\r\n+    protected byte[] Buffer { get; set; }\r\n\r\n+    /// \u003csummary\u003e\r\n+    /// Derived types can override this to restrict maximum chunk size to allocate when writing\r\n+    /// a contiguous set of bytes through the WriteBytes APIs. When unset the default is to allocate\r\n+    /// a chunk for the rest of the bytes that don\u0027t fit into the current chunk.\r\n+    /// \u003c/summary\u003e\r\n+    protected virtual int? MaxChunkSize =\u003e null;\r\n\r\n+    /// \u003csummary\u003e\r\n+    /// Set the capacity of the \u003csee cref=\"BlobBuilder\"/\u003e.\r\n+    // \u003c/summary\u003e\r\n+    public int Capacity { get; set; }\r\n\r\n+    protected BlobBuilder(byte[] buffer);\r\n\r\n+    /// \u003csummary\u003e\r\n+    /// This method is called in \u003csee cref=\"LinkSuffix\"\u003e or \u003csee cref=\"LinkPrefix\"\u003e for both the\r\n+    /// current instance as well as the target of the link method. This allows derived types to \r\n+    /// detect when a link is being made between two different types of \u003csee cref=\"BlobBuilder\"/\u003e\r\n+    /// and take appropriate action.\r\n+    /// \u003c/summary\u003e\r\n+    /// \u003cremarks\u003e\r\n+    /// This method is called before the underlying buffers are swapped.\r\n+    /// \u003c/remarks\u003e\r\n+    protected virtual void BeforeSwap(BlobBuilder other);\r\n\r\n+    /// \u003csummary\u003e\r\n+    /// Derived types can override this to control the allocation when \u003csee cref=\"Capacity\"\u003e is \r\n+    /// changed.\r\n+    // \u003c/summary\u003e\r\n+    protected virtual void SetCapacity(int capacity);\r\n\r\n+    protected void WriteBytes(ReadOnlySpan\u003cbyte\u003e buffer);\r\n}\r\n\r\npublic class MetadataBuilder\r\n{\r\n+    public MetadataBuilder(\r\n+        int userStringHeapStartOffset,\r\n+        int stringHeapStartOffset,\r\n+        int blobHeapStartOffset,\r\n+        int guidHeapStartOffset,\r\n+        Func\u003cint, BlobBuilder\u003e? createBlobBuilderFunc);\r\n}\r\n\r\npublic class DebugDirectoryBuilder\r\n{\r\n+    public DebugDirectoryBuilder(BlobBuilder blobBuilder);\r\n}\r\n\r\npublic class ManagedPEBuilder\r\n{\r\n+    /// \u003csummary\u003e\r\n+    /// Dervied types can override this to control how \u003csee cref=\"BlobBuilder\"\u003e instances are \r\n+    /// allocated during the emit pass. This allows consumers to pool \u003csee cref=\"BlobBuilder\"\u003e\r\n+    /// instances more effectively.\r\n+    /// \u003c/summary\u003e\r\n+    protected virtual BlobBuilder CreateBlobBuilder(int? minimumSize = null);\r\n}\r\n\r\n```\r\n\r\n### API Usage\r\n\r\nCan see a full implementation of a [PooledBlobBuilder][pooledblobbuilder]. That branch contains the other changes necessary to use this new API. \r\n\r\n\r\n[pooledblobbuilder]: https://github.com/jaredpar/roslyn/blob/perf-builder/src/Compilers/Core/Portable/PEWriter/PooledBlobBuilder.cs\r\n\r\n### Alternative Designs\r\n\r\nOne alternative design is to limit the ability to control the underlying `byte[]` allocation and have consumers focus on pooling `BlobBuilders` only. That will provide some benefit but it is inefficient. It means that a large number of `byte[]` are unused in the pooled `BlobBuilder` instances and hence other parts of the program end up allocating them instead. \r\n\r\n### Risks\r\n\r\nThere are a few risks to consider:\r\n1. Other teams besides Roslyn can provide derived instances of `BlobBuilder`, `ManagedPEBuilder`, etc ... These changes are careful to ensure that those consumers are not impacted by these changes. The behavior of the existing code only changes when the new hooks are used in derived types.\r\n2. That the changes don\u0027t fully hook all the places `BlobBuilders` are allocated. That would mean `LinkSuffix / LinkPrefix` are called with differing types thus limiting potential gains. In my local tests I hooked `BeforeSwap` such that it fails when linked with different types. Was able to successfully rebuild Roslyn with these changes so I\u0027m confident these hooks are thorough. \r\n3. Taking advantage of `BlobBuilder.MaxChunkSize` does _significantly_ increase the number of allocated `BlobBuilder` during emit. That will require changes to pooling strategies if leveraged. However the new APIs give consumers the flexibility to pursue several strategies here. ",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOmiIOCw==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc58pdci",
                                           "createdAt":  "2024-05-02T18:35:45Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "bartonjs",
                                           "body":  "[Video](https://www.youtube.com/watch?v=oQERLVomgvE\u0026t=0h0m0s)\n\n\r\n* `WriteBytes` should have been public (typo in the proposal)\r\n* There was a question as to whether `MaxChunkSize` should be a ctor-set field. It got moved to a ctor parameter only for the byte[]-accepting protected ctor\r\n* ManagedPEBuilder.CreateBlobBulder changed from `int?=null` to `int=0` as zero has no alternative meaning\r\n* ManagedPEBuilder\u0027s new ctor should have all the parameters defaulted, and should \"un-default\" and hide the previous 4 argument ctor.\r\n* `BeforeSwap` =\u003e `OnLinking`\r\n\r\n```c#\r\npublic partial class BlobBuilder\r\n{\r\n     protected byte[] Buffer { get; set; }\r\n     public int Capacity { get; set; }\r\n\r\n     protected BlobBuilder(byte[] buffer, int maxChunkSize = 0);\r\n\r\n     protected virtual void OnLinking(BlobBuilder other);\r\n     protected virtual void SetCapacity(int capacity);\r\n\r\n     public void WriteBytes(ReadOnlySpan\u003cbyte\u003e buffer);\r\n}\r\n\r\npublic partial class DebugDirectoryBuilder\r\n{\r\n     public DebugDirectoryBuilder(BlobBuilder blobBuilder);\r\n}\r\n\r\npublic partial class ManagedPEBuilder\r\n{\r\n     protected virtual BlobBuilder CreateBlobBuilder(int minimumSize = 0);\r\n}\r\n```\r\n\r\n```diff\r\npublic partial class MetadataBuilder\r\n{\r\n+    [EditorBrowsable(EditorBrowsableState.Never)]\r\n     public MetadataBuilder(\r\n-        int userStringHeapStartOffset = 0,\r\n+        int userStringHeapStartOffset,\r\n-        int stringHeapStartOffset = 0,\r\n+        int stringHeapStartOffset,\r\n-        int blobHeapStartOffset = 0,\r\n+        int blobHeapStartOffset,\r\n-        int guidHeapStartOffset = 0);\r\n+        int guidHeapStartOffset);\r\n\r\n+    public MetadataBuilder(\r\n+        int userStringHeapStartOffset = 0,\r\n+        int stringHeapStartOffset = 0,\r\n+        int blobHeapStartOffset = 0,\r\n+        int guidHeapStartOffset = 0,\r\n+        Func\u003cint, BlobBuilder\u003e? createBlobBuilderFunc = null);\r\n}\r\n",
                                           "updatedAt":  "2024-05-02T21:25:46Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6GCkUl",
                                           "createdAt":  "2024-07-24T20:14:36Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "steveharter",
                                           "body":  "@jaredpar were you planning on porting your [branch](https://github.com/jaredpar/roslyn/blob/perf-builder/src/Compilers/Core/Portable/PEWriter/PooledBlobBuilder.cs) to runtime or were you expecting the runtime team to do this?\r\n\r\nMoving to v10 as we have reached the \"feature complete\" milestone.",
                                           "updatedAt":  "2024-07-24T20:14:36Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6GCp5R",
                                           "createdAt":  "2024-07-24T20:28:06Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jaredpar",
                                           "body":  "\u003e @jaredpar were you planning on porting your [branch](https://github.com/jaredpar/roslyn/blob/perf-builder/src/Compilers/Core/Portable/PEWriter/PooledBlobBuilder.cs) to runtime or were you expecting the runtime team to do this?\r\n\r\nI was planning on doing this but I just ran out of time. Will revisit in 10.0",
                                           "updatedAt":  "2024-07-24T20:28:06Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6aIg4L",
                                           "createdAt":  "2025-01-12T21:29:23Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "teo-tsirpanis",
                                           "body":  "I\u0027ve been working on this and will open a PR after #111292 gets merged.",
                                           "updatedAt":  "2025-01-12T21:29:23Z"
                                       }
                                   ],
                         "totalCount":  4
                     },
        "title":  "[API Proposal]: Extend BlobBuilder so consumers can better control allocations",
        "labels":  [
                       "api-approved",
                       "area-System.Reflection.Metadata"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/100920",
        "createdAt":  "2024-04-11T15:24:59Z",
        "number":  100920,
        "author":  "adamsitnik",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOC3KIcg==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "colejohnson66",
                                            "createdAt":  "2024-04-11T16:01:31Z"
                                        }
                                    ],
                          "totalCount":  1
                      },
        "updatedAt":  "2025-07-26T10:47:06Z",
        "body":  "## Background and Motivation\r\n\r\nOver the years @grabyourpitchforks has built an opinionated parser for type name parsing from untrusted input.\r\n\r\nThe parser has been adopted internally at Microsoft and for .NET 9 we have decided to productize it (and :shipit: ), in order to help us with `BinaryFormatter` removal effort.\r\n\r\nBased on feedback from @jkotas who noticed the problem of having multiple type name parsers implemented by various teams, we have decided to extend the parser with the possibility to parse all type names supported by CLR itself.\r\n\r\nThe initial proposal for `TypeName` #97566 contained a very vague boolean flag `StrictValidation`. In this proposal I would like to introduce two `[Flags] enum` that allow the users to enable opinionated restrictions.\r\n\r\n**Note:** From my perspective (I don\u0027t have security background and I am not the original author of the parser), the flags can be grouped into few categories:\r\n1. Preventing obvious attacks (examples: using path characters in the assembly name to load the assembly from a disk and perform remote code execution, using non-predefined cultures)\r\n2. Rejecting valid input that can be used as a vector of attack (example: not following the backtick convention and specifying name like ``List`1[[DateTime], [Attacker]]``)\r\n3. Rejecting valid input that was clearly mangled (example: the names provided by `Type.FullName` never use whitespaces other than space, while the CLR allows for tabs)\r\n\r\nI don\u0027t have strong opinions about the last category, but I believe than 1\u00262 are a must have.\r\n\r\n## Proposed API\r\n\r\n```csharp\r\nnamespace System.Reflection.Metadata;\r\n\r\n[Flags]\r\npublic enum TypeNameRestrictions\r\n{\r\n    /// \u003csummary\u003e\r\n    /// No restrictions beside default CLR parsing rules with all backward compatibility handling.\r\n    /// \u003c/summary\u003e\r\n    None = 0,\r\n    /// \u003csummary\u003e\r\n    /// Type names that contain escaped characters are rejected.\r\n    /// \u003cpara\u003eExample: \"Not\\+Nested\".\u003c/para\u003e\r\n    /// \u003cpara\u003eExample: \"NotAPointer\\*\".\u003c/para\u003e\r\n    /// \u003cpara\u003eSuch names are invalid for C# and F#, require using pure IL (for example via Reflection Emit).\u003c/para\u003e\r\n    /// \u003c/summary\u003e\r\n    NoEscaping = 1 \u003c\u003c 0,\r\n    /// \u003csummary\u003e\r\n    /// Type names that contain quote characters are rejected.\r\n    /// \u003cpara\u003eExample: \"Quotes\\\"AreNotAllowed\".\u003c/para\u003e\r\n    /// \u003cpara\u003eExample: \"Quote\u0027IsNotAllowed\".\u003c/para\u003e\r\n    /// \u003c/summary\u003e\r\n    NoQuoteCharacters = 1 \u003c\u003c 1,\r\n    /// \u003csummary\u003e\r\n    /// Type names that contain NULL character are rejected.\r\n    /// \u003cpara\u003eExample: \"Na\\0me\".\u003c/para\u003e\r\n    /// \u003c/summary\u003e\r\n    NoNullCharacter = 1 \u003c\u003c 2,\r\n    /// \u003csummary\u003e\r\n    /// Type names that use whitespaces other than space are rejected.\r\n    /// \u003cpara\u003eExample: \"Name\\t\".\u003c/para\u003e\r\n    /// \u003cpara\u003e\u003cseealso cref=\"Type.FullName\"/\u003e never uses such characters.\u003c/para\u003e\r\n    /// \u003c/summary\u003e\r\n    OnlySpaces = 1 \u003c\u003c 3,\r\n    /// \u003csummary\u003e\r\n    /// The number provided after a backtick must specify exact number of generic type arguments.\r\n    /// \u003cpara\u003eExample: \"List`1[[DateTime], [Attacker]]\" gets rejected.\u003c/para\u003e\r\n    /// \u003c/summary\u003e\r\n    BacktickConvention = 1 \u003c\u003c 4,\r\n    /// \u003csummary\u003e\r\n    /// Enforces the parser to reject type names that describe invalid types.\r\n    /// \u003cpara\u003eExample: byref of byref (Name\u0026amp;\u0026amp;).\u003c/para\u003e\r\n    /// \u003cpara\u003eExample: arrays with rank larger than 32 (Name[,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,]).\u003c/para\u003e\r\n    /// \u003c/summary\u003e\r\n    OnlyLegalTypes = 1 \u003c\u003c 5,\r\n    /// \u003csummary\u003e\r\n    /// Enforces all restrictions.\r\n    /// \u003c/summary\u003e\r\n    All = ~None\r\n}\r\n\r\n[Flags]\r\npublic enum AssemblyNameRestrictions\r\n{\r\n    /// \u003csummary\u003e\r\n    /// No restrictions beside default CLR parsing rules with all backward compatibility handling.\r\n    /// \u003c/summary\u003e\r\n    None = 0,\r\n    /// \u003csummary\u003e\r\n    /// Assembly names that contain path characters are rejected.\r\n    /// \u003cpara\u003eExample: \"./../PathToA.dll\".\u003c/para\u003e\r\n    /// \u003c/summary\u003e\r\n    NoPathCharacters = 1 \u003c\u003c 0,\r\n    /// \u003csummary\u003e\r\n    /// Assembly names that contain NULL character are rejected.\r\n    /// \u003cpara\u003eExample: \"Na\\0me\".\u003c/para\u003e\r\n    /// \u003c/summary\u003e\r\n    NoNullCharacter = 1 \u003c\u003c 1,\r\n    /// \u003csummary\u003e\r\n    /// Assembly names that contain unconsumed trailing characters are rejected.\r\n    /// \u003cpara\u003eExample: \"Name, \".\u003c/para\u003e\r\n    /// \u003c/summary\u003e\r\n    NoUnconsumedTrailingCharacters = 1 \u003c\u003c 2,\r\n    /// \u003csummary\u003e\r\n    /// Assembly names that use whitespaces other than space are rejected.\r\n    /// \u003cpara\u003eExample: \"Name,\\tVersion=1.2.3.4\".\u003c/para\u003e\r\n    /// \u003cpara\u003e\u003cseealso cref=\"Assembly.FullName\"/\u003e never uses such characters.\u003c/para\u003e\r\n    /// \u003c/summary\u003e\r\n    OnlySpaces = 1 \u003c\u003c 3,\r\n    /// \u003csummary\u003e\r\n    /// Assembly names that contain obsolete \u003cseealso cref=\"AssemblyName\"/\u003e attributes are rejected.\r\n    /// \u003cpara\u003eExample: \"Name, Architecture=x86\".\u003c/para\u003e\r\n    /// \u003cpara\u003eExample: \"Name, CodeBase=file://path\".\u003c/para\u003e\r\n    /// \u003c/summary\u003e\r\n    NoObsoleteAttributes = 1 \u003c\u003c 4,\r\n    /// \u003csummary\u003e\r\n    /// Unrecognized attributes are rejected.\r\n    /// \u003cpara\u003eExample: \"Name, Custom=value\".\u003c/para\u003e\r\n    /// \u003c/summary\u003e\r\n    NoUnrecognizedAttributes = 1 \u003c\u003c 5,\r\n    /// \u003csummary\u003e\r\n    /// Assembly names that contain duplicate attributes are rejected.\r\n    /// \u003cpara\u003eExample: \"Name, Version=1.2.3.4, Version=1.2.3.4\".\u003c/para\u003e\r\n    /// \u003c/summary\u003e\r\n    NoDuplicateAttributes = 1 \u003c\u003c 6,\r\n    /// \u003csummary\u003e\r\n    /// Exact casing is used to match attributes.\r\n    /// \u003cpara\u003eExample: \"Name, Version=1.2.3.4\" is allowed, but \"Name, version=1.2.3.4\" is not.\u003c/para\u003e\r\n    /// \u003c/summary\u003e\r\n    ExactCasing = 1 \u003c\u003c 7,\r\n    /// \u003csummary\u003e\r\n    /// Assembly names that use custom, non-predefined cultures are rejected.\r\n    /// \u003cpara\u003eExample: \"Name, Culture=en-US_XYZ\".\u003c/para\u003e\r\n    /// \u003c/summary\u003e\r\n    OnlyPredefinedCultures = 1 \u003c\u003c 8,\r\n    /// \u003csummary\u003e\r\n    /// Enforces all restrictions.\r\n    /// \u003c/summary\u003e\r\n    All = ~None\r\n}\r\n\r\npublic sealed class TypeNameParseOptions\r\n{\r\n    // Existing: int MaxNodes\r\n    public TypeNameRestrictions TypeNameRestrictions { get; set; } = TypeNameRestrictions.BacktickConvention;\r\n    public AssemblyNameRestrictions AssemblyNameRestrictions { get; set; } = AssemblyNameRestrictions.None;\r\n}\r\n```\r\n\r\nAssuming that #100867 gets approved, it\u0027s going to require following changes:\r\n\r\n```diff\r\npublic sealed class AssemblyNameInfo : IEquatable\u003cAssemblyNameInfo\u003e\r\n{\r\n-    public static AssemblyNameInfo Parse(ReadOnlySpan\u003cchar\u003e assemblyName);\r\n-    public static bool TryParse(ReadOnlySpan\u003cchar\u003e assemblyName, [NotNullWhenAttribute(true)] out AssemblyNameInfo? result);\r\n+    public static AssemblyNameInfo Parse(ReadOnlySpan\u003cchar\u003e assemblyName, AssemblyNameRestrictions restrictions = AssemblyNameRestrictions.None);\r\n+    public static bool TryParse(ReadOnlySpan\u003cchar\u003e assemblyName, [NotNullWhenAttribute(true)] out AssemblyNameInfo? result, AssemblyNameRestrictions restrictions = AssemblyNameRestrictions.None);\r\n}\r\n```\r\n\r\n## Usage Examples\r\n\r\n```csharp\r\nTypeNameParsingOptions options = new()\r\n{\r\n    TypeNameRestrictions = TypeNameRestrictions.All,\r\n    AssemblyNameRestrictions = AssemblyNameRestrictions.All\r\n};\r\n    \r\nTypeName parsed = TypeName.Parse(typeName, options);\r\n```\r\n\r\n## Alternative Designs\r\n\r\nWe could implement those restrictions on top of the existing `TypeName` API, but it would:\r\n- be hard to do right and require us to repeat a LOT of logic\r\n    - example: to enforce backtick convention we would need to re-parse part of the input again, find the beginning of generic arguments, then the backtick, ensure it\u0027s not escaped, try to parse the number and handle all edge cases like int overflow.\r\n- would require maintaining another package (finding a name, repo, release schedule, patching strategy and OWNERS),\r\n- would make it harder to discover and use for the end users. And this is against our ultimate goal of making .NET apps secure.\r\n\r\nAnd again, it was not our goal in the first place (we needed an opinionated, secure parser, not a general-purpose parser)\r\n\r\n## Risks\r\n\r\nUsing `int`-based enumeration limits us to only 32 flags, but it should be enough.\r\n\r\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOhgpjAw==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc56L99t",
                                           "createdAt":  "2024-04-11T15:25:17Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-reflection-metadata\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2024-04-11T15:25:17Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc56MPEF",
                                           "createdAt":  "2024-04-11T16:00:44Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODd224A==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "adamsitnik",
                                                                               "createdAt":  "2024-04-11T16:03:56Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "colejohnson66",
                                           "body":  "`BacktickConvention` sounds weird IMO. `EnforceGenericArity` would be more clear about what it means.",
                                           "updatedAt":  "2024-04-11T16:00:51Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc56Miv7",
                                           "createdAt":  "2024-04-11T16:49:38Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "\u003e Based on feedback from @jkotas who noticed the problem of having multiple type name parsers implemented by various team\r\n\r\nMore context: My specific objection was with having yet another type name parser mantained by .NET team. \r\n\r\n\u003e names are invalid for C# and F#\r\n\r\nThe options do not cover all possible names that are invalid in C#. For example, emojis are invalid in C# type names too. Would it make more sense for the opionated hardened layer built on top of this to scan the input for allowed/disallowed characters using something like IndexOfAny (no parsing required)?\r\n\r\n\u003e OnlyLegalTypes\r\n\r\nThe interpretation of this rule is runtime-version specific. For example, `byref of byref` is not legal today, but it may be legal tomorrow. There are number of rules that you can invent for given runtime version. For example, generics of byref or generics of pointers are not legal today but may become legal tomorrow. This option is trying to partially duplicate type validation checks done by runtime type loader for given .NET version that sounds like a bad idea to me.\r\n\r\n\u003e Rejecting valid input that was clearly mangled\r\n\r\nNit: This assumes that the input was generated by .NET type name formatter. The type and assembly names are frequently hand-authored and it is not unusual to see casing and white space differences in hand-authored names.\r\n\r\n\u003e OnlyPredefinedCultures\r\n\r\nIs the list of pre-defined cultures going to depend on the ICU that happens to be installed on the machine? I think that having the type parser to have different behavior from machine to machine is poor behavior, and it may actually open you to interesting security issues.\r\n\r\nDo we actually need this given the AssemblyNameInfo proposal?\r\n\r\n\u003e be hard to do right and require us to repeat a LOT of logic\r\n\u003e example: to enforce backtick convention we would need to re-parse part of the input again, find the beginning of generic arguments, then the backtick, ensure it\u0027s not escaped, try to parse the number and handle all edge cases like int overflow.\r\n\r\nI am not convinced by this example. All you need is to check that the name ends with $\"`{expectedGenericArity}\". No need to parse anything.",
                                           "updatedAt":  "2024-04-11T16:49:38Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc56MkfF",
                                           "createdAt":  "2024-04-11T16:54:17Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "\u003e would require maintaining another package (finding a name, repo, release schedule, patching strategy and OWNERS)\r\n\r\nWe have been saying that there is going to be a hardened binary serializer type resolver (with allow lists, etc.) built on top the core type name parser. Most (if not all) of these rules can be enforced by the hardened binary serializer type resolver. No new package required. Why is that not possible?",
                                           "updatedAt":  "2024-04-11T17:09:57Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc56TiKC",
                                           "createdAt":  "2024-04-12T15:04:49Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "adamsitnik",
                                           "body":  "\u003e Most (if not all) of these rules can be enforced by the hardened binary serializer type resolver. No new package required. Why is that not possible?\r\n\r\n`BinaryFormatter` is being moved to the OOB package, which will be marked as unsafe/unsecure/BAD from day 1. If we release the  allow-list binder (it\u0027s on our TODO list but it\u0027s not committed, more like a nice to have if we have enough time), it will be released in that new OOB package. If we release the high-level `TypeName` validator in that package, only those who install this package can use it. But there are other serializers that may need to use secure type name parsing and I am afraid they can not have unsafe/unsecure dependency.",
                                           "updatedAt":  "2024-04-12T15:04:49Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc56Tmvg",
                                           "createdAt":  "2024-04-12T15:15:05Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "adamsitnik",
                                           "body":  "\u003e The interpretation of this rule is runtime-version specific\r\n\r\nYou are right, I am going to remove it from the proposal.\r\n\r\n\u003e This assumes that the input was generated by .NET type name formatter. The type and assembly names are frequently hand-authored and it is not unusual to see casing and white space differences in hand-authored names\r\n\r\nOur main target for the opinionated restrictions are serializers, as they usually work with untrusted input. Do you really believe that there are serializers which implement their own type-name formatting rather than using `Type.FullName` or `Type.AssemblyQualifiedName`?\r\n\r\n\u003e Is the list of pre-defined cultures going to depend on the ICU that happens to be installed on the machine? I think that having the type parser to have different behavior from machine to machine is poor behavior, and it may actually open you to interesting security issues.\r\n\r\nThe implementation is going to use `CultureInfo.GetCultureInfo(cultureName, predefinedOnly: true)`, so yes, it may be machine-specific. But lets consider all three scenarios:\r\n1. The culture name is valid and installed: everything works like a charm.\r\n2. The culture name is valid, but not installed: instead of getting the exception during `CultureInfo` creation the user gets it during parsing (a little bit earlier). So it would fail in both cases, but with different exceptions?\r\n3. The culture is invalid (and not installed of course): we prevent from attack, which IMO is the win (and from my understanding this is our goal with the binary formatter removal)\r\n\r\n\u003e Do we actually need this given the AssemblyNameInfo proposal?\r\n\r\nYes and no. `CultureInfo` won\u0027t be created during `TypeName` parsing, but there is nothing to stop the users from calling `TypeName.AssemblyName.ToAssemblyNameInfo()` and create it anyway.\r\n\r\n\u003e All you need is to check that the name ends with $\"`{expectedGenericArity}\"\r\n\r\nAnd also that it does not end with  $\"`\\\\{expectedGenericArity}\"?\r\n",
                                           "updatedAt":  "2024-04-12T15:16:52Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc56WsYz",
                                           "createdAt":  "2024-04-13T00:55:41Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODeIw3w==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "jkotas",
                                                                               "createdAt":  "2024-04-15T05:59:01Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "jeffhandley",
                                           "body":  "\u003e If we release the allow-list binder (it\u0027s on our TODO list but it\u0027s not committed, more like a nice to have if we have enough time), it will be released in that new OOB package. If we release the high-level TypeName validator in that package, only those who install this package can use it. But there are other serializers that may need to use secure type name parsing and I am afraid they can not have unsafe/unsecure dependency.\r\n\r\nI\u0027m not yet sure what the shipping vehicle would be for an allow-list binder, so if we do produce a type name validator as a by-product of that feature, we could evaluate the best shipping vehicle(s)--either together or separate. That binder would likely be the first consumer of this logic. Taking inspiration from @jkotas\u0027s comments, we could choose to defer this proposal here until we\u0027ve built that binder, prove the need for the logic to be reusable in other contexts, and then consider refactoring the logic out into a natural place for reuse.",
                                           "updatedAt":  "2024-04-13T00:55:41Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc56hKpS",
                                           "createdAt":  "2024-04-15T06:15:15Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "\u003e Do you really believe that there are serializers which implement their own type-name formatting\r\n\r\nOur own binary serializer [can take the assembly name from `TypeForwardedFrom` attribute](https://github.com/dotnet/runtime/blob/fa1164c327052042120bf0d3b6fc81e86cfab69d/src/libraries/System.Runtime.Serialization.Formatters/src/System/Runtime/Serialization/FormatterServices.cs#L327). `TypeForwardedFrom` attributes are hand-authored and so they are susceptible to both intentional and unintentional formatting variations. For example, run the following and look at the serialized payload:\r\n```csharp\r\nusing System.Runtime.CompilerServices;\r\nusing System.Runtime.Serialization;\r\nusing System.Runtime.Serialization.Formatters.Binary;\r\n\r\nusing (var fs = new FileStream(\"temp.bin\", FileMode.Create))\r\n{\r\n    var bf = new BinaryFormatter();\r\n    bf.Serialize(fs, new MyType());\r\n}\r\n\r\n[TypeForwardedFrom(\"MyAssembly, PUBLICkeyTOKEN=b77a5c561934e089\")]\r\n[Serializable]\r\nclass MyType\r\n{\r\n}\r\n```\r\nI won\u0027t be surprised if other binary-formatter like serializers that store type names into the payload have additional paths to introduce atypical formatting of type names.  \r\n\r\n\u003e And also that it does not end with $\"`\\{expectedGenericArity}\"?\r\n\r\nI am not sure what you meant by this exactly. I agree that you can invent many empirical rules for validating type names. For example, you can create a rule that enforces that the type name does not start with a digit (System.Reflection.Metadata does not look like a good home for this sort of empirical rules).",
                                           "updatedAt":  "2024-04-15T06:17:33Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6GCmMD",
                                           "createdAt":  "2024-07-24T20:19:03Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "steveharter",
                                           "body":  "Moving to v10 as we have reached the \"feature complete\" milestone.\r\n\r\nSee also\r\nhttps://github.com/dotnet/runtime/pull/100094\r\nhttps://github.com/dotnet/runtime/pull/101910",
                                           "updatedAt":  "2024-07-24T20:19:03Z"
                                       }
                                   ],
                         "totalCount":  9
                     },
        "title":  "[API Proposal]: Opinionated restrictions for TypeName parsing",
        "labels":  [
                       "api-suggestion",
                       "area-System.Reflection.Metadata",
                       "binaryformatter-migration"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/102263",
        "createdAt":  "2024-05-15T14:59:38Z",
        "number":  102263,
        "author":  "adamsitnik",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-02-10T08:58:47Z",
        "body":  "### Background and motivation\r\n\r\nAs we have started using the new `TypeName` APIs all over the place, I\u0027ve realized that it would be very nice to have the ability to create a new `TypeName` instance with given `AssemblyNameInfo` without the need of re-parsing the [concatenated input](https://github.com/dotnet/winforms/blob/31176a4d203711e766b8b587414d04c27d8cc173/src/System.Windows.Forms/src/System/Resources/ResXSerializationBinder.cs#L54-L61) again.\r\n\r\nFor example, in BinaryFormatter the type and library names are provided separately (https://github.com/dotnet/runtime/issues/102014#issuecomment-2112683887), I would like to join them without re-parsing the whole thing again.\r\n\r\n\r\n### API Proposal\r\n\r\n```csharp\r\nnamespace System.Reflection.Metadata;\r\n\r\npublic sealed class TypeName\r\n{\r\n    /// \u003csummary\u003e\r\n    /// Returns a \u003csee cref=\"TypeName\" /\u003e object representing a one-dimensional array\r\n    /// of the current type, with a lower bound of zero.\r\n    /// \u003c/summary\u003e\r\n    /// \u003creturns\u003e\r\n    public TypeName MakeArrayTypeName();\r\n    \r\n    /// \u003csummary\u003e\r\n    /// Returns a \u003csee cref=\"TypeName\" /\u003e object representing an array of the current type,\r\n    /// with the specified number of dimensions.\r\n    /// \u003c/summary\u003e\r\n    /// \u003cparam name=\"rank\"\u003eThe number of dimensions for the array. This number must be more than zero and less than or equal to 32.\u003c/param\u003e\r\n    /// \u003cexception cref=\"ArgumentOutOfRangeException\"\u003erank is invalid. For example, 0 or negative.\u003c/exception\u003e\r\n    public TypeName MakeArrayTypeName(int rank);\r\n    \r\n    /// \u003csummary\u003e\r\n    /// Returns a \u003csee cref=\"TypeName\" /\u003e object that represents a pointer to the current type.\r\n    /// \u003c/summary\u003e\r\n    public TypeName MakePointerTypeName();\r\n    \r\n    /// \u003csummary\u003e\r\n    /// Returns a \u003csee cref=\"TypeName\" /\u003e object that represents a managed reference to the current type.\r\n    /// \u003c/summary\u003e\r\n    public TypeName MakeByRefTypeName();\r\n    \r\n    /// \u003csummary\u003e\r\n    /// Creates a new constructed generic type name.\r\n    /// \u003c/summary\u003e\r\n    /// \u003cparam name=\"typeArguments\"\u003eAn array of type names to be used as generic arguments of the current simple type name.\u003c/param\u003e\r\n    /// \u003cexception cref=\"InvalidOperationException\"\u003eThe current type name is not simple.\u003c/exception\u003e\r\n    public TypeName MakeGenericTypeName(ImmutableArray\u003cTypeName\u003e typeArguments)\r\n\r\n    /// \u003csummary\u003e\r\n    /// Returns a \u003csee cref=\"TypeName\" /\u003e object that represents the current type name with provided assembly name.\r\n    /// \u003c/summary\u003e\r\n    public TypeName WithAssemblyName(AssemblyNameInfo? assemblyName);\r\n\r\n    public static TypeName CreateSimpleTypeName(string fullName, TypeName? declaringType = null, AssemblyNameInfo? assemblyInfo = null);\r\n}\r\n```\r\n\r\n### API Usage\r\n\r\n```csharp\r\nTypeName WithoutAssemblyVersion(TypeName typeName) \r\n    =\u003e typeName.WithAssemblyName(\r\n        new AssemblyNameInfo(\r\n            typeName.AssemblyName.Name,\r\n            version: null,\r\n            typeName.AssemblyName.CultureName,\r\n            typeName.AssemblyName.Flags,\r\n            typeName.AssemblyName.PublicKeyOrToken));\r\n```\r\n\r\n### Risks\r\n\r\nSome users may miss the fact that the API creates a new instance of `TypeName` rather than mutating the current instance.\r\n\r\nSample implementation with tests and usages in dotnet/runtime available at #103713",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOncsccA==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc597oem",
                                           "createdAt":  "2024-05-15T15:00:03Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-reflection-metadata\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2024-05-15T15:00:03Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc598pJz",
                                           "createdAt":  "2024-05-15T17:07:31Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "Should we rather address the more general problem of creating TypeName of any shape through constructors or factory methods?\r\n\r\nIt happens that the AssemblyName case showed up with the binary formatter. I think it is a tell-take of a general need for creating arbitrary TypeNames.",
                                           "updatedAt":  "2024-05-15T17:07:31Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5-D7vX",
                                           "createdAt":  "2024-05-16T11:21:01Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "adamsitnik",
                                           "body":  "\u003e Should we rather address the more general problem of creating TypeName of any shape through constructors or factory methods?\r\n\r\nAll `TypeName` ctors that are going to accept strings of any kind are going to need to be fully validated, which is almost like reparsing them. And this is something that I would like to avoid with the provided API.\r\n\r\nI am not saying no, I just don\u0027t have a clear vision of how these APIs would look like.",
                                           "updatedAt":  "2024-05-16T11:21:01Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5-Gcc1",
                                           "createdAt":  "2024-05-16T15:56:31Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "\u003e All TypeName ctors that are going to accept strings of any kind are going to need to be fully validate\r\n\r\nWhy do the strings need to be validated? Type names can be anything.",
                                           "updatedAt":  "2024-05-16T15:56:31Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5-Gj9I",
                                           "createdAt":  "2024-05-16T16:10:26Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODlktDQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "JeremyKuhne",
                                                                               "createdAt":  "2024-06-13T16:38:50Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "jkotas",
                                           "body":  "Ah, it is because the APIs returned escaped names. The escaping validation should be very cheap, much cheaper than parsing.\r\n\r\nThe more I see the issues with the name escaping, the more I think that it was a bad design decision to make the Name and FullName properties to match reflection behavior. Should we revisit that?\r\n\r\nThe APIs can look like this:\r\n```csharp\r\npublic static TypeName MakeSimpleTypeName(string fullName, TypeName? declaringType = null, AssemblyNameInfo? assemblyInfo = null);\r\npublic static TypeName MakeArrayTypeName(TypeName elementType);\r\npublic static TypeName MakeArrayTypeName(TypeName elementType, int rank);\r\npublic static TypeName MakePointerTypeName(TypeName elementType);\r\npublic static TypeName MakeByRefTypeName(TypeName elementType);\r\npublic static TypeName MakeGenericTypeName(TypeName genericTypeDefinition, ImmutableArray\u003cTypeName\u003e typeArguments);\r\n\r\n// Matches Unscape method proposed in #101774\r\npublic static string Escape(string name);\r\n```",
                                           "updatedAt":  "2024-05-16T19:14:33Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5-HiXC",
                                           "createdAt":  "2024-05-16T18:14:26Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "adamsitnik",
                                           "body":  "\u003e the more I think that it was a bad design decision to make the Name and FullName properties to match reflection behavior\r\n\r\nBut it allows for things like `if (typeName.FullName == typeof(T).FullName)` which already proved very useful in payload reader.\r\n\r\nI know it may sound silly but IMO we would not have that problem if we would simply forbid using certain characters without the ability to escape them in the first place.\r\n\r\n",
                                           "updatedAt":  "2024-05-16T18:14:26Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5-H8mH",
                                           "createdAt":  "2024-05-16T19:17:10Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "\u003e if (typeName.FullName == typeof(T).FullName)\r\n\r\nYeah, that\u0027s the conundrum when you want to use this together with reflection. It is hard to tell how common this use case is going to be. \r\n\r\nAnyway, I edited my suggestion at https://github.com/dotnet/runtime/issues/102263#issuecomment-2115649352 to include `Escape` method, so that there is a reasonable path when you have the raw name.\r\n\r\n\u003e we would not have that problem if we would simply forbid using certain characters without the ability to escape them in the first place.\r\n\r\nIt would produce non-compliant type name parser. It may be ok for BF-specific parser. I do not think it is ok for S.R.Metadata or the runtime that need compliant and backward compatible type name parsers. It would be a needless breaking change to drop support for escaped type names.",
                                           "updatedAt":  "2024-05-16T19:17:10Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6GCnl0",
                                           "createdAt":  "2024-07-24T20:21:45Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "steveharter",
                                           "body":  "Moving to v10 since we have reached the \"feature complete\" milestone; still in API review backlog.",
                                           "updatedAt":  "2024-07-24T20:21:45Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6G7NqX",
                                           "createdAt":  "2024-08-01T18:10:35Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "bartonjs",
                                           "body":  "[Video](https://www.youtube.com/watch?v=vZ49KRsLcvs\u0026t=1h8m24s)\n\n* WithAssemblyName doesn\u0027t seem to have a solid scenario (outside of one case), so it\u0027s being withheld until it has a more clear use pattern with regard to composed types (e.g. generics).\r\n* It was asked if the instance methods should be prefixed with \"Make\" or \"Create\", and it seems that \"Make\" matches reflection, and the static one \"Create\" is a patterned prefix.\r\n* We changed CreateSimpleTypeName\u0027s `fullName` parameter to `metadataName` to avoid confusion between the unescaped value as a parameter and the escaped value as the property with the same name.\r\n* The parameterless MakeArrayTypeName is renamed to MakeSZArrayTypeName because MakeArrayTypeName(1) and MakeArrayTypeName() are not the same.\r\n\r\n```c#\r\nnamespace System.Reflection.Metadata;\r\n\r\npublic partial class TypeName\r\n{      \r\n    public TypeName MakeSZArrayTypeName();\r\n    public TypeName MakeArrayTypeName(int rank);\r\n    public TypeName MakePointerTypeName();\r\n    public TypeName MakeByRefTypeName();\r\n    public TypeName MakeGenericTypeName(ImmutableArray\u003cTypeName\u003e typeArguments);\r\n\r\n    public static TypeName CreateSimpleTypeName(\r\n        string metadataName,\r\n        TypeName? declaringType = null,\r\n        AssemblyNameInfo? assemblyInfo = null);\r\n}\r\n```",
                                           "updatedAt":  "2024-08-01T19:06:48Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6HB_j3",
                                           "createdAt":  "2024-08-02T13:49:56Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "adamsitnik",
                                           "body":  "I\u0027ve adopted my initial implementation (#103713) to the approved API in https://github.com/dotnet/runtime/pull/103713/commits/9a0cd5819f8d5367e94aeb0da9d98e6fb5ea51f3.\r\n\r\nSo far, all `TypeName` instances that any library or app could somehow get were valid and escaped type names. Users could simply rely on that and the information the API provides no matter where it comes from.\r\n\r\nThe introduction of `CreateSimpleTypeName` that accepts unescaped full names introduces a possibility to create invalid `TypeName` instances.\r\n\r\nExample: `TypeName.Parse(\"TypeName, MyLib\")` returns a `TypeName` where `FullName=TypeName` and `AssemblyName=MyLib`.\r\nWhen we pass the same input to `CreateSimpleTypeName` we don\u0027t know whether `,` was previously escaped (it\u0027s not a begining of assembly name) or not (it\u0027s a begining of an assembly name).\r\n\r\nSame goes for escaping. If we have a name that consists of escaped escape character followed by an escaped special character like `*` and unescape it, the escape character is followed by a special character. It seems to still be escaped, but it\u0027s not.\r\n\r\nExample: `\\\\\\*` -\u003e Unescape -\u003e `\\*` -\u003e Unescape -\u003e `*`.\r\n\r\nIn my opinion, since `static string Unescape(string name)` got approved https://github.com/dotnet/runtime/issues/101774#issuecomment-2263693421, we don\u0027t need `CreateSimpleTypeName`.\r\n\r\nBut we still need the ability to replace `AssemblyName` for simple types. That is why I propose following change:\r\n\r\n```diff\r\npublic class TypeName\r\n{\r\n\r\n-   public static TypeName CreateSimpleTypeName(string metadataName, TypeName? declaringType = null, AssemblyNameInfo? assemblyInfo = null);\r\n+   public TypeName MakeSimpleTypeName(TypeName? declaringType = null, AssemblyNameInfo? assemblyInfo = null);\r\n}\r\n```\r\n\r\nThat method would throw for non-simple names and prevent the users from creating invalid instances. I\u0027ve implemented it in https://github.com/dotnet/runtime/pull/103713/commits/aabe51b8bfb7e2ab7d90d1672e4feb56f91315af\r\n\r\ncc @jkotas @GrabYourPitchforks ",
                                           "updatedAt":  "2024-08-02T13:49:56Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6HCIbd",
                                           "createdAt":  "2024-08-02T14:09:21Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "\u003e Example: TypeName.Parse(\"TypeName, MyLib\") returns a TypeName where FullName=TypeName and AssemblyName=MyLib.\r\nWhen we pass the same input to CreateSimpleTypeName we don\u0027t know whether , was previously escaped (it\u0027s not a begining of assembly name) or not (it\u0027s a begining of an assembly name).\r\n\r\n`CreateSimpleTypeName` was meant to take unescaped name. It is why we have opted to name the argument `metadataName` to make it clear that it is not the regular (escaped) name.\r\n\r\nIf you pass `TypeName, MyLib` to `CreateSimpleTypeName`, it should create a TypeName that returns `TypeName\\, MyLib` from FullName property. It is a valid typename. There is no ambiguity.\r\n\r\n\u003e In my opinion, since static string Unescape(string name) got approved https://github.com/dotnet/runtime/issues/101774#issuecomment-2263693421, we don\u0027t need CreateSimpleTypeName.\r\n\r\n`CreateSimpleTypeName` was equivalent of `Escape`. `Unescape` is not a replacement. ",
                                           "updatedAt":  "2024-08-02T14:09:21Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6HY-En",
                                           "createdAt":  "2024-08-06T14:42:54Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "adamsitnik",
                                           "body":  "@jkotas big thanks for the clarification, now it all makes sense.\r\n\r\nSince `CreateSimpleTypeName` needs to parse the name to unescape it, I can not use it (my requirement is to create a new type name with given assembly name without reparsing).\r\n\r\nI\u0027ve finished implementing https://github.com/dotnet/runtime/pull/103713 and I need just one more method:\r\n\r\n```diff\r\nnamespace System.Reflection.Metadata;\r\n\r\npublic partial class TypeName\r\n{      \r\n    public TypeName MakeSZArrayTypeName();\r\n    public TypeName MakeArrayTypeName(int rank);\r\n    public TypeName MakePointerTypeName();\r\n    public TypeName MakeByRefTypeName();\r\n    public TypeName MakeGenericTypeName(ImmutableArray\u003cTypeName\u003e typeArguments);\r\n+   public TypeName MakeSimpleTypeName(AssemblyNameInfo? assemblyInfo);\r\n\r\n    public static TypeName CreateSimpleTypeName(\r\n        string metadataName,\r\n        TypeName? declaringType = null,\r\n        AssemblyNameInfo? assemblyInfo = null);\r\n}\r\n```\r\n\r\nI am going to create a new issue with the proposal for it.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
                                           "updatedAt":  "2024-08-06T14:42:54Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6HZDJ-",
                                           "createdAt":  "2024-08-06T14:52:20Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "\u003e Since CreateSimpleTypeName needs to parse the name to unescape it, I can not use it (my requirement is to create a new type name with given assembly name without reparsing).\r\n\r\nI do not see why escaping the type name passed into `CreateSimpleTypeName` is a problem for your BF use case. It does not create non-linear amount of work. ",
                                           "updatedAt":  "2024-08-06T14:52:20Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6HZId4",
                                           "createdAt":  "2024-08-06T15:02:04Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "adamsitnik",
                                           "body":  "\u003e I do not see why escaping the type name passed into `CreateSimpleTypeName` is a problem for your BF use case.\r\n\u003e It does not create non-linear amount of work. \r\n\r\nI think it depends on how you treat the comparison of current char vs chars that needs to be escaped. For me, assuming that we have `n` needles (characters that need escaping) and `i` characters in the input name, it\u0027s `O(n * i)`.\r\n\r\n",
                                           "updatedAt":  "2024-08-06T15:02:04Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6HZLZH",
                                           "createdAt":  "2024-08-06T15:07:13Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "This is not a general-purpose escaping with arbitrary escape characters. The number of characters that need escaping is very small (7 to be exact) and set in stone. So it is `O(7 * i)`.",
                                           "updatedAt":  "2024-08-06T15:07:13Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6dRfpS",
                                           "createdAt":  "2025-02-06T02:14:05Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "teo-tsirpanis",
                                           "body":  "@adamsitnik is there anything left to do here? Can we close this issue?",
                                           "updatedAt":  "2025-02-06T02:14:05Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6dULWR",
                                           "createdAt":  "2025-02-06T09:44:35Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "adamsitnik",
                                           "body":  "\u003e @adamsitnik is there anything left to do here? Can we close this issue?\n\nThe `CreateSimpleTypeName` method has not been implemented yet.",
                                           "updatedAt":  "2025-02-06T09:44:35Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6dtv-e",
                                           "createdAt":  "2025-02-09T01:37:55Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "\u003e The CreateSimpleTypeName method has not been implemented yet.\n\nThat\u0027s correct. On the other hand, I am not aware of any place that can use the API of this shape currently, so we may want to let this issue linger until this need materializes.\n\nThere are a few places that do raw type name escaping (e.g. https://github.com/dotnet/runtime/blob/2a1b35e8afe469e4db01de7ba96b9133acc55d38/src/libraries/System.Reflection.MetadataLoadContext/src/System/Reflection/TypeLoading/General/Helpers.cs#L103 ), but this API is not of the right shape to replace them. A static method that does raw escaping may be more useful.",
                                           "updatedAt":  "2025-02-09T01:42:52Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6dyxxw",
                                           "createdAt":  "2025-02-10T08:58:45Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "adamsitnik",
                                           "body":  "\u003e That\u0027s correct. On the other hand, I am not aware of any place that can use the API of this shape currently, so we may want to let this issue linger until this need materializes.\n\nI agree, let\u0027s wait 👍 .",
                                           "updatedAt":  "2025-02-10T08:58:45Z"
                                       }
                                   ],
                         "totalCount":  19
                     },
        "title":  "[API Proposal]: Creating new TypeName without reparsing",
        "labels":  [
                       "api-approved",
                       "area-System.Reflection.Metadata"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/103071",
        "createdAt":  "2024-06-05T04:34:52Z",
        "number":  103071,
        "author":  "gregsdennis",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOC8KZmg==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "warappa",
                                            "createdAt":  "2024-06-05T19:02:16Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "crackalak",
                                            "createdAt":  "2024-07-29T16:16:32Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "jjonescz",
                                            "createdAt":  "2024-10-25T17:54:39Z"
                                        }
                                    ],
                          "totalCount":  3
                      },
        "updatedAt":  "2025-01-20T01:56:19Z",
        "body":  "### Is there an existing issue for this?\r\n\r\n- [X] I have searched the existing issues\r\n\r\n### Describe the bug\r\n\r\nSimilar to dotnet/aspnetcore#52162, I need to load assemblies after the website as loaded.  However, I\u0027m loading them into a compilation context so that users can enters some C# code which I then compile.  (See https://json-everything.net/json-schema ([source](https://github.com/gregsdennis/json-everything)), and select \"Generate a Schema\".)\r\n\r\nThe problem on that site (because I haven\u0027t updated it yet) is that it can\u0027t find the `.dll`s... because they\u0027ve been renamed to `.wasm`s.  I\u0027m okay with the rename.\r\n\r\nMy problem, however, is that these `.wasm` files aren\u0027t accepted by the .Net emitter.\r\n\r\nThis code works in .Net 6, using `.dll` files:\r\n\r\n_Loading the references_\r\n```c#\r\nvar stream = await Client.GetStreamAsync(source);\r\nreferences.Add(MetadataReference.CreateFromStream(stream));\r\n```\r\n\r\n_Compiling_\r\n```c#\r\nvar syntaxTree = CSharpSyntaxTree.ParseText(fullSource);\r\nvar assemblyPath = Path.ChangeExtension(Path.GetTempFileName(), \"dll\");\r\n\r\nvar compilation = CSharpCompilation.Create(Path.GetFileName(assemblyPath))\r\n    .WithOptions(new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary))\r\n    .AddReferences(references)\r\n    .AddSyntaxTrees(syntaxTree);\r\n\r\nusing var dllStream = new MemoryStream();\r\nusing var pdbStream = new MemoryStream();\r\nusing var xmlStream = new MemoryStream();\r\nvar emitResult = compilation.Emit(dllStream, pdbStream, xmlStream);\r\nif (!emitResult.Success)\r\n{\r\n    // .net 6 doesn\u0027t enter here\r\n    // but .net 8 does with no changes except for the file extension\r\n    return \"Compilation error\";\r\n}\r\n\r\nvar assembly = Assembly.Load(dllStream.ToArray());\r\n```\r\n\r\nThe diagnostics in the `emitResult` are primarily to do with the references:\r\n\r\n```\r\nerror CS0009: Metadata file \u0027\u003cin-memory assembly\u003e\u0027 could not be opened -- PE image doesn\u0027t contain managed metadata.\r\n```\r\n\r\nThis happens whether the code should compile or not.\r\n\r\n### Expected Behavior\r\n\r\nI expect the files to load into the compilation context and the emit to work, just as it does with .Net 6.\r\n\r\n### Steps To Reproduce\r\n\r\nMinimal repro: https://github.com/gregsdennis/aspnet56080-repro\r\n\r\nThe solution file is in `/BlazorApp1` for some reason.  Not sure how that happened.\r\n\r\nThe .Net 6 app works fine, but the .Net 8 app doesn\u0027t.  The only thing the .Net 8 app does differently is load `.wasm`s instead of `.dll`s.\r\n\r\n### Exceptions (if any)\r\n\r\nThere are no exceptions, just the emit diagnostics.\r\n\r\n### .NET Version\r\n\r\n8.0.206\r\n\r\n### Anything else?\r\n\r\nHappy to know if there\u0027s something I\u0027m missing, but it\u0027s obvious to me that the contents of a `.wasm` are different from the contents of a `.dll`.  The assembly loader may be set up to understand and account for the difference, but the compiler/emitter isn\u0027t.\r\n\r\n## workaround\r\n\r\ndisable the .wasm extension for your project:\r\n\r\n```\r\n\u003cPropertyGroup\u003e\r\n  \u003cWasmEnableWebcil\u003efalse\u003c/WasmEnableWebcil\u003e\r\n\u003c/PropertyGroup\u003e\r\n```",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOmwqpJg==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6AIROV",
                                           "createdAt":  "2024-06-05T11:46:24Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ScarletKuro",
                                           "body":  "Just disable the `.wasm` extension for your project:\r\n\r\n```xml\r\n\u003cPropertyGroup\u003e\r\n  \u003cWasmEnableWebcil\u003efalse\u003c/WasmEnableWebcil\u003e\r\n\u003c/PropertyGroup\u003e\r\n```\r\n\r\nMore info: [Webcil Documentation](https://github.com/dotnet/runtime/blob/main/docs/design/mono/webcil.md)\r\n\r\nIn short, the payload is different, and .NET cannot load this directly. The webcil to PE conversion is not supported, and this is intentional.",
                                           "updatedAt":  "2024-06-05T12:24:41Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6AIThO",
                                           "createdAt":  "2024-06-05T12:01:57Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "javiercn",
                                           "body":  "@maraf @lewing FYI",
                                           "updatedAt":  "2024-06-05T12:01:57Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6AMu-X",
                                           "createdAt":  "2024-06-05T19:39:32Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEPZDkg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "markusschaber",
                                                                               "createdAt":  "2025-04-23T14:27:48Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "gregsdennis",
                                           "body":  "So I won\u0027t be able to cater to those people who have that firewall issue that\u0027s mentioned in that doc.  I get that it\u0027s the same for .Net 6, which doesn\u0027t have `.wasm` files, but it\u0027s a shame I can\u0027t use them because someone(s) decided not to support it.",
                                           "updatedAt":  "2024-06-05T19:39:32Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6AM8ur",
                                           "createdAt":  "2024-06-05T20:11:21Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "gregsdennis",
                                           "body":  "Disabling WebCIL did work, BTW.",
                                           "updatedAt":  "2024-06-05T20:11:21Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6ANaSR",
                                           "createdAt":  "2024-06-05T21:33:24Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODk3Rcg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "gregsdennis",
                                                                               "createdAt":  "2024-06-05T22:12:23Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "lambdageek",
                                                                               "createdAt":  "2024-06-06T23:22:13Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "JakeYallop",
                                           "body":  "I had this same problem for my project as well ([WasmSharp](https://github.com/JakeYallop/WasmSharp)), I\u0027ve not been contributing to it for a while, but I do have a couple of things bookmarked to look at regarding WebCIL, the idea being that maybe (eventually) I could accept the WebCIL format and decode it myself.\r\n\r\nFirstly, there is this PR which adds support to ILSpy for decoding WebCIL: https://github.com/icsharpcode/ILSpy/pull/3184\r\n\r\nAnd more importantly, I found this: \r\n\r\nhttps://github.com/StefH/ProtoBufJsonConverter/tree/main/src-webcil\r\n\u003e Generate a valid MetadataReference based on a Wasm wrapped Webcil stream (MetadataReferenceService.BlazorWasm)\r\n\r\nI haven\u0027t had the time to investigate any further myself, but I\u0027ll leave these links here in case they are useful",
                                           "updatedAt":  "2024-06-05T21:33:24Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6AXJ7U",
                                           "createdAt":  "2024-06-06T23:24:17Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-reflection-metadata\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2024-06-06T23:24:17Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6bCqkm",
                                           "createdAt":  "2025-01-20T01:56:18Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "teo-tsirpanis",
                                           "body":  "Your scenario involves passing to Roslyn assemblies that are already loaded in your app. One way to implement this is:\n\n* Mono implements [`AssemblyExtensions.TryGetRawMetadata`](https://learn.microsoft.com/en-us/dotnet/api/system.reflection.metadata.assemblyextensions.trygetrawmetadata) (currently returns always false).\n* Roslyn adds a `MetadataReference.CreateFromAssemblyMetadata(Assembly)` API that calls the above API.\n  * It has [the capability](https://github.com/dotnet/roslyn/blob/9934fb9e3527e1c0c51314e57d4aab30f97e8f9e/src/Compilers/Core/Portable/MetadataReader/PEModule.cs#L40) to read raw metadata without a PE file; we need to expose it.\n* User code calls the above API.\n\nThere isn\u0027t something required here on SRM\u0027s side. Reading metadata from WebCIL files without loading them should be tracked by a separate issue, if someone requests it.",
                                           "updatedAt":  "2025-01-20T01:56:18Z"
                                       }
                                   ],
                         "totalCount":  7
                     },
        "title":  "Blazor DLL -\u003e WASM file extension change causing functionality failure when updating to .Net 8",
        "labels":  [
                       "arch-wasm",
                       "area-System.Reflection.Metadata",
                       "feature-request",
                       "os-browser"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/103168",
        "createdAt":  "2024-06-07T16:27:31Z",
        "number":  103168,
        "author":  "AArnott",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-07-26T10:50:32Z",
        "body":  "### Background and motivation\r\n\r\nSeveral tools beyond compilers require the ability to construct \"[doc IDs](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/documentation-comments#d42-id-string-format)\" (documentation comments that unambiguously reference a particular API).\r\n\r\nConstructing these is non-trivial. I recently created a DocID construction class based on System.Reflection.Metadata, and @terrajobst suggested I contribute it back to the SRM library (or some other that sits on top of it).\r\n\r\n### API Proposal\r\n\r\n```csharp\r\nnamespace System.ReflectionMetadata;\r\n\r\npublic partial class MetadataReader\r\n{\r\n    /// \u003csummary\u003e\r\n    /// Constructs a \u003csee href=\"https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/documentation-comments#d42-id-string-format\"\u003eDocID\u003c/see\u003e for the given entity handle.\r\n    /// \u003c/summary\u003e\r\n    /// \u003cparam name=\"entityHandle\"\u003eThe handle to the entity to construct a DocID for.\u003c/param\u003e\r\n    /// \u003creturns\u003eThe DocID.\u003c/returns\u003e\r\n    /// \u003cexception cref=\"NotSupportedException\"\u003eThrown when \u003cparamref name=\"entityHandle\"/\u003e refers to an entity for which no DocID can be constructed.\u003c/exception\u003e\r\n    /// \u003cremarks\u003e\r\n    /// \u003cpara\u003e\r\n    /// DocIDs can be constructed for the following entity types:\r\n    /// \u003clist type=\"bullet\"\u003e\r\n    /// \u003citem\u003e\u003csee cref=\"HandleKind.TypeDefinition\"/\u003e\u003c/item\u003e\r\n    /// \u003citem\u003e\u003csee cref=\"HandleKind.EventDefinition\"/\u003e\u003c/item\u003e\r\n    /// \u003citem\u003e\u003csee cref=\"HandleKind.FieldDefinition\"/\u003e\u003c/item\u003e\r\n    /// \u003citem\u003e\u003csee cref=\"HandleKind.MethodDefinition\"/\u003e\u003c/item\u003e\r\n    /// \u003citem\u003e\u003csee cref=\"HandleKind.PropertyDefinition\"/\u003e\u003c/item\u003e\r\n    /// \u003citem\u003e\u003csee cref=\"HandleKind.TypeReference\"/\u003e\u003c/item\u003e\r\n    /// \u003citem\u003e\u003csee cref=\"HandleKind.MemberReference\"/\u003e\u003c/item\u003e\r\n    /// \u003c/list\u003e\r\n    /// \u003c/para\u003e\r\n    /// \u003c/remarks\u003e\r\n    public string GetDocId(EntityHandle entityHandle);\r\n}\r\n```\r\n\r\n\r\n### API Usage\r\n\r\n```csharp\r\nusing FileStream assemblyStream = File.OpenRead(Assembly.GetExecutingAssembly().Location);\r\nusing PEReader peReader = new(this.assemblyStream);\r\nMetadataReader reader = peReader.GetMetadataReader();\r\n\r\nforeach (TypeDefinitionHandle tdh in reader.TypeDefinitions)\r\n{\r\n    string docId = reader.GetDocId(tdh);\r\n}\r\n```\r\n\r\n\r\n### Alternative Designs\r\n\r\nInstead of adding `GetDocId` directly to `MetadataReader`, when it isn\u0027t really about reading metadata per se, we could add the method to a new class. The new class would have just one method on it however, and it would have to be constructed with a reference to a `MetadataReader`.\r\n\r\nYet another option is to put this functionality in another library.\r\n\r\n### Risks\r\n\r\nThe code I have was ported from the Upgrade Assistant (which used Mono.Cecil instead of SRM). I didn\u0027t study the [original spec for DocIDs](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/documentation-comments#d42-id-string-format) closely, so the code I have may not be 100% compliant with the spec.\r\n\r\nIt does come with a bunch of tests though, which also came from Upgrade Assistant.\r\n\r\nWhen producing DocIDs for `MemberReference`, we can\u0027t be sure whether to construct a property (`P:`) or event (`E:`) style reference vs. a standard method reference (`M:`) when the reference is to an API in another assembly because we don\u0027t have access to the other assembly. We can merely guess based on prefix naming conventions.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOgvn7qQ==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6AdSy3",
                                           "createdAt":  "2024-06-07T16:27:56Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-reflection-metadata\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2024-06-07T16:27:56Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6BnxvE",
                                           "createdAt":  "2024-06-18T00:36:16Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODntEtw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "terrajobst",
                                                                               "createdAt":  "2024-06-28T18:12:58Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "ericstj",
                                           "body":  "Making DocID more widely available is a good thing.  The nice thing about putting it in SRM is that it\u0027s already a nuget package (as opposed to reflection or some new package).\r\n\r\nI see Roslyn already has https://learn.microsoft.com/en-us/dotnet/api/microsoft.codeanalysis.isymbol.getdocumentationcommentid?view=roslyn-dotnet-4.7.0 but I imagine you need this for a tool that doesn\u0027t already use Roslyn?\r\n\r\nI wonder if there are more scenarios for type name rendering from metadata that should be looked at as part of this.",
                                           "updatedAt":  "2024-06-18T00:36:16Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6Bn1h0",
                                           "createdAt":  "2024-06-18T00:54:21Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AArnott",
                                           "body":  "Ya, roslyn is a huge dependency to take just for DocID creation. And it isn\u0027t just the dll sizes, it\u0027s that I\u0027d have to switch to the much more GC heavy roslyn API instead of the nearly alloc-free SRM object model.\r\n\r\n That said, I need it for tools in which I\u0027ve already got the code (code that I would contribute to SRM if accepted). So I\u0027m not blocked by this.",
                                           "updatedAt":  "2024-06-18T00:55:23Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6C-fup",
                                           "createdAt":  "2024-06-28T18:15:14Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODntjvw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "AArnott",
                                                                               "createdAt":  "2024-06-28T19:33:35Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "terrajobst",
                                           "body":  "The big problem is that Roslyn requires the closure of dependencies to crack open metadata reliably. That\u0027s often very expensive as it disallows looking at binaries in isolation (such as NuGet packages) and requires the caller to somehow resolve all of those, including the framework binaries.\r\n\r\nFor a lot of the analyses we\u0027re doing we\u0027re content with just dumping the type ref / member ref table as dependencies without even having to parse any of the IL bodies.\r\n\r\nAnd that\u0027s where having this API would be incredibly convenient. I would absolutely love having this API and would use it virtually everywhere where I\u0027m still using CCI, which is unmaintained. However, it\u0027s the only MR that can you look at binaries without forcing resolution.",
                                           "updatedAt":  "2024-06-28T18:17:01Z"
                                       }
                                   ],
                         "totalCount":  4
                     },
        "title":  "[API Proposal]: System.Reflection.Metadata.MetadataReader.GetDocId(EntityHandle)",
        "labels":  [
                       "api-suggestion",
                       "area-System.Reflection.Metadata",
                       "needs-further-triage"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/112830",
        "createdAt":  "2025-02-23T22:11:36Z",
        "number":  112830,
        "author":  "teo-tsirpanis",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOC_Y_hg==",
                          "nodes":  [
                                        {
                                            "content":  "EYES",
                                            "user":  "filipnavara",
                                            "createdAt":  "2025-02-24T07:27:39Z"
                                        }
                                    ],
                          "totalCount":  1
                      },
        "updatedAt":  "2025-07-26T10:53:13Z",
        "body":  "### Background and motivation\n\nWhen `PEReader` reads an image that does not have a PE header, it tries to read it as a COFF file. However, because COFF files do not have a signature, the reader will not immediately fail when reading files that are not COFF files, which has misleading behavior by not failing, and wastes memory to store section headers. This has affected both first-party (https://github.com/dotnet/runtime/pull/112653#discussion_r1962168516) and third-party users (#48419).\n\nI am proposing to add an option to cause `PEReader` to immediately throw if the image does not contain a PE header and not attempt to further read it.\n\n### API Proposal\n\n```csharp\nnamespace System.Reflection.PortableExecutable;\n\npublic enum PEStreamOptions\n{\n    RequirePEHeader = 16,\n}\n```\n\n\n### API Usage\n\n```csharp\nusing var pe = new PEReader(File.OpenRead(\"MyFile.dll\"), PEStreamOptions.RequirePEHeader);\n```\n\n\n### Alternative Designs\n\n* The name of the flag could be different.\n* Should we also add more overloads to cover reading images from contiguous memory?\n* Should we also add a `PEHeaders(Stream peStream, int size, bool isLoadedImage, bool requirePEHeader)` constructor overload?\n\n### Risks\n\nThe API might be too niche or too hard to discover. Users can do the PE signature validation themselves before creating the `PEReader`; it\u0027s quite simple to implement.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOn679uw==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6fkfQX",
                                           "createdAt":  "2025-02-23T22:11:59Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-io\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2025-02-23T22:11:59Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6fkfYm",
                                           "createdAt":  "2025-02-23T22:13:30Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-reflection-metadata\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2025-02-23T22:13:30Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6fmW6g",
                                           "createdAt":  "2025-02-24T07:38:54Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "MichalStrehovsky",
                                           "body":  "It\u0027s also possible to do a bit more validation that this file makes sense as a COFF object:\n\n* SizeOfOptionalHeader needs to be zero in a COFF file (this would be enough to fix the repro in #48419)\n* PointerToSymbolTable must be less than the file size\n* Characteristics field has several bits that must be zero and a couple other bits that must be zero in object files. It effectively always is all-zero, but that\u0027s not guaranteed.\n\nOne could also go further and add a range check for the NumberOfSections and then validate each section has a zero VirtualAddress (must be zero in object file).\n\nIt\u0027s not as good as looking for magic numbers, but better than nothing.",
                                           "updatedAt":  "2025-02-24T07:38:54Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6frv27",
                                           "createdAt":  "2025-02-24T16:43:35Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "steveharter",
                                           "body":  "\u003e It\u0027s also possible to do a bit more validation that this file makes sense as a COFF object:\n\nYes thanks. We should start by adding validation to reject a non-COFF (after knowing the file is not a PE) then add the enum if we still need it.",
                                           "updatedAt":  "2025-02-24T16:43:35Z"
                                       }
                                   ],
                         "totalCount":  4
                     },
        "title":  "[API Proposal]: Add capability in `PEReader` to reject COFF files.",
        "labels":  [
                       "investigate",
                       "api-suggestion",
                       "area-System.Reflection.Metadata"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/113910",
        "createdAt":  "2025-03-26T01:41:32Z",
        "number":  113910,
        "author":  "tmat",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-07-26T10:56:36Z",
        "body":  "### Description\n\nguidSizes is incorrectly accumulated here:\n\nhttps://github.com/dotnet/runtime/blob/main/src/libraries/System.Reflection.Metadata/src/System/Reflection/Metadata/Ecma335/MetadataAggregator.cs#L156\n\nThe size of GUID heap in aggregated metadata is the same as the size in the metadata delta where the GUID is used (unlike other heaps).\n\n### Regression?\n\nNo\n\n### Known Workarounds\n\nSee https://github.com/dotnet/metadata-tools/pull/308\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOqck6tw==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6kF-2C",
                                           "createdAt":  "2025-03-26T01:42:05Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-reflection-metadata\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2025-03-26T01:42:05Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6k6yJa",
                                           "createdAt":  "2025-03-31T17:15:16Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ericstj",
                                           "body":  "@tmat I see you have added a workaround.  Are you aware of any downstream callers of this API (like Roslyn) who might be impacted by this?\n\nDid you want to suggest a fix?",
                                           "updatedAt":  "2025-03-31T17:15:16Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6k74dz",
                                           "createdAt":  "2025-03-31T19:12:10Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tmat",
                                           "body":  "\u003e I see you have added a workaround. Are you aware of any downstream callers of this API (like Roslyn) who might be impacted by this?\n\nI\u0027m not aware of any. Not high priority to fix. Would be nice to remove the workaround.\n\n\u003e Did you want to suggest a fix?\n\nThe line referenced above needs to be updated to no accumulate. Then some comments and tests need to be updated.\nShould be easy to do. \n",
                                           "updatedAt":  "2025-03-31T19:12:10Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6pjVOo",
                                           "createdAt":  "2025-05-01T10:29:41Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "fabrimaz",
                                           "body":  "Hello, I am trying to read this thread and hope to understand it so that I could start contributing this as my first task.\nI guess I will need a bit of guidance, though.\nI am not sure if I got what the recently added workaround should be replaced with.\n\n",
                                           "updatedAt":  "2025-05-01T10:29:41Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6pjoBo",
                                           "createdAt":  "2025-05-01T11:39:45Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "fabrimaz",
                                           "body":  "Can you elaborate on `The line referenced above needs to be updated to no accumulate.`? \nDo you mean something like `guidSizes[r + 1] = deltaReaders[r].GetHeapSize(HeapIndex.Guid) / guidSize;`?",
                                           "updatedAt":  "2025-05-01T11:39:45Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6pn9Ww",
                                           "createdAt":  "2025-05-01T21:30:22Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEeiIWA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "fabrimaz",
                                                                               "createdAt":  "2025-05-03T16:28:43Z"
                                                                           },
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "MarceloChG",
                                                                               "createdAt":  "2025-08-17T02:41:57Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "tmat",
                                           "body":  "When `#Guid` heap is emitted in delta metadata the compiler first writes N empty guids in the heap. where N is number of Guids in all previous generations including the baseline DLL, and then writes guids used in the delta.\n\nLike so:\n\nBaseline DLL: `{Guid 1}` ... `{Guid N0}` \nGeneration 1 delta: `{empty guid}` ... `{empty guid}` `{Guid N0+1}` ... `{Guid N0 + N1}`\nGeneration 2 delta: `{empty guid}` ... `{empty guid}` `{empty guid}` ... `{empty guid}` `{Guid N0+N1+1}` ... `{Guid N0 + N1 + N2}`\n\nThis is therefore not correct:\n```\nguidSizes[r + 1] = guidSizes[r] + deltaReaders[r].GetHeapSize(HeapIndex.Guid) / guidSize;\n```\n\n`guidSizes[r]` shouldn\u0027t be added to `guidSizes[r+1]`.\n\nInstead the size of Guid heap in generation `r` is simply: `deltaReaders[r].GetHeapSize(HeapIndex.Guid) / guidSize;`\n\n",
                                           "updatedAt":  "2025-05-01T21:30:22Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6pyTq3",
                                           "createdAt":  "2025-05-03T09:21:39Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "fabrimaz",
                                           "body":  "I just opened this: \n#115268 \nLet me know if it could be fine",
                                           "updatedAt":  "2025-05-03T09:21:39Z"
                                       }
                                   ],
                         "totalCount":  7
                     },
        "title":  "MetadataAggregator.GetGenerationHandle returns incorrect results for Guid heap handles",
        "labels":  [
                       "bug",
                       "area-System.Reflection.Metadata",
                       "good first issue",
                       "help wanted"
                   ]
    }
]
