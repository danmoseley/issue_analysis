[
    {
        "url":  "https://github.com/dotnet/runtime/issues/10428",
        "createdAt":  "2018-05-31T22:40:51Z",
        "number":  10428,
        "author":  "smmalis37",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2023-02-07T21:54:42Z",
        "body":  "I have code that calls EventSource.Write and passes in a field that is an array of strings. The code looks similar to:\r\n```\r\npublic static void LogFoo(string[] foo) {\r\n    EventSource logger = new EventSource(...);\r\n    logger.Write(\"...\", options, new { Foo = foo });\r\n}\r\n```\r\nThis code works without issue when run targeting any version of .net Framework I\u0027ve tested, and when targeting netcoreapp2.0. It does not work with netcoreapp2.1 with runtime version v2.1.300, instead throwing a System.NotSupportedException: \u0027Arrays of null-terminated string are not supported.\u0027 . While the message is pretty clear, I\u0027m wondering if this functionality regression was intentional?",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOVLqEWw==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDM5MzcxMDgyOA==",
                                           "createdAt":  "2018-05-31T23:10:27Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "davidmatson",
                                           "body":  "Yeah, having a minor version include breaking changes isn\u0027t good semver, so I\u0027m hoping that\u0027s not intentional.\r\n\r\n@brianrob, would you happen to know what the root cause might be? (Since you were the last one to edit [that line](https://github.com/dotnet/coreclr/blame/85374ceaed177f71472cc4c23c69daf7402e5048/src/System.Private.CoreLib/shared/System/Diagnostics/Tracing/TraceLogging/FieldMetadata.cs#L141), though admittedly just changing how the error lookup happens.)",
                                           "updatedAt":  "2018-05-31T23:10:27Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDM5Mzg5NzA1Mw==",
                                           "createdAt":  "2018-06-01T14:25:45Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "brianrob",
                                           "body":  "This is likely caused by https://github.com/dotnet/coreclr/pull/16672 where we switch from writing to ETW using counted strings to null-terminated strings when using the Write\u003cT\u003e APIs.  The message was always there, but because we were using counted strings we never hit it.  Let me see what can be done to fix this.",
                                           "updatedAt":  "2018-06-01T14:25:45Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ3MzA3MDA4Mw==",
                                           "createdAt":  "2019-03-14T21:25:41Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "vancem",
                                           "body":  "including @jorive @noahfalk ",
                                           "updatedAt":  "2019-03-14T21:25:41Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ4MzM1NzgyOQ==",
                                           "createdAt":  "2019-04-15T18:04:47Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tommcdon",
                                           "body":  "@noahfalk any objections moving this to future?",
                                           "updatedAt":  "2019-04-15T18:04:47Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ4MzUyNjU3OA==",
                                           "createdAt":  "2019-04-16T06:20:04Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOAopZuw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "tommcdon",
                                                                               "createdAt":  "2019-04-16T15:53:46Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "amrmahdi",
                                                                               "createdAt":  "2019-05-14T23:17:36Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "noahfalk",
                                           "body":  "I\u0027d still like to get this addressed in 3.0 if we can",
                                           "updatedAt":  "2019-04-16T06:20:04Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ4NTkxODQzOA==",
                                           "createdAt":  "2019-04-23T18:21:28Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "josalem",
                                           "body":  "After some research, changing this in a fully supportable manner (not just a workaround) would involve non-trivial changes to the serialization format used.  This could introduce instability in both the source and reader that is unwanted going into the 3.0 release.  I\u0027m going to move this to future for now.  @brianrob, you\u0027re most likely much more familiar with these code paths, if you think this would be a relatively straightforward update to the format, please let me know.",
                                           "updatedAt":  "2019-04-23T18:21:28Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ4NjQ3NDM3OA==",
                                           "createdAt":  "2019-04-25T00:23:38Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "noahfalk",
                                           "body":  "@josalem - can you elaborate on your investigation results such as what options you looked at and what changes/risks those options cause? Since we\u0027ve only marked this Future rather than closing it suggests that someone is going to be re-opening this investigation and it would be a shame if they had to start over from the beginning.",
                                           "updatedAt":  "2019-04-25T00:23:38Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ4NjUxMjYwNQ==",
                                           "createdAt":  "2019-04-25T04:07:55Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOAnlC8Q==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "josalem",
                                                                               "createdAt":  "2019-04-25T18:08:58Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "brianrob",
                                           "body":  "@josalem, I suspect you are right that this is not going to be trivial.  It stems from the fact that I was trying to unify the way we serialize strings between TraceLogging ETW and EventPipe so that I could add support for TraceLogging in EventPipe without having to support two deserialization schemes within TraceEvent. TraceLogging ETW previously used counted strings and had support for arrays of counted strings but when I switched things over to NULL-terminated strings, I did not realize, nor have a test case that covered arrays of strings.  The code had always been written to disallow this, but the path was never hit.\r\n\r\nI suspect that it is possible to implement this without too much trouble, but I don\u0027t know what the encoding would look like.  I don\u0027t believe that this would require fundamental changes to EventSource, but would require that we understand what the encoding should look like for supporting this on the ETW side, and then making sure that this works on the EventPipe side as well.\r\n\r\nIf you want to dig into this more, let me know and I can connect you with the right person who can tell us what the encoding should look like.",
                                           "updatedAt":  "2019-04-25T04:07:55Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ4Njc4MjkxMQ==",
                                           "createdAt":  "2019-04-25T18:17:13Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "josalem",
                                           "body":  "@noahfalk, as @brianrob points out, it looks to me like the majority of this work is going to be nailing down a stable encoding for arrays of \"primitive\" types (primitive in regards to what is already serializable by ETW/EventPipe).  That, in and of itself, shouldn\u0027t be too difficult (famous last words and all that), but will require updates to the serializers for ETW _and_ EventPipe, as well as updating the deserializers.  \r\n\r\nI feel there is higher priority work that will introduce less instability that can be completed with the timeframe we\u0027re looking at.  I do think this work _is_ worth implementing, as having arrays of \"things\" inside events would be very useful.  I\u0027m open to moving it back into 3.0, but I think IPC work should take priority since the current encoding seems to have only recently stabilized.  @brianrob, since there is going to be work surrounding serialization in general I think it would be worth syncing offline to go over the moving parts.",
                                           "updatedAt":  "2019-04-25T18:17:13Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ4Njg0MjA5Nw==",
                                           "createdAt":  "2019-04-25T21:20:00Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "brianrob",
                                           "body":  "Sure, @josalem.  Happy to chat.",
                                           "updatedAt":  "2019-04-25T21:20:00Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY2NTkyNjA4Mg==",
                                           "createdAt":  "2020-07-29T21:02:58Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tommcdon",
                                           "body":  "@davmason is this fixed in 5.0?",
                                           "updatedAt":  "2020-07-29T21:02:58Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY3MDc3ODUwNA==",
                                           "createdAt":  "2020-08-07T23:09:00Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "davmason",
                                           "body":  "This is not fixed in 5.0. The work I did recently for array types would allow us to put an array of strings in the file, but there is some code in EventSource that explicitly checks for arrays of null terminated strings and throws an exception. It may be as simple as removing that code, I\u0027m looking further",
                                           "updatedAt":  "2020-08-07T23:09:00Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY3MDc5MTU2OA==",
                                           "createdAt":  "2020-08-08T00:09:05Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOBQ_iVg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "iSazonov",
                                                                               "createdAt":  "2020-09-21T11:09:48Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "davmason",
                                           "body":  "After some further research, this works because you can pass arbitrary sized collections of strings to EventSource, but the specific example above doesn\u0027t work.\r\n\r\nAnonymous types with arrays as arguments are broken for all types. I.e. if you pass `new { args = new int[] { 1, 2, 3, 4 }}` as a parameter to WriteEvent it will also fail.\r\n\r\nI suspect the code above is doing that because `WriteEvent(1, new string[] { \"sample\", \"array\" });` will fail because the C# compiler resolves to the ` WriteEvent(int eventId, params object[]? args)` overload and the strings are passed as individual arguments instead of one array argument.\r\n\r\nIf you use the IEnumerable overload instead it will correctly send the event in .net 5:\r\n```\r\n        [Event(2, Level = EventLevel.LogAlways)]\r\n        public void StringIEnumerableEvent(IEnumerable\u003cstring\u003e args)\r\n        {\r\n            WriteEvent(2, args);\r\n        }\r\n```\r\n\r\nThis is not an issue for built in types (int, double, etc) arrays. I am not a C# language spec expert, but I suspect the issue is that string is an object and ints, etc, are value types so they won\u0027t use the `object[] params` overload.\r\n\r\nThe real issue here is the fact that anonymous types don\u0027t work with array types. I think this will require enough changes to EventSource that it should probably be pushed out to 6.0.",
                                           "updatedAt":  "2020-08-08T00:09:05Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcyMzM2MTM2Mg==",
                                           "createdAt":  "2020-11-07T00:43:59Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "josalem",
                                           "body":  "@davmason was this fixed in 5.0?",
                                           "updatedAt":  "2020-11-07T00:43:59Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcyMzM3MjgzNA==",
                                           "createdAt":  "2020-11-07T01:57:22Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "davmason",
                                           "body":  "No, I explained the issue above but I haven\u0027t worked on it. I don\u0027t think there really is an issue with the way arrays of strings work, it\u0027s just that the EventSource APIs have some corner cases that are unexpected.",
                                           "updatedAt":  "2020-11-07T01:57:22Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5UuoRb",
                                           "createdAt":  "2023-02-07T21:54:42Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "mslukebo",
                                           "body":  "Have there been any updates on this issue? I am trying to log an array of strings from a .NET 6 application, but I\u0027m hitting this exception. My `IEnumerable\u003cstring\u003e` is inside `EventData` struct, so I cannot manually call the appropriate `Write` method since I\u0027m writing the entire struct.",
                                           "updatedAt":  "2023-02-07T21:54:42Z"
                                       }
                                   ],
                         "totalCount":  16
                     },
        "title":  "Calling EventSource.Write with data containing an array of string throws on .net Core 2.1, works on .net Core 2.0",
        "labels":  [
                       "area-Tracing-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/10496",
        "createdAt":  "2018-06-12T18:34:55Z",
        "number":  10496,
        "author":  "vancem",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2022-06-08T20:36:39Z",
        "body":  "Useing the 2.1 version of .NET Core, you profile a simple app .NET Core App o (e.g. a spin loop like)\r\n```\r\n            var start = DateTime.Now;\r\n            while ((DateTime.Now - start).TotalSeconds \u003c 5)\r\n                {}\r\n```\r\nUsing EventPipe (e.g. set COMPlus_EnableEventPipe=1 and run the app) and then open the resulting *.netperf file, you will find that PerfView\u0027s \u0027Goto Source\u0027 feature works in the main program, attributing the cost to the correct source line.  \r\n\r\nHowever if you open up frames that are inside the framework (e.g. System.TimeZoneInfo.GetLocalTimeZoneFromTzFile) you will find that while PerfView can open the source code (it can correctly find the PDBS for System.Private.Corelib.pdb and the source files on Github), but it will attribute all the cost the the first line in the method.\r\n\r\nThis is because PerfView lacks the Native-\u003eIL mapping needed to map to a particular IL instruction (which in turn can be mapped to a particular line).     These normally given to perfView by the ILToNativeMap events in the runtime.  (Normally PerfView hides these events when you look at a trace but if you pass PerfView the /keepAllEvents when the trace is converted you can see them).  \r\n\r\nWhat you will find is that the mappings exist for all JIT compiled methods (at the time of JIT as well as during rundown), but there are no ILToNativeMap rundown events for DLLs that have been precompiled with Crossgen (which is most of the framework). \r\n\r\nWe do force the rundown of all methods (DCStopVerbose), that are precompiled (that is how we know the method), but we do currently do this for the ILToNativeMap.   \r\n\r\nThus the most straightforward solution is to simply log the ILToNativeMap during this rundown as well.  \r\n\r\nThis will be alot of data, and it may not be needed for simple investigations, but I think it is best to do the simple thing (always include it), and we can talk about having options for turning it off for advanced scenarios that care about file size.   \r\n\r\n@brianrob \r\n\r\n\r\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHORJGGew==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDM5NzM4MjU2Nw==",
                                           "createdAt":  "2018-06-14T17:52:28Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "brianrob",
                                           "body":  "I\u0027ve done some investigation on what it will take to add the ILToNativeMap for pre-compiled methods.  Overall, it does not look difficult, but I have a couple of questions.  @noahfalk can you help me answer these, or point me to the right person?\r\n\r\n1. ```SendMethodILToNativeMapEvent``` uses the debugger interface to get the map via https://github.com/dotnet/coreclr/blob/master/src/vm/eventtrace.cpp#L6757.  Will ```g_pDebugInterface-\u003eGetILToNativeMappingIntoArrays``` handle the hot and cold sections of a pre-compiled method?  I know in the ETW case it doesn\u0027t need to, but I\u0027m not sure if the debugger does need this.\r\n2. Does the rejitID matter?  For rundown events we specify 0 for the rejitID, but just want to make sure.\r\n3. Does tiering affect the validity of this data for pre-compiled methods?\r\n4. [Slightly less related] Is tiering already covered for the JIT case?",
                                           "updatedAt":  "2018-06-14T17:52:28Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDM5NzQzMTEyMw==",
                                           "createdAt":  "2018-06-14T20:40:10Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "noahfalk",
                                           "body":  "1) Yeah, that should work, but you probably want to make sure the right behavior is happening end to end. As I recall the offsets given in the map are encoded as if the hot and cold sections were contiguous in memory. This means the trace reader might need to compute:\r\n\r\n`     offset = ip_somewhere_in_cold_code - cold_code_start + hot_code_size`\r\n\r\nbefore it can use the data in the map that corresponds to the cold offsets.\r\n\r\n2) Yes we should make ReJITID be correct, but for precompiled code 0 is the correct value. Just curious, if the precompiled code isn\u0027t eligible to be used (lets says someone specified COMPlus_ReadyToRun=0) are the events going to skipped entirely? \r\n\r\n3) Nope. \r\n\r\n4) Yes it is. All jitting, whether or not for tiering, is funneled through JitCompileCode\r\nhttps://github.com/dotnet/coreclr/blob/master/src/vm/prestub.cpp#L555\r\n\r\nFrom there, assuming ETW events are enabled it will reach the callstack:\r\n\r\n```\r\nETW::MethodLog::SendMethodILToNativeMapEvent\r\nETW::MethodLog::MethodJitted\r\nMethodDesc::JitCompileCodeLockedEventWrapper\r\nMethodDesc::JitCompileCode\r\n```",
                                           "updatedAt":  "2018-06-14T20:40:10Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQwMTE0NzQ5MQ==",
                                           "createdAt":  "2018-06-28T19:31:35Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "brianrob",
                                           "body":  "Thanks @noahfalk.\r\n\r\nWe can certainly disable these events if ReadyToRun is disabled.  I\u0027m not sure at what level we have this knowledge, but at a minimum, we can check the environment variable.  I need to look further into this to see how we know that we\u0027re dealing with pre-compiled code to know for sure.\r\n\r\nOne follow-up question as well - I dug more into the current implementation of ```SendMethodILToNativeMapEvent``` and how it gets the ILToNativeMap.  It does look like it will provide information for both hot and cold sections, though as you point out, we\u0027ll need to make sure that we validate end-to-end that we do the math correctly.  One thing that I noticed is that when we emit the event today, we do the following:\r\n\r\n```\r\n        FireEtwMethodILToNativeMap(\r\n            ullMethodIdentifier, \r\n            rejitID,\r\n            0,          // Extent:  This event is only sent for JITted (not NGENd) methods, and\r\n            //          currently there is only one extent (hot) for JITted methods.\r\n            cMap,\r\n            rguiILOffset,\r\n            rguiNativeOffset,\r\n            GetClrInstanceId());\r\n```\r\n\r\nDoes ```g_pDebugInterface-\u003eGetILToNativeMappingIntoArrays``` provide a way to get at the data individually for the hot and cold sections?  I haven\u0027t found one yet.  I\u0027m wondering if that\u0027s the right way to go here, or if the extent number matters, and we can just emit the whole map with extent == 0.",
                                           "updatedAt":  "2018-06-28T19:31:35Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQwMTI1NzAxNg==",
                                           "createdAt":  "2018-06-29T06:06:42Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "noahfalk",
                                           "body":  "\u003e Does g_pDebugInterface-\u003eGetILToNativeMappingIntoArrays provide a way to get at the data individually for the hot and cold sections?\r\n\r\nI don\u0027t think there is anything directly inside the arrays you get back. You could seperately use CodeRegionInfo to determine the extents and then split the array based on the native offset.\r\n\r\n\u003e Does g_pDebugInterface-\u003eGetILToNativeMappingIntoArrays provide a way to get at the data individually for the hot and cold sections?\r\n\r\nHave ETW parsers have already taken a dependency on some contract for that extent? (You and Vance probably know better than I on that) If we don\u0027t have a conflicting implementation already in place then it seems reasonable to define that the event will always have extent = 0 and include offsets for all code regions.",
                                           "updatedAt":  "2018-06-29T06:06:42Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ4MzM0MDkwNg==",
                                           "createdAt":  "2019-04-15T17:17:36Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tommcdon",
                                           "body":  "@noahfalk any objections if we move this to future?",
                                           "updatedAt":  "2019-04-15T17:17:36Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5ERdlR",
                                           "createdAt":  "2022-06-02T23:14:03Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "pharring",
                                           "body":  "@brianrob, @noahfalk This still appears to be the case in .NET 6.\r\nI can\u0027t seem to \"Goto Source (Def)\" in PerfView for AOT-compiled framework assemblies. In the log below, I tried to \"Goto Source (Def)\" on `system.private.corelib!System.Threading.Tasks.Task::ExecuteWithThreadLocal(System.Threading.Tasks.Task\u0026, System.Threading.Thread)` on a trace from a .NET 6 app.\r\n\r\n```\r\nOpened Pdb file C:\\REDACTED\\SymbolCache\\System.Private.CoreLib.ni.pdb\\30C6BACB883EDCDD65584917F360153E1\\System.Private.CoreLib.ni.pdb\r\nSourceLocationForRva: looking up RVA 27387e \r\nSourceLocationForRva: did not find line info Looking for mangled symbol name (for NGEN pdbs)\r\nSourceLocationForRva: RVA lives in method with 4.6.1 mangled name System.Threading.Tasks.Task::ExecuteWithThreadLocal(System.Threading.Tasks.Task\u0026, System.Threading.Thread)$##60032B5\r\nSourceLocationForRva: Looking up IL Offset by RVA 0x27387e\r\nSourceLocationForRva: Ran out of IL mappings, guessing 0x0\r\nSourceLocationForRva: Found native to IL mappings, IL offset 0x0\r\nGetSourceLine:  Found mapping from Native to IL assembly System.Private.CoreLib Token 0x60032b5 offset 0x0\r\nGetSourceLine: Could not find managed module for NGEN image c:\\program files (x86)\\dotnet\\shared\\microsoft.netcore.app\\6.0.3\\system.private.corelib.dll\r\nGetSourceLine: Warning could not find line information in C:\\REDACTED\\SymbolCache\\System.Private.CoreLib.ni.pdb\\30C6BACB883EDCDD65584917F360153E1\\System.Private.CoreLib.ni.pdb\r\nGetSourceLine: Maybe because the NGEN pdb was generated without being able to reach the IL PDB\r\nGetSourceLine: If you are on the machine where the data was collected, deleting the file may help\r\n\r\nMetric as a function of code address\r\n      Address    :   Line     Metric\r\n        71cd387e :      0       14.0\r\nSource could not find a source location for the given Frame.\r\n```\r\n",
                                           "updatedAt":  "2022-06-02T23:14:03Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5ERga1",
                                           "createdAt":  "2022-06-02T23:39:43Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "noahfalk",
                                           "body":  "I think that is expected because the work to emit Native2IL mappings for R2R images at rundown didn\u0027t make any more progress after the discussion above back in 2018. @brianrob does that sound right?\r\n\r\n@pharring are you looking to do a profiling scenario where this is going to matter? I assume this is largely a priorities issue and thus far nothing pushed the priority to be high.",
                                           "updatedAt":  "2022-06-02T23:39:43Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5ERl0i",
                                           "createdAt":  "2022-06-03T00:11:36Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "pharring",
                                           "body":  "Yes, @noahfalk, this is about lighting up \"go to source\" from ETW traces.",
                                           "updatedAt":  "2022-06-03T00:11:36Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5EkYZ7",
                                           "createdAt":  "2022-06-08T20:36:38Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "brianrob",
                                           "body":  "Yes, @noahfalk I think that is right.  I don\u0027t believe that R2R PDBs have Native2IL mappings at this point.",
                                           "updatedAt":  "2022-06-08T20:36:38Z"
                                       }
                                   ],
                         "totalCount":  9
                     },
        "title":  "Make Line numbers work for crossgened DLLs when profiling with EventPipe ",
        "labels":  [
                       "EventPipe",
                       "area-Tracing-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/10620",
        "createdAt":  "2018-07-02T20:32:13Z",
        "number":  10620,
        "author":  "brianrob",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2021-05-04T22:40:48Z",
        "body":  "There are two event decoder paths in EventSource.  We should look to merge them.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOHM9voA==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ4MzM0MTM4MA==",
                                           "createdAt":  "2019-04-15T17:18:56Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tommcdon",
                                           "body":  "@sywhang @jorive is this work happening as part of IPC event pipe?  If no, any objections to moving this to future?",
                                           "updatedAt":  "2019-04-15T17:18:56Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ4MzM1NjU3Ng==",
                                           "createdAt":  "2019-04-15T18:00:58Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOAm8_HA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "jorive",
                                                                               "createdAt":  "2019-04-15T18:53:07Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "sywhang",
                                           "body":  "This isn\u0027t part of the IPC event pipe as this issue is mostly (if not all) refactoring managed code whereas the IPC work is all native part. I have no objections on moving this to future. ",
                                           "updatedAt":  "2019-04-15T18:00:58Z"
                                       }
                                   ],
                         "totalCount":  2
                     },
        "title":  "Merge EventPipePayloadDecoder.DecodePayload and EventProvider.DecodeObject",
        "labels":  [
                       "EventPipe",
                       "area-Tracing-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/11316",
        "createdAt":  "2018-10-24T22:09:44Z",
        "number":  11316,
        "author":  "vancem",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2023-10-16T07:08:22Z",
        "body":  "Today in the EventPipe, it is not easy to distinguish between an CPU bound thread and a blocked thread.  Today we just distinguish between threads in managed code (which CAN\u0027T be blocked) and threads that are not in managed code (which often are blocked but don\u0027t have to be).\r\n\r\nThis works OK, but is really not what we want because you can\u0027t answer simple questions like: is this thread/process CPU bound?   How much CPU capacity is my process consuming?     These are really quite useful.  \r\n\r\nFundamentally the reason we don\u0027t have this information is that there was no really EASY, EFFICIENT way of getting this information in a CROSS_PLATFORM way (since we would need to fetch it once per msec, PER THREAD) which is a lot.\r\n\r\nMy proposal here is to solve this in conjunction with Issue dotnet/runtime#11301.  \r\n* We add a new 64 bit field CpuOnThreadNSec which gives the number of nanoseconds of CPU time on that thread (the basis is not given, it is only useful for computing deltas).    This number can be 0 which means at the time the sample is taken we did not fetch this CPU time.\r\n  \r\nFor any threads that are actually sampled using the algorithm in dotnet/runtime#11301.\r\n\r\n* for every thread, if the last sample was in managed code, we will not bother setting the CpuOnThreadNSec field if the last time CpuOnThreadNSec was emitted on this thread was \u003c  1 second ago.  \r\n\r\nThus we get accurate CpuOnThreadNSec  every second (if we get events on the thread at all),   However we only pay for this once every second rather than once every msec, which is a huge improvement (indeed we may wish to make the threshold once every 100 msec (or make it configurable)).  \r\n\r\nNow if we do the optimization in dotnet/runtime#11301 if a thread never returns from native code, then you wont get any data on it (even if that native code is consuming CPU).     Thus event threads that have not returned should also log their CpuOnThreadsNSec at a low rate (~ once a second or slower),  I actually recommend a binary backoff algorithm (thus 1 sec, then 2 , then 4 ...) as long as the thread never returns from native code.   This allows the overhead of threads that just block and do almost nothing to approach 0 as time goes on.   \r\n\r\nThings can be tweeked here, but the basics are\r\n1) We have a new OPTIONAL field on the CPU Sample event that tells you CPU spend on the thread.   \r\n2) We collect this but at a lower rate \r\n3) For threads outside the runtime we collect it at even a lower rate still (because they are likley to be blocked).\r\n\r\nBut now the viewer can get a very good idea of what % of the time a thread spends CPU bound, and if it assumes all managed code is CPU, it can attribute how much of the native time is blocked.\r\n\r\n@noahfalk @brianrob @jorive",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOaSJdgA==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQzMjg0NzgyNg==",
                                           "createdAt":  "2018-10-24T22:18:40Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "vancem",
                                           "body":  "For Linux see getrusage() for AP ocr clock_gettime with CLOCK_THREAD_CPUTIME_ID for APIs that let you get at the CPU time of a thread (but granted it is the running thread).  \r\n\r\nWe might still use these if we put the logic for getting this information into the hijacking code (since we do cooperate to stop the thread).  \r\n\r\nThe other alternative is that we already in System.Diagnostics.ProcessThread do have logic for getting the CPU time for any thread (but looking at special files that OS exposes), but this is probably significantly slower (but maybe we don\u0027t care because we are only doing it ~1 / sec)  We should see what the  perf tradeoffs are here.   \r\n",
                                           "updatedAt":  "2018-10-24T22:18:40Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ4MzM1MzE3Mw==",
                                           "createdAt":  "2019-04-15T17:51:50Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tommcdon",
                                           "body":  "Moved to future milestone as our .net core 3.0 diagnostics user stories are targeting CPU and memory profiling.  We should bring this back to 3.0 if the fix is small.",
                                           "updatedAt":  "2019-04-15T17:51:50Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5pHEtw",
                                           "createdAt":  "2023-10-15T18:01:10Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Due to lack of recent activity, this issue has been marked as a candidate for backlog cleanup.  It will be closed if no further activity occurs within 14 more days. Any new comment (by anyone, not necessarily the author) will undo this process.\n\nThis process is part of our [issue cleanup automation](https://github.com/dotnet/runtime/blob/main/docs/issue-cleanup.md).",
                                           "updatedAt":  "2023-10-15T18:01:10Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5pIl2A",
                                           "createdAt":  "2023-10-16T07:08:15Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "adamsitnik",
                                           "body":  "\u003e  Any new comment (by anyone, not necessarily the author) will undo this process.\r\n\r\nThis is an important issue, please undo the process.",
                                           "updatedAt":  "2023-10-16T07:08:15Z"
                                       }
                                   ],
                         "totalCount":  4
                     },
        "title":  "Distinguish between Blocked and CPU time in EventPipe Traces.  ",
        "labels":  [
                       "EventPipe",
                       "area-Diagnostics-coreclr",
                       "area-Tracing-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/11358",
        "createdAt":  "2018-10-29T21:33:29Z",
        "number":  11358,
        "author":  "vancem",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2021-05-04T22:40:49Z",
        "body":  "In ETL files we have a bunch of OS events that we do not have in EventPipe  *.NetPerf files.   This  lack of information is unfortunate, and we should fix it.   Here are some missing things.\r\n\r\nThese could be put on the ProcessInfo event \r\n   * The Processor Speed \r\n   * The Processor Count  (And whether it is hyperthreaded).  \r\n   * The Time zone where the data is collected \r\n   * Total Machine Memory (when will paging start).\r\n\r\n* Expected sampling rate for the thread sampling.  \r\n\r\nTo replace the page fault events, some memory statstics, logged every second or two.   (Can get from System.Diagnostics.Process including\r\n\r\n    * Working Set\r\n    * Peak Working Set\r\n    * Virtual Memory Allocated\r\n    * Private Memory Allocated\r\n    * Page Faults.   \r\n    * Disk I/O bytes and number.   \r\n    * Average Disk response time (if available).  \r\n    * Network activity.  \r\n\r\nWe also need an unambiguous version number for the runtime (we have the Runtime/Start but it should be a rundown event (always logged even in circular buffer), and the version number should be accurate (today we don\u0027t have a sensible version number).  \r\n\r\nIn short a trace should never be WORSE than any common performance counter.   \r\n\r\nThis is a very straightforward work item (and can be implemented in managed code).  \r\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOJg_Hwg==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDYzODU2ODM4Ng==",
                                           "createdAt":  "2020-06-04T02:43:21Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "sywhang",
                                           "body":  "The VS blocking part of this issue has been moved to #37374 instead. I\u0027m marking this one for Future release unless anybody has objections.\r\n\r\n",
                                           "updatedAt":  "2020-06-04T02:43:21Z"
                                       }
                                   ],
                         "totalCount":  1
                     },
        "title":  "Add Missing OS information to EventPipe traces",
        "labels":  [
                       "EventPipe",
                       "area-Tracing-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/11434",
        "createdAt":  "2018-11-09T19:54:34Z",
        "number":  11434,
        "author":  "vancem",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2022-05-18T13:26:31Z",
        "body":  "In EventProvider.cs there is code that code that shared between EventPipe and ETW in the method EtwEnableCallBack that tries to support Session-based filtering.     Unfortunately, in the ports from Desktop the Session based functionality was broken.  (see below), and in addition this code is causing grief for EventPipe (which shares much of the ETW code path), and has broken it already (we patched it once) and is likely to again.   \r\n\r\nThis issue tracks cleaning this up.   The recommendation is to remove the Session-based logic for ETW (it did not work anyway, and has not proven valuable so far).   As a second step (probably as a separate issue), we can decide to implement Session-based filtering for EventPipe (which is significantly easier), and if we ultimately care (we probably wont) we could do it properly for ETW (importantly, since the time we implemented this for ETW we have learned of better ways to doing it, so the current code is never useful (we would do it very differently, even for ETW).  \r\n\r\nBACKGROUND:   First, what is Session-based filtering.\r\n\r\nEventSource has a multiple-reader model.   Each reader is called a session and when sessions enable an EventSource the provide bitmask (keywords), and level (verbosity), which determine which events to give to the session.   Importantly, you can have multiple sessions (readers) connected simultaneously and they should not interfere with one another (each gets the events they asked for and are unaware of the other sessions).   Thus logically each session has the bitmask and verbosity for the EventSource associated with it and when an event is written, logically there is a loop over all sessions which writes the event to just those sessions that want it.   \r\n\r\nThis all works well.   The issue is when you have parameters for EventSource that is the problem.   This is not a theoretical issue.   Much of our instrumentation now is DiagnosticSource, and you turn on these events via a special EventSource.   You specify exactly which DiagnosticSource events you want by using EventSource parameters.   If you have more than two EventSources that want to listen to DiagnositicSource events, then you will have the issue I am about to describe.  \r\n\r\nThe issue is that it is a PARTICULAR EventSource (e.g. DiagnosticSourceEventSource), that knows how to interpret the string, but the only mechanism it has to write will write to ALL sessions unconditionally.   Thus for example if two sessions give filter parameters to DiagnosticSourceEventSource, turning on different events, then the second one \u0027win\u0027s and the first session does no get what it wants.   \u0027Session based filtering fixes this  so that each session gets the events it asked for and the two sessions do not interfere).  \r\n\r\nFixing this is not actually trivial, because it requires a \u0027improved\u0027 contract between the EventSource base class and subclasses like DiagnosticSourceEventSource.   I will open a separate issue for that.\r\n\r\nBut suffice it to say that an attempt was made to do this for ETW (that is different ETW sessions would be distinguished) but it was tricky because unlike EventPipe or EventListener, our code cannot \u0027iterate\u0027 over the session (we see just the OS WriteEvent and the dispatch to individual sessions happens in the OS).    Suffice it to say, it added a bunch of complexity, and ultimately did not work.   \r\n\r\nThis issue tracks SIMPLY REMOVING THIS SUPPORT.  \r\n\r\nThe rational here is that we actually care more about EventPipe (which is cross platform) rather than ETW so the likely multi-session case for ETW is not likely.   Also it does not work today (so we are removing nothing, but does simplify things (in a non-trivial way).  \r\n\r\nBasically we need to remove GetSessions() and all its related code (which includes SessionMask.   You can remove all references to perEventSourceSessionId and etwSessionId.  \r\n\r\nFYI, if we ever decide we actually want to implement this per-session functionality on ETW, there is a .NET Framework bug \r\n\r\nSee bug https://devdiv.visualstudio.com/DevDiv/_workitems/edit/105200 Using ETW session-based filtering with EventWriteEx() instead of custom reserved \"Session\" keywords\r\n\r\nThat goes into some of the details.     I don\u0027t expect us to do this any time soon.  ",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  null,
                         "nodes":  [

                                   ],
                         "totalCount":  0
                     },
        "title":  "Fix EventSource ETW Session Logic (affects EventPipe)",
        "labels":  [
                       "area-Tracing-coreclr",
                       "tracking",
                       "feature-request"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/11775",
        "createdAt":  "2019-01-08T19:11:24Z",
        "number":  11775,
        "author":  "mjsabby",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOAl--Uw==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "leons727",
                                            "createdAt":  "2019-03-27T23:45:54Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Epp-code",
                                            "createdAt":  "2019-03-29T22:17:41Z"
                                        }
                                    ],
                          "totalCount":  2
                      },
        "updatedAt":  "2021-05-04T22:40:49Z",
        "body":  "To do continuous monitoring of an application where you would like MethodLoad events for jitted code to support symbolic lookup, and would also like GC events you end up getting AllocationTicks as well because the GC Keyword\u0027s verbosity level 5 gives you that data.\r\n\r\nI\u0027m proposing we add a new GCLowVolume keyword so that we can get verbose data for MethodLoads and continue to have GC monitoring that does not impact performance (due to the high event volume).",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOHVMomg==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ1OTQ4MDAzNQ==",
                                           "createdAt":  "2019-01-31T19:45:27Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tommcdon",
                                           "body":  "cc @Maoni0 @andy-ms  @noahfalk @jorive ",
                                           "updatedAt":  "2019-01-31T19:45:27Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ1OTUwNTE2Nw==",
                                           "createdAt":  "2019-01-31T21:02:44Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Maoni0",
                                           "body":  "it sounds like what you are asking is the ability to specify different levels for different keywords. from a feature area\u0027s POV, there\u0027s nothing that prevents you from doing that - each event will check if it\u0027s enabled based on keyword + level already. I\u0027m curious - @vancem is there a way currently to specify to collect with different levels for different keywords with perfview?",
                                           "updatedAt":  "2019-01-31T21:02:44Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ1OTYyNDg0Nw==",
                                           "createdAt":  "2019-02-01T06:48:44Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "mjsabby",
                                           "body":  "It maybe that the event does that, but as far as I know ETW does not allow per event verbosity levels, and only supports verbosity at the provider level.\r\n\r\nYou could image going the other way, i.e. make a new keyword for Method Load data being available in a new keyword at non verbose levels, and that will be fine with me as well. I had to pick one direction.",
                                           "updatedAt":  "2019-02-01T06:48:44Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ2MDM4NDQ3Ng==",
                                           "createdAt":  "2019-02-04T19:42:19Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "vancem",
                                           "body":  "@mjsabby quiet a while ago (years now), we moved the Method*Verbose events (which have the symbolic information) from the Verbose level to the Informational level, for precisely the reason you state.  I allows you to get symbols information for the JIT compiled code without having to have verbose events (in particular the GCAllocationTick event), if you desire that.  \r\n\r\nDoes that solve your problem?    It is already there (and has been for a while).   You can simply turn your verbosity down it Informational to avoid the verbose GC events.   \r\n ",
                                           "updatedAt":  "2019-02-04T19:42:36Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ2MDkzOTg1OQ==",
                                           "createdAt":  "2019-02-06T08:31:35Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "mjsabby",
                                           "body":  "It does, but I don\u0027t see that actually occurring so I\u0027ll have to confirm. If I recall not setting the level to verbose caused the dynamic methods not to be emitted.",
                                           "updatedAt":  "2019-02-06T08:31:35Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ2MTE0NzI1Nw==",
                                           "createdAt":  "2019-02-06T19:07:06Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "vancem",
                                           "body":  "If there are bugs, we should fix them (but I would not have expected dynamic methods to be treated differently, so I am surprised it would not just work).   We should confirm.  ",
                                           "updatedAt":  "2019-02-06T19:07:06Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ4NDMwODk1Mg==",
                                           "createdAt":  "2019-04-18T00:21:11Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Maoni0",
                                           "body":  "@mjsabby could you please verify if you are seeing the designed behavior (Method events on information level)? if not we should fix that.",
                                           "updatedAt":  "2019-04-18T00:21:11Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ4NDMzMDM2NQ==",
                                           "createdAt":  "2019-04-18T02:19:53Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "mjsabby",
                                           "body":  "On information level we see `Microsoft-Windows-DotNETRuntime/Method/Load`, whereas on verbose we see `Microsoft-Windows-DotNETRuntime/Method/LoadVerbose`. The verbose events carry the method name, namespace \u0026 signature. The regular events do not.\r\n\r\nI still think that it makes sense to add a new keyword for GC like GCLowVolume because it may be that there are other verbose events that are useful like JIT inlining information, and it is fine to want them because eventually an application reaches steady state but the GC events continue to be voluminous.\r\n\r\nFurthermore, it is probably a regression to do this at Information level. Because one could argue that even at Level 4 of Method events there is enough information being emitted that in conjunction with ModuleLoad events you could open the PE file and read the method name, method namespace and signature from the metadata.",
                                           "updatedAt":  "2019-04-18T02:19:53Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ5MTQ2MjgwMQ==",
                                           "createdAt":  "2019-05-11T00:19:21Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "mjsabby",
                                           "body":  "I looked into implementing this and it would require a lot of changes to the GC events. Instead maybe we can add a SupressGCAllocationTick keyword that will suppress the AllocationTicks. This way the change is only in a single place in the GC. @Maoni0 thoughts?",
                                           "updatedAt":  "2019-05-11T00:19:21Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ5MTk4OTE0Ng==",
                                           "createdAt":  "2019-05-13T21:13:34Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "noahfalk",
                                           "body":  "@mjsabby - I am guessing there is going to be a general pattern here of people wanting verbose events from one keyword and not from another. I want to make sure that if we do something we are following a path that scales towards a general solution, even if we only implement a little part of it to start. My instinct is that GCLowVolume could probably be generalized but SupressGCAllocationTick feels very one-off (not any significant analysis behind this, just a hunch). The team is really heads down trying to get 3.0 wrapped up and with all the work in flight I don\u0027t think we\u0027ve got time to engage on the design for this right now. I\u0027m going to suggest we let this one rest for now and return to it once we\u0027ve got fewer features in-progress.",
                                           "updatedAt":  "2019-05-13T21:13:34Z"
                                       }
                                   ],
                         "totalCount":  10
                     },
        "title":  "New GCLowVolume keyword for ETW/EventPipe events when verbose events are enabled for other keywords",
        "labels":  [
                       "enhancement",
                       "area-GC-coreclr",
                       "area-Tracing-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/12926",
        "createdAt":  "2019-04-23T12:30:30Z",
        "number":  12926,
        "author":  "noahfalk",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2021-11-12T23:30:47Z",
        "body":  "Once we have runtime multi-session support, we need to handle the case where multiple clients are each requesting different refresh rates from EventCounters. My proposal in our earlier design discussions is that we emit a series of counter data for every requested interval. In the future we might filter it so that each client\u0027s request only goes to their session, but that requires work from [#20917](https://github.com/dotnet/coreclr/issues/20917) which we aren\u0027t doing yet. In the meantime we will let all clients observe the requests from all other clients and they can pick out the series they are interested in. \r\n\r\nWe need to do work in EventSource/EventCounters to maintain distinct requests from each client and to compute statistics/emit events corresponding to those intervals.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOHhN-XA==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDUwNDU5NDAxMg==",
                                           "createdAt":  "2019-06-21T22:35:53Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "noahfalk",
                                           "body":  "We didn\u0027t have time to do this in 3.0. The plan for now is that asking for EventCounters in multiple sessions will use the lowest refresh rate of all sessions. Listeners can either use the smaller intervals as is or aggregate the stats from multiple smaller intervals into a larger one. We can revisit based on feedback in the future.",
                                           "updatedAt":  "2019-06-21T22:35:53Z"
                                       }
                                   ],
                         "totalCount":  1
                     },
        "title":  "EventCounter multi-session support",
        "labels":  [
                       "enhancement",
                       "area-Tracing-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/12631",
        "createdAt":  "2019-05-05T01:46:40Z",
        "number":  12631,
        "author":  "VincentBu",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2021-06-03T17:46:49Z",
        "body":  "**Job:**\r\nhttps://ci.dot.net/job/dotnet_coreclr/job/master/view/x64/job/jitstress/job/x64_checked_windows_nt_minopts/841/\r\n\r\n**Failed tests:**\r\ntracing\\tracevalidation\\inducedgc\\inducedgc\\inducedgc.cmd\r\n\r\n**Log:**\r\n```\r\ntracing\\tracevalidation\\inducedgc\\inducedgc\\inducedgc.cmd [FAIL]\r\n        \r\n        Unhandled Exception: System.Exception: Read past end of stream.\r\n           at FastSerialization.IOStreamStreamReader.Fill(Int32 minimum)\r\n           at FastSerialization.PinnedStreamReader.GetPointer(Int32 length)\r\n           at Microsoft.Diagnostics.Tracing.EventPipeEventSource.ReadEvent(PinnedStreamReader reader)\r\n           at Microsoft.Diagnostics.Tracing.EventPipeEventBlock.FromStream(Deserializer deserializer)\r\n           at FastSerialization.Deserializer.ReadObjectDefinition(Tags tag, StreamLabel objectLabel)\r\n           at FastSerialization.Deserializer.ReadObject()\r\n           at Microsoft.Diagnostics.Tracing.EventPipeEventSource.Process()\r\n           at Tracing.Tests.TraceValidationInducedGC.Main(String[] args) in D:\\j\\workspace\\x64_checked_w---a16971a7\\tests\\src\\tracing\\tracevalidation\\inducedgc\\InducedGC.cs:line 60\r\n        \r\n        Return code:      1\r\n```",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOHT2aKQ==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ5MDU3NjA3NA==",
                                           "createdAt":  "2019-05-08T17:25:37Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "RussKeldorph",
                                           "body":  "      tracing\\tracevalidation\\inducedgc\\inducedgc\\inducedgc.cmd [FAIL]\r\n        \r\n        Unhandled Exception: System.Exception: Read past end of stream.\r\n           at FastSerialization.IOStreamStreamReader.Fill(Int32 minimum)\r\n           at FastSerialization.PinnedStreamReader.GetPointer(Int32 length)\r\n           at Microsoft.Diagnostics.Tracing.EventPipeEventSource.ReadEvent(PinnedStreamReader reader)\r\n           at Microsoft.Diagnostics.Tracing.EventPipeEventBlock.FromStream(Deserializer deserializer)\r\n           at FastSerialization.Deserializer.ReadObjectDefinition(Tags tag, StreamLabel objectLabel)\r\n           at FastSerialization.Deserializer.ReadObject()\r\n           at Microsoft.Diagnostics.Tracing.EventPipeEventSource.Process()\r\n           at Tracing.Tests.TraceValidationInducedGC.Main(String[] args) in D:\\j\\workspace\\x64_checked_w---a16971a7\\tests\\src\\tracing\\tracevalidation\\inducedgc\\InducedGC.cs:line 60\r\n        \r\n        Return code:      1\r\n        Raw output file:      D:\\j\\workspace\\x64_checked_w---a16971a7\\bin\\tests\\Windows_NT.x64.Checked\\Reports\\tracing.tracevalidation\\inducedgc\\inducedgc\\inducedgc.output.txt\r\n        Raw output:\r\n        BEGIN EXECUTION\r\n         \"D:\\j\\workspace\\x64_checked_w---a16971a7\\bin\\tests\\Windows_NT.x64.Checked\\Tests\\Core_Root\\corerun.exe\" inducedgc.exe \r\n        \tStart: Enable tracing.\r\n        \tEnd: Enable tracing.\r\n        \r\n        \tStart: Generate some events.\r\n        \tEnd: Generate some events.\r\n        \r\n        \tStart: Disable tracing.\r\n        \tEnd: Disable tracing.\r\n        \r\n        \tStart: Process the trace file.\r\n        Expected: 100\r\n        Actual: -532462766\r\n        END EXECUTION - FAILED\r\n        FAILED\r\n        Test Harness Exitcode is : 1\r\n        To run the test:\r\n        \u003e set CORE_ROOT=D:\\j\\workspace\\x64_checked_w---a16971a7\\bin\\tests\\Windows_NT.x64.Checked\\Tests\\Core_Root\r\n        \u003e D:\\j\\workspace\\x64_checked_w---a16971a7\\bin\\tests\\Windows_NT.x64.Checked\\tracing\\tracevalidation\\inducedgc\\inducedgc\\inducedgc.cmd\r\n        Expected: True\r\n        Actual:   False\r\n",
                                           "updatedAt":  "2019-05-08T17:25:37Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ5MDU3NjQyNQ==",
                                           "createdAt":  "2019-05-08T17:26:39Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "RussKeldorph",
                                           "body":  "Note that this is failed under COMPlus_JITMinOps=1.  That may be related, or it may just be an unstable test since it doesn\u0027t repro consistently.",
                                           "updatedAt":  "2019-05-08T17:26:39Z"
                                       }
                                   ],
                         "totalCount":  2
                     },
        "title":  "[x64] Test failed: tracing\\tracevalidation\\inducedgc\\inducedgc\\inducedgc.cmd",
        "labels":  [
                       "arch-x64",
                       "area-Tracing-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/12662",
        "createdAt":  "2019-05-08T09:21:58Z",
        "number":  12662,
        "author":  "jiangzeng01",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOBEBg0g==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "daviburg",
                                            "createdAt":  "2020-05-13T04:35:52Z"
                                        }
                                    ],
                          "totalCount":  1
                      },
        "updatedAt":  "2022-10-13T20:19:21Z",
        "body":  "Test: \r\ncoreclr\\tests\\src\\tracing\\eventsource\\eventsourcetrace\\EventSourceTrace.cs\r\nLine 23: \r\nthis.WriteEvent(1, x, y, z, **null**);\r\n \r\n```\r\nF:\\TempRepo\\coreclr\u003ebin\\tests\\Windows_NT.x64.Debug\\tracing\\eventsource\\eventsourcetrace\\eventsourcetrace\\eventsourcetrace.cmd\r\nBEGIN EXECUTION\r\n \"F:\\TempRepo\\coreclr\\bin\\tests\\Windows_NT.x64.Debug\\Tests\\Core_Root\\corerun.exe\" eventsourcetrace.exe\r\n        Start: Enable tracing.\r\n        End: Enable tracing.\r\n\r\n        Start: Messaging.\r\n\r\nUnhandled Exception: System.Diagnostics.Tracing.EventSourceException: Null passed as a event argument.\r\n   at System.Diagnostics.Tracing.EventSource.ThrowEventSourceException(String eventName, Exception innerEx)\r\n   at System.Diagnostics.Tracing.EventSource.WriteEventVarargs(Int32 eventId, Guid* childActivityID, Object[] args)\r\n   at System.Diagnostics.Tracing.EventSource.WriteEvent(Int32 eventId, Object[] args)\r\n   at Tracing.Tests.SimpleEventSource.MathResult(Int32 x, Int32 y, Int32 z, String formula) in F:\\TempRepo\\coreclr\\tests\\src\\tracing\\eventsource\\eventsourcetrace\\EventSourceTrace.cs:line 23\r\n   at Tracing.Tests.EventSourceTrace.Main(String[] args) in F:\\TempRepo\\coreclr\\tests\\src\\tracing\\eventsource\\eventsourcetrace\\EventSourceTrace.cs:line 75\r\nExpected: 100\r\nActual: 255\r\nEND EXECUTION - FAILED\r\nFAILED\r\n```\r\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOTC7E_A==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ5MDY0NjI1Mg==",
                                           "createdAt":  "2019-05-08T20:51:13Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "sywhang",
                                           "body":  "@brianrob Is this an expected behavior that\u0027s working as design? I tried something similar on Framework and it doesn\u0027t seem to be throwing there. Just wanted to know what the correct behavior should be here before I put out a \"fix\" :-) ",
                                           "updatedAt":  "2019-05-08T20:51:13Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ5MDY2Nzg0Nw==",
                                           "createdAt":  "2019-05-08T22:04:50Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOBEBgxQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "daviburg",
                                                                               "createdAt":  "2020-05-13T04:35:28Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "brianrob",
                                           "body":  "@sywhang, I would expect a null argument passed for ```formula``` in ```Tracing.Tests.SimpleEventSource.MathResult(Int32 x, Int32 y, Int32 z, String formula)``` should result in that null being written into the trace file.  Said another way, null is a legal value for reference types.",
                                           "updatedAt":  "2019-05-08T22:04:50Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ5MDY2ODM5OA==",
                                           "createdAt":  "2019-05-08T22:06:54Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jorive",
                                           "body":  "I think the function being called here is `WriteEvent(Int32, param object[])`",
                                           "updatedAt":  "2019-05-08T22:06:54Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ5MDY3MTExNA==",
                                           "createdAt":  "2019-05-08T22:18:00Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "brianrob",
                                           "body":  "Right - every manifest based event is implemented as something that looks like this:\r\n\r\n```\r\n[Event(1)]\r\npublic void MathResult(Int32 x, Int32 y, Int32 z, String formula)\r\n{\r\n    WriteEvent(1, x, y, z, formula);\r\n}\r\n```\r\n\r\nThere are various overloads of WriteEvent to avoid the array allocation and subsequent boxing associated with param object[], but if there isn\u0027t a specialized overload for the set of arguments to the event then the compiler will bind to ```WriteEvent(Int32, param object[])```.\r\n\r\nSo even though you see the exception inside fo ```WriteEvent```, the work being done is on-behalf-of the event method.",
                                           "updatedAt":  "2019-05-08T22:18:00Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDYyNzc0MDcyMQ==",
                                           "createdAt":  "2020-05-13T04:38:07Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "daviburg",
                                           "body":  "I got tripped by that today. I have tracing in place and sometimes one of the write event parameters (type string) is null, most of the time it\u0027s not. So first it look all hunky dory then I get this back from customer traces:\r\n\r\n`EventSourceException while processing event \"**redacted**\": Null passed as a event argument.`",
                                           "updatedAt":  "2020-05-13T04:38:07Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5MLU42",
                                           "createdAt":  "2022-10-13T18:47:46Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "JJamesWWang",
                                           "body":  "@davmason @noahfalk Is this issue still actionable? I noticed the original file with the failing test no longer exists.",
                                           "updatedAt":  "2022-10-13T18:47:46Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5MLpus",
                                           "createdAt":  "2022-10-13T20:07:42Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCt0adg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "AaronRobinsonMSFT",
                                                                               "createdAt":  "2022-10-13T20:19:30Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "JJamesWWang",
                                                                               "createdAt":  "2022-10-13T20:21:46Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "noahfalk",
                                           "body":  "I\u0027m guessing the underlying issue may still actionable even if the test is gone or moved. Given that the bug is 3 years old there was probably some churn in the tests since then. The only way to know for sure would be to recreate a new test case that hits the issue. From the description it appears you would need to create an EventSource that takes a reference type argument such as a string and then pass null to it. Hope that helps!",
                                           "updatedAt":  "2022-10-13T20:07:42Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5MLsT8",
                                           "createdAt":  "2022-10-13T20:19:21Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCt0agQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "JJamesWWang",
                                                                               "createdAt":  "2022-10-13T20:21:56Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "AaronRobinsonMSFT",
                                           "body":  "@JJamesWWang The introduction for EventSource is at https://learn.microsoft.com/dotnet/core/diagnostics/eventsource-getting-started. You could also try searching in git and check the history to recover the old test source that existed in 2019.",
                                           "updatedAt":  "2022-10-13T20:19:21Z"
                                       }
                                   ],
                         "totalCount":  8
                     },
        "title":  "[EventPipe] Null passed as an event argument causes crash",
        "labels":  [
                       "help wanted",
                       "area-Tracing-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/12669",
        "createdAt":  "2019-05-09T01:09:00Z",
        "number":  12669,
        "author":  "VincentBu",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2021-06-03T17:46:50Z",
        "body":  "**Job:**\r\nhttps://ci.dot.net/job/dotnet_coreclr/job/master/view/x86/job/jitstress/job/x86_checked_windows_nt_jitstress1_tiered/283/\r\n\r\n**Failed tests:**\r\ntracing\\eventsource\\eventsourcetrace\\eventsourcetrace\\eventsourcetrace.cmd\r\n\r\n**Log:**\r\n```\r\ntracing\\eventsource\\eventsourcetrace\\eventsourcetrace\\eventsourcetrace.cmd [FAIL]\r\n        \r\n        Unhandled Exception: OutOfMemoryException.\r\n        \r\n        Return code:      1\r\n        Raw output file:      D:\\j\\workspace\\x86_checked_w---5cbe5e6f\\bin\\tests\\Windows_NT.x86.Checked\\Reports\\tracing.eventsource\\eventsourcetrace\\eventsourcetrace\\eventsourcetrace.output.txt\r\n        Raw output:\r\n        BEGIN EXECUTION\r\n         \"D:\\j\\workspace\\x86_checked_w---5cbe5e6f\\bin\\tests\\Windows_NT.x86.Checked\\Tests\\Core_Root\\corerun.exe\" eventsourcetrace.exe \r\n        \tStart: Enable tracing.\r\n        \tEnd: Enable tracing.\r\n        \r\n        \tStart: Messaging.\r\n        \tEnd: Messaging.\r\n        \r\n        \tStart: Disable tracing.\r\n        \tEnd: Disable tracing.\r\n        \r\n        \tStart: Processing events from file.\r\n        Expected: 100\r\n        Actual: -532462766\r\n        END EXECUTION - FAILED\r\n        FAILED\r\n        Test Harness Exitcode is : 1\r\n        To run the test:\r\n        \u003e set CORE_ROOT=D:\\j\\workspace\\x86_checked_w---5cbe5e6f\\bin\\tests\\Windows_NT.x86.Checked\\Tests\\Core_Root\r\n        \u003e D:\\j\\workspace\\x86_checked_w---5cbe5e6f\\bin\\tests\\Windows_NT.x86.Checked\\tracing\\eventsource\\eventsourcetrace\\eventsourcetrace\\eventsourcetrace.cmd\r\n        Expected: True\r\n        Actual:   False\r\n        Stack Trace:\r\n          D:\\j\\workspace\\x86_checked_w---5cbe5e6f\\bin\\tests\\Windows_NT.x86.Checked\\TestWrappers\\tracing.eventsource\\tracing.eventsource.XUnitWrapper.cs(129,0): at tracing_eventsource._eventsourcetrace_eventsourcetrace_eventsourcetrace_._eventsourcetrace_eventsourcetrace_eventsourcetrace_cmd()\r\n        Output:\r\n          \r\n          Unhandled Exception: OutOfMemoryException.\r\n          \r\n          Return code:      1\r\n          Raw output file:      D:\\j\\workspace\\x86_checked_w---5cbe5e6f\\bin\\tests\\Windows_NT.x86.Checked\\Reports\\tracing.eventsource\\eventsourcetrace\\eventsourcetrace\\eventsourcetrace.output.txt\r\n          Raw output:\r\n          BEGIN EXECUTION\r\n           \"D:\\j\\workspace\\x86_checked_w---5cbe5e6f\\bin\\tests\\Windows_NT.x86.Checked\\Tests\\Core_Root\\corerun.exe\" eventsourcetrace.exe \r\n          \tStart: Enable tracing.\r\n          \tEnd: Enable tracing.\r\n          \r\n          \tStart: Messaging.\r\n          \tEnd: Messaging.\r\n          \r\n          \tStart: Disable tracing.\r\n          \tEnd: Disable tracing.\r\n          \r\n          \tStart: Processing events from file.\r\n          Expected: 100\r\n          Actual: -532462766\r\n          END EXECUTION - FAILED\r\n          FAILED\r\n          Test Harness Exitcode is : 1\r\n          To run the test:\r\n          \u003e set CORE_ROOT=D:\\j\\workspace\\x86_checked_w---5cbe5e6f\\bin\\tests\\Windows_NT.x86.Checked\\Tests\\Core_Root\r\n          \u003e D:\\j\\workspace\\x86_checked_w---5cbe5e6f\\bin\\tests\\Windows_NT.x86.Checked\\tracing\\eventsource\\eventsourcetrace\\eventsourcetrace\\eventsourcetrace.cmd\r\n```",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOHUOLqg==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ5MDk2NTcxMQ==",
                                           "createdAt":  "2019-05-09T16:04:21Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "RussKeldorph",
                                           "body":  "Related to dotnet/runtime#12642?",
                                           "updatedAt":  "2019-05-09T16:04:21Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ5MDk2NTkzMA==",
                                           "createdAt":  "2019-05-09T16:04:56Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "RussKeldorph",
                                           "body":  "@sywhang",
                                           "updatedAt":  "2019-05-09T16:04:56Z"
                                       }
                                   ],
                         "totalCount":  2
                     },
        "title":  "[x86] Test failed: tracing\\eventsource\\eventsourcetrace\\eventsourcetrace\\eventsourcetrace.cmd",
        "labels":  [
                       "arch-x86",
                       "area-Tracing-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/12750",
        "createdAt":  "2019-05-24T23:58:09Z",
        "number":  12750,
        "author":  "noahfalk",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOCzJxmA==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "lmolkova",
                                            "createdAt":  "2022-07-12T15:42:44Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "brenthompson2",
                                            "createdAt":  "2023-10-09T17:04:27Z"
                                        }
                                    ],
                          "totalCount":  2
                      },
        "updatedAt":  "2021-11-23T05:01:12Z",
        "body":  "Today there is some friction using ILogger from .Net libraries. Different library authors may have different reasons but some common examples would be ILogger isn\u0027t shipped as part of the BCL, or that they don\u0027t want to create requirements that the library user pass in an ILogger instance. There are different ideas on how to get deal with this, one of them being use EventSource from the library and let the app developer bridge it to ILogger if that is what they are using.\r\n\r\n\r\nThis issue tracks exploring what that could look like, cataloging potential issues and solutions to those issues. There is some related discussion that already happened in dotnet/runtime#12730 - in particular the desire to transmit Exception objects without serializing them.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOOi8s2A==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc46LyzY",
                                           "createdAt":  "2021-11-23T05:01:12Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODJLX-Q==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "brenthompson2",
                                                                               "createdAt":  "2023-10-10T14:00:10Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "reyang",
                                           "body":  "In addition, folks using EventSource might want to get the [correlation with Activity](https://docs.microsoft.com/dotnet/api/microsoft.extensions.logging.loggerfactoryoptions.activitytrackingoptions). This could also be done by updating the ETW correlation GUID during Activity creation/destruction.",
                                           "updatedAt":  "2021-11-23T05:01:12Z"
                                       }
                                   ],
                         "totalCount":  1
                     },
        "title":  "Explore using EventSource in front of ILogger",
        "labels":  [
                       "area-Tracing-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/12774",
        "createdAt":  "2019-05-30T05:56:00Z",
        "number":  12774,
        "author":  "jkotas",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2022-05-18T13:26:32Z",
        "body":  "`EventPipe::Shutdown` + `DiagnosticServer::Shutdown` is called as the first thing in `EEShutDownHelper`: https://github.com/dotnet/coreclr/blob/5b283a18625f7a8009c18221592ec81c3cd32375/src/vm/ceemain.cpp#L1409\r\n\r\nThis is too early. There is still quite a bit of user managed code running during `EEShutDownHelper` (all AppDomain.ProcessExit events) that should be able to use tracing facilities.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  null,
                         "nodes":  [

                                   ],
                         "totalCount":  0
                     },
        "title":  "EventPipe shutdown too early",
        "labels":  [
                       "EventPipe",
                       "area-Tracing-coreclr",
                       "tracking",
                       "feature-request"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/12847",
        "createdAt":  "2019-06-11T01:58:19Z",
        "number":  12847,
        "author":  "VincentBu",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2021-06-03T17:46:50Z",
        "body":  "**Job:**\r\nhttps://mc.dot.net/#/user/coreclr-outerloop-jitstress/ci~2Fdotnet~2Fcoreclr~2Frefs~2Fheads~2Fmaster/test~2Ffunctional~2Fcli~2F/20190609.1/workItem/PayloadGroup0/analysis/xunit/tracing_eventcounter._pollingcounter_pollingcounter_~2F_pollingcounter_pollingcounter_sh\r\n\r\n**Failed tests:**\r\ntracing_eventcounter._pollingcounter_pollingcounter_._pollingcounter_pollingcounter_sh\r\n\r\n**Log:**\r\n```\r\nReturn code:      1\r\nRaw output file:      /root/helix/work/workitem/tracing/eventcounter/Reports/tracing.eventcounter/pollingcounter/pollingcounter.output.txt\r\nRaw output:\r\nBEGIN EXECUTION\r\n/root/helix/work/correlation/corerun pollingcounter.exe \u0027\u0027\r\nTest Failed\r\nExpected: 100\r\nActual: 1\r\nEND EXECUTION - FAILED\r\nTest Harness Exitcode is : 1\r\nTo run the test:\r\n\u003e set CORE_ROOT=/root/helix/work/correlation\r\n\u003e /root/helix/work/workitem/tracing/eventcounter/pollingcounter/pollingcounter.sh\r\nExpected: True\r\nActual:   False\r\n```\r\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOH6Bctg==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDUwMDg2MjI1Ng==",
                                           "createdAt":  "2019-06-11T14:18:01Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "BruceForstall",
                                           "body":  "Failed in:\r\n```\r\nUbuntu.1804.Arm32.Open-arm-Checked-zapdisable\r\nOSX.1014.Amd64.Open-x64-Checked-zapdisable\r\n```",
                                           "updatedAt":  "2019-06-11T14:18:01Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDUwMTU0ODc4Ng==",
                                           "createdAt":  "2019-06-13T04:58:49Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jorive",
                                           "body":  "@sywhang Could you please take a look?",
                                           "updatedAt":  "2019-06-13T04:58:49Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDUwNDgzNzQ0Ng==",
                                           "createdAt":  "2019-06-24T02:48:31Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "VincentBu",
                                           "body":  "please take a look at https://mc.dot.net/#/user/coreclr-outerloop-jitstressregs/ci~2Fdotnet~2Fcoreclr~2Frefs~2Fheads~2Fmaster/test~2Ffunctional~2Fcli~2F/20190623.1/workItem/PayloadGroup0/analysis/xunit/tracing_eventcounter._incrementingpollingcounter_incrementingpollingcounter_~2F_incrementingpollingcounter_incrementingpollingcounter_sh\r\nI am not sure whether it can be related to this issue.",
                                           "updatedAt":  "2019-06-24T02:48:31Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDUzMDYwMzE5MA==",
                                           "createdAt":  "2019-09-11T23:24:43Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "sywhang",
                                           "body":  "https://github.com/dotnet/coreclr/pull/26666 should address this.",
                                           "updatedAt":  "2019-09-11T23:24:43Z"
                                       }
                                   ],
                         "totalCount":  4
                     },
        "title":  "[Test failed] tracing_eventcounter._pollingcounter_pollingcounter_._pollingcounter_pollingcounter_sh",
        "labels":  [
                       "arch-arm32",
                       "os-linux",
                       "area-Tracing-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/13019",
        "createdAt":  "2019-07-02T00:39:13Z",
        "number":  13019,
        "author":  "noahfalk",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOC6-53Q==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "ReubenBond",
                                            "createdAt":  "2019-07-02T01:11:07Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "sywhang",
                                            "createdAt":  "2019-07-02T01:25:34Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "davmason",
                                            "createdAt":  "2019-07-02T01:59:16Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "lmolkova",
                                            "createdAt":  "2019-07-02T03:21:33Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "mjsabby",
                                            "createdAt":  "2019-07-02T05:47:38Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "mattwarren",
                                            "createdAt":  "2019-07-02T10:15:57Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "stevejgordon",
                                            "createdAt":  "2019-07-02T10:22:46Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "gregkalapos",
                                            "createdAt":  "2019-07-02T10:35:26Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "jborut",
                                            "createdAt":  "2019-07-02T10:37:53Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "russcam",
                                            "createdAt":  "2019-07-02T10:59:28Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "eric-b",
                                            "createdAt":  "2019-07-02T11:13:46Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "chrisnas",
                                            "createdAt":  "2019-07-02T11:42:05Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "lokki",
                                            "createdAt":  "2019-07-02T11:58:44Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "holthe-tveit",
                                            "createdAt":  "2019-07-02T12:03:40Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "MedAnd",
                                            "createdAt":  "2019-07-02T13:39:24Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "szehetner",
                                            "createdAt":  "2019-07-02T14:30:14Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Mpdreamz",
                                            "createdAt":  "2019-07-02T14:44:10Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "stephenpope",
                                            "createdAt":  "2019-07-02T14:45:26Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "nklsaxo",
                                            "createdAt":  "2019-07-02T17:05:55Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "shanegrueling",
                                            "createdAt":  "2019-07-02T17:18:18Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "delia-buhan",
                                            "createdAt":  "2019-07-02T17:26:13Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "OmerRaviv",
                                            "createdAt":  "2019-07-02T17:47:40Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Enumix",
                                            "createdAt":  "2019-07-02T21:08:38Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "veikkoeeva",
                                            "createdAt":  "2019-07-02T21:25:30Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "hoyosjs",
                                            "createdAt":  "2019-07-02T22:08:44Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "NickDarvey",
                                            "createdAt":  "2019-07-02T23:54:49Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "mirbeta",
                                            "createdAt":  "2019-07-03T00:28:12Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "kishanAnem",
                                            "createdAt":  "2019-07-03T02:39:54Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "EvgeniyZviryaka",
                                            "createdAt":  "2019-07-03T13:39:11Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "tonyredondo",
                                            "createdAt":  "2019-07-03T22:01:20Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "josalem",
                                            "createdAt":  "2019-07-03T22:53:01Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "loic-sharma",
                                            "createdAt":  "2019-07-03T23:21:06Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "gjuttla",
                                            "createdAt":  "2019-07-05T08:57:17Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "MarcusKohnert",
                                            "createdAt":  "2019-07-26T18:25:09Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "moshegutman",
                                            "createdAt":  "2019-08-12T13:21:27Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "shirhatti",
                                            "createdAt":  "2020-03-05T20:17:31Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "funkeyfreak",
                                            "createdAt":  "2020-07-10T14:18:05Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "MihaZupan",
                                            "createdAt":  "2020-11-02T13:41:28Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "discostu105",
                                            "createdAt":  "2021-11-19T16:35:59Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "julealgon",
                                            "createdAt":  "2024-09-12T22:17:40Z"
                                        }
                                    ],
                          "totalCount":  40
                      },
        "updatedAt":  "2024-09-12T22:19:13Z",
        "body":  "I\u0027m making this issue as an informal way to flag other issues and discussions that might be relevant to doing tracing, logging, and performance counters in the .Net runtime. This includes technologies such as EventSource, EventPipe, ETW, Lttng, EventCounter, EventListener, DiagnosticsSource, and Activity. This thread is likely to stay closer to the bleeding edge than release notes or docs on docs.microsoft.com, but in exchange it is likely be more informal. If this is something you are interested in, subscribe to this issue to follow along.\r\n\r\nPlease don\u0027t do discussion directly in this issue, just links or short announcements. Thanks!",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOi-mS1g==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU0ODYxMDMxNw==",
                                           "createdAt":  "2019-10-31T23:37:33Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "noahfalk",
                                           "body":  "I recently made a few fixes/minor feature additions for EventPipe and DiagnosticSourceEventSource. With these changes it may now be possible to make a basic distributed tracing instrumentation tool that uses only EventPipe rather than the traditional approach of in-process SDKs or profiler based IL instrumentation. I have only created prototype at this point, it has yet to be proven with a production scale implementation.\r\n\r\nhttps://github.com/dotnet/coreclr/pull/27522 \r\nhttps://github.com/dotnet/corefx/pull/42104   ",
                                           "updatedAt":  "2019-10-31T23:37:33Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU0ODYxMTkwOA==",
                                           "createdAt":  "2019-10-31T23:44:00Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "noahfalk",
                                           "body":  "We are working to improve our [documentation](https://docs.microsoft.com/en-us/dotnet/core/diagnostics/) on new global tools created in .Net Core 3.0, such as dotnet-counters and dotnet-trace. Feedback on the documentation or the tools is always welcome (though please use https://github.com/dotnet/diagnostics/issues/515 or new issues in the diagnostics repo as needed). Thanks!",
                                           "updatedAt":  "2019-10-31T23:44:00Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU5ODEzNjQ4NQ==",
                                           "createdAt":  "2020-03-12T11:26:45Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOA-Aqxw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "ReubenBond",
                                                                               "createdAt":  "2020-03-12T19:49:51Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "joacar",
                                                                               "createdAt":  "2020-03-12T22:31:47Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "noahfalk",
                                           "body":  "@tarekgh has been hard at work planning some improvements to the Activity APIs for .NET 5. These APIs make it easier for anyone to add Activities to their distributed traces and improve the OpenTelemetry integration story. Check out #31373 and let us know what you think in the comments there. Thanks!",
                                           "updatedAt":  "2020-03-12T11:26:45Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6L6ZLW",
                                           "createdAt":  "2024-09-12T22:19:01Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "julealgon",
                                           "body":  "@noahfalk any updates to share here?",
                                           "updatedAt":  "2024-09-12T22:19:01Z"
                                       }
                                   ],
                         "totalCount":  4
                     },
        "title":  "Tracing and Counters Interest Group - Announcements",
        "labels":  [
                       "question",
                       "design-discussion",
                       "area-Diagnostics-coreclr",
                       "area-Tracing-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/13124",
        "createdAt":  "2019-07-23T02:17:16Z",
        "number":  13124,
        "author":  "kouvel",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2023-03-24T14:12:51Z",
        "body":  "Code:\r\n\r\n```c#\r\nstatic class Program\r\n{\r\n    private class ClrEventListener : EventListener\r\n    {\r\n        public static readonly string ClrProviderName = \"Microsoft-Windows-DotNETRuntime\";\r\n        public static readonly Guid ClrProviderGuid = new Guid(unchecked((int)0x5e5bb766), unchecked((short)0xbbfc), unchecked((short)0x5662), 0x05, 0x48, 0x1d, 0x44, 0xfa, 0xd9, 0xbb, 0x56);\r\n        private const EventKeywords CompilationKeyword = (EventKeywords)0x1000000000;\r\n\r\n        protected override void OnEventSourceCreated(EventSource eventSource)\r\n        {\r\n            if (eventSource.Name == ClrProviderName \u0026\u0026 eventSource.Guid == ClrProviderGuid)\r\n                EnableEvents(eventSource, EventLevel.Informational, CompilationKeyword);\r\n\r\n            base.OnEventSourceCreated(eventSource);\r\n        }\r\n\r\n        protected override void OnEventWritten(EventWrittenEventArgs eventData)\r\n        {\r\n            Console.WriteLine($\"{s_sw.Elapsed.TotalMilliseconds,10:0.000} - {eventData.EventName}\");\r\n            Console.WriteLine($\"  Keywords: 0x{eventData.Keywords:x}\");\r\n            Console.WriteLine($\"  ID:       {eventData.EventId}\");\r\n            Console.WriteLine($\"  Task:     {eventData.Task}\");\r\n            Console.WriteLine($\"  Opcode:   {eventData.Opcode}\");\r\n            var payloadNames = eventData.PayloadNames.ToList();\r\n            var payloads = eventData.Payload.Select(o =\u003e o.ToString()).ToList();\r\n            var payloadCount = Math.Min(payloadNames.Count, payloads.Count);\r\n            Console.WriteLine($\"  Payloads: {payloadCount}\");\r\n            for (int i = 0; i \u003c payloadCount; ++i)\r\n                Console.WriteLine($\"    {payloadNames[i]}: {payloads[i]}\");\r\n            Console.WriteLine();\r\n\r\n            base.OnEventWritten(eventData);\r\n        }\r\n    }\r\n\r\n    private static void Main()\r\n    {\r\n        using (var el = new ClrEventListener())\r\n        {\r\n            var marker = \"######################################################\";\r\n            var nl = Environment.NewLine;\r\n\r\n            Console.WriteLine($\"{s_sw.Elapsed.TotalMilliseconds,10:0.000} - {marker} - Waiting for misc stuff{nl}\");\r\n            Thread.Sleep(2000);\r\n\r\n            Console.WriteLine($\"{s_sw.Elapsed.TotalMilliseconds,10:0.000} - {marker} - Foo() tier 0 and waiting for startup delay{nl}\");\r\n            Foo();\r\n            Thread.Sleep(1000);\r\n\r\n            Console.WriteLine($\"{s_sw.Elapsed.TotalMilliseconds,10:0.000} - {marker} - Tiering up{nl}\");\r\n            for (int i = 1; i \u003c 100; ++i)\r\n                Foo();\r\n            Thread.Sleep(1000);\r\n\r\n            Console.WriteLine($\"{s_sw.Elapsed.TotalMilliseconds,10:0.000} - {marker} - Foo() tier 1{nl}\");\r\n            Foo();\r\n        }\r\n    }\r\n\r\n    [MethodImpl(MethodImplOptions.NoInlining)]\r\n    private static void Foo()\r\n    {\r\n    }\r\n\r\n    private static readonly Stopwatch s_sw = Stopwatch.StartNew();\r\n}\r\n```\r\n\r\nOutput:\r\n\r\n```\r\n...\r\n\r\n  2003.498 - ###################################################### - Foo() tier 0 and waiting for startup delay\r\n\r\n  2014.411 - TieredCompilationPause\r\n  Keywords: 0x0000F01000000000\r\n  ID:       281\r\n  Task:     65253\r\n  Opcode:   Info\r\n  Payloads: 1\r\n    ClrInstanceID: 5\r\n\r\n  2223.281 - TieredCompilationResume\r\n  Keywords: 0x0000F01000000000\r\n  ID:       282\r\n  Task:     65252\r\n  Opcode:   Info\r\n  Payloads: 2\r\n    ClrInstanceID: 5\r\n    NewMethodCount: 2\r\n\r\n  3004.193 - ###################################################### - Tiering up\r\n\r\n  3014.768 - TieredCompilationBackgroundJitStart\r\n  Keywords: 0x0000F01000000000\r\n  ID:       283\r\n  Task:     65251\r\n  Opcode:   Start\r\n  Payloads: 2\r\n    ClrInstanceID: 5\r\n    PendingMethodCount: 1\r\n\r\n  3021.809 - TieredCompilationBackgroundJitStop\r\n  Keywords: 0x0000F01000000000\r\n  ID:       284\r\n  Task:     65251\r\n  Opcode:   Stop\r\n  Payloads: 3\r\n    ClrInstanceID: 5\r\n    PendingMethodCount: 0\r\n    JittedMethodCount: 1\r\n\r\n  4005.403 - ###################################################### - Foo() tier 1\r\n```\r\n\r\n- For these events the expected `Task` is `31`\r\n- For the `Pause`/`Resume` events the expected `Opcode`s are `12` and `13` respectively\r\n- The `Opcode`s for the `Start`/`Stop` events are correct",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOLEpZsg==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDUxNTYzODQ3NQ==",
                                           "createdAt":  "2019-07-27T00:57:03Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tommcdon",
                                           "body":  "@sywhang @josalem ",
                                           "updatedAt":  "2019-07-27T00:57:03Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc0MjE1NDczNQ==",
                                           "createdAt":  "2020-12-10T00:37:56Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tommcdon",
                                           "body":  "@kouvel we are triaging issues for 6.0, is this still an issue that we should fix in this release?",
                                           "updatedAt":  "2020-12-10T00:37:56Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc0MzA3MDEzMA==",
                                           "createdAt":  "2020-12-11T09:08:00Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "kouvel",
                                           "body":  "The issue still repros. It\u0027s not blocking me, though the Task values are way off and Opcode values look incorrect sometimes I can probably use just the event name or ID for tests if necessary since they are unique for the provider.",
                                           "updatedAt":  "2020-12-11T09:08:00Z"
                                       }
                                   ],
                         "totalCount":  3
                     },
        "title":  "[EventListener] Reported Task and Opcode are incorrect for events",
        "labels":  [
                       "area-Tracing-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/13125",
        "createdAt":  "2019-07-23T02:21:11Z",
        "number":  13125,
        "author":  "kouvel",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2022-05-18T13:25:16Z",
        "body":  "`EventWrittenEventArgs` doesn\u0027t appear to provide information about which thread fired the event. It would be useful to have that information to be able to associate paired events such as `Start`/`Stop` that may be fired from multiple threads concurrently.\r\n\r\nAs for which thread ID, it would be useful to have both the OS thread ID, and the managed thread ID if it\u0027s a managed thread. The OS thread ID would be useful for events fired by the runtime, some of which may be fired from unmanaged threads. The managed thread ID would be useful for consumers tracking their events that are fired from managed threads using .NET APIs.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOHqkdhA==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDUxNDIwMzgyMA==",
                                           "createdAt":  "2019-07-23T13:13:18Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "Isn\u0027t the EventSource event fired synchronously, in which case you can just look at Environment.CurrentManagedThreadId?",
                                           "updatedAt":  "2019-07-23T18:11:14Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDUxNDMxMjMwNA==",
                                           "createdAt":  "2019-07-23T17:42:38Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "kouvel",
                                           "body":  "The callback is happening on a thread pool thread and it\u0027s a different thread from the thread that fired the event (main thread in this case).\r\n\r\n```\r\n   at System.Environment.get_StackTrace()\r\n   at TieringInProcEventListener.ClrEventListener.OnEventWritten(EventWrittenEventArgs eventData) in D:\\Test\\source\\test\\Program.cs:line 65\r\n   at System.Diagnostics.Tracing.EventSource.DispatchToAllListeners(Int32 eventId, Guid* childActivityID, EventWrittenEventArgs eventCallbackArgs)\r\n   at System.Diagnostics.Tracing.EventPipeEventDispatcher.DispatchEventsToEventListeners()\r\n   at System.Threading.Tasks.Task.InnerInvoke()\r\n   at System.Threading.Tasks.Task.\u003c\u003ec.\u003c.cctor\u003eb__274_0(Object obj)\r\n   at System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state)\r\n   at System.Threading.Tasks.Task.ExecuteWithThreadLocal(Task\u0026 currentTaskSlot, Thread threadPoolThread)\r\n   at System.Threading.Tasks.Task.ExecuteEntryUnsafe(Thread threadPoolThread)\r\n   at System.Threading.Tasks.ThreadPoolTaskScheduler.\u003c\u003ec.\u003c.cctor\u003eb__10_0(Object s)\r\n   at System.Threading.ThreadHelper.ThreadStart_Context(Object state)\r\n   at System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state)\r\n   at System.Threading.ThreadHelper.ThreadStart(Object obj)\r\n```",
                                           "updatedAt":  "2019-07-23T17:42:38Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDUxNDMyMjM0Nw==",
                                           "createdAt":  "2019-07-23T18:10:38Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "Ah, EventPipe is doing the offloading.",
                                           "updatedAt":  "2019-07-23T18:10:38Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDUxNDM5OTYyMA==",
                                           "createdAt":  "2019-07-23T21:59:32Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "kouvel",
                                           "body":  "Updated description to specify the kind of thread ID",
                                           "updatedAt":  "2019-07-23T21:59:32Z"
                                       }
                                   ],
                         "totalCount":  4
                     },
        "title":  "[EventListener] Include thread ID",
        "labels":  [
                       "enhancement",
                       "EventPipe",
                       "area-Tracing-coreclr",
                       "tracking"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/49080",
        "createdAt":  "2019-10-17T18:32:15Z",
        "number":  49080,
        "author":  "wfurt",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2022-06-21T21:22:17Z",
        "body":  "I have trivial project like I\u0027m trying to trace:\r\n```c#\r\nusing System;\r\nusing System.Net;\r\nusing System.Net.Http;\r\nusing System.Diagnostics;\r\n\r\nnamespace MacMinimal\r\n{\r\n    class Program\r\n    {\r\n        static void Main(string[] args)\r\n        {\r\n            string name = args.Length \u003e 0 ? args[0] : \"www.micsrosoft.com\";\r\n            Console.WriteLine(\"Press enter to get {0}! {1}\", name,  Process.GetCurrentProcess().Id );\r\n            Console.ReadLine();\r\n\r\n            Console.WriteLine(\"got {0}\", Dns.GetHostEntry(name));\r\n            var client = new HttpClient();\r\n            client.Timeout = TimeSpan.FromSeconds(10);\r\n            var response = client.GetAsync(new Uri(\"http://\" + name)).GetAwaiter().GetResult();\r\n            Console.WriteLine(response.StatusCode);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nWhen I press ^C while running or if this throws, I get corrupted trace. I cannot open it either with PerfView or Microsoft.Diagnostics.Tracing packges:\r\n```\r\nUnhandled exception. System.Exception: Read past end of stream.\r\n   at FastSerialization.IOStreamStreamReader.Fill(Int32 minimum)\r\n   at FastSerialization.MemoryStreamReader.ReadByte()\r\n   at FastSerialization.Deserializer.ReadTag()\r\n   at FastSerialization.Deserializer.ReadObject()\r\n   at Microsoft.Diagnostics.Tracing.EventPipeEventSource.Process()\r\n   at Microsoft.Diagnostics.Tracing.Etlx.TraceLog.CopyRawEvents(TraceEventDispatcher rawEvents, IStreamWriter writer)\r\n   at Microsoft.Diagnostics.Tracing.Etlx.TraceLog.\u003c\u003ec__DisplayClass118_0.\u003cFastSerialization.IFastSerializable.ToStream\u003eb__0()\r\n   at FastSerialization.DeferedRegion.Write(Serializer serializer, Action toStream)\r\n   at Microsoft.Diagnostics.Tracing.Etlx.TraceLog.FastSerialization.IFastSerializable.ToStream(Serializer serializer)\r\n   at FastSerialization.Serializer.WriteObjectData(IFastSerializable obj, Tags beginTag)\r\n   at FastSerialization.Serializer.WriteObjectRef(IFastSerializable obj, Boolean defered)\r\n   at FastSerialization.Serializer..ctor(IStreamWriter writer, IFastSerializable entryObject)\r\n   at Microsoft.Diagnostics.Tracing.Etlx.TraceLog.CreateFromEventPipeEventSources(TraceEventDispatcher source, String etlxFilePath, TraceLogOptions options)\r\n   at Microsoft.Diagnostics.Tracing.Etlx.TraceLog.CreateFromEventPipeDataFile(String filePath, String etlxFilePath, TraceLogOptions options)\r\n   at tracing.Program.Main(String[] args) in /home/furt/tracing/Program.cs:line 19\r\n``` \r\nI would expect that tracing will produce valid output up to process exit. \r\nWithout it, it will be very difficult to use diagnostic to trace bugs.  \r\n\r\nI\u0027m running on ubuntu 16.04 with Microsoft.Diagnostics.Tracing.TraceEvent 2.0.45\r\n\r\n\r\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOLxceZg==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU0MzMwNzg4OA==",
                                           "createdAt":  "2019-10-17T18:39:27Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "sywhang",
                                           "body":  "This is by design. We get truncated traces because the runtime cannot flush its buffer for storing events upon unhandled exceptions or any other abrupt terminations. To make the trace fully useful, we need to send additional events via rundown events, but none of this can be sent if the app is crashing abruptly. \r\n\r\nTo make PerfView open the truncated trace with best-effort, you can run PerfView with the /ContinueOnError option and it will try to open the trace as much as it can.\r\n\r\n\u003e Without it, it will be very difficult to use diagnostic to trace bugs.\r\n\r\nTo diagnose a crash, `dotnet-dump` is the better tool to use since `dotnet-trace` wasn\u0027t designed to diagnose crashes or abrupt exits.",
                                           "updatedAt":  "2019-10-17T18:39:27Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU0MzMxMTgwOA==",
                                           "createdAt":  "2019-10-17T18:49:41Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "wfurt",
                                           "body":  "In case of exception we can still flush pipeline, right? It is not like we get hard OS crash. \r\nMaybe re-consider current design? Tracing is still useful as corefile may not have events leading to exception - specially for networking operations. \r\n\r\ncc: @jkotas ",
                                           "updatedAt":  "2019-10-17T18:49:41Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU0MzQxOTUwOQ==",
                                           "createdAt":  "2019-10-18T00:10:45Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "Related: https://github.com/dotnet/coreclr/pull/27238\r\n\r\ncc @kouvel ",
                                           "updatedAt":  "2019-10-18T00:10:45Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU0MzUwMTk5NQ==",
                                           "createdAt":  "2019-10-18T04:49:18Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "noahfalk",
                                           "body":  "\u003e In case of exception we can still flush pipeline, right? It is not like we get hard OS crash.\r\n\r\nPotentially - I agree it would be worth having us take a look. The hard cases are where the OS has started killing threads (leaked locks) or the exception is occurring because the process is in a fairly bad state (ie OOM, stack overflow, memory corruption). If we have a reasonable opportunity to finish up the trace while the process is still in predictable state that seems worth pursuing.",
                                           "updatedAt":  "2019-10-18T04:49:18Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc5MDA0NDI2Mg==",
                                           "createdAt":  "2021-03-03T20:47:49Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tommcdon",
                                           "body":  "Adding enhancement label - the runtime does not fire rundown events on unhandled exceptions",
                                           "updatedAt":  "2021-03-03T20:47:49Z"
                                       }
                                   ],
                         "totalCount":  5
                     },
        "title":  "dotnet-trace can produce corrupted traces when traced process does not exit cleanly",
        "labels":  [
                       "documentation",
                       "enhancement",
                       "area-Tracing-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/32877",
        "createdAt":  "2020-02-26T18:21:37Z",
        "number":  32877,
        "author":  "noahfalk",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2022-05-18T13:26:33Z",
        "body":  "Opening new issue on behalf of @joacar. It wasn\u0027t clear if the original issue #26727 was related. Copied from https://github.com/dotnet/runtime/issues/26727#issuecomment-591526718\r\n\r\n\u003e Hi,\r\n\u003e \r\n\u003e I\u0027m trying to create counters dynamically and it works all though I\u0027m not sure it\u0027s the recommended approach. The upper limit of http clients (see zip) is bounded by 50. \r\n\u003e \r\n\u003e The gist of my solution:\r\n\u003e 1. Create DiagnosticListener and listen to `System.Net.Http.RequestOut.Start` and `Stop`\r\n\u003e 1. A static instance of EventSource that has a `ConcurrentDictionary` to keep a metric for each http client making a request on `RequestStart` and `RequestStop`.\r\n\u003e \r\n\u003e I loaded the .trace file into perfiew and can\u0027t see the formatted message nor is the method name appended to the event name, as seen [here](https://user-images.githubusercontent.com/174258/66986366-15ff8d80-f0bf-11e9-9cd7-b7beea70746c.PNG) ([source](https://github.com/Particular/NServiceBus/pull/5465)). Read some article on MSDN that the number of arguments sent to method should be sent in the same order to `WriteEvent` for it to work. Thing is, I don\u0027t use raw `EventCounter` instead I rely on `PollingCounter` et al.\r\n\u003e \r\n\u003e Thanks\r\n\u003e \r\n\u003e [WebApplication1.zip](https://github.com/dotnet/runtime/files/4257005/WebApplication1.zip)\r\n ",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOI7gNow==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU5MTU3NjY3Mw==",
                                           "createdAt":  "2020-02-26T18:36:59Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "noahfalk",
                                           "body":  "\u003e can\u0027t see the formatted message nor is the method name appended to the event name\r\n\r\nWhat command are you using to collect the trace and which events are you expecting to see this information for? I assumed the picture you linked is to show an example of behavior you were expecting (it does have text in the FormattedText column), let me know if that isn\u0027t the correct interpretation.\r\n\r\nWhen I looked at your repro I saw a few potential issues:\r\n1. The implementation of event logging functions (such as ModuleRequestStarted) in the ModuleEventSource never calls WriteEvent(…) so no event is logged.\r\n\r\n2. The comments suggested running dotnet-trace using command-line:\r\n\r\n`// dotnet trace collect -p \u003cpid\u003e --providers My.Custom.Source.WebApplication1`\r\n\r\n  If you want the trace to collect the counters (and you don\u0027t have to) then you need to tell it how often to collect them. It can be indicated like this:\r\n\r\n`dotnet-trace collect -p \u003cpid\u003e --providers My.Custom.Source.WebApplication1:::EventCounterIntervalSec=1`",
                                           "updatedAt":  "2020-02-26T18:36:59Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU5MTU4MzMxOA==",
                                           "createdAt":  "2020-02-26T18:51:50Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "noahfalk",
                                           "body":  "\u003e Read some article on MSDN that the number of arguments sent to method should be sent in the same order to WriteEvent for it to work\r\n\r\nIf your goal is only to log counters and not to log the explicit events for each RequestStart and request failure then you probably want to remove the [Event(...)] attribute from those methods and use the [NonEvent](https://docs.microsoft.com/en-us/dotnet/api/system.diagnostics.tracing.noneventattribute?view=netframework-4.8) attribute instead. If your goal is to log an event each time a request starts/fails then you should call WriteEvent(...) inside the implementation of ModuleRequestStarted and ModuleRequestFailed.\r\n\r\nAs the code is currently written you won\u0027t get explicit events for RequestStart/RequestFailed because WriteEvent() is never called. The Event attribute causes no harm that I am aware of, but it might confuse someone reading the source. There are also some minor side-effects where EventSource is creating data structures/event manifests assuming that RequestStart/RequestFailed events might be emitted but they never are.",
                                           "updatedAt":  "2020-02-26T18:51:50Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU5MTg3ODA1OA==",
                                           "createdAt":  "2020-02-27T09:45:54Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "joacar",
                                           "body":  "Thanks @noahfalk for clarification and educating me. I assumed that writing an event counter also wrote corresponding event. I\u0027ve updated the code to call `WriteEvent` but FormattedMessage is still blank.\r\n\r\n```c#\r\n[Event(Id.RequestCompletedId, Message = \"Request for module \u0027{0}\u0027 completed\", Level = EventLevel.Informational)]\r\npublic void RequestCompleted(string moduleId)\r\n{\r\n    WriteEvent(Id.RequestCompletedId, moduleId);\r\n    // ...\r\n}\r\n```\r\n![perfview_empty_formattedmessage](https://user-images.githubusercontent.com/439028/75426946-ea7e9080-5945-11ea-8e7c-8d5a3c7531d6.png)\r\n\r\nThanks for the tip about fetching interval counters with specified interval. That explains why I occasionally saw them in perfview.\r\n\r\nI\u0027m thinking of writing an event with a formatted message `HTTP/{Version} {Method} {Uri.Authority} responded {StatusCode} in {ElapsedTime} ms`. Since I\u0027m using HttpClientFactory parts of this information is already logged (see below) and maybe it\u0027s already an event doing what I\u0027m planning. Is there any built in event that tracks outgoing HTTP calls in this fashion?\r\n\r\n```\r\ninfo: System.Net.Http.HttpClient.\u003cName\u003e.LogicalHandler[100]\r\n      Start processing HTTP request GET http://localhost:63697/test\r\ninfo: System.Net.Http.HttpClient.\u003cName\u003e.ClientHandler[100]\r\n      Sending HTTP request GET http://localhost:63697/test\r\ninfo: System.Net.Http.HttpClient.\u003cName\u003e.ClientHandler[101]\r\n      Received HTTP response after 86203.4755ms - OK\r\ninfo: System.Net.Http.HttpClient.\u003cName\u003e.LogicalHandler[101]\r\n      End processing HTTP request after 86213.6493ms - OK\r\n```\r\n",
                                           "updatedAt":  "2020-02-27T13:17:20Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU5MjE1OTAwMQ==",
                                           "createdAt":  "2020-02-27T20:22:14Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOA-Kt4g==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "joacar",
                                                                               "createdAt":  "2020-03-15T21:01:50Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "noahfalk",
                                           "body":  "\u003e but FormattedMessage is still blank.\r\n\r\nI investigated a bit and there are appears to be more than one issue causing this. The first one that I expected is that you are running into a current limitation with nettrace file serialization. When collecting using ETW (.etl files) the string you put in the Message attribute is transmitted as part of the trace, but the nettrace file isn\u0027t saving it. Without the template string available PerfView is unable to produce the final formatted string. This is one of the unfortunate rough edges where nettrace isn\u0027t yet at full parity with ETW capabilities.\r\nHowever then I went to test this using an ETW collection (Collect menu -\u003e Collect menu item -\u003e Write \"*My.Custom.Source.WebApplication1:::EventCounterIntervalSec=1\" in the additional providers text box) and it still didn\u0027t work. I was seeing that the majority of events in the trace didn\u0027t have FormattedMessage, not just the ones produced by the custom EventSource. I haven\u0027t tracked down a root cause, but it suggests there is at least one additional bug preventing this from working properly.\r\n\r\nAs a workaround if you get rid of the FormattedMessage column in PerfView then the Rest column will show you the raw key/value pairs that were collected, including your moduleId parameter:\r\n![image](https://user-images.githubusercontent.com/6243776/75478708-44d21e00-5953-11ea-933d-faadec3caca1.png)\r\n\r\n\u003e Is there any built in event that tracks outgoing HTTP calls in this fashion?\r\n\r\n[HttpClient](https://docs.microsoft.com/en-us/dotnet/api/system.net.http.httpclient.-ctor?view=netframework-4.8#System_Net_Http_HttpClient__ctor_System_Net_Http_HttpMessageHandler_) supports [pluggable handlers](https://docs.microsoft.com/en-us/dotnet/api/system.net.http.httpmessagehandler?view=netframework-4.8) that can run code when the message is going out or a response is coming back. The logging you\u0027ve spotted comes from two different handlers that I was aware of, though you could also add your own:\r\n1. The DiagnosticSource logging the current code hooks into comes from the [DiagnosticsHandler](https://source.dot.net/#System.Net.Http/System/Net/Http/DiagnosticsHandler.cs,989e1e62b8fd60ec,references) which is included in all HttpClient instances by default.\r\n2. The ILogger based logging you noticed comes from the [LoggingHttpMessageHandler](\r\nhttps://source.dot.net/#Microsoft.Extensions.Http/Logging/LoggingHttpMessageHandler.cs,eb567f49ba7fdb9f) which is injected by the implementation of IHttpClientFactory you are using.\r\n\r\nUnless you want to add your own HttpMessageHandler to log in a custom way, the rest of the solutions are around converting between the forms of logging that are in place and the form of logging you ultimately want. If your goal is to get the logging out-of-process using dotnet trace then we are looking at solutions that convert from DiagnosticSource -\u003e EventSource or from ILogger to EventSource. You already spotted the option to implement your own DiagnosticListener and do the conversion directly. Likewise you could create your own ILoggerProvider and do a similar conversion on the ILogger messages. However there are also two existing mechanisms that might give you what you were hoping for:\r\n1. [DiagnosticSourceEventSource](https://source.dot.net/#System.Diagnostics.DiagnosticSource/System/Diagnostics/DiagnosticSourceEventSource.cs,24) - This is a built in EventSource that can configured to capture and convert arbitrary DiagnosticSource events into EventSource events. Although not as flexible as doing a custom listener, it has the advantage that it ships in the runtime making it available for all .Net Core apps. The configuration is also done externally using filter arguments (the same way we configured the polling interval for the counters) which means any .Net Core app can be traced this way without doing any special configuration inside the app\u0027s code.\r\n2. [EventSourceLoggerProvider](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/logging/?view=aspnetcore-3.1#event-source-provider) - This converts ILogger messages into EventSource events and from 3.0 onwards it is enabled as a default provider in asp.net core apps. Similar to the DiagnosticSourceEventSource it can capture arbitrary ILogger messages and it can be configured externally using filter arguments.\r\n\r\nSorry about the FormattedMessage troubles but hope this info helps : )",
                                           "updatedAt":  "2020-02-27T20:22:14Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU5OTI2NDY3NQ==",
                                           "createdAt":  "2020-03-15T21:06:20Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "joacar",
                                           "body":  "Great post! I‘ve read it and intend to look into it in more detail and provide an answer to your proposals. I’ll mention another potential finding (so I won’t forget it my self) and it relates to ‘in’ parameter modifier passed to a method that in turns calls ‘WriteEvent’ with that parameter fails. I’ll provide a repro when I have the opportunity. \r\n\r\nThanks again for a great answer, really appreciate it and the great work put into .NET Core",
                                           "updatedAt":  "2020-03-15T21:06:20Z"
                                       }
                                   ],
                         "totalCount":  5
                     },
        "title":  "Can\u0027t see FormattedMessage for EventSource events in PerfView",
        "labels":  [
                       "question",
                       "area-Tracing-coreclr",
                       "feature-request"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/34137",
        "createdAt":  "2020-03-26T17:14:39Z",
        "number":  34137,
        "author":  "valco1994",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOA_yEfg==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "evgn",
                                            "createdAt":  "2020-04-01T12:14:02Z"
                                        }
                                    ],
                          "totalCount":  1
                      },
        "updatedAt":  "2025-09-12T00:21:09Z",
        "body":  "It was declared by `.NET` team (details can be found in several places, e.g. [here](https://lttng.org/blog/2018/08/28/bringing-dotnet-perf-analysis-to-linux/)), that `LTTng` had been chosen as a major tool for performance analysis on Linux. Even more, it was written that \r\n\r\n\u003e For every `ETW` event in `CoreCLR` we construct an `LTTng-UST` tracepoint when running on Linux, which means there\u0027s a complete one-to-one mapping between the two - whenever an `ETW` event is emitted, there\u0027s a corresponding `LTTng-UST` tracepoint.\r\n\r\n and \r\n\r\n\u003e ... the information that comes from the runtime is the same regardless of whether the code is executed on Windows or Linux.\r\n\r\nBy the way there is a `DotNETRuntime:CLRStackWalk` event in `CoreCLR`, which provides managed callstacks and, as far as I found, unexpectedly wasn\u0027t being emitted on Linux. Even more, code related to callstack manipulation and sending in [`src/coreclr/src/vm/eventtrace.cpp`](https://github.com/dotnet/runtime/blob/master/src/coreclr/src/vm/eventtrace.cpp) is conditionally compiled with the predicate `!HOST_UNIX`.\r\n\r\nAt the same time new `.NET Core` subsystem for performance analysis - `EventPipe` - successfully provides callstacks on Linux. And code related to callstack manipulation in [`src/coreclr/src/vm/eventpipe.cpp`](https://github.com/dotnet/runtime/blob/master/src/coreclr/src/vm/eventpipe.cpp) is written in a cross-platform manner. And there are also files [`stackcontents.h`](https://github.com/dotnet/runtime/blob/master/src/coreclr/src/vm/stackcontents.h), [`stackwalk.h`](https://github.com/dotnet/runtime/blob/master/src/coreclr/src/vm/stackwalk.h), [`stackwalk.cpp`](https://github.com/dotnet/runtime/blob/master/src/coreclr/src/vm/stackwalk.cpp) in the same directory, which relate to stackwalking but are not used by both subsystems.\r\n\r\nSo, I propose to:\r\n * reuse existing cross-platform code for stackwalking to generate CLRStackWalk event with `LTTng`\r\n * unify and put in the one place code related to stackwalking ",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOw69x-g==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDYwNDYyMjk1NA==",
                                           "createdAt":  "2020-03-26T18:57:46Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "hoyosjs",
                                           "body":  "@sywhang @josalem cc: @dotnet/dotnet-diag ",
                                           "updatedAt":  "2020-03-26T18:57:46Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDYwNDY3MjAyMg==",
                                           "createdAt":  "2020-03-26T20:37:14Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOA_SEcA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "josalem",
                                                                               "createdAt":  "2020-03-26T20:38:36Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "sywhang",
                                           "body":  "\u003e It was declared by .NET team (details can be found in several places, e.g. here), that LTTng had been chosen as a major tool for performance analysis on Linux.\r\n\r\nYes, and this is still true :) \r\n\r\n\u003e By the way there is a DotNETRuntime:CLRStackWalk event in CoreCLR, which provides managed callstacks and, as far as I found, unexpectedly wasn\u0027t being emitted on Linux.\r\n\r\nThe way managed callstacks get resolved in LTTng is different from the way they get resolved on EventPipe or Windows. To resolve callstacks in LTTng we use perf to get the stack (which includes both native and managed callstack). If I recall correctly I believe perf uses libunwind to get the callstack for each tracepoints. On top of this, since the OS doesn\u0027t know how to resolve jitted (managed) callstacks, the runtime emits a file that maps IPs to symbols for jitted code. This gets zipped into .trace.zip file that you see when you use perfcollect and PerfView is able to decode them into managed callstack. \r\n\r\n\u003e\u003e At the same time new .NET Core subsystem for performance analysis - EventPipe - successfully provides callstacks on Linux.\r\n\r\nYes, but only for managed. In fact, for callstack resolutions LTTng is ahead of EventPipe in the sense that it can provide both native and managed callstack. EventPipe can only understand managed callstack so when users want native callstack we point them to LTTng. \r\n\r\n\u003e reuse existing cross-platform code for stackwalking to generate CLRStackWalk event with LTTng\r\n\r\nAs explained above, this event isn\u0027t necessary to get managed code. \r\n\r\n\u003e unify and put in the one place code related to stackwalking\r\n\r\nThe runtime has many components that use stackwalking. In diagnostics space alone the profiler APIs and SampleProfiler which is used by EventPipe to get managed callstack both rely on stackwalking code. Both of them use the code you found (stalkwalk.cpp). ",
                                           "updatedAt":  "2020-03-26T20:37:14Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDYwNTAzMTAwMA==",
                                           "createdAt":  "2020-03-27T14:28:39Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOA_yElg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "evgn",
                                                                               "createdAt":  "2020-04-01T12:14:16Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "valco1994",
                                           "body":  "I had read about `perf` and `perfcollect` before writing this issue and, as far as I understand, they do not satisfy my requirements. It is important for me to have a callstack **corresponding**  to the event precisely. But `perf` can only sample callstacks with a specified frequency or provide them for **its** events.  And it doesn\u0027t know about LTTng events emitted by CoreCLR at all.\r\n\r\nIs it right? If there is a way to establish a correspondence between LTTng events and native callstacks collected by perf, it would be wonderful.\r\n\r\nNow about `DotNETRuntime:CLRStackWalk`. It’s the fact that in ETW it’s produced for every event which logically has associated stack. I mean this event: https://docs.microsoft.com/en-us/dotnet/framework/performance/stack-etw-event. And in such a case, I can establish a correspondence between other events and their callstacks. Furthermore, the absence of this event on Linux breaks promises about the one-to-one mapping between ETW-events on Windows and LTTng-events on Linux.\r\n",
                                           "updatedAt":  "2020-03-27T14:28:39Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDYwNjYwMDEzMQ==",
                                           "createdAt":  "2020-03-31T12:37:22Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "valco1994",
                                           "body":  "@sywhang @josalem, could you please comment on the situation taking into account the context clarified by me above?",
                                           "updatedAt":  "2020-03-31T12:37:22Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDYwNzE1NDA1MQ==",
                                           "createdAt":  "2020-04-01T09:57:11Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOA_yj0w==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "valco1994",
                                                                               "createdAt":  "2020-04-01T13:20:40Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "noahfalk",
                                           "body":  "Thanks for filing the issue @valco1994! Let me see if I can help move this along a bit...\r\n\r\n\u003e [@sywhang] To resolve callstacks in LTTng we use perf to get the stack (which includes both native and managed callstack)\r\n\r\nThis appears to conflate perfcollect with Lttng. Perfcollect is running both perf and lttng and each of them is producing a distinct set of events. @valco1994 is correct in noting that perf collects native callstacks for the events it generates but nothing is producing a callstack for the events which come from Lttng.\r\n\r\n\u003e So, I propose to:\r\nreuse existing cross-platform code for stackwalking to generate CLRStackWalk event with LTTng\r\n\r\nThe principle that we\u0027d have stackwalks for these events seems fine to me, but there are some details to sort out:\r\n\r\n1. EventPipe does not actually have callstacks for all events - rather it has callstacks for all events generated by managed EventSource calls and only a subset of the events that come directly from the runtime. If that is acceptable we can follow the same path, if you are looking for *all* runtime events to have a callstack then we would need to solve [this issue](https://github.com/dotnet/runtime/issues/12184)\r\n\r\n2. The existing stackwalker in stackwalk.cpp is also likely to have higher performance overhead than what [ETW was doing](https://github.com/dotnet/runtime/blob/master/src/coreclr/src/vm/eventtrace.cpp#L296). If your needs are a \u003c= a few thousand events/sec then it should be fine, above that and you will likely see the stackwalker consuming a non-trivial portion of CPU time.\r\n\r\n3. Is stack symbolication needed? The CLRStackwalk event emits a list of IPs as I recall and most scenarios want a set of IP-\u003ename mapping information to symbolicate it with. There are a few different ways symbolication can be done such as using the JIT events (assuming the trace was enabled at that point in time), with rundown events (what ETW  usually does), or with platform/tool specific techniques (what perf does). \r\n\r\n4. We\u0027d need to decide on the mechanism that turns stacks on/off.\r\n\r\n\u003e unify and put in the one place code related to stackwalking\r\n\r\nI am happy in principle with refactoring that lets Lttng and ETW share more of their stackwalking implementation but I might have reservations on specifics. I trust we could find something good and we probably don\u0027t need to dig into it until we\u0027ve resolved the requirements related questions above.\r\n\r\n\r\n@valco1994 given all your research were you interested in also implementing this feature or you are requesting Microsoft implements it? Either way is fine, though if it is request for us to handle it then we\u0027ll have to prioritize it against other requests. Right now we haven\u0027t heard from many customers in need of this so we\u0027d probably prioritize other work while leaving the issue open so that others can register their interest.",
                                           "updatedAt":  "2020-04-01T09:57:11Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDYwNzI0MjQ1OQ==",
                                           "createdAt":  "2020-04-01T13:16:04Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "valco1994",
                                           "body":  "Thanks for detailed answer @noahfalk!\r\n\r\nAs far as I understand, the limitations described by you are acceptable to me. Existing ways to do symbolication are also sufficient.\r\n\r\nProbably, a new environment variable can be added to turn stacks on/off, as well as it was done for turning on/off LTTng events producing with `COMPlus_EnableEventLog`.\r\n\r\nI am interested in implementing this feature but unfortunately have no time now (and don\u0027t know if I will have time in the foreseeable future). So, currently, I\u0027m requesting Microsoft to implement it.",
                                           "updatedAt":  "2020-04-01T13:16:04Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDYwNzYzMzU3NA==",
                                           "createdAt":  "2020-04-02T05:44:20Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "noahfalk",
                                           "body":  "\u003e I am interested in implementing this feature but unfortunately have no time now (and don\u0027t know if I will have time in the foreseeable future). So, currently, I\u0027m requesting Microsoft to implement it.\r\n\r\nSure thing. As mentioned we haven\u0027t heard of anyone else needing this right now so it wouldn\u0027t currently be a priority, but we\u0027ll leave the issue open and see if it gains more interest. And of course if you or anyone else wants to work on it I am happy to discuss next steps for putting together a PR. Thanks!",
                                           "updatedAt":  "2020-04-02T05:44:20Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc7Dr3H6",
                                           "createdAt":  "2025-09-12T00:21:08Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Due to lack of recent activity, this issue has been marked as a candidate for backlog cleanup.  It will be closed if no further activity occurs within 14 more days. Any new comment (by anyone, not necessarily the author) will undo this process.\n\nThis process is part of our [issue cleanup automation](https://github.com/dotnet/runtime/blob/main/docs/issue-cleanup.md).\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2025-09-12T00:21:08Z"
                                       }
                                   ],
                         "totalCount":  8
                     },
        "title":  "Callstacks for LTTng events",
        "labels":  [
                       "enhancement",
                       "area-Tracing-coreclr",
                       "tracking",
                       "no-recent-activity",
                       "backlog-cleanup-candidate"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/37382",
        "createdAt":  "2020-06-04T02:07:23Z",
        "number":  37382,
        "author":  "sywhang",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2021-06-03T17:46:50Z",
        "body":  "Before starting a counter session, it is not possible for a listener process to \"query\" for list of counters that are active on the target process.\r\n\r\nThis work item is to add an event that emits the list of counters that are currently active in a given process so that it is possible to query for this info. \r\n\r\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  null,
                         "nodes":  [

                                   ],
                         "totalCount":  0
                     },
        "title":  "Add an Event that defines list of counters",
        "labels":  [
                       "area-Tracing-coreclr",
                       "tracking",
                       "feature-request"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/37438",
        "createdAt":  "2020-06-04T19:02:46Z",
        "number":  37438,
        "author":  "josalem",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2022-05-18T13:25:16Z",
        "body":  "This was a pre-existing issue but since we are changing the code DiagnosticServer::Initialize and PauseForDiagnosticsMonitor should not be conditional on FEATURE_PERFTRACING. If that is going cascade into a bunch of refactoring feel free to track it with an issue instead of fixing it right away.\r\n\r\n_Originally posted by @noahfalk in https://github.com/dotnet/runtime/pull/36720_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  null,
                         "nodes":  [

                                   ],
                         "totalCount":  0
                     },
        "title":  "Refactor FEATURE flags for Diagnostics Server and EventPipe",
        "labels":  [
                       "enhancement",
                       "area-Tracing-coreclr",
                       "feature-request"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/38478",
        "createdAt":  "2020-06-26T22:24:57Z",
        "number":  38478,
        "author":  "noahfalk",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2022-05-18T13:26:33Z",
        "body":  "Repro:\r\n\r\n1. Write the following code in a .Net Core 3 console app:\r\n````\r\nusing System;\r\nusing System.Diagnostics.Tracing;\r\nusing System.Threading;\r\n\r\nnamespace ConsoleApp25\r\n{\r\n    class Program\r\n    {\r\n        static void Main(string[] args)\r\n        {\r\n            MyEventSource s = new MyEventSource();\r\n            MyEventListener l = new MyEventListener();\r\n            while (true)\r\n            {\r\n                s.HelloWorld(12);\r\n                Thread.Sleep(1000);\r\n            }\r\n        }\r\n    }\r\n\r\n    [EventSource(Name = \"Name\")]\r\n    public class MyEventSource : EventSource\r\n    {\r\n        public MyEventSource() : base(\"Name\") { }\r\n\r\n        internal bool TraceMacroExpansion { get; set; } = false;\r\n\r\n        [Event(1)]\r\n        public void HelloWorld(int arg)\r\n        {\r\n            WriteEvent(1, arg);\r\n        }\r\n    }\r\n\r\n    public class MyEventListener : EventListener\r\n    {\r\n        protected override void OnEventSourceCreated(EventSource eventSource)\r\n        {\r\n            if(eventSource.Name == \"Name\")\r\n            {\r\n                EnableEvents(eventSource, EventLevel.Informational);\r\n            }\r\n        }\r\n\r\n        protected override void OnEventWritten(EventWrittenEventArgs eventData)\r\n        {\r\n            Console.WriteLine(eventData.EventName);\r\n        }\r\n    }\r\n}\r\n````\r\n2. Run the app\r\nExpected behavior: Every second \"HelloWorld\" should be written to the console\r\nActual behavior: \"EventSourceMessage\" is written to the console once\r\n\r\n### Workaround\r\n\r\nIf you apply the [NonEvent] attribute to the getter and setter of the TraceMacroExpansion property like this:\r\n````C#\r\ninternal bool TraceMacroExpansion { [NonEvent] get; [NonEvent] set; } = false;\r\n````\r\nthen the code will run as expected\r\n\r\n### Underlying issue\r\n\r\nThe EventSource base class uses reflection to walk all methods on the derived type and it assumes that any method not marked with a [NonEvent] attribute represents an event. Properties are represented as a pair of methods (getter/setter) so they count too. For methods that don\u0027t specify an id using [Event(id)] attribute have an id auto-assigned and the auto-assignments start at 1. In this example the property getter is assigned id 1, then HelloWorld also claims to be id 1 and an error occurs because two methods are not both allowed to have the same id.\r\n\r\n### Suggested solution\r\n\r\nIt seems incredibly unlikely that anyone would write a property getter/setter in an EventSource with the intention that it should be treated as an Event. EventSource reflection logic could identify these methods and assume by default that they are not events.\r\n\r\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOKCWfzg==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY1MDQzMDQ4OA==",
                                           "createdAt":  "2020-06-26T22:24:59Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Dotnet-GitSync-Bot",
                                           "body":  "I couldn\u0027t figure out the best area label to add to this issue. If you have write-permissions please help me learn by adding exactly one [area label](https://github.com/dotnet/runtime/blob/master/docs/area-owners.md).",
                                           "updatedAt":  "2020-06-26T22:24:59Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY3MzU1NDM4Mg==",
                                           "createdAt":  "2020-08-13T15:44:20Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOBNX-Gg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "noahfalk",
                                                                               "createdAt":  "2020-08-14T08:22:32Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "KalleOlaviNiemitalo",
                                           "body":  "Could perhaps check [MethodBase.IsSpecialName](https://docs.microsoft.com/dotnet/api/system.reflection.methodbase.isspecialname?view=net-5.0) around here: \u003chttps://github.com/dotnet/runtime/blob/53976d38b1bd6917b8fa4d1dd4f009728ece3adb/src/libraries/System.Private.CoreLib/src/System/Diagnostics/Tracing/EventSource.cs#L3140-L3152\u003e\r\n\r\nThat would take care of property accessors and event accessors, at least in C#, and would be easier to implement and faster to run than enumerating all properties and events and their accessors.\r\n\r\nIf a method has the specialname attribute, then the name of the method probably doesn\u0027t make sense as the name of a a manifest event, anyway. If the developer still wants it to be a manifest event method, then they can add EventAttribute.\r\n\r\n\u003e In this example the property getter is assigned id 1\r\n\r\nThe property getter does not return `void` so it should already be excluded by default. The property setter passes that check, though.",
                                           "updatedAt":  "2020-08-13T15:44:20Z"
                                       }
                                   ],
                         "totalCount":  2
                     },
        "title":  "EventSource fails to create manifests when a property is added to the type",
        "labels":  [
                       "area-Tracing-coreclr",
                       "feature-request"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/42378",
        "createdAt":  "2020-09-17T11:16:40Z",
        "number":  42378,
        "author":  "valco1994",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-01-13T15:17:06Z",
        "body":  "As far as I see, currently, `EventPipe` only sends events from `Microsoft-Windows-DotNETRuntimeRundown` at the end of the session. So, I can receive `*DCEnd*` events with `EventPipe`, but can\u0027t receive `*DCStart*` events, which are supposed to be sent when the session started.\r\n\r\nIt means, that I can\u0027t resolve stacks in real-time with `EventPipe`, while with `ETW` I can choose to resolve it in real-time or during post-processing.\r\n\r\nCould you clarify, if it is a bug or it is supposed to be so by design and isn\u0027t going to be changed?\r\nIt would be very nice to have `*DCStart*` events with `EventPipe`.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOmjh60Q==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY5NDQyNzQxMA==",
                                           "createdAt":  "2020-09-17T18:45:02Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tommcdon",
                                           "body":  "@sywhang @josalem ",
                                           "updatedAt":  "2020-09-17T18:45:02Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY5NDQ0NTQ3MA==",
                                           "createdAt":  "2020-09-17T19:19:25Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "josalem",
                                           "body":  "One workaround is to start an EventPipe session with rundown enabled, then immediately end it to collect the rundown events at any point in time.\r\n\r\n---\r\n\r\nLooking at the code, we only invoke `ETW::EnumerationLog::EndRundown` in EventPipe (when a session ends).  I don\u0027t see any calls to `ETW::EnumerationLog::StartRuntdown` so, this is _currently_ by design, whether intentional or not.  This _is_, however, something we can change, but most likely not for 5.0.\r\n\r\nI think we could move/translate this chunk of code:\r\nhttps://github.com/dotnet/runtime/blob/f35d747e8d7fe44d7dab76b9683d7c642ec26888/src/coreclr/src/vm/eventtrace.cpp#L4662-L4683\r\nup a level, to here https://github.com/dotnet/runtime/blob/f35d747e8d7fe44d7dab76b9683d7c642ec26888/src/coreclr/src/vm/eventtrace.cpp#L4323.\r\n\r\nBetter yet, we could do a larger audit of these two functions to validate we aren\u0027t artificially preventing some functionality of EventPipe.  For now, this on our potential 6.0 backlog.",
                                           "updatedAt":  "2020-09-17T19:19:50Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY5NDg4OTQ4Ng==",
                                           "createdAt":  "2020-09-18T14:06:50Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "valco1994",
                                           "body":  "Thank you for the clarification, @josalem.\r\nI think this issue can be reclassified as a \"Feature request\" so.",
                                           "updatedAt":  "2020-09-18T14:06:50Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6aOHrR",
                                           "createdAt":  "2025-01-13T15:17:04Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "chrisnas",
                                           "body":  "\u003e One workaround is to start an EventPipe session with rundown enabled, then immediately end it to collect the rundown events at any point in time.\n\n@josalem: I tried it but it does not work and the next \"normal\" session seems to be blocked\n\n```\nvar client = new DiagnosticsClient(_processId);\nlong rundownKeywords = ((_filter \u0026 EventFilter.Contention) == EventFilter.Contention)\n    ? (long) (\n        ClrTraceEventParser.Keywords.Jit |\n        ClrTraceEventParser.Keywords.JittedMethodILToNativeMap |\n        ClrTraceEventParser.Keywords.Loader |\n        ClrTraceEventParser.Keywords.StartEnumeration  // This indicates to do the rundown now (at enable time)\n        )\n    : 0;\n\nif (rundownKeywords != 0)\n{\n    var configRundown = new EventPipeSessionConfiguration(GetProviders(), 256, rundownKeywords, true);\n    using (var session = client.StartEventPipeSession(configRundown))\n    {\n        var source = new EventPipeEventSource(session.EventStream);\n        _rundownParser = new ClrRundownTraceEventParser(source);\n        _rundownParser.MethodDCStopVerbose += OnMethodDetailsRundown;\n    }\n    session.Stop();\n    // events should be emitted now\n}\n\n// recreate a new session...\n```\n\nThis issue is problematic for tools trying to get symbolized call stacks BEFORE the end of the monitored application  :^(",
                                           "updatedAt":  "2025-01-13T15:17:04Z"
                                       }
                                   ],
                         "totalCount":  4
                     },
        "title":  "DCStart events from EventPipe",
        "labels":  [
                       "area-Tracing-coreclr",
                       "feature-request"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/43140",
        "createdAt":  "2020-10-07T14:42:42Z",
        "number":  43140,
        "author":  "kkokosa",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOCsFj7A==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "mhmd-azeez",
                                            "createdAt":  "2020-10-08T06:45:43Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "chrisnas",
                                            "createdAt":  "2020-10-08T06:50:27Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "dasMulli",
                                            "createdAt":  "2020-10-08T07:53:59Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "sywhang",
                                            "createdAt":  "2020-10-09T00:32:20Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "paulomorgado",
                                            "createdAt":  "2020-10-13T10:34:30Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "myarichuk",
                                            "createdAt":  "2021-06-04T09:19:56Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "xsoheilalizadeh",
                                            "createdAt":  "2023-01-03T09:00:08Z"
                                        }
                                    ],
                          "totalCount":  7
                      },
        "updatedAt":  "2022-06-28T15:11:17Z",
        "body":  "Currently `\"Working Set (MB)\"` is exposed via dotnet counters, which is totally fine. However, to have a full picture, wouldn\u0027t it be good to expose also \"Private Bytes\"?\r\n\r\nAdvantages:\r\n\r\n- memory leaks awareness - we could look at both RAM usage and RAM + swap/page usage. If there is some strange memory leak, we may notice it by constant growth of committed memory (like page file(s) growth). I know, most \"leaks\" will be covered by `GC Heap Size (MB)` or `# of Assemblies Loaded`, but exposing private bytes seems to be a perfect counterpart to the existing one\r\n- better picture of memory utilization - in various environments paging may be extensively influenced by other processes and looking only at Working Set may be misleading (sudden drops of WS in case of memory pressure etc.)\r\n\r\nDisadvantages:\r\n\r\n- overhead? I see [how `Environment.WorkingSet` is implemented on Unix](https://github.com/dotnet/runtime/blob/de6f9114a54587ea1c3e13c1aba2dbaff3c39fc5/src/libraries/System.Private.CoreLib/src/System/Environment.Unix.cs#L28-L45) and this is how probably \"private bytes\" would be implemented too.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOKimh6g==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcwNDk4NDMxNA==",
                                           "createdAt":  "2020-10-07T14:42:49Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Dotnet-GitSync-Bot",
                                           "body":  "I couldn\u0027t figure out the best area label to add to this issue. If you have write-permissions please help me learn by adding exactly one [area label](https://github.com/dotnet/runtime/blob/master/docs/area-owners.md).",
                                           "updatedAt":  "2020-10-07T14:42:49Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcwNTI4Mjc5NA==",
                                           "createdAt":  "2020-10-08T01:49:32Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "am11",
                                           "body":  "\u003e I see [how `Environment.WorkingSet` is implemented on Unix](https://github.com/dotnet/runtime/blob/de6f9114a54587ea1c3e13c1aba2dbaff3c39fc5/src/libraries/System.Private.CoreLib/src/System/Environment.Unix.cs#L28-L45) and this is how probably \"private bytes\" would be implemented too.\r\n\r\nPR is up to remove reflection from `WorkingSet`: #43154.",
                                           "updatedAt":  "2020-10-08T01:49:32Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcwNzM3MTQ5OA==",
                                           "createdAt":  "2020-10-12T22:12:58Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOBTSgmg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "kkokosa",
                                                                               "createdAt":  "2020-10-13T10:01:16Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "sywhang",
                                           "body":  "Thanks for the thoughtful suggestion @kkokosa! I do agree this can be useful to diagnose certain types of memory issues, since working set can sometimes be misleading (i.e. for apps that touch a lot of pages but is running in an environment with plenty of free space in the memory.) \r\n\r\nI can target this to be added as part of new runtime counters for .NET 6.0 release.\r\n\r\ncc @tommcdon @noahfalk",
                                           "updatedAt":  "2020-10-12T22:13:16Z"
                                       }
                                   ],
                         "totalCount":  3
                     },
        "title":  "Exposing \"Private bytes (MB)\" dotnet counter",
        "labels":  [
                       "area-Tracing-coreclr",
                       "feature-request"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/43390",
        "createdAt":  "2020-10-14T07:02:15Z",
        "number":  43390,
        "author":  "mjsabby",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOC55eNw==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "lambdageek",
                                            "createdAt":  "2020-10-14T14:48:37Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "SiamAbdullah",
                                            "createdAt":  "2020-10-15T05:14:11Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "HurricanKai",
                                            "createdAt":  "2020-10-15T07:01:37Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "strangeman375",
                                            "createdAt":  "2020-10-15T09:35:10Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "cgillum",
                                            "createdAt":  "2020-11-17T15:38:38Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "laurentksh",
                                            "createdAt":  "2020-11-27T12:52:38Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "dymo",
                                            "createdAt":  "2020-11-28T06:27:24Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "RyoukoKonpaku",
                                            "createdAt":  "2021-01-04T05:53:05Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Jure-BB",
                                            "createdAt":  "2022-08-16T08:58:01Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "xsoheilalizadeh",
                                            "createdAt":  "2022-11-16T08:35:28Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "allantargino",
                                            "createdAt":  "2022-12-21T13:58:54Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "ibebbs",
                                            "createdAt":  "2024-08-02T14:48:01Z"
                                        }
                                    ],
                          "totalCount":  12
                      },
        "updatedAt":  "2024-07-23T21:35:52Z",
        "body":  "EventSource is a common logging abstraction in .NET but it uses reflection to generate the schema for an EventSource definition. The source generator would do this at build time and make using EventSources reflection free.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOYinAhw==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcwODI0MTY4Mg==",
                                           "createdAt":  "2020-10-14T08:18:57Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "MichalStrehovsky",
                                           "body":  "EventSource used to have a hookup point for this that was used in .NET Native. It looked like this:\r\n\r\nhttps://github.com/dotnet/runtime/blob/dbcea6b29704b1f485e569f90ee1906809a03119/src/libraries/System.Private.CoreLib/src/System/Diagnostics/Tracing/EventSource.cs#L646-L663\r\n\r\nIt was nuked in the meantime (latest sources don\u0027t have it anymore).",
                                           "updatedAt":  "2020-10-14T08:18:57Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcyODk1MDQ2MQ==",
                                           "createdAt":  "2020-11-17T14:06:17Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOBbTa6w==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "AngelMunoz",
                                                                               "createdAt":  "2020-11-17T15:30:29Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "TonyHenrique",
                                                                               "createdAt":  "2020-11-17T15:48:31Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Szer",
                                                                               "createdAt":  "2020-11-18T15:26:16Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "LYP951018",
                                                                               "createdAt":  "2020-12-06T11:18:37Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "RyoukoKonpaku",
                                                                               "createdAt":  "2021-01-04T05:53:16Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  5
                                                         },
                                           "author":  "7sharp9",
                                           "body":  "How would this be consumed by non C# languages?",
                                           "updatedAt":  "2020-11-17T14:06:17Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc0MDMxMDA3OQ==",
                                           "createdAt":  "2020-12-08T02:00:04Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "benaadams",
                                           "body":  "\u003e How would this be consumed by non C# languages?\r\n\r\nIt would affect all the EventSources in the runtime and aspnet so all languages would get benefits (reduced startup; increased trimability etc)\r\n\r\n* ConcurrencyLimiterEventSource\r\n* HostingEventSource\r\n* KestrelEventSource\r\n* CertificateManagerEventSource\r\n* HttpConnectionsEventSource\r\n* LoggingEventSource\r\n* System.Net.NetEventSource\r\n* DependencyInjectionEventSource\r\n* CDSCollectionETWBCLProvider\r\n* DataCommonEventSource\r\n* DiagnosticSourceEventSource\r\n* PLINQETWProvider\r\n* HttpTelemetry\r\n* NameResolutionTelemetry\r\n* NetSecurityTelemetry\r\n* SocketsTelemetry\r\n* ArrayPoolEventSource\r\n* TplEventSource\r\n* FrameworkEventSource\r\n* NativeRuntimeEventSource\r\n* RuntimeEventSource\r\n* PortableThreadPoolEventSource\r\n* XmlSerializationEventSource\r\n* DataflowEtwProvider\r\n* ParallelETWProvider\r\n* TransactionsEtwProvider \r\n\r\nWhether or not you enable the EventSources they do a reflection based initialization step to see whether they are Enabled; which is expensive in startup.\r\n\r\nIt will also mean exposing runtime apis for EventSources that other languages can use if they also wish to implement similar source generators; or can manually use.",
                                           "updatedAt":  "2020-12-08T02:17:09Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc2ODQ2NzY3Ng==",
                                           "createdAt":  "2021-01-27T18:01:43Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOBd7QHQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "josalem",
                                                                               "createdAt":  "2021-01-27T18:15:37Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "vitek-karas",
                                           "body":  "\u003e How would this be consumed by non C# languages?\r\n\r\nOn top of the benefits with framework event sources mentioned by @benaadams, this could be used for any other event source as well.\r\n\r\nIf the API is exposed as public any language could be used to implement it. For the C# source generator to actually work it would need to be public anyway.\r\n\r\nThe C# source generator would make it easier (do it automatically), but it would still be possible to implement the same functionality manually in any other language.",
                                           "updatedAt":  "2021-01-27T18:01:43Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc5MTA3NjY1MQ==",
                                           "createdAt":  "2021-03-05T01:32:07Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "samsp-msft",
                                           "body":  "Dropping the priority as we don\u0027t have early AoT customers depending on it.",
                                           "updatedAt":  "2021-03-05T01:32:07Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc5NDgzOTI0OQ==",
                                           "createdAt":  "2021-03-10T04:06:05Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "benaadams",
                                           "body":  "A whole lot of startup going into generating EventSource manifests and Guids etc for a standardish ASP.NET Core app with ApplicationInsights, e.g. this is https://themesof.net/\r\n\r\n![image](https://user-images.githubusercontent.com/1142958/110574795-b4c5d780-8155-11eb-9678-6673ba7f6453.png)\r\n\r\nCouldn\u0027t fit it all on one screen, here\u0027s the rest\r\n\r\n![image](https://user-images.githubusercontent.com/1142958/110575503-de333300-8156-11eb-89a7-11de18878fb9.png)\r\n",
                                           "updatedAt":  "2021-03-10T04:14:36Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc5NDg3NDY0Nw==",
                                           "createdAt":  "2021-03-10T04:49:53Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "benaadams",
                                           "body":  "For https://themesof.net/ looks like 27 `EventSource`s are created on startup, most of them probably just to check `.Log.IsEnabled()` and get `false` back... 😅\r\n\r\nWith any not in `System.Private.CoreLib.dll` doing reflection to get the `Guid` to use\r\n\r\n![image](https://user-images.githubusercontent.com/1142958/110577951-a2e73300-815b-11eb-8141-c2671ac6fcff.png)",
                                           "updatedAt":  "2021-03-10T04:51:52Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc5NDg4OTUwNQ==",
                                           "createdAt":  "2021-03-10T05:07:46Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "iSazonov",
                                           "body":  "It is an issue for PowerShell startup too.",
                                           "updatedAt":  "2021-03-10T05:07:46Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5iKUoS",
                                           "createdAt":  "2023-07-23T15:44:26Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tommcdon",
                                           "body":  "@LakshanF @davmason do you know of any unresolved issues related to using EventSource on NativeAOT?",
                                           "updatedAt":  "2023-07-23T15:44:26Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5iKcCH",
                                           "createdAt":  "2023-07-23T17:47:22Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "LakshanF",
                                           "body":  "Any payload that uses complex data types in `EventSource`, that in turn depends on unbound reflection for serialization, will be problematic for `NativeAOT `applications (primarily due to trimming). The long-term solution is to use a source generator for such cases. These scenarios would cause both Roslyn analyzer (when the application project file indicate intention to use `NativeAOT`) and `ILCompiler` to generate warnings, and developers should not ignore these warnings. \r\n\r\nAll Framework `EventSource `providers should work without problems, as well as payloads with primitive data types.",
                                           "updatedAt":  "2023-07-23T17:47:22Z"
                                       }
                                   ],
                         "totalCount":  10
                     },
        "title":  "Developers can employ EventSource APIs when publishing for AOT targets to be able to use .NET tracing capabilities",
        "labels":  [
                       "area-Tracing-coreclr",
                       "feature-request",
                       "User Story",
                       "Priority:2",
                       "Team:Runtime"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/45059",
        "createdAt":  "2020-11-21T20:38:47Z",
        "number":  45059,
        "author":  "benaadams",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2023-03-24T14:12:52Z",
        "body":  "On startup `FrameworkEventSource` and `RuntimeEventSource`; while running on different threads, contend on `EventSource.Initialize` waiting for the DoCommand of the other to complete, so run sequentially (intermixed), also `PortableThreadPoolEventSource` and `ArrayPoolEventSource`:\r\n\r\n![image](https://user-images.githubusercontent.com/1142958/99895070-28170c80-2c7f-11eb-9bfb-2307f1a2ed24.png)\r\n\r\n\r\n![image](https://user-images.githubusercontent.com/1142958/99885671-b9aa5e00-2c2e-11eb-9cec-40e54e7cbfa7.png)\r\n\r\n/cc @stephentoub \r\n\r\nRelated to #44598 ",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOLHEoXw==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDczMTYzMzU2NQ==",
                                           "createdAt":  "2020-11-21T20:38:49Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Dotnet-GitSync-Bot",
                                           "body":  "I couldn\u0027t figure out the best area label to add to this issue. If you have write-permissions please help me learn by adding exactly one [area label](https://github.com/dotnet/runtime/blob/master/docs/area-owners.md).",
                                           "updatedAt":  "2020-11-21T20:38:49Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDczMTY5Nzc1OQ==",
                                           "createdAt":  "2020-11-22T04:45:18Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "benaadams",
                                           "body":  "Also `PortableThreadPoolEventSource` and `ArrayPoolEventSource` can collide forcing sequential initialization and waits on alternative threads",
                                           "updatedAt":  "2020-11-22T04:45:18Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDczMTY5ODQ2Ng==",
                                           "createdAt":  "2020-11-22T04:56:46Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "benaadams",
                                           "body":  "![image](https://user-images.githubusercontent.com/1142958/99895045-1d5c7780-2c7f-11eb-92d3-c2b4e9379e1a.png)\r\n",
                                           "updatedAt":  "2020-11-22T04:56:46Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDczMTY5OTc1NQ==",
                                           "createdAt":  "2020-11-22T05:14:56Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "benaadams",
                                           "body":  "`InitializeProviderMetadata` and `CreateManifestAndDescriptors` look to be the problematic methods called under a global lock as they are very reflection heavy",
                                           "updatedAt":  "2020-11-22T05:18:05Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDczMjM5NDg4Mg==",
                                           "createdAt":  "2020-11-23T20:02:39Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "josalem",
                                           "body":  "To be clear, you\u0027re talking about the `EventListenerLock`?\r\n\r\nhttps://github.com/dotnet/runtime/blob/78adc93ff9fed8d8c92f02fa77dbc9089f4c906b/src/libraries/System.Private.CoreLib/src/System/Diagnostics/Tracing/EventSource.cs#L1488-L1493\r\n\r\nhttps://github.com/dotnet/runtime/blob/78adc93ff9fed8d8c92f02fa77dbc9089f4c906b/src/libraries/System.Private.CoreLib/src/System/Diagnostics/Tracing/EventSource.cs#L1536-L1548\r\n\r\nThe lock is used for registration of providers with the `EventPipe`, `EventListener`, and `EventSource` infrastructure.  The generation of the manifest and descriptors isn\u0027t concurrency sensitive as far as I can recall.  Theoretically, we could always separate that generation step from the registration to minimize time under the lock.  The issue is that we shouldn\u0027t attempt to do that generation until we know the source is going to be used, which is what leads to it being done on registration.\r\n\r\nhttps://github.com/dotnet/runtime/blob/78adc93ff9fed8d8c92f02fa77dbc9089f4c906b/src/libraries/System.Private.CoreLib/src/System/Diagnostics/Tracing/EventSource.cs#L2603\r\n\r\nThe generation logic seems like a prime candidate for source generation at compile time.\r\n\r\nThat being said, there should only be deferred commands for an `EventSource` (the trigger for calling `DoCommand` under a lock in `Initialize`) if it is requested to be enabled _before_ `Initialize` in its constructor is called.  If you _don\u0027t_ enable those providers, you shouldn\u0027t pay the penalty for generating their manifest/descriptors on construction or get into this serialization situation.  Are you enabling those providers when you collect this data?\r\n\r\nCC @sywhang @noahfalk ",
                                           "updatedAt":  "2020-11-23T20:02:39Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDczMjQwNTI0Nw==",
                                           "createdAt":  "2020-11-23T20:23:05Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "benaadams",
                                           "body":  "`PortableThreadPoolEventSource` always seems to have a couple updates to send (on Windows) even if I\u0027m just running at command line (added a Console.WriteLine to check) /cc @kouvel \r\n\r\nThat causes the manifest to be generated; and its generation uses ArrayPool, which calls `ArrayPoolEventSource.Log` to check if its enabled which then causes initialization of the `ArrayPoolEventSource` which blocks because it needs the same `EventListenersLock` lock that the `DoCommands` in the other `Initalize` is using which is what you see here:\r\n\r\n![image](https://user-images.githubusercontent.com/1142958/99895045-1d5c7780-2c7f-11eb-92d3-c2b4e9379e1a.png)\r\n\r\n`EventSource.Initalize` does grab and release the global `EventListenersLock` lock 3 times:\r\n1. For `eventPipeProvider.Register(this);`\r\n2. Inside `EventListener.AddEventSource(this);`\r\n3. For handling the `deferredCommands` (which then triggers the lengthy Manifest generation)\r\n\r\n\r\n",
                                           "updatedAt":  "2020-11-23T20:23:05Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDczMjQxMDQ0Nw==",
                                           "createdAt":  "2020-11-23T20:33:12Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "josalem",
                                           "body":  "Cases 1 and 2 shouldn\u0027t be too expensive, but 3 certainly can be due to the reflection required to generate the data.\r\n\r\nI find it curious that these providers have deferred commands without being explicitly enabled.  Do you observe this on non-Windows platforms?  I\u0027m wondering if ETW requests the manifest for all providers that register themselves.  That would cause case 3 to fire every time for every `EventSource` on Windows even if the source isn\u0027t enabled by the user.",
                                           "updatedAt":  "2020-11-23T20:33:12Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDczMjQ2MjI5MA==",
                                           "createdAt":  "2020-11-23T22:27:31Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "josalem",
                                           "body":  "Another thought: That UI looks like dotTrace.  It\u0027s possible that dotTrace specifically uses the ThreadPool event source.",
                                           "updatedAt":  "2020-11-23T22:27:31Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDczOTU3OTE5OQ==",
                                           "createdAt":  "2020-12-06T22:55:11Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "benaadams",
                                           "body":  "EtwEventRegister is triggering the command\r\n\r\n![image](https://user-images.githubusercontent.com/1142958/101295325-de006000-3814-11eb-8030-01b7d15b6531.png)\r\n\r\nNot sure why it only seems to be `PortableThreadPoolEventSource` and not `RuntimeEventSource` or `NativeRuntimeEventSource`\r\n\r\n![image](https://user-images.githubusercontent.com/1142958/101295484-d8efe080-3815-11eb-9a5d-cb598bfab043.png)\r\n\r\nPerhaps because it shares the same Guid and Name as `NativeRuntimeEventSource`; so its the second registration?",
                                           "updatedAt":  "2020-12-06T22:55:11Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc0MjE0ODk3Ng==",
                                           "createdAt":  "2020-12-10T00:24:05Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tommcdon",
                                           "body":  "Related to #45518",
                                           "updatedAt":  "2020-12-10T00:24:05Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc0MzA4ODc0MQ==",
                                           "createdAt":  "2020-12-11T09:40:46Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "kouvel",
                                           "body":  "After https://github.com/dotnet/runtime/pull/45901 the `PortableThreadPoolEventSource` would not be used during startup unless the thread pool is used by the user\u0027s startup code. It was being used by tiered compilation.\r\n\r\nI\u0027m not sure if `NativeRuntimeEventSource` is being used on this path. There is a work item to move events from `PortableThreadPoolEventSource` into `NativeRuntimeEventSource` and use the latter instead, but I suspect the manifest generation issue would not go away just from that.",
                                           "updatedAt":  "2020-12-11T09:40:46Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc0MzE3NDIwNQ==",
                                           "createdAt":  "2020-12-11T12:48:48Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "benaadams",
                                           "body":  "I haven\u0027t worked out why `PortableThreadPoolEventSource` gets triggered for the manifest generation and `NativeRuntimeEventSource` doesn\u0027t as they both seem to do the same startup and same flags etc",
                                           "updatedAt":  "2020-12-11T12:48:48Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc0MzE4MzYyMw==",
                                           "createdAt":  "2020-12-11T13:09:29Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "kouvel",
                                           "body":  "Can you share a code sample to repro this? I\u0027m curious how `NativeRuntimeEventSource` is being used during startup. Last I checked (which was a while back) it didn\u0027t have any events of its own, so I don\u0027t yet see how it would be used.",
                                           "updatedAt":  "2020-12-11T13:09:29Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc0MzE5Njg5Nw==",
                                           "createdAt":  "2020-12-11T13:37:42Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "benaadams",
                                           "body":  "\u003e Can you share a code sample to repro this? I\u0027m curious how `NativeRuntimeEventSource` is being used during startup. \r\n\r\nHappens with a `Console.WriteLine(\"Hello world\")` app on Windows\r\n\r\n`NativeRuntimeEventSource` gets created by `EventSource` .cctor\r\n\r\nhttps://github.com/dotnet/runtime/blob/574e6259ab0d26cf97c0eca07c8b08948018b07b/src/libraries/System.Private.CoreLib/src/System/Diagnostics/Tracing/EventSource.cs#L3760-L3767\r\n\r\nWhich is triggered by `RuntimeEventSource` being initialized in `StartupHookProvider.ProcessStartupHooks`\r\n\r\nhttps://github.com/dotnet/runtime/blob/07664ad036ceb395a2f2f2736d2e781dbb6b4dac/src/coreclr/System.Private.CoreLib/src/System/StartupHookProvider.cs#L29-L35\r\n\r\n![image](https://user-images.githubusercontent.com/1142958/101909304-32a92f80-3bb5-11eb-89c8-baa740a3e079.png)\r\n",
                                           "updatedAt":  "2020-12-11T13:37:42Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc0MzIwMTQ1Ng==",
                                           "createdAt":  "2020-12-11T13:47:22Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "benaadams",
                                           "body":  "Doesn\u0027t explain why the `PortableThreadPoolEventSource` Etw registration triggers an immediate `OnControllerCommand` callback which then causes the manifest to be generated; but the `RuntimeEventSource` and `NativeRuntimeEventSource` Etw registrations don\u0027t\r\n\r\n![image](https://user-images.githubusercontent.com/1142958/101910620-17d7ba80-3bb7-11eb-8700-0f8f65f7ba5a.png)\r\n",
                                           "updatedAt":  "2020-12-11T13:47:22Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc0MzIwNTg3MA==",
                                           "createdAt":  "2020-12-11T13:56:41Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "benaadams",
                                           "body":  "The only difference I can see is Etw `SetInformation` is called *after* the Etw `EventRegister`\r\n\r\nhttps://github.com/dotnet/runtime/blob/07664ad036ceb395a2f2f2736d2e781dbb6b4dac/src/libraries/System.Private.CoreLib/src/System/Diagnostics/Tracing/EventSource.cs#L1511-L1516\r\n\r\nSo when `NativeRuntimeEventSource` does its register; `SetInformation` has not been called for that name/guid; however when `PortableThreadPoolEventSource` calls the `EventRegister` `NativeRuntimeEventSource` has already called Etw `SetInformation` for that name/guid (as they share the same one), so it triggers the callback?",
                                           "updatedAt":  "2020-12-11T13:56:41Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc0MzIwNzk2Mw==",
                                           "createdAt":  "2020-12-11T14:00:42Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "kouvel",
                                           "body":  "I\u0027ll defer to the experts on this, perhaps it has something to do with the double-registration, which wouldn\u0027t happen after the consolidation work item is done. I don\u0027t know the details about what kind of side effects may occur as a result of the current situation. It does look troubling though.",
                                           "updatedAt":  "2020-12-11T14:00:42Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc0MzQzNjY5OA==",
                                           "createdAt":  "2020-12-11T21:29:57Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "benaadams",
                                           "body":  "Added PR to merge the two https://github.com/dotnet/runtime/pull/45974 does look to stop the manifest generation (though may also be the change to not use it for tiering)",
                                           "updatedAt":  "2020-12-11T21:29:57Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc0MzQ1MDAzOQ==",
                                           "createdAt":  "2020-12-11T22:02:12Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "benaadams",
                                           "body":  "Looks like the ThreadPool is still being used; whether or not user code uses it, so avoiding double registration does look like the fix for the manifest generation\r\n\r\n![image](https://user-images.githubusercontent.com/1142958/101958402-23e56b80-3bfb-11eb-83e0-5fa0b82d53c2.png)\r\n\r\n\r\nGets set up by a call to `UnsafeQueueUnmanagedWorkItem` from `ThreadpoolMgr::TimerThreadStart`\r\n\r\n![image](https://user-images.githubusercontent.com/1142958/101959060-825f1980-3bfc-11eb-8840-dc9fb37a6df3.png)\r\n",
                                           "updatedAt":  "2020-12-11T22:02:12Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc0MzQ1NjcwMg==",
                                           "createdAt":  "2020-12-11T22:18:34Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "kouvel",
                                           "body":  "Yea that\u0027s the path that tiering uses. I haven\u0027t looked at the PR yet, but my understanding was that there were some other issues that needed to be resolved in order to be able to merge those event sources, otherwise we would not get thread pool events, or there would be other issues.",
                                           "updatedAt":  "2020-12-11T22:24:10Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc0MzkxNzg0Mg==",
                                           "createdAt":  "2020-12-12T23:06:56Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "benaadams",
                                           "body":  "Hmm... I\u0027ve clearly got something on my machine that\u0027s pre-registered for the portable threadpool (native eventsource)\u0027s Guid; when I switch of all the Jetbrains stuff including the ETW Host Service its still triggering; so not sure what it is",
                                           "updatedAt":  "2020-12-12T23:06:56Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc0MzkxODE3MQ==",
                                           "createdAt":  "2020-12-12T23:10:51Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "kouvel",
                                           "body":  "I noticed before that VS enables some providers when it\u0027s open",
                                           "updatedAt":  "2020-12-12T23:10:51Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc0MzkxODIwOA==",
                                           "createdAt":  "2020-12-12T23:11:09Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOBZyTEw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "benaadams",
                                                                               "createdAt":  "2020-12-12T23:41:56Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "kouvel",
                                                                               "createdAt":  "2020-12-12T23:45:48Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "josalem",
                                           "body":  "You can check what\u0027s creating ETW sessions using `tracelog -l -lp \u003e etw.log` (`-l` -\u003e list sessions, `-lp` -\u003e list providers on those sessions).  That ought to tell you if there are any sessions open.\r\n\r\n[docs for `tracelog`](https://docs.microsoft.com/en-us/windows-hardware/drivers/devtest/tracelog-command-syntax)",
                                           "updatedAt":  "2020-12-12T23:11:38Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc0MzkyMTAyMg==",
                                           "createdAt":  "2020-12-12T23:41:45Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "benaadams",
                                           "body":  "\u003e I noticed before that VS enables some providers when it\u0027s open\r\n\r\nYep; looks like just having VS open on a project will register it for verbose\r\n```\r\nLogger Name:            Microsoft-VisualStudio-Telemetry-PerfWatson2-16356\r\nLogger Id:              0x1d\r\nLogger Thread Id:       000000000000421C\r\nGuid:                   522e1583-3cbe-11eb-ad29-982cbc21eb61\r\nSession Security:       ...\r\nBuffer Size:            512 Kb\r\nMaximum Buffers:        160\r\nMinimum Buffers:        40\r\nNumber of Buffers:      40\r\nFree Buffers:           34\r\nBuffers Written:        162\r\nEvents Lost:            0\r\nLog Buffers Lost:       0\r\nReal Time Buffers Lost: 0\r\nReal Time Consumers:    1\r\nClockType:              PerfCounter\r\nLog Mode:               Sequential Realtime \r\nHybrid Shutdown:        Stop\r\nMaximum File Size:      not set\r\nBuffer Flush Timer:     1 secs\r\nLog Filename:           \r\n\r\nEnabled Providers:\r\nGuid                                  Level  Flags               Enable Properties\r\n----------------------------------------------------------------------------------\r\n641d7f6c-481c-42e8-ab7e-d18dc5e5cb9e      5  0xffffffffffffffff  EnableKeywordZero \r\n4e17e413-3c0c-4c2a-a531-c1799a05ad7c      5  0x0000000000000067  EnableKeywordZero \r\ne13c0d23-ccbc-4e12-931b-d9cc2eee27e4      5  0x0000000000000099  EnableKeywordZero \r\n589491ba-4f15-53fe-c376-db7f020f5204      5  0xffffffffffffffff  EnableKeywordZero \r\na669021c-c450-4609-a035-5af59af4df18      5  0x0000000000000098  EnableKeywordZero \r\nee328c6f-4c94-45f7-acaf-640c6a447654      5  0x0000000000000004  EnableKeywordZero \r\nTotal of 6 providers\r\n```\r\n\r\n3rd provider `e13c0d23-ccbc-4e12-931b-d9cc2eee27e4`",
                                           "updatedAt":  "2020-12-12T23:41:45Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc0MzkyMTI2Mw==",
                                           "createdAt":  "2020-12-12T23:44:42Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOBaWzBw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "josalem",
                                                                               "createdAt":  "2020-12-15T18:08:04Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "tommcdon",
                                                                               "createdAt":  "2020-12-17T19:38:35Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "benaadams",
                                           "body":  "Suppose that still counts as \"part of a developer\u0027s inner loop development process\" for https://github.com/dotnet/runtime/issues/44598 😅\r\n\r\n#amirite",
                                           "updatedAt":  "2020-12-12T23:44:42Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc0NTQ2NzU4NA==",
                                           "createdAt":  "2020-12-15T18:08:05Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "josalem",
                                           "body":  "That makes sense.  I\u0027m curious if we observe the slowdown without VS open or on non-Windows platforms where we don\u0027t register with a system-wide tracing service.\r\n\r\nCC @karpinsn",
                                           "updatedAt":  "2020-12-15T18:08:05Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc0NTYxMzQwNw==",
                                           "createdAt":  "2020-12-15T22:42:17Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOBbX9IA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "josalem",
                                                                               "createdAt":  "2021-01-04T18:01:54Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "benaadams",
                                           "body":  "Note this is from just having VS open; running an app in VS also attaches 2 more listeners to the EventSource; so 3 listeners in total from VS\r\n```\r\nLogger Name:            DiagHubEtwSession.16.0492B62A-A2B9-4B93-BCC6-ADA193F84587.1.user_paged\r\n\r\nGuid                                  Level  Flags               Enable Properties\r\n----------------------------------------------------------------------------------\r\ne13c0d23-ccbc-4e12-931b-d9cc2eee27e4      4  0x0000000000000001  EnableKeywordZero \r\n```\r\n```\r\nLogger Name:            DiagHubEtwSession.16.A471A57C-135D-4BEA-B550-F9A1768249CF.1.user_paged\r\n\r\nGuid                                  Level  Flags               Enable Properties\r\n----------------------------------------------------------------------------------\r\ne13c0d23-ccbc-4e12-931b-d9cc2eee27e4      4  0x0000000100000000  EnableKeywordZero \r\n```\r\n\r\n\u003e I\u0027m curious if we observe the slowdown without VS open\r\n\r\nNo; hence my inconsistent results on \"fixing\" the issue, it was more to do with if I had VS open when profiling or using `Console.WriteLine` to see if it was triggered by profiler.\r\n\r\n\u003e or on non-Windows platforms\r\n\r\nIs only triggered by default from the `EtwEventProvider.EventRegister` causing the callback (due to pre-registration by VS) so don\u0027t think so unless you are subscribing to the events; however it does always trigger manifest generation on the first `DoCommand` regardless of whether than is an Enable or `SendManifest` event as its tied up with the `EnsureDescriptorsInitialized` code that happens at the start.\r\n\r\nOTOH `InitializeProviderMetadata` does always get triggered when checking `.Log.Enabled()` which then Jits and initializes all `Encoding.UTF8`\u0027s stuff; but that\u0027s resolved by the source generator PR https://github.com/dotnet/runtime/pull/45699\r\n\r\nUsing the EventSources https://github.com/dotnet/runtime/issues/43390 would still trigger the issue with manifest generation unless they were changed to SelfDescribing (though the ManifestBuilder would still be populated in `EnsureDescriptorsInitialized`); but what the different types of event source modes are and what impact changing them would have is beyond my knowledge.\r\n\r\nThe reason why consolidating `NativeRuntimeEventSource` and `PortableThreadPoolEventSource` stopped the Manifest generation is because `NativeRuntimeEventSource` already has an on disk manifest it uses (and probably sends instead?), so merging them isn\u0027t as straightforward https://github.com/dotnet/runtime/pull/45974#issuecomment-743793332",
                                           "updatedAt":  "2020-12-15T22:42:17Z"
                                       }
                                   ],
                         "totalCount":  27
                     },
        "title":  "Does locking for EventSource.DoCommand need to be a global lock?",
        "labels":  [
                       "tenet-performance",
                       "area-Tracing-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/45466",
        "createdAt":  "2020-12-02T07:45:23Z",
        "number":  45466,
        "author":  "iSazonov",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2022-05-18T13:25:17Z",
        "body":  "\u003c!--This is just a template - feel free to delete any and all of it and replace as appropriate.--\u003e\r\n\r\n### Description\r\n\r\nRelated #44598\r\nI measured PowerShell startup scenario with `pwsh -c exit` (really start-stop scenario).\r\nOne delay in the scenario is in AssemblyLoadContext.StartAssemblyLoad() called from hostpolicy - 59 ms (10%).\r\n\r\n![image](https://user-images.githubusercontent.com/22290914/100843299-fa5e6e80-349b-11eb-862c-fa54e8c73371.png)\r\n\r\n\r\nThe StartAssemblyLoad() initializes tracing\r\nhttps://github.com/dotnet/runtime/blob/191ea066b157103d6332b2cf3e986b055fda3bcd/src/coreclr/src/System.Private.CoreLib/src/System/Runtime/Loader/AssemblyLoadContext.CoreCLR.cs#L199-L206\r\n\r\nEspecially the slow System.Threading.Tasks.TplEventSource..cctor () - 49 ms (8.5%).\r\n(And System.Diagnostics.Tracing.NativeRuntimeEventSource..cctor() too)\r\n\r\n![image](https://user-images.githubusercontent.com/22290914/100842695-0bf34680-349b-11eb-81f7-78507d8388c1.png)\r\n\r\nWe can\u0027t seem to improve this in PowerShell and I hope it will be improved in .Net in some way. Perhaps it is possible to postpone the initialization or make it async. \r\n\r\n\r\n### Configuration\r\n\r\nUsed PowerShell 7.2 Preview.1 based on .Net 5.0.\r\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOLDxKzA==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDczNzA1NTQzNA==",
                                           "createdAt":  "2020-12-02T07:45:27Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @vitek-karas, @agocke, @coffeeflux\nSee info in area-owners.md if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n\u003c!--This is just a template - feel free to delete any and all of it and replace as appropriate.--\u003e\r\n\r\n### Description\r\n\r\nRelated #44598\r\nI measured PowerShell startup scenario with `pwsh -c exit` (really start-stop scenario).\r\nOne delay in the scenario is in AssemblyLoadContext.StartAssemblyLoad() called from hostpolicy - 59 ms (10%).\r\n\r\n![image](https://user-images.githubusercontent.com/22290914/100843299-fa5e6e80-349b-11eb-862c-fa54e8c73371.png)\r\n\r\n\r\nThe StartAssemblyLoad() initializes tracing\r\nhttps://github.com/dotnet/runtime/blob/191ea066b157103d6332b2cf3e986b055fda3bcd/src/coreclr/src/System.Private.CoreLib/src/System/Runtime/Loader/AssemblyLoadContext.CoreCLR.cs#L199-L206\r\n\r\nEspecially the slow System.Threading.Tasks.TplEventSource..cctor () - 49 ms (8.5%).\r\n(And System.Diagnostics.Tracing.NativeRuntimeEventSource..cctor() too)\r\n\r\n![image](https://user-images.githubusercontent.com/22290914/100842695-0bf34680-349b-11eb-81f7-78507d8388c1.png)\r\n\r\nWe can\u0027t seem to improve this in PowerShell and I hope it will be improved in .Net in some way. Perhaps it is possible to postpone the initialization or make it async. \r\n\r\n\r\n### Configuration\r\n\r\nUsed PowerShell 7.2 Preview.1 based on .Net 5.0.\r\n\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eiSazonov\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-AssemblyLoader-coreclr`, `tenet-performance`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2020-12-02T07:45:27Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDczNzA2NzcwMA==",
                                           "createdAt":  "2020-12-02T08:13:18Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "EventSource construction is relatively expensive reflection heavy operation today.\r\n\r\nThe ultimate way to fix this overhead is to replace the reflection with source generators: https://github.com/dotnet/runtime/issues/43390",
                                           "updatedAt":  "2020-12-02T08:13:18Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDczNzE4OTUxMw==",
                                           "createdAt":  "2020-12-02T12:07:30Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "iSazonov",
                                           "body":  "\u003e EventSource construction is relatively expensive reflection heavy operation today.\r\n\u003e \r\n\u003e The ultimate way to fix this overhead is to replace the reflection with source generators: #43390\r\n\r\nIn the my trace for startup scenario it seems a reflection calls take \u003c0.8% but System.Resources.ResourceManager.GetString() 1.2%.\r\nI doubt that generators will help in this scenario. \r\nIf this initialization cannot be postponed, then most likely it is necessary to improve a little bit of all parts\r\n/cc @adamsitnik \r\n\r\n",
                                           "updatedAt":  "2020-12-02T12:07:30Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc0MDIwMDcwOQ==",
                                           "createdAt":  "2020-12-07T21:49:52Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tommcdon",
                                           "body":  "@josalem ",
                                           "updatedAt":  "2020-12-07T21:49:52Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc0MDMwMjgzMQ==",
                                           "createdAt":  "2020-12-08T01:36:47Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOBZMN5g==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "josalem",
                                                                               "createdAt":  "2020-12-08T01:44:14Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "benaadams",
                                           "body":  "\u003e In the my trace for startup scenario it seems a reflection calls take \u003c0.8% but System.Resources.ResourceManager.GetString() 1.2%.\r\n\r\nLooking at the stacktrace It\u0027s the manifest generation; `System.Resources.ResourceManager.GetString` is being called as the `TplEventSource` has a translatable manifest.\r\n\r\nSource generators should still help here.",
                                           "updatedAt":  "2020-12-08T01:36:47Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc0MjE0ODgxMg==",
                                           "createdAt":  "2020-12-10T00:23:42Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tommcdon",
                                           "body":  "Related to #45518",
                                           "updatedAt":  "2020-12-10T00:23:42Z"
                                       }
                                   ],
                         "totalCount":  6
                     },
        "title":  "Slow AssemblyLoadContext.StartAssemblyLoad() at startup",
        "labels":  [
                       "enhancement",
                       "tenet-performance",
                       "area-Tracing-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/47061",
        "createdAt":  "2021-01-15T21:52:48Z",
        "number":  47061,
        "author":  "sywhang",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2021-06-03T17:46:53Z",
        "body":  "If EventSourceSupport feature switch is turned off and EventSource is trimmed, external diagnostic tools can run into issues when trying to consume events from EventSource. This issue tracks the work to make this issue more diagnosable by adding a command in diagnostics server to check if the target app is running with trimmed EventSource. \r\n\r\ncc @LakshanF  ",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOL6qSfw==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc5OTcwNzc3NQ==",
                                           "createdAt":  "2021-03-15T19:53:09Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "LakshanF",
                                           "body":  "From a team discussion related to #43657",
                                           "updatedAt":  "2021-03-15T19:53:09Z"
                                       }
                                   ],
                         "totalCount":  1
                     },
        "title":  "Add diagnostic server command to detect EventSourceSupport feature switch",
        "labels":  [
                       "area-Tracing-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/47062",
        "createdAt":  "2021-01-15T21:56:23Z",
        "number":  47062,
        "author":  "sywhang",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2021-06-03T17:46:54Z",
        "body":  "Related: https://github.com/dotnet/runtime/issues/47061\r\n\r\nFor ETW/LTTng scenarios - if EventSourceSwitch is turned off, tools that relies on OS-specific tracing mechanisms like ETW/LTTng can\u0027t use diagnostics server command to detect that EventSourceSwitch is turned off for a target app. \r\n\r\nThis issue tracks work for adding a runtime event under the Microsoft-Windows-DotNETRuntime provider that always fires when EventSourceSwitch is turned off.\r\n\r\n cc @LakshanF ",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOL6qRSA==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc5OTcwNzQ2NA==",
                                           "createdAt":  "2021-03-15T19:52:44Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "LakshanF",
                                           "body":  "From a team discussion related to #43657",
                                           "updatedAt":  "2021-03-15T19:52:44Z"
                                       }
                                   ],
                         "totalCount":  1
                     },
        "title":  "Add a runtime event for detecting EventSourceSwitch turned off",
        "labels":  [
                       "area-Tracing-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/47627",
        "createdAt":  "2021-01-29T13:37:41Z",
        "number":  47627,
        "author":  "janvorli",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2024-06-28T19:39:31Z",
        "body":  "This test always fails in my local coreclr test runs on Linux and macOS:\r\n```\r\n  0.0s: ==TEST STARTING==\r\n  1.1s: Started sending sentinel events...\r\n  1.1s: Connecting to EventPipe...\r\n  1.4s: Connected to EventPipe with sessionID \u00270x7fb320008de0\u0027\r\n  1.4s: Creating EventPipeEventSource...\r\n  1.5s: EventPipeEventSource created\r\n  1.5s: Dynamic.All callback registered\r\n  1.5s: Running optional trace validator\r\n  1.5s: Finished running optional trace validator\r\n  1.5s: Starting stream processing...\r\n  1.8s: Saw sentinel event\r\n  1.8s: Stopped sending sentinel events\r\n  1.8s: Starting event generating action...\r\n  1.8s: Stopping event generating action\r\n  1.8s: Sending StopTracing command...\r\n  1.9s: Saw new provider \u0027IllegalTypesEventSource\u0027\r\n  1.9s: Saw new provider \u0027Microsoft-DotNETCore-EventPipe\u0027\r\n  1.9s: Saw new provider \u0027Microsoft-Windows-DotNETRuntimeRundown\u0027\r\n  1.9s: Saw new provider \u0027Microsoft-Windows-DotNETRuntime\u0027\r\n  1.9s: Finished StopTracing command\r\n  1.9s: Stopping stream processing\r\n  1.9s: Dropped 0 events\r\n  1.9s: Reader task finished\r\n  1.9s: Test FAILED!\r\n  1.9s: Event count mismatch for provider \"IllegalTypesEventSource\": expected 1 +- 0, but saw 2\r\n  1.9s: Configuration:\r\n  1.9s: {\r\n  1.9s: bufferSize: 1024,\r\n  1.9s: providers: [\r\n  1.9s: IllegalTypesEventSource:0xFFFFFFFFFFFFFFFF:5,\r\n  1.9s: SentinelEventSource:0xFFFFFFFFFFFFFFFF:5,\r\n  1.9s: ]\r\n  1.9s: }\r\n\r\n  1.9s: Expected:\r\n  1.9s: {\r\n  1.9s: \"IllegalTypesEventSource\" = 1 +- 0\r\n  1.9s: }\r\n\r\n  1.9s: Actual:\r\n  1.9s: {\r\n  1.9s: \"IllegalTypesEventSource\" = 2\r\n  1.9s: \"Microsoft-DotNETCore-EventPipe\" = 1\r\n  1.9s: \"Microsoft-Windows-DotNETRuntimeRundown\" = 3628\r\n  1.9s: \"Microsoft-Windows-DotNETRuntime\" = 4\r\n  1.9s: }\r\n  1.9s: ==TEST FINISHED: FAILED!==\r\n```\r\n\r\nIt seems that similar to #47625, the `Microsoft-Windows-DotNETRuntime*` events are not expected by the test",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOgvuEKg==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc2OTgwOTc4MA==",
                                           "createdAt":  "2021-01-29T13:38:02Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "janvorli",
                                           "body":  "cc: @dotnet/dotnet-diag ",
                                           "updatedAt":  "2021-01-29T13:38:02Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc2OTk2NzgzNA==",
                                           "createdAt":  "2021-01-29T18:18:37Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "josalem",
                                           "body":  "Interesting.  As far as I\u0027m aware, this isn\u0027t failing in CI or PR validation.\r\n\r\n@janvorli did this start recently or has this been ongoing?",
                                           "updatedAt":  "2021-01-29T18:18:37Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc3MDA1MTk5OA==",
                                           "createdAt":  "2021-01-29T21:10:45Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "janvorli",
                                           "body":  "@josalem this has been failing like this for quite some time, I don\u0027t know when it started, but it has been at least a month, maybe more.",
                                           "updatedAt":  "2021-01-29T21:10:45Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc3MDA1MzMzOQ==",
                                           "createdAt":  "2021-01-29T21:13:54Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "janvorli",
                                           "body":  "And it is failing on all of my machines, including the new mac M1 in both Rosetta 2 and arm64 mode. ",
                                           "updatedAt":  "2021-01-29T21:13:54Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6C-4Qq",
                                           "createdAt":  "2024-06-28T19:39:30Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "hoyosjs",
                                           "body":  "Closing in favor of https://github.com/dotnet/runtime/issues/80666",
                                           "updatedAt":  "2024-06-28T19:39:30Z"
                                       }
                                   ],
                         "totalCount":  5
                     },
        "title":  "tracing/eventpipe/eventsourceerror/eventsourceerror test always failing locally on Linux / macOS",
        "labels":  [
                       "area-Tracing-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/49338",
        "createdAt":  "2021-03-08T23:09:19Z",
        "number":  49338,
        "author":  "valco1994",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2023-03-24T14:12:54Z",
        "body":  "I would like to detect the framework version of the application being profiled with EventPipe. I was going to use the `RuntimeInformationStart` event from `Microsoft-Windows-DotNETRuntime` provider and/or `RuntimeInformationDCStart` from `Microsoft-Windows-DotNETRuntimeRundown` provider, but faced the following issues:\r\n\r\n* Firstly, `RuntimeInformationStart` is not produced at all. Is it done so by design? And if yes, why?  \r\n* Secondly, when I used rundown event `RuntimeInformationDCStart` I had faced some issues too:\r\n  * There are two types of version - VM version and BCL version. And these versions have different build number for .NET 5 and .NET 6 preview. It\u0027s not clear to me how these versions correspond with runtime version (e.g. `Environment.Version`). Could you, please, clarify it?\r\n  * For .NET Core 3.0 and .NET Core 3.1 situation is much more frustrating. I receive identical `4.0.30319` VM version and `4.0.0` BCL version for them, so I can\u0027t tell them apart from relying on this event. Could you say, maybe there\u0027s some other rundown event that can allow me to distinguish .NET Core 3.0 and .NET Core 3.1?",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHONQU5vg==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc5MzE1NTQ2Mg==",
                                           "createdAt":  "2021-03-08T23:09:22Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "I couldn\u0027t figure out the best area label to add to this issue. If you have write-permissions please help me learn by adding exactly one [area label](https://github.com/dotnet/runtime/blob/master/docs/area-owners.md).",
                                           "updatedAt":  "2021-03-08T23:09:22Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc5MzE1NTg2Mg==",
                                           "createdAt":  "2021-03-08T23:10:06Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "valco1994",
                                           "body":  "@sywhang @josalem",
                                           "updatedAt":  "2021-03-08T23:10:06Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc409k4R",
                                           "createdAt":  "2021-07-28T19:17:37Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "josalem",
                                           "body":  "\u003e Firstly, RuntimeInformationStart is not produced at all. Is it done so by design? And if yes, why?\r\n\r\nLooks like this event is only fired when `RundownStart()` is triggered. Currently, that is only triggered by ETW sessions and not EventPipe sessions. I would say this is by design, but I don\u0027t have a good answer for why we don\u0027t allow you to request `RundownStart` via Eventpipe. I\u0027ll take a look if there is a historical reason for this or if we can just move this logic to a shared location.\r\n\r\n\r\nFor the past 2 years, `System.Environment.Version` has returned the assembly version of System.Private.CoreLib:\r\nhttps://github.com/dotnet/runtime/blob/db1b3023b791aa93d9095699117efb4c0afc41c7/src/libraries/System.Private.CoreLib/src/System/Environment.cs#L189-L205\r\n\r\nThis should be the same as what gets returned in the `BCLVersion*` fields of the `RuntimeInformation*` events potentially with a build flavor moniker, e.g., \"preview5\".\r\n\r\nIt looks like there was a cleanup of the code that populats the `BCLVersion*` fields about a year ago, so I\u0027ll need to do some spelunking to see what these values were pre-.net5.",
                                           "updatedAt":  "2021-07-28T19:17:37Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc409_iA",
                                           "createdAt":  "2021-07-28T22:39:29Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "valco1994",
                                           "body":  "Thank you for the answer, John! It would be very nice if `RuntimeInformationStart` will be fired on EventPipe session start.",
                                           "updatedAt":  "2021-07-28T22:39:29Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc41BTm-",
                                           "createdAt":  "2021-07-30T00:03:38Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "josalem",
                                           "body":  "I tinkered with adding this code, and this is doable. I\u0027m not sure we want to put this in for .net6 at this point since the change has the potential to affect some out of band tooling dependent on ETW as well.\r\n\r\nSince there is a workaround (open a session and collect an EndRundown then start a second session where you use that information) I\u0027m inclined to push this feature to .net7. I\u0027ll link to my patch and discuss with some folks on my team whether this is something we want to try getting in at the end of .net6 here.\r\n\r\nhttps://github.com/josalem/runtime/tree/dev/josalem/runtimeinformation-eventpipe\r\n\r\n",
                                           "updatedAt":  "2021-07-30T00:03:38Z"
                                       }
                                   ],
                         "totalCount":  5
                     },
        "title":  "RuntimeInformation events from EventPipe",
        "labels":  [
                       "question",
                       "area-Tracing-coreclr",
                       "feature-request"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/49424",
        "createdAt":  "2021-03-10T10:08:48Z",
        "number":  49424,
        "author":  "discostu105",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOCjkQBw==",
                          "nodes":  [
                                        {
                                            "content":  "HEART",
                                            "user":  "damiankaminski",
                                            "createdAt":  "2022-06-24T11:33:17Z"
                                        }
                                    ],
                          "totalCount":  1
                      },
        "updatedAt":  "2024-02-08T16:05:05Z",
        "body":  "We do have a use-case for low overhead heap profiling (production ready, continuously on) that is currently hard to archive in .NET. I would like to start a conversation about what would be needed in .NET to achieve this and if there is a way forward to get such support in future .NET versions. \r\n\r\n## Use-Case \r\n\r\nWe do have a .NET Profiler (for APM and cpu-profiling use-cases) and want to extend it with memory/allocation profiling capabilities. We want to be able to tell our users, what code leads to expensive allocations, in production environment, continuously-on, low-overhead. \r\n\r\nWhat we would like to capture: \r\n\r\n* Allocated type \r\n* Allocation size (object size, array size+base object size) \r\n* Callsite of an allocation (full callstack) \r\n* Identify allocations that lead to “surviving” objects (e.g. through tagging objects and get a \"free\" callback for them)\r\n\r\nIt shall have the following properties: \r\n* Can be enabled/disabled at runtime\r\n* Has a controllable sampling rate (so that the desired overhead/accuracy can be dynamically adapted, based on user-config or overhead estimation heuristics)\r\n\r\nHere is an example of how such data could be visualized: https://www.dynatrace.com/support/help/how-to-use-dynatrace/transactions-and-services/analysis/memory-profiling/ \r\n\r\n## Status Quo \r\n\r\nWe have researched multiple approaches, but none of them fully satisfied our requirements.\r\n\r\nOne approach is to use the `ObjectAllocated`, `MovedReferences`, `SurvivedReferences `and `GarbageCollectionFinished` profiler callbacks. However, this is not viable for production scenarios, since the performance overhead for just enabling these callbacks is extremely high (more than 100%). \r\n\r\nSince .NET 5 we can also use the `EventPipeEventDelivered` profiler callback. There are the `AllocationTick_V3`, `GCBulkMovedObjectRanges` and `GCBulkSurvivedObjectRanges` event pipe events that provide similar data as the profiler callbacks mentioned above. The measured overhead for this was significantly lower (Between ~1% to ~20%, depending on the number of allocations and GC runs. The 20% overhead was measured with a sample that allocates large arrays in a loop. For more realistic applications this overhead is closer to ~2%). \r\n\r\nProblems of the event pipe approach: \r\n* Obtaining size of allocated arrays not possible \r\n* `AllocationTick_V3` sampling rate fixed at ~100KB (problematic for applications that allocate very low/high amounts of memory) \r\n* Overhead still higher than in java \r\n\r\n### Array Size \r\n\r\nArray size is critical for our use-case, as arrays can make up a significant portion of overall allocations. As mentioned in https://github.com/dotnet/runtime/issues/43345, it is not possible to obtain the size of allocated array objects in the callback of the `AllocationTick_V3` event.\r\n\r\nWe can obtain the size in the `GarbageCollectionStarted` profiler callback with the `ICorProfilerInfo::GetObjectSize` method if we track the `ObjectId`. However, enabling this profiler callback increases the overhead significantly. \r\n\r\nThe `GCStart` event pipe event would have less overhead, however it is not possible to reliably obtain the object size in that callback, since the `ICorProfilerInfo::GetObjectSize` method sometimes fails with a read access violation at: \r\n\r\n`coreclr.dll!Object::GetSize() Line 44` \r\n`coreclr.dll!ProfToEEInterfaceImpl::GetObjectSize(unsigned __int64 objectId, unsigned long * pcSize) Line 1586` \r\n\r\n## Comparable solutions \r\n\r\nSince JDK 11, there are callbacks that provide the necessary information with minimal overhead. It matches our use-case really well.\r\n\r\nIt is possible to monitor allocated objects with the `SampledObjectAlloc` callback (https://docs.oracle.com/en/java/javase/11/docs/specs/jvmti.html#SampledObjectAlloc). The sampling rate for this callback can be configured with the `SetHeapSamplingInterval` method. \r\n\r\nAdditionally, there is the `ObjectFree` callback that is sent when a tagged object is freed by the garbage collector (https://docs.oracle.com/en/java/javase/11/docs/specs/jvmti.html#ObjectFree). \r\n\r\nA detailed description of this can be found at https://openjdk.java.net/jeps/331 \r\n\r\n## Summary\r\n\r\nCurrently it looks like our use-case cannot be fulfilled in .NET. With this ticket, we\u0027re hoping to have a discussion if such a capability makes sense in a future .NET version. If this isn\u0027t the right place/form to have such a discussion, please let us know :).\r\n\r\n@discostu105 @d-schneider\r\n ",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOc01K_A==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc5NTE5MDYzOA==",
                                           "createdAt":  "2021-03-10T10:08:55Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/gc\nSee info in area-owners.md if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nWe do have a use-case for low overhead heap profiling (production ready, continuously on) that is currently hard to archive in .NET. I would like to start a conversation about what would be needed in .NET to achieve this and if there is a way forward to get such support in future .NET versions. \r\n\r\n## Use-Case \r\n\r\nWe do have a .NET Profiler (for APM and cpu-profiling use-cases) and want to extend it with memory/allocation profiling capabilities. We want to be able to tell our users, what code leads to expensive allocations, in production environment, continuously-on, low-overhead. \r\n\r\nWhat we would like to capture: \r\n\r\n* Allocated type \r\n* Allocation size (object size, array size+base object size) \r\n* Callsite of an allocation (full callstack) \r\n* Identify allocations that lead to “surviving” objects (e.g. through tagging objects and get a \"free\" callback for them)\r\n\r\nIt shall have the following properties: \r\n* Can be enabled/disabled at runtime\r\n* Has a controllable sampling rate (so that the desired overhead/accuracy can be dynamically adapted, based on user-config or overhead estimation heuristics)\r\n\r\nHere is an example of how such data could be visualized: https://www.dynatrace.com/support/help/how-to-use-dynatrace/transactions-and-services/analysis/memory-profiling/ \r\n\r\n## Status Quo \r\n\r\nWe have researched multiple approaches, but none of them fully satisfied our requirements.\r\n\r\nOne approach is to use the `ObjectAllocated`, `MovedReferences`, `SurvivedReferences `and `GarbageCollectionFinished` profiler callbacks. However, this is not viable for production scenarios, since the performance overhead for just enabling these callbacks is extremely high (more than 100%). \r\n\r\nSince .NET 5 we can also use the `EventPipeEventDelivered` profiler callback. There are the `AllocationTick_V3`, `GCBulkMovedObjectRanges` and `GCBulkSurvivedObjectRanges` event pipe events that provide similar data as the profiler callbacks mentioned above. The measured overhead for this was significantly lower (Between ~1% to ~20%, depending on the number of allocations and GC runs. The 20% overhead was measured with a sample that allocates large arrays in a loop. For more realistic applications this overhead is closer to ~2%). \r\n\r\nProblems of the event pipe approach: \r\n* Obtaining size of allocated arrays not possible \r\n* `AllocationTick_V3` sampling rate fixed at ~100KB (problematic for applications that allocate very low/high amounts of memory) \r\n* Overhead still higher than in java \r\n\r\n### Array Size \r\n\r\nAs mentioned in https://github.com/dotnet/runtime/issues/43345, it is not possible to obtain the size of allocated array objects in the callback of the `AllocationTick_V3` event. \r\n\r\nWe can obtain the size in the `GarbageCollectionStarted` profiler callback with the `ICorProfilerInfo::GetObjectSize` method if we track the `ObjectId`. However, enabling this profiler callback increases the overhead significantly. \r\n\r\nThe `GCStart` event pipe event would have less overhead, however it is not possible to reliably obtain the object size in that callback, since the `ICorProfilerInfo::GetObjectSize` method sometimes fails with a read access violation at: \r\n\r\n`coreclr.dll!Object::GetSize() Line 44` \r\n`coreclr.dll!ProfToEEInterfaceImpl::GetObjectSize(unsigned __int64 objectId, unsigned long * pcSize) Line 1586` \r\n\r\n## Comparable solutions \r\n\r\nSince JDK 11, there are callbacks that provide the necessary information with minimal overhead.  \r\n\r\nIt is possible to monitor allocated objects with the `SampledObjectAlloc` callback (https://docs.oracle.com/en/java/javase/11/docs/specs/jvmti.html#SampledObjectAlloc). The sampling rate for this callback can be configured with the `SetHeapSamplingInterval` method. \r\n\r\nAdditionally, there is the `ObjectFree` callback that is sent when a tagged object is freed by the garbage collector (https://docs.oracle.com/en/java/javase/11/docs/specs/jvmti.html#ObjectFree). \r\n\r\nA detailed description of this can be found at https://openjdk.java.net/jeps/331 \r\n\r\n## Summary\r\n\r\nCurrently it looks like our use-case cannot be fulfilled in .NET. With this ticket, we\u0027re hoping to have a discussion if such a capability makes sense in a future .NET version. If this isn\u0027t the right place/form to have such a discussion, please let us know :).\r\n\r\n@discostu105 @d-schneider\r\n \n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003ediscostu105\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-GC-coreclr`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2021-03-10T10:08:55Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc5OTc2NTcyMA==",
                                           "createdAt":  "2021-03-15T21:30:33Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "davmason",
                                           "body":  "Hi @discostu105,\r\n\r\nThanks for reaching out to start the discussion.\r\n\r\nThe GC profiling available over ICorProfiler has historically been extremely performance impactful, and we have done some work over the last couple releases to try and make it better. I\u0027m happy to work with you to identify ways we can iterate even  more.\r\n\r\nJust to make sure you\u0027re aware of the recent work I\u0027ll mention it here:\r\n\r\nWe first added the concept of \"lightweight GC Profiling\" that enables just GC start and end and updates of generational bounds: https://github.com/dotnet/coreclr/pull/22866\r\n\r\nThen we added \"medium weight GC profiling\" providing some APIs to be able to track objects more efficiently: https://github.com/dotnet/coreclr/pull/24156\r\n\r\nAnd then as you mention in 5.0 we added the ability to get EventPipe events over ICorProfiler.\r\n\r\nFor the specific issues you point out, I have a couple follow up questions.\r\n\r\n\u003e We can obtain the size in the GarbageCollectionStarted profiler callback with the ICorProfilerInfo::GetObjectSize method if we track the ObjectId. However, enabling this profiler callback increases the overhead significantly.\r\n\r\nHave you tried getting GC start events with lightweight GC profiling enabled? Hopefully that should be very little overhead.\r\n\r\nThere also is the option of using only the EventPipe events and doing GC profiling the same way the dotnet team\u0027s tools (e.g. PerfView) already do GC profiling. I am not an expert in them, but can help wade through the details if you want to go that route.\r\n\r\n\u003e Overhead still higher than in java\r\n\r\nCan you give specific numbers for what the overhead difference is when collecting the same type of data?",
                                           "updatedAt":  "2021-03-15T21:30:33Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgwOTMzNjAyOQ==",
                                           "createdAt":  "2021-03-29T12:26:39Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "d-schneider",
                                           "body":  "Hi @davmason,\r\n\r\nthank you for the link to the lightweight GC profiling. It is indeed possible to obtain the size of array objects in the GC started callback with the `COR_PRF_HIGH_BASIC_GC` event mask enabled. As you mentioned, this has very low overhead. Enabling it in addition to the mentioned event pipe events adds no significant overhead.  \r\n\r\nHowever, array-sizes can only be obtained at collection-time, not at allocation-time. There are situations where few garbage collections occur. In that case we must wait for the next garbage collection before we can obtain the size of array objects. This makes it more complex if we want to report the amount of allocated memory in a certain timeframe, since it is possible that we don’t know the sizes of allocated arrays at the end of the reporting-timeframe, if there was no GC run. So, while it’s not ideal, it certainly already helps us to get array-sizes most of the time, especially in times with high GC activity, which are the interesting situations anyway. \r\n\r\nIn an ideal world though, it would be preferable if we could obtain the object size of the last allocated object during the `EventPipeEventDelivered` callback for the `AllocationTick` event (e.g., by including it in the event data). This is currently not possible for array objects, as mentioned in https://github.com/dotnet/runtime/issues/43345.  \r\n\r\n  \r\n\r\n \r\n\r\nConcerning overhead, there are two main differences between Java and .NET that can influence it:  \r\n\r\n* We can configure the sampling rate for the Java `SampledObjectAlloc` callback during runtime, while the sampling rate for the .Net `AllocationTick` event is fixed at ~100KB. With the configurable sampling rate, it’s possible to dynamically adapt overhead to an acceptable level. \r\n\r\n \r\n\r\n* In Java it is possible to tag specific objects and obtain an `ObjectFree` callback when this object is freed by the garbage collector. For .NET, we need the `GCBulkSurvivedObjectRanges` and `GCBulkMovedObjectRanges` event pipe events to determine if an object survived the GC run. These events add high overhead if there are many garbage collections. In extreme cases e.g., when allocating a lot of large arrays, this can add ~15% overhead. \r\n\r\nOur Java solution generally adds very low overhead (lower than 1%). Compared to that, just enabling the necessary event pipe events described in the original post has a performance overhead of ~1-20%, depending on the number of allocations, amount of allocated memory and number of GC runs. ",
                                           "updatedAt":  "2021-03-29T12:26:39Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgwOTc1NjEyNw==",
                                           "createdAt":  "2021-03-29T22:32:21Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Maoni0",
                                           "body":  "@d-schneider I\u0027d definitely be interested to see how we can make this better for you. re your questions \r\n\r\n\u003e With the configurable sampling rate, it’s possible to dynamically adapt overhead to an acceptable level.\r\n\r\nthis can definitely be a config instead of hard coded 100k. \r\n\r\n\u003e In an ideal world though, it would be preferable if we could obtain the object size of the last allocated object during the EventPipeEventDelivered callback for the AllocationTick event \r\n\r\nif you meant could we give you the size of the object that happened to trigger the AllocTick event, that\u0027s totally doable - GC has this info when an allocation triggered a GC. \r\n\r\n\u003e In Java it is possible to tag specific objects and obtain an ObjectFree callback when this object is freed by the garbage collector. \r\n\r\ncan you please tell me a bit about your usage of this callback? I presume you are doing this all in native code, just like with .NET. do you normally register for this callback with say a few user specified objects? I can see how the overhead would totally go up if there were many objects that registered for this callback. ",
                                           "updatedAt":  "2021-03-29T22:32:21Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgwOTc5OTUwMw==",
                                           "createdAt":  "2021-03-29T23:49:15Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "davmason",
                                           "body":  "\u003e \u003e In an ideal world though, it would be preferable if we could obtain the object size of the last allocated object during the EventPipeEventDelivered callback for the AllocationTick event\r\n\u003e \r\n\u003e if you meant could we give you the size of the object that happened to trigger the AllocTick event, that\u0027s totally doable - GC has this info when an allocation triggered a GC.\r\n\r\nFrom a native ICorProfiler implementation point of view, the issue is that the event is fired before the MethodTable/array size is set on the object, so you can\u0027t call [GetArrayObjectInfo](https://docs.microsoft.com/en-us/dotnet/framework/unmanaged-api/profiling/icorprofilerinfo2-getarrayobjectinfo-method) on it from the callback to the AllocationTick event (since EventPipe events are synchronous for ICorProfiler). Either including the size in the event or moving the event so it is fired after the object is published should work for this case.\r\n",
                                           "updatedAt":  "2021-03-29T23:49:15Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgxMDQ1Nzg2Nw==",
                                           "createdAt":  "2021-03-30T17:52:06Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "d-schneider",
                                           "body":  "Thanks for the replies! \r\n\r\n\u003e This can definitely be a config instead of hard coded 100k. \r\n\r\nIt would be great for us if the sampling rate for the AllocationTick event is configurable at runtime. As mentioned, this would help us to dynamically reduce overhead or increase accuracy in situations with few allocations. \r\n\r\n\u003e if you meant could we give you the size of the object that happened to trigger the AllocTick event, that\u0027s totally doable - GC has this info when an allocation triggered a GC. \r\n\r\nYes, I meant the size of the object that triggered the AllocationTick event. \r\n\r\n\u003e Either including the size in the event or moving the event so it is fired after the object is published should work for this case. \r\n\r\nBoth solutions would be ok for us. \r\n\r\n\u003e can you please tell me a bit about your usage of this callback? I presume you are doing this all in native code, just like with .NET. do you normally register for this callback with say a few user specified objects? I can see how the overhead would totally go up if there were many objects that registered for this callback. \r\n\r\nOur Java implementation is also done in native code. We register each object that triggered a SampledObjectAlloc callback for the ObjectFree callback. This way, the number of ObjectFree callbacks sent is at most as high as the number of SampledObjectAlloc callbacks.  \r\nSince we can adjust the sampling rate for the SampledObjectAlloc callback during runtime, it is possible to target a certain number of sampled allocations per timeframe (e.g., 1000 sampled allocations per minute). To reduce overhead, we only track objects for one timeframe and the object tag, which determines if an ObjectFree callback should be sent, is cleared for all remaining survivors after that timeframe. ",
                                           "updatedAt":  "2021-03-30T17:52:06Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgxMTY3NzY3OQ==",
                                           "createdAt":  "2021-04-01T06:28:16Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Maoni0",
                                           "body":  "@d-schneider \r\n\r\n\u003e Both solutions would be ok for us.\r\n\r\nahh, my question was if you just wanted the size, or if you needed it to be an object that\u0027s already constructed. if it\u0027s just the size that\u0027s trivial \u0027cause GC already knows the size. but if you need this to be a constructed object (eg, you can call some method on this object), that would require the event to be moved as @davmason mentioned - the place where it\u0027s fired now is in GC before the methodtable is filled in.\r\n\r\nregarding the ObjectFree callback, you could implement this via GC handles. you can allocate a weak GC handle to hold onto objects of interest and during the GC done callback check if they are nulled by the GC, if so you know they are dead. obviously this requires you to be able to allocate a GC handle in your code. so if you currently already have some way to do that (ie, you already have managed code running and can pass a delegate back to native code to reverse pinvoke to create a GC handle to hold onto these objects), that\u0027s great; if not, it\u0027d be some work to get this managed code infra running first. it\u0027s possible to make the profiling API provide this plumbing for you (but that\u0027d be work on the diagnostics team :)). ",
                                           "updatedAt":  "2021-04-01T06:28:16Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgxMTc2NzY2MQ==",
                                           "createdAt":  "2021-04-01T09:05:41Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "davmason",
                                           "body":  "@Maoni0 are the first two items (reporting size in the alloc event and configurable alloc tick frequency) things the GC team would take on?\r\n\r\nI\u0027m happy to work with @d-schneider on how to best achieve the object tracking from the profiler.",
                                           "updatedAt":  "2021-04-01T09:05:41Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgxMjE4NDA4MA==",
                                           "createdAt":  "2021-04-01T21:32:00Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Maoni0",
                                           "body":  "@davmason yes, I don\u0027t feel like I have a confirmation whether this event would need to be moved though (it\u0027d be really great to avoid it \u0027cause it means the code has to move from the GC side to the VM side).",
                                           "updatedAt":  "2021-04-01T21:32:00Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgxNDA2MzM1NQ==",
                                           "createdAt":  "2021-04-06T12:00:21Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "d-schneider",
                                           "body":  "\u003e ahh, my question was if you just wanted the size, or if you needed it to be an object that\u0027s already constructed. \r\n\r\n@Maoni0  Just the size is sufficient for our use case.\r\n\r\n  \r\n\r\nConcerning the AllocationTick sampling rate: The Java SampledObjectAlloc callback also uses a random variation for the sampling frequency, as described in [JEP-331](https://openjdk.java.net/jeps/331). If possible, a similar feature for the AllocationTick event would also be interesting for us. \r\n\r\nDescription for this from https://openjdk.java.net/jeps/331: \"Note that the sampling interval is not precise. Each time a sample occurs, the number of bytes before the next sample will be chosen will be pseudo-random with the given average interval. This is to avoid sampling bias; for example, if the same allocations happen every 512KB, a 512KB sampling interval will always sample the same allocations. Therefore, though the sampling interval will not always be the selected interval, after a large number of samples, it will tend towards it.\" ",
                                           "updatedAt":  "2021-04-06T12:00:21Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgxNDQzMTExNA==",
                                           "createdAt":  "2021-04-06T20:49:32Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Maoni0",
                                           "body":  "thanks for the info @d-schneider. have you observed that the random interval is needed often? in theory it sounds like a useful thing but in practice it should be completely rare that \"same allocations happen every 512KB\" - even if that happened, since we are almost always in a multi-threaded environment this means to the GC it won\u0027t see the same allocation every 512kb (ie, one thread could be doing the same alloc every 512kb but since it shares the same heap with another thread, GC won\u0027t see that alloc every 512kb on that heap). ",
                                           "updatedAt":  "2021-04-06T20:49:32Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgxNDcxMjU0OA==",
                                           "createdAt":  "2021-04-07T08:23:37Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "discostu105",
                                           "body":  "@Maoni0 We don\u0027t really have data on how significant the bias would be without the random interval, as this is a built-in JVM feature that cannot be disabled.",
                                           "updatedAt":  "2021-04-07T08:23:37Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgxNTI4NjcwNA==",
                                           "createdAt":  "2021-04-07T21:49:34Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOBmbTCg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "discostu105",
                                                                               "createdAt":  "2021-04-08T11:00:38Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "Maoni0",
                                           "body":  "@discostu105 then I would vote to not include this in our system \u0027cause I simply don\u0027t see it having a practical usage. ",
                                           "updatedAt":  "2021-04-07T21:49:34Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgxNjQyMDIzMw==",
                                           "createdAt":  "2021-04-09T05:34:24Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "davmason",
                                           "body":  "@discostu105 or @d-schneider, do you want to talk about the object tracking portion of your request?\r\n\r\nMaoni has a great idea to use weak references, if you are already doing IL rewriting then it would be not that much work. I\u0027m also happy to discuss adding a new API to ICorProfiler*, but then it would only be available in .net 6 or 7 and newer, depending on when it lands.",
                                           "updatedAt":  "2021-04-09T05:34:24Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgyMTIwMjA4NA==",
                                           "createdAt":  "2021-04-16T14:06:07Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "d-schneider",
                                           "body":  "@davmason @Maoni0  \r\n\r\n\u003e Maoni has a great idea to use weak references, if you are already doing IL rewriting then it would be not that much work. \r\n\r\nAs I understand it, we would have to do a reverse pinvoke in the AllocationTick and GarbageCollectionFinished callbacks to allocate the GC handles and to check if they were nulled by the GC respectively. However, when trying this I ran into problems when calling the delegate: \r\n\r\n- In the case of the GarbageCollectionFinished callback the managed thread of my sample app and the thread of the GC finished callback where I call the delegate hang indefinitely. \r\n\r\n- In the EventPipeEventDelivered callback for the AllocationTick event the process crashes with a \"Fatal error. Invalid Program: attempted to call a UnmanagedCallersOnly method from managed code.\". I am not sure why this error occurs, but it could be because we get the AllocationTick callback on the managed thread where the allocation occurred. \r\n\r\nIs there anything special to consider for the reverse pinvoke in those cases that I might have missed? \r\n\r\nThe reverse pinvoke does work in a native worker thread, but then there could be race conditions e.g., a GC run between the allocation and when the worker thread creates a GC handle. We would have to wait in the AllocationTick callback for the worker thread to finish creating a GC handle, but this is not an optimal solution. \r\n\r\nI haven\u0027t tried this yet, but another question is if there could be any problems when creating the GC handle for the object that triggered the AllocationTick event, considering that we currently can\u0027t get the size of the object in that callback? \r\n\r\n \r\n\r\n\u003e I\u0027m also happy to discuss adding a new API to ICorProfiler*, but then it would only be available in .net 6 or 7 and newer, depending on when it lands. \r\n\r\nWe think the native ICorProfiler API would be the better approach, as it would be simpler to consume. Preferably similar to Java, e.g., we can register an object for a callback when it\u0027s freed by the GC. Getting this added in a future .NET release would be great! We are happy to answer any questions regarding a possible ICorProfiler API. ",
                                           "updatedAt":  "2021-04-16T14:48:17Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgyNTUzNzMwOA==",
                                           "createdAt":  "2021-04-23T09:41:36Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "davmason",
                                           "body":  "\u003e As I understand it, we would have to do a reverse pinvoke in the AllocationTick and GarbageCollectionFinished callbacks to allocate the GC handles and to check if they were nulled by the GC respectively. However, when trying this I ran into problems when calling the delegate:\r\n\u003e \r\n\u003e  * In the case of the GarbageCollectionFinished callback the managed thread of my sample app and the thread of the GC finished callback where I call the delegate hang indefinitely.\r\n\r\nYeah, that makes sense. The GC is still considered in progress during the GarbageCollectionFinished callback, so managed code won\u0027t be able to run until you return from it and let the GC complete.\r\n\r\n\u003e * In the EventPipeEventDelivered callback for the AllocationTick event the process crashes with a \"Fatal error. Invalid Program: attempted to call a UnmanagedCallersOnly method from managed code.\". I am not sure why this error occurs, but it could be because we get the AllocationTick callback on the managed thread where the allocation occurred.\r\n\r\n\r\nThis makes sense, the AllocationTick event is going to be fired in the middle of the allocation, which would be in managed code. So even though your profiler is native code, there is managed code on the stack so it triggers that error.\r\n\r\n\r\n\u003e Is there anything special to consider for the reverse pinvoke in those cases that I might have missed?\r\n\u003e \r\n\u003e The reverse pinvoke does work in a native worker thread, but then there could be race conditions e.g., a GC run between the allocation and when the worker thread creates a GC handle. We would have to wait in the AllocationTick callback for the worker thread to finish creating a GC handle, but this is not an optimal solution.\r\n\r\nI hadn\u0027t thought through exactly how you would have to accomplish this, but you\u0027re right that there are a lot of potential race conditions and deadlocks. I think the only way you could accomplish it right now is how you describe it, you would have to spin up a separate thread that has no managed code on it, pass the object to the thread and then block in the AllocationTick event callback until the other thread is done allocating a handle to it.\r\n\r\nIf you go that route, you would have to be very careful to not do any allocations, and not call any methods that allocate. Since you would blocking inside an allocation, it would prevent a GC from running and any allocation can trigger a GC (that would lead to a deadlock).\r\n\r\n\u003e \r\n\u003e I haven\u0027t tried this yet, but another question is if there could be any problems when creating the GC handle for the object that triggered the AllocationTick event, considering that we currently can\u0027t get the size of the object in that callback?\r\n\r\nI don\u0027t think there will be any issues with that.\r\n\r\n\u003e \u003e I\u0027m also happy to discuss adding a new API to ICorProfiler*, but then it would only be available in .net 6 or 7 and newer, depending on when it lands.\r\n\u003e \r\n\u003e We think the native ICorProfiler API would be the better approach, as it would be simpler to consume. Preferably similar to Java, e.g., we can register an object for a callback when it\u0027s freed by the GC. Getting this added in a future .NET release would be great! We are happy to answer any questions regarding a possible ICorProfiler API.\r\n\r\nAfter thinking about this for a while, I think it would make sense to add a general purpose GC handle API to ICorProfiler - profilers could allocated weak handles to track object lifetime like you want to do, but then could also allocate a strong handle to keep objects alive that they want to keep alive. It wouldn\u0027t give you a callback, but it would be more general purpose and provide benefit to more scenarios.\r\n\r\n```\r\n    typedef enum\r\n    {\r\n        COR_PRF_HANDLE_TYPE_STRONG,\r\n        COR_PRF_HANDLE_TYPE_WEAK,\r\n        COR_PRF_HANDLE_TYPE_PINNED\r\n    } COR_PRF_OBJECT_HANDLE_TYPE;\r\n\r\n    HRESULT AllocateHandle(\r\n                [in] ObjectID objectID,\r\n                [in] COR_PRF_OBJECT_HANDLE handleType,\r\n                [out] ObjectHandle *pObjectHandle);\r\n\r\n    HRESULT FreeHandle([in] ObjectHandle objectHandle);\r\n\r\n    HRESULT GetObjectFromHandle(\r\n                [in] ObjectHandle handle,\r\n                [out] ObjectID *pObjectID);\r\n```\r\n",
                                           "updatedAt":  "2021-04-23T09:41:36Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgyODI4OTQxOA==",
                                           "createdAt":  "2021-04-28T09:07:40Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "d-schneider",
                                           "body":  "@davmason Thanks for the API proposal. The described API would be great for our use case. \r\n\r\nHow high is the expected performance impact of calling the GetObjectFromHandle method multiple times per GC run? \r\nWe would call it for each of our tracked objects after each GC run until it is freed or the tracked objects are cleared (happens every minute). This could be problematic in scenarios with many GC runs.  \r\n\r\nIs it possible that a variant of the GetObjectFromHandle method that allows us to get multiple objects at once would be better from a performance perspective for this use-case? ",
                                           "updatedAt":  "2021-04-28T09:08:44Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgyODQ3MjU0OQ==",
                                           "createdAt":  "2021-04-28T13:51:01Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOBpGyFA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "davmason",
                                                                               "createdAt":  "2021-04-29T19:36:55Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "jkotas",
                                           "body":  "`GetObjectFromHandle` would be very cheap. The implementation is going to be:\r\n```\r\nHRESULT GetObjectFromHandle(\r\n                [in] ObjectHandle handle,\r\n                [out] ObjectID *pObjectID)\r\n{\r\n    if (handle == NULL || pObjectID == NULL) return E_INVALIDARG;\r\n    *pObjectID = *(void**)handle;\r\n}\r\n```\r\nUnless you are at the point where you are trying to micro-optimize at instruction level, the cost is negligible.",
                                           "updatedAt":  "2021-04-28T13:51:01Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgyOTM4MDQ0OA==",
                                           "createdAt":  "2021-04-29T16:20:41Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "d-schneider",
                                           "body":  "\u003e `GetObjectFromHandle` would be very cheap.\r\n\r\nThanks for the info about the `GetObjectFromHandle` implementation. Then the proposed API would be great for our use case.",
                                           "updatedAt":  "2021-04-29T16:22:02Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgyOTUzNjkyMA==",
                                           "createdAt":  "2021-04-29T19:43:38Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "davmason",
                                           "body":  "Thanks for the confirmation @d-schneider.\r\n\r\nI don\u0027t think I said this explictly so far, there is about a month or two left to get features in for 6.0 and we are already completely booked on the diagnostics team. This feature would be scheduled for 7.0 at the earliest as it stands.\r\n\r\nThat being said, we always welcome PRs from the community and this is probably one of the easier ones to implement. If you or anyone on your team is feeling up for it I would be more than happy to guide you through the process of implementing it.",
                                           "updatedAt":  "2021-04-29T19:43:38Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc40rVbK",
                                           "createdAt":  "2021-07-20T23:41:36Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Maoni0",
                                           "body":  "@d-schneider while reviewing my instrumentation change [#55888](https://github.com/dotnet/runtime/pull/55888), @noahfalk brought up something that I hadn\u0027t thought of and wanted to check with you. in my PR I made the alloc tick threshold configurable via a runtime config (which can also be set as an env var), but he pointed out that it may not produce desirable effect for you because a profiler wouldn\u0027t have the freedom to do this config on the user\u0027s behalf and you probably meant a profiling API for you to set this threshold instead? could you please confirm which is your preference? \r\n\r\nI presume you still would like the object size as part of the alloc tick regardless, right? which the new version of the event provides. ",
                                           "updatedAt":  "2021-07-20T23:41:36Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc40vvTW",
                                           "createdAt":  "2021-07-22T13:52:09Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "d-schneider",
                                           "body":  "@Maoni0  Thanks for implementing this! We would prefer a profiling API for this configuration. It is also important for us that we can adjust the allocation tick threshold with this API while the application is running.\r\n\r\nYes, we would still like the object size as part of the allocation tick event. The new AllocationTick_V4 event looks great in this regard!",
                                           "updatedAt":  "2021-07-22T13:52:09Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc40we6c",
                                           "createdAt":  "2021-07-22T18:05:51Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Maoni0",
                                           "body":  "@d-schneider thanks for confirming! that\u0027s the same as what @noahfalk told me. I\u0027ve pulled out the runtime config and kept the new AllocationTick_V4 event in my PR. for adjusting the threshold with profiling API, the diagnostics team will handle that (@davmason @noahfalk). it shouldn\u0027t be hard to add it and allow it to change the threshold while the process is running. ",
                                           "updatedAt":  "2021-07-22T18:05:51Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5zTUr8",
                                           "createdAt":  "2024-02-08T16:05:04Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODWdgoQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "discostu105",
                                                                               "createdAt":  "2024-02-12T21:12:12Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "noahfalk",
                                           "body":  "Just a heads up that over in https://github.com/dotnet/runtime/pull/98167 I am starting to look into low overhead randomized heap sampling again.",
                                           "updatedAt":  "2024-02-08T16:05:04Z"
                                       }
                                   ],
                         "totalCount":  24
                     },
        "title":  "Low overhead heap profiling",
        "labels":  [
                       "area-Tracing-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/51766",
        "createdAt":  "2021-04-23T22:20:39Z",
        "number":  51766,
        "author":  "noahfalk",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOBoaevg==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "AaronRobinsonMSFT",
                                            "createdAt":  "2021-04-23T23:43:19Z"
                                        }
                                    ],
                          "totalCount":  1
                      },
        "updatedAt":  "2022-05-18T13:25:18Z",
        "body":  "When tracing using EventPipe the trace does not contain any explicit recording of the configuration that was used to generate it. This makes it challenging to determine after-the-fact if events that are missing in the trace truly did not occur or if the trace was not configured to collect them. This information could also be very useful for tools that are analyzing traces to determine which analysis views to show.\r\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  null,
                         "nodes":  [

                                   ],
                         "totalCount":  0
                     },
        "title":  "[Feature Request] EventPipe should record the configuration used to collect a trace",
        "labels":  [
                       "enhancement",
                       "area-Tracing-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/54736",
        "createdAt":  "2021-06-25T10:09:20Z",
        "number":  54736,
        "author":  "noahfalk",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2022-05-18T13:26:35Z",
        "body":  "We have an event Microsoft-Windows-DotNETRuntimeRundown/Runtime/Start that logs some versioning information at startup. For people with long running applications that log events as telemetry they may not be able to easily query the telemetry over large time ranges. We got a request to enable repeating this event on some interval so that a bounded time query would find an instance of it.\r\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  null,
                         "nodes":  [

                                   ],
                         "totalCount":  0
                     },
        "title":  "Emit versioning events on a periodic timer",
        "labels":  [
                       "area-Tracing-coreclr",
                       "feature-request"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/55441",
        "createdAt":  "2021-07-10T00:37:42Z",
        "number":  55441,
        "author":  "josalem",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOCvL4VA==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "afilatov-st",
                                            "createdAt":  "2023-03-30T23:38:44Z"
                                        }
                                    ],
                          "totalCount":  1
                      },
        "updatedAt":  "2023-03-15T06:31:13Z",
        "body":  "There is a rare race that can result in a use-after-free on the native end of `EventPipeEventProvider` and potentially the `EtwEventProvider`.\r\n\r\nhttps://github.com/dotnet/runtime/blob/c90aa4d8ab36bd454e5937abd903924fe7e859fe/src/libraries/System.Private.CoreLib/src/System/Diagnostics/Tracing/EventSource.cs#L1420-L1484\r\n\r\nIf one thread (A) is calling `EventSource.Dispose()`, and another is in the process of writing (B), it is possible for the following sequence to occur:\r\n\r\nA: (1)`Dispose` -\u003e (3)`m_eventSourceEnabled = false` -\u003e (4)`m_eventPipeProvider.Dispose()` -\u003e (6)`m_eventPipeProvider = null`\r\nB: (2)`if (IsEnabled)` -\u003e (5)use `m_eventPipeProvider`\r\n\r\n`EventPipeEventProvider.Dispose()` calls `EventPipeEventProvider.EventUnregister()`. This deletes the underlying native structures (the only time `EventPipeProvider::m_pEventList` is set to `nullptr`). The managed code, does not unset the `m_provHandle` member, so if someone got a reference to this managed object, they would have a pointer to freed memory. The managed provider _has_ been marked as disabled, however, not all code paths check that value. Specifically:\r\n\r\nhttps://github.com/dotnet/runtime/blob/c90aa4d8ab36bd454e5937abd903924fe7e859fe/src/libraries/System.Private.CoreLib/src/System/Diagnostics/Tracing/EventPipeEventProvider.cs#L81-L87\r\n\r\nwhich is where we AV in this case. We get here from `TraceLoggingEventSource.WriteImpl()` which ends up in `NameInfo.GetOrCreateEventHandle()` which calls `DefineEvent` on the provider:\r\n\r\nhttps://github.com/dotnet/runtime/blob/9da4d075ef8c581a28c8c171f36ccb05b66f2346/src/libraries/System.Private.CoreLib/src/System/Diagnostics/Tracing/TraceLogging/NameInfo.cs#L81-L123\r\n\r\nI\u0027m still pinning down the exact sequencing of events in the hopes I can create a deterministic repro. \r\n\r\nI believe this is the cause for the failures on https://github.com/dotnet/coreclr/pull/28179 and #55240.\r\n\r\nCC @tommcdon @noahfalk @dotnet/dotnet-diag ",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOV5WeHA==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc4090Tz",
                                           "createdAt":  "2021-07-28T21:04:36Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "josalem",
                                           "body":  "Migrating the conversation from #55862 to here:\r\n\r\n@noahfalk:\r\n\u003e @josalem and I chatted earlier, but just to record it - most BCL types don\u0027t provide a thread-safety guarantee for Dispose() and I wonder if it is necessary here. The synchronization necessary to provide that guarantee comes with perf costs I\u0027m hopeful we can avoid.\r\n\u003e- If the runtime will automatically call Dispose() on a thread of our choosing at shutdown then we do need some thread-safety guarantee, but does the runtime need to be calling Dispose() at all? I\u0027m not sure what benefit it gives us but research may reveal that is necessary.\r\n\u003e- Since the runtime automatically calls Write for EventCounters we would need to modify Dispose() to ensure that we stopped the EventCounter Write() calls prior to freeing the provider.\r\n\r\n@brianrob:\r\n\u003e I agree. I was trying to figure out what I was concerned about with regard to this change and I couldn\u0027t quite verbalize it. I think you hit it on the head @noahfalk.\r\n\r\n@noahfalk:\r\n\u003eI was looking at a related bug and wound up doing some research on why we call EventSource.Dispose() at shutdown. So far I see two reasons:\r\n\u003e\r\n\u003eAvoiding native-\u003emanaged callbacks after we\u0027ve made it illegal to call back into managed code here\r\nLogging ETW manifests at the end of the trace here\r\nWith a little refactoring we could create a new internal API like EventSource.HandleShutdown() that handles only these concerns while still leaving us in a state where concurrent calls to Write don\u0027t generate failures (whether any data is logged is optional). Then we would call this new API and not Dispose() in the shutdown path. Dispose() would continue to do what it does now including freeing memory, but unlike HandleShutdown() the onus could be on the caller to ensure they don\u0027t make any concurrent calls to other EventSource APIs during/after the call to Dispose().\r\n\u003e\r\n\u003eIn the case of EventPipe, HandleShutdown() could disable the callbacks without deleting the provider. In the case of ETW past precedent suggests concurrent calls to EventUnregister and EventWrite are already safe (we\u0027ve presumably been doing it for many years with no reported issues).\r\n\u003e\r\n\u003e@AaronRobinsonMSFT @vitek-karas @elinor-fung - The comment in the source references throwing a COMPLUS_BOOT_EXCEPTION and I find no reference to it any longer. I do recall that we used to block native-\u003emanaged calls at some point during AppDomain shutdown, but do you know if that constraint is a relic of the desktop runtime that is no longer an issue on CoreCLR?",
                                           "updatedAt":  "2021-07-28T21:04:36Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc41loSQ",
                                           "createdAt":  "2021-08-15T14:10:40Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "\u003e The comment in the source references throwing a COMPLUS_BOOT_EXCEPTION and I find no reference to it any longer. I do recall that we used to block native-\u003emanaged calls at some point during AppDomain shutdown, but do you know if that constraint is a relic of the desktop runtime that is no longer an issue on CoreCLR?\r\n\r\nCorrect, `COMPLUS_BOOT_EXCEPTION` does not exist in CoreCLR. We do not try to prevent threads from running managed code as the process is shutting down.",
                                           "updatedAt":  "2021-08-15T14:10:40Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc41o3Rh",
                                           "createdAt":  "2021-08-17T00:27:46Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "josalem",
                                           "body":  "Having investigated this a little bit I think there are a couple things we could do to solve it:\r\n\r\n* (1) In `EventSource.Dispose`, unregister and disable any associated counters before cleaning up resources.\r\n  * This is problematic since it means we need to make `EventSource.Dispose` wait until the counters are actually disabled. They get copied while under the counter lock, so we\u0027d need to wait till those copies are done writing to make sure the race doesn\u0027t happen.\r\n  * This is really only needed if a user manually disposes an `EventSource` before the end of the process, i.e., doesn\u0027t use the `public static MySource Log = new MySource(...);` pattern.\r\n* (2) In `AppContext.OnProcessEnd`, disable _all_ counters and stop the `PollForValues` thread before the logic that disposes _all_ `EventSource`s.\r\n  * This will prevent the problem from occurring, but _only_ if the `public static MySource Log = new MySource(...);` pattern is followed\r\n\r\nNeither of the above solutions actually prevents a user from writing their own code that attempts to write events while an event source is being disabled.\r\n\r\nIt\u0027s worth noting that this has only been observed on arm32. Most likely due to instruction ordering constraints being looser than other architectures. \r\n\r\nAs a result, I\u0027m leaning towards option 2.",
                                           "updatedAt":  "2021-08-17T00:27:46Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5BqO-P",
                                           "createdAt":  "2022-04-18T17:30:40Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "josalem",
                                           "body":  "Moving to future as there isn\u0027t a strong signal that this is a pressing issue. If we receive more reports of this specific failure we can pull it back on the backlog.\r\n\r\nCC @tommcdon ",
                                           "updatedAt":  "2022-04-18T17:30:40Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5XMmFF",
                                           "createdAt":  "2023-03-09T22:32:52Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOC47hdA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "afilatov-st",
                                                                               "createdAt":  "2023-03-30T23:21:39Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "SergeiPavlov",
                                           "body":  "We have daily crashes during process shutdown  probably related to this issue.\r\n`prometheus-net.DotNetRuntime` package listens for events.\r\n\r\nPlatform: .NET6, Debian\r\nStack Trace:\r\n```\r\n\u003e clrstack -n\r\nOS Thread Id: 0x1d (17)\r\n        Child SP               IP Call Site\r\n00007EF5457F8900 00007f0a2b30fb07 [FaultingExceptionFrame: 00007ef5457f8900] \r\n00007EF5457F9700 00007F09BB0A7234 System.Diagnostics.Tracing.EventPipePayloadDecoder.DecodePayload(EventMetadata ByRef, System.ReadOnlySpan`1\u003cByte\u003e)\r\n00007EF5457F97C0 00007F09BB0A6AD6 System.Diagnostics.Tracing.NativeRuntimeEventSource.ProcessEvent(UInt32, UInt32, System.DateTime, System.Guid, System.Guid, System.ReadOnlySpan`1\u003cByte\u003e)\r\n00007EF5457F9820 00007F09B3402E26 System.Diagnostics.Tracing.EventPipeEventDispatcher.DispatchEventsToEventListeners()\r\n00007EF5457F98E0 00007F09B2C343A7 System.Threading.Tasks.Task.InnerInvoke()\r\n00007EF5457F9920 00007F09B2C0EA0C System.Threading.Tasks.Task+\u003c\u003ec.\u003c.cctor\u003eb__272_0(System.Object)\r\n00007EF5457F9950 00007F09B2C0E47A System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object)\r\n00007EF5457F99D0 00007F09B2C0DE0D System.Threading.Tasks.Task.ExecuteWithThreadLocal(System.Threading.Tasks.Task ByRef, System.Threading.Thread)\r\n00007EF5457F9AA0 00007F09B2C0D63C System.Threading.Tasks.Task.ExecuteEntryUnsafe(System.Threading.Thread)\r\n00007EF5457F9AD0 00007F09B2C0D58C System.Threading.Tasks.ThreadPoolTaskScheduler+\u003c\u003ec.\u003c.cctor\u003eb__10_0(System.Object)\r\n00007EF5457F9B00 00007F09B2C0D3B2 System.Threading.Thread+StartHelper.RunWorker()\r\n00007EF5457F9B50 00007F09B2C0D25E System.Threading.Thread+StartHelper.Run()\r\n00007EF5457F9B80 00007F09B2C0CD65 System.Threading.Thread.StartCallback()\r\n00007EF5457F9CF0 00007f0a2adc5e47 [DebuggerU2MCatchHandlerFrame: 00007ef5457f9cf0] \r\n\u003cEND_COMMAND_OUTPUT\u003e\r\n\u003e pe -nested -lines\r\nException object: 00007ef59c0011b8\r\nException type:   System.ExecutionEngineException\r\n```\r\n\r\nTo mitigate it we tried to dispose all `EventSource.GetSources()` manually. But then we got NRE:\r\n```\r\n00007F4959D20C10 00007f495db45b07 [FaultingExceptionFrame: 00007f4959d20c10] \r\n00007F4959D21A10 00007F48F48C22F8 System.Diagnostics.Tracing.EventSource.Dispose(Boolean)\r\n00007F4959D21A40 00007F48F48C11DE System.Diagnostics.Tracing.EventSource.Dispose()\r\n00007F4959D21A70 00007F48F48C2930 System.Diagnostics.Tracing.EventListener.DisposeOnShutdown()\r\n00007F4959D21AF0 00007F48F48C1248 System.AppContext.OnProcessExit()\r\n\u003cEND_COMMAND_OUTPUT\u003e\r\n\u003e pe -nested -lines\r\nException object: 00007f43f9a25000\r\nException type:   System.NullReferenceException\r\nMessage:          Object reference not set to an instance of an object.\r\n```\r\n\r\nWe hope this bug report encourage further investigation/fixing of the issue.",
                                           "updatedAt":  "2023-03-09T22:34:37Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Xjj3Z",
                                           "createdAt":  "2023-03-14T22:33:54Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "davmason",
                                           "body":  "Hi @SergeiPavlov, thanks for reaching out. Are you able to share a core dump of the crash? We have ways to share them privately if that is a concern",
                                           "updatedAt":  "2023-03-14T22:33:54Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5XlZ4c",
                                           "createdAt":  "2023-03-15T06:31:13Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "SergeiPavlov",
                                           "body":  "\u003e Hi @SergeiPavlov, thanks for reaching out. Are you able to share a core dump of the crash? We have ways to share them privately if that is a concern\r\n\r\nUnfortunately I cannot. \r\nIf we will be able to reproduce it in small test app, I will provide a crash dump.\r\n\r\nBTW the mentioned NRE probably is race condition between our call of `EventSource.Dispose()` and `DisposeOnShutdown()` called by `OnProcessExit()`, so now we just clearing the global EventSource list by Reflection.\r\n\r\nAnd we still have similar CRASH problem on stage when `prometheus-net.DotNetRuntime` begins to subscribe for Events, but the app is in the process of shutting down.\r\n\r\n",
                                           "updatedAt":  "2023-03-15T06:31:13Z"
                                       }
                                   ],
                         "totalCount":  7
                     },
        "title":  "Rare race condition in EventSource dispose/finalizer",
        "labels":  [
                       "area-Tracing-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/57517",
        "createdAt":  "2021-08-16T18:33:22Z",
        "number":  57517,
        "author":  "Tohron",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2022-05-17T23:14:17Z",
        "body":  "### Description\r\n\r\nWhen doing a 3.1 run with perfcollect active, the trace file does not contain any Startup/EEStartupStart, Startup/MainStart or Startup/MainStop events, as it should.  Instead, it contains a list of Startup/SecurityCatchCallStart events.\r\n\r\n### Configuration\r\n\r\nThis was tested using perfcollect with a run of 3.1.412, and compared to results with perfcollect for a 6.0 run.\r\n\r\n### Other information\r\n\r\nThis is blocking https://github.com/dotnet/performance/issues/1894, since the lack of MainStart events prevents the collection of performance information that is used in the 3.1.4 performance pipeline run.\r\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHONa7GgA==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc41rsaA",
                                           "createdAt":  "2021-08-17T21:34:01Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "josalem",
                                           "body":  "These events weren\u0027t fired in 3.1 for non-Windows due to the macro that fires them being nulled out for non-Windows platforms.\r\n\r\nThere was a PR in 5.0 (https://github.com/dotnet/runtime/pull/35737) that fixed this and enabled these events to be fired.",
                                           "updatedAt":  "2021-08-17T21:34:01Z"
                                       }
                                   ],
                         "totalCount":  1
                     },
        "title":  "Failure To Generate EEStartupStart, MainStart, or MainStop on 3.1 Runs",
        "labels":  [
                       "enhancement",
                       "tenet-performance",
                       "area-Tracing-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/57675",
        "createdAt":  "2021-08-18T18:07:09Z",
        "number":  57675,
        "author":  "Temp1ar",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOB25kgQ==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "evgn",
                                            "createdAt":  "2021-08-18T21:54:39Z"
                                        }
                                    ],
                          "totalCount":  1
                      },
        "updatedAt":  "2022-05-17T23:15:07Z",
        "body":  "\u003c!--This is just a template - feel free to delete any and all of it and replace as appropriate.--\u003e\r\n\r\n### Description\r\nI found that in some cases I get recursive frames of a method that can\u0027t be recursive.\r\nMinimal code example\r\n```\r\nusing System.Threading;\r\n\r\nnamespace RecursiveFinallyStackBug\r\n{\r\n  internal class Program\r\n  {\r\n    private static void A()\r\n    {\r\n      Thread.Sleep(1000);\r\n      var array = new byte[200_000]; // This is to trigger GC_AllocationTick event with incorrect call stack\r\n    }\r\n\r\n    private static void Main(string[] args)\r\n    {\r\n      try\r\n      {\r\n        Thread.Sleep(1000);\r\n        var array = new byte[100_000]; // This is to trigger GC_AllocationTick event with incorrect call stack\r\n      }\r\n      finally\r\n      {\r\n        A();\r\n      }\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nIf you profile this program with perfview you will find callstacks that contain two Main methods calling one another.\r\n![image](https://user-images.githubusercontent.com/1234294/129948683-94e4433c-5bf1-480b-9438-adc54cd78dc6.png)\r\n\r\nAs far as I understand, this happens if a method contains any `try/finally` block or a construct that unfolds into `try/finally` like `using()`\r\n\r\n\u003c!--\r\n* Please share a clear and concise description of the problem.\r\n* Include minimal steps to reproduce the problem if possible. E.g.: the smallest possible code snippet; or a small repo to clone, with steps to run it.\r\n* What behavior are you seeing, and what behavior would you expect?\r\n  --\u003e\r\n\r\n### Configuration\r\n\r\n* Which version of .NET is the code running on?\r\n\r\nLooks like this is an old problem which reproduces on .NET 4.5+ up until dotnet core 5.0\r\n\r\n* What OS and version, and what distro if applicable?\r\n\r\nWindows 10 x64.\r\n\r\n* What is the architecture (x64, x86, ARM, ARM64)?\r\n\r\nx64\r\n\r\n* Do you know whether it is specific to that configuration?\r\n\r\nDon\u0027t think so\r\n\r\n### Regression?\r\n\r\nThis is not a regression, I think I saw this since .NET Framework 4.5",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHONcTEXw==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc41uRSn",
                                           "createdAt":  "2021-08-18T18:07:11Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "I couldn\u0027t figure out the best area label to add to this issue. If you have write-permissions please help me learn by adding exactly one [area label](https://github.com/dotnet/runtime/blob/master/docs/area-owners.md).",
                                           "updatedAt":  "2021-08-18T18:07:11Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc41w4pM",
                                           "createdAt":  "2021-08-19T15:23:38Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tommcdon",
                                           "body":  "+ @brianrob @josalem   My guess is that there are 2 issues here.  The first is that the ```A()``` frame is being inlined into Main.  Adding MethodImplOptions.NoInlining to ```A()``` should cause the frame to show on the callstack.  Additionally it seems perfview is folding the Main method recursive call rather than displaying the stack. ",
                                           "updatedAt":  "2021-08-19T15:23:38Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc41xMRf",
                                           "createdAt":  "2021-08-19T17:06:08Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Temp1ar",
                                           "body":  "Hey @tommcdon.\r\nSorry, that wasn\u0027t good screenshot from PerfView. I made another one, which clear things up: \r\n* A() frame is in the right place. \r\n* No folding is applied. I found this bug looking on raw events from ETW. I\u0027m using PerfView just as a way to show/reproduce the problem.\r\n\r\n![image](https://user-images.githubusercontent.com/1234294/130112201-cd9080b4-9fa3-4afd-b60a-e06c94b74412.png)\r\n\r\nAlso configuration of providers to get proper events:\r\n![image](https://user-images.githubusercontent.com/1234294/130112476-48f8325f-afc3-4128-b18b-9a60f5a61629.png)\r\n",
                                           "updatedAt":  "2021-08-19T17:06:08Z"
                                       }
                                   ],
                         "totalCount":  3
                     },
        "title":  "ETW callstacks from .NET provider contain impossible recursive frames",
        "labels":  [
                       "question",
                       "area-Tracing-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/59439",
        "createdAt":  "2021-09-21T23:02:57Z",
        "number":  59439,
        "author":  "jander-msft",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2023-06-12T16:57:03Z",
        "body":  "\r\n### Description\r\n\r\nOn a non-Windows platform, while a runtime instance is suspended, issuing the GetProcessInfo command on the diagnostic pipe will only return the process name for the command line field. None of the command line parameters are provided.\r\n\r\n### Configuration\r\n\r\nAll non-Windows platforms, both .NET 5 and .NET 6.\r\n\r\n### Regression?\r\n\r\nNo, my understanding is that during suspension on non-Windows platforms, this field never provided the full command line.\r\n\r\n### Other information\r\n\r\nDuring suspension, the command line field in the GetProcessInfo response will be something like:\r\n\r\n`/__w/1/s/.dotnet/dotnet`\r\n\r\nIf the GetProcessInfo command is issued immediately after resuming the runtime, the same data is reported (only the process name).\r\n\r\nIf the GetProcessInfo command is issued sometime after the runtime is resumed and has run for a bit, then it returns the proper command line, e.g.:\r\n\r\n`/__w/1/s/.dotnet/dotnet /__w/1/s/artifacts/bin/Microsoft.Diagnostics.Monitoring.UnitTestApp/Release/net5.0/Microsoft.Diagnostics.Monitoring.UnitTestApp.dll AsyncWait`\r\n\r\ncc @josalem",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHONyi6mA==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc43Gf5S",
                                           "createdAt":  "2021-09-21T23:03:00Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-diagnostics-process\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n\r\n### Description\r\n\r\nOn a non-Windows platform, while a runtime instance is suspended, issuing the GetProcessInfo command on the diagnostic pipe will only return the process name for the command line field. None of the command line parameters are provided.\r\n\r\n### Configuration\r\n\r\nAll non-Windows platforms, both .NET 5 and .NET 6.\r\n\r\n### Regression?\r\n\r\nNo, my understanding is that during suspension on non-Windows platforms, this field never provided the full command line.\r\n\r\n### Other information\r\n\r\nDuring suspension, the command line field in the GetProcessInfo response will be something like:\r\n\r\n`/__w/1/s/.dotnet/dotnet`\r\n\r\nIf the GetProcessInfo command is issued immediately after resuming the runtime, the same data is reported (only the process name).\r\n\r\nIf the GetProcessInfo command is issued sometime after the runtime is resumed and has run for a bit, then it returns the proper command line, e.g.:\r\n\r\n`/__w/1/s/.dotnet/dotnet /__w/1/s/artifacts/bin/Microsoft.Diagnostics.Monitoring.UnitTestApp/Release/net5.0/Microsoft.Diagnostics.Monitoring.UnitTestApp.dll AsyncWait`\r\n\r\ncc @josalem\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003ejander-msft\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Diagnostics.Process`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2021-09-21T23:03:00Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc43KLqY",
                                           "createdAt":  "2021-09-23T00:08:43Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "josalem",
                                           "body":  "I took a look at the code paths for this and I think this unfortunately falling prey to the same ordering problems that the assembly name does, namely, part of command line resolution happens in the host. This means we are stuck waiting on the host to populate the command line.\r\n\r\nSpecifically, the runtime suspends in `EEStartupHelper` in ceemain.cpp, which gets called by `CorHost2::Start`, but the command line that we use doesn\u0027t get populated until `CorHost2::ExecuteAssembly` is called. I\u0027m not entirely sure why we have a partial population of the value while suspended honestly. I\u0027ll have to put it under a debugger and see when that value is being put there.\r\n\r\nThe main issue is that on non-Windows platforms, we _calculate_ the commandline rather than read it from some system API. The host is using the assembly path for the main assembly to generate it.",
                                           "updatedAt":  "2021-09-23T00:08:43Z"
                                       }
                                   ],
                         "totalCount":  2
                     },
        "title":  "Getting command line via diagnostic pipe GetProcessInfo command during suspension only reports process name",
        "labels":  [
                       "enhancement",
                       "area-Tracing-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/61492",
        "createdAt":  "2021-11-12T02:42:24Z",
        "number":  61492,
        "author":  "tommcdon",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2022-08-04T23:46:17Z",
        "body":  "HandleableCollectionClearItemsTest fails in CI with `Assert.Equal() Failure\\r\\nExpected: 1\\r\\nActual:   2`\r\n\r\n### Callstack\r\n\r\n```\r\n   at Microsoft.Diagnostics.NETCore.Client.HandleableCollectionTests.AddAndVerifyItems[T](HandleableCollection`1 collection, IEnumerable`1 itemsAndCounts) in /_/src/tests/Microsoft.Diagnostics.NETCore.Client/HandleableCollectionTests.cs:line 409\r\n   at Microsoft.Diagnostics.NETCore.Client.HandleableCollectionTests.HandleableCollectionClearItemsTest() in /_/src/tests/Microsoft.Diagnostics.NETCore.Client/HandleableCollectionTests.cs:line 323\r\n--- End of stack trace from previous location ---\r\n```\r\n\u003c!-- runfo report start --\u003e\r\nRunfo Tracking Issue: [handleablecollectionclearitemstest](https://runfo.azurewebsites.net/tracking/issue/220)\r\n|Build|Definition|Kind|Run Name|\r\n|---|---|---|---|\r\n\r\n\r\n\r\nBuild Result Summary\r\n|Day Hit Count|Week Hit Count|Month Hit Count|\r\n|---|---|---|\r\n|0|0|0|\r\n\r\n\u003c!-- runfo report end --\u003e\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOOZ_X3g==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc45n9eG",
                                           "createdAt":  "2021-11-12T02:47:49Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-collections\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nHandleableCollectionClearItemsTest fails in CI with `Assert.Equal() Failure\\r\\nExpected: 1\\r\\nActual:   2`\r\n\r\n### Callstack\r\n\r\n```\r\n   at Microsoft.Diagnostics.NETCore.Client.HandleableCollectionTests.AddAndVerifyItems[T](HandleableCollection`1 collection, IEnumerable`1 itemsAndCounts) in /_/src/tests/Microsoft.Diagnostics.NETCore.Client/HandleableCollectionTests.cs:line 409\r\n   at Microsoft.Diagnostics.NETCore.Client.HandleableCollectionTests.HandleableCollectionClearItemsTest() in /_/src/tests/Microsoft.Diagnostics.NETCore.Client/HandleableCollectionTests.cs:line 323\r\n--- End of stack trace from previous location ---\r\n```\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003etommcdon\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Collections`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2021-11-12T02:47:49Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc45n9fe",
                                           "createdAt":  "2021-11-12T02:48:03Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @tommcdon\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nHandleableCollectionClearItemsTest fails in CI with `Assert.Equal() Failure\\r\\nExpected: 1\\r\\nActual:   2`\r\n\r\n### Callstack\r\n\r\n```\r\n   at Microsoft.Diagnostics.NETCore.Client.HandleableCollectionTests.AddAndVerifyItems[T](HandleableCollection`1 collection, IEnumerable`1 itemsAndCounts) in /_/src/tests/Microsoft.Diagnostics.NETCore.Client/HandleableCollectionTests.cs:line 409\r\n   at Microsoft.Diagnostics.NETCore.Client.HandleableCollectionTests.HandleableCollectionClearItemsTest() in /_/src/tests/Microsoft.Diagnostics.NETCore.Client/HandleableCollectionTests.cs:line 323\r\n--- End of stack trace from previous location ---\r\n```\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003etommcdon\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-Diagnostics-coreclr`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2021-11-12T02:48:03Z"
                                       }
                                   ],
                         "totalCount":  2
                     },
        "title":  "HandleableCollectionClearItemsTest test failure",
        "labels":  [
                       "area-Tracing-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/61493",
        "createdAt":  "2021-11-12T02:57:57Z",
        "number":  61493,
        "author":  "tommcdon",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2024-03-25T23:15:17Z",
        "body":  "This is a tracking issue for test timeouts in the diagnostics repo \r\n\u003c!-- runfo report start --\u003e\r\nRunfo Tracking Issue: [The operation has timed out](https://runfo.azurewebsites.net/tracking/issue/221)\r\n|Build|Definition|Kind|Run Name|\r\n|---|---|---|---|\r\n\r\n\r\n\r\nBuild Result Summary\r\n|Day Hit Count|Week Hit Count|Month Hit Count|\r\n|---|---|---|\r\n|0|0|0|\r\n\r\n\u003c!-- runfo report end --\u003e\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOQYfvsQ==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5Bh--x",
                                           "createdAt":  "2022-04-14T17:14:12Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "josalem",
                                           "body":  "@tommcdon is this actually tracking anything or is it a test issue for runfo?",
                                           "updatedAt":  "2022-04-14T17:14:12Z"
                                       }
                                   ],
                         "totalCount":  1
                     },
        "title":  "The operation has timed out tracking issue",
        "labels":  [
                       "area-Tracing-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/64993",
        "createdAt":  "2022-02-08T16:52:32Z",
        "number":  64993,
        "author":  "richlander",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2022-06-21T21:22:18Z",
        "body":  "I\u0027m doing some performance analysis of .NET apps. I\u0027m working on Windows with PerfView, however this issue isn\u0027t intended to be Windows specific.\r\n\r\nI\u0027m new at doing performance analysis via our tools. Naively, I was expecting the following types of events to be available:\r\n\r\n- Process exe start\r\n- \"About to start managed main\"\r\n- App stack has gotten to some minimal state -- Examples:\r\n   - Windows Forms: Main Form activated\r\n   - WPF: Main page loaded\r\n   - ASP.NET Core: `app.run` called and server available\r\n- Application idle -- App has quiesced.\r\n- Application terminating\r\n\r\nNote: I did find the first one.\r\n\r\nIt is entirely possible that I\u0027m doing this wrong. It seems like basic performance analysis would be easier if these events existed and would compliment/compose nicely with custom events.\r\n\r\nIf these events make sense and we don\u0027t have them, do folks think we should start an effort to add them?",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOPiz9KQ==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc49j9u_",
                                           "createdAt":  "2022-02-08T16:52:35Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "I couldn\u0027t figure out the best area label to add to this issue. If you have write-permissions please help me learn by adding exactly one [area label](https://github.com/dotnet/runtime/blob/master/docs/area-owners.md).",
                                           "updatedAt":  "2022-02-08T16:52:35Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc49k2xO",
                                           "createdAt":  "2022-02-08T21:19:02Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCNsgUw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "richlander",
                                                                               "createdAt":  "2022-02-08T21:21:08Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "brianrob",
                                           "body":  "There is an event for \"about to start managed main\", which is located here: https://github.com/dotnet/runtime/blob/main/src/coreclr/vm/assembly.cpp#L1469.  It\u0027s not ideal as is because to turn it on, you have to turn on lots of other events, but it does work.  You must turn on the private provider, start-up keyword, and verbosity level of informational.  It would be worthwhile to see how many of these other events actually fire, since some of them look to me like they could be specific to .NET Framework, but I don\u0027t know that for sure.\r\n\r\nIf we need to do work here, we should add a new event to the public provider just prior to execution of main.",
                                           "updatedAt":  "2022-02-08T21:19:02Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc498f5e",
                                           "createdAt":  "2022-02-14T16:09:52Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tommcdon",
                                           "body":  "@noahfalk ",
                                           "updatedAt":  "2022-02-14T16:09:52Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc49_A4u",
                                           "createdAt":  "2022-02-15T07:09:33Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "noahfalk",
                                           "body":  "What I have done in the past is create a trivial EventSource and then instrument my example app to invoke them, but agreed that investigations would be easier if there were some events ready to go and it feels perfectly reasonable to ask for. Surprisingly @richlander you are the first person that I can recall to ask about it : ) @brianrob do you know if you or Vance got earlier requests for these types of events?\r\n\r\nFor Asp.Net there is an ILogger message [here](https://source.dot.net/#Microsoft.AspNetCore.Hosting/GenericHost/GenericWebHostedService.cs,143) but no strongly typed ETW event that I am aware of. For Kestrel specifically I assume you could look at the AcceptStart event for System.Net.Sockets (https://source.dot.net/#System.Net.Sockets/System/Net/Sockets/SocketsTelemetry.cs,54).\r\nIn my past investigations of ASP.Net there is a lot of work that occurs lazily when receiving the first request, so the first [RequestStop event](https://source.dot.net/#Microsoft.AspNetCore.Hosting/Internal/HostingEventSource.cs,62) might be more meaningful.\r\nI filed this issue: https://github.com/dotnet/aspnetcore/issues/40238\r\n\r\n- Do you guys know which devs are maintaining WinForms/WPF these days?\r\n\r\n- Application idle - this one seems ambiguous. I think some app models have tried to define this with heuristics and we could ask each app model to instrument the code that implements their definition of it, but I don\u0027t think there is a uniform definition we could apply that would get broad agreement.\r\n\r\n- Application terminating - typically I\u0027ve used the OS process exit event or I have a more explicit workload that I\u0027ve instrumented myself. I probably need more info on the scenario to understand what this one was intended to help measure.",
                                           "updatedAt":  "2022-02-15T07:09:33Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc4-IJcp",
                                           "createdAt":  "2022-02-16T21:23:13Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "brianrob",
                                           "body":  "I\u0027ve also done what you\u0027ve done in the past @noahfalk.  Vance and I haven\u0027t had other requests for this, but we have been the ones looking to request such things.  If I recall correctly, this just never came to the top of the priority list at the time.  I think overall, having some platform events to be able to measure reliably, especially for points in the app that occur in the platform, would be valuable.\r\n\r\nThat said, we don\u0027t always need to have a specific \"startup\" event - if we determine that something like AcceptStart is reasonable for web workloads, then that is OK for such scenarios.\r\n\r\n\u003e Do you guys know which devs are maintaining WinForms/WPF these days?\r\n\r\nWe can probably just file an issue in https://github.com/dotnet/winforms and https://github.com/dotnet/wpf.\r\n\r\n\u003e Application idle - this one seems ambiguous. \r\n\r\nAgreed that this is app type specific.  For example, I don\u0027t think of console apps as having an idle state.\r\n\r\n\u003e Application terminating\r\n\r\nI usually use OS process exit as well.  This one is interesting if we want to pay attention to runtime shutdown.  If we\u0027re going to do the exercise and add new events to be able to track app lifetime, this is probably worth having.  Usually runtime shutdown is fast, but I have run into cases where it is not.",
                                           "updatedAt":  "2022-02-16T21:23:29Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc4-IfwX",
                                           "createdAt":  "2022-02-16T23:40:40Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCPD5yA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "brianrob",
                                                                               "createdAt":  "2022-02-16T23:42:31Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "noahfalk",
                                           "body":  "Thanks @brianrob!\r\n\r\nWe\u0027ve now got:\r\nWPF - https://github.com/dotnet/wpf/issues/6138\r\nWinforms - https://github.com/dotnet/winforms/issues/6646\r\nASP.NET - https://github.com/dotnet/aspnetcore/issues/40238\r\n\r\n\u003e Usually runtime shutdown is fast, but I have run into cases where it is not.\r\n\r\nWhat do you think should define the beginning of app shutdown, after we\u0027ve returned from Main()?",
                                           "updatedAt":  "2022-02-16T23:40:40Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc4-If8O",
                                           "createdAt":  "2022-02-16T23:42:12Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "brianrob",
                                           "body":  "\u003e What do you think should define the beginning of app shutdown, after we\u0027ve returned from Main()?\r\n\r\nYes, I think that\u0027s right.  From there, everything else is pretty much runtime/process shutdown.",
                                           "updatedAt":  "2022-02-16T23:42:12Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc4-JfGL",
                                           "createdAt":  "2022-02-17T08:06:18Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "\u003e What do you think should define the beginning of app shutdown, after we\u0027ve returned from Main()?\r\n\r\nThat\u0027s over-simplification. The shutdown is app-model specific just like startup is app-model specific. Number of app models do a lot of (potentially asynchronous) work during shutdown before exiting Main. Some app models actually exit Main right away during startup and keeping the application running via non-background threads.\r\n\r\nFor Windows UI apps, the shutdown starts by user clicking the X for Windows UI apps. For container apps, the shutdown starts by the container orchestrator sending `SIGTERM` signal to the process.",
                                           "updatedAt":  "2022-02-17T08:06:18Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc4-KjdO",
                                           "createdAt":  "2022-02-17T13:33:25Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "noahfalk",
                                           "body":  "I agree that there are app-model specific definitions of shutdown too. For me it was more if Brian and Rich are the proxy for users wanting this capability, what is the scenario that they believe is interesting to measure? If they (or others) want to measure a wide variety of app-model specific definitions of shutdown I\u0027m happy to let folks enumerate all the situations they care about. Given that I\u0027d never seen any asks on the topic before, my default response was to start with a very simple proposal.",
                                           "updatedAt":  "2022-02-17T13:33:25Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc4-LP0p",
                                           "createdAt":  "2022-02-17T16:12:17Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "brianrob",
                                           "body":  "Yup, totally agree that not all apps will follow this pattern - depending on the apps we\u0027re looking at, we will need to select the right set of events for measurement.",
                                           "updatedAt":  "2022-02-17T16:12:17Z"
                                       }
                                   ],
                         "totalCount":  10
                     },
        "title":  "Default trace events for .NET app performance analysis",
        "labels":  [
                       "enhancement",
                       "area-Tracing-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/65570",
        "createdAt":  "2022-02-18T16:11:41Z",
        "number":  65570,
        "author":  "deeprobin",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2022-02-23T03:40:47Z",
        "body":  "Follow-up issue for #43657\r\n\r\n---\r\n\r\nAs described in https://github.com/dotnet/runtime/issues/63902, it would be good to remove comments and workarounds that have already been fixed.\r\n\r\nWould be great if someone would take another look at the following (and whether this can be removed or replaced with something better if necessary).\r\n\r\nhttps://github.com/dotnet/runtime/blob/f04a24249835096eea1a1a66e4af03cfec5ed32b/src/libraries/System.Private.CoreLib/src/System/Diagnostics/Tracing/NativeRuntimeEventSource.cs#L40-L44\r\n\r\n/area System.Diagnostics.Tracing",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  null,
                         "nodes":  [

                                   ],
                         "totalCount":  0
                     },
        "title":  "Reconsider tracing functionality when EventSource is disabled",
        "labels":  [
                       "area-Tracing-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/66174",
        "createdAt":  "2022-03-04T01:12:55Z",
        "number":  66174,
        "author":  "VincentBu",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2022-07-13T23:44:06Z",
        "body":  "Run: [runtime-coreclr outerloop 20220303.2](https://dev.azure.com/dnceng/public/_build/results?buildId=1643242\u0026view=ms.vss-test-web.build-test-results-tab\u0026runId=45433282\u0026resultId=110069\u0026paneView=debug)\r\n\r\nFailed test:\r\n```\r\nCoreCLR OSX x64 Checked no_tiered_compilation @ OSX.1200.Amd64.Open\r\n\r\n- profiler/eventpipe/eventpipe/eventpipe.sh\r\n\r\n```\r\n**Error message:**\r\n```\r\ncmdLine:/private/tmp/helix/working/C5030A0F/w/B5FB0987/e/profiler/eventpipe/eventpipe/eventpipe.sh Timed Out (timeout in milliseconds: 600000 from variable __TestTimeout, start: 3/3/2022 12:33:40 PM, end: 3/3/2022 12:43:41 PM)\r\n\r\nReturn code:      -100\r\nRaw output file:      /tmp/helix/working/C5030A0F/w/B5FB0987/uploads/Reports/profiler.eventpipe/eventpipe/eventpipe.output.txt\r\nRaw output:\r\nBEGIN EXECUTION\r\n/tmp/helix/working/C5030A0F/p/corerun -p System.Reflection.Metadata.MetadataUpdater.IsSupported=false eventpipe.dll \u0027\u0027\r\nProfiler path: /private/tmp/helix/working/C5030A0F/w/B5FB0987/e/profiler/eventpipe/eventpipe/libProfiler.dylib\r\nProfiler.dll!DllGetClassObject\r\nProfiler.dll!Profiler::Initialize\r\nThis method being jitted should trigger events firing...\r\n\r\ncmdLine:/private/tmp/helix/working/C5030A0F/w/B5FB0987/e/profiler/eventpipe/eventpipe/eventpipe.sh Timed Out (timeout in milliseconds: 600000 from variable __TestTimeout, start: 3/3/2022 12:33:40 PM, end: 3/3/2022 12:43:41 PM)\r\nTest Harness Exitcode is : -100\r\nTo run the test:\r\n\r\nset CORE_ROOT=/tmp/helix/working/C5030A0F/p\r\n/private/tmp/helix/working/C5030A0F/w/B5FB0987/e/profiler/eventpipe/eventpipe/eventpipe.sh\r\nExpected: True\r\nActual:   False\r\n\r\n\r\nStack trace\r\n   at profiler_eventpipe._eventpipe_eventpipe_._eventpipe_eventpipe_sh()\r\n```",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOQ1F3Jw==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc4_JaR2",
                                           "createdAt":  "2022-03-04T18:56:11Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "BruceForstall",
                                           "body":  "This timeout is pervasive: Kusto data shows that it happens in many pipelines, but mostly on osx/x64.\r\n\r\n@dotnet/area-system-diagnostics-tracing ",
                                           "updatedAt":  "2022-03-04T18:56:11Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc4_TxYe",
                                           "createdAt":  "2022-03-08T19:55:28Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "fanyang-mono",
                                           "body":  "This happened again for rolling build #20220308.1 on `CoreCLR Pri0 Runtime Tests Run OSX x64 checked`. The link to the log is https://helixre8s23ayyeko0k025g8.blob.core.windows.net/dotnet-runtime-refs-heads-main-a1a9de6e17b849f196/profiler.eventpipe/1/console.1158da49.log?sv=2019-07-07\u0026se=2022-03-28T09%3A24%3A17Z\u0026sr=c\u0026sp=rl\u0026sig=Xqtq4mBksJ5vn2SeQpc00q9oqntl2GhaHPQ5vDmaJAM%3D",
                                           "updatedAt":  "2022-03-08T19:55:28Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc4_Yit5",
                                           "createdAt":  "2022-03-09T21:39:28Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "agocke",
                                           "body":  "This is now blocking the runtime builds as well @tommcdon could someone take a look asap?",
                                           "updatedAt":  "2022-03-09T21:39:28Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc4_Ytoi",
                                           "createdAt":  "2022-03-09T22:34:44Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tommcdon",
                                           "body":  "@agocke  taking a look",
                                           "updatedAt":  "2022-03-09T22:34:44Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc4_ZE58",
                                           "createdAt":  "2022-03-10T01:05:13Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "BruceForstall",
                                           "body":  "Here\u0027s where it started failing for the nightly scheduled jitstress run:\r\n\r\nhttps://dev.azure.com/dnceng/public/_build/results?buildId=1644509\u0026view=ms.vss-test-web.build-test-results-tab\r\n\r\n",
                                           "updatedAt":  "2022-03-10T01:05:13Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc4_d2z0",
                                           "createdAt":  "2022-03-11T05:39:56Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "hoyosjs",
                                           "body":  "There\u0027s a few families of errors in here. Most of them were old and targeted to specific PR\u0027s \r\n\r\nThere\u0027s this:\r\n```\r\nProcess terminated. Infinite recursion during resource lookup within System.Private.CoreLib.  This may be a bug in System.Private.CoreLib, or potentially in certain extensibility points such as assembly resolve events or CultureInfo names.  Resource name: Arg_NullReferenceException\r\n   at System.Environment.FailFast(System.String)\r\n   at System.SR.InternalGetResourceString(System.String)\r\n   at System.SR.GetResourceString(System.String)\r\n   at System.NullReferenceException..ctor()\r\n   at System.Char.IsWhiteSpaceLatin1(Char)\r\n   at System.Resources.ResourceManager.IsDefaultType(System.String, System.String)\r\n   at System.Resources.ManifestBasedResourceGroveler.CanUseDefaultResourceClasses(System.String, System.String)\r\n   at System.Resources.ManifestBasedResourceGroveler.CreateResourceSet(System.IO.Stream, System.Reflection.Assembly)\r\n   at System.Resources.ManifestBasedResourceGroveler.GrovelForResourceSet(System.Globalization.CultureInfo, System.Collections.Generic.Dictionary`2\u003cSystem.String,System.Resources.ResourceSet\u003e, Boolean, Boolean)\r\n   at System.Resources.ResourceManager.InternalGetResourceSet(System.Globalization.CultureInfo, Boolean, Boolean)\r\n   at System.Resources.ResourceManager.GetString(System.String, System.Globalization.CultureInfo)\r\n   at System.SR.InternalGetResourceString(System.String)\r\n   at System.SR.GetResourceString(System.String)\r\n   at System.NullReferenceException..ctor()\r\n   at System.Char.IsWhiteSpaceLatin1(Char)\r\n   at System.MemoryExtensions.Trim(System.ReadOnlySpan`1\u003cChar\u003e)\r\n   at System.Guid.TryParseGuid(System.ReadOnlySpan`1\u003cChar\u003e, GuidResult ByRef)\r\n   at System.Guid..ctor(System.String)\r\n   at EventPipeTests.EventPipe..cctor()\r\n   at EventPipeTests.EventPipe.Main(System.String[])\r\n```\r\n\r\nThese type of simd asserts that have been reported elsewhere: \r\n```\r\nAssert failure(PID 12180 [0x00002f94], Thread: 12222 [0x2fbe]): Assertion failed \u0027IsBaselineSimdIsaSupportedDebugOnly()\u0027 in \u0027Microsoft.Diagnostics.Tracing.EventPipeEventSource:CheckForWellKnownEventFields(Microsoft.Diagnostics.Tracing.EventPipeEventMetaDataHeader):PayloadFetchClassInfo:this\u0027 during \u0027Morph - Inlining\u0027 (IL size 492; hash 0x78e35964; FullOpts)\r\n```\r\n\r\nAll the ones that come from the profiler test itself are timeouts in OSX, regardless of jit modes. \r\n\r\n",
                                           "updatedAt":  "2022-03-11T05:39:56Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc4_geZY",
                                           "createdAt":  "2022-03-11T20:15:38Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "BruceForstall",
                                           "body":  "@hoyosjs Why did you remove the \"blocking-outerloop\" label? Unless this test has been fixed or disabled, it is, indeed, blocking clean outerloop test runs.",
                                           "updatedAt":  "2022-03-11T20:15:38Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc4_jY-b",
                                           "createdAt":  "2022-03-14T01:21:34Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "VincentBu",
                                           "body":  "Failed again in: [runtime-coreclr jitstress-isas-x86 20220312.1\r\n](https://dev.azure.com/dnceng/public/_build/results?buildId=1660479\u0026view=ms.vss-test-web.build-test-results-tab\u0026runId=45714288\u0026paneView=debug\u0026resultId=110073)\r\n\r\nFailed test:\r\n```\r\nCoreCLR OSX x64 Checked jitstress_isas_nohwintrinsic_nosimd @ OSX.1200.Amd64.Open\r\n\r\n- profiler/eventpipe/eventpipe/eventpipe.sh\r\n\r\nCoreCLR OSX x64 Checked jitstress_isas_x86_nosse @ OSX.1200.Amd64.Open\r\n\r\n- profiler/eventpipe/eventpipe/eventpipe.sh\r\n\r\nCoreCLR OSX x64 Checked jitstress_isas_nohwintrinsic @ OSX.1200.Amd64.Open\r\n\r\n- profiler/eventpipe/eventpipe/eventpipe.sh\r\n\r\nCoreCLR OSX x64 Checked jitstress_isas_x86_nolzcnt @ OSX.1200.Amd64.Open\r\n\r\n- profiler/eventpipe/eventpipe/eventpipe.sh\r\n\r\nCoreCLR OSX x64 Checked jitstress_isas_x86_nohwintrinsic @ OSX.1200.Amd64.Open\r\n\r\n- profiler/eventpipe/eventpipe/eventpipe.sh\r\n\r\nCoreCLR OSX x64 Checked jitstress_isas_x86_noaes @ OSX.1200.Amd64.Open\r\n\r\n- profiler/eventpipe/eventpipe/eventpipe.sh\r\n\r\nCoreCLR OSX x64 Checked jitstress_isas_x86_nofma @ OSX.1200.Amd64.Open\r\n\r\n- profiler/eventpipe/eventpipe/eventpipe.sh\r\n```\r\n**Error message:**\r\n```\r\ncmdLine:/private/tmp/helix/working/B50109A6/w/B95809E4/e/profiler/eventpipe/eventpipe/eventpipe.sh Timed Out (timeout in milliseconds: 1800000 from variable __TestTimeout, start: 3/12/2022 1:34:43 PM, end: 3/12/2022 2:04:43 PM)\r\n\r\nReturn code:      -100\r\nRaw output file:      /tmp/helix/working/B50109A6/w/B95809E4/uploads/Reports/profiler.eventpipe/eventpipe/eventpipe.output.txt\r\nRaw output:\r\nBEGIN EXECUTION\r\n/tmp/helix/working/B50109A6/p/corerun -p System.Reflection.Metadata.MetadataUpdater.IsSupported=false eventpipe.dll \u0027\u0027\r\nProfiler path: /private/tmp/helix/working/B50109A6/w/B95809E4/e/profiler/eventpipe/eventpipe/libProfiler.dylib\r\nProfiler.dll!DllGetClassObject\r\nProfiler.dll!Profiler::Initialize\r\nThis method being jitted should trigger events firing...\r\n\r\ncmdLine:/private/tmp/helix/working/B50109A6/w/B95809E4/e/profiler/eventpipe/eventpipe/eventpipe.sh Timed Out (timeout in milliseconds: 1800000 from variable __TestTimeout, start: 3/12/2022 1:34:43 PM, end: 3/12/2022 2:04:43 PM)\r\nTest Harness Exitcode is : -100\r\nTo run the test:\r\n\r\nset CORE_ROOT=/tmp/helix/working/B50109A6/p\r\n/private/tmp/helix/working/B50109A6/w/B95809E4/e/profiler/eventpipe/eventpipe/eventpipe.sh\r\nExpected: True\r\nActual:   False\r\n\r\n\r\nStack trace\r\n   at profiler_eventpipe._eventpipe_eventpipe_._eventpipe_eventpipe_sh()\r\n```",
                                           "updatedAt":  "2022-03-14T01:32:19Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc4_l7vg",
                                           "createdAt":  "2022-03-14T15:00:53Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "fanyang-mono",
                                           "body":  "Should the test be disabled for now? I saw this being hit on rolling build quite often.",
                                           "updatedAt":  "2022-03-14T15:00:53Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc4_n42D",
                                           "createdAt":  "2022-03-14T23:53:50Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "BruceForstall",
                                           "body":  "Note: this test was disabled in #66606. Re-enable when fixing/closing this issue.",
                                           "updatedAt":  "2022-03-14T23:53:50Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5DUXcn",
                                           "createdAt":  "2022-05-17T23:21:39Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tommcdon",
                                           "body":  "@davmason  PTAL",
                                           "updatedAt":  "2022-05-17T23:21:39Z"
                                       }
                                   ],
                         "totalCount":  11
                     },
        "title":  "Test failure profiler/eventpipe/eventpipe/eventpipe.sh",
        "labels":  [
                       "disabled-test",
                       "os-mac-os-x",
                       "area-Tracing-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/71644",
        "createdAt":  "2022-07-05T15:37:07Z",
        "number":  71644,
        "author":  "pharring",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-07-15T18:18:24Z",
        "body":  "Nuget’s symbol server requires clients to know up-front the [SHA256 hash of the PDB they’re requesting](https://github.com/NuGet/NuGetGallery/issues/8354) -- not just the usual PDB signature stuff (because that’s too weak, cryptographically). The SHA256 hash is included in the [PE header\u0027s debug directory](https://github.com/dotnet/corefx/blob/master/src/System.Reflection.Metadata/specs/PE-COFF.md#pdb-checksum-debug-directory-entry-type-19). If you’re working with a live process or a dump, you can read the relevant debug directory out of the loaded module\u0027s PE header. However, if you’re starting with a perf trace, you don’t have it.\r\n\r\nThe [Loader\u0027s ModuleDCStart and ModuleDCStop events](https://docs.microsoft.com/en-us/dotnet/framework/performance/loader-etw-events#module-events) include the \"CodeView\" PDB signature and age. Could we augment that event to emit the new checksum algorithm and value -- possibly enabled via a new keyword for backwards compatibility?",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOaAa2UA==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5GNGp8",
                                           "createdAt":  "2022-07-07T15:55:57Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tommcdon",
                                           "body":  "@pharring I\u0027ve put this issue into .net 8 however please let me know if this is something blocking you and is needed for .net 7",
                                           "updatedAt":  "2022-07-07T15:55:57Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5VQqPC",
                                           "createdAt":  "2023-02-14T21:59:22Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @agocke, @vitek-karas, @vsadov\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nNuget’s symbol server requires clients to know up-front the [SHA256 hash of the PDB they’re requesting](https://github.com/NuGet/NuGetGallery/issues/8354) -- not just the usual PDB signature stuff (because that’s too weak, cryptographically). The SHA256 hash is included in the [PE header\u0027s debug directory](https://github.com/dotnet/corefx/blob/master/src/System.Reflection.Metadata/specs/PE-COFF.md#pdb-checksum-debug-directory-entry-type-19). If you’re working with a live process or a dump, you can read the relevant debug directory out of the loaded module\u0027s PE header. However, if you’re starting with a perf trace, you don’t have it.\r\n\r\nThe [Loader\u0027s ModuleDCStart and ModuleDCStop events](https://docs.microsoft.com/en-us/dotnet/framework/performance/loader-etw-events#module-events) include the \"CodeView\" PDB signature and age. Could we augment that event to emit the new checksum algorithm and value -- possibly enabled via a new keyword for backwards compatibility?\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003epharring\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`enhancement`, `area-Single-File`, `area-Tracing-coreclr`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e8.0.0\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-02-14T21:59:22Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5VQqa1",
                                           "createdAt":  "2023-02-14T22:00:07Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "pharring",
                                           "body":  "Sorry. Mis-keyed the tag (area-Single-File) please ignore.",
                                           "updatedAt":  "2023-02-14T22:00:07Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5gFHBV",
                                           "createdAt":  "2023-06-28T19:13:23Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "pharring",
                                           "body":  "Hey, @tommcdon is this going to happen for .NET 8?",
                                           "updatedAt":  "2023-06-28T19:13:23Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5oBrZQ",
                                           "createdAt":  "2023-10-03T15:58:15Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "pharring",
                                           "body":  "Without this, we are unable to \"go to source\" for assemblies like Newtonsoft.json which are open-source on github.com and publish their PDBs to nuget\u0027s symbol server. You can do it if you have a memory dump (because then you have the full PE header with the SHA256 checksum), but not from a performance trace (ETL).",
                                           "updatedAt":  "2023-10-03T15:58:15Z"
                                       }
                                   ],
                         "totalCount":  5
                     },
        "title":  "Request: Add PDB checksum (type 19) to ModuleDCStart/ModuleDCStop events",
        "labels":  [
                       "enhancement",
                       "area-Tracing-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/72322",
        "createdAt":  "2022-07-16T18:09:32Z",
        "number":  72322,
        "author":  "k15tfu",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2022-08-01T18:04:23Z",
        "body":  "Same as https://github.com/dotnet/runtime/issues/2067, but it wasn\u0027t fixed for .NET Core 3.1 which is still supported. Is it possible?\r\n\r\nLinux ARM32",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOR5331A==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5GtNOK",
                                           "createdAt":  "2022-07-16T18:09:34Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "I couldn\u0027t figure out the best area label to add to this issue. If you have write-permissions please help me learn by adding exactly one [area label](https://github.com/dotnet/runtime/blob/master/docs/area-owners.md).",
                                           "updatedAt":  "2022-07-16T18:09:34Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5GyJaw",
                                           "createdAt":  "2022-07-18T14:18:06Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tommcdon",
                                           "body":  "Hi @k15tfu End of support for .NET Core 3.1 is in December 2022.  The fix should already be in our latest .NET release, would it be possible to try it on .NET 6?  ",
                                           "updatedAt":  "2022-07-18T14:18:06Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5GyJqM",
                                           "createdAt":  "2022-07-18T14:18:30Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "This issue has been marked `needs-author-action` and may be missing some important information.",
                                           "updatedAt":  "2022-07-18T14:18:30Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Hk5FZ",
                                           "createdAt":  "2022-08-01T08:01:26Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "k15tfu",
                                           "body":  "@tommcdon Hi! Sorry for the late reply. Yes, it works in .NET 6 and .NET 7 preview, the issue is about the possibility to backport it to .NET Core 3.1.",
                                           "updatedAt":  "2022-08-01T08:01:26Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5HnffU",
                                           "createdAt":  "2022-08-01T18:04:23Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tommcdon",
                                           "body":  "@k15tfu Thanks for the response!  According to https://dotnet.microsoft.com/en-us/download/dotnet, .NET Core 3.1 support ends on 12/13/2022.  Given that we are about 4 months from the end of support, would it be possible to upgrade to .NET 6 where the fix already exists?  ",
                                           "updatedAt":  "2022-08-01T18:04:23Z"
                                       }
                                   ],
                         "totalCount":  5
                     },
        "title":  "Bus error when parsing EventPipeProviderConfiguration in .NET Core 3.1",
        "labels":  [
                       "area-Tracing-coreclr",
                       "needs-further-triage"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/72324",
        "createdAt":  "2022-07-16T20:01:54Z",
        "number":  72324,
        "author":  "am11",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2022-07-18T14:20:44Z",
        "body":  "See https://github.com/dotnet/runtime/pull/72314#discussion_r922707395.\r\nThere are typos in some event names which maybe causing issues in collecting the data. `DestoryGCHandle` (correction: `DestroyGCHandle`) for instance looks like a dead event due to the typo as everything else in C++ code refers to it with correct spelling.\r\n\r\nHere is the patch for manifest for reference which is reverted in the PR: \r\n```diff\r\n--- a/src/coreclr/vm/ClrEtwAll.man\r\n+++ b/src/coreclr/vm/ClrEtwAll.man\r\n@@ -7483,7 +7483,7 @@\r\n                             \u003copcode name=\"GCHeapDumpObjectReference\" message=\"$(string.MonoProfilerPublisher.GCHeapDumpObjectReferenceOpcodeMessage)\" symbol=\"CLR_MONO_PROFILER_GC_HEAP_DUMP_OBJECT_REFERENCE_OPCODE\" value=\"70\" /\u003e\r\n                             \u003copcode name=\"MonitorContention\" message=\"$(string.MonoProfilerPublisher.MonitorContentionOpcodeMessage)\" symbol=\"CLR_MONO_PROFILER_MONITOR_CONTENTION_OPCODE\" value=\"71\" /\u003e\r\n                             \u003copcode name=\"MonitorFailed\" message=\"$(string.MonoProfilerPublisher.MonitorFailedOpcodeMessage)\" symbol=\"CLR_MONO_PROFILER_MONITOR_FAILED_OPCODE\" value=\"72\" /\u003e\r\n-                            \u003copcode name=\"MonitorAquired\" message=\"$(string.MonoProfilerPublisher.MonitorAquiredOpcodeMessage)\" symbol=\"CLR_MONO_PROFILER_MONITOR_AQUIRED_OPCODE\" value=\"73\" /\u003e\r\n+                            \u003copcode name=\"MonitorAcquired\" message=\"$(string.MonoProfilerPublisher.MonitorAcquiredOpcodeMessage)\" symbol=\"CLR_MONO_PROFILER_MONITOR_AQUIRED_OPCODE\" value=\"73\" /\u003e\r\n                             \u003copcode name=\"ThreadStarted\" message=\"$(string.MonoProfilerPublisher.ThreadStartedOpcodeMessage)\" symbol=\"CLR_MONO_PROFILER_THREAD_STARTED_OPCODE\" value=\"74\" /\u003e\r\n                             \u003copcode name=\"ThreadStopping\" message=\"$(string.MonoProfilerPublisher.ThreadStoppingOpcodeMessage)\" symbol=\"CLR_MONO_PROFILER_THREAD_STOPPING_OPCODE\" value=\"75\" /\u003e\r\n                             \u003copcode name=\"ThreadStopped\" message=\"$(string.MonoProfilerPublisher.ThreadStoppedOpcodeMessage)\" symbol=\"CLR_MONO_PROFILER_THREAD_STOPPED_OPCODE\" value=\"76\" /\u003e\r\n@@ -8282,7 +8282,7 @@\r\n                            symbol=\"MonoProfilerMonitorFailed\" message=\"$(string.MonoProfilerPublisher.MonitorContentionFailedAcquiredEventMessage)\" /\u003e\r\n \r\n                     \u003cevent value=\"56\" version=\"0\" level=\"win:Informational\"  template=\"MonitorContentionFailedAcquired\"\r\n-                           keywords =\"MonitorKeyword\" opcode=\"MonitorAquired\"\r\n+                           keywords =\"MonitorKeyword\" opcode=\"MonitorAcquired\"\r\n                            task=\"MonoProfiler\"\r\n                            symbol=\"MonoProfilerMonitorAcquired\" message=\"$(string.MonoProfilerPublisher.MonitorContentionFailedAcquiredEventMessage)\" /\u003e\r\n \r\n@@ -9148,7 +9148,7 @@\r\n                 \u003cstring id=\"RuntimePublisher.StatsOpcodeMessage\" value=\"Stats\" /\u003e\r\n                 \u003cstring id=\"RuntimePublisher.ModuleRangeLoadOpcodeMessage\" value=\"ModuleRangeLoad\" /\u003e\r\n                 \u003cstring id=\"RuntimePublisher.SetGCHandleOpcodeMessage\" value=\"SetGCHandle\" /\u003e\r\n-                \u003cstring id=\"RuntimePublisher.DestroyGCHandleOpcodeMessage\" value=\"DestoryGCHandle\" /\u003e\r\n+                \u003cstring id=\"RuntimePublisher.DestroyGCHandleOpcodeMessage\" value=\"DestroyGCHandle\" /\u003e\r\n                 \u003cstring id=\"RuntimePublisher.TriggeredOpcodeMessage\" value=\"Triggered\" /\u003e\r\n                 \u003cstring id=\"RuntimePublisher.PinObjectAtGCTimeOpcodeMessage\" value=\"PinObjectAtGCTime\" /\u003e\r\n                 \u003cstring id=\"RuntimePublisher.IncreaseMemoryPressureOpcodeMessage\" value=\"IncreaseMemoryPressure\" /\u003e\r\n@@ -9241,7 +9241,7 @@\r\n                 \u003cstring id=\"PrivatePublisher.BGCAllocWaitEndOpcodeMessage\" value=\"BGCAllocWaitStop\" /\u003e\r\n                 \u003cstring id=\"PrivatePublisher.FinalizeObjectOpcodeMessage\" value=\"FinalizeObject\" /\u003e\r\n                 \u003cstring id=\"PrivatePublisher.SetGCHandleOpcodeMessage\" value=\"SetGCHandle\" /\u003e\r\n-                \u003cstring id=\"PrivatePublisher.DestroyGCHandleOpcodeMessage\" value=\"DestoryGCHandle\" /\u003e\r\n+                \u003cstring id=\"PrivatePublisher.DestroyGCHandleOpcodeMessage\" value=\"DestroyGCHandle\" /\u003e\r\n                 \u003cstring id=\"PrivatePublisher.PinPlugAtGCTimeOpcodeMessage\" value=\"PinPlugAtGCTime\" /\u003e\r\n                 \u003cstring id=\"PrivatePublisher.CCWRefCountChangeOpcodeMessage\" value=\"CCWRefCountChange\" /\u003e\r\n                 \u003cstring id=\"PrivatePublisher.EEStartupStartOpcodeMessage\" value=\"EEStartupStart\" /\u003e\r\n@@ -9434,7 +9434,7 @@\r\n \r\n                 \u003cstring id=\"MonoProfilerPublisher.MonitorContentionOpcodeMessage\" value=\"MonitorContention\" /\u003e\r\n                 \u003cstring id=\"MonoProfilerPublisher.MonitorFailedOpcodeMessage\" value=\"MonitorFailed\" /\u003e\r\n-                \u003cstring id=\"MonoProfilerPublisher.MonitorAquiredOpcodeMessage\" value=\"MonitorAquired\" /\u003e\r\n+                \u003cstring id=\"MonoProfilerPublisher.MonitorAcquiredOpcodeMessage\" value=\"MonitorAcquired\" /\u003e\r\n \r\n                 \u003cstring id=\"MonoProfilerPublisher.ThreadStartedOpcodeMessage\" value=\"ThreadStarted\" /\u003e\r\n                 \u003cstring id=\"MonoProfilerPublisher.ThreadStoppingOpcodeMessage\" value=\"ThreadStopping\" /\u003e\r\ndiff --git a/src/coreclr/vm/amd64/JitHelpers_Fast.asm b/src/coreclr/vm/amd64/JitHelpers_Fast.asm\r\n```",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHORrUw3Q==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5GtS_G",
                                           "createdAt":  "2022-07-16T20:01:59Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "I couldn\u0027t figure out the best area label to add to this issue. If you have write-permissions please help me learn by adding exactly one [area label](https://github.com/dotnet/runtime/blob/master/docs/area-owners.md).",
                                           "updatedAt":  "2022-07-16T20:01:59Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5GtTDd",
                                           "createdAt":  "2022-07-16T20:03:14Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @tommcdon\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nSee https://github.com/dotnet/runtime/pull/72314#discussion_r922707395.\r\nThere are typos in some event names which maybe causing issues in collecting the data. `DestoryGCHandle` (correction: `DestroyGCHandle`) for instance looks like a dead event due to the typo as everything else in C++ code refers to it with correct spelling.\r\n\r\nHere is the patch for manifest for reference which is reverted in the PR: \r\n```diff\r\n--- a/src/coreclr/vm/ClrEtwAll.man\r\n+++ b/src/coreclr/vm/ClrEtwAll.man\r\n@@ -7483,7 +7483,7 @@\r\n                             \u003copcode name=\"GCHeapDumpObjectReference\" message=\"$(string.MonoProfilerPublisher.GCHeapDumpObjectReferenceOpcodeMessage)\" symbol=\"CLR_MONO_PROFILER_GC_HEAP_DUMP_OBJECT_REFERENCE_OPCODE\" value=\"70\" /\u003e\r\n                             \u003copcode name=\"MonitorContention\" message=\"$(string.MonoProfilerPublisher.MonitorContentionOpcodeMessage)\" symbol=\"CLR_MONO_PROFILER_MONITOR_CONTENTION_OPCODE\" value=\"71\" /\u003e\r\n                             \u003copcode name=\"MonitorFailed\" message=\"$(string.MonoProfilerPublisher.MonitorFailedOpcodeMessage)\" symbol=\"CLR_MONO_PROFILER_MONITOR_FAILED_OPCODE\" value=\"72\" /\u003e\r\n-                            \u003copcode name=\"MonitorAquired\" message=\"$(string.MonoProfilerPublisher.MonitorAquiredOpcodeMessage)\" symbol=\"CLR_MONO_PROFILER_MONITOR_AQUIRED_OPCODE\" value=\"73\" /\u003e\r\n+                            \u003copcode name=\"MonitorAcquired\" message=\"$(string.MonoProfilerPublisher.MonitorAcquiredOpcodeMessage)\" symbol=\"CLR_MONO_PROFILER_MONITOR_AQUIRED_OPCODE\" value=\"73\" /\u003e\r\n                             \u003copcode name=\"ThreadStarted\" message=\"$(string.MonoProfilerPublisher.ThreadStartedOpcodeMessage)\" symbol=\"CLR_MONO_PROFILER_THREAD_STARTED_OPCODE\" value=\"74\" /\u003e\r\n                             \u003copcode name=\"ThreadStopping\" message=\"$(string.MonoProfilerPublisher.ThreadStoppingOpcodeMessage)\" symbol=\"CLR_MONO_PROFILER_THREAD_STOPPING_OPCODE\" value=\"75\" /\u003e\r\n                             \u003copcode name=\"ThreadStopped\" message=\"$(string.MonoProfilerPublisher.ThreadStoppedOpcodeMessage)\" symbol=\"CLR_MONO_PROFILER_THREAD_STOPPED_OPCODE\" value=\"76\" /\u003e\r\n@@ -8282,7 +8282,7 @@\r\n                            symbol=\"MonoProfilerMonitorFailed\" message=\"$(string.MonoProfilerPublisher.MonitorContentionFailedAcquiredEventMessage)\" /\u003e\r\n \r\n                     \u003cevent value=\"56\" version=\"0\" level=\"win:Informational\"  template=\"MonitorContentionFailedAcquired\"\r\n-                           keywords =\"MonitorKeyword\" opcode=\"MonitorAquired\"\r\n+                           keywords =\"MonitorKeyword\" opcode=\"MonitorAcquired\"\r\n                            task=\"MonoProfiler\"\r\n                            symbol=\"MonoProfilerMonitorAcquired\" message=\"$(string.MonoProfilerPublisher.MonitorContentionFailedAcquiredEventMessage)\" /\u003e\r\n \r\n@@ -9148,7 +9148,7 @@\r\n                 \u003cstring id=\"RuntimePublisher.StatsOpcodeMessage\" value=\"Stats\" /\u003e\r\n                 \u003cstring id=\"RuntimePublisher.ModuleRangeLoadOpcodeMessage\" value=\"ModuleRangeLoad\" /\u003e\r\n                 \u003cstring id=\"RuntimePublisher.SetGCHandleOpcodeMessage\" value=\"SetGCHandle\" /\u003e\r\n-                \u003cstring id=\"RuntimePublisher.DestroyGCHandleOpcodeMessage\" value=\"DestoryGCHandle\" /\u003e\r\n+                \u003cstring id=\"RuntimePublisher.DestroyGCHandleOpcodeMessage\" value=\"DestroyGCHandle\" /\u003e\r\n                 \u003cstring id=\"RuntimePublisher.TriggeredOpcodeMessage\" value=\"Triggered\" /\u003e\r\n                 \u003cstring id=\"RuntimePublisher.PinObjectAtGCTimeOpcodeMessage\" value=\"PinObjectAtGCTime\" /\u003e\r\n                 \u003cstring id=\"RuntimePublisher.IncreaseMemoryPressureOpcodeMessage\" value=\"IncreaseMemoryPressure\" /\u003e\r\n@@ -9241,7 +9241,7 @@\r\n                 \u003cstring id=\"PrivatePublisher.BGCAllocWaitEndOpcodeMessage\" value=\"BGCAllocWaitStop\" /\u003e\r\n                 \u003cstring id=\"PrivatePublisher.FinalizeObjectOpcodeMessage\" value=\"FinalizeObject\" /\u003e\r\n                 \u003cstring id=\"PrivatePublisher.SetGCHandleOpcodeMessage\" value=\"SetGCHandle\" /\u003e\r\n-                \u003cstring id=\"PrivatePublisher.DestroyGCHandleOpcodeMessage\" value=\"DestoryGCHandle\" /\u003e\r\n+                \u003cstring id=\"PrivatePublisher.DestroyGCHandleOpcodeMessage\" value=\"DestroyGCHandle\" /\u003e\r\n                 \u003cstring id=\"PrivatePublisher.PinPlugAtGCTimeOpcodeMessage\" value=\"PinPlugAtGCTime\" /\u003e\r\n                 \u003cstring id=\"PrivatePublisher.CCWRefCountChangeOpcodeMessage\" value=\"CCWRefCountChange\" /\u003e\r\n                 \u003cstring id=\"PrivatePublisher.EEStartupStartOpcodeMessage\" value=\"EEStartupStart\" /\u003e\r\n@@ -9434,7 +9434,7 @@\r\n \r\n                 \u003cstring id=\"MonoProfilerPublisher.MonitorContentionOpcodeMessage\" value=\"MonitorContention\" /\u003e\r\n                 \u003cstring id=\"MonoProfilerPublisher.MonitorFailedOpcodeMessage\" value=\"MonitorFailed\" /\u003e\r\n-                \u003cstring id=\"MonoProfilerPublisher.MonitorAquiredOpcodeMessage\" value=\"MonitorAquired\" /\u003e\r\n+                \u003cstring id=\"MonoProfilerPublisher.MonitorAcquiredOpcodeMessage\" value=\"MonitorAcquired\" /\u003e\r\n \r\n                 \u003cstring id=\"MonoProfilerPublisher.ThreadStartedOpcodeMessage\" value=\"ThreadStarted\" /\u003e\r\n                 \u003cstring id=\"MonoProfilerPublisher.ThreadStoppingOpcodeMessage\" value=\"ThreadStopping\" /\u003e\r\ndiff --git a/src/coreclr/vm/amd64/JitHelpers_Fast.asm b/src/coreclr/vm/amd64/JitHelpers_Fast.asm\r\n```\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eam11\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-Diagnostics-coreclr`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-07-16T20:03:14Z"
                                       }
                                   ],
                         "totalCount":  2
                     },
        "title":  "Review CLR ETW manifest for typos",
        "labels":  [
                       "area-Tracing-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/76704",
        "createdAt":  "2022-10-06T04:50:54Z",
        "number":  76704,
        "author":  "wiktork",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2023-05-17T20:47:26Z",
        "body":  "### Description\n\nEventPipe events that are generated in a small batch with no subsequent events cannot be read in real-time by TraceEvent. \r\n\r\nEventPipe events periodically get a timestamp. This timestamp informs TraceEvent that events that it has received so far can be ordered and dispatched. However, events after this timestamp are cached and are not dispatched until another timed event occurs. \r\n\r\nThis is described at [here](https://github.com/dotnet/runtime/blob/9d6396deb02161f5ee47af72ccac52c2e1bae458/src/native/eventpipe/ep-buffer-manager.c#L1203). \r\n\r\nThe TraceEvent logic that caches events that are not timestamped is at [here](https://github.com/microsoft/perfview/blob/a70bb00cc9b00ef225b9e35e52c7c61956647f61/src/TraceEvent/EventPipe/EventCache.cs#L83).\r\n\r\n@noahfalk @davmason \n\n### Reproduction Steps\n\nCreate an app that generates custom events similar to:\r\n\r\n``` c#\r\nusing System.Diagnostics.Tracing;\r\n\r\nTestEventSource s = new TestEventSource();\r\n\r\nwhile (true)\r\n{\r\n    Console.ReadLine();\r\n  \r\n    for (int i = 0; i \u003c 10; i++)\r\n    {\r\n        s.TestEvent(i);\r\n    }\r\n\r\n}\r\n\r\n[EventSource(Name = \"TestProvider\")]\r\nclass TestEventSource : EventSource\r\n{\r\n    public void TestEvent(int id) =\u003e WriteEvent(1, id);\r\n}\r\n```\r\n\r\nCreate an app that consumes these events in realtime:\r\n\r\n``` c#\r\nProcess[]? processes = null;\r\nwhile (processes?.Length != 1)\r\n{\r\n    processes = Process.GetProcessesByName(\"EventPipeRepro\");\r\n    await Task.Delay(100);\r\n}\r\n\r\nint counter = 0;\r\n\r\nDiagnosticsClient client = new DiagnosticsClient(processes.First().Id);\r\nvar session = client.StartEventPipeSession(new[]{\r\n      new EventPipeProvider(\"TestProvider\", System.Diagnostics.Tracing.EventLevel.Verbose, (long)TraceEventKeyword.All),\r\nSystem.Diagnostics.Tracing.EventLevel.Verbose},\r\n      false);\r\n\r\n  \r\n  \r\n  var source = new EventPipeEventSource(session.EventStream);\r\n\r\n  source.Dynamic.All += (e) =\u003e\r\n  {\r\n      if (e.ProviderName == \"TestProvider\")\r\n      {\r\n          Console.WriteLine($\"{counter++} {e.EventName} {e.PayloadString(0)}\");\r\n      }\r\n      else\r\n      {\r\n          Console.WriteLine($\"{e.ProviderName} {e.EventName}\");\r\n      }\r\n  };\r\n  source.Process();\r\n```\n\n### Expected behavior\n\nEvery time events are generated the reader should be able to see all of them.\n\n### Actual behavior\n\nThe reader typically sees 1 event. The remaining events can only be seen once another run of events is generated. \n\n### Regression?\n\nNo\n\n### Known Workarounds\n\nOne of the events that is generated must be delayed so that it gets timestamped.\n\n### Configuration\n\nWindows x64 .net 6 console app for both reader and writer. The issue is not configuration specific. \n\n### Other information\n\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOXIKf7g==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5cgp_u",
                                           "createdAt":  "2023-05-17T20:47:26Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tommcdon",
                                           "body":  "@wiktork we are reviewing remaining work for 8.0 and have punted this one based off of remaining time.  Please let us know if we should re-evaluate.",
                                           "updatedAt":  "2023-05-17T20:47:26Z"
                                       }
                                   ],
                         "totalCount":  1
                     },
        "title":  "EventPipe events cannot always be read in realtime.",
        "labels":  [
                       "enhancement",
                       "area-Tracing-coreclr",
                       "feature-request"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/81987",
        "createdAt":  "2023-02-11T00:30:32Z",
        "number":  81987,
        "author":  "davmason",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2023-05-17T21:57:51Z",
        "body":  "Right now the code in EventProvider always sends an Update command to EventSource.\r\n\r\nSee here: https://github.com/dotnet/runtime/blob/221b69fd48142ebc252348850c2527df90826538/src/libraries/System.Private.CoreLib/src/System/Diagnostics/Tracing/EventProvider.cs#L210-L274\r\n\r\nDepending on the values of perEventSourceSessionId or isEnabled it is translated to an Enable or Disable command in EventSource.DoCommand: https://github.com/dotnet/runtime/blob/221b69fd48142ebc252348850c2527df90826538/src/libraries/System.Private.CoreLib/src/System/Diagnostics/Tracing/EventSource.cs#L2601-L2614\r\n\r\nAs far as I can tell there is no reason for this complicated scheme, and we could just send Enable/Disable from EventProvider in the first place. We should investigate and either refactor/simplify the code, or document why it\u0027s necessary to do it this way.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  null,
                         "nodes":  [

                                   ],
                         "totalCount":  0
                     },
        "title":  "Refactor EventSource/EventProvider command scheme so it is more understandable",
        "labels":  [
                       "enhancement",
                       "area-Tracing-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/82423",
        "createdAt":  "2023-02-16T04:59:44Z",
        "number":  82423,
        "author":  "nxtn-staged",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2023-05-17T21:52:39Z",
        "body":  "### Description\r\n\r\nWhen received from EventPipe, the byte array payload written with `WriteEvent(int eventId, byte[]? arg1)` or `WriteEvent(int eventId, long arg1, byte[]? arg2)` is incorrect.\r\n\r\n### Steps to reproduce\r\n\r\n1. Add project files\r\n\r\n```csproj\r\n\u003cProject Sdk=\"Microsoft.NET.Sdk\"\u003e\r\n\r\n  \u003cPropertyGroup\u003e\r\n    \u003cOutputType\u003eExe\u003c/OutputType\u003e\r\n    \u003cTargetFramework\u003enet7.0\u003c/TargetFramework\u003e\r\n  \u003c/PropertyGroup\u003e\r\n\r\n  \u003cItemGroup\u003e\r\n    \u003cPackageReference Include=\"Microsoft.Diagnostics.NETCore.Client\" Version=\"0.2.351802\" /\u003e\r\n    \u003cPackageReference Include=\"Microsoft.Diagnostics.Tracing.TraceEvent\" Version=\"3.0.7\" /\u003e\r\n  \u003c/ItemGroup\u003e\r\n\r\n\u003c/Project\u003e\r\n```\r\n\r\n```cs\r\nusing System;\r\nusing System.Diagnostics.Tracing;\r\nusing Microsoft.Diagnostics.NETCore.Client;\r\nusing Microsoft.Diagnostics.Tracing;\r\n\r\nvar array = Convert.FromHexString(\"010203\");\r\n\r\n_ = new DemoEventListener();\r\n\r\nvar provider = new EventPipeProvider(\"Demo\", EventLevel.Informational);\r\nvar client = new DiagnosticsClient(Environment.ProcessId);\r\n\r\nusing var session = client.StartEventPipeSession(provider, false);\r\nusing var source = new EventPipeEventSource(session.EventStream);\r\n\r\nsource.Dynamic.AddCallbackForProviderEvent(\"Demo\", null, obj =\u003e Console.WriteLine($\"{obj.EventName} from EventPipe    : {Convert.ToHexString((byte[])obj.PayloadByName(\"array\"))}\"));\r\n\r\nvar eventSource = new DemoEventSource();\r\neventSource.ByteArray(array);\r\n\r\nsource.Process();\r\n\r\nclass DemoEventListener : EventListener\r\n{\r\n    protected override void OnEventSourceCreated(EventSource eventSource)\r\n    {\r\n        if (eventSource.Name == \"Demo\")\r\n        {\r\n            this.EnableEvents(eventSource, EventLevel.Informational);\r\n        }\r\n    }\r\n\r\n    protected override void OnEventWritten(EventWrittenEventArgs eventData)\r\n    {\r\n        Console.WriteLine($\"{eventData.EventName} from EventListener: {Convert.ToHexString((byte[])eventData.Payload[1])}\");\r\n    }\r\n}\r\n\r\nclass DemoEventSource : EventSource\r\n{\r\n    public DemoEventSource() : base(\"Demo\")\r\n    {\r\n    }\r\n\r\n    public void ByteArray(byte[] array)\r\n    {\r\n        this.WriteEvent(1, array);\r\n    }\r\n\r\n    // This works.\r\n    public void ByteArrayAsObject(byte[] array)\r\n    {\r\n        this.WriteEvent(2, (object)array);\r\n    }\r\n}\r\n```\r\n\r\n2. `dotnet run`\r\n\r\n### Expected behavior\r\n\r\n```\r\nByteArray from EventListener: 010203\r\nByteArray from EventPipe    : 010203\r\n```\r\n\r\n### Actual behavior\r\n\r\n```\r\nByteArray from EventListener: 010203\r\nByteArray from EventPipe    : 000000\r\n```\r\n\r\n### Configuration\r\n\r\n\u003cdetails\u003e\r\n\u003csummary\u003e\r\ndotnet --info\r\n\u003c/summary\u003e\r\n.NET SDK:\r\n Version:   7.0.200-preview.22628.1\r\n Commit:    76bbaffad6\r\n\r\nRuntime Environment:\r\n OS Name:     Windows\r\n OS Version:  10.0.22621\r\n OS Platform: Windows\r\n RID:         win10-x64\r\n Base Path:   C:\\Program Files\\dotnet\\sdk\\7.0.200-preview.22628.1\\\r\n\r\nHost:\r\n  Version:      7.0.0\r\n  Architecture: x64\r\n  Commit:       d099f075e4\r\n\r\n.NET SDKs installed:\r\n  7.0.100 [C:\\Program Files\\dotnet\\sdk]\r\n  7.0.200-preview.22628.1 [C:\\Program Files\\dotnet\\sdk]\r\n\r\n.NET runtimes installed:\r\n  Microsoft.AspNetCore.App 6.0.12 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.AspNetCore.App 7.0.0 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.NETCore.App 6.0.12 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 7.0.0 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.WindowsDesktop.App 6.0.12 [C:\\Program Files\\dotnet\\shared\\Microsoft.WindowsDesktop.App]\r\n  Microsoft.WindowsDesktop.App 7.0.0 [C:\\Program Files\\dotnet\\shared\\Microsoft.WindowsDesktop.App]\r\n\r\nOther architectures found:\r\n  x86   [C:\\Program Files (x86)\\dotnet]\r\n    registered at [HKLM\\SOFTWARE\\dotnet\\Setup\\InstalledVersions\\x86\\InstallLocation]\r\n\r\nEnvironment variables:\r\n  Not set\r\n\r\nglobal.json file:\r\n  Not found\r\n\r\nLearn more:\r\n  https://aka.ms/dotnet/info\r\n\r\nDownload .NET:\r\n  https://aka.ms/dotnet/download\r\n\u003c/details\u003e",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOXIO3MA==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5VuHfz",
                                           "createdAt":  "2023-02-21T09:35:38Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "hoyosjs",
                                           "body":  "cc: @davmason @dramos020 ",
                                           "updatedAt":  "2023-02-21T09:35:38Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5WHdif",
                                           "createdAt":  "2023-02-25T00:27:21Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOC2wL6Q==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "nxtn-staged",
                                                                               "createdAt":  "2023-02-25T16:33:00Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "davmason",
                                           "body":  "Thanks @nxtn-staged for reporting this. I can reproduce the problem and I believe it is an issue with metadata generation for EventPipe with byte[]. We don\u0027t emit the right event metadata so when we parse the event we fail to read the byte[] even though it is written to the event stream correctly. I am working on a fix.",
                                           "updatedAt":  "2023-02-25T00:27:21Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5WX_fJ",
                                           "createdAt":  "2023-03-01T00:27:20Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "davmason",
                                           "body":  "@brianrob @noahfalk after looking at this there are two issues. The first is the metadata issue I mentioned above which is a trivial fix, but even once we start emitting metadata for the event correctly, it will not be parsed by TraceEvent correctly.\r\n\r\nWe special case byte[] for manifest EventSources as the win:Binary type, which is encoded as a 4 byte length and then the raw bytes after. EventPipe and self describing EventSources use 2 byte lengths for arrays/enumerables so the byte[] is parsed incorrectly.\r\n\r\nIn ETW we read the manifest and special case the parsing, but we don\u0027t have the manifest available in a nettrace file. I see two paths forward\r\n1. Special case the writing of byte[] in manifest EventSources so it writes a 2 byte length for byte[] on EventPipe and a 4 byte length for ETW \r\n2. Add a new typecode to the nettrace event metadata equivalent to the win:Binary type and emit it for byte[] on manifest EventSources\r\n\r\nI\u0027m leaning towards option 2. It requires changes to TraceEvent and the runtime but both changes would be small.\r\n\r\nOption 1 would be nice because it is a self contained fix in the runtime, but there are many places where we special case byte[] already and the current architecture doesn\u0027t allow us to cleanly write different data for EventPipe and ETW - we generate one set of descriptors/data and expect it to work for both. We could add some special logic in WriteEventTransfer to massage the data, but that feels kludgy.\r\n\r\nThoughts?",
                                           "updatedAt":  "2023-03-01T00:27:20Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5WpESr",
                                           "createdAt":  "2023-03-03T14:23:02Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "noahfalk",
                                           "body":  "\u003e Add a new typecode to the nettrace event metadata equivalent to the win:Binary type and emit it for byte[] on manifest EventSources\r\n\r\nWhat happens when a tool that doesn\u0027t have the updated version of TraceEvent attempts to read metadata containing the new typecode? Can we insert it into the format in a way that doesn\u0027t cause existing readers to behave any worse than they already do?",
                                           "updatedAt":  "2023-03-03T14:23:02Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5cg7cw",
                                           "createdAt":  "2023-05-17T21:52:38Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tommcdon",
                                           "body":  "After careful consideration, we do not plan to action this particular item in this release.  This likely requires a changes to the tracevent file format and update the consumers of the tracevent.  Given the amount of time left in .NET 8 we have decided to move this to \"Future\".  We will continue to evaluate it for future releases. Ideally, we would like to fix every issue and implement every idea people submit. Realistically, we cannot address every item.  ",
                                           "updatedAt":  "2023-05-17T21:52:38Z"
                                       }
                                   ],
                         "totalCount":  5
                     },
        "title":  "WriteEvent(Int32, Byte[]) not supported by EventPipe?",
        "labels":  [
                       "bug",
                       "area-Tracing-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/82524",
        "createdAt":  "2023-02-23T14:33:05Z",
        "number":  82524,
        "author":  "verdie-g",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2023-02-25T02:58:52Z",
        "body":  "This issue probably applies to other things than perf but it\u0027s what I mainly use.\r\n\r\nWhen using perf on a .NET process, you\u0027ll get such symbols\r\n```\r\nclass [System.Runtime]System.Threading.Tasks.Task`1\u003cint32\u003e [Test] Program::AsyncVoidMethodChild1(valuetype [System.Runtime]System.ValueTuple`2\u003cint32,class [System.Collections]System.Collections.Generic.List`1\u003cstring\u003e\u003e)[MinOptJitted]\r\n```\r\n\r\nSpotting the method name (`AsyncVoidMethodChild1` here) can be challenging which doesn\u0027t help analysis the perf result.\r\n\r\nI\u0027ve tried building [the regex to parse a symbol](https://regex101.com/r/jO86jx/15) but it\u0027s very challenging because it seems like there a lot of inconsistencies. \r\n\r\nWould it possible to somehow have cleaned .NET symbols? For example above that would give\r\n```\r\nSystem.Threading.Tasks.Task\u003cint32\u003e Program.AsyncVoidMethodChild1((int32, System.Collections.Generic.List\u003cstring\u003e))\r\n```\r\nOr alternatively, have a consistence mangling so it can be parsed.\r\n\r\nWhat do I mean by inconsistent? Here are some examples:\r\n```\r\nvoid [Test] DummyWork::Consume(!!0\u0026)[MinOptJitted]\r\n```\r\nWhat\u0027s `!!0` ?\r\n\r\n```\r\ninstance void [Criteo.KeyValueStore] Criteo.KeyValueStore.Storage.BucketStorage+\u003cSdk-Interfaces-KeyValueStore-IAsyncStorage-GetAsync\u003ed__16::MoveNext()[OptimizedTier1]\r\n```\r\nwhy is `-` used\r\n\r\n```\r\ninstance bool [System.Private.CoreLib] System.Collections.Generic.List`1+Enumerator[System.__Canon]::MoveNext()[OptimizedTier1]\r\n```\r\nGeneric for the parent is \u00271 and doesn\u0027t specify the types, generic for the child class doesn\u0027t use \u00271 but brackets and what is `System.__Canon`.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOVfUNFg==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5V9Bd7",
                                           "createdAt":  "2023-02-23T16:20:09Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "teo-tsirpanis",
                                           "body":  "Have you tried https://github.com/benaadams/Ben.Demystifier ?",
                                           "updatedAt":  "2023-02-23T16:20:09Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5V9Q0W",
                                           "createdAt":  "2023-02-23T17:01:37Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOC2xWqw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "jodydonetti",
                                                                               "createdAt":  "2023-02-23T17:49:45Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "jkoritzinsky",
                                                                               "createdAt":  "2023-02-23T18:07:02Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "AaronRobinsonMSFT",
                                                                               "createdAt":  "2023-02-26T17:15:48Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  3
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "It\u0027s worth noting that this isn\u0027t done by C# and isn\u0027t necessarily \"mangling\" per say.\r\n\r\nThis is rather the IL names as represented in metadata. `!!0` and `+` is simply the symbols used to represent type parameters by index and nested types.\r\n\r\nSince .NET is language agnostic and supports many languages (C#, F#, VB, C++/CLI, etc) it can\u0027t necessarily express these in terms of C#, particularly since some concepts are not expressible in C#.\r\n\r\nThere are some places where the language does emit \"unspeakable\" names (identifiers which can\u0027t be represented in C#), but those are typically for internal implementation details on how something may actually work behind the scenes (such as `fixed sized buffers` or a type used to hold `captured variables` for a lambda expression). Since such names are typically not part of the \"public surface area\", they may not have a strictly well-defined format and may change over time",
                                           "updatedAt":  "2023-02-23T17:02:31Z"
                                       }
                                   ],
                         "totalCount":  2
                     },
        "title":  "C# mangling affects troubleshooting",
        "labels":  [
                       "enhancement",
                       "area-Tracing-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/82939",
        "createdAt":  "2023-03-03T12:33:39Z",
        "number":  82939,
        "author":  "vaind",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHODK7Few==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "cleptric",
                                            "createdAt":  "2023-03-03T17:44:41Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "phacops",
                                            "createdAt":  "2023-03-06T14:32:02Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "mattjohnsonpint",
                                            "createdAt":  "2023-03-06T18:09:38Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "bruno-garcia",
                                            "createdAt":  "2023-03-06T19:46:32Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "JonasBa",
                                            "createdAt":  "2023-03-06T19:47:06Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "AbhiPrasad",
                                            "createdAt":  "2023-03-06T19:48:35Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "markushi",
                                            "createdAt":  "2023-03-06T21:58:38Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "joaopgrassi",
                                            "createdAt":  "2023-03-06T22:12:28Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "indragiek",
                                            "createdAt":  "2023-03-06T22:36:04Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "bitsandfoxes",
                                            "createdAt":  "2023-03-08T17:26:41Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "d-bucur",
                                            "createdAt":  "2025-06-17T19:05:34Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "lolleko",
                                            "createdAt":  "2025-08-12T19:41:43Z"
                                        }
                                    ],
                          "totalCount":  12
                      },
        "updatedAt":  "2023-11-25T20:00:07Z",
        "body":  "## Background and Motivation\r\n\r\n`Microsoft-DotNETCore-SampleProfiler` currently samples at a fixed rate of 1 ms, defined in [`ep-sample-profiler.c`](https://github.com/dotnet/runtime/blob/844702d736eef2fc456c1e4d89043fab6d054609/src/native/eventpipe/ep-sample-profiler.c#L19). In various situations, it would be beneficial to decrease the rate at which the samples are produced, thus lowering the profiling impact on the runtime.\r\n\r\n## Proposed Feature\r\n\r\nAllow configuring the sampling rate in nanoseconds (`_sampling_rate_in_ns`) as part of the session creation process, preferably before the sampling starts.\r\n\r\n## Usage Examples\r\n\r\nE.g. profiling in production, minimising the performance impact on the runtime.\r\n\r\nPreviously, this change was also mentioned in these (differently scoped) issues:\r\n* https://github.com/dotnet/runtime/issues/45518\r\n* https://github.com/dotnet/diagnostics/issues/1706#issuecomment-728277744",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHObNzLHw==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5Woik0",
                                           "createdAt":  "2023-03-03T12:33:51Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @tommcdon\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n## Background and Motivation\r\n\r\n`Microsoft-DotNETCore-SampleProfiler` currently samples at a fixed rate of 1 ms, defined in [`ep-sample-profiler.c`](https://github.com/dotnet/runtime/blob/844702d736eef2fc456c1e4d89043fab6d054609/src/native/eventpipe/ep-sample-profiler.c#L19). In various situations, it would be beneficial to decrease the rate at which the samples are produced, thus lowering the profiling impact on the runtime.\r\n\r\n## Proposed Feature\r\n\r\nAllow configuring the sampling rate as part of the session creation process, preferably before the sampling starts.\r\n\r\n## Usage Examples\r\n\r\nE.g. profiling in production, minimising the performance impact on the runtime.\r\n\r\nPreviously, this change was also mentioned in these (differently scoped) issues:\r\n* https://github.com/dotnet/runtime/issues/45518\r\n* https://github.com/dotnet/diagnostics/issues/1706#issuecomment-728277744\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003evaind\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-Diagnostics-coreclr`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-03-03T12:33:51Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5WrkNO",
                                           "createdAt":  "2023-03-03T23:30:04Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOC3LzdA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "tommcdon",
                                                                               "createdAt":  "2023-03-04T01:14:20Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "hoyosjs",
                                           "body":  "@tommcdon @davmason I didn\u0027t add a milestone, since I don\u0027t know if this can get into .NET 8 ",
                                           "updatedAt":  "2023-03-03T23:30:04Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Wr6Lp",
                                           "createdAt":  "2023-03-04T03:01:41Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "davmason",
                                           "body":  "Hi @vaind,\r\n\r\nThanks for reaching out and filing this issue. I agree that this is a good change and I would like to see it included in dotnet. I am not sure when the work would be scheduled though, and it likely wouldn\u0027t make it in for dotnet 8.\r\n\r\nThis is a good candidate for a motivated external developer to contribute. If you (or anyone reading this) is interested in contributing the steps are pretty straightforward.\r\n\r\nWe create the sample provider here: https://github.com/dotnet/runtime/blob/507acb66e51ccc8fbe5e95f2a07ec4e3280b330c/src/native/eventpipe/ep-sample-profiler.c#L214.\r\n\r\nThe callback signature looks like this: https://github.com/dotnet/runtime/blob/507acb66e51ccc8fbe5e95f2a07ec4e3280b330c/src/native/eventpipe/ep-types-forward.h#L180-L187\r\n\r\nThe filter_data argument is a list of optional key-value pairs the session can specify when enabling the provider. We can add a filter data argument `SampleProfilerIntervalMS`, if that is provided we can override the default sampling interval.\r\n\r\nWe would have the potential issue of multiple sessions specifying different overrides, but we can document that whatever the last one that is set is what we will use.",
                                           "updatedAt":  "2023-03-04T03:01:41Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5XVraY",
                                           "createdAt":  "2023-03-12T21:10:27Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODNX4rQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "bruno-garcia",
                                                                               "createdAt":  "2023-11-22T17:36:06Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "pedrobsaila",
                                           "body":  "Hey @davmason I would like to work on it. However I don\u0027t find docs that explain how to debug eventpipe. Can you give me some directions on how to do it on windows ?\r\nHere is what I tried :\r\n* SET DOTNET_EnableEventPipe=1\r\n* launched corerun.exe someApp.dll with VS\r\n\r\nBut VS could not find symbols.",
                                           "updatedAt":  "2023-03-12T21:57:28Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5XjbHG",
                                           "createdAt":  "2023-03-14T22:06:16Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "davmason",
                                           "body":  "Hi @pedrobsaila,\r\n\r\nThanks for reaching out! EventPipe is built in to the coreclr runtime so you can follow the instructions for building and debugging coreclr:\r\n* https://github.com/dotnet/runtime/tree/main/docs/workflow/building/coreclr\r\n* https://github.com/dotnet/runtime/blob/main/docs/workflow/debugging/coreclr/debugging-runtime.md\r\n\r\nTo debug the runtime itself requires native code debugging, so with VS you have to manually select the debugging engine to be native instead of managed, or you will debug the managed code in the app and not the runtime.\r\n\r\nIf you debug an app that is built via VS or dotnet build, you will be debugging the publicly available coreclr which is built in release mode and will have a poor debugging experience.  For symbols with a publicly release runtime you have to turn on the microsoft public symbol server in the debugging options-\u003esymbols in VS. \r\n\r\nThe better way to debug is to build a debug runtime locally and then publish your test app as \"self contained\" to a folder. For Windows it would be `dotnet publish -r win-x64 --self-contained\". Then you can patch the self contained folder with the output of your build and it will run on your locally built binaries, and debugging will be much better.",
                                           "updatedAt":  "2023-03-14T22:06:16Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5s3Msf",
                                           "createdAt":  "2023-11-25T20:00:06Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "bruno-garcia",
                                           "body":  "The PR #83635 was closed but there folks seemed to have agreed on a plan:\r\n\r\n* https://github.com/dotnet/runtime/pull/83635#issuecomment-1518486392\r\n\r\nWondering if this is ending up on a plan anytime soon? Would love to get lower overhead when profiling stuff",
                                           "updatedAt":  "2023-11-25T20:00:06Z"
                                       }
                                   ],
                         "totalCount":  6
                     },
        "title":  "Expose setting CPU SamplingProfiler rate",
        "labels":  [
                       "enhancement",
                       "help wanted",
                       "area-Tracing-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/83754",
        "createdAt":  "2023-03-21T22:02:20Z",
        "number":  83754,
        "author":  "LakshanF",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-08-19T21:43:27Z",
        "body":  "As part of exploring enabling the sample profiler in `NativeAOT`, I came across the `CoreCLR `[implementation ](https://github.com/dotnet/runtime/blob/main/src/coreclr/vm/eventing/eventpipe/ep-rt-coreclr.cpp#L144)and that seems relatively expensive. We suspend managed execution, [iterate over managed threads to get the stack information](https://github.com/dotnet/runtime/blob/main/src/coreclr/vm/eventing/eventpipe/ep-rt-coreclr.cpp#L99), and then resume execution. \r\n\r\nWrt `NativeAOT`, it might not be necessary for the runtime to provide this service and perhaps `NativeAOT `can get away with relying on platform profilers for this service.\r\n\r\nTalking over this with @VSadov, it seems worthwhile to explore less expensive ways to do this in `CoreCLR `when large numbers of threads are involved. \r\n\r\nFiling this issue to track the problem, relevant details of the call stack is copied in case its useful. \r\n\r\n```\r\n0:010\u003e kn\r\nChild-SP          RetAddr               Call Site\r\n05 00000026`d707fba0 00007ffd`3d4baf1e     coreclr!ep_rt_coreclr_sample_profiler_write_sampling_event_for_threads+0x5c [runtime\\src\\coreclr\\vm\\eventing\\eventpipe\\ep-rt-coreclr.cpp @ 159] \r\n06 00000026`d707fbd0 00007ffd`3d4c4ac0     coreclr!ep_rt_sample_profiler_write_sampling_event_for_threads+0x1e [runtime\\src\\coreclr\\vm\\eventing\\eventpipe\\ep-rt-coreclr.h @ 565] \r\n07 00000026`d707fc00 00007ffd`3d4bb3f2     coreclr!sampling_thread+0xe0 [runtime\\src\\native\\eventpipe\\ep-sample-profiler.c @ 101] \r\n08 00000026`d707fcf0 00007ffd`ec0c26bd     coreclr!ep_rt_thread_coreclr_start_func+0x32 [runtime\\src\\coreclr\\vm\\eventing\\eventpipe\\ep-rt-coreclr.h @ 813] \r\n09 00000026`d707fd40 00007ffd`edd0a9f8     KERNEL32!BaseThreadInitThunk+0x1d\r\n0a 00000026`d707fd70 00000000`00000000     ntdll!RtlUserThreadStart+0x28\r\n```",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOXIPgDw==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5Ya1al",
                                           "createdAt":  "2023-03-24T21:32:52Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "VSadov",
                                           "body":  "It was observed that when profiling concurrent workloads the effect of frequent runtime suspension alters the behavior of the application to the degree that it can\u0027t be considered the same scenario.\r\n\r\nThere are ways to make this much less intrusive by, for example, sending signals/APCs to the threads and perform sampling in the handlers. \r\nThis way the sampling will scale with the app and will not stand in the way of concurrency.\r\n",
                                           "updatedAt":  "2023-03-24T21:32:52Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5YbJyb",
                                           "createdAt":  "2023-03-24T22:28:46Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "alexrp",
                                           "body":  "\u003e There are ways to make this much less intrusive by, for example, sending signals\r\n\r\nI have a fair amount of experience in this area from my time maintaining Mono\u0027s log profiler (for Unix systems), where we did exactly this. I can share some insights here that might be useful for anyone doing work in this area:\r\n\r\n* At a certain point, regular signals (e.g. `SIGPROF`) are going to get throttled by the kernel.\r\n    * The kernel seems to prioritize delivery to the main thread.\r\n    * This can get so bad that you get little-to-literally-no data for some threads.\r\n    * The throttling is process-wide, so no matter what you do, this can\u0027t actually scale with number of threads.\r\n    * macOS seems to throttle much more aggressively than e.g. Linux.\r\n    * macOS doesn\u0027t allow you to `pthread_kill` GCD threads (`ESRCH`).\r\n* Real-time signals don\u0027t suffer from throttling.\r\n    * Some older Android versions don\u0027t support them properly (small `sigset_t`, incorrect `SIGRTMIN`/`SIGRTMAX`), but I doubt this is relevant today.\r\n    * They are not supported on macOS. AFAIK, thread suspension/resumption is still your best bet there.\r\n    * Spamming threads with RT signals is subject to similar issues to thread suspension/resumption, so should be done with care.\r\n    * An RT signal should be ack\u0027d before sending the next signal to prevent signal queue overflow (`EAGAIN`), which, in Mono\u0027s case, caused the whole STW machinery to break.\r\n* It is very difficult to write correct code in signal handlers.\r\n    * This is especially true when you need to perform a task as (relatively) complex as walking the stack at an arbitrary point and recording an arbitrary number of frames.\r\n    * On some platforms, profiling signals can arrive before a thread has even had a chance to initialize TLS, making TLS access in the handler unsafe. Coordination with the runtime\u0027s thread manager is required to avoid this.\r\n    * For loadable profilers (i.e. in `.so`/`.dylib`), it\u0027s important to load them with `RTLD_NOW`, since lazy symbol binding happening in a callback invoked from a signal handler can break horribly.",
                                           "updatedAt":  "2023-03-24T22:28:46Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Ybq4p",
                                           "createdAt":  "2023-03-25T01:02:18Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "VSadov",
                                           "body":  "@alexrp Thanks! This is very useful info.\r\n\r\nWe have seen some of these problems as a part of working on GC suspension, which is also based on signals, but some concerns are new - i.e. throttling. I guess GC suspension is just not frequent enough to suffer from that.\r\n\r\nMany concerns like signal safety are mitigated in GC suspension scenarios by the fact that we are only interested in stopping at safe points and that must be in managed code and in most cases at call sites. At safe points signal safety can be ignored as we know what managed code could or could not be doing. (can\u0027t be inside the kernel or holding malloc locks for example)\r\nPerhaps such constraint is acceptable. The current GC suspension-based tracing would have the same limitation anyways.\r\n\r\nThe throttling is a new concern though, although it must be already affecting the current suspension-based tracing, since signals are used (RT where available, ordinary signals otherwise).\r\n\r\nBasically - yes. It looks like it might be more challenging than it seems at first, but it also looks like all the concerns are applicable to the current approach, so it probably can\u0027t get worse than what it is today.\r\n\r\n",
                                           "updatedAt":  "2023-03-25T01:02:18Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5YcHPS",
                                           "createdAt":  "2023-03-25T08:36:44Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "alexrp",
                                           "body":  "\u003e We have seen some of these problems as a part of working on GC suspension, which is also based on signals, but some concerns are new - i.e. throttling. I guess GC suspension is just not frequent enough to suffer from that.\r\n\r\nThat sounds likely. In Mono we will opportunistically use RT signals for both GC and profiling if they are available, and fall back to regular signals if not.\r\n\r\n\u003e Many concerns like signal safety are mitigated in GC suspension scenarios by the fact that we are only interested in stopping at safe points and that must be in managed code and in most cases at call sites. At safe points signal safety can be ignored as we know what managed code could or could not be doing. (can\u0027t be inside the kernel or holding malloc locks for example)\r\nPerhaps such constraint is acceptable. The current GC suspension-based tracing would have the same limitation anyways.\r\n\r\nThat *might* be okay. It still makes me *super* nervous to do non-async-signal-safe stuff in a signal handler, but maybe it can work in practice under these controlled circumstances. You\u0027re essentially still relying on undefined behavior, though.\r\n\r\n\u003e The throttling is a new concern though, although it must be already affecting the current suspension-based tracing, since signals are used (RT where available, ordinary signals otherwise).\r\n\r\nI would assume that the throttling isn\u0027t necessarily a huge concern for suspension since you\u0027re likely to always make forward progress as long as you keep retrying the suspension signal on threads that haven\u0027t ack\u0027d it yet (in the non-RT-signal case). Sampling signals are more troublesome because you usually want a guaranteed X number of signals multiplied by Y number of threads per second, in order to get high quality data.",
                                           "updatedAt":  "2023-03-25T08:38:29Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5cg8pG",
                                           "createdAt":  "2023-05-17T21:55:44Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tommcdon",
                                           "body":  "After careful consideration, we do not plan to action this particular item in this release. We will continue to evaluate it for future releases. Ideally, we would like to fix every issue and implement every idea people submit. Realistically, we cannot address every item.  ",
                                           "updatedAt":  "2023-05-17T21:55:44Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5cg-AP",
                                           "createdAt":  "2023-05-17T22:02:29Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOC7-rNQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "tommcdon",
                                                                               "createdAt":  "2023-05-18T14:23:41Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "VSadov",
                                           "body":  "Makes sense. On the benefit/cost/risk scale this may not be the most urgent item to go after. ",
                                           "updatedAt":  "2023-05-17T22:02:29Z"
                                       }
                                   ],
                         "totalCount":  6
                     },
        "title":  "CoreCLR sample profiling seems expensive",
        "labels":  [
                       "enhancement",
                       "area-Tracing-coreclr",
                       "runtime-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/86086",
        "createdAt":  "2023-05-11T09:20:58Z",
        "number":  86086,
        "author":  "davmason",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2023-07-17T22:40:51Z",
        "body":  "\u003e This usage of PrepareCodeConfig looks suspicious. At JIT time we create an instance which gets [mutated](https://github.com/dotnet/runtime/blob/main/src/coreclr/vm/jitinterface.cpp#L6685) during the process of jitting. However those mutations aren\u0027t going to happen here because the JIT isn\u0027t being re-run. This means the optimization tier in config object may not accurately represent the true optimization level that was used when JIT happened.\r\n\u003e Looking at rundown, it looks like it is wrong there too or I don\u0027t understand something:\r\nhttps://github.com/dotnet/runtime/blob/main/src/coreclr/vm/eventtrace.cpp#L6685\r\n\r\n_Originally posted by @noahfalk in https://github.com/dotnet/runtime/pull/85801#discussion_r1185894442_\r\n            ",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  null,
                         "nodes":  [

                                   ],
                         "totalCount":  0
                     },
        "title":  "EventPipe/ETW/PerfMap rundown can report wrong optimization tier",
        "labels":  [
                       "area-Tracing-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/86103",
        "createdAt":  "2023-05-11T15:19:31Z",
        "number":  86103,
        "author":  "vaind",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOCyDrew==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "mattjohnsonpint",
                                            "createdAt":  "2023-06-06T18:12:14Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "bruno-garcia",
                                            "createdAt":  "2023-08-20T13:22:56Z"
                                        }
                                    ],
                          "totalCount":  2
                      },
        "updatedAt":  "2023-12-05T22:23:17Z",
        "body":  "I\u0027m trying to implement continuous profiler with Diagnostics IPC `StartEventPipeSession()`. The idea is to start a profiler when the app launches and only do sample-profiling of select parts of the application. O\r\n\r\nOriginally, I\u0027ve tried doing this by creating a new `EventPipeSession` each time I needed to profile some time span but the startup is pretty heavy (about 100 ms to start when the `Microsoft-DotNETCore-SampleProfiler` provider is included in the list). Therefore, I\u0027ve switched to starting the session at the beginning and subscribing to the `SampleProfilerTraceEventParser.ThreadSample` only for the time needed. This way, the overall overhead is reasonable (below 5 % from my testing) and the long session startup time doesn\u0027t affect actual operations, only the app startup (and can be made in the background).\r\n\r\n### Now to the issue at hand\r\n\r\nAs the samples are captured, I\u0027m trying to assign modules and methods. These are, however, only provided by the **rundown** provider when the session is being stopped. In my use-case, this would mean when the application is shut down. The relevant code is: \r\nhttps://github.com/dotnet/runtime/blob/1d5c424487c476831d9f98b1ca78b4fda6d18066/src/native/eventpipe/ep.c#L587-L604\r\n\r\nI wonder what the reason for this is and whether there is a way to trigger **rundown** right at the beginning of the session and then rely on **runtime** provider during the application lifetime to get updates.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHObcZqtQ==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5cCmp8",
                                           "createdAt":  "2023-05-11T15:19:38Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @tommcdon\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nI\u0027m trying to implement continuous profiler with Diagnostics IPC `StartEventPipeSession()`. The idea is to start a profiler when the app launches and only do sample-profiling of select parts of the application. O\r\n\r\nOriginally, I\u0027ve tried doing this by creating a new `EventPipeSession` each time I needed to profile some time span but the startup is pretty heavy (about 100 ms to start when the `Microsoft-DotNETCore-SampleProfiler` provider is included in the list). Therefore, I\u0027ve switched to starting the session at the beginning and subscribing to the `SampleProfilerTraceEventParser.ThreadSample` only for the time needed. This way, the overall overhead is reasonable (below 5 % from my testing) and the long session startup time doesn\u0027t affect actual operations, only the app startup (and can be made in the background).\r\n\r\n### Now to the issue at hand\r\n\r\nAs the samples are captured, I\u0027m trying to assign modules and methods. These are, however, only provided by the **rundown** provider when the session is being stopped. In my use-case, this would mean when the application is shut down. The relevant code is: \r\nhttps://github.com/dotnet/runtime/blob/1d5c424487c476831d9f98b1ca78b4fda6d18066/src/native/eventpipe/ep.c#L587-L604\r\n\r\nI wonder what the reason for this is and whether there is a way to trigger **rundown** right at the beginning of the session and then rely on **runtime** provider during the application lifetime to get updates.\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003evaind\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-Diagnostics-coreclr`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-05-11T15:19:38Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5cDI51",
                                           "createdAt":  "2023-05-11T16:43:56Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tommcdon",
                                           "body":  "@davmason @noahfalk ",
                                           "updatedAt":  "2023-05-11T16:43:56Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5cEy7Q",
                                           "createdAt":  "2023-05-11T22:14:11Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "davmason",
                                           "body":  "Hi @vaind,\r\n\r\nTo answer the question of why rundown behaves this way, it\u0027s because it was designed for the scenario where you take a trace and then do analysis later. It wasn\u0027t designed to do live processing and analysis of traces. This dates back many years to the desktop framework.\r\n\r\nHaving rundown happen at the beginning of the session is something we have thought about but so far other work items have taken priority. \r\n\r\nFor your scenario, a trace will continue to emit method and module events as they are loaded, so you could always work around by starting two sessions and immediately stopping one. The stopped session will give you rundown and then you can get future events from the ongoing session. ",
                                           "updatedAt":  "2023-05-11T22:14:11Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5cGmOH",
                                           "createdAt":  "2023-05-12T06:19:37Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "vaind",
                                           "body":  "Thanks @davmason, that\u0027s what I\u0027ve assumed. I\u0027ve also thought about that workaround but wasn\u0027t sure it would be alright and wouldn\u0027t miss anything important. Thanks for the confirmation it should work that way.\r\n\r\nAs you\u0027re saying you\u0027ve thought about having rundown at the beginning of the session (or maybe it could be triggered by an `EventPipeSession` method instead to provide greater flexibility), I guess this issue can stay open as a feature request?",
                                           "updatedAt":  "2023-05-12T06:19:37Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5cg87_",
                                           "createdAt":  "2023-05-17T21:57:12Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tommcdon",
                                           "body":  "After careful consideration, we do not plan to action this particular item in this release. We will continue to evaluate it for future releases. Ideally, we would like to fix every issue and implement every idea people submit. Realistically, we cannot address every item.  ",
                                           "updatedAt":  "2023-05-17T21:57:12Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5cjRpe",
                                           "createdAt":  "2023-05-18T08:58:28Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOC7-kjw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "tommcdon",
                                                                               "createdAt":  "2023-05-18T14:01:57Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "vaind",
                                           "body":  "Thanks for the update. Looking forward to this, whenever it does make the cut.",
                                           "updatedAt":  "2023-05-18T08:58:28Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5dMQyF",
                                           "createdAt":  "2023-05-25T20:55:18Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODObgcQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "bruno-garcia",
                                                                               "createdAt":  "2023-12-04T16:25:21Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "brianrob",
                                           "body":  "Given the streaming scenario for EventPipe, it would be good to keep this around and implement it in the future.  I don\u0027t imagine that it would take too much work to make it happen - likely just updating the callbacks in the runtime to allow EventPipe sources to trigger rundown (both start and stop).  Not sure what the corresponding change in Mono would be, but @lateralusX will know.",
                                           "updatedAt":  "2023-05-25T20:55:18Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5tnOuJ",
                                           "createdAt":  "2023-12-04T16:26:11Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "bruno-garcia",
                                           "body":  "@brianrob with the move towards NativeAOT, do we need to change Mono too?\r\n\r\n.NET 8 is out, any chance this can make it to .NET 9?",
                                           "updatedAt":  "2023-12-04T16:26:11Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5txmq1",
                                           "createdAt":  "2023-12-05T22:23:17Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODOnptA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "bruno-garcia",
                                                                               "createdAt":  "2023-12-05T23:40:15Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "brianrob",
                                           "body":  "I anticipate that if we\u0027re going to make this change in CoreCLR, we\u0027d want to do so in Mono too if for no other reason than consistency.  I don\u0027t think that NativeAOT affects anything here.\r\n\r\nIn terms of getting this into .NET 9, I will defer to @davmason and @tommcdon who own this space for CoreCLR.",
                                           "updatedAt":  "2023-12-05T22:23:17Z"
                                       }
                                   ],
                         "totalCount":  9
                     },
        "title":  "EventPipe rundown happening at the end of a session",
        "labels":  [
                       "enhancement",
                       "area-Tracing-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/87257",
        "createdAt":  "2023-06-08T07:34:59Z",
        "number":  87257,
        "author":  "davmason",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2024-07-23T21:15:56Z",
        "body":  "For each generic method we will have a reference instantiation and one instantiation for each value type, but we emit the same rundown event for all. Distinguishing between overloads (as we already do for R2R code) should be an easy win for profilers.\r\n\r\nFor example, the following method:\r\n```\r\nstatic T Test\u003cT\u003e(Test a, Test b)\r\n```\r\n\r\nWill emit these rundown events for `T=char`, `T=int`, and `T=object`. All have the same signature `generic !!0  (!!0,!!0)`\r\n```\r\n\r\n  \u003cPrettyPrint\u003e\r\n    \u003cEvent MSec=   \"572.2851\" PID=\"35752\" PName=\"ConsoleApp31\" TID=\"38296\" EventName=\"Method/LoadVerbose\" MethodID=\"0x00007FFF6D205DB0\" ModuleID=\"0x00007FFF6D0CCF48\" MethodStartAddress=\"0x00007FFF6D004630\" MethodSize=\"0x0000004C\" MethodToken=\"0x06000007\" MethodFlags=\"Generic, Jitted\" MethodNamespace=\"ConsoleApp31.Program\" MethodName=\"Test\" MethodSignature=\"generic !!0  (!!0,!!0)\" ClrInstanceID=\"10\" ReJITID=\"0x00000000\" OptimizationTier=\"MinOptJitted\"/\u003e\r\n  \u003c/PrettyPrint\u003e\r\n \r\n  \u003cPrettyPrint\u003e\r\n    \u003cEvent MSec=   \"572.5086\" PID=\"35752\" PName=\"ConsoleApp31\" TID=\"38296\" EventName=\"Method/LoadVerbose\" MethodID=\"0x00007FFF6D205ED0\" ModuleID=\"0x00007FFF6D0CCF48\" MethodStartAddress=\"0x00007FFF6D004690\" MethodSize=\"0x00000043\" MethodToken=\"0x06000007\" MethodFlags=\"Generic, Jitted\" MethodNamespace=\"ConsoleApp31.Program\" MethodName=\"Test\" MethodSignature=\"generic !!0  (!!0,!!0)\" ClrInstanceID=\"10\" ReJITID=\"0x00000000\" OptimizationTier=\"MinOptJitted\"/\u003e\r\n  \u003c/PrettyPrint\u003e\r\n \r\n  \u003cPrettyPrint\u003e\r\n    \u003cEvent MSec=   \"572.5952\" PID=\"35752\" PName=\"ConsoleApp31\" TID=\"38296\" EventName=\"Method/LoadVerbose\" MethodID=\"0x00007FFF6D206018\" ModuleID=\"0x00007FFF6D0CCF48\" MethodStartAddress=\"0x00007FFF6D0046F0\" MethodSize=\"0x00000098\" MethodToken=\"0x06000007\" MethodFlags=\"Generic, HasSharedGenericCode, Jitted\" MethodNamespace=\"ConsoleApp31.Program\" MethodName=\"Test\" MethodSignature=\"generic !!0  (!!0,!!0)\" ClrInstanceID=\"10\" ReJITID=\"0x00000000\" OptimizationTier=\"MinOptJitted\"/\u003e\r\n  \u003c/PrettyPrint\u003e\r\n```",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  null,
                         "nodes":  [

                                   ],
                         "totalCount":  0
                     },
        "title":  "When firing rundown events we do not distinguish between generic overloads for jitted methods",
        "labels":  [
                       "enhancement",
                       "area-Tracing-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/89629",
        "createdAt":  "2023-07-28T12:14:31Z",
        "number":  89629,
        "author":  "lateralusX",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2023-08-02T07:22:15Z",
        "body":  "Currently EventPipe/DiagnosticServer shutdown won\u0027t clean up some resources, like default listeners IPC channel and won\u0027t stop diagnostic server thread, instead it relies on OS cleanup of resources on process exit. This works in the case where runtime lifetime == process lifetime, but in cases where runtime could be restarted (mono embedding scenarios), this will cause resource leaks, and potentially prevent the runtime to re-initialize.\r\n\r\nhttps://github.com/dotnet/runtime/blob/main/src/native/eventpipe/ds-ipc-pal-namedpipe.c#L538\r\nhttps://github.com/dotnet/runtime/blob/main/src/native/eventpipe/ds-ipc-pal-socket.c#L1303\r\n\r\nMain reason why we can\u0027t close down the IPC channels during shutdown is because the shutdown does little efforts to orchestrate with threads currently using the IPC channels. The fix would include better orchestration between the diagnostic server thread that handles the IPC ports and the shutdown thread. Currently shutdown thread flags diagnostic server that a shutdown is in progress https://github.com/dotnet/runtime/blob/main/src/native/eventpipe/ds-server.c#L128, but if diagnostic server thread is blocked in `ds_ipc_stream_factory_get_next_available_stream`, shutdown thread wont wait and since there is no coordination around shared resource usage, shutdown can\u0027t close down the IPC ports.\r\n\r\nThere is also an old issue around EventPipe shutdown race condition, https://github.com/dotnet/runtime/blob/main/src/native/eventpipe/ep.c#L1456 that should be investigated in order to be able to free up even more resources during EventPipe shutdown.\r\n\r\nAnother thing that probably increase chances to hit runtime races is that we shutdown EventPipe before shutting down Diagnostic Server (https://github.com/dotnet/runtime/blob/main/src/coreclr/vm/ceemain.cpp#L1138), it should probably be done in reverse order, making sure no new IPC channel requests comes in while shutting down EventPipe sessions and resources.\r\n\r\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  null,
                         "nodes":  [

                                   ],
                         "totalCount":  0
                     },
        "title":  "Improve cleanup of EventPipe/DiagnosticServer resources during shutdown.",
        "labels":  [
                       "enhancement",
                       "area-Tracing-coreclr",
                       "area-Tracing-mono"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/90052",
        "createdAt":  "2023-08-04T22:17:58Z",
        "number":  90052,
        "author":  "davmason",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2024-07-23T21:12:39Z",
        "body":  "In EventPipeEventDispatcher we currently have a shared session for all EventListeners, whenever a new listener is added we will stop the existing session and then start a new session with the combined keywords/level. This has the side effect that for existing listeners we will drop events that happen between stopping the old session and starting the new one, as well as any unread events from the old session when we stop delivering events.\r\n\r\nWe can address this by changing the logic to update the keywords/level rather than starting and stopping. I have a first attempt at this at  https://github.com/davmason/runtime/tree/eventpipe_update",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  null,
                         "nodes":  [

                                   ],
                         "totalCount":  0
                     },
        "title":  "Adding a new listener to EventPipeEventDispatcher temporarily stops emitting events for existing sessions",
        "labels":  [
                       "enhancement",
                       "area-Tracing-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/92734",
        "createdAt":  "2023-09-27T18:07:44Z",
        "number":  92734,
        "author":  "vaind",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOCy5HoA==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "bruno-garcia",
                                            "createdAt":  "2023-09-27T18:12:37Z"
                                        }
                                    ],
                          "totalCount":  1
                      },
        "updatedAt":  "2025-07-15T18:10:24Z",
        "body":  "I\u0027m trying subscribe to a [sampleprofiler-provider](https://learn.microsoft.com/en-us/dotnet/core/diagnostics/well-known-event-providers#microsoft-dotnetcore-sampleprofiler-provider) via EventPipe but am not getting any samples. Using the following project properties:\r\n```\r\n    \u003cPublishAot\u003etrue\u003c/PublishAot\u003e\r\n    \u003cEventSourceSupport\u003etrue\u003c/EventSourceSupport\u003e\r\n```\r\n\r\nThese docs https://learn.microsoft.com/en-us/dotnet/core/deploying/native-aot/diagnostics#cpu-profiling say \r\n\r\n\u003e Native AOT provides partial support for some [well-known event providers](https://learn.microsoft.com/en-us/dotnet/core/diagnostics/well-known-event-providers). Not all [runtime events](https://learn.microsoft.com/en-us/dotnet/fundamentals/diagnostics/runtime-events) are supported in Native AOT.\r\n\r\nbut it\u0027s not clear what that means. Is there a doc page listing out which events/providers are not supported?",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOaE7cNA==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5nmeP2",
                                           "createdAt":  "2023-09-27T22:04:52Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tommcdon",
                                           "body":  "@LakshanF is this a known issue or do we have sample code demonstrating eventpipe sample profiling with NativeAOT?\r\n",
                                           "updatedAt":  "2023-09-27T22:04:52Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5nmwpY",
                                           "createdAt":  "2023-09-27T22:58:17Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "LakshanF",
                                           "body":  "[SampleProfiler](https://learn.microsoft.com/en-us/dotnet/core/diagnostics/well-known-event-providers#microsoft-dotnetcore-sampleprofiler-provider) is not supported in native AOT on net8.0.\r\n\r\nThanks for the feedback @vaind on the documentation, I created an [issue](https://github.com/dotnet/docs/issues/37282) to track this.\r\n\r\nA possible workaround might be to use [CPU profiler tools](https://learn.microsoft.com/en-us/dotnet/core/deploying/native-aot/diagnostics#cpu-profiling).",
                                           "updatedAt":  "2023-09-27T22:58:17Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5n0Exg",
                                           "createdAt":  "2023-09-30T07:30:27Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "vaind",
                                           "body":  "Thank you, @LakshanF, for your response and for the docs update tracking issue. \r\n\r\nIs there a plan to support the SampleProfiler provider in AOT in the future?",
                                           "updatedAt":  "2023-09-30T07:30:46Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5n4sQk",
                                           "createdAt":  "2023-10-02T12:20:45Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "LakshanF",
                                           "body":  "@vaind, we are evaluating customer feedback to prioritize future diagnostic capabilities in native AOT. Getting the CPU call stack via the native AOT runtime can be expensive. Do you mind describing your scenario for this please? Would platform profilers like PerfView (windows), Perf (Linux) that rely on OS to get the call stacks help you with your scenario?",
                                           "updatedAt":  "2023-10-02T12:21:38Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5oTtw0",
                                           "createdAt":  "2023-10-06T05:18:58Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "vaind",
                                           "body":  "@LakshanF the idea is to have a low-frequency (101 Hz) sampling profiler in production. Using native profilers may be an option, it\u0027s just not ideal to have two profiling implementations in the SDK, one for Native AOT and another for the standard .NET runtime.",
                                           "updatedAt":  "2023-10-06T05:18:58Z"
                                       }
                                   ],
                         "totalCount":  5
                     },
        "title":  "SampleProfiler EventPipe provider support for .net 8 Native AOT ",
        "labels":  [
                       "enhancement",
                       "area-Tracing-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/96365",
        "createdAt":  "2023-12-30T02:21:50Z",
        "number":  96365,
        "author":  "verdie-g",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2024-07-23T21:09:35Z",
        "body":  "### Description\r\n\r\nWhile writing my own event pipe reader, I noticed that some event metadata have an empty event name and don\u0027t define any field descriptions. It seems like all these events are under the `Microsoft-Windows-DotNETRuntimeRundown` provider.\r\n\r\n### Reproduction Steps\r\n\r\nWrite a random .NET program, for example\r\n```csharp\r\nwhile (true)\r\n{\r\n    await Task.Run(() =\u003e { });\r\n    await Task.Delay(50);\r\n}\r\n```\r\nand collect a trace, for example\r\n```\r\ndotnet trace collect -p $PID --providers=\u0027System.Threading.Tasks.TplEventSource:0x1:4\u0027\r\n```\r\nNow if you look for the field strings in the nettrace file\r\n```\r\n$ grep -ao \u0027O.r.i.g.i.n.a.t.i.n.g.T.a.s.k.S.c.h.e.d.u.l.e.r.I.D\u0027 Test.exe_20231229_192905.nettrace\r\nOriginatingTaskSchedulerID\r\nOriginatingTaskSchedulerID\r\nOriginatingTaskSchedulerID\r\n\r\n$ grep -ao \u0027M.e.t.h.o.d.S.t.a.r.t.A.d.d.r.e.s.s\u0027 Test.exe_20231229_192905.nettrace\r\n```\r\nThe field `OriginatingTaskSchedulerID` from an event of the `TplEventSource` provider is present but the `MethodStartAddress` field of the `Microsoft-Windows-DotNETRuntimeRundown/MethodLoadUnloadRundown` event is not.\r\n\r\n### Expected behavior\r\n\r\nI\u0027m expecting the nettrace file to self-contain all metadata to be parsed. Especially, all event metadata with their fields in the MetadataBlock objects so the events in EventBlock objects can be parsed.\r\n\r\n### Actual behavior\r\n\r\n![image](https://github.com/dotnet/runtime/assets/9092290/eaeb77e0-aefa-431a-bbdf-3ff6642eeaa5)\r\n\r\nIn my custom event pipe parser I can see that the `Microsoft-Windows-DotNETRuntimeRundown` events don\u0027t have an event name and field descriptors.\r\n\r\n### Regression?\r\n\r\n_No response_\r\n\r\n### Known Workarounds\r\n\r\nI think PerfView hardcodes the `Microsoft-Windows-DotNETRuntimeRundown` field descriptors instead of reading them from the nettrace file. This is not future proof in the case where a new version of an event is introduced.\r\n\r\n### Configuration\r\n\r\n- .NET 8.0\r\n- Windows\r\n- x64\r\n\r\n### Other information\r\n\r\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOenCVZg==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5vrOfr",
                                           "createdAt":  "2024-01-02T04:00:09Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tommcdon",
                                           "body":  "@davmason",
                                           "updatedAt":  "2024-01-02T04:00:09Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc56cJVm",
                                           "createdAt":  "2024-04-14T22:06:40Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "verdie-g",
                                           "body":  "Actually it appears that many events have the same issue\r\n\r\n![image](https://github.com/dotnet/runtime/assets/9092290/1127ae5b-75aa-41db-81a2-3429174d8f04)\r\n\r\nIn this screenshot, only ProcessInfo and TaskWaitBegin have a non-empty name and field definitions. Event such as GCAllocationTick (id=10 from Microsoft-Windows-DotNETRuntime) has the issue.",
                                           "updatedAt":  "2024-04-14T22:06:40Z"
                                       }
                                   ],
                         "totalCount":  2
                     },
        "title":  "Incomplete rundown event metadata",
        "labels":  [
                       "enhancement",
                       "area-Tracing-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/98270",
        "createdAt":  "2024-02-10T16:47:05Z",
        "number":  98270,
        "author":  "rubin55",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2024-03-04T20:01:08Z",
        "body":  "### Describe the bug\r\nRunning `dotnet` without arguments shows the general help output. However, when trying to run `dotnet publish` or `dotnet --info`, or other dotnet commands, the command hangs indefinitely.\r\n\r\n### To Reproduce\r\nI can reproduce this on two of my three Linux systems, with .NET core 6.x, 7.x and 8.x. I initially ran into this when trying to build `netcoredbg` and filed an issue with them here: https://github.com/Samsung/netcoredbg/issues/162.\r\n\r\nI later figured out that it was not with the `netcoredbg` project, but more fundamentally with `dotnet` itself. I found three issues which seem similar but I can\u0027t be sure:\r\n\r\n  * https://github.com/dotnet/runtime/issues/9494\r\n  * https://github.com/dotnet/sdk/issues/30455\r\n  * https://github.com/dotnet/sdk/issues/37774\r\n \r\nDetails of the machines I\u0027ve tested this on (all running an identical setup of Arch Linux):\r\n\r\n  * Desktop at home (13900T with NVIDIA 4090 graphics, 128GiB ram): *hangs*\r\n  * Desktop at work (13900T with NVIDIA 3090 graphics, 128GiB ram): *hangs*\r\n  * Laptop (Framework Laptop 13, 1370P with Intel graphics, 64GiB ram): **works**\r\n \r\n### Exceptions (if any)\r\nNone, the tool hangs without any feedback, even when specifying verbose logging.\r\n\r\n### Further technical details\r\n* Tested with the latest versions of dotnet 6.x, 7.x, 8.x\r\n* on Arch Linux, with Linux kernel 6.7.4\r\n* Core dump from hung process: [core.zip](https://github.com/dotnet/sdk/files/14229891/core.zip)\r\n\r\n### GDB Backtrace\r\n```\r\nfutex_wait (private=0, expected=2, futex_word=0x7068751f7080) at ../sysdeps/nptl/futex-internal.h:146\r\n146       int err = lll_futex_timed_wait (futex_word, expected, NULL, private);                                                     \r\n(gdb) bt\r\n#0  futex_wait (private=0, expected=2, futex_word=0x7068751f7080) at ../sysdeps/nptl/futex-internal.h:146\r\ndotnet/sdk#1  __GI___lll_lock_wait (futex=futex@entry=0x7068751f7080, private=0) at lowlevellock.c:49\r\ndotnet/sdk#2  0x0000706875aac9b2 in lll_mutex_lock_optimized (mutex=0x7068751f7080) at pthread_mutex_lock.c:48\r\ndotnet/sdk#3  ___pthread_mutex_lock (mutex=0x7068751f7080) at pthread_mutex_lock.c:93\r\ndotnet/sdk#4  0x000070687519799d in ust_lock_nocheck () from /usr/lib/liblttng-ust.so.0\r\ndotnet/sdk#5  0x00007068751a743d in ?? () from /usr/lib/liblttng-ust.so.0\r\ndotnet/sdk#6  0x00007068751a7572 in lttng_probe_register () from /usr/lib/liblttng-ust.so.0\r\ndotnet/sdk#7  0x0000706875977383 in ?? () from /usr/share/dotnet/shared/Microsoft.NETCore.App/8.0.1/libcoreclrtraceptprovider.so\r\ndotnet/sdk#8  0x00007068760bd1be in call_init (env=0x7ffd018e1e40, argv=0x7ffd018e1e28, argc=2, l=\u003coptimized out\u003e) at dl-init.c:74\r\ndotnet/sdk#9  call_init (l=\u003coptimized out\u003e, argc=2, argv=0x7ffd018e1e28, env=0x7ffd018e1e40) at dl-init.c:26\r\ndotnet/sdk#10 0x00007068760bd2ac in _dl_init (main_map=0x579486b15f30, argc=2, argv=0x7ffd018e1e28, env=0x7ffd018e1e40) at dl-init.c:121\r\ndotnet/sdk#11 0x00007068760b956e in __GI__dl_catch_exception (exception=exception@entry=0x0, \r\n    operate=operate@entry=0x7068760c3d80 \u003ccall_dl_init\u003e, args=args@entry=0x7ffd018e07f0) at dl-catch.c:211\r\ndotnet/sdk#12 0x00007068760c3d26 in dl_open_worker (a=a@entry=0x7ffd018e0990) at dl-open.c:829\r\ndotnet/sdk#13 0x00007068760b94e1 in __GI__dl_catch_exception (exception=exception@entry=0x7ffd018e0970, \r\n    operate=operate@entry=0x7068760c3c90 \u003cdl_open_worker\u003e, args=args@entry=0x7ffd018e0990) at dl-catch.c:237\r\ndotnet/sdk#14 0x00007068760c410c in _dl_open (\r\n    file=0x7ffd018e0c70 \"/usr/share/dotnet/shared/Microsoft.NETCore.App/8.0.1/libcoreclrtraceptprovider.so\", mode=\u003coptimized out\u003e, \r\n    caller_dlopen=0x70687563f83b, nsid=\u003coptimized out\u003e, argc=2, argv=0x7ffd018e1e28, env=0x7ffd018e1e40) at dl-open.c:905\r\ndotnet/sdk#15 0x0000706875aa53fc in dlopen_doit (a=a@entry=0x7ffd018e0c00) at dlopen.c:56\r\ndotnet/sdk#16 0x00007068760b94e1 in __GI__dl_catch_exception (exception=exception@entry=0x7ffd018e0b60, \r\n    operate=0x706875aa53a0 \u003cdlopen_doit\u003e, args=0x7ffd018e0c00) at dl-catch.c:237\r\ndotnet/sdk#17 0x00007068760b9603 in _dl_catch_error (objname=0x7ffd018e0bb8, errstring=0x7ffd018e0bc0, mallocedp=0x7ffd018e0bb7, \r\n    operate=\u003coptimized out\u003e, args=\u003coptimized out\u003e) at dl-catch.c:256\r\ndotnet/sdk#18 0x0000706875aa4f07 in _dlerror_run (operate=operate@entry=0x706875aa53a0 \u003cdlopen_doit\u003e, args=args@entry=0x7ffd018e0c00)\r\n    at dlerror.c:138\r\ndotnet/sdk#19 0x0000706875aa54b1 in dlopen_implementation (dl_caller=\u003coptimized out\u003e, mode=\u003coptimized out\u003e, file=\u003coptimized out\u003e)\r\n    at dlopen.c:71\r\ndotnet/sdk#20 ___dlopen (file=\u003coptimized out\u003e, mode=\u003coptimized out\u003e) at dlopen.c:81\r\ndotnet/sdk#21 0x000070687563f83b in ?? () from /usr/share/dotnet/shared/Microsoft.NETCore.App/8.0.1/libcoreclr.so\r\ndotnet/sdk#22 0x00007068760bd1be in call_init (env=0x7ffd018e1e40, argv=0x7ffd018e1e28, argc=2, l=\u003coptimized out\u003e) at dl-init.c:74\r\ndotnet/sdk#23 call_init (l=\u003coptimized out\u003e, argc=2, argv=0x7ffd018e1e28, env=0x7ffd018e1e40) at dl-init.c:26\r\ndotnet/sdk#24 0x00007068760bd2ac in _dl_init (main_map=0x579486b12ae0, argc=2, argv=0x7ffd018e1e28, env=0x7ffd018e1e40) at dl-init.c:121\r\ndotnet/sdk#25 0x00007068760b956e in __GI__dl_catch_exception (exception=exception@entry=0x0, \r\n    operate=operate@entry=0x7068760c3d80 \u003ccall_dl_init\u003e, args=args@entry=0x7ffd018e0f60) at dl-catch.c:211\r\ndotnet/sdk#26 0x00007068760c3d26 in dl_open_worker (a=a@entry=0x7ffd018e1100) at dl-open.c:829\r\ndotnet/sdk#27 0x00007068760b94e1 in __GI__dl_catch_exception (exception=exception@entry=0x7ffd018e10e0, \r\n    operate=operate@entry=0x7068760c3c90 \u003cdl_open_worker\u003e, args=args@entry=0x7ffd018e1100) at dl-catch.c:237\r\ndotnet/sdk#28 0x00007068760c410c in _dl_open (file=0x579486b263d0 \"/usr/share/dotnet/shared/Microsoft.NETCore.App/8.0.1/libcoreclr.so\", \r\n    mode=\u003coptimized out\u003e, caller_dlopen=0x706875ee6c1d, nsid=\u003coptimized out\u003e, argc=2, argv=0x7ffd018e1e28, env=0x7ffd018e1e40)\r\n    at dl-open.c:905\r\ndotnet/sdk#29 0x0000706875aa53fc in dlopen_doit (a=a@entry=0x7ffd018e1370) at dlopen.c:56\r\ndotnet/sdk#30 0x00007068760b94e1 in __GI__dl_catch_exception (exception=exception@entry=0x7ffd018e12d0, \r\n    operate=0x706875aa53a0 \u003cdlopen_doit\u003e, args=0x7ffd018e1370) at dl-catch.c:237\r\ndotnet/sdk#31 0x00007068760b9603 in _dl_catch_error (objname=0x7ffd018e1328, errstring=0x7ffd018e1330, mallocedp=0x7ffd018e1327, \r\n    operate=\u003coptimized out\u003e, args=\u003coptimized out\u003e) at dl-catch.c:256\r\ndotnet/sdk#32 0x0000706875aa4f07 in _dlerror_run (operate=operate@entry=0x706875aa53a0 \u003cdlopen_doit\u003e, args=args@entry=0x7ffd018e1370)\r\n    at dlerror.c:138\r\ndotnet/sdk#33 0x0000706875aa54b1 in dlopen_implementation (dl_caller=\u003coptimized out\u003e, mode=\u003coptimized out\u003e, file=\u003coptimized out\u003e)\r\n    at dlopen.c:71\r\ndotnet/sdk#34 ___dlopen (file=\u003coptimized out\u003e, mode=\u003coptimized out\u003e) at dlopen.c:81\r\ndotnet/sdk#35 0x0000706875ee6c1d in ?? () from /usr/share/dotnet/shared/Microsoft.NETCore.App/8.0.1/libhostpolicy.so\r\ndotnet/sdk#36 0x0000706875ebbc53 in ?? () from /usr/share/dotnet/shared/Microsoft.NETCore.App/8.0.1/libhostpolicy.so\r\ndotnet/sdk#37 0x0000706875ebd069 in ?? () from /usr/share/dotnet/shared/Microsoft.NETCore.App/8.0.1/libhostpolicy.so\r\ndotnet/sdk#38 0x0000706875ed9581 in ?? () from /usr/share/dotnet/shared/Microsoft.NETCore.App/8.0.1/libhostpolicy.so\r\ndotnet/sdk#39 0x0000706875ed8f94 in corehost_main () from /usr/share/dotnet/shared/Microsoft.NETCore.App/8.0.1/libhostpolicy.so\r\ndotnet/sdk#40 0x0000706875f150aa in ?? () from /usr/share/dotnet/host/fxr/8.0.1/libhostfxr.so\r\ndotnet/sdk#41 0x0000706875f147bc in ?? () from /usr/share/dotnet/host/fxr/8.0.1/libhostfxr.so\r\ndotnet/sdk#42 0x0000706875f1405f in ?? () from /usr/share/dotnet/host/fxr/8.0.1/libhostfxr.so\r\ndotnet/sdk#43 0x0000706875f101e2 in hostfxr_main_startupinfo () from /usr/share/dotnet/host/fxr/8.0.1/libhostfxr.so\r\ndotnet/sdk#44 0x0000579485ba1d88 in ?? ()\r\ndotnet/sdk#45 0x0000579485ba206f in ?? ()\r\ndotnet/sdk#46 0x0000706875a43cd0 in __libc_start_call_main (main=main@entry=0x579485ba1fc0, argc=argc@entry=2, \r\n    argv=argv@entry=0x7ffd018e1e28) at ../sysdeps/nptl/libc_start_call_main.h:58\r\ndotnet/sdk#47 0x0000706875a43d8a in __libc_start_main_impl (main=0x579485ba1fc0, argc=2, argv=0x7ffd018e1e28, init=\u003coptimized out\u003e, \r\n    fini=\u003coptimized out\u003e, rtld_fini=\u003coptimized out\u003e, stack_end=0x7ffd018e1e18) at ../csu/libc-start.c:360\r\ndotnet/sdk#48 0x0000579485b98645 in ?? ()\r\n```\r\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOddwYkw==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5zgYAy",
                                           "createdAt":  "2024-02-11T20:54:43Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tommcdon",
                                           "body":  "@davmason ",
                                           "updatedAt":  "2024-02-11T20:54:43Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5zruZ4",
                                           "createdAt":  "2024-02-13T09:09:34Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "davmason",
                                           "body":  "@brianrob do you recognize the callstack above? is this another symptom of the LTTng breaking abi changes?",
                                           "updatedAt":  "2024-02-13T09:09:34Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5z0MMO",
                                           "createdAt":  "2024-02-14T04:23:44Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "brianrob",
                                           "body":  "I don\u0027t expect this to be caused by the breaking abi change because in that case, `dlopen` would return `NULL` because the expected lttng-ust binary doesn\u0027t exist on disk (it\u0027s been renamed on purpose).\r\n\r\nThis looks familiar, but it\u0027s been a long time since I\u0027ve seen this.  It reminds me of a bug that existed in `LTTng` years back that was due to a difference in struct packing behavior between gdb and g++.  I did a search of my e-mail, but I could not find it.\r\n\r\nWhat version of `LTTng` is installed on this machine?",
                                           "updatedAt":  "2024-02-14T04:23:44Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc50T-eb",
                                           "createdAt":  "2024-02-18T17:32:37Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "rubin55",
                                           "body":  "\u003e What version of `LTTng` is installed on this machine?\r\n\r\nThis is an up-to-date Arch Linux installation: `lttng-ust2.12 2.12.9-1`",
                                           "updatedAt":  "2024-02-18T17:32:37Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc50-Idb",
                                           "createdAt":  "2024-02-24T18:11:59Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tommcdon",
                                           "body":  "\u003e This is an up-to-date Arch Linux installation: lttng-ust2.12 2.12.9-1\r\n\r\n@brianrob  [lttng 2.12](https://lttng.org/docs/v2.12/) looks like a recent version.  Do you have other thoughts, perhaps an incompatibility between lttng and Arch linux?\r\n@rubin55 Out of curiosity does this issue reproduce on one of our supported OS\u0027s? https://github.com/dotnet/core/blob/main/release-notes/9.0/supported-os.md",
                                           "updatedAt":  "2024-02-24T18:11:59Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc51KQv7",
                                           "createdAt":  "2024-02-27T01:24:22Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "brianrob",
                                           "body":  "@tommcdon agreed that is a new version. I doubt that they\u0027re incompatible, but here\u0027s the installation and compatibility info for LTTng 2.12: https://lttng.org/docs/v2.12/#doc-alpine-linux.  I don\u0027t see the version of Arch Linux here (or I missed it), so it would be good to confirm that the version is listed on the LTTng link.\r\n\r\nDo you know what version of the LTTng headers we\u0027re building with? I wonder if it\u0027s possible that there is an unintended bug there that perhaps is fixed in a newer version of the headers.  I have no proof of this - just a thought.\r\n\r\n",
                                           "updatedAt":  "2024-02-27T01:24:22Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc51KSep",
                                           "createdAt":  "2024-02-27T01:33:13Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "MichalPetryka",
                                           "body":  "\u003e the version of Arch Linux\r\n\r\nArch Linux is a non versioned distro, the only somewhat version like thing is creation dates of installer images.",
                                           "updatedAt":  "2024-02-27T01:33:13Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc51KS_c",
                                           "createdAt":  "2024-02-27T01:35:55Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "brianrob",
                                           "body":  "Sorry, for some reason, I read Arch as Alpine.  In that case, yes it\u0027s possible that there are issues.  I don\u0027t see anything about installation using Arch Linux, but I would imagine that you\u0027re building from source.",
                                           "updatedAt":  "2024-02-27T01:35:55Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc51Segp",
                                           "createdAt":  "2024-02-27T22:32:40Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "rubin55",
                                           "body":  "No, not built from source. Arch Linux packages dotnet, which is what I installed: https://archlinux.org/packages/?sort=\u0026q=dotnet\r\n\r\nMy installed packages in particular: \r\n* dotnet-host 8.0.1.sdk101-1\r\n* dotnet-runtime 8.0.1.sdk101-1\r\n* dotnet-sdk 8.0.1.sdk101-1\r\n* dotnet-targeting-pack 8.0.1.sdk101-1\r\n\r\nDoesn\u0027t the core dump and backtrace I shared provide any hint about what\u0027s happening? It\u0027s really perplexing + a little frustrating (these are very new systems which I intended to use for development purposes - it\u0027s particularly strange that the identical OS image works on my laptop - only difference is essentially the 13900T vs 1370P, 128GiB ECC vs 64GiB non-ECC, and NVIDIA graphics vs Intel).\r\n\r\nLet me know if I can try anything else to clarify what\u0027s going on..",
                                           "updatedAt":  "2024-02-27T22:40:52Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc51StZL",
                                           "createdAt":  "2024-02-27T22:54:34Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "rubin55",
                                           "body":  "Another similar issue here: https://github.com/dotnet/runtime/issues/9494\r\n\r\nLike mentioned in that issue, I `export COREHOST_TRACE=1`, and then run `dotnet --help`, here\u0027s the output: [dotnet-trace-out.txt](https://github.com/dotnet/runtime/files/14426500/dotnet-trace-out.txt)\r\n\r\nI also ran the exact same command(s) on my laptop system (which I know to be working) to compare the trace output (do a `diff -Naur` between the two). I notice that `HOST_RUNTIME_CONTRACT` is different + a few dates and directories where I ran the command, and in the working version, you see a line as follows:\r\n\r\n`Launch host: /usr/share/dotnet/dotnet, app: /usr/share/dotnet/sdk/8.0.101/dotnet.dll, argc: 1, args: --help,`\r\n\r\nWhich is then followed more-or-less by the expected output of `dotnet --help`.\r\n\r\nHere\u0027s the trace from `dotnet --help` on my laptop, which works, for comparison purposes: [dotnet-trace-out-working.txt](https://github.com/dotnet/runtime/files/14426560/dotnet-trace-out-working.txt)\r\n",
                                           "updatedAt":  "2024-02-27T23:07:54Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc51pR3C",
                                           "createdAt":  "2024-03-01T18:58:57Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tommcdon",
                                           "body":  "\u003e Do you know what version of the LTTng headers we\u0027re building with? \r\n\r\n@brianrob We are building .NET 8 with a Mariner 2.0 docker image (mcr.microsoft.com/dotnet-buildtools/prereqs:cbl-mariner-2.0-cross-amd64).  The version of LTTng it is targeting seems to be `2.7.1` based off of `/crossrootfs/x64/usr/include/lttng/ust-version.h` in that distro:\r\n```c++\r\n#define LTTNG_UST_MAJOR_VERSION 2\r\n#define LTTNG_UST_MINOR_VERSION 7\r\n#define LTTNG_UST_PATCHLEVEL_VERSION 1\r\n#define LTTNG_UST_VERSION 2.7.1\r\n```",
                                           "updatedAt":  "2024-03-01T18:58:57Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc51q03O",
                                           "createdAt":  "2024-03-02T01:22:48Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "brianrob",
                                           "body":  "Hmm... that is relatively old, so it\u0027s possible that there is an unexpected incompatibility with 2.12.  I suspect the only way to know for sure is to try building with newer headers.",
                                           "updatedAt":  "2024-03-02T01:22:48Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc51ttMl",
                                           "createdAt":  "2024-03-02T21:38:21Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tommcdon",
                                           "body":  "\u003e Doesn\u0027t the core dump and backtrace I shared provide any hint about what\u0027s happening? \r\n\r\nUnfortunately, the stack is not symbolicated so it is difficult to tell what exactly is happening.  I also tried to look at the dump but was unable to make progress because I could not find a matching version of /usr/share/dotnet/dotnet (dump debugging requires the exact same modules used when collecting the dump).\r\n\r\nAs an experiment I setup an arch linux VM installed via ISO from http://mirrors.kernel.org/archlinux/iso/2024.03.01/ (`Linux 6.7.6-arch1-2 #1 SMP PREEMPT_DYNAMIC Thu, 29 Feb 2024 19:08:51 +0000 x86_64 GNU/Linux`).  By default arch linux does not seem to include lttng, so I manually installed LTTNG using `pacman -S lttng-ust2.12`, which installed the `lttng-ust2.12-2.12.9-1-x86_64` package, and then I installed `lttng-tools-2.12.9` via https://lttng.org/files/lttng-tools/.  I installed the latest .NET using `dotnet-install.sh --install-dir /usr/share/dotnet --channel LTS`.  I was not able to repro the hang with `dotnet --info`, both with and without an active LTTNG session.  As an additional level of verification, I set `DOTNET_EnableEventLog=1` with a running LTTNG session and verified that it captured .NET application events.  \r\n\r\nGiven all of the above, I do not believe this issue is not actionable for our team at this time, and so I will move this issue into the Future milestone.  Please feel free to try @brianrob\u0027s suggestion of building the runtime against the latest version of lttng to determine if that resolves the issue.  If we end up learning something new and find a .NET runtime issue here we will re-evaluate and bring this issue back to the .NET 9 milestone.",
                                           "updatedAt":  "2024-03-02T21:38:21Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc51ttkQ",
                                           "createdAt":  "2024-03-02T21:46:38Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "This issue has been marked `needs-author-action` and may be missing some important information.",
                                           "updatedAt":  "2024-03-02T21:46:38Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc51tw8Y",
                                           "createdAt":  "2024-03-02T22:50:59Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "rubin55",
                                           "body":  "@tommcdon instead of installing `dotnet` with `dotnet-install.sh`, could you try with the `dotnet` packages provided by Arch? i.e., `pacman -S dotnet-host dotnet-runtime dotnet-sdk dotnet-targeting-pack`\r\n\r\nLike I mentioned in the original description of this issue, I don\u0027t have this issue on my (Framework 13) laptop (Raptor Lake 1370p); I only have this on two almost identical desktop systems (Intel W680 chipset + Raptor Lake 13900T + ECC ram). I suspect this is hardware related, and/or timing-due-to-hardware+lttng. I will try what you mentioned before and see if I can reproduce on one of the supported Linux variants.",
                                           "updatedAt":  "2024-03-02T22:53:01Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc51txRg",
                                           "createdAt":  "2024-03-02T22:57:38Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODZDumg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "tommcdon",
                                                                               "createdAt":  "2024-03-03T01:42:18Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "rubin55",
                                           "body":  "Update: I can confirm that if I remove the LTTng package with `pacman -R lttng-ust2.12`, `dotnet` works normally on my desktop systems.",
                                           "updatedAt":  "2024-03-02T22:57:38Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc51t7Hj",
                                           "createdAt":  "2024-03-03T01:44:09Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tommcdon",
                                           "body":  "\u003e @tommcdon instead of installing dotnet with dotnet-install.sh, could you try with the dotnet packages provided by Arch? i.e., pacman -S dotnet-host dotnet-runtime dotnet-sdk dotnet-targeting-pack\r\n\r\nYes I tried using the package manager install as well as dotnet-install.sh, and all worked as expected for me.  ",
                                           "updatedAt":  "2024-03-03T01:44:09Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc51t7QV",
                                           "createdAt":  "2024-03-03T01:45:00Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tommcdon",
                                           "body":  "\u003e Update: I can confirm that if I remove the LTTng package with `pacman -R lttng-ust2.12`, `dotnet` works normally on my desktop systems.\r\n\r\nThanks for confirming! ",
                                           "updatedAt":  "2024-03-03T01:45:00Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc51vA-B",
                                           "createdAt":  "2024-03-03T18:46:13Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "MichalPetryka",
                                           "body":  "I seem to be getting hangs when trying to build the runtime repo in WSL2 Ubuntu 22.04.3 in the dotnet processes too, could this be related? The `lttng` version there is `2.13.1`, I can\u0027t verify uninstalling it though as that stops the runtime from building.\r\nThe host machine is Ryzen 9 7900X, 64GB of RAM and Windows 10 22H2.",
                                           "updatedAt":  "2024-03-03T18:47:15Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc51vQwy",
                                           "createdAt":  "2024-03-03T20:57:17Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tommcdon",
                                           "body":  "\u003e I seem to be getting hangs when trying to build the runtime repo in WSL2 Ubuntu 22.04.3 in the dotnet processes too, could this be related? The `lttng` version there is `2.13.1`, I can\u0027t verify uninstalling it though as that stops the runtime from building. The host machine is Ryzen 9 7900X, 64GB of RAM and Windows 10 22H2.\r\n\r\n@MichalPetryka would you mind trying to debugging the hung process with lldb?  If debugging a dotnet that is restored via nuget vs. built locally, I use `setsymbolserver -loadsymbols` to download symbols for libcoreclr.so.  This requires SOS which can be installed with the [dotnet-sos](https://learn.microsoft.com/en-us/dotnet/core/diagnostics/dotnet-sos) global tool.  Note it will require a 6.0+ runtime installed.  \r\n\r\nIf you have docker installed, it might be worth trying to build with `docker run -it -v $(pwd):$(pwd)  -w $(pwd) -e ROOTFS_DIR=\u0027/crossrootfs/x64\u0027 mcr.microsoft.com/dotnet-buildtools/prereqs:cbl-mariner-2.0-cross-amd64 /bin/bash ./build.sh clr --cross -c release`.  This is currently the same container image used to build .NET 8 and 9.\r\n\r\nAlso if you wish to build the runtime with lttng disabled, feel free to try cherry-picking these commits and rebuilding - https://github.com/tommcdon/runtime/commit/4eeacff728285b8c141d92c2ede8e06a1c5e3921 and https://github.com/tommcdon/runtime/commit/0bdf4ee3e58d78d0ef1e350b4b2e66fcc7b67a67",
                                           "updatedAt":  "2024-03-03T20:57:17Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc51vSge",
                                           "createdAt":  "2024-03-03T21:25:20Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "MichalPetryka",
                                           "body":  "\u003e would you mind trying to debugging the hung process with lldb?\r\n\r\nThe issue with that is that `htop` shows a few hundred `dotnet` processes running stuff like MSBuild, VBSCompiler, ILLink and such and I have no idea which one is the hanged one (it hangs at various places FYI, sometimes while compiling some random assembly, sometimes in ILLink).\r\n\r\n\u003e If you have docker installed, it might be worth trying to build with `docker run -it -v $(pwd):$(pwd) -w $(pwd) -e ROOTFS_DIR=\u0027/crossrootfs/x64\u0027 mcr.microsoft.com/dotnet-buildtools/prereqs:cbl-mariner-2.0-cross-amd64 /bin/bash ./build.sh clr --cross -c release`. This is currently the same container image used to build .NET 8 and 9.\r\n\r\nI don\u0027t have docker set up at the moment and I\u0027m not really experienced with it, sadly.\r\n\r\n\r\n\r\n\u003e Also if you wish to build the runtime with lttng disabled, feel free to try cherry-picking these commits and rebuilding - [tommcdon@4eeacff](https://github.com/tommcdon/runtime/commit/4eeacff728285b8c141d92c2ede8e06a1c5e3921) and [tommcdon@0bdf4ee](https://github.com/tommcdon/runtime/commit/0bdf4ee3e58d78d0ef1e350b4b2e66fcc7b67a67)\r\n\r\nI\u0027ll try building with the patches and lttng uninstalled tomorrow.",
                                           "updatedAt":  "2024-03-03T21:25:20Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc513BiT",
                                           "createdAt":  "2024-03-04T20:01:07Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "MichalPetryka",
                                           "body":  "Seems like this is an issue with WSL2, not dotnet in particular since now it froze while compiling native code. Weirdly enough, other terminal sessions keep working normally.",
                                           "updatedAt":  "2024-03-04T20:01:07Z"
                                       }
                                   ],
                         "totalCount":  22
                     },
        "title":  "dotnet command hangs on two out of three Linux systems (possible deadlock in LTTNG)",
        "labels":  [
                       "area-Tracing-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/101764",
        "createdAt":  "2024-05-01T14:17:59Z",
        "number":  101764,
        "author":  "cshung",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2024-07-23T21:57:48Z",
        "body":  "### Description\n\nIf I had a malformed event pipe request, it could crash the runtime.\n\n### Reproduction Steps\n\nApply this patch to the dotnet/diagnostics repo to intentionally make a malformed eventpipe request\r\n\r\n```\r\ndiff --git a/src/Microsoft.Diagnostics.NETCore.Client/DiagnosticsClient/EventPipeSession.cs b/src/Microsoft.Diagnostics.NETCore.Client/DiagnosticsClient/EventPipeSession.cs\r\nindex 805298cf..c14ae293 100644\r\n--- a/src/Microsoft.Diagnostics.NETCore.Client/DiagnosticsClient/EventPipeSession.cs\r\n+++ b/src/Microsoft.Diagnostics.NETCore.Client/DiagnosticsClient/EventPipeSession.cs\r\n@@ -111,7 +111,7 @@ private static IpcMessage CreateStartMessage(EventPipeSessionConfiguration confi\r\n             }\r\n             else\r\n             {\r\n-                command = EventPipeCommandId.CollectTracing2;\r\n+                command = EventPipeCommandId.CollectTracing3;\r\n                 payload = config.SerializeV2();\r\n             }\r\n```\r\n\r\nAnd then take a trace using `dotnet-trace`.\n\n### Expected behavior\n\nThe runtime should report a bad request error. \n\n### Actual behavior\n\nThe runtime crashed with this stack:\r\n\r\n```\r\n0:004\u003e k\r\n# Child-SP          RetAddr               Call Site\r\n00 000000ca`4497fc40 00007ff8`912bd2c0     coreclr!ds_eventpipe_collect_tracing_command_payload_free+0x5f [D:\\Dev\\runtime\\src\\native\\eventpipe\\ds-eventpipe-protocol.c @ 296]\r\n01 000000ca`4497fcc0 00007ff8`912b74a6     coreclr!eventpipe_collect_tracing3_command_try_parse_payload+0x1a0 [D:\\Dev\\runtime\\src\\native\\eventpipe\\ds-eventpipe-protocol.c @ 406]\r\n02 000000ca`4497fd40 00007ff8`912b6834     coreclr!ds_ipc_message_try_parse_payload+0x96 [D:\\Dev\\runtime\\src\\native\\eventpipe\\ds-protocol.c @ 562]\r\n03 000000ca`4497fd80 00007ff8`912c205d     coreclr!ds_eventpipe_protocol_helper_handle_ipc_message+0xf4 [D:\\Dev\\runtime\\src\\native\\eventpipe\\ds-eventpipe-protocol.c @ 615]\r\n04 000000ca`4497fdd0 00007ff9`3458257d     coreclr!server_thread+0x2ed [D:\\Dev\\runtime\\src\\native\\eventpipe\\ds-server.c @ 158]\r\n...\r\n```\n\n### Regression?\n\nNo\n\n### Known Workarounds\n\nThere is no need for a workaround.\n\n### Configuration\n\nwindows, x64, debug.\r\n\r\nBut don\u0027t see why it cannot repro on other platforms.\n\n### Other information\n\nWe confirmed that this is not a security bug - a malformed request can be issued only by authenticated user.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  null,
                         "nodes":  [

                                   ],
                         "totalCount":  0
                     },
        "title":  "Malformed EventPipe request can crash the runtime",
        "labels":  [
                       "EventPipe",
                       "area-Tracing-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/104795",
        "createdAt":  "2024-07-12T14:24:26Z",
        "number":  104795,
        "author":  "omajid",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2024-07-12T14:37:26Z",
        "body":  "The .NET runtime has a copy of the LinuxTracepoints library at src/native/external. Like other libraries in runtime (eg, rapidjson, zlib, libunwind), it would be nice if we could build runtime against the system version of the LinuxTracepoints library.\r\n\r\nThis isn\u0027t an urgent/important issue. I certainly don\u0027t want/expect it to be fixed for .NET 9. I am filing it here so this stays tracked.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  null,
                         "nodes":  [

                                   ],
                         "totalCount":  0
                     },
        "title":  "RFE: Add support for using system version of the LinuxTracepoints library",
        "labels":  [
                       "area-Tracing-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/111368",
        "createdAt":  "2025-01-13T20:00:47Z",
        "number":  111368,
        "author":  "dqsully",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOC_xaUg==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "poblahblahblah",
                                            "createdAt":  "2025-01-21T16:23:36Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "ugrkm",
                                            "createdAt":  "2025-01-21T16:40:26Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "jukie",
                                            "createdAt":  "2025-01-21T17:19:38Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "kevingosse",
                                            "createdAt":  "2025-01-27T09:45:39Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Reasonably",
                                            "createdAt":  "2025-03-06T11:34:35Z"
                                        }
                                    ],
                          "totalCount":  5
                      },
        "updatedAt":  "2025-07-30T15:45:56Z",
        "body":  "### Description\n\nEventPipe sessions that aren\u0027t file or IPC sessions never garbage collect their \"thread state session list\" for exited threads. This results in a memory leak proportional to the number of threads that have ever started since the EventPipe session began, and for each EventPipe event, a single-threaded CPU leak caused by iterating over the ever-growing thread session state linked list when looking for the next event.\n\nThis behavior has been present since at least .NET 6.0 when EventPipe was rewritten into CoreCLR in C, and is still present in the latest `main` branch as of writing this.\n\n### Reproduction Steps\n\nCreate an `EventListener` subclass that enables CLR events, something like this:\n```csharp\nclass ClrEventListener : EventListener\n{\n    protected override void OnEventSourceCreated(EventSource eventSource)\n    {\n        if (eventSource.Name.Equals(\"Microsoft-Windows-DotNETRuntime\"))\n        {\n            EnableEvents(eventSource, EventLevel.Informational, (EventKeywords) 0x8000); // 0x8000 enables exception events in this case\n        }\n    }\n}\n```\n\nInstantiate the event listener subclass, spawn thousands of short-lived threads, and then do something that creates CLR events (e.g. throw and catch exceptions).\n\nAs the number of threads ever spawned increases, the `.NET Long Runni` thread that processes these CLR events will get slower and slower and tend towards 100% CPU time, even if the number of currently running threads stays constant.\n\nI made a [GitHub repo to fully demonstrate and reproduce this issue](https://github.com/dqsully/coreclr-eventpipe-thread-gc-bug).\n\n### Expected behavior\n\nEventPipe session performance should be at least proportional to number currently running threads, not threads that have ever existed during the session.\n\nEventPipe \"thread session states\" should be garbage collected in all EventPipe session types, so that the length of the thread session state linked-list approximates the number of currently running threads.\n\n### Actual behavior\n\nAfter a non-file, non-IPC EventPipe session is created, any new threads created will cause the `.NET Long Runni` thread to consume more and more CPU for each event it collects.\n\n### Regression?\n\nI haven\u0027t tried this on .NET 5.0, so I\u0027m not sure, but it\u0027s been around since at least .NET 6.0 when EventPipe was rewritten in C.\n\n### Known Workarounds\n\nIf the EventPipe session is closed and reopened, the new session will start with an empty \"thread state session list\" and the old one will have cleaned everything up. This also happens if an active EventPipe session is reconfigured, which ends up closing and opening a new session anyways.\n\nAnother workaround would be to only use file or IPC-type EventPipe sessions if possible, as these session types do run garbage collection on the \"thread session state list\".\n\n### Configuration\n\nTested locally on .NET 8.0.404 and .NET 9.0.101, on a Linux laptop running Ubuntu 24.04 (kernel 6.8.0) with an Intel i7-13800H processor.\n\nHave seen this in production in containers on both Intel and AMD processors, all x86, on various Linux kernels. I don\u0027t believe this issue is specific to any particular system or architecture.\n\n### Other information\n\nWhen I test creating 5,000 synchronous, short-lived threads, and then throwing 5,000,000 exceptions on .NET 9.0.101 on my Linux laptop, `perf` reports the following \"Self\" times with `libcoreclr.so` offsets:\n```\n26.23%  .NET Long Runni  libcoreclr.so  [.] 0x00000000004f9eda\n13.61%  .NET Long Runni  libcoreclr.so  [.] 0x00000000004f9ed6\n 7.88%  .NET Long Runni  libcoreclr.so  [.] 0x00000000004f9ed2\n```\n\nFor some reason, on my laptop, the `perf` addresses are off by exactly 0x1000. I couldn\u0027t tell you why, but I have validated this behavior with .NET 8.0.404 on my laptop, and I\u0027ve seen this exact same issue in at least 5 different production systems all on different .NET versions with correct `perf` addresses.\n\nUnfortunately, [`libcoreclr.so` isn\u0027t built with debug symbols, and no debuginfo is published for it](https://github.com/dotnet/runtime/issues/1924), so I\u0027ve had to reverse-engineer `libcoreclr.so` to match the disassembly with the source code to figure out what is going on here. Below are the .NET 9.0 slow instructions in question:\n\n```asm\n004faec5  4d8b6d08           mov     r13, qword [r13+0x8]\n004faec9  4d85ed             test    r13, r13\n004faecc  0f848f000000       je      0x4faf61\n\n004faed2  498b4500           mov     rax, qword [r13]\n004faed6  488b5818           mov     rbx, qword [rax+0x18]\n004faeda  4c8b7b10           mov     r15, qword [rbx+0x10]\n004faede  4d85ff             test    r15, r15\n004faee1  74e2               je      0x4faec5\n```\n\nThis is the section from `buffer_manager_move_next_event_any_thread` that [iterates each thread session state to find a single event](https://github.com/dotnet/runtime/blob/v9.0.0/src/native/eventpipe/ep-buffer-manager.c#L607), which will then be sent back through to the EventListener.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOuvk4TQ==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6bMJGC",
                                           "createdAt":  "2025-01-21T04:51:29Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tommcdon",
                                           "body":  "@mdh1418 ",
                                           "updatedAt":  "2025-01-21T04:51:29Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6bMPY3",
                                           "createdAt":  "2025-01-21T05:16:57Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "\u003e libcoreclr.so isn\u0027t built with debug symbols, and no debuginfo is published for it\n\nlibcoreclr.so symbols are published for the Microsoft-built binaries. You can use https://learn.microsoft.com/en-us/dotnet/core/diagnostics/dotnet-symbol tool to download them.",
                                           "updatedAt":  "2025-01-21T05:16:57Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6bQlbr",
                                           "createdAt":  "2025-01-21T14:00:28Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dqsully",
                                           "body":  "Didn\u0027t know about that, thanks @jkotas! It would be nice if using `dotnet-symbol` to supplement `perf` or other non-coredump tools was clearly documented somewhere. (Or if it is, I couldn\u0027t find it)\n\nIf anyone needs to replicate this in the future, here\u0027s what I did:\n- Make sure `dotnet-dump` and `dotnet-symbol` are installed (e.g. `dotnet tool install --global dotnet-symbol`)\n- Download debug symbols with `dotnet-symbol /usr/local/share/dotnet/shared/Microsoft.NETCore.App/9.0.0/libcoreclr.so` (or wherever your `libcoreclr.so` is, thanks @jkotas for the tip)\n- Run `perf record` from the same directory as the debug symbols\n\nRunning that same 5,000 thread/5,000,000 exception test from before with the debug symbols shows this output in `perf`:\n\n![Image](https://github.com/user-attachments/assets/5bcaed12-9f5c-4ac1-af45-99bc750f8c50)\n\n![Image](https://github.com/user-attachments/assets/6897ac6d-535c-47f7-a027-cd698462e9e4)",
                                           "updatedAt":  "2025-01-21T16:20:30Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6bRRr7",
                                           "createdAt":  "2025-01-21T15:10:36Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEDbd5A==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "dqsully",
                                                                               "createdAt":  "2025-01-21T16:17:12Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "jkotas",
                                           "body":  "\u003e If anyone needs to replicate this in the future, here\u0027s what I did\n\nNit: You do not have to go through a dump file. You can directly point dotnet-symbol to the binaries that you need the symbols downloaded for: `dotnet-symbol .../shared/Microsoft.NETCore.App/9.0.0/libcoreclr.so` or `dotnet-symbol .../shared/Microsoft.NETCore.App/9.0.0/*`. Replace `...` with the installation path on your system.",
                                           "updatedAt":  "2025-01-21T15:10:36Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6bY74h",
                                           "createdAt":  "2025-01-22T11:35:46Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEDlyaw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "mdh1418",
                                                                               "createdAt":  "2025-01-22T16:12:43Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "lateralusX",
                                           "body":  "Using an in-proc EventListener together with native dotnet runtime events will flow differently through EventPipe since they need to surface into managed code. Using regular EventPipe sessions (like file or IPC) includes logic to write events into the nettrace file format as part of ep_session_write_all_buffers_to_file, https://github.com/dotnet/runtime/blob/1f93ea7763a6391a9063c5e35843253f3d666893/src/native/eventpipe/ep-session.c#L471,  called by the streaming thread, https://github.com/dotnet/runtime/blob/1f93ea7763a6391a9063c5e35843253f3d666893/src/native/eventpipe/ep-session.c#L62 and that includes logic to remove exhausted session states from the buffer managers thread session state list, making sure they are removed after all data has been serialized into the nettrace file format.\n\nSurfacing events into managed code from EventPipe follow a different pattern, in that case the session is owned by EventPipeEventDispatcher managed class and handled here, https://github.com/dotnet/runtime/blob/1f93ea7763a6391a9063c5e35843253f3d666893/src/libraries/System.Private.CoreLib/src/System/Diagnostics/Tracing/EventPipeEventDispatcher.cs#L174. It looks like that code will never do anything to collect the exhausted session states like done in the file/IPC case using streaming thread. That probably explains this issue and it will only be reproducible for in-proc listeners consuming native runtime events.\n\nI would expect the fix to include a similar mechanism for this path like we have in the file/IPC case, collect exhausted session states, we just need to make sure to not introduce to much overhead related to GetNextEvent since it could be on a very hot path.\n\n@mdh1418 I guess above info will give you a good place to start investigating a fix for this issue.\n\n",
                                           "updatedAt":  "2025-01-22T11:37:10Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6boQ-u",
                                           "createdAt":  "2025-01-23T21:10:05Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dmex",
                                           "body":  "\u003e As the number of threads ever spawned increases, the .NET Long Runni thread that processes these CLR events will get slower and slower and tend towards 100% CPU time, even if the number of currently running threads stays constant.\n\nThere\u0027s also a separate issue here where it doesn\u0027t close any thread handles causing a memory leak:\n\n\u003cimg width=\"364\" alt=\"Image\" src=\"https://github.com/user-attachments/assets/b3c8633e-5915-4018-bedd-cf8fe6e506b7\" /\u003e",
                                           "updatedAt":  "2025-01-23T21:10:05Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6bsN_O",
                                           "createdAt":  "2025-01-24T09:29:08Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "lateralusX",
                                           "body":  "ok, that is probably a different thing, EventPipe doesn\u0027t hold on to OS thread handles, it uses its own representation of a thread, since the actual thread might not be around when events get flushed into the stream. Does it only repro if you have an in-proc EventListener that enables Microsoft-Windows-DotNETRuntime and spawns a lot of short-lived threads?",
                                           "updatedAt":  "2025-01-24T09:29:53Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6b2w9t",
                                           "createdAt":  "2025-01-27T04:25:58Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEIxgzg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Reasonably",
                                                                               "createdAt":  "2025-03-06T11:34:45Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "npubl629",
                                           "body":  "Hello, I would like to report my own repro of this issue. Similar to dqsully - running .Net 8 on linux with Datadog which captures runtime metrics via \"Microsoft-Windows-DotNETRuntime\" event pipe listener, and uses short-lived threads to push those events to an external agent. (related issue https://github.com/DataDog/dd-trace-dotnet/issues/5862)\n\nThere does seem to be an extremely subtle memory leak though my team discovered the issue last year on .Net 6 as our k8s pods started consuming more CPU over several weeks.\n\n![Chart of CPU Usage](https://raw.githubusercontent.com/npubl629/dd-trace/master/v1/postprocessing/cpu-usage.png)\n![Chart of Memory Usage](https://raw.githubusercontent.com/npubl629/dd-trace/master/v1/postprocessing/mem-diff.png)\n\nI have a faster repro now (still depends on datadog) and collected a trace with perfcollect.\n[sampleTrace.trace.zip](https://github.com/user-attachments/files/18553387/sampleTrace.trace.zip)\nRepro source: https://github.com/npubl629/dd-trace/tree/master/v2\n\n@dqsully you may be interested in my [debugging notes and links to relevant documentation](https://github.com/npubl629/dd-trace/blob/master/v2/debugging-notes.md), particularly [this article](https://learn.microsoft.com/en-us/dotnet/core/diagnostics/trace-perfcollect-lttng). My linked repo is hopefully easy to follow for getting perfcollect and lldb working with jit dumps and perfmaps (note there are several env vars in Dockerfiles and docker-compose).\n\nI also found these old issues which seem related. Not sure they are of much use but haven\u0027t seen them mentioned yet.\nhttps://github.com/dotnet/runtime/issues/43985\nhttps://github.com/dotnet/runtime/issues/49804\n",
                                           "updatedAt":  "2025-01-27T04:25:58Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc66-ThN",
                                           "createdAt":  "2025-07-30T15:45:52Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "steveisok",
                                           "body":  "After some discussion, I don\u0027t think we\u0027ll be able to land anything other than something incremental in 10. The intention is to try and land a proper fix early in 11. ",
                                           "updatedAt":  "2025-07-30T15:45:52Z"
                                       }
                                   ],
                         "totalCount":  9
                     },
        "title":  "CoreCLR EventPipe CPU+memory leak",
        "labels":  [
                       "area-Tracing-coreclr",
                       "in-pr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/113412",
        "createdAt":  "2025-03-12T07:56:19Z",
        "number":  113412,
        "author":  "AloisKraus",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-07-15T18:07:19Z",
        "body":  "### Description\n\nCurrently it is not possible to record ETW Shutdown traces for JITed code (.NET and .NET Core). I am mainly interested also for a solution for .NET Framework classic but the behavior is the same for .NET Core.\n\nWindows Shutdown recording is unique in the sense that at the end of the shutdown no ETW Rundown can be performed to emit the JIT events MethodUnloadVerbose and friends which are needed to decode JITed stacks for which the initial JIT event could not be recorded.\n\n\n\n### Reproduction Steps\n\nLets suppose that little application\n\n```\nusing System.Diagnostics;\n\nnamespace ShutdownTester\n{\n    internal class Program\n    {\n        static void Main(string[] args)\n        {\n            while(true)\n            {\n                Console.WriteLine(\"Press any key to call into some methods\");\n                Console.ReadKey();\n                \n                new Program().Run();\n                Console.WriteLine(\"Run completed\");\n            }\n        }\n\n        private void Run()\n        {\n            var sw = Stopwatch.StartNew();\n            while(sw.Elapsed.TotalSeconds \u003c 1)\n            {\n\n            }\n        }\n    }\n}\nShutdownTester.exe       \nPress any key to call into some methods\n Run completed\nPress any key to call into some methods\n Run completed\nPress any key to call into some methods\nRun completed\nPress any key to call into some methods\nRun completed\nPress any key to call into some methods\n```\n\n- Start Test application and press a the key once to JIT all methods. \n- Start ETW recording\n- Press any in tester application to consume CPU\n- Stop ETW recording without the usual Rundown to simulate shutdown recording.\n\n```\nwpr -start cpu -filemode -recordtempto c:\\temp  \nPress key in tester once or more.\nxperf -stop \"WPR_initiated_WprApp_WPR System Collector\"  -stop \"WPR_initiated_WprApp_WPR Event Collector\"     \nxperf -merge \"c:\\temp\\WPR_initiated_WprApp_WPR System Collector.etl\" \"c:\\temp\\WPR_initiated_WprApp_WPR Event Collector.etl\" c:\\temp\\testMerge.etl \n```\n\n![Image](https://github.com/user-attachments/assets/7bb41bb9-9ae8-49dc-8bfc-d4af5e3308de)\n\nyou find missing stack frames with ?!? as method name. \n\nAs workaround I have tried to emit the Rundown events before tracing was stopped with a CaptureStateOnDemand call which will emit the ETW CLR rundown events just like during regular stop with my custom profile: \n```\nwpr -start MultiProfile.wprp -filemode -recordtempto c:\\temp   \nPress any key before Capture State will lead to resolved stacks\nwpr -capturestateondemand\nPress any key after Capture State will lead to unresolved ?!? stacks because the ETW stack parsers treat this method as already unloaded.\nxperf -stop \"WPR_initiated_WprApp_WPR System Collector\" -stop \"WPR_initiated_WprApp_WPR Rundown Event Collector\" -stop \"WPR_initiated_WprApp_WPR User Event Collector\" \nxperf -merge \"c:\\temp\\WPR_initiated_WprApp_WPR System Collector.etl\" \"c:\\temp\\WPR_initiated_WprApp_WPR Rundown Event Collector.etl\" \"c:\\temp\\WPR_initiated_WprApp_WPR User Event Collector.etl\" c:\\temp\\TestCaptureStateComamnd.etl\n```\nThat does only work partially because all current ETW parsers do not decode the stack frames which were seen the first time after the MethodUnloadVerbose event. The semantics of unload the MethodUnloadVerbose  is that after that time if this method is called again it cannot be used to decode the stack frame because it has been unloaded. \n\nI am left with two options:\n - Rewrite the ETL to shift the MethodUnloadVerbose at the end of the ETW session. I have tried TraceEvent which supports relogging but so far my attempts have failed to reemit the events with a different time stamp. Any example would be nice. \n -  The ability to emit not MethodUnloadVerbose but MethodJittingStarted events\n\n\n### Expected behavior\n\nAbitility to record JITed stack frames during shutdown trace.\nWhat are the options here? \n\n[MultiProfile.zip](https://github.com/user-attachments/files/19205455/MultiProfile.zip)\n\n### Actual behavior\n\nJITed stacks are decoded with ?!?\n\n### Regression?\n\nNo\n\n### Known Workarounds\n\nNo\n\n### Configuration\n\n.NET Core all versions and .NET Framework classic. The behavior is the same.\n\n### Other information\n\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOqVL3KQ==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6it2NR",
                                           "createdAt":  "2025-03-17T15:20:07Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tommcdon",
                                           "body":  "@brianrob @noahfalk ",
                                           "updatedAt":  "2025-03-17T15:20:07Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6k1SJ7",
                                           "createdAt":  "2025-03-31T08:00:28Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AloisKraus",
                                           "body":  "Is this going to be addressed also for .NET Framework? ",
                                           "updatedAt":  "2025-03-31T08:00:28Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6pSqvg",
                                           "createdAt":  "2025-04-29T21:06:15Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tommcdon",
                                           "body":  "Hi @AloisKraus!  I apologize for the delayed response. It\u0027s a known limitation of .NET ETW profiling when profiling JIT\u0027d methods at or after runtime shutdown.",
                                           "updatedAt":  "2025-04-29T21:06:15Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6pUvcp",
                                           "createdAt":  "2025-04-30T04:40:59Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "AloisKraus",
                                           "body":  "Hi Tom. Yes but what can one do about it? I can also live with a relogging the events by shifting them \nat the end of the trace but so far I was not successful. When I tried to change the timestamp these events did not show up in the relogged etl file with TraceEvent library. \nAn example how to shift event times would be great. ",
                                           "updatedAt":  "2025-04-30T04:40:59Z"
                                       }
                                   ],
                         "totalCount":  4
                     },
        "title":  "Windows Shutdown ETW Recording for JITed stacks is not working.",
        "labels":  [
                       "enhancement",
                       "area-Tracing-coreclr"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/118939",
        "createdAt":  "2025-08-20T19:14:29Z",
        "number":  118939,
        "author":  "Yajur-Grover",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-09-15T14:50:39Z",
        "body":  "### Description\n\nI have an EventSource provider that is firing off events in an application, which I am unable to view when trying to use WPR to generate an .etl file. When reading the .etl file using WPA, the events from the provider do not show up in the \u0027Generic Events\u0027 tab. The only provider coming up is an \u0027EventTrace\u0027 provider. \n\n\u003cimg width=\"1701\" height=\"464\" alt=\"Image\" src=\"https://github.com/user-attachments/assets/65456936-238d-4ef8-929d-65ab56be979c\" /\u003e\n\nI am deploying my .NET app to a VM. I tried running WPR on both my local machine and the VM but wasn\u0027t able to pick the provider up on either of them. \n\n### Reproduction Steps\n\nThe overall app is quite large, but the EventSource relevant code is here (all these files are in the same project):\n\nAgentProxyEventSource.cs:\n```\nusing System.Diagnostics.Tracing;\n\nnamespace AgentIsolationEnvironment.AgentProxy;\n\n[EventSource(Name = \"AgentProxyProvider\")]\npublic class AgentProxyEventSource: EventSource\n{\n    public static AgentProxyEventSource Log { get; } = new AgentProxyEventSource();\n\n    [Event(1)]\n    public void TestEvent(string message)\n    {\n        WriteEvent(1, message);\n    }\n}\n```\n\nCoreService.cs (running when the app is being deployed):\n```\npublic override async Create() \n{\n....\nAgentProxyEventSource.Log.TestEvent(\"Testing\");\n...\n}.\n```\n\nWhen setting breakpoints in VS in the TestEvent code, they are being hit, but the events are not showing up, which makes me thing that I am missing something when trying to collect events. Is there any recommended guidance you have for collecting EventSource events when deploying a project to a VM?\n\n### Expected behavior\n\nEvents show up in .etl file.\n\n### Actual behavior\n\nEvents do not show up.\n\n### Regression?\n\n_No response_\n\n### Known Workarounds\n\n_No response_\n\n### Configuration\n\n.NET 8\nVM is running on ge_current_directwinai_dev1\nx64\n\nHitting this issue on other VMs on different branches.\n\n### Other information\n\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOv6Tcxw==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6_pNzH",
                                           "createdAt":  "2025-08-22T18:29:17Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "steveisok",
                                           "body":  "@Yajur-Grover take a look at https://learn.microsoft.com/en-us/dotnet/core/diagnostics/eventsource-collect-and-view-traces. \n\nGuessing the eventsource isn\u0027t enabled when you\u0027re starting the session.",
                                           "updatedAt":  "2025-08-22T18:29:17Z"
                                       }
                                   ],
                         "totalCount":  1
                     },
        "title":  "Unable to view events from EventSource provider",
        "labels":  [
                       "question",
                       "area-Tracing-coreclr"
                   ]
    }
]
