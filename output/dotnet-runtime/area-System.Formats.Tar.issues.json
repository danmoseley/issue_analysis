[
    {
        "url":  "https://github.com/dotnet/runtime/issues/68230",
        "createdAt":  "2022-04-19T20:07:26Z",
        "number":  68230,
        "author":  "carlossanlop",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-05-21T16:23:09Z",
        "body":  "Initial PR changes were introduced here: https://github.com/dotnet/runtime/pull/67883\r\n\r\nThe following is pending feedback I need to address (not urgent, for 8.0, mostly just additional testing coverage):\r\n\r\nPerf improvements:\r\n- [x] Address stackalloc and stream-related suggestions by @stephentoub .\r\n- [x] Improve code that retrieves the extended attributes from the data section. Use IndexOf and related APIs suggested by Stephen.\r\n- [x] After IndexOfAnyExcept gets merged, consider using it: https://github.com/dotnet/runtime/pull/67941\r\n- [x] Improve the code from Archiving.Utils.Windows.cs https://github.com/dotnet/runtime/pull/67883#discussion_r853047222\r\n\r\nAdditional test coverage:\r\n- [ ] Make sure that when archiving an executable, then extracting it, the executable mode bit gets properly preserved.\r\n- [ ] Add test that reads an archive containing an unsupported entry type (no writing).\r\n- [ ] Add test that ensures a hidden file can be used to create an entry from file.\r\n- [ ] Verify these GNU fields are written in the data stream: AllGnuUnused = Offset + LongNames + Unused + Sparse + IsExtended + RealSize.\r\n- [ ] Add test that ensures that a GNU archive (generated with tar tool) containing unused GNU bytes (sparse, etc) get preserved when written to another GNU archive.\r\n- [x] Add test to extract entries to disk one by one.\r\n- [x] Add test with entries containing relative segments that would cause extraction to happen outside of destination directory.\r\n- [x] Add test that opens one file concurrently, to prevent https://github.com/dotnet/runtime/pull/68361 from happening again.\r\n- [ ] Add test that verifies that adding a Windows path with \u0027\\\u0027 separators changes them to \u0027/\u0027.\r\n- [x] Consider enabling CA1305: https://github.com/dotnet/runtime/pull/67883#discussion_r853328091\r\n- [ ] Add to the runtime-assets script an unarchived test with both a longlink and a longpath.\r\n- [ ] Find out how (if possible) to add a file as a hardlink, because otherwise, it can only be created directly as an entry, not by reading it from the filesystem.\r\n- [ ] Share WrappedStream in Common as suggested by @danmoseley .\r\n\r\nDone:\r\n- [x] Address documentation suggestions, make sure all exceptions and remarks are properly filled out.\r\n- [x] Make sure I have full tests for individual extraction of all data types.\r\n- [x] Add test that advances DataStream a bit before extracting into filesystem, verify data was written starting from that position.\r\n- [x] Add Ustar checksum test.\r\n- [x] Add Pax checksum test.\r\n- [x] Add Gnu checksum test.\r\n- [x] Think of a better way to verify DateTimeOffsets in tests.\r\n  - [x] Ensure extended attribute timestamps atime and ctime are converted to/from decimal, not double.\r\n- [x] Implement async APIs: https://github.com/dotnet/runtime/pull/70574\r\n- [x] Add test that reads an archive from a file with both a longlink and a longpath.\r\n- [x] Address chmod suggestions by @tmds : https://github.com/dotnet/runtime/pull/71647 https://github.com/dotnet/runtime/pull/71760\r\n- [x] Archives created in MacOS fail to get extracted if entries start with `.\\`. https://github.com/dotnet/runtime/issues/70516\r\n- [x] Fix failing tests around timestamps (most likely due to access time being modified, and expected value is now different). https://github.com/dotnet/runtime/pull/71038\r\n  - [x] File tests: [#69474](https://github.com/dotnet/runtime/issues/69474), [#70060](https://github.com/dotnet/runtime/issues/70060), test disabled with https://github.com/dotnet/runtime/pull/69997\r\n  - [x] Symbolic link tests might also have [the same issue](https://github.com/dotnet/runtime/pull/69997/files#r885209363).\r\n- [x] Verify extended attributes in all PAX tests.\r\n- [x] Investigate why retrieving the devmajor and devminor with syscalls are not matching the expected values. https://github.com/dotnet/runtime/pull/67883/files#r852463720\r\n  - [x] Re-enable the tests that verify the values https://github.com/dotnet/runtime/pull/71988\r\n- [X] Add tests that verify readerOfOrigin still works as expected when using the new conversion constructor to transform an entry from one format to another. https://github.com/dotnet/runtime/pull/70325\r\n- [x] Allow multiple Global Extended Attributes entries.\r\n  - [X] Proposal: https://github.com/dotnet/runtime/issues/69935\r\n  - [x] PR: https://github.com/dotnet/runtime/pull/70869\r\n- [x] Follow up on `Format` detection in the reader when an archive has entries of multiple formats. SharpCompress and 7-zip handle this, we should too.\r\n  - [X] Proposal: https://github.com/dotnet/runtime/issues/69544\r\n  - [x] PR to rename enum: https://github.com/dotnet/runtime/pull/70313\r\n- [X] Add Tar conversion constructors https://github.com/dotnet/runtime/pull/70325\r\n- [X] Add simple tests to verify uncompressing a tar.gz works. PR: https://github.com/dotnet/runtime/pull/70178\r\n- [x] Fix hardlink test failure on Android/iOS/tvOS due to possible elevation requirement. Issue: https://github.com/dotnet/runtime/issues/68360 - Fix: https://github.com/dotnet/runtime/pull/69416\r\n- [x] Find all the stream.Read calls and make sure we read all that was expected (use similar logic to what\u0027s being done in ReadOrThrow). - This was addressed by @eerhardt in https://github.com/dotnet/runtime/pull/69272\r\n- [x] Discuss if the TarFile extraction methods should extract something and throw at the end. - It was decided that we should throw immediately. We don\u0027t know if the archive is malformed after the error happens.\r\n- [x] Remove src csproj nullable enable after @eerhardt merges his PR.\r\n- [x] Implement p/invokes that retrieve UName and GName from uid and gid.\r\n- [x] Enable csproj in $(NetCoreAppCurrent)-Browser.\r\n- [x] Need to add the assembly to NetCoreAppLibrary.props to ensure it gets shipped as part of shared framework.\r\n- [x] Add a symlink test that has a link with an absolute path to a target.\r\n- [x] Remove errno from makedev, major and minor syscalls. They don\u0027t set it.\r\n- [x] Discuss if we want to merge DevMajor and DevMinor into a single public API. https://github.com/dotnet/runtime/issues/68974",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOrMRQdg==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5Bv5Tt",
                                           "createdAt":  "2022-04-19T20:07:29Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "I couldn\u0027t figure out the best area label to add to this issue. If you have write-permissions please help me learn by adding exactly one [area label](https://github.com/dotnet/runtime/blob/master/docs/area-owners.md).",
                                           "updatedAt":  "2022-04-19T20:07:29Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Bv7Fx",
                                           "createdAt":  "2022-04-19T20:11:46Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-io\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nI received feedback in my first Tar PR https://github.com/dotnet/runtime/pull/67883 that I would like to address in a follow-up PR.\r\n\r\n- [ ] Address chmod suggestions by @tmds .\r\n- [ ] Address stackalloc and stream-related suggestions by @stephentoub .\r\n- [ ] Implement UName and GName from the current process\u0027 gid and uid, maybe use GetNameFromUid and (new) GetNameFromGid.\r\n- [ ] Make sure I have full tests for individual extraction of all data types.\r\n- [ ] Add a symlink test that has a link with an absolute path to a target.\r\n- [ ] Make sure that when archiving an executable, then extracting it, the executable mode bit gets properly preserved.\r\n- [ ] Add test that reads an archive containing an unsupported entry type (no writing).\r\n- [ ] Add test that advances DataStream a bit before extracting into filesystem, verify data was written starting from that position.\r\n- [ ] Add test that ensures a hidden file can be used to create an entry from file.\r\n- [ ] Verify these GNU fields are written in the data stream: AllGnuUnused = Offset + LongNames + Unused + Sparse + IsExtended + RealSize.\r\n- [ ] Add test that ensures that a GNU archive (generated with tar tool) containing unused GNU bytes (sparse, etc) get preserved when written to another GNU archive.\r\n- [ ] Add simple tests to verify uncompressing a tar.gz works.\r\n- [ ] Add test to extract entries to disk one by one.\r\n- [ ] Verify extended attributes in all PAX tests.\r\n- [ ] Add Ustar checksum test.\r\n- [ ] Add Pax checksum test.\r\n- [ ] Add Gnu checksum test.\r\n- [ ] Find all the stream.Read calls and make sure we read all that was expected (use similar logic to what\u0027s being done in ReadOrThrow).\r\n- [ ] Investigate why retrieving the devmajor and devminor with syscalls are not matching the expected values.\r\n- [ ] Add to the runtime-assets script an unarchived test with both a longlink and a longpath.\r\n- [ ] Add test that reads an archive from a file with both a longlink and a longpath.\r\n- [ ] Address documentation suggestions, make sure all exceptions and remarks are properly filled out.\r\n- [ ] Remove src csproj nullable enable after @eerhardt merges his PR.\r\n- [ ] Find out how (if possible) to add a file as a hardlink, because otherwise, it can only be created directly as an entry, not by reading it from the filesystem.\r\n- [ ] Think of a better way to verify DateTimeOffsets in tests.\r\n- [ ] Implement async TarFile APIs.\r\n- [ ] Implement async TarEntry APIs.\r\n- [ ] Implement async TarWriter APIs.\r\n- [ ] Implement async TarReader APIs.\r\n- [ ] Share WrappedStream in Common as suggested by @danmoseley .\r\n- [ ] Discuss if the TarFile extraction methods should extract something and throw at the end.\r\n- [ ] Discuss if we want to merge DevMajor and DevMinor into a single public API.\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003ecarlossanlop\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003ecarlossanlop\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.IO`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-04-19T20:11:46Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5DP_xE",
                                           "createdAt":  "2022-05-17T00:23:34Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCdH2qw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "danmoseley",
                                                                               "createdAt":  "2022-05-17T02:20:50Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "carlossanlop",
                                                                               "createdAt":  "2022-05-17T04:16:52Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "Bio2hazard",
                                           "body":  "On .NET 7 Preview 4,\r\nI\u0027ve been testing the Tar APIs on some `tar.gz` files created on our teamcity agents (in `ustar` format) and ran into 2 issues:\r\n\r\n- When using `TarReader` over a unseekable `GZipStream` it manages to read the first entry, but fails on the second one with an `EndOfStreamException` emitted in TarHelpers.cs line 40. \r\n- When using `TarReader` over a seekable MemoryStream, it fails when it encounters a long filename that the tar format splits into a separate header. It detects it as a GNU format instead of `ustar` and fails with ` Entry \u0027blah\u0027 was expected to be in the GNU format, but did not have the expected version data.`\r\n\r\nHope that helps.",
                                           "updatedAt":  "2022-05-17T00:23:34Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5DQeWy",
                                           "createdAt":  "2022-05-17T04:17:26Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "carlossanlop",
                                           "body":  "Thank you for your report, @Bio2hazard ! Any chance you can share a sample tar for each one of your experiments?",
                                           "updatedAt":  "2022-05-17T04:17:26Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5DTj89",
                                           "createdAt":  "2022-05-17T18:44:57Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCdmj5Q==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "carlossanlop",
                                                                               "createdAt":  "2022-05-19T05:43:04Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "Bio2hazard",
                                           "body":  "@carlossanlop yes I was able to reproduce it without sensitive information, thankfully. Here it is: \r\n[testarchive.tar.gz](https://github.com/dotnet/runtime/files/8710679/testarchive.tar.gz)\r\n\r\nIt has 3 files in it:\r\n- `testfile1.txt` which should have 5 paragraphs of lorem ipsum\r\n- `testfile3.txt` which has the same content as testfile1.txt\r\n- `testing-a-verylong.filename-that-cant-fit-in-a-single.tar-header-and-will-probably-fail-to-load-correctly.txt` which just contains its own filename\r\n\r\nI was trying to benchmark it, so I\u0027ll just drop the benchmarking code in here. Goal is just to get the content `byte[]` for every file in the archive.\r\n\r\n```csharp\r\nusing System.Formats.Tar;\r\nusing System.IO.Compression;\r\nusing BenchmarkDotNet.Attributes;\r\n\r\nnamespace Benchmarks7;\r\n\r\n[GcServer(true)]\r\n[GcForce(true)]\r\n[MemoryDiagnoser]\r\npublic class ReadFromTarGz\r\n{\r\n    private static byte[] fileData;\r\n\r\n    public ReadFromTarGz()\r\n    {\r\n\t    fileData = File.ReadAllBytes(@\"testarchive.tar.gz\");\r\n    }\r\n\r\n    [Benchmark]\r\n    public List\u003cbyte[]\u003e WithSharpCompress()\r\n    {\r\n        var ret = new List\u003cbyte[]\u003e();\r\n        using (var fileStream = new MemoryStream(fileData))\r\n        using (var stream = new System.IO.Compression.GZipStream(fileStream, CompressionMode.Decompress))\r\n        using (var tarReader = SharpCompress.Readers.Tar.TarReader.Open(stream))\r\n        {\r\n    \t    while (tarReader.MoveToNextEntry())\r\n    \t    {\r\n    \t\t    var entry = tarReader.Entry;\r\n                if (entry.IsDirectory)\r\n    \t\t    {\r\n    \t\t\t    continue;\r\n    \t\t    }\r\n\r\n    \t\t    byte[] entryData = new byte[entry.Size];\r\n    \t\t    using (var fileMemoryStream = new MemoryStream(entryData))\r\n    \t\t    using (var entryStream = tarReader.OpenEntryStream())\r\n    \t\t    {\r\n    \t\t\t    entryStream.CopyTo(fileMemoryStream);\r\n    \t\t    }\r\n                ret.Add(entryData);\r\n    \t    }\r\n        }\r\n\r\n        return ret;\r\n    }\r\n\r\n    [Benchmark]\r\n    public List\u003cbyte[]\u003e WithSystemsFormatTar_PreDecompressed()\r\n    {\r\n\t    var ret = new List\u003cbyte[]\u003e();\r\n\t    using var decompressedStream = new MemoryStream();\r\n\r\n\t    using (var fileStream = new MemoryStream(fileData))\r\n\t    using (var stream = new System.IO.Compression.GZipStream(fileStream, CompressionMode.Decompress))\r\n\t    {\r\n\t\t    stream.CopyTo(decompressedStream);\r\n\t    }\r\n\r\n\t    decompressedStream.Position = 0;\r\n\r\n\t    using (var tarReader = new System.Formats.Tar.TarReader(decompressedStream))\r\n\t    {\r\n\t\t    System.Formats.Tar.TarEntry entry;\r\n\t\t    while ((entry = tarReader.GetNextEntry()) != null)\r\n\t\t    {\r\n\t\t\t    if (entry.EntryType == TarEntryType.Directory)\r\n\t\t\t    {\r\n\t\t\t\t    continue;\r\n\t\t\t    }\r\n\r\n\t\t\t    byte[] entryData = new byte[entry.Length];\r\n\t\t\t    using (var fileMemoryStream = new MemoryStream(entryData))\r\n\t\t\t    {\r\n\t\t\t\t    entry.DataStream.CopyTo(fileMemoryStream);\r\n\t\t\t    }\r\n\t\t\t    ret.Add(entryData);\r\n\t\t    }\r\n\t    }\r\n\r\n\t    return ret;\r\n    }\r\n\r\n    [Benchmark]\r\n    public List\u003cbyte[]\u003e WithSystemsFormatTar_StreamedDecompression()\r\n    {\r\n\t    var ret = new List\u003cbyte[]\u003e();\r\n\t    using (var fileStream = new MemoryStream(fileData))\r\n\t    using (var stream = new System.IO.Compression.GZipStream(fileStream, CompressionMode.Decompress))\r\n\t    using (var tarReader = new System.Formats.Tar.TarReader(stream))\r\n\t    {\r\n\t\t    System.Formats.Tar.TarEntry entry;\r\n\t\t    while ((entry = tarReader.GetNextEntry()) != null)\r\n\t\t    {\r\n\t\t\t    if (entry.EntryType == TarEntryType.Directory)\r\n\t\t\t    {\r\n\t\t\t\t    continue;\r\n\t\t\t    }\r\n\r\n\t\t\t    byte[] entryData = new byte[entry.Length];\r\n\t\t\t    using (var fileMemoryStream = new MemoryStream(entryData))\r\n\t\t\t    {\r\n\t\t\t\t    entry.DataStream.CopyTo(fileMemoryStream);\r\n\t\t\t    }\r\n\t\t\t    ret.Add(entryData);\r\n\t\t    }\r\n\t    }\r\n\r\n\t    return ret;\r\n    }\r\n\r\n    [Benchmark]\r\n    public List\u003cbyte[]\u003e WithSystemsFormatTar_StreamedDecompression_WithCopyData()\r\n    {\r\n\t    var ret = new List\u003cbyte[]\u003e();\r\n\t    using (var fileStream = new MemoryStream(fileData))\r\n\t    using (var stream = new System.IO.Compression.GZipStream(fileStream, CompressionMode.Decompress))\r\n\t    using (var tarReader = new System.Formats.Tar.TarReader(stream))\r\n\t    {\r\n\t\t    System.Formats.Tar.TarEntry entry;\r\n\t\t    while ((entry = tarReader.GetNextEntry(true)) != null)\r\n\t\t    {\r\n\t\t\t    if (entry.EntryType == TarEntryType.Directory)\r\n\t\t\t    {\r\n\t\t\t\t    continue;\r\n\t\t\t    }\r\n\r\n\t\t\t    byte[] entryData = new byte[entry.Length];\r\n\t\t\t    using (var fileMemoryStream = new MemoryStream(entryData))\r\n\t\t\t    {\r\n\t\t\t\t    entry.DataStream.CopyTo(fileMemoryStream);\r\n\t\t\t    }\r\n\t\t\t    ret.Add(entryData);\r\n\t\t    }\r\n\t    }\r\n\r\n\t    return ret;\r\n    }\r\n}\r\n\r\n```\r\n\r\n- `WithSharpCompress` works as expected\r\n- `WithSystemsFormatTar_PreDecompressed` fails with Exception (which I\u0027ll paste at the bottom of the message)\r\n- `WithSystemsFormatTar_StreamedDecompression` _appears_ to work, but only contains a single result because of the aforementioned `EndOfStreamException` which gets caught internally, so it never gets to the long filename file\r\n- `WithSystemsFormatTar_StreamedDecompression_WithCopyData` throws the same exception as `WithSystemsFormatTar_PreDecompressed`\r\n\r\nException:\r\n```\r\nSystem.Reflection.TargetInvocationException: Exception has been thrown by the target of an invocation.\r\n ---\u003e System.FormatException: Entry \u0027testing-a-verylong.filename-that-cant-fit-in-a-single.tar-header-and-will-probably-fail-to-load-cor\u0027 was expected to be in the GNU format, but did not have the expected version data.\r\n   at System.Formats.Tar.TarHeader.ReadVersionAttribute(Span`1 buffer)\r\n   at System.Formats.Tar.TarHeader.TryGetNextHeader(Stream archiveStream, Boolean copyData)\r\n   at System.Formats.Tar.TarReader.TryProcessGnuMetadataHeader(TarHeader header, Boolean copyData, TarHeader\u0026 finalHeader)\r\n   at System.Formats.Tar.TarReader.TryGetNextEntryHeader(TarHeader\u0026 header, Boolean copyData)\r\n   at System.Formats.Tar.TarReader.GetNextEntry(Boolean copyData)\r\n   at Benchmarks7.ReadFromTarGz.WithSystemsFormatTar_PreDecompressed() in C:\\Development\\Benchmarks7\\ReadFromTarGz.cs:line 65\r\n```\r\n\r\nI hope that helps!",
                                           "updatedAt":  "2022-05-17T18:44:57Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Dbm_X",
                                           "createdAt":  "2022-05-19T07:09:21Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "carlossanlop",
                                           "body":  "Hi again @Bio2hazard ,\r\n\r\nWhat tool did you use to generate the tar file inside your gz file?\r\n\r\nI inspected the internal tar file with the Hex Editor HxD. The `magic` and `version` metadata fields of the first 2 entries indicate the archive is in `ustar` format, but then it contains an unexpected `GNU` format entry with the TarType `LongLink` in the 3rd position (and then a 4th entry containing the actual data, because the `LongLink` entry is a metadata entry). Hence why you\u0027re getting the `FormatException` thrown: the reader detects that the archive is malformed for containing mixed format entries, and it is expected that the exception is thrown when attempting to read the 3rd one.\r\n\r\nHere is what the spec has to say about the `magic` and `version` fields depending on the archive format:\r\n\r\n### For POSIX archives (ustar and pax)\r\n\r\n```\r\n     magic   Contains the magic\tvalue \"ustar\" followed by a NUL\tbyte to\tindi-\r\n\t     cate that this is a POSIX standard\tarchive.  Full compliance re-\r\n\t     quires the\tuname and gname\tfields be properly set.\r\n\r\n     version\r\n\t     Version.  This should be \"00\" (two\tcopies of the ASCII digit\r\n\t     zero) for POSIX standard archives.\r\n```\r\nAnd then a few lines below it says:\r\n```\r\n     Field termination is specified slightly differently by POSIX than by pre-\r\n     vious implementations.  The magic,\tuname, and gname fields\tmust have a\r\n     trailing NUL. \r\n```\r\n\r\n### For GNU\r\n\r\n```\r\n magic   The magic field holds the five characters \"ustar\" followed\tby a\r\n\t     space.  Note that POSIX ustar archives have a trailing null.\r\nversion\r\n\t     The version field holds a space character followed\tby a null.\r\n\t     Note that POSIX ustar archives use\ttwo copies of the ASCII\tdigit\r\n\t     \"0\".\r\n```\r\n\r\nIn other words:\r\n\r\n- For POSIX format archives (ustar or pax), the `magic` + `version` fields, which are one after the other, should look like: `ustar\\000`.\r\n- In the GNU format, should look like: `ustar  \\0`.\r\n\r\nI\u0027m surprised that SharpCompress and 7-zip are able to open this malformed archive. This tells me that they are flexible when it comes to mixed format entries. The spec does not explicitly indicate the entries should all be in the same format, but I interpreted it this way considering there are metadata entries like `L`, `K` (GNU) or `x`, `g` (PAX) which precede other entries. Also, the Unix `tar` CLI tool does not mix format entries, and fails to write entries with long paths and long entries if you create an archive in `v7` or `ustar`, because those formats do not support that.\r\n\r\nBased on the above, I see one public API structure change we should make: If archives are allowed to have mixed entries as we are seeing in your example (or in other words, should not expect all entries to be of the same format), then we would have to remove the public `Format` property from `TarReader`, and we would have to move it to the base `TarEntry` class. That way, the user will have to check this property from each individual entry so they know to which format they should cast the returned entry.\r\n\r\nNote: The `TarWriter` receives a `Format` in the constructor, and this is important, particularly when creating a PAX archive, because the user should be able to add global extended attributes which only show up at the beginning of the archive. So the constructor\u0027s format argument should stay. But if the user creates a V7 or a Ustar formatted archive with the writer, and suddenly decides to write an unsupported entry like a `GnuTarEntry` or a `PaxTarEntry` with a long path or a long link, we should still throw (current behavior), to prevent the user from intermixing formats, exactly like the Unix `tar` CLI tool does.\r\n",
                                           "updatedAt":  "2022-05-19T07:28:30Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Dbon9",
                                           "createdAt":  "2022-05-19T07:17:58Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "carlossanlop",
                                           "body":  "@Bio2hazard I\u0027m really curious how you generated your archive, because even if I address the above by allowing intermixing formats, the `magic` and `version` of your entries are malformed in the 3rd entry: they indicate ustar instead of in gnu format, even though the entry type is `L` which is exclusive to the gnu format. And once again, I\u0027m very surprised that SharpCompress and 7-zip were kind enough to allow it 😄 .",
                                           "updatedAt":  "2022-05-19T07:17:58Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5De4st",
                                           "createdAt":  "2022-05-19T20:23:25Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Bio2hazard",
                                           "body":  "@carlossanlop \r\n\r\nYikes, I was unaware that the archive is in a malformed format. \r\n\r\nSo the _original_ file that I first encountered this problem with was created by TeamCity Enterprise. A build agent designated a folder as the output artifact, and TeamCity automatically turned the folder into a `.tar.gz`. I think [these are the relevant docs](https://www.jetbrains.com/help/teamcity/configuring-general-settings.html#Artifact+Paths) in particular the `target_archive` part.\r\n\r\nThese are the relevant build logs:\r\n\r\n```\r\n[10:46:02] Publishing artifacts (13s)\r\n[10:46:02] [Publishing artifacts] Collecting files to publish: [+:project/dist/dev=\u003eproject-dev-12345-67890-abcdefg.tar.gz]\r\n[10:46:02] [Publishing artifacts] Creating archive project-dev-12345-67890-abcdefg.tar.gz (8s)\r\n[10:46:02] [Creating archive project-dev-12345-67890-abcdefg.tar.gz] Creating /opt/jetbrains/TeamCity_agent/temp/buildTmp/TarPreprocessor1234567890123456789/project-dev-12345-67890-abcdefg.tar.gz\r\n```\r\n\r\nOf course, I can\u0027t exactly share our internal build artifacts, so what I did was:\r\n- Downloaded the build artifact onto my windows 10 machine (and ran into the reported errors when trying to benchmark)\r\n- _Opened_ (not extracted) the `.tar.gz` archive with the 7z GUI\r\n- Navigated into the `.tar` file\r\n- Through the 7z GUI I modified the contents of the tar by adding the 3 test files, and deleting all the proprietary build artifacts\r\n- Then closed the 7z GUI window, which prompts 7z to ask if you want to persist the changes, which I accepted\r\n\r\n![image](https://user-images.githubusercontent.com/2462038/169393410-8b2aa98d-8a4b-4c5a-812a-ffd95b5df681.png)\r\n\r\nMy hope here was that modifying the file in this manner would cause 7z to use the same tar format/style as the original archive produced by TeamCity. \r\n\r\nWhile I understand that that is a fairly ... unorthodox way of creating an archive, I am actually fairly confident it is a faithful reproduction. Debugging the actual TeamCity archive and the supplied test archive shows that they both fail in the same way with the same stack traces. \r\n\r\nFurthermore, I had actually as a proof of concept created a _very rudimentary_ manual tar extractor based on the GNU spec and it also got tripped up and failed at the long link part 😄\r\n\r\nTeamCity is a _big_ player in the CI/CD space, and the artifact publisher that produced this artifact is built-in and native. Given that I could not find any notable user discussions around problems with the artifact archives produced by TeamCity, I have to assume that it is very widely supported despite being malformed. Otherwise I am sure there would be plenty of discussions about it.\r\n\r\nPlease let me know if you need anything else. If you are concerned that the reproduction archive isn\u0027t accurate enough I can provide the header bytes of the original archive.\r\n\r\nEdit: To further make sure the reproduction is accurate:\r\n- I took the original build artifact from teamcity\r\n- made a copy of it\r\n- opened the copy with the 7z GUI, removed a file and saved it\r\n- opened the copy with the 7z GUI a second time, re-added the file and saved it\r\n- compared all 512-byte tar headers between the original and the 7z modified copy: They all matched",
                                           "updatedAt":  "2022-05-19T21:17:25Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5DfvkR",
                                           "createdAt":  "2022-05-20T02:34:42Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "carlossanlop",
                                           "body":  "Thanks for the information, @Bio2hazard . A few more questions:\r\n\r\n\u003e _So the original file that I first encountered this problem with was created by TeamCity Enterprise_\r\n\r\nDo you happen to know what was the original format of the archive? I couldn\u0027t find it in the documentation you shared. The reason I ask is because you then mentioned:\r\n\r\n\u003e _Through the 7z GUI I modified the contents of the tar by adding the 3 test files, and deleting all the proprietary build artifacts_\r\n\r\nWhich I interpret as: you deleted all the original files that the TeamCity tool generated, then added new files using 7-zip. So it\u0027s 7-zip who\u0027s adding the (seemingly) malformed files, not TeamCity.\r\n\r\n\u003e _Furthermore, I had actually as a proof of concept created a very rudimentary manual tar extractor based on the GNU spec and it also got tripped up and failed at the long link part_\r\n\r\nDo you mean you tried reading the entries using the new `TarReader` API, or did you use some other tools? If you used `TarReader` and it failed, it was most likely because of the malformed `magic` and `version`. I should make it more flexible and avoid failing if the magic is not well formed, see if that helps with your case.\r\n\r\n\u003e _Given that I could not find any notable user discussions around problems with the artifact archives produced by TeamCity, I have to assume that it is very widely supported despite being malformed._\r\n\r\nI don\u0027t think the archive created with the TeamCity tool is generating malformed entries. I think it was 7-zip, since you did not preserve any of the original artifacts.\r\n\r\n\u003e - _opened the copy with the 7z GUI, removed a file and saved it_\r\n\u003e - _opened the copy with the 7z GUI a second time, re-added the file and saved it_\r\n\u003e - _compared all 512-byte tar headers between the original and the 7z modified copy: They all matched_\r\n\r\nThese 3 steps are confusing: Are you saying that some of the files in the .tar.gz file you shared are the original ones that were added by the TeamCity tool? If yes, which one was not removed?\r\n\r\nIf all the files were replaced using 7-zip, then 7-zip is making a bad job at detecting the format of existing entries, and adding entries in whatever format it wants.\r\n\r\nStill, if you\u0027re saying 7-zip and SharpCompress both support intermixed format entries in a single archive, then we should support them as well. So I\u0027ll start working on that.",
                                           "updatedAt":  "2022-05-20T02:34:42Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5DjAtg",
                                           "createdAt":  "2022-05-20T19:30:31Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Bio2hazard",
                                           "body":  "Sorry, you may be right. I\u0027ll try to clarify.\r\n\r\nI created a LINQPad Script ([gist](https://gist.github.com/Bio2hazard/fd40220f3b076c8fc15e0159a83444d4)) to read the headers of the files in the tar archive and compare the headers between 2 archives.\r\n\r\nI was trying to determine if 7z changes the tar headers when files are added through the 7z GUI, as you are suspecting.\r\n\r\nI extracted and untar\u0027d the original archive as produced by teamcity, then made a copy of it and through the 7z GUI deleted, and then re-added a single file (from the extracted original archive). In that test, the header did not show up as changed by 7z, but I\u0027m not convinced it was working right.\r\n\r\nI performed the experiment again today, this time removing and re-adding every file, and now the headers do show up differently, so 7z is modifying the tar headers.\r\n\r\nAt a glance, I can tell that some differences are that user / group are removed and that the file modes are different. \r\n\r\nSo for comparison, here is the Base64 of a tar header as created directly by **TeamCity**:\r\n`YXNzZXRzLzAtNjA4ZWNhOWJiMWRlMjE4ZjFiZTUucG5nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAxMDA2NDQgMDAzNTIzMCAwMDM1MjMwIDAwMDAwMTMzMzEwIDE0MjI1MDY1MzYwIDAyMDM0MwAgMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB1c3RhcgAwMHRlYW1jaXR5AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAdGVhbWNpdHkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwMDAwMDAwIDAwMDAwMDAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=`\r\n\r\nAnd the Base64 of the tar header for the same file as created by **7z**:\r\n`YXNzZXRzLzAtNjA4ZWNhOWJiMWRlMjE4ZjFiZTUucG5nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAxMDA3NzcAMDAwMDAwMAAwMDAwMDAwADAwMDAwMTMzMzEwADE0MjI1MDY1MzYwADAxMzIyMAAgMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB1c3RhcgAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=`\r\n\r\n-----\r\n\r\nHere is the Base64 of a **long link** tar header as created directly by **TeamCity**:\r\n`Li8uL0BMb25nTGluawAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAxMDA2NDQgMDAwMDAwMCAwMDAwMDAwIDAwMDAwMDAwMTY0IDE0MjI1MDY1MzYwIDAxMTYzNwAgTAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB1c3RhciAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwMDAwMDAwIDAwMDAwMDAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=`\r\n\r\nAnd the corresponding Base64 of a **long link** tar header as created by **7z**:\r\n`Li8uL0BMb25nTGluawAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAxMDA3NzcAMDAwMDAwMAAwMDAwMDAwADAwMDAwMDAwMTY0ADE0MjI1MDY1MzYwADAxMDEwNgAgTAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB1c3RhcgAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=`\r\n\r\n-----\r\n\r\nFinally, here is the Base64 of a **long file name** entry as created directly by **TeamCity**:\r\n`YXNzZXRzL2ZlYXR1cmVzLmNoYW5uZWwtaGVhZGVyLmNvbXBvbmVudHMuc29jaWFsLWJ1dHRvbnMuY29tcG9uZW50cy5mb2xsb3dlci1lbW90ZXMtcHJvbXB0LTRlNzZjZmYyNjAxMDA2NDQgMDAzNTIzMCAwMDM1MjMwIDAwMDAwMDEzMzQwIDE0MjI1MDY1MzYwIDAzNjMzMwAgMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB1c3RhcgAwMHRlYW1jaXR5AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAdGVhbWNpdHkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwMDAwMDAwIDAwMDAwMDAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=`\r\n\r\nAnd here is the corresponding Base64 of a **long file name** entry as created by **7z**:\r\n`YXNzZXRzL2ZlYXR1cmVzLmNoYW5uZWwtaGVhZGVyLmNvbXBvbmVudHMuc29jaWFsLWJ1dHRvbnMuY29tcG9uZW50cy5mb2xsb3dlci1lbW90ZXMtcHJvbXB0LTRlNzZjZmYyADAxMDA3NzcAMDAwMDAwMAAwMDAwMDAwADAwMDAwMDEzMzQwADE0MjI1MDY1MzYwADAzMTEyMgAgMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB1c3RhcgAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=`\r\n\r\nI think that should cover all cases as far as header differences goes.\r\n\r\nIt bears repeating that the original, completely unmodified, downloaded straight from teamcity `.tar.gz` archive failed to process with the new `TarReader` in the same manner as the test file I provided here. So even if the header of the teamcity entry is not malformed, it still failed in the same way.\r\n\r\nHope that helps and clears things up. I\u0027m an SDE, not DevOps so I didn\u0027t have the option of producing a sharable/sanitized archive directly in teamcity.",
                                           "updatedAt":  "2022-05-20T19:31:31Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5DjNqM",
                                           "createdAt":  "2022-05-20T20:07:55Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "carlossanlop",
                                           "body":  "Thanks for spending time helping with this, @Bio2Hazard. I appreciate it a lot.\r\n\r\n\u003e _I performed the experiment again today, this time removing and re-adding every file, and now the headers do show up differently, so 7z is modifying the tar headers._\r\n\r\nAh good to know, my suspicion was correct.\r\n\r\n\u003e _At a glance, I can tell that some differences are that user / group are removed and that the file modes are different._\r\n\r\nThis might be because you were doing this on a Windows machine. The concept of mode, uname and gname are from Unix. This is ok.\r\n\r\n\u003e _So even if the header of the teamcity entry is not malformed, it still failed in the same way._\r\n\r\nThis is interesting, and I think it\u0027s the only thing left for us to clarify, if that\u0027s ok. Do you mind sharing the exception message/callstack when using TarReader with the original TeamCity archive? I think the exception messages you shared in your previous comments came from the _modified_ file, which contained entries that were added by 7-zip, not TeamCity. Feel free to obfuscate any sensitive information if needed.\r\n\r\nActually, if you have time and the chance to help a bit more: if you can download [HxD Hex Editor](https://mh-nexus.de/en/downloads.php?product=HxD20) and open the `.tar` file generated with TeamCity (_not_ the `.tar.gz` file) you can see the raw bytes of the archive. The metadata is always located in the first 512 bytes of each entry. So for example, in the archive you shared that was modified with 7-zip, the `magic` and `version` fields of the first entry can be located in the blocks 257-264. If you scroll down, the `magic` and `version` fields of the LongLink entry are located in the blocks 9473-9480.\r\n\r\n**Can you share the magic and version fields of the LongLink entry in the TeamCity archive?** This would help us determine if it\u0027s malformed or not.\r\n\r\nHere\u0027s what I get from the first entry:\r\n\u003cimg src=\"https://user-images.githubusercontent.com/1175054/169602467-303ae310-1ea6-4fba-bd80-343744ef5b83.png\" width=\"500\" /\u003e\r\n\r\nHere are the `magic` and `version` of the LongLink that 7-zip modified, they are malformed - Notice that it the value is `ustar\\000`, which is the posix format, instead of `ustar  \\0`, which is the GNU format expected for a LongLink entry:\r\n\u003cimg src=\"https://user-images.githubusercontent.com/1175054/169602872-6778df3b-893b-40a6-9d5b-b69ec2d1d208.png\" width=\"500\" /\u003e\r\n\r\nAnd again, thank you so much for testing this and for your patience.\r\n\r\n",
                                           "updatedAt":  "2022-05-20T20:07:55Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5DjQIE",
                                           "createdAt":  "2022-05-20T20:13:10Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCd-iCQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "carlossanlop",
                                                                               "createdAt":  "2022-05-20T21:18:40Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "Bio2hazard",
                                           "body":  "@carlossanlop I\u0027ll get those stack traces for you\r\n\r\n\u003e Can you share the magic and version fields of the LongLink entry in the TeamCity archive?\r\n\r\nI wanted to quickly add that you should be able to just base64 decode the headers in my last message. They should have **exactly** what you are looking for. It\u0027s the first 512 bytes of the entries, from both teamcity and 7z.",
                                           "updatedAt":  "2022-05-20T20:13:10Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5DjiB3",
                                           "createdAt":  "2022-05-20T21:19:32Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCeAb3Q==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "LAUGH",
                                                                               "user":  "GSPP",
                                                                               "createdAt":  "2022-05-21T13:55:56Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "carlossanlop",
                                           "body":  "\u003e I wanted to quickly add that you should be able to just base64 decode the headers in my last message.\r\n\r\nOh cool, never done that. Allow me to figure it out then, and will come back to you if I don\u0027t find the info I wanted.\r\n\r\nEDIT: this is AWESOME! https://www.base64decode.org/",
                                           "updatedAt":  "2022-05-20T21:20:36Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5DjqVD",
                                           "createdAt":  "2022-05-20T22:04:57Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCd_DIw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "carlossanlop",
                                                                               "createdAt":  "2022-05-20T23:15:30Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "Bio2hazard",
                                           "body":  "@carlossanlop nice looks like it worked out! Base64 is just a quick and convenient way to share byte[]s through a text format. You can use `Convert.FromBase64String(\"\u003cbase 64 header from before\u003e\")` to get the raw byte[] in C# if that helps.\r\n\r\nI got the stack traces for you:\r\n\r\n### WithSystemsFormatTar_PreDecompressed()\r\nIn this variant, the `.tar.gz` is first decompressed via `GZipStream` into a seekable `MemoryStream`, which is passed into `TarReader`\r\n\r\n**TeamCity Archive**:\r\n```\r\nSystem.FormatException: Entry \u0027assets/features.channel-header.components.social-buttons.components.follower-emotes-prompt-4e76cff26\u0027 was expected to be in the GNU format, but did not have the expected version data.\r\n   at System.Formats.Tar.TarHeader.ReadVersionAttribute(Span`1 buffer)\r\n   at System.Formats.Tar.TarHeader.TryGetNextHeader(Stream archiveStream, Boolean copyData)\r\n   at System.Formats.Tar.TarReader.TryProcessGnuMetadataHeader(TarHeader header, Boolean copyData, TarHeader\u0026 finalHeader)\r\n   at System.Formats.Tar.TarReader.TryGetNextEntryHeader(TarHeader\u0026 header, Boolean copyData)\r\n   at System.Formats.Tar.TarReader.GetNextEntry(Boolean copyData)\r\n   at Program.\u003c\u003cMain\u003e$\u003eg__WithSystemsFormatTar_PreDecompressed|0_0(\u003c\u003ec__DisplayClass0_0\u0026) in C:\\Development\\Experimentation\\net7testing\\Program.cs:line 27\r\n   at Program.\u003cMain\u003e$(String[] args) in C:\\Development\\Experimentation\\net7testing\\Program.cs:line 8\r\n```\r\n\r\n**Test Archive**:\r\n```\r\nSystem.FormatException: Entry \u0027testing-a-verylong.filename-that-cant-fit-in-a-single.tar-header-and-will-probably-fail-to-load-cor\u0027 was expected to be in the GNU format, but did not have the expected version data.\r\n   at System.Formats.Tar.TarHeader.ReadVersionAttribute(Span`1 buffer)\r\n   at System.Formats.Tar.TarHeader.TryGetNextHeader(Stream archiveStream, Boolean copyData)\r\n   at System.Formats.Tar.TarReader.TryProcessGnuMetadataHeader(TarHeader header, Boolean copyData, TarHeader\u0026 finalHeader)\r\n   at System.Formats.Tar.TarReader.TryGetNextEntryHeader(TarHeader\u0026 header, Boolean copyData)\r\n   at System.Formats.Tar.TarReader.GetNextEntry(Boolean copyData)\r\n   at Program.\u003c\u003cMain\u003e$\u003eg__WithSystemsFormatTar_PreDecompressed|0_0(\u003c\u003ec__DisplayClass0_0\u0026) in C:\\Development\\Experimentation\\net7testing\\Program.cs:line 27\r\n   at Program.\u003cMain\u003e$(String[] args) in C:\\Development\\Experimentation\\net7testing\\Program.cs:line 8\r\n```\r\n\r\nStack Traces are identical\r\n\r\n----\r\n\r\n### WithSystemsFormatTar_StreamedDecompression()\r\nIn this variant, the `TarReader` reads directly from the nonseekable `GZipStream`.\r\nNo exception gets thrown here, but only a single entry is returned. The stack trace represents the part where it failed when processing the second file.\r\n\r\n**TeamCity Archive**:\r\n```\r\nTarHelpers.IsAllNullBytes()at TarHelpers.cs:line 106\r\nTarHeader.TryReadCommonAttributes()at TarHeader.Read.cs:line 309\r\nTarHeader.TryGetNextHeader()\r\nTarReader.TryGetNextEntryHeader()\r\nTarReader.GetNextEntry()\r\nProgram.\u003c\u003cMain\u003e$\u003eg__WithSystemsFormatTar_StreamedDecompression|0_1()\r\nProgram.\u003cMain\u003e$()\r\n```\r\n\r\n**Test Archive**:\r\n```\r\nTarHelpers.IsAllNullBytes()at TarHelpers.cs:line 106\r\nTarHeader.TryReadCommonAttributes()at TarHeader.Read.cs:line 309\r\nTarHeader.TryGetNextHeader()\r\nTarReader.TryGetNextEntryHeader()\r\nTarReader.GetNextEntry()\r\nProgram.\u003c\u003cMain\u003e$\u003eg__WithSystemsFormatTar_StreamedDecompression|0_1()\r\nProgram.\u003cMain\u003e$()\r\n```\r\n\r\nThe stack traces are again identical. This is the relevant failure point in `TryReadCommonAttributes`\r\n```csharp\r\n// Empty checksum means this is an invalid (all blank) entry, finish early\r\nSpan\u003cbyte\u003e spanChecksum = buffer.Slice(FieldLocations.Checksum, FieldLengths.Checksum);\r\nif (TarHelpers.IsAllNullBytes(spanChecksum))\r\n{\r\n    return false;\r\n}\r\n```\r\n\r\nThe debugger showed all bytes of the checksum being null, which bubbles up and causes `GetNextEntry` to return false.\r\n\r\n----\r\n\r\n### WithSystemsFormatTar_StreamedDecompression_WithCopyData()\r\nIn this variant, the `TarReader` reads directly from the nonseekable `GZipStream` just like the previous one. The only difference is that this uses `tarReader.GetNextEntry(true)` when reading entries.\r\n\r\n**TeamCity Archive**:\r\n```\r\nSystem.IO.EndOfStreamException: Attempted to read past the end of the stream.\r\n   at System.Formats.Tar.TarHelpers.CopyBytes(Stream origin, Stream destination, Int64 bytesToCopy)\r\n   at System.Formats.Tar.TarHeader.GetDataStream(Stream archiveStream, Boolean copyData)\r\n   at System.Formats.Tar.TarHeader.ProcessDataBlock(Stream archiveStream, Boolean copyData)\r\n   at System.Formats.Tar.TarHeader.TryGetNextHeader(Stream archiveStream, Boolean copyData)\r\n   at System.Formats.Tar.TarReader.TryGetNextEntryHeader(TarHeader\u0026 header, Boolean copyData)\r\n   at System.Formats.Tar.TarReader.GetNextEntry(Boolean copyData)\r\n   at Program.\u003c\u003cMain\u003e$\u003eg__WithSystemsFormatTar_StreamedDecompression_WithCopyData|0_2(\u003c\u003ec__DisplayClass0_0\u0026) in C:\\Development\\Experimentation\\net7testing\\Program.cs:line 81\r\n   at Program.\u003cMain\u003e$(String[] args) in C:\\Development\\Experimentation\\net7testing\\Program.cs:line 8\r\n```\r\n\r\n**Test Archive**:\r\n```\r\nSystem.FormatException: Entry \u0027testing-a-verylong.filename-that-cant-fit-in-a-single.tar-header-and-will-probably-fail-to-load-cor\u0027 was expected to be in the GNU format, but did not have the expected version data.\r\n   at System.Formats.Tar.TarHeader.ReadVersionAttribute(Span`1 buffer)\r\n   at System.Formats.Tar.TarHeader.TryGetNextHeader(Stream archiveStream, Boolean copyData)\r\n   at System.Formats.Tar.TarReader.TryProcessGnuMetadataHeader(TarHeader header, Boolean copyData, TarHeader\u0026 finalHeader)\r\n   at System.Formats.Tar.TarReader.TryGetNextEntryHeader(TarHeader\u0026 header, Boolean copyData)\r\n   at System.Formats.Tar.TarReader.GetNextEntry(Boolean copyData)\r\n   at Program.\u003c\u003cMain\u003e$\u003eg__WithSystemsFormatTar_StreamedDecompression_WithCopyData|0_2(\u003c\u003ec__DisplayClass0_0\u0026) in C:\\Development\\Experimentation\\net7testing\\Program.cs:line 81\r\n   at Program.\u003cMain\u003e$(String[] args) in C:\\Development\\Experimentation\\net7testing\\Program.cs:line 8\r\n```\r\n\r\nThis is the only test case where the result was different between the two. I hope that helps!",
                                           "updatedAt":  "2022-05-20T22:04:57Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6cMBQU",
                                           "createdAt":  "2025-01-29T01:30:48Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "carlossanlop",
                                           "body":  "This is resolved.",
                                           "updatedAt":  "2025-01-29T01:30:48Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6sxFB2",
                                           "createdAt":  "2025-05-21T16:23:09Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ericstj",
                                           "body":  "Reopening this as we have TODO\u0027s in the TarReader pointing to this issue.  @tmds [mentioned](https://github.com/dotnet/runtime/pull/115778#discussion_r2099536788):\n\u003e This is about the fields in the following header which are not read/round-tripped:\n```\nstruct oldgnu_header\n{                              /* byte offset */\n  char unused_pad1[345];        /*   0 */\n  char atime[12];               /* 345 Incr. archive: atime of the file */\n  char ctime[12];               /* 357 Incr. archive: ctime of the file */\n  char offset[12];              /* 369 Multivolume archive: the offset of\n                                   the start of this volume */\n  char longnames[4];            /* 381 Not used */\n  char unused_pad2;             /* 385 */\n  struct sparse sp[SPARSES_IN_OLDGNU_HEADER];\n                                /* 386 */\n  char isextended;              /* 482 Sparse file: Extension sparse header\n                                   follows */\n  char realsize[12];            /* 483 Sparse file: Real size*/\n                                /* 495 */\n};\n```",
                                           "updatedAt":  "2025-05-21T16:23:09Z"
                                       }
                                   ],
                         "totalCount":  16
                     },
        "title":  "Tar APIs pending feedback to address",
        "labels":  [
                       "area-System.Formats.Tar"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/68360",
        "createdAt":  "2022-04-22T00:48:52Z",
        "number":  68360,
        "author":  "akoeplinger",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-07-31T19:02:31Z",
        "body":  "Newly added test from https://github.com/dotnet/runtime/pull/67883 fails on runtime-extra-platfroms.\r\nI haven\u0027t investigated whether it is expected, just filing this so I can disable the test with ActiveIssue.\r\n\r\nAndroid fails with \r\n```\r\nSystem.UnauthorizedAccessException : Access to the path \u0027/data/user/0/net.dot.System.Formats.Tar.Tests/cache/qtsmyi3v.nmj/link\u0027 is denied.\r\n---- System.IO.IOException : Permission denied\r\n\r\n\r\nStack trace\r\n   at Interop.ThrowExceptionForIoErrno(ErrorInfo errorInfo, String path, Boolean isDirectory, Func`2 errorRewriter)\r\n   at Interop.CheckIo(Int64 result, String path, Boolean isDirectory, Func`2 errorRewriter)\r\n   at Interop.CheckIo(Int32 result, String path, Boolean isDirectory, Func`2 errorRewriter)\r\n   at System.Formats.Tar.TarEntry.ExtractAsHardLink(String targetFilePath, String hardLinkFilePath)\r\n   at System.Formats.Tar.TarEntry.ExtractToFileInternal(String filePath, String linkTargetPath, Boolean overwrite)\r\n   at System.Formats.Tar.TarEntry.ExtractRelativeToDirectory(String destinationDirectoryPath, Boolean overwrite)\r\n   at System.Formats.Tar.TarFile.ExtractToDirectoryInternal(Stream source, String destinationDirectoryPath, Boolean overwriteFiles, Boolean leaveOpen)\r\n   at System.Formats.Tar.TarFile.ExtractToDirectory(Stream source, String destinationDirectoryName, Boolean overwriteFiles)\r\n   at System.Formats.Tar.Tests.TarFile_ExtractToDirectory_Stream_Tests.Extract_LinkEntry_TargetInsideDirectory_Internal(TarEntryType entryType) in /_/src/libraries/System.Formats.Tar/tests/TarFile/TarFile.ExtractToDirectory.Stream.Tests.cs:line 123\r\n   at System.Formats.Tar.Tests.TarFile_ExtractToDirectory_Stream_Tests.Extract_HardLinkEntry_TargetInsideDirectory() in /_/src/libraries/System.Formats.Tar/tests/TarFile/TarFile.ExtractToDirectory.Stream.Tests.cs:line 101\r\n   at System.Reflection.RuntimeMethodInfo.InvokeNonEmitUnsafe(Object obj, IntPtr* byrefParameters, Span`1 argsForTemporaryMonoSupport, BindingFlags invokeAttr)\r\n----- Inner Stack Trace -----\r\n```\r\n\r\niOS/tvOS Simulators fail with\r\n\r\n```\r\nSystem.IO.IOException : Extracting the Tar entry \u0027/Users/helix-runner/Library/Developer/CoreSimulator/Devices/11416593-2690-443B-964F-E9F6694BA19A/dat\u0027 would have resulted in a link target outside the specified destination directory: \u0027/Users/helix-runner/Library/Developer/CoreSimulator/Devices/11416593-2690-443B-964F-E9F6694BA19A/data/Containers/Data/Application/1BD07C3B-0285-4EAB-943A-2BBFDD9E63A5/tmp/f2gsvib5.4m4/\u0027\r\n\r\n\r\nStack trace\r\n   at System.Formats.Tar.TarEntry.\u003cExtractRelativeToDirectory\u003eg__GetSanitizedFullPath|34_0(String destinationDirectoryFullPath, String path, String exceptionMessage)\r\n   at System.Formats.Tar.TarEntry.ExtractRelativeToDirectory(String destinationDirectoryPath, Boolean overwrite)\r\n   at System.Formats.Tar.TarFile.ExtractToDirectoryInternal(Stream source, String destinationDirectoryPath, Boolean overwriteFiles, Boolean leaveOpen)\r\n   at System.Formats.Tar.TarFile.ExtractToDirectory(Stream source, String destinationDirectoryName, Boolean overwriteFiles)\r\n   at System.Formats.Tar.Tests.TarFile_ExtractToDirectory_Stream_Tests.Extract_LinkEntry_TargetInsideDirectory_Internal(TarEntryType entryType)\r\n   at System.Formats.Tar.Tests.TarFile_ExtractToDirectory_Stream_Tests.Extract_HardLinkEntry_TargetInsideDirectory()\r\n   at System.Reflection.RuntimeMethodInfo.InvokeNonEmitUnsafe(Object obj, IntPtr* byrefParameters, Span`1 argsForTemporaryMonoSupport, BindingFlags invokeAttr)\r\n```\r\n\r\nFYI @carlossanlop ",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHORxgLnw==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5B6pfJ",
                                           "createdAt":  "2022-04-22T00:48:56Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-io\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nNewly added test from https://github.com/dotnet/runtime/pull/67883 fails on runtime-extra-platfroms.\r\nI haven\u0027t investigated whether it is expected, just filing this so I can disable the test with ActiveIssue.\r\n\r\nAndroid fails with \r\n```\r\nSystem.UnauthorizedAccessException : Access to the path \u0027/data/user/0/net.dot.System.Formats.Tar.Tests/cache/qtsmyi3v.nmj/link\u0027 is denied.\r\n---- System.IO.IOException : Permission denied\r\n\r\n\r\nStack trace\r\n   at Interop.ThrowExceptionForIoErrno(ErrorInfo errorInfo, String path, Boolean isDirectory, Func`2 errorRewriter)\r\n   at Interop.CheckIo(Int64 result, String path, Boolean isDirectory, Func`2 errorRewriter)\r\n   at Interop.CheckIo(Int32 result, String path, Boolean isDirectory, Func`2 errorRewriter)\r\n   at System.Formats.Tar.TarEntry.ExtractAsHardLink(String targetFilePath, String hardLinkFilePath)\r\n   at System.Formats.Tar.TarEntry.ExtractToFileInternal(String filePath, String linkTargetPath, Boolean overwrite)\r\n   at System.Formats.Tar.TarEntry.ExtractRelativeToDirectory(String destinationDirectoryPath, Boolean overwrite)\r\n   at System.Formats.Tar.TarFile.ExtractToDirectoryInternal(Stream source, String destinationDirectoryPath, Boolean overwriteFiles, Boolean leaveOpen)\r\n   at System.Formats.Tar.TarFile.ExtractToDirectory(Stream source, String destinationDirectoryName, Boolean overwriteFiles)\r\n   at System.Formats.Tar.Tests.TarFile_ExtractToDirectory_Stream_Tests.Extract_LinkEntry_TargetInsideDirectory_Internal(TarEntryType entryType) in /_/src/libraries/System.Formats.Tar/tests/TarFile/TarFile.ExtractToDirectory.Stream.Tests.cs:line 123\r\n   at System.Formats.Tar.Tests.TarFile_ExtractToDirectory_Stream_Tests.Extract_HardLinkEntry_TargetInsideDirectory() in /_/src/libraries/System.Formats.Tar/tests/TarFile/TarFile.ExtractToDirectory.Stream.Tests.cs:line 101\r\n   at System.Reflection.RuntimeMethodInfo.InvokeNonEmitUnsafe(Object obj, IntPtr* byrefParameters, Span`1 argsForTemporaryMonoSupport, BindingFlags invokeAttr)\r\n----- Inner Stack Trace -----\r\n```\r\n\r\niOS/tvOS Simulators fail with\r\n\r\n```\r\nSystem.IO.IOException : Extracting the Tar entry \u0027/Users/helix-runner/Library/Developer/CoreSimulator/Devices/11416593-2690-443B-964F-E9F6694BA19A/dat\u0027 would have resulted in a link target outside the specified destination directory: \u0027/Users/helix-runner/Library/Developer/CoreSimulator/Devices/11416593-2690-443B-964F-E9F6694BA19A/data/Containers/Data/Application/1BD07C3B-0285-4EAB-943A-2BBFDD9E63A5/tmp/f2gsvib5.4m4/\u0027\r\n\r\n\r\nStack trace\r\n   at System.Formats.Tar.TarEntry.\u003cExtractRelativeToDirectory\u003eg__GetSanitizedFullPath|34_0(String destinationDirectoryFullPath, String path, String exceptionMessage)\r\n   at System.Formats.Tar.TarEntry.ExtractRelativeToDirectory(String destinationDirectoryPath, Boolean overwrite)\r\n   at System.Formats.Tar.TarFile.ExtractToDirectoryInternal(Stream source, String destinationDirectoryPath, Boolean overwriteFiles, Boolean leaveOpen)\r\n   at System.Formats.Tar.TarFile.ExtractToDirectory(Stream source, String destinationDirectoryName, Boolean overwriteFiles)\r\n   at System.Formats.Tar.Tests.TarFile_ExtractToDirectory_Stream_Tests.Extract_LinkEntry_TargetInsideDirectory_Internal(TarEntryType entryType)\r\n   at System.Formats.Tar.Tests.TarFile_ExtractToDirectory_Stream_Tests.Extract_HardLinkEntry_TargetInsideDirectory()\r\n   at System.Reflection.RuntimeMethodInfo.InvokeNonEmitUnsafe(Object obj, IntPtr* byrefParameters, Span`1 argsForTemporaryMonoSupport, BindingFlags invokeAttr)\r\n```\r\n\r\nFYI @carlossanlop \n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eakoeplinger\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.IO`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-04-22T00:48:56Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5B6qZl",
                                           "createdAt":  "2022-04-22T00:54:46Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "Same root cause as what\u0027s being fixed in https://github.com/dotnet/runtime/pull/68361?",
                                           "updatedAt":  "2022-04-22T00:55:10Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5B6qxn",
                                           "createdAt":  "2022-04-22T00:57:07Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "akoeplinger",
                                           "body":  "I don\u0027t think it\u0027s the same issue.",
                                           "updatedAt":  "2022-04-22T00:57:07Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5B65Fg",
                                           "createdAt":  "2022-04-22T03:08:20Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-io-compression\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nNewly added test from https://github.com/dotnet/runtime/pull/67883 fails on runtime-extra-platfroms.\r\nI haven\u0027t investigated whether it is expected, just filing this so I can disable the test with ActiveIssue.\r\n\r\nAndroid fails with \r\n```\r\nSystem.UnauthorizedAccessException : Access to the path \u0027/data/user/0/net.dot.System.Formats.Tar.Tests/cache/qtsmyi3v.nmj/link\u0027 is denied.\r\n---- System.IO.IOException : Permission denied\r\n\r\n\r\nStack trace\r\n   at Interop.ThrowExceptionForIoErrno(ErrorInfo errorInfo, String path, Boolean isDirectory, Func`2 errorRewriter)\r\n   at Interop.CheckIo(Int64 result, String path, Boolean isDirectory, Func`2 errorRewriter)\r\n   at Interop.CheckIo(Int32 result, String path, Boolean isDirectory, Func`2 errorRewriter)\r\n   at System.Formats.Tar.TarEntry.ExtractAsHardLink(String targetFilePath, String hardLinkFilePath)\r\n   at System.Formats.Tar.TarEntry.ExtractToFileInternal(String filePath, String linkTargetPath, Boolean overwrite)\r\n   at System.Formats.Tar.TarEntry.ExtractRelativeToDirectory(String destinationDirectoryPath, Boolean overwrite)\r\n   at System.Formats.Tar.TarFile.ExtractToDirectoryInternal(Stream source, String destinationDirectoryPath, Boolean overwriteFiles, Boolean leaveOpen)\r\n   at System.Formats.Tar.TarFile.ExtractToDirectory(Stream source, String destinationDirectoryName, Boolean overwriteFiles)\r\n   at System.Formats.Tar.Tests.TarFile_ExtractToDirectory_Stream_Tests.Extract_LinkEntry_TargetInsideDirectory_Internal(TarEntryType entryType) in /_/src/libraries/System.Formats.Tar/tests/TarFile/TarFile.ExtractToDirectory.Stream.Tests.cs:line 123\r\n   at System.Formats.Tar.Tests.TarFile_ExtractToDirectory_Stream_Tests.Extract_HardLinkEntry_TargetInsideDirectory() in /_/src/libraries/System.Formats.Tar/tests/TarFile/TarFile.ExtractToDirectory.Stream.Tests.cs:line 101\r\n   at System.Reflection.RuntimeMethodInfo.InvokeNonEmitUnsafe(Object obj, IntPtr* byrefParameters, Span`1 argsForTemporaryMonoSupport, BindingFlags invokeAttr)\r\n----- Inner Stack Trace -----\r\n```\r\n\r\niOS/tvOS Simulators fail with\r\n\r\n```\r\nSystem.IO.IOException : Extracting the Tar entry \u0027/Users/helix-runner/Library/Developer/CoreSimulator/Devices/11416593-2690-443B-964F-E9F6694BA19A/dat\u0027 would have resulted in a link target outside the specified destination directory: \u0027/Users/helix-runner/Library/Developer/CoreSimulator/Devices/11416593-2690-443B-964F-E9F6694BA19A/data/Containers/Data/Application/1BD07C3B-0285-4EAB-943A-2BBFDD9E63A5/tmp/f2gsvib5.4m4/\u0027\r\n\r\n\r\nStack trace\r\n   at System.Formats.Tar.TarEntry.\u003cExtractRelativeToDirectory\u003eg__GetSanitizedFullPath|34_0(String destinationDirectoryFullPath, String path, String exceptionMessage)\r\n   at System.Formats.Tar.TarEntry.ExtractRelativeToDirectory(String destinationDirectoryPath, Boolean overwrite)\r\n   at System.Formats.Tar.TarFile.ExtractToDirectoryInternal(Stream source, String destinationDirectoryPath, Boolean overwriteFiles, Boolean leaveOpen)\r\n   at System.Formats.Tar.TarFile.ExtractToDirectory(Stream source, String destinationDirectoryName, Boolean overwriteFiles)\r\n   at System.Formats.Tar.Tests.TarFile_ExtractToDirectory_Stream_Tests.Extract_LinkEntry_TargetInsideDirectory_Internal(TarEntryType entryType)\r\n   at System.Formats.Tar.Tests.TarFile_ExtractToDirectory_Stream_Tests.Extract_HardLinkEntry_TargetInsideDirectory()\r\n   at System.Reflection.RuntimeMethodInfo.InvokeNonEmitUnsafe(Object obj, IntPtr* byrefParameters, Span`1 argsForTemporaryMonoSupport, BindingFlags invokeAttr)\r\n```\r\n\r\nFYI @carlossanlop \n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eakoeplinger\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.IO.Compression`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-04-22T03:08:20Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5B65GU",
                                           "createdAt":  "2022-04-22T03:08:26Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "danmoseley",
                                           "body":  "@carlossanlop ",
                                           "updatedAt":  "2022-04-22T03:08:26Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5CsLZx",
                                           "createdAt":  "2022-05-05T17:48:07Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "carlossanlop",
                                           "body":  "I think the user we use to execute tests in Android/iOS/tvOS does not have permission to create symbolic links in those operating systems. I will have to use elevation in those OS.",
                                           "updatedAt":  "2022-05-05T17:48:07Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5FGF0t",
                                           "createdAt":  "2022-06-17T21:02:38Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "carlossanlop",
                                           "body":  "Test failure has been fixed, and the test method has been reenabled.",
                                           "updatedAt":  "2022-06-17T21:02:38Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5FHurg",
                                           "createdAt":  "2022-06-19T08:28:49Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "karelz",
                                           "body":  "The test is failing again -- @carlossanlop can you please disable it again and take a look?\r\n\r\nFailures since 6/17 - [query in runfo](https://runfo.azurewebsites.net/search/tests/?q=started%3A2022-06-17+definition%3Aruntime-extra-platforms+name%3A%22system.formats.tar.tests.tarfile_extracttodirectory_stream_tests.extract_hardlinkentry_targetinsidedirectory%22)\r\n- 6/19: 43 failures\r\n\r\nRolling builds:\r\n- [1833406](https://runfo.azurewebsites.net/view/build/?number=1833406) (6/19 PM) - 3 failures (same 3 platforms)\r\n- [1833058](https://runfo.azurewebsites.net/view/build/?number=1833058) (6/19 AM) - 3 failures (same 3 platforms)\r\n- [1832621](https://runfo.azurewebsites.net/view/build/?number=1832621) (6/18 PM) - 3 failures:\r\n    - net7.0-tvOS-Release-arm64-Mono_Release-OSX.1015.Amd64.AppleTV.Open\r\n    - net7.0-tvOSSimulator-Release-x64-Mono_Release-OSX.1015.Amd64.Open\r\n    - net7.0-iOSSimulator-Release-x64-Mono_Release-OSX.1015.Amd64.Open\r\n- [1832161](https://runfo.azurewebsites.net/view/build/?number=1832161) (6/18 AM) - 3 failures:\r\n   - net7.0-iOSSimulator-Release-x64-Mono_Release-OSX.1015.Amd64.Open\r\n   - net7.0-tvOSSimulator-Release-x64-Mono_Release-OSX.1015.Amd64.Open\r\n   - net7.0-tvOS-Release-arm64-Mono_Release-OSX.1015.Amd64.AppleTV.Open\r\n\r\nTest output example:\r\n```\r\nSystem.IO.IOException : Extracting the Tar entry \u0027/Users/helix-runner/Library/Developer/CoreSimulator/Devices/B689B860-E125-4467-80B3-E8073029AB31/dat\u0027 would have resulted in a link target outside the specified destination directory: \u0027/Users/helix-runner/Library/Developer/CoreSimulator/Devices/B689B860-E125-4467-80B3-E8073029AB31/data/Containers/Data/Application/34807FE3-9761-4A8D-95A4-38EDB198D1E0/tmp/5jyza0jc.ucf\u0027\r\n\r\n   at System.Formats.Tar.TarEntry.ExtractRelativeToDirectory(String destinationDirectoryPath, Boolean overwrite)\r\n   at System.Formats.Tar.TarFile.ExtractToDirectoryInternal(Stream source, String destinationDirectoryPath, Boolean overwriteFiles, Boolean leaveOpen)\r\n   at System.Formats.Tar.TarFile.ExtractToDirectory(Stream source, String destinationDirectoryName, Boolean overwriteFiles)\r\n   at System.Formats.Tar.Tests.TarFile_ExtractToDirectory_Stream_Tests.Extract_LinkEntry_TargetInsideDirectory_Internal(TarEntryType entryType)\r\n   at System.Formats.Tar.Tests.TarFile_ExtractToDirectory_Stream_Tests.Extract_HardLinkEntry_TargetInsideDirectory()\r\n   at System.Reflection.MethodInvoker.InterpretedInvoke(Object obj, Span`1 args, BindingFlags invokeAttr)\r\n```",
                                           "updatedAt":  "2022-06-20T08:35:58Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5FHu3-",
                                           "createdAt":  "2022-06-19T08:33:23Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "karelz",
                                           "body":  "Also, test System.Formats.Tar.Tests.TarReader_ExtractToFile_Tests.**ExtractToFile_SpecialFile_Unelevated_Throws** fails as well with similar error to the 1st one report in the top post:\r\n\r\n```\r\nSystem.UnauthorizedAccessException : Access to the path \u0027/private/var/mobile/Containers/Data/Application/607B5A9D-8D94-42C4-8CCD-54BCE7B1B2E9/tmp/j2osgcp1.kpt/output\u0027 is denied.\r\n---- System.IO.IOException : Operation not permitted\r\n\r\n  at Interop.ThrowExceptionForIoErrno(ErrorInfo errorInfo, String path, Boolean isDirectory, Func`2 errorRewriter)\r\n   at System.Formats.Tar.TarEntry.ExtractAsFifo(String destinationFileName)\r\n   at System.Formats.Tar.TarEntry.ExtractToFileInternal(String filePath, String linkTargetPath, Boolean overwrite)\r\n   at System.Formats.Tar.TarEntry.ExtractToFile(String destinationFileName, Boolean overwrite)\r\n   at System.Formats.Tar.Tests.TarReader_ExtractToFile_Tests.ExtractToFile_SpecialFile_Unelevated_Throws()\r\n   at System.Reflection.MethodInvoker.InterpretedInvoke(Object obj, Span`1 args, BindingFlags invokeAttr)\r\n```\r\n\r\nFailures since 6/17 - [query in runfo](https://runfo.azurewebsites.net/search/tests/?q=started%3A2022-06-17+definition%3Aruntime-extra-platforms+name%3A%22system.formats.tar.tests.tarreader_extracttofile_tests.extracttofile_specialfile_unelevated_throws%22)\r\n- 6/19: 5 failures\r\n\r\nRolling builds:\r\n- [1833406](https://runfo.azurewebsites.net/view/build/?number=1833406) (6/19 PM) - same platform\r\n- [1833058](https://runfo.azurewebsites.net/view/build/?number=1833058) (6/19 AM) - same platform\r\n- [1832621](https://runfo.azurewebsites.net/view/build/?number=1832621) (6/18 PM)\r\n    - net7.0-tvOS-Release-arm64-Mono_Release-OSX.1015.Amd64.AppleTV.Open\r\n- [1832161](https://runfo.azurewebsites.net/view/build/?number=1832161) (6/18 AM)\r\n    - net7.0-tvOS-Release-arm64-Mono_Release-OSX.1015.Amd64.AppleTV.Open\r\n",
                                           "updatedAt":  "2022-06-20T08:36:27Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5FHve-",
                                           "createdAt":  "2022-06-19T08:43:58Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to \u0027os-ios\u0027: @steveisok, @akoeplinger\nSee info in area-owners.md if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nNewly added test from https://github.com/dotnet/runtime/pull/67883 fails on runtime-extra-platfroms.\r\nI haven\u0027t investigated whether it is expected, just filing this so I can disable the test with ActiveIssue.\r\n\r\nAndroid fails with \r\n```\r\nSystem.UnauthorizedAccessException : Access to the path \u0027/data/user/0/net.dot.System.Formats.Tar.Tests/cache/qtsmyi3v.nmj/link\u0027 is denied.\r\n---- System.IO.IOException : Permission denied\r\n\r\n\r\nStack trace\r\n   at Interop.ThrowExceptionForIoErrno(ErrorInfo errorInfo, String path, Boolean isDirectory, Func`2 errorRewriter)\r\n   at Interop.CheckIo(Int64 result, String path, Boolean isDirectory, Func`2 errorRewriter)\r\n   at Interop.CheckIo(Int32 result, String path, Boolean isDirectory, Func`2 errorRewriter)\r\n   at System.Formats.Tar.TarEntry.ExtractAsHardLink(String targetFilePath, String hardLinkFilePath)\r\n   at System.Formats.Tar.TarEntry.ExtractToFileInternal(String filePath, String linkTargetPath, Boolean overwrite)\r\n   at System.Formats.Tar.TarEntry.ExtractRelativeToDirectory(String destinationDirectoryPath, Boolean overwrite)\r\n   at System.Formats.Tar.TarFile.ExtractToDirectoryInternal(Stream source, String destinationDirectoryPath, Boolean overwriteFiles, Boolean leaveOpen)\r\n   at System.Formats.Tar.TarFile.ExtractToDirectory(Stream source, String destinationDirectoryName, Boolean overwriteFiles)\r\n   at System.Formats.Tar.Tests.TarFile_ExtractToDirectory_Stream_Tests.Extract_LinkEntry_TargetInsideDirectory_Internal(TarEntryType entryType) in /_/src/libraries/System.Formats.Tar/tests/TarFile/TarFile.ExtractToDirectory.Stream.Tests.cs:line 123\r\n   at System.Formats.Tar.Tests.TarFile_ExtractToDirectory_Stream_Tests.Extract_HardLinkEntry_TargetInsideDirectory() in /_/src/libraries/System.Formats.Tar/tests/TarFile/TarFile.ExtractToDirectory.Stream.Tests.cs:line 101\r\n   at System.Reflection.RuntimeMethodInfo.InvokeNonEmitUnsafe(Object obj, IntPtr* byrefParameters, Span`1 argsForTemporaryMonoSupport, BindingFlags invokeAttr)\r\n----- Inner Stack Trace -----\r\n```\r\n\r\niOS/tvOS Simulators fail with\r\n\r\n```\r\nSystem.IO.IOException : Extracting the Tar entry \u0027/Users/helix-runner/Library/Developer/CoreSimulator/Devices/11416593-2690-443B-964F-E9F6694BA19A/dat\u0027 would have resulted in a link target outside the specified destination directory: \u0027/Users/helix-runner/Library/Developer/CoreSimulator/Devices/11416593-2690-443B-964F-E9F6694BA19A/data/Containers/Data/Application/1BD07C3B-0285-4EAB-943A-2BBFDD9E63A5/tmp/f2gsvib5.4m4/\u0027\r\n\r\n\r\nStack trace\r\n   at System.Formats.Tar.TarEntry.\u003cExtractRelativeToDirectory\u003eg__GetSanitizedFullPath|34_0(String destinationDirectoryFullPath, String path, String exceptionMessage)\r\n   at System.Formats.Tar.TarEntry.ExtractRelativeToDirectory(String destinationDirectoryPath, Boolean overwrite)\r\n   at System.Formats.Tar.TarFile.ExtractToDirectoryInternal(Stream source, String destinationDirectoryPath, Boolean overwriteFiles, Boolean leaveOpen)\r\n   at System.Formats.Tar.TarFile.ExtractToDirectory(Stream source, String destinationDirectoryName, Boolean overwriteFiles)\r\n   at System.Formats.Tar.Tests.TarFile_ExtractToDirectory_Stream_Tests.Extract_LinkEntry_TargetInsideDirectory_Internal(TarEntryType entryType)\r\n   at System.Formats.Tar.Tests.TarFile_ExtractToDirectory_Stream_Tests.Extract_HardLinkEntry_TargetInsideDirectory()\r\n   at System.Reflection.RuntimeMethodInfo.InvokeNonEmitUnsafe(Object obj, IntPtr* byrefParameters, Span`1 argsForTemporaryMonoSupport, BindingFlags invokeAttr)\r\n```\r\n\r\nFYI @carlossanlop \n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eakoeplinger\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003ecarlossanlop\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.IO.Compression`, `os-ios`, `os-tvos`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e7.0.0\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-06-19T08:43:58Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Fdnpt",
                                           "createdAt":  "2022-06-24T09:34:42Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "karelz",
                                           "body":  "@carlossanlop the main issue with test Extract_HardLinkEntry_TargetInsideDirectory was addressed. Thanks!\r\n\r\nHowever, the second similar issue with test **ExtractToFile_SpecialFile_Unelevated_Throws** is still happening -- see above https://github.com/dotnet/runtime/issues/68360#issuecomment-1159654910\r\n\r\nReopening to keep tracking it. Feel free to split it into another issue if it is more convenient for you.",
                                           "updatedAt":  "2022-06-24T09:34:42Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Fdyv4",
                                           "createdAt":  "2022-06-24T10:29:55Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "karelz",
                                           "body":  "@carlossanlop given that it fails in each CI run, please disable the test ASAP unless you have high confidence fix. Thanks!",
                                           "updatedAt":  "2022-06-24T10:29:55Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5FejLQ",
                                           "createdAt":  "2022-06-24T14:33:40Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCkTXtg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "karelz",
                                                                               "createdAt":  "2022-06-29T08:45:15Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "adamsitnik",
                                           "body":  "I\u0027ve opened #71258 to disable this test for tvOS",
                                           "updatedAt":  "2022-06-24T14:33:40Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Gahfv",
                                           "createdAt":  "2022-07-12T06:14:34Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ilonatommy",
                                           "body":  "I\u0027m facing a very similar issue on unconnected PRs ([Run](https://dev.azure.com/dnceng/public/_build/results?buildId=1867809)) on:\r\n- net7.0-Linux-Release-x64-Mono_Release_LinuxBionic-Ubuntu.1804.Amd64.Android.29.Open\r\n- net7.0-Linux-Release-arm64-Mono_Release_LinuxBionic-Windows.10.Amd64.Android.Open\r\nThe error:\r\n```\r\nSystem.UnauthorizedAccessException : Access to the path \u0027/data/local/tmp/htuovavi.iw1/output\u0027 is denied.\r\n---- System.IO.IOException : Permission denied\r\n\r\n at Interop.ThrowExceptionForIoErrno(ErrorInfo errorInfo, String path, Boolean isDirectory) in /_/src/libraries/Common/src/Interop/Unix/Interop.IOErrors.cs:line 16\r\n   at Interop.CheckIo(Int64 result, String path, Boolean isDirectory) in /_/src/libraries/Common/src/Interop/Unix/Interop.IOErrors.cs:line 42\r\n   at Interop.CheckIo(Int32 result, String path, Boolean isDirectory) in /_/src/libraries/Common/src/Interop/Unix/Interop.IOErrors.cs:line 58\r\n   at System.Formats.Tar.TarEntry.ExtractAsFifo(String destinationFileName) in /_/src/libraries/System.Formats.Tar/src/System/Formats/Tar/TarEntry.Unix.cs:line 31\r\n   at System.Formats.Tar.TarEntry.CreateNonRegularFile(String filePath, String linkTargetPath) in /_/src/libraries/System.Formats.Tar/src/System/Formats/Tar/TarEntry.cs:line 461\r\n   at System.Formats.Tar.TarEntry.ExtractToFileInternalAsync(String filePath, String linkTargetPath, Boolean overwrite, CancellationToken cancellationToken) in /_/src/libraries/System.Formats.Tar/src/System/Formats/Tar/TarEntry.cs:line 425\r\n   at System.Formats.Tar.TarEntry.ExtractToFileAsync(String destinationFileName, Boolean overwrite, CancellationToken cancellationToken) in /_/src/libraries/System.Formats.Tar/src/System/Formats/Tar/TarEntry.cs:line 261\r\n   at System.Formats.Tar.Tests.TarReader_TarEntry_ExtractToFileAsync_Tests.SpecialFile_Unelevated_Throws_Async() in /_/src/libraries/System.Formats.Tar/tests/TarReader/TarReader.TarEntry.ExtractToFileAsync.Tests.Unix.cs:line 37\r\n   at System.Formats.Tar.Tests.TarReader_TarEntry_ExtractToFileAsync_Tests.SpecialFile_Unelevated_Throws_Async() in /_/src/libraries/System.Formats.Tar/tests/TarReader/TarReader.TarEntry.ExtractToFileAsync.Tests.Unix.cs:line 41\r\n   at System.Formats.Tar.Tests.TarReader_TarEntry_ExtractToFileAsync_Tests.SpecialFile_Unelevated_Throws_Async() in /_/src/libraries/System.Formats.Tar/tests/TarReader/TarReader.TarEntry.ExtractToFileAsync.Tests.Unix.cs:line 41\r\n```\r\nIt looks the same as above, just different platforms. Occurring every time on `runtime-staging` run.",
                                           "updatedAt":  "2022-07-12T06:16:00Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5HGAuf",
                                           "createdAt":  "2022-07-22T16:45:30Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCoS6kw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "adamsitnik",
                                                                               "createdAt":  "2022-07-25T10:48:11Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "karelz",
                                           "body":  "Test is disabled, not blocking CI anymore -\u003e removing blocking-clean-ci label.",
                                           "updatedAt":  "2022-07-22T16:45:30Z"
                                       }
                                   ],
                         "totalCount":  15
                     },
        "title":  "Extract_HardLinkEntry_TargetInsideDirectory test from System.Formats.Tar.Tests fails on Android/iOS/tvOS",
        "labels":  [
                       "disabled-test",
                       "os-ios",
                       "os-tvos",
                       "area-System.Formats.Tar"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/69780",
        "createdAt":  "2022-05-25T06:52:05Z",
        "number":  69780,
        "author":  "tmds",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOC6GIcA==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "GSPP",
                                            "createdAt":  "2022-05-25T12:59:16Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "eerhardt",
                                            "createdAt":  "2022-05-31T19:58:27Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "prettybits",
                                            "createdAt":  "2023-01-30T15:34:45Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "andrewlock",
                                            "createdAt":  "2024-08-11T13:24:24Z"
                                        }
                                    ],
                          "totalCount":  4
                      },
        "updatedAt":  "2025-01-29T20:42:56Z",
        "body":  "### Background and motivation\r\n\r\nThe Tar API that is introduced in https://github.com/dotnet/runtime/issues/65951 currently provides one option while creating: `includeBaseDirectory`, and one option while extracting: `overwriteFiles`.\r\n\r\nThere are many more options that would make sense, for example controlling the owner/group that gets stored in the tar-file when creating, and controlling whether the exact permissions should be restored (including the setgroup/setuser/sticky bit). See [man tar](https://man7.org/linux/man-pages/man1/tar.1.html) for other options that a user may want to control.\r\n\r\nMaybe we want to introduce option classes immediately, to avoid adding additional overloads to the `Create`/`Extract` methods.\r\n\r\n### API Proposal\r\n\r\n```csharp\r\nnamespace System.Formats.Tar;\r\n\r\npublic static partial class TarFile\r\n{\r\n-    public static void CreateFromDirectory(string sourceDirectoryName, Stream destination, bool includeBaseDirectory);\r\n-    public static void CreateFromDirectory(string sourceDirectoryName, string destinationFileName, bool includeBaseDirectory);\r\n-    public static void ExtractToDirectory(Stream source, string destinationDirectoryName, bool overwriteFiles);\r\n-    public static void ExtractToDirectory(string sourceFileName, string destinationDirectoryName, bool overwriteFiles);\r\n+    public static void CreateFromDirectory(string sourceDirectoryName, Stream destination, TarCreateOptions? options = null);\r\n+    public static void CreateFromDirectory(string sourceDirectoryName, string destinationFileName, TarCreateOptions? options = null);\r\n+    public static void ExtractToDirectory(Stream source, string destinationDirectoryName, TarExtractOptions? options = null);\r\n+    public static void ExtractToDirectory(string sourceFileName, string destinationDirectoryName, TarExtractOptions? options = null);\r\n}\r\npublic abstract partial class TarEntry\r\n{\r\n-    public void ExtractToFile(string destinationFileName, bool overwrite);    \r\n+    public void ExtractToFile(string destinationFileName, TarExtractOptions? options = null);\r\n}\r\n\r\n+public sealed class TarExtractOptions\r\n+{\r\n+    public bool OverwriteFiles { get; set; } = true;\r\n+}\r\n+public sealed class TarCreateOptions\r\n+{\r\n+    public bool IncludeBaseDirectory { get; set; } = true;\r\n+}\r\n```\r\n\r\n\r\n### API Usage\r\n\r\n```cs\r\nTarFile.CreateFromDirectory(\"D:/SourceDirectory/\", \"D:/destination.tar\", new() { IncludeBaseDirectory = false });\r\n```\r\n\r\n### Alternative Designs\r\n\r\n_No response_\r\n\r\n### Risks\r\n\r\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOnFTKqw==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5DwpvM",
                                           "createdAt":  "2022-05-25T06:52:10Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-io\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Background and motivation\n\nThe Tar API that is introduced in https://github.com/dotnet/runtime/issues/65951 currently provides one option while creating: `includeBaseDirectory`, and one option while extracting: `overwriteFiles`.\r\n\r\nThere are many more options that would make sense, for example controlling the owner/group that gets stored in the tar-file when creating, and controlling whether the exact permissions should be restored (including the setgroup/setuser/sticky bit). See [man tar](https://man7.org/linux/man-pages/man1/tar.1.html) for other options that a user may want to control.\r\n\r\nMaybe we want to introduce option classes immediately, to avoid adding additional overloads to the `Create`/`Extract` methods.\n\n### API Proposal\n\n```csharp\r\npublic static partial class TarFile\r\n{\r\n-    public static void CreateFromDirectory(string sourceDirectoryName, System.IO.Stream destination, bool includeBaseDirectory);\r\n-    public static void CreateFromDirectory(string sourceDirectoryName, string destinationFileName, bool includeBaseDirectory);\r\n-    public static void ExtractToDirectory(System.IO.Stream source, string destinationDirectoryName, bool overwriteFiles);\r\n-    public static void ExtractToDirectory(string sourceFileName, string destinationDirectoryName, bool overwriteFiles);\r\n+    public static void CreateFromDirectory(string sourceDirectoryName, System.IO.Stream destination, TarCreateOptions? options = null);\r\n+    public static void CreateFromDirectory(string sourceDirectoryName, string destinationFileName, TarCreateOptions? options = null);\r\n+    public static void ExtractToDirectory(System.IO.Stream source, string destinationDirectoryName, TarExtractOptions? options = null);\r\n+    public static void ExtractToDirectory(string sourceFileName, string destinationDirectoryName, TarExtractOptions? options = null);\r\n}\r\npublic abstract partial class TarEntry\r\n{\r\n-    public void ExtractToFile(string destinationFileName, bool overwrite);    \r\n+    public void ExtractToFile(string destinationFileName, TarExtractOptions? options = null);\r\n}\r\n\r\n+public sealed class TarExtractOptions\r\n+{\r\n+    public bool OverwriteFiles { get; set; } = true;\r\n+}\r\n+public sealed class TarCreateOptions\r\n+{\r\n+    public bool IncludeBaseDirectory { get; set; } = true;\r\n+}\r\n```\r\n\n\n### API Usage\n\n```cs\r\nTarFile.CreateFromDirectory(\"D:/SourceDirectory/\", \"D:/destination.tar\", new() { IncludeBaseDirectory = false });\r\n```\n\n### Alternative Designs\n\n_No response_\n\n### Risks\n\n_No response_\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003etmds\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`api-suggestion`, `area-System.IO`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-05-25T06:52:10Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5DwqBz",
                                           "createdAt":  "2022-05-25T06:52:51Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tmds",
                                           "body":  "cc @carlossanlop ",
                                           "updatedAt":  "2022-05-25T06:52:51Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5DyHJS",
                                           "createdAt":  "2022-05-25T13:01:50Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "GSPP",
                                           "body":  "This issue has affected quite a few other .NET classes. It starts with one innocuous bool, and over time expands into a jungle of overloads. It seems wise to immediately use the options approach, and only that.\r\n\r\nAn alternative is to create a flags enum. Of course, that can only control boolean options.",
                                           "updatedAt":  "2022-05-25T13:01:50Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5D_rUM",
                                           "createdAt":  "2022-05-30T06:49:12Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tmds",
                                           "body":  "cc @adamsitnik @eerhardt @bartonjs @stephentoub @terrajobst ",
                                           "updatedAt":  "2022-05-30T06:49:12Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5FLtRt",
                                           "createdAt":  "2022-06-20T17:35:16Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "adamsitnik",
                                           "body":  "@carlossanlop PTAL",
                                           "updatedAt":  "2022-06-20T17:35:16Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5HM_fk",
                                           "createdAt":  "2022-07-25T20:28:02Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "carlossanlop",
                                           "body":  "We did discuss these options classes in the early design stages:\r\n\r\n```diff\r\n+public sealed class TarExtractOptions\r\n+{\r\n+    public bool OverwriteFiles { get; set; } = true;\r\n+}\r\n+public sealed class TarCreateOptions\r\n+{\r\n+    public bool IncludeBaseDirectory { get; set; } = true;\r\n+}\r\n```\r\n\r\nBut since we only had _one_ setting to add, we didn\u0027t think they were needed. So the current static methods are sufficient with their current signature. I would definitely welcome creating the two proposed classes as soon as we have more than one setting to include.\r\n\r\n\u003e There are many more options that would make sense, for example controlling the owner/group that gets stored in the tar-file when creating, and controlling whether the exact permissions should be restored (including the setgroup/setuser/sticky bit)\r\n\r\nI\u0027d be interested in exploring these items you mention, making sure they are proposed in a cross-platform way, because I can see some of these settings not being Windows friendly.\r\n",
                                           "updatedAt":  "2022-07-25T20:28:25Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6cVMqr",
                                           "createdAt":  "2025-01-29T20:42:54Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "carlossanlop",
                                           "body":  "We can include in the proposal the option to extract to an absolute directory, from https://github.com/dotnet/runtime/issues/86724#issuecomment-1639453824\n\nQuoting @am11:\n\n\u003e Something like:\n\u003e ```cs\n\u003e public sealed class TarCreateOptions\n\u003e {\n\u003e +    public bool ContainAbsoluteSymlinkTargetsInDestination { get; set; } = false;\n\u003e }\n\u003e ```\n\u003e and change this logic\n\u003e \n\u003e [runtime/src/libraries/System.Formats.Tar/src/System/Formats/Tar/TarEntry.cs](https://github.com/dotnet/runtime/blob/b6266a6e4ceac8708304eed764e25777d08cf184/src/libraries/System.Formats.Tar/src/System/Formats/Tar/TarEntry.cs#L352)\n\u003e \n\u003e Line 352 in [b6266a6](/dotnet/runtime/commit/b6266a6e4ceac8708304eed764e25777d08cf184)\n\u003e ```cs\n\u003e  Path.IsPathFullyQualified(linkName) ? linkName : Path.Join(Path.GetDirectoryName(fileDestinationPath), linkName)); \n\u003e ```\n\u003e to\n\u003e ```cs\n\u003e  Path.IsPathFullyQualified(linkName) \u0026\u0026 !_creationOptions.ContainAbsoluteSymlinkTargetsInDestination ?\n\u003e      linkName :\n\u003e      Path.Join(Path.GetDirectoryName(fileDestinationPath),\n\u003e          _creationOptions.ContainAbsoluteSymlinkTargetsInDestination ? linkName.TrimStart(\u0027/\u0027) : linkName));\n\u003e ```\n",
                                           "updatedAt":  "2025-01-29T20:42:54Z"
                                       }
                                   ],
                         "totalCount":  7
                     },
        "title":  "[API Proposal]: Add TarExtractOptions/TarCreateOptions",
        "labels":  [
                       "api-suggestion",
                       "area-System.Formats.Tar"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/69953",
        "createdAt":  "2022-05-28T22:02:13Z",
        "number":  69953,
        "author":  "carlossanlop",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-07-31T19:02:31Z",
        "body":  "In this [PR resubmission](https://github.com/dotnet/runtime/pull/69469) I added the missing Browser target platform in the tests project, and the result was that the browser tests that need to read file assets do not work on WASM.\r\n\r\nThose test classes that read file assets will be topped with the ActiveIssue attribute and will be linked to this issue for future investigation, to unblock merging that PR.\r\n\r\n[Log1](https://helixre107v0xdeko0k025g8.blob.core.windows.net/dotnet-runtime-refs-pull-69469-merge-1c7f6feb86f44e48a2/normal-System.Formats.Tar.Tests/1/console.06e0cbb4.log?helixlogtype=result), [log2](https://helixre107v0xdeko0k025g8.blob.core.windows.net/dotnet-runtime-refs-pull-69469-merge-72cadc08da8d459e97/WasmTestOnBrowser-System.Formats.Tar.Tests/1/console.b789a313.log?helixlogtype=result)\r\n\r\nHere\u0027s an output example of one of the browser CI legs:\r\n\r\n```\r\n[02:30:29] fail: [FAIL] System.Formats.Tar.Tests.TarFile_CreateFromDirectory_File_Tests.IncludeAllSegmentsOfPath(includeBaseDirectory: False)\r\n[02:30:29] info: Assert.NotNull() Failure\r\n[02:30:29] info:    at System.Formats.Tar.Tests.TarFile_CreateFromDirectory_File_Tests.IncludeAllSegmentsOfPath(Boolean includeBaseDirectory)\r\n[02:30:29] info:    at System.Reflection.MethodInvoker.InterpretedInvoke(Object obj, Span`1 args, BindingFlags invokeAttr)\r\n[02:30:29] fail: [FAIL] System.Formats.Tar.Tests.TarFile_CreateFromDirectory_File_Tests.IncludeAllSegmentsOfPath(includeBaseDirectory: True)\r\n[02:30:29] info: Assert.NotNull() Failure\r\n[02:30:29] info:    at System.Formats.Tar.Tests.TarFile_CreateFromDirectory_File_Tests.IncludeAllSegmentsOfPath(Boolean includeBaseDirectory)\r\n[02:30:29] info:    at System.Reflection.MethodInvoker.InterpretedInvoke(Object obj, Span`1 args, BindingFlags invokeAttr)\r\n[02:30:29] fail: [FAIL] System.Formats.Tar.Tests.TarFile_CreateFromDirectory_File_Tests.VerifyIncludeBaseDirectory(includeBaseDirectory: False)\r\n[02:30:29] info: Assert.Equal() Failure\r\n[02:30:29] info: Expected: 3\r\n[02:30:29] info: Actual:   0\r\n[02:30:29] info:    at System.Formats.Tar.Tests.TarFile_CreateFromDirectory_File_Tests.VerifyIncludeBaseDirectory(Boolean includeBaseDirectory)\r\n[02:30:29] info:    at System.Reflection.MethodInvoker.InterpretedInvoke(Object obj, Span`1 args, BindingFlags invokeAttr)\r\n[02:30:29] fail: [FAIL] System.Formats.Tar.Tests.TarFile_CreateFromDirectory_File_Tests.VerifyIncludeBaseDirectory(includeBaseDirectory: True)\r\n[02:30:29] info: Assert.Equal() Failure\r\n[02:30:29] info: Expected: 3\r\n[02:30:29] info: Actual:   0\r\n[02:30:29] info:    at System.Formats.Tar.Tests.TarFile_CreateFromDirectory_File_Tests.VerifyIncludeBaseDirectory(Boolean includeBaseDirectory)\r\n[02:30:29] info:    at System.Reflection.MethodInvoker.InterpretedInvoke(Object obj, Span`1 args, BindingFlags invokeAttr)\r\n[02:30:30] fail: [FAIL] System.Formats.Tar.Tests.TarFile_ExtractToDirectory_Stream_Tests.Extract_HardLinkEntry_TargetInsideDirectory\r\n[02:30:30] info: Assert.Equal() Failure\r\n[02:30:30] info: Expected: 2\r\n[02:30:30] info: Actual:   1\r\n[02:30:30] info:    at System.Formats.Tar.Tests.TarFile_ExtractToDirectory_Stream_Tests.Extract_LinkEntry_TargetInsideDirectory_Internal(TarEntryType entryType)\r\n[02:30:30] info:    at System.Formats.Tar.Tests.TarFile_ExtractToDirectory_Stream_Tests.Extract_HardLinkEntry_TargetInsideDirectory()\r\n[02:30:30] info:    at System.Reflection.MethodInvoker.InterpretedInvoke(Object obj, Span`1 args, BindingFlags invokeAttr)\r\n[02:30:30] fail: [FAIL] System.Formats.Tar.Tests.TarFile_ExtractToDirectory_File_Tests.Extract_SpecialFiles_Unix_Unelevated_ThrowsUnauthorizedAccess\r\n[02:30:30] info: Assert.Throws() Failure\r\n[02:30:30] info: Expected: typeof(System.UnauthorizedAccessException)\r\n[02:30:30] info: Actual:   (No exception was thrown)\r\n[02:30:30] info:    at System.Formats.Tar.Tests.TarFile_ExtractToDirectory_File_Tests.Extract_SpecialFiles_Unix_Unelevated_ThrowsUnauthorizedAccess()\r\n[02:30:30] info:    at System.Reflection.MethodInvoker.InterpretedInvoke(Object obj, Span`1 args, BindingFlags invokeAttr)\r\n[02:30:30] fail: [FAIL] System.Formats.Tar.Tests.TarWriter_WriteEntry_File_Tests.EntryName_NullOrEmpty\r\n[02:30:30] info: Assert.NotNull() Failure\r\n[02:30:30] info:    at System.Formats.Tar.Tests.TarWriter_WriteEntry_File_Tests.EntryName_NullOrEmpty()\r\n[02:30:30] info:    at System.Reflection.MethodInvoker.InterpretedInvoke(Object obj, Span`1 args, BindingFlags invokeAttr)\r\n[02:30:30] fail: [FAIL] System.Formats.Tar.Tests.TarWriter_WriteEntry_File_Tests.Add_Directory(format: V7, withContents: False)\r\n[02:30:30] info: Assert.Equal() Failure\r\n[02:30:30] info: Expected: V7\r\n[02:30:30] info: Actual:   Unknown\r\n[02:30:30] info:    at System.Formats.Tar.Tests.TarWriter_WriteEntry_File_Tests.Add_Directory(TarFormat format, Boolean withContents)\r\n[02:30:30] info:    at System.Reflection.MethodInvoker.InterpretedInvoke(Object obj, Span`1 args, BindingFlags invokeAttr)\r\n[02:30:30] fail: [FAIL] System.Formats.Tar.Tests.TarWriter_WriteEntry_File_Tests.Add_Directory(format: V7, withContents: True)\r\n[02:30:30] info: Assert.Equal() Failure\r\n[02:30:30] info: Expected: V7\r\n[02:30:30] info: Actual:   Unknown\r\n[02:30:30] info:    at System.Formats.Tar.Tests.TarWriter_WriteEntry_File_Tests.Add_Directory(TarFormat format, Boolean withContents)\r\n[02:30:30] info:    at System.Reflection.MethodInvoker.InterpretedInvoke(Object obj, Span`1 args, BindingFlags invokeAttr)\r\n[02:30:30] fail: [FAIL] System.Formats.Tar.Tests.TarWriter_WriteEntry_File_Tests.Add_Directory(format: Ustar, withContents: False)\r\n[02:30:30] info: Assert.Equal() Failure\r\n[02:30:30] info: Expected: Ustar\r\n[02:30:30] info: Actual:   Unknown\r\n[02:30:30] info:    at System.Formats.Tar.Tests.TarWriter_WriteEntry_File_Tests.Add_Directory(TarFormat format, Boolean withContents)\r\n[02:30:30] info:    at System.Reflection.MethodInvoker.InterpretedInvoke(Object obj, Span`1 args, BindingFlags invokeAttr)\r\n[02:30:30] fail: [FAIL] System.Formats.Tar.Tests.TarWriter_WriteEntry_File_Tests.Add_Directory(format: Ustar, withContents: True)\r\n[02:30:30] info: Assert.Equal() Failure\r\n[02:30:30] info: Expected: Ustar\r\n[02:30:30] info: Actual:   Unknown\r\n[02:30:30] info:    at System.Formats.Tar.Tests.TarWriter_WriteEntry_File_Tests.Add_Directory(TarFormat format, Boolean withContents)\r\n[02:30:30] info:    at System.Reflection.MethodInvoker.InterpretedInvoke(Object obj, Span`1 args, BindingFlags invokeAttr)\r\n[02:30:30] fail: [FAIL] System.Formats.Tar.Tests.TarWriter_WriteEntry_File_Tests.Add_Directory(format: Pax, withContents: False)\r\n[02:30:30] info: Assert.Equal() Failure\r\n[02:30:30] info: Expected: Pax\r\n[02:30:30] info: Actual:   Unknown\r\n[02:30:30] info:    at System.Formats.Tar.Tests.TarWriter_WriteEntry_File_Tests.Add_Directory(TarFormat format, Boolean withContents)\r\n[02:30:30] info:    at System.Reflection.MethodInvoker.InterpretedInvoke(Object obj, Span`1 args, BindingFlags invokeAttr)\r\n[02:30:30] fail: [FAIL] System.Formats.Tar.Tests.TarWriter_WriteEntry_File_Tests.Add_Directory(format: Pax, withContents: True)\r\n[02:30:30] info: Assert.Equal() Failure\r\n[02:30:30] info: Expected: Pax\r\n[02:30:30] info: Actual:   Unknown\r\n[02:30:30] info:    at System.Formats.Tar.Tests.TarWriter_WriteEntry_File_Tests.Add_Directory(TarFormat format, Boolean withContents)\r\n[02:30:30] info:    at System.Reflection.MethodInvoker.InterpretedInvoke(Object obj, Span`1 args, BindingFlags invokeAttr)\r\n[02:30:30] fail: [FAIL] System.Formats.Tar.Tests.TarWriter_WriteEntry_File_Tests.Add_Directory(format: Gnu, withContents: False)\r\n[02:30:30] info: Assert.Equal() Failure\r\n[02:30:30] info: Expected: Gnu\r\n[02:30:30] info: Actual:   Unknown\r\n[02:30:30] info:    at System.Formats.Tar.Tests.TarWriter_WriteEntry_File_Tests.Add_Directory(TarFormat format, Boolean withContents)\r\n[02:30:30] info:    at System.Reflection.MethodInvoker.InterpretedInvoke(Object obj, Span`1 args, BindingFlags invokeAttr)\r\n[02:30:30] fail: [FAIL] System.Formats.Tar.Tests.TarWriter_WriteEntry_File_Tests.Add_Directory(format: Gnu, withContents: True)\r\n[02:30:30] info: Assert.Equal() Failure\r\n[02:30:30] info: Expected: Gnu\r\n[02:30:30] info: Actual:   Unknown\r\n[02:30:30] info:    at System.Formats.Tar.Tests.TarWriter_WriteEntry_File_Tests.Add_Directory(TarFormat format, Boolean withContents)\r\n[02:30:30] info:    at System.Reflection.MethodInvoker.InterpretedInvoke(Object obj, Span`1 args, BindingFlags invokeAttr)\r\n[02:30:30] fail: [FAIL] System.Formats.Tar.Tests.TarWriter_WriteEntry_File_Tests.Add_File(format: V7)\r\n[02:30:30] info: Assert.NotNull() Failure\r\n[02:30:30] info:    at System.Formats.Tar.Tests.TarWriter_WriteEntry_File_Tests.Add_File(TarFormat format)\r\n[02:30:30] info:    at System.Reflection.MethodInvoker.InterpretedInvoke(Object obj, Span`1 args, BindingFlags invokeAttr)\r\n[02:30:30] fail: [FAIL] System.Formats.Tar.Tests.TarWriter_WriteEntry_File_Tests.Add_File(format: Ustar)\r\n[02:30:30] info: Assert.NotNull() Failure\r\n[02:30:30] info:    at System.Formats.Tar.Tests.TarWriter_WriteEntry_File_Tests.Add_File(TarFormat format)\r\n[02:30:30] info:    at System.Reflection.MethodInvoker.InterpretedInvoke(Object obj, Span`1 args, BindingFlags invokeAttr)\r\n[02:30:30] fail: [FAIL] System.Formats.Tar.Tests.TarWriter_WriteEntry_File_Tests.Add_File(format: Pax)\r\n[02:30:30] info: Assert.NotNull() Failure\r\n[02:30:30] info:    at System.Formats.Tar.Tests.TarWriter_WriteEntry_File_Tests.Add_File(TarFormat format)\r\n[02:30:30] info:    at System.Reflection.MethodInvoker.InterpretedInvoke(Object obj, Span`1 args, BindingFlags invokeAttr)\r\n[02:30:30] fail: [FAIL] System.Formats.Tar.Tests.TarWriter_WriteEntry_File_Tests.Add_File(format: Gnu)\r\n[02:30:30] info: Assert.NotNull() Failure\r\n[02:30:30] info:    at System.Formats.Tar.Tests.TarWriter_WriteEntry_File_Tests.Add_File(TarFormat format)\r\n[02:30:30] info:    at System.Reflection.MethodInvoker.InterpretedInvoke(Object obj, Span`1 args, BindingFlags invokeAttr)\r\n[02:30:30] info: Finished:    System.Formats.Tar.Tests.dll\r\n```",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHORBYh8w==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5D-CJ_",
                                           "createdAt":  "2022-05-28T22:02:16Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-io\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nIn this [PR resubmission](https://github.com/dotnet/runtime/pull/69469) I added the missing Browser target platform in the tests project, and the result was that the browser tests that need to read file assets do not work on WASM.\r\n\r\nThose test classes that read file assets will be topped with the ActiveIssue attribute and will be linked to this issue for future investigation, to unblock merging that PR.\r\n\r\n[Log1](https://helixre107v0xdeko0k025g8.blob.core.windows.net/dotnet-runtime-refs-pull-69469-merge-1c7f6feb86f44e48a2/normal-System.Formats.Tar.Tests/1/console.06e0cbb4.log?helixlogtype=result), [log2](https://helixre107v0xdeko0k025g8.blob.core.windows.net/dotnet-runtime-refs-pull-69469-merge-72cadc08da8d459e97/WasmTestOnBrowser-System.Formats.Tar.Tests/1/console.b789a313.log?helixlogtype=result)\r\n\r\nHere\u0027s an output example of one of the browser CI legs:\r\n\r\n```\r\n[02:30:29] fail: [FAIL] System.Formats.Tar.Tests.TarFile_CreateFromDirectory_File_Tests.IncludeAllSegmentsOfPath(includeBaseDirectory: False)\r\n[02:30:29] info: Assert.NotNull() Failure\r\n[02:30:29] info:    at System.Formats.Tar.Tests.TarFile_CreateFromDirectory_File_Tests.IncludeAllSegmentsOfPath(Boolean includeBaseDirectory)\r\n[02:30:29] info:    at System.Reflection.MethodInvoker.InterpretedInvoke(Object obj, Span`1 args, BindingFlags invokeAttr)\r\n[02:30:29] fail: [FAIL] System.Formats.Tar.Tests.TarFile_CreateFromDirectory_File_Tests.IncludeAllSegmentsOfPath(includeBaseDirectory: True)\r\n[02:30:29] info: Assert.NotNull() Failure\r\n[02:30:29] info:    at System.Formats.Tar.Tests.TarFile_CreateFromDirectory_File_Tests.IncludeAllSegmentsOfPath(Boolean includeBaseDirectory)\r\n[02:30:29] info:    at System.Reflection.MethodInvoker.InterpretedInvoke(Object obj, Span`1 args, BindingFlags invokeAttr)\r\n[02:30:29] fail: [FAIL] System.Formats.Tar.Tests.TarFile_CreateFromDirectory_File_Tests.VerifyIncludeBaseDirectory(includeBaseDirectory: False)\r\n[02:30:29] info: Assert.Equal() Failure\r\n[02:30:29] info: Expected: 3\r\n[02:30:29] info: Actual:   0\r\n[02:30:29] info:    at System.Formats.Tar.Tests.TarFile_CreateFromDirectory_File_Tests.VerifyIncludeBaseDirectory(Boolean includeBaseDirectory)\r\n[02:30:29] info:    at System.Reflection.MethodInvoker.InterpretedInvoke(Object obj, Span`1 args, BindingFlags invokeAttr)\r\n[02:30:29] fail: [FAIL] System.Formats.Tar.Tests.TarFile_CreateFromDirectory_File_Tests.VerifyIncludeBaseDirectory(includeBaseDirectory: True)\r\n[02:30:29] info: Assert.Equal() Failure\r\n[02:30:29] info: Expected: 3\r\n[02:30:29] info: Actual:   0\r\n[02:30:29] info:    at System.Formats.Tar.Tests.TarFile_CreateFromDirectory_File_Tests.VerifyIncludeBaseDirectory(Boolean includeBaseDirectory)\r\n[02:30:29] info:    at System.Reflection.MethodInvoker.InterpretedInvoke(Object obj, Span`1 args, BindingFlags invokeAttr)\r\n[02:30:30] fail: [FAIL] System.Formats.Tar.Tests.TarFile_ExtractToDirectory_Stream_Tests.Extract_HardLinkEntry_TargetInsideDirectory\r\n[02:30:30] info: Assert.Equal() Failure\r\n[02:30:30] info: Expected: 2\r\n[02:30:30] info: Actual:   1\r\n[02:30:30] info:    at System.Formats.Tar.Tests.TarFile_ExtractToDirectory_Stream_Tests.Extract_LinkEntry_TargetInsideDirectory_Internal(TarEntryType entryType)\r\n[02:30:30] info:    at System.Formats.Tar.Tests.TarFile_ExtractToDirectory_Stream_Tests.Extract_HardLinkEntry_TargetInsideDirectory()\r\n[02:30:30] info:    at System.Reflection.MethodInvoker.InterpretedInvoke(Object obj, Span`1 args, BindingFlags invokeAttr)\r\n[02:30:30] fail: [FAIL] System.Formats.Tar.Tests.TarFile_ExtractToDirectory_File_Tests.Extract_SpecialFiles_Unix_Unelevated_ThrowsUnauthorizedAccess\r\n[02:30:30] info: Assert.Throws() Failure\r\n[02:30:30] info: Expected: typeof(System.UnauthorizedAccessException)\r\n[02:30:30] info: Actual:   (No exception was thrown)\r\n[02:30:30] info:    at System.Formats.Tar.Tests.TarFile_ExtractToDirectory_File_Tests.Extract_SpecialFiles_Unix_Unelevated_ThrowsUnauthorizedAccess()\r\n[02:30:30] info:    at System.Reflection.MethodInvoker.InterpretedInvoke(Object obj, Span`1 args, BindingFlags invokeAttr)\r\n[02:30:30] fail: [FAIL] System.Formats.Tar.Tests.TarWriter_WriteEntry_File_Tests.EntryName_NullOrEmpty\r\n[02:30:30] info: Assert.NotNull() Failure\r\n[02:30:30] info:    at System.Formats.Tar.Tests.TarWriter_WriteEntry_File_Tests.EntryName_NullOrEmpty()\r\n[02:30:30] info:    at System.Reflection.MethodInvoker.InterpretedInvoke(Object obj, Span`1 args, BindingFlags invokeAttr)\r\n[02:30:30] fail: [FAIL] System.Formats.Tar.Tests.TarWriter_WriteEntry_File_Tests.Add_Directory(format: V7, withContents: False)\r\n[02:30:30] info: Assert.Equal() Failure\r\n[02:30:30] info: Expected: V7\r\n[02:30:30] info: Actual:   Unknown\r\n[02:30:30] info:    at System.Formats.Tar.Tests.TarWriter_WriteEntry_File_Tests.Add_Directory(TarFormat format, Boolean withContents)\r\n[02:30:30] info:    at System.Reflection.MethodInvoker.InterpretedInvoke(Object obj, Span`1 args, BindingFlags invokeAttr)\r\n[02:30:30] fail: [FAIL] System.Formats.Tar.Tests.TarWriter_WriteEntry_File_Tests.Add_Directory(format: V7, withContents: True)\r\n[02:30:30] info: Assert.Equal() Failure\r\n[02:30:30] info: Expected: V7\r\n[02:30:30] info: Actual:   Unknown\r\n[02:30:30] info:    at System.Formats.Tar.Tests.TarWriter_WriteEntry_File_Tests.Add_Directory(TarFormat format, Boolean withContents)\r\n[02:30:30] info:    at System.Reflection.MethodInvoker.InterpretedInvoke(Object obj, Span`1 args, BindingFlags invokeAttr)\r\n[02:30:30] fail: [FAIL] System.Formats.Tar.Tests.TarWriter_WriteEntry_File_Tests.Add_Directory(format: Ustar, withContents: False)\r\n[02:30:30] info: Assert.Equal() Failure\r\n[02:30:30] info: Expected: Ustar\r\n[02:30:30] info: Actual:   Unknown\r\n[02:30:30] info:    at System.Formats.Tar.Tests.TarWriter_WriteEntry_File_Tests.Add_Directory(TarFormat format, Boolean withContents)\r\n[02:30:30] info:    at System.Reflection.MethodInvoker.InterpretedInvoke(Object obj, Span`1 args, BindingFlags invokeAttr)\r\n[02:30:30] fail: [FAIL] System.Formats.Tar.Tests.TarWriter_WriteEntry_File_Tests.Add_Directory(format: Ustar, withContents: True)\r\n[02:30:30] info: Assert.Equal() Failure\r\n[02:30:30] info: Expected: Ustar\r\n[02:30:30] info: Actual:   Unknown\r\n[02:30:30] info:    at System.Formats.Tar.Tests.TarWriter_WriteEntry_File_Tests.Add_Directory(TarFormat format, Boolean withContents)\r\n[02:30:30] info:    at System.Reflection.MethodInvoker.InterpretedInvoke(Object obj, Span`1 args, BindingFlags invokeAttr)\r\n[02:30:30] fail: [FAIL] System.Formats.Tar.Tests.TarWriter_WriteEntry_File_Tests.Add_Directory(format: Pax, withContents: False)\r\n[02:30:30] info: Assert.Equal() Failure\r\n[02:30:30] info: Expected: Pax\r\n[02:30:30] info: Actual:   Unknown\r\n[02:30:30] info:    at System.Formats.Tar.Tests.TarWriter_WriteEntry_File_Tests.Add_Directory(TarFormat format, Boolean withContents)\r\n[02:30:30] info:    at System.Reflection.MethodInvoker.InterpretedInvoke(Object obj, Span`1 args, BindingFlags invokeAttr)\r\n[02:30:30] fail: [FAIL] System.Formats.Tar.Tests.TarWriter_WriteEntry_File_Tests.Add_Directory(format: Pax, withContents: True)\r\n[02:30:30] info: Assert.Equal() Failure\r\n[02:30:30] info: Expected: Pax\r\n[02:30:30] info: Actual:   Unknown\r\n[02:30:30] info:    at System.Formats.Tar.Tests.TarWriter_WriteEntry_File_Tests.Add_Directory(TarFormat format, Boolean withContents)\r\n[02:30:30] info:    at System.Reflection.MethodInvoker.InterpretedInvoke(Object obj, Span`1 args, BindingFlags invokeAttr)\r\n[02:30:30] fail: [FAIL] System.Formats.Tar.Tests.TarWriter_WriteEntry_File_Tests.Add_Directory(format: Gnu, withContents: False)\r\n[02:30:30] info: Assert.Equal() Failure\r\n[02:30:30] info: Expected: Gnu\r\n[02:30:30] info: Actual:   Unknown\r\n[02:30:30] info:    at System.Formats.Tar.Tests.TarWriter_WriteEntry_File_Tests.Add_Directory(TarFormat format, Boolean withContents)\r\n[02:30:30] info:    at System.Reflection.MethodInvoker.InterpretedInvoke(Object obj, Span`1 args, BindingFlags invokeAttr)\r\n[02:30:30] fail: [FAIL] System.Formats.Tar.Tests.TarWriter_WriteEntry_File_Tests.Add_Directory(format: Gnu, withContents: True)\r\n[02:30:30] info: Assert.Equal() Failure\r\n[02:30:30] info: Expected: Gnu\r\n[02:30:30] info: Actual:   Unknown\r\n[02:30:30] info:    at System.Formats.Tar.Tests.TarWriter_WriteEntry_File_Tests.Add_Directory(TarFormat format, Boolean withContents)\r\n[02:30:30] info:    at System.Reflection.MethodInvoker.InterpretedInvoke(Object obj, Span`1 args, BindingFlags invokeAttr)\r\n[02:30:30] fail: [FAIL] System.Formats.Tar.Tests.TarWriter_WriteEntry_File_Tests.Add_File(format: V7)\r\n[02:30:30] info: Assert.NotNull() Failure\r\n[02:30:30] info:    at System.Formats.Tar.Tests.TarWriter_WriteEntry_File_Tests.Add_File(TarFormat format)\r\n[02:30:30] info:    at System.Reflection.MethodInvoker.InterpretedInvoke(Object obj, Span`1 args, BindingFlags invokeAttr)\r\n[02:30:30] fail: [FAIL] System.Formats.Tar.Tests.TarWriter_WriteEntry_File_Tests.Add_File(format: Ustar)\r\n[02:30:30] info: Assert.NotNull() Failure\r\n[02:30:30] info:    at System.Formats.Tar.Tests.TarWriter_WriteEntry_File_Tests.Add_File(TarFormat format)\r\n[02:30:30] info:    at System.Reflection.MethodInvoker.InterpretedInvoke(Object obj, Span`1 args, BindingFlags invokeAttr)\r\n[02:30:30] fail: [FAIL] System.Formats.Tar.Tests.TarWriter_WriteEntry_File_Tests.Add_File(format: Pax)\r\n[02:30:30] info: Assert.NotNull() Failure\r\n[02:30:30] info:    at System.Formats.Tar.Tests.TarWriter_WriteEntry_File_Tests.Add_File(TarFormat format)\r\n[02:30:30] info:    at System.Reflection.MethodInvoker.InterpretedInvoke(Object obj, Span`1 args, BindingFlags invokeAttr)\r\n[02:30:30] fail: [FAIL] System.Formats.Tar.Tests.TarWriter_WriteEntry_File_Tests.Add_File(format: Gnu)\r\n[02:30:30] info: Assert.NotNull() Failure\r\n[02:30:30] info:    at System.Formats.Tar.Tests.TarWriter_WriteEntry_File_Tests.Add_File(TarFormat format)\r\n[02:30:30] info:    at System.Reflection.MethodInvoker.InterpretedInvoke(Object obj, Span`1 args, BindingFlags invokeAttr)\r\n[02:30:30] info: Finished:    System.Formats.Tar.Tests.dll\r\n```\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003ecarlossanlop\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003ecarlossanlop\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.IO`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e7.0.0\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-05-28T22:02:16Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5EFYEP",
                                           "createdAt":  "2022-05-31T15:08:40Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCldm4A==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "adamsitnik",
                                                                               "createdAt":  "2022-06-23T12:03:03Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "carlossanlop",
                                                                               "createdAt":  "2022-07-06T19:45:54Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "radical",
                                           "body":  "@carlossanlop you can surface files to the wasm app by using `\u003cWasmFilesToIncludeInFileSystem Include=\"...\" /\u003e`",
                                           "updatedAt":  "2022-05-31T15:08:40Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5EFiHz",
                                           "createdAt":  "2022-05-31T15:41:07Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to \u0027arch-wasm\u0027: @lewing\nSee info in area-owners.md if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nIn this [PR resubmission](https://github.com/dotnet/runtime/pull/69469) I added the missing Browser target platform in the tests project, and the result was that the browser tests that need to read file assets do not work on WASM.\r\n\r\nThose test classes that read file assets will be topped with the ActiveIssue attribute and will be linked to this issue for future investigation, to unblock merging that PR.\r\n\r\n[Log1](https://helixre107v0xdeko0k025g8.blob.core.windows.net/dotnet-runtime-refs-pull-69469-merge-1c7f6feb86f44e48a2/normal-System.Formats.Tar.Tests/1/console.06e0cbb4.log?helixlogtype=result), [log2](https://helixre107v0xdeko0k025g8.blob.core.windows.net/dotnet-runtime-refs-pull-69469-merge-72cadc08da8d459e97/WasmTestOnBrowser-System.Formats.Tar.Tests/1/console.b789a313.log?helixlogtype=result)\r\n\r\nHere\u0027s an output example of one of the browser CI legs:\r\n\r\n```\r\n[02:30:29] fail: [FAIL] System.Formats.Tar.Tests.TarFile_CreateFromDirectory_File_Tests.IncludeAllSegmentsOfPath(includeBaseDirectory: False)\r\n[02:30:29] info: Assert.NotNull() Failure\r\n[02:30:29] info:    at System.Formats.Tar.Tests.TarFile_CreateFromDirectory_File_Tests.IncludeAllSegmentsOfPath(Boolean includeBaseDirectory)\r\n[02:30:29] info:    at System.Reflection.MethodInvoker.InterpretedInvoke(Object obj, Span`1 args, BindingFlags invokeAttr)\r\n[02:30:29] fail: [FAIL] System.Formats.Tar.Tests.TarFile_CreateFromDirectory_File_Tests.IncludeAllSegmentsOfPath(includeBaseDirectory: True)\r\n[02:30:29] info: Assert.NotNull() Failure\r\n[02:30:29] info:    at System.Formats.Tar.Tests.TarFile_CreateFromDirectory_File_Tests.IncludeAllSegmentsOfPath(Boolean includeBaseDirectory)\r\n[02:30:29] info:    at System.Reflection.MethodInvoker.InterpretedInvoke(Object obj, Span`1 args, BindingFlags invokeAttr)\r\n[02:30:29] fail: [FAIL] System.Formats.Tar.Tests.TarFile_CreateFromDirectory_File_Tests.VerifyIncludeBaseDirectory(includeBaseDirectory: False)\r\n[02:30:29] info: Assert.Equal() Failure\r\n[02:30:29] info: Expected: 3\r\n[02:30:29] info: Actual:   0\r\n[02:30:29] info:    at System.Formats.Tar.Tests.TarFile_CreateFromDirectory_File_Tests.VerifyIncludeBaseDirectory(Boolean includeBaseDirectory)\r\n[02:30:29] info:    at System.Reflection.MethodInvoker.InterpretedInvoke(Object obj, Span`1 args, BindingFlags invokeAttr)\r\n[02:30:29] fail: [FAIL] System.Formats.Tar.Tests.TarFile_CreateFromDirectory_File_Tests.VerifyIncludeBaseDirectory(includeBaseDirectory: True)\r\n[02:30:29] info: Assert.Equal() Failure\r\n[02:30:29] info: Expected: 3\r\n[02:30:29] info: Actual:   0\r\n[02:30:29] info:    at System.Formats.Tar.Tests.TarFile_CreateFromDirectory_File_Tests.VerifyIncludeBaseDirectory(Boolean includeBaseDirectory)\r\n[02:30:29] info:    at System.Reflection.MethodInvoker.InterpretedInvoke(Object obj, Span`1 args, BindingFlags invokeAttr)\r\n[02:30:30] fail: [FAIL] System.Formats.Tar.Tests.TarFile_ExtractToDirectory_Stream_Tests.Extract_HardLinkEntry_TargetInsideDirectory\r\n[02:30:30] info: Assert.Equal() Failure\r\n[02:30:30] info: Expected: 2\r\n[02:30:30] info: Actual:   1\r\n[02:30:30] info:    at System.Formats.Tar.Tests.TarFile_ExtractToDirectory_Stream_Tests.Extract_LinkEntry_TargetInsideDirectory_Internal(TarEntryType entryType)\r\n[02:30:30] info:    at System.Formats.Tar.Tests.TarFile_ExtractToDirectory_Stream_Tests.Extract_HardLinkEntry_TargetInsideDirectory()\r\n[02:30:30] info:    at System.Reflection.MethodInvoker.InterpretedInvoke(Object obj, Span`1 args, BindingFlags invokeAttr)\r\n[02:30:30] fail: [FAIL] System.Formats.Tar.Tests.TarFile_ExtractToDirectory_File_Tests.Extract_SpecialFiles_Unix_Unelevated_ThrowsUnauthorizedAccess\r\n[02:30:30] info: Assert.Throws() Failure\r\n[02:30:30] info: Expected: typeof(System.UnauthorizedAccessException)\r\n[02:30:30] info: Actual:   (No exception was thrown)\r\n[02:30:30] info:    at System.Formats.Tar.Tests.TarFile_ExtractToDirectory_File_Tests.Extract_SpecialFiles_Unix_Unelevated_ThrowsUnauthorizedAccess()\r\n[02:30:30] info:    at System.Reflection.MethodInvoker.InterpretedInvoke(Object obj, Span`1 args, BindingFlags invokeAttr)\r\n[02:30:30] fail: [FAIL] System.Formats.Tar.Tests.TarWriter_WriteEntry_File_Tests.EntryName_NullOrEmpty\r\n[02:30:30] info: Assert.NotNull() Failure\r\n[02:30:30] info:    at System.Formats.Tar.Tests.TarWriter_WriteEntry_File_Tests.EntryName_NullOrEmpty()\r\n[02:30:30] info:    at System.Reflection.MethodInvoker.InterpretedInvoke(Object obj, Span`1 args, BindingFlags invokeAttr)\r\n[02:30:30] fail: [FAIL] System.Formats.Tar.Tests.TarWriter_WriteEntry_File_Tests.Add_Directory(format: V7, withContents: False)\r\n[02:30:30] info: Assert.Equal() Failure\r\n[02:30:30] info: Expected: V7\r\n[02:30:30] info: Actual:   Unknown\r\n[02:30:30] info:    at System.Formats.Tar.Tests.TarWriter_WriteEntry_File_Tests.Add_Directory(TarFormat format, Boolean withContents)\r\n[02:30:30] info:    at System.Reflection.MethodInvoker.InterpretedInvoke(Object obj, Span`1 args, BindingFlags invokeAttr)\r\n[02:30:30] fail: [FAIL] System.Formats.Tar.Tests.TarWriter_WriteEntry_File_Tests.Add_Directory(format: V7, withContents: True)\r\n[02:30:30] info: Assert.Equal() Failure\r\n[02:30:30] info: Expected: V7\r\n[02:30:30] info: Actual:   Unknown\r\n[02:30:30] info:    at System.Formats.Tar.Tests.TarWriter_WriteEntry_File_Tests.Add_Directory(TarFormat format, Boolean withContents)\r\n[02:30:30] info:    at System.Reflection.MethodInvoker.InterpretedInvoke(Object obj, Span`1 args, BindingFlags invokeAttr)\r\n[02:30:30] fail: [FAIL] System.Formats.Tar.Tests.TarWriter_WriteEntry_File_Tests.Add_Directory(format: Ustar, withContents: False)\r\n[02:30:30] info: Assert.Equal() Failure\r\n[02:30:30] info: Expected: Ustar\r\n[02:30:30] info: Actual:   Unknown\r\n[02:30:30] info:    at System.Formats.Tar.Tests.TarWriter_WriteEntry_File_Tests.Add_Directory(TarFormat format, Boolean withContents)\r\n[02:30:30] info:    at System.Reflection.MethodInvoker.InterpretedInvoke(Object obj, Span`1 args, BindingFlags invokeAttr)\r\n[02:30:30] fail: [FAIL] System.Formats.Tar.Tests.TarWriter_WriteEntry_File_Tests.Add_Directory(format: Ustar, withContents: True)\r\n[02:30:30] info: Assert.Equal() Failure\r\n[02:30:30] info: Expected: Ustar\r\n[02:30:30] info: Actual:   Unknown\r\n[02:30:30] info:    at System.Formats.Tar.Tests.TarWriter_WriteEntry_File_Tests.Add_Directory(TarFormat format, Boolean withContents)\r\n[02:30:30] info:    at System.Reflection.MethodInvoker.InterpretedInvoke(Object obj, Span`1 args, BindingFlags invokeAttr)\r\n[02:30:30] fail: [FAIL] System.Formats.Tar.Tests.TarWriter_WriteEntry_File_Tests.Add_Directory(format: Pax, withContents: False)\r\n[02:30:30] info: Assert.Equal() Failure\r\n[02:30:30] info: Expected: Pax\r\n[02:30:30] info: Actual:   Unknown\r\n[02:30:30] info:    at System.Formats.Tar.Tests.TarWriter_WriteEntry_File_Tests.Add_Directory(TarFormat format, Boolean withContents)\r\n[02:30:30] info:    at System.Reflection.MethodInvoker.InterpretedInvoke(Object obj, Span`1 args, BindingFlags invokeAttr)\r\n[02:30:30] fail: [FAIL] System.Formats.Tar.Tests.TarWriter_WriteEntry_File_Tests.Add_Directory(format: Pax, withContents: True)\r\n[02:30:30] info: Assert.Equal() Failure\r\n[02:30:30] info: Expected: Pax\r\n[02:30:30] info: Actual:   Unknown\r\n[02:30:30] info:    at System.Formats.Tar.Tests.TarWriter_WriteEntry_File_Tests.Add_Directory(TarFormat format, Boolean withContents)\r\n[02:30:30] info:    at System.Reflection.MethodInvoker.InterpretedInvoke(Object obj, Span`1 args, BindingFlags invokeAttr)\r\n[02:30:30] fail: [FAIL] System.Formats.Tar.Tests.TarWriter_WriteEntry_File_Tests.Add_Directory(format: Gnu, withContents: False)\r\n[02:30:30] info: Assert.Equal() Failure\r\n[02:30:30] info: Expected: Gnu\r\n[02:30:30] info: Actual:   Unknown\r\n[02:30:30] info:    at System.Formats.Tar.Tests.TarWriter_WriteEntry_File_Tests.Add_Directory(TarFormat format, Boolean withContents)\r\n[02:30:30] info:    at System.Reflection.MethodInvoker.InterpretedInvoke(Object obj, Span`1 args, BindingFlags invokeAttr)\r\n[02:30:30] fail: [FAIL] System.Formats.Tar.Tests.TarWriter_WriteEntry_File_Tests.Add_Directory(format: Gnu, withContents: True)\r\n[02:30:30] info: Assert.Equal() Failure\r\n[02:30:30] info: Expected: Gnu\r\n[02:30:30] info: Actual:   Unknown\r\n[02:30:30] info:    at System.Formats.Tar.Tests.TarWriter_WriteEntry_File_Tests.Add_Directory(TarFormat format, Boolean withContents)\r\n[02:30:30] info:    at System.Reflection.MethodInvoker.InterpretedInvoke(Object obj, Span`1 args, BindingFlags invokeAttr)\r\n[02:30:30] fail: [FAIL] System.Formats.Tar.Tests.TarWriter_WriteEntry_File_Tests.Add_File(format: V7)\r\n[02:30:30] info: Assert.NotNull() Failure\r\n[02:30:30] info:    at System.Formats.Tar.Tests.TarWriter_WriteEntry_File_Tests.Add_File(TarFormat format)\r\n[02:30:30] info:    at System.Reflection.MethodInvoker.InterpretedInvoke(Object obj, Span`1 args, BindingFlags invokeAttr)\r\n[02:30:30] fail: [FAIL] System.Formats.Tar.Tests.TarWriter_WriteEntry_File_Tests.Add_File(format: Ustar)\r\n[02:30:30] info: Assert.NotNull() Failure\r\n[02:30:30] info:    at System.Formats.Tar.Tests.TarWriter_WriteEntry_File_Tests.Add_File(TarFormat format)\r\n[02:30:30] info:    at System.Reflection.MethodInvoker.InterpretedInvoke(Object obj, Span`1 args, BindingFlags invokeAttr)\r\n[02:30:30] fail: [FAIL] System.Formats.Tar.Tests.TarWriter_WriteEntry_File_Tests.Add_File(format: Pax)\r\n[02:30:30] info: Assert.NotNull() Failure\r\n[02:30:30] info:    at System.Formats.Tar.Tests.TarWriter_WriteEntry_File_Tests.Add_File(TarFormat format)\r\n[02:30:30] info:    at System.Reflection.MethodInvoker.InterpretedInvoke(Object obj, Span`1 args, BindingFlags invokeAttr)\r\n[02:30:30] fail: [FAIL] System.Formats.Tar.Tests.TarWriter_WriteEntry_File_Tests.Add_File(format: Gnu)\r\n[02:30:30] info: Assert.NotNull() Failure\r\n[02:30:30] info:    at System.Formats.Tar.Tests.TarWriter_WriteEntry_File_Tests.Add_File(TarFormat format)\r\n[02:30:30] info:    at System.Reflection.MethodInvoker.InterpretedInvoke(Object obj, Span`1 args, BindingFlags invokeAttr)\r\n[02:30:30] info: Finished:    System.Formats.Tar.Tests.dll\r\n```\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003ecarlossanlop\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003ecarlossanlop\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`arch-wasm`, `area-System.IO`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e7.0.0\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-05-31T15:41:07Z"
                                       }
                                   ],
                         "totalCount":  3
                     },
        "title":  "Tar tests that interact with file assets do not work on Browser",
        "labels":  [
                       "arch-wasm",
                       "area-System.Formats.Tar"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/70517",
        "createdAt":  "2022-06-09T20:46:22Z",
        "number":  70517,
        "author":  "carlossanlop",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOCqUiBA==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "ericstj",
                                            "createdAt":  "2022-06-10T19:49:49Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "GSPP",
                                            "createdAt":  "2022-06-19T06:52:08Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "slang25",
                                            "createdAt":  "2022-08-28T10:24:44Z"
                                        }
                                    ],
                          "totalCount":  3
                      },
        "updatedAt":  "2023-07-05T16:31:40Z",
        "body":  "The APIs we added in `System.Formats.Tar` are meant for handling the `tar` format only. No compression handling was added there.\r\n\r\nCurrently, to handle compressed `tar.gz` files with those APIs, we can use these two methods:\r\n\r\nWe can extract the whole archive in one call:\r\n```cs\r\nusing FileStream compressedStream = File.OpenRead(\"/home/dotnet/SourceDirectory/compressed.tar.gz\");\r\nusing GZipStream decompressor = new(compressedStream, CompressionMode.Decompress);\r\nTarFile.ExtractToDirectory(source: decompressor, destinationDirectoryName: \"/home/dotnet/DestinationDirectory/\", overwriteFiles: false);\r\n```\r\n\r\nOr we can iterate through each individual entry and decide what to do with each:\r\n```cs\r\nusing FileStream compressedStream = File.OpenRead(@\"D:\\SourceDirectory\\compressed.tar.gz\");\r\nusing GZipStream decompressor = new(compressedStream, CompressionMode.Decompress);\r\nusing TarReader reader = new(decompressor, leaveOpen: true);\r\nTarEntry? entry;\r\n\r\nwhile ((entry = GetNextEntry(copyData: true)) != null)\r\n{\r\n    Console.WriteLine($\"Entry type: {entry.EntryType}, entry name: {entry.Name}\");\r\n}\r\n```\r\n\r\nIf we want to add APIs that can handle archives compressed with gzip (or any compression algorithm), we should add them to `System.IO.Compression`. I am opening this issue to initiate the discussion.\r\n\r\nNote: We have an open issue that is trying to standardize the way we use all our compression algorithms: [Standardize pattern for exposing advanced configuration for compression streams](https://github.com/dotnet/runtime/issues/42820). It\u0027s possible this proposal depends on solving that one first.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOSK6-cQ==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5EpBaa",
                                           "createdAt":  "2022-06-09T20:46:34Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-io-compression\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nThe APIs we added in `System.Formats.Tar` are meant for handling the `tar` format only. No compression handling was added there.\r\n\r\nCurrently, to handle compressed `tar.gz` files with those APIs, we can use these two methods:\r\n\r\nWe can extract the whole archive in one call:\r\n```cs\r\nusing FileStream compressedStream = File.OpenRead(\"/home/dotnet/SourceDirectory/compressed.tar.gz\");\r\nusing GZipStream decompressor = new(compressedStream, CompressionMode.Decompress);\r\nTarFile.ExtractToDirectory(source: decompressor, destinationDirectoryName: \"/home/dotnet/DestinationDirectory/\", overwriteFiles: false);\r\n```\r\n\r\nOr we can iterate through each individual entry and decide what to do with each:\r\n```cs\r\nusing FileStream compressedStream = File.OpenRead(@\"D:\\SourceDirectory\\compressed.tar.gz\");\r\nusing GZipStream decompressor = new(compressedStream, CompressionMode.Decompress);\r\nusing TarReader reader = new(decompressor, leaveOpen: true);\r\nTarEntry? entry;\r\n\r\nwhile ((entry = GetNextEntry(copyData: true)) != null)\r\n{\r\n    Console.WriteLine($\"Entry type: {entry.EntryType}, entry name: {entry.Name}\");\r\n}\r\n```\r\n\r\nIf we want to add APIs that can handle archives compressed with gzip (or any compression algorithm), we should add them to `System.IO.Compression`. I am opening this issue to initiate the discussion.\r\n\r\nNote: We have an open issue that is trying to standardize the way we use all our compression algorithms: [Standardize pattern for exposing advanced configuration for compression streams](https://github.com/dotnet/runtime/issues/42820). It\u0027s possible this proposal depends on solving that one first.\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003ecarlossanlop\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.IO.Compression`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-06-09T20:46:34Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Irr5x",
                                           "createdAt":  "2022-08-18T12:06:33Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "iSazonov",
                                           "body":  "Example of code to extract an archive:\r\n```c#\r\n        TarEntry? entry = null;\r\n\r\n        using (var sourceStream = File.Open(Source, FileMode.Open, FileAccess.ReadWrite, FileShare.ReadWrite))\r\n        {\r\n            using var reader = new TarReader(sourceStream);\r\n            try\r\n            {\r\n                entry = reader.GetNextEntry();\r\n            }\r\n            catch\r\n            {\r\n                // It is not tar archive. Go to next format detection.\r\n            }\r\n        }\r\n\r\n        if (entry is not null)\r\n        {\r\n            TarFile.ExtractToDirectory(Source, ToDirectory, Otherwrite);\r\n            return;\r\n        }\r\n\r\n        using (var sourceStream = File.Open(Source, FileMode.Open, FileAccess.Read, FileShare.Read))\r\n        {\r\n            using var decompressorStream = new GZipStream(sourceStream, CompressionMode.Decompress);\r\n            using var reader = new TarReader(decompressorStream);\r\n            try\r\n            {\r\n                entry = reader.GetNextEntry();\r\n            }\r\n            catch\r\n            {\r\n                // It is not tar archive. Go to next format detection.\r\n            }\r\n        }\r\n\r\n        if (entry is not null)\r\n        {\r\n            using var sourceStream = File.Open(Source, FileMode.Open, FileAccess.Read, FileShare.Read);\r\n            using var decompressorStream = new GZipStream(sourceStream, CompressionMode.Decompress);\r\n            TarFile.ExtractToDirectory(decompressorStream, ToDirectory, Otherwrite);\r\n\r\n            return;\r\n        }\r\n\r\n        ExtractZipToDirectory(this, Source, ToDirectory, Encoding, Otherwrite);\r\n```\r\n\r\nNotice, we have to put Zip detection on last place - **after .gz**",
                                           "updatedAt":  "2022-08-18T12:58:07Z"
                                       }
                                   ],
                         "totalCount":  2
                     },
        "title":  "[API Proposal]: Add APIs to `System.IO.Compression` that can compressed `tar` archives like `tar.gz`",
        "labels":  [
                       "area-System.Formats.Tar"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/74404",
        "createdAt":  "2022-08-23T08:31:24Z",
        "number":  74404,
        "author":  "tmds",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOC7aEjg==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "andrewlock",
                                            "createdAt":  "2024-08-11T13:03:12Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "elementh",
                                            "createdAt":  "2024-09-03T12:15:32Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Xor-el",
                                            "createdAt":  "2024-09-03T17:43:38Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "nulltoken",
                                            "createdAt":  "2024-09-03T18:44:48Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "dcuccia",
                                            "createdAt":  "2024-09-29T17:07:52Z"
                                        }
                                    ],
                          "totalCount":  5
                      },
        "updatedAt":  "2024-07-28T01:45:26Z",
        "body":  "Currently hard links to the same file get duplicated in the archive.\r\nInstead, when additional hard links to the same file are encountered, they should be stored as hard links to the first entry.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOSPibBw==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5I8MMm",
                                           "createdAt":  "2022-08-23T08:31:31Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-io\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nCurrently hard links to the same file get duplicated in the archive.\r\nInstead, when additional hard links to the same file are encountered, they should be stored as hard links to the first entry.\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003etmds\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.IO`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003eFuture\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-08-23T08:31:31Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5I8MTb",
                                           "createdAt":  "2022-08-23T08:31:54Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tmds",
                                           "body":  "cc @carlossanlop ",
                                           "updatedAt":  "2022-08-23T08:31:54Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5I851Z",
                                           "createdAt":  "2022-08-23T11:19:26Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "carlossanlop",
                                           "body":  "How do you differentiate a regular file from a hard link?",
                                           "updatedAt":  "2022-08-23T11:19:26Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5I89VK",
                                           "createdAt":  "2022-08-23T11:33:14Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tmds",
                                           "body":  "\u003e How do you differentiate a regular file from a hard link?\r\n\r\nOnce the hard link is created the resulting path is no different from the path it was created from.\r\nBoth paths now have a strong reference to the file.\r\n\r\nWhen you `stat`, `st_nlink` contains the nr of hard links. When there are multiple hard links, it will be higher than 1.\r\nPaths to the same file have the same `st_ino`.",
                                           "updatedAt":  "2022-08-23T11:33:14Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5I8-sj",
                                           "createdAt":  "2022-08-23T11:38:39Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOC_ITVg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "jozkee",
                                                                               "createdAt":  "2023-06-26T23:40:31Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "tmds",
                                           "body":  "For example:\r\n\r\nCreate a file:\r\n```\r\ntouch file\r\n```\r\nCreate a hard link:\r\n```\r\nln file file2\r\n```\r\n\r\nBoth of these are valid paths for the file. They both register as regular files. Notice the `2` in the output of `ls` which is the nr of hard links.\r\n```\r\n$ ls -lah\r\ntotal 0\r\ndrwxr-xr-x.  2 tmds tmds   80 Aug 23 13:36 .\r\ndrwxrwxrwt. 43 root root 1.4K Aug 23 13:22 ..\r\n-rw-r--r--.  2 tmds tmds    0 Aug 23 13:36 file\r\n-rw-r--r--.  2 tmds tmds    0 Aug 23 13:36 file2\r\n```\r\nThey have the same inode nr:\r\n```\r\n$ stat file file2\r\n  File: file\r\n  Size: 0         \tBlocks: 0          IO Block: 4096   regular empty file\r\nDevice: 0,41\tInode: 13530       Links: 2\r\nAccess: (0644/-rw-r--r--)  Uid: ( 1000/    tmds)   Gid: ( 1000/    tmds)\r\nContext: unconfined_u:object_r:user_tmp_t:s0\r\nAccess: 2022-08-23 13:36:05.514551062 +0200\r\nModify: 2022-08-23 13:36:05.514551062 +0200\r\nChange: 2022-08-23 13:36:08.184538995 +0200\r\n Birth: 2022-08-23 13:36:05.514551062 +0200\r\n  File: file2\r\n  Size: 0         \tBlocks: 0          IO Block: 4096   regular empty file\r\nDevice: 0,41\tInode: 13530       Links: 2\r\nAccess: (0644/-rw-r--r--)  Uid: ( 1000/    tmds)   Gid: ( 1000/    tmds)\r\nContext: unconfined_u:object_r:user_tmp_t:s0\r\nAccess: 2022-08-23 13:36:05.514551062 +0200\r\nModify: 2022-08-23 13:36:05.514551062 +0200\r\nChange: 2022-08-23 13:36:08.184538995 +0200\r\n Birth: 2022-08-23 13:36:05.514551062 +0200\r\n```",
                                           "updatedAt":  "2022-08-23T11:38:39Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5I9iwj",
                                           "createdAt":  "2022-08-23T13:39:44Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "KalleOlaviNiemitalo",
                                           "body":  "\u003e Paths to the same file have the same `st_ino`.\r\n\r\nAnd the same `st_dev`.\r\n\r\nFor Win32, there is [FindFirstFileNameW](https://docs.microsoft.com/windows/win32/api/fileapi/nf-fileapi-findfirstfilenamew), but I don\u0027t know whether it works with all remote file systems (SMB, NFS, WSL2), and the results might be difficult to use if symbolic links to directories are involved. There is also `DWORD NumberOfLinks` in [FILE_STANDARD_INFO](https://docs.microsoft.com/windows/win32/api/winbase/ns-winbase-file_standard_info), `LARGE_INTEGER FileId` in [FILE_ID_BOTH_DIR_INFO](https://docs.microsoft.com/windows/win32/api/winbase/ns-winbase-file_id_both_dir_info), and `FILE_ID_128 FileId` in [FILE_ID_INFO](https://docs.microsoft.com/windows/win32/api/winbase/ns-winbase-file_id_info) or [FILE_ID_EXTD_DIR_INFO](https://docs.microsoft.com/windows/win32/api/winbase/ns-winbase-file_id_extd_dir_info). Of these, FILE_ID_128 appears to be supported on Windows Server only. On Windows client operating systems, you\u0027d have to use some other way to check whether the files are in the same volume, but I don\u0027t know how to do that efficiently. Perhaps the volume check doesn\u0027t have to be efficient if you do it only when `DWORD NumberOfLinks` is greater than one and `LARGE_INTEGER FileId` already matches.",
                                           "updatedAt":  "2022-08-23T13:40:45Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5I-FEA",
                                           "createdAt":  "2022-08-23T15:26:59Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "carlossanlop",
                                           "body":  "Thanks @tmds. When I was implementing hardlinks, I didn\u0027t find information explaining st_nlink. I should\u0027ve asked you directly.\r\n\r\nWould you consider hardlinks a common enough scenario that we would have to fix this in 7? Or can this wait to be fixed in 8?",
                                           "updatedAt":  "2022-08-23T15:26:59Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5I-Io-",
                                           "createdAt":  "2022-08-23T15:38:19Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "adamsitnik",
                                           "body":  "I\u0027ve moved it to 8.0 as I don\u0027t believe that such scenarios should be common. Moreover, it sounds like we are going to need to perform some extra work to get it working. This might cause minor perf regression.",
                                           "updatedAt":  "2022-08-23T15:38:19Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5I-JsH",
                                           "createdAt":  "2022-08-23T15:41:31Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCrBkBA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "adamsitnik",
                                                                               "createdAt":  "2022-08-23T18:37:23Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "tmds",
                                           "body":  "Yes, 8 is fine.",
                                           "updatedAt":  "2022-08-23T15:41:31Z"
                                       }
                                   ],
                         "totalCount":  9
                     },
        "title":  "Tar: archive creation should detect hard links to same file",
        "labels":  [
                       "help wanted",
                       "area-System.Formats.Tar"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/76405",
        "createdAt":  "2022-09-29T21:58:22Z",
        "number":  76405,
        "author":  "jozkee",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2024-07-28T01:47:56Z",
        "body":  "### Description\n\nThere\u0027s no syncronization between `ExtendedAttributes` and public properties, which may lead to unexpected results when writing a `PaxTarEntry`. And when the entry is written, we always take the value from the properties, which is better than the opposite IMO.\n\n### Reproduction Steps\n\n```cs\r\n[Fact]\r\npublic void QuickTest()\r\n{\r\n    Dictionary\u003cstring, string\u003e ea = new();\r\n    ea[\"path\"] = \"foo\";\r\n\r\n    PaxTarEntry paxEntry = new PaxTarEntry(TarEntryType.RegularFile, \"bar\", ea);\r\n\r\n    Console.WriteLine(paxEntry.Name); // prints bar\r\n    Console.WriteLine(paxEntry.ExtendedAttributes[\"path\"]); // prints foo\r\n}\r\n```\n\n### Expected behavior\n\nI would expect an exception when you pass an ExtendedAttributes dictionary with a key that colides with a pulbic property AND the values are different. \r\nAlso, I would expect that setting the value on any of them would update the other. I think you can just set values through the public properties e.g: Name, LinkName, GroupName, etc. but we need to double-check.\r\n\n\n### Actual behavior\n\nNo syncronization nor exception is thrown when this happens.\n\n### Regression?\n\nNo\n\n### Known Workarounds\n\nThis is more relevant for the \"path\" key and you can lookup the key in the dictionary before passing it to the ctor. and use that for the `entryName` argument. \n\n### Configuration\n\n_No response_\n\n### Other information\n\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOS1cVNA==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5LRa9F",
                                           "createdAt":  "2022-09-29T21:58:26Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "I couldn\u0027t figure out the best area label to add to this issue. If you have write-permissions please help me learn by adding exactly one [area label](https://github.com/dotnet/runtime/blob/master/docs/area-owners.md).",
                                           "updatedAt":  "2022-09-29T21:58:26Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5LRdcf",
                                           "createdAt":  "2022-09-29T22:10:52Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jozkee",
                                           "body":  "Other scenario that came to my mind.\r\n1. someone uses the copy ctor. passing the extended attributes from the other entry.\r\n2. on the new entry, you set ModificationTime.\r\n3. pass the new entry to TarWriter.WriteEntry. \r\n\r\nThe modification time will be neglected due to this check:\r\nhttps://github.com/dotnet/runtime/blob/8ff1bd04dfce1ca7e80401053b8983e22798a29d/src/libraries/System.Formats.Tar/src/System/Formats/Tar/TarHeader.Write.cs#L725-L728\r\n",
                                           "updatedAt":  "2022-09-29T22:10:52Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5LTUxr",
                                           "createdAt":  "2022-09-30T09:50:31Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-io-compression\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Description\n\nThere\u0027s no syncronization between `ExtendedAttributes` and public properties, which may lead to unexpected results when writing a `PaxTarEntry`. And when the entry is written, we always take the value from the properties, which is better than the opposite IMO.\n\n### Reproduction Steps\n\n```cs\r\n[Fact]\r\npublic void QuickTest()\r\n{\r\n    Dictionary\u003cstring, string\u003e ea = new();\r\n    ea[\"path\"] = \"foo\";\r\n\r\n    PaxTarEntry paxEntry = new PaxTarEntry(TarEntryType.RegularFile, \"bar\", ea);\r\n\r\n    Console.WriteLine(paxEntry.Name); // prints bar\r\n    Console.WriteLine(paxEntry.ExtendedAttributes[\"path\"]); // prints foo\r\n}\r\n```\n\n### Expected behavior\n\nI would expect an exception when you pass an ExtendedAttributes dictionary with a key that colides with a pulbic property AND the values are different. \r\nAlso, I would expect that setting the value on any of them would update the other. I think you can just set values through the public properties e.g: Name, LinkName, GroupName, etc. but we need to double-check.\r\n\n\n### Actual behavior\n\nNo syncronization nor exception is thrown when this happens.\n\n### Regression?\n\nNo\n\n### Known Workarounds\n\nThis is more relevant for the \"path\" key and you can lookup the key in the dictionary before passing it to the ctor. and use that for the `entryName` argument. \n\n### Configuration\n\n_No response_\n\n### Other information\n\n_No response_\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eJozkee\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.IO.Compression`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e8.0.0\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-09-30T09:50:31Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5LVxU0",
                                           "createdAt":  "2022-09-30T20:33:32Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-io\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Description\n\nThere\u0027s no syncronization between `ExtendedAttributes` and public properties, which may lead to unexpected results when writing a `PaxTarEntry`. And when the entry is written, we always take the value from the properties, which is better than the opposite IMO.\n\n### Reproduction Steps\n\n```cs\r\n[Fact]\r\npublic void QuickTest()\r\n{\r\n    Dictionary\u003cstring, string\u003e ea = new();\r\n    ea[\"path\"] = \"foo\";\r\n\r\n    PaxTarEntry paxEntry = new PaxTarEntry(TarEntryType.RegularFile, \"bar\", ea);\r\n\r\n    Console.WriteLine(paxEntry.Name); // prints bar\r\n    Console.WriteLine(paxEntry.ExtendedAttributes[\"path\"]); // prints foo\r\n}\r\n```\n\n### Expected behavior\n\nI would expect an exception when you pass an ExtendedAttributes dictionary with a key that colides with a pulbic property AND the values are different. \r\nAlso, I would expect that setting the value on any of them would update the other. I think you can just set values through the public properties e.g: Name, LinkName, GroupName, etc. but we need to double-check.\r\n\n\n### Actual behavior\n\nNo syncronization nor exception is thrown when this happens.\n\n### Regression?\n\nNo\n\n### Known Workarounds\n\nThis is more relevant for the \"path\" key and you can lookup the key in the dictionary before passing it to the ctor. and use that for the `entryName` argument. \n\n### Configuration\n\n_No response_\n\n### Other information\n\n_No response_\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eJozkee\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.IO`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e8.0.0\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-09-30T20:33:32Z"
                                       }
                                   ],
                         "totalCount":  4
                     },
        "title":  "Tar: ExtendedAttributes does not synchronize with public properties of PaxTarEntry",
        "labels":  [
                       "area-System.Formats.Tar"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/82949",
        "createdAt":  "2023-03-03T18:08:30Z",
        "number":  82949,
        "author":  "billfreist",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-07-31T19:02:32Z",
        "body":  "https://github.com/dotnet/runtime/blob/9fd3ece652fed473c9f2398363da6d7bca41a5d9/src/libraries/System.Formats.Tar/src/System/Formats/Tar/TarWriter.Windows.cs#L25\r\n\r\nAs seen in the snippet above, the Tar Entry gets mistaken for a symlink if the reparse point flag is set, but it doesn\u0027t verify if the file/directory is actually a symlink/junction. Windows Server with file deduplication enabled, or even OneDrive synced files, can set the Reparse point flag, but utilizes entirely different reparse tags.\r\n\r\nIO_REPARSE_TAG_DEDUP is used for deduplication, whereas IO_REPARSE_TAG_MOUNT_POINT \u0026 IO_REPARSE_TAG_SYMLINK are used for junctions and symlinks.\r\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOYcipVQ==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5WqN1S",
                                           "createdAt":  "2023-03-03T18:08:39Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-io\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nhttps://github.com/dotnet/runtime/blob/9fd3ece652fed473c9f2398363da6d7bca41a5d9/src/libraries/System.Formats.Tar/src/System/Formats/Tar/TarWriter.Windows.cs#L25\r\n\r\nAs seen in the snippet above, the Tar Entry gets mistaken for a symlink if the reparse point flag is set, but it doesn\u0027t verify if the file/directory is actually a symlink/junction. Windows Server with file deduplication enabled, or even OneDrive synced files, can set the Reparse point flag, but utilizes entirely different reparse tags.\r\n\r\nIO_REPARSE_TAG_DEDUP is used for deduplication, whereas IO_REPARSE_TAG_MOUNT_POINT \u0026 IO_REPARSE_TAG_SYMLINK are used for junctions and symlinks.\r\n\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003ebillfreist\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.IO`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-03-03T18:08:39Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5WqOXV",
                                           "createdAt":  "2023-03-03T18:10:34Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "billfreist",
                                           "body":  "I should note, this results in the following exception:\r\n\r\n```\r\nSystem.ArgumentException: The value cannot be an empty string. (Parameter \u0027value\u0027)\r\n   at System.ArgumentException.ThrowNullOrEmptyException(String argument, String paramName)\r\n   at System.Formats.Tar.TarEntry.set_LinkName(String value)\r\n   at System.Formats.Tar.TarWriter.ConstructEntryForWriting(String fullPath, String entryName, FileOptions fileOptions)\r\n   at System.Formats.Tar.TarWriter.ReadFileFromDiskAndWriteToArchiveStreamAsEntryAsync(String fullPath, String entryName, CancellationToken cancellationToken)",
                                           "updatedAt":  "2023-03-03T18:10:34Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5WqUdR",
                                           "createdAt":  "2023-03-03T18:35:00Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "billfreist",
                                           "body":  "Looking further, it appears this line is masking the issue (which ultimately leads to the exception due to the fallback to passing `string.Empty`.\r\nhttps://github.com/dotnet/runtime/blob/9fd3ece652fed473c9f2398363da6d7bca41a5d9/src/libraries/System.Formats.Tar/src/System/Formats/Tar/TarWriter.Windows.cs#L61\r\n\r\n`FileSystemInfo.LinkTarget` checks for those proper Reparse Tags mentioned above and returns `null` when it doesn\u0027t have those tags. It would _seem_ that the code could just check for the existence of that valid LinkTarget once it determines it has the reparse point file flag. Something like:\r\n\r\n`if ((attributes \u0026 FileAttributes.ReparsePoint) != 0 \u0026\u0026 info.LinkTarget is not null)`",
                                           "updatedAt":  "2023-03-03T18:35:00Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5XbRRR",
                                           "createdAt":  "2023-03-13T18:58:02Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "carlossanlop",
                                           "body":  "@Jozkee @adamsitnik is this something that the System.IO APIs do correctly, or do we have to address this problem in both the Tar APIs and the IO APIs? (maybe Zip too?)",
                                           "updatedAt":  "2023-03-13T18:58:02Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5XbnST",
                                           "createdAt":  "2023-03-13T19:47:18Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jozkee",
                                           "body":  "`LinkTarget` works properly.\r\n\r\n\u003e FileSystemInfo.LinkTarget checks for those proper Reparse Tags mentioned above and returns null",
                                           "updatedAt":  "2023-03-13T19:47:18Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5XbsK7",
                                           "createdAt":  "2023-03-13T20:02:05Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOC3vEPg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "jozkee",
                                                                               "createdAt":  "2023-03-13T20:54:10Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "billfreist",
                                           "body":  "\u003e `LinkTarget` works properly.\r\n\u003e \r\n\u003e \u003e FileSystemInfo.LinkTarget checks for those proper Reparse Tags mentioned above and returns null\r\n\r\nSorry, the wording wasn\u0027t clear. I meant that it returns `null` when its supposed to. So in the case I\u0027m hitting with the dedup tag, its `null`, when it has the symbolic link or junction tags then it returns a valid link target.",
                                           "updatedAt":  "2023-03-13T20:02:05Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5hsTru",
                                           "createdAt":  "2023-07-17T23:03:31Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "carlossanlop",
                                           "body":  "@billfreist - \r\n\r\nI see what you mean. We should explicitly confirm that the file is a reparse point of type junction, and nothing else, and if the answer is \"junction\", we should store it in the archive as a symbolic link (because it\u0027s the closest entry type to junction, and because the Tar spec does not officially support junctions).\r\n\r\nI am unsure how the other reparse points should be treated. I suspect we could try treating them as regular files. I\u0027d have to investigate.\r\n\r\nIf it\u0027s helpful for you, @billfreist , the workaround would be to manually extract that reparse point junction entry manually, using TarArchive to open the archive, then iterating the entries until the one that failed is found, and manually creating a symbolic link for it: https://learn.microsoft.com/en-us/dotnet/api/system.io.file.createsymboliclink?view=net-7.0\r\n",
                                           "updatedAt":  "2023-07-17T23:03:31Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5hyKlV",
                                           "createdAt":  "2023-07-18T16:19:21Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "carlossanlop",
                                           "body":  "Ok I have a fix that would specifically check, just like we do in FileSystem.Windows.cs, that if we have a reparse point, we only treat it as a tar symlink if windows categorized it as a junction or as a symlink.",
                                           "updatedAt":  "2023-07-18T16:19:21Z"
                                       }
                                   ],
                         "totalCount":  8
                     },
        "title":  "TarWriter on Windows Server treats File Deduplication reparse point flag as symbolic links",
        "labels":  [
                       "area-System.Formats.Tar"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/89037",
        "createdAt":  "2023-07-17T19:23:32Z",
        "number":  89037,
        "author":  "carlossanlop",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2023-07-17T19:23:38Z",
        "body":  "Follow up of PR https://github.com/dotnet/runtime/pull/88280 and specifically, follow-up of this commit: https://github.com/dotnet/runtime/pull/88280/commits/548200889cce7d5c1d31c41702246a480789e455\r\n\r\nNeed to create a test that actually runs in the CI that simulates writing and reading the long data section, but without torturing our CI machines\u0027 disk and memory.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOYa0nlg==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5hrSeW",
                                           "createdAt":  "2023-07-17T19:23:37Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-formats-tar\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nFollow up of PR https://github.com/dotnet/runtime/pull/88280 and specifically, follow-up of this commit: https://github.com/dotnet/runtime/pull/88280/commits/548200889cce7d5c1d31c41702246a480789e455\r\n\r\nNeed to create a test that actually runs in the CI that simulates writing and reading the long data section, but without torturing our CI machines\u0027 disk and memory.\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003ecarlossanlop\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`test-enhancement`, `area-System.Formats.Tar`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003eFuture\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-07-17T19:23:37Z"
                                       }
                                   ],
                         "totalCount":  1
                     },
        "title":  "Add tar test with custom stream that simulates reading/writing \u003e8GB file entry",
        "labels":  [
                       "test-enhancement",
                       "area-System.Formats.Tar"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/89056",
        "createdAt":  "2023-07-17T22:29:10Z",
        "number":  89056,
        "author":  "carlossanlop",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOC8skRQ==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "mthalman",
                                            "createdAt":  "2024-11-15T18:45:01Z"
                                        }
                                    ],
                          "totalCount":  1
                      },
        "updatedAt":  "2025-09-15T09:09:20Z",
        "body":  "As suggested here: https://github.com/dotnet/runtime/issues/74316#issuecomment-1637308693\r\n\r\nIdeally, when reading a `tar.xyz` compressed file using `TarFile` or `TarArchive` APIs, we should detect the magic numbers at the beginning of the archive, determine the archive is compressed, and throw a friendlier error message. We currently throw `Unable to parse number` in `ThrowInvalidNumber()`. And we could offer two variations of the same exception:\r\n\r\n- If we support the compression algorithm, suggest wrapping the archive with a stream class for that algorithm (DeflateStream, GZipStream, ZLibStream).\r\n- If we don\u0027t support the compression algorithm, but it has magic numbers, detect them, mention the algorithm is currently unsupported.\r\n\r\nNote: We have proposal https://github.com/dotnet/runtime/issues/70517 to track the request to be able to open `tar.gz` files, since we support gzip. `TarFile` and `TarArchive` support the tar format only, no compression.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOYbDGnw==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5hsMaf",
                                           "createdAt":  "2023-07-17T22:29:14Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-formats-tar\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nAs suggested here: https://github.com/dotnet/runtime/issues/74316#issuecomment-1637308693\r\n\r\nIdeally, when reading a `tar.xyz` compressed file using `TarFile` or `TarArchive` APIs, we should detect the magic numbers at the beginning of the archive, determine the archive is compressed, and throw a friendlier error message. We currently throw `Unable to parse number` in `ThrowInvalidNumber()`. And we could offer two variations of the same exception:\r\n\r\n- If we support the compression algorithm, suggest wrapping the archive with a stream class for that algorithm (DeflateStream, GZipStream, ZLibStream).\r\n- If we don\u0027t support the compression algorithm, but it has magic numbers, detect them, mention the algorithm is currently unsupported.\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003ecarlossanlop\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Formats.Tar`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003eFuture\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-07-17T22:29:14Z"
                                       }
                                   ],
                         "totalCount":  1
                     },
        "title":  "Tar: Detect magic numbers in archives compressed with popular algorithms",
        "labels":  [
                       "area-System.Formats.Tar"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/101948",
        "createdAt":  "2024-05-06T22:12:48Z",
        "number":  101948,
        "author":  "ericstj",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOC5EBEA==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "fchamieh",
                                            "createdAt":  "2024-07-02T09:05:03Z"
                                        }
                                    ],
                          "totalCount":  1
                      },
        "updatedAt":  "2024-07-20T01:39:50Z",
        "body":  "### Description\n\nWhen disposing the stream of a single `TarEntry`, I cannot advance the `TarReader` to the next entry.\r\n\r\nConsider the following sample:\r\n```\r\nusing (var tarReader = new TarReader(unseekableStream))\r\n{\r\n    TarEntry? entry;\r\n    while ((entry = tarReader.GetNextEntry()) != null)\r\n    {\r\n         Stream s = entry.DataStream;\r\n         s.CopyTo(someOtherStream);\r\n         s.Dispose();\r\n    }\r\n}\r\n```\r\n\r\nThis will throw \r\n```\r\nSystem.ObjectDisposedException\r\n  HResult=0x80131622\r\n  Message=Cannot access a disposed object.\r\nObject name: \u0027System.Formats.Tar.SubReadStream\u0027.\r\n  Source=System.Private.CoreLib\r\n  StackTrace:\r\nSystem.Private.CoreLib.dll!System.ThrowHelper.ThrowObjectDisposedException(object instance) Line 458\r\n\tat /_/src/libraries/System.Private.CoreLib/src/System/ThrowHelper.cs(458)\r\nSystem.Private.CoreLib.dll!System.ObjectDisposedException.ThrowIf(bool condition, object instance) Line 61\r\n\tat /_/src/libraries/System.Private.CoreLib/src/System/ObjectDisposedException.cs(61)\r\nSystem.Formats.Tar.dll!System.Formats.Tar.SubReadStream.Position.get() Line 52\r\n\tat /_/src/libraries/System.Formats.Tar/src/System/Formats/Tar/SubReadStream.cs(52)\r\nSystem.Formats.Tar.dll!System.Formats.Tar.TarReader.AdvanceDataStreamIfNeeded() Line 228\r\n\tat /_/src/libraries/System.Formats.Tar/src/System/Formats/Tar/TarReader.cs(228)\r\nSystem.Formats.Tar.dll!System.Formats.Tar.TarReader.GetNextEntry(bool copyData) Line 133\r\n\tat /_/src/libraries/System.Formats.Tar/src/System/Formats/Tar/TarReader.cs(133)\r\n```\r\n\r\nThe suspect code is here: https://github.com/dotnet/runtime/blob/84b33395057737db3ea342a5151feb6b90c1b6f6/src/libraries/System.Formats.Tar/src/System/Formats/Tar/TarReader.cs#L200-L237\r\n \n\n### Reproduction Steps\n\nSee above\n\n### Expected behavior\n\nNo exception thrown\n\n### Actual behavior\n\nObjectDisposedException\n\n### Regression?\n\nNo\n\n### Known Workarounds\n\nCopy the entry to a memory stream.  Copy the archive to a memory stream before opening (so it is seek-able). Etc \n\n### Configuration\n\n_No response_\n\n### Other information\n\nI noticed when debugging this that the state of the `SubReadStream` was the following:\r\n![image](https://github.com/dotnet/runtime/assets/8918108/b7da21f1-845d-4c22-8f48-a8cb0feaf2df)\r\n\r\nNote that `_positionInSuperStream` is the same as `_endInSuperStream`.  I noticed that the `HasReachedEnd` property is checked before accessing `Position` which will throw.  It seems like `HasReachedEnd` checks both the fields mentioned, but will only treat it as true if greater, perhaps it should have been greater or equal?",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOfQSI9Q==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc58_el_",
                                           "createdAt":  "2024-05-06T22:13:18Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-formats-tar\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2024-05-06T22:13:18Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc59BIj1",
                                           "createdAt":  "2024-05-07T05:00:29Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tmds",
                                           "body":  "This code determines how much of the superstream was read through the `SubReadStream` by calling the `Position` property. That getter throws ODE because the `SubReadStream` got disposed:\r\n\r\nhttps://github.com/dotnet/runtime/blob/7dc3669ebebcc406b327bbaceae2a300a8b66bd3/src/libraries/System.Formats.Tar/src/System/Formats/Tar/TarReader.cs#L226-L233",
                                           "updatedAt":  "2024-05-07T05:00:29Z"
                                       }
                                   ],
                         "totalCount":  2
                     },
        "title":  "Disposing TarEntry.DataStream causes TarReader.GetNextEntry to throw ObjectDisposedException",
        "labels":  [
                       "area-System.Formats.Tar"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/117455",
        "createdAt":  "2025-07-09T07:37:57Z",
        "number":  117455,
        "author":  "tmds",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-08-12T06:58:12Z",
        "body":  "I noticed this while working on https://github.com/dotnet/runtime/pull/117410:\n\nhttps://github.com/dotnet/runtime/blob/513ff1acc981118e4b981e965dce614c3b8770f5/src/libraries/System.Formats.Tar/src/System/Formats/Tar/TarHeader.Read.cs#L372-L377\n\nThere\u0027s no reason to treat zero separate from any other checksum value.\nI think this code should be removed.\n\n@ericstj @dotnet/area-system-formats-tar wdyt?",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOvWvKgw==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc614tYh",
                                           "createdAt":  "2025-07-09T07:44:56Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tmds",
                                           "body":  "Separate issue/question:\n\nI don\u0027t find code that verifies the checksum has the expected value for the header that is read. Is this missing?",
                                           "updatedAt":  "2025-07-09T07:44:56Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc61438v",
                                           "createdAt":  "2025-07-09T07:59:38Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-formats-tar\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2025-07-09T07:59:38Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc61-1aY",
                                           "createdAt":  "2025-07-09T15:48:09Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ericstj",
                                           "body":  "Seems to me like it\u0027s just a fast-path to avoid work when the header is known to be empty.  If it\u0027s not causing any observable bug then I would leave it.\n\nAre you thinking of a case where the checksum is 0 and the header is *not* empty?  Could we craft such a case to prove we have a bug?\n\n(PS: please assign a milestone when removing `untriaged` - milestone should be where we want to take action.  In this case since a bug here would mean data corruption I\u0027ve assigned 10.0.0)",
                                           "updatedAt":  "2025-07-09T15:49:58Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc61_Bxz",
                                           "createdAt":  "2025-07-09T16:01:41Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEaH-rA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "elgonzo",
                                                                               "createdAt":  "2025-07-09T18:17:24Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "ericstj",
                                                                               "createdAt":  "2025-07-10T17:12:07Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "tmds",
                                           "body":  "\u003e Seems to me like it\u0027s just a fast-path to avoid work when the header is known to be empty.\n\nIt doesn\u0027t look like that. On a checksum that has a value zero it returns as if there is no entry to be read.\n\nI think the expected behavior is to check the checksum is correct and throw `InvalidDataException` if it isn\u0027t.\nCurrently, the checksum is never checked.",
                                           "updatedAt":  "2025-07-09T16:01:41Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc62RaKQ",
                                           "createdAt":  "2025-07-10T15:49:14Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "am11",
                                           "body":  "\u003e I think the expected behavior is to check the checksum is correct and throw `InvalidDataException` if it isn\u0027t.\n\nDo other tools (`tar(1)`, 7zip etc.) allow invalid checksum during extraction; warn-and-continue behavior? If so, would be nice to add a bail-out switch for lenient extraction.",
                                           "updatedAt":  "2025-07-10T15:49:14Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc62Rt1M",
                                           "createdAt":  "2025-07-10T16:14:36Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tmds",
                                           "body":  "`tar` has no options to ignore invalid checksums.\n\nIf the checksum is incorrect, do you want to assume the size is correct to move to the next entry.\nI\u0027m not sure this is a use-case the `TarReader` should try to support.",
                                           "updatedAt":  "2025-07-10T16:14:36Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc62eZqe",
                                           "createdAt":  "2025-07-11T09:14:31Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEbM07A==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "jeffhandley",
                                                                               "createdAt":  "2025-07-20T05:16:43Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "tmds",
                                           "body":  "I won\u0027t have time to work on this till mid/end of August. If the issue is still open then, I\u0027ll pick it up.",
                                           "updatedAt":  "2025-07-11T09:14:31Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc62e6SO",
                                           "createdAt":  "2025-07-11T09:46:12Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEbWoMQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "ericstj",
                                                                               "createdAt":  "2025-07-21T20:49:03Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "am11",
                                           "body":  "\u003e `tar` has no options to ignore invalid checksums.\n\nOk, and `tar` errors out on invalid checksum by default and doesn\u0027t extract the archive with just a warning? Then it makes sense to always throw for invalid checksum here as well. Looking at the past issues related to this namespace, most folks want to match existing tools\u0027 behavior as producer of tar is rarely in user\u0027s control.",
                                           "updatedAt":  "2025-07-11T09:47:54Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc69ODq_",
                                           "createdAt":  "2025-08-11T12:35:13Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "rzikm",
                                           "body":  "I tried to add checksum checking in https://github.com/dotnet/runtime/pull/118577, but there are failing tests (some tests expect us to pass on invalid checksums). Also, if we go ahead with this, there would be no way to ignore the checksum mismatches, which can potentially break some users. @ericstj do you think we should proceed with the change?",
                                           "updatedAt":  "2025-08-12T06:47:40Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc69S2Mi",
                                           "createdAt":  "2025-08-11T16:39:11Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ericstj",
                                           "body":  "I\u0027m reluctant to take any change here unless there is real customer impact.  I think @tmds noticed this through code inspection and felt it was necessary follow up from other changes that were made.\n\nIf fixing this introduces new failure points without fixing any customer-impacting bug, then I\u0027d suggest we move it to next release or even wont-fix  it.  We try to be as compatible as possible with file formats that may have come from many different clients, while still being spec compliant.  I\u0027m not hearing a super strong argument for spec compliance here, but if there is one then that could drive a fix-in-net11 vs wont-fix decision.",
                                           "updatedAt":  "2025-08-11T16:39:11Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc69UpIz",
                                           "createdAt":  "2025-08-11T18:31:17Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tmds",
                                           "body":  "The behavior of GNU `tar` is to skip to the next entry and try and extract that. The error code of the `tar` command will be non-zero when there is an incorrect checksum.\n\nAn incorrect checksum indicates a corruption in the tar file.\n\nImo checksums should be checked by default.",
                                           "updatedAt":  "2025-08-11T18:31:17Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc69a8qD",
                                           "createdAt":  "2025-08-12T06:58:05Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "rzikm",
                                           "body":  "\u003e Imo checksums should be checked by default.\n\nI agree, but I am reluctant to introduce this change this late in .NET 10 cycle. If we want to do it in 10, then I would err on the side of caution and add an app context switch to escape to previous behavior.\n\n\u003e I\u0027m not hearing a super strong argument for spec compliance here, but if there is one then that could drive a fix-in-net11 vs wont-fix decision.\n\nI agree with moving this to next release for now. And maybe we can figure out some reasonable API change that would allow users ignore checksum failures (at their own peril).\n\n",
                                           "updatedAt":  "2025-08-12T06:58:05Z"
                                       }
                                   ],
                         "totalCount":  12
                     },
        "title":  "Tar reader checksum checking",
        "labels":  [
                       "discussion",
                       "area-System.Formats.Tar"
                   ]
    }
]
