[
    {
        "url":  "https://github.com/dotnet/runtime/issues/21617",
        "createdAt":  "2017-05-10T14:13:31Z",
        "number":  21617,
        "author":  "stephentoub",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOCuDYoQ==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "benaadams",
                                            "createdAt":  "2017-05-10T15:27:13Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Drawaes",
                                            "createdAt":  "2017-11-20T01:39:16Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "strangeman375",
                                            "createdAt":  "2020-02-25T16:08:43Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "pentp",
                                            "createdAt":  "2020-06-05T17:32:15Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "escalonn",
                                            "createdAt":  "2020-09-14T16:37:33Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "AmrAlSayed0",
                                            "createdAt":  "2021-12-31T18:30:56Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "halter73",
                                            "createdAt":  "2023-01-24T21:24:40Z"
                                        }
                                    ],
                          "totalCount":  7
                      },
        "updatedAt":  "2023-06-06T03:30:05Z",
        "body":  "Task currently exposes two When helpers: WhenAll and WhenAny.  These are the most commonly needed combinators, but there\u0027s another that\u0027s quite helpful, especially in tests: a combinatory that asynchronously waits for either all of the tasks to complete successfully or for the first one that doesn\u0027t complete successfully.  This is particularly valuable when writing tests that involve related asynchronous operations, such as in networking, for example where you want to have an asynchronous client operation (e.g. socket.ConnectAsync) and an asynchronous server operation (e.g. socket.AcceptAsync) that are directly dependent on each other... using WhenAll can lead to deadlocks if one of those operations fails causing the other to wait forever.\r\n\r\nProposal:\r\n```C#\r\npublic class Task\r\n{\r\n    public static Task WhenAllSuccessfulOrAnyFailed(params Task[] tasks);\r\n    public static Task WhenAllSuccessfulOrAnyFailed(IEnumerable\u003cTask\u003e tasks);\r\n    ...\r\n}\r\n```\r\n\r\nFrom a behavioral standpoint, it would be as if code like this were used:\r\n```C#\r\nvar remaining = new List\u003cTask\u003e(tasks);\r\nwhile (remaining.Count \u003e 0)\r\n{\r\n    Task t = await Task.WhenAny(remaining).ConfigureAwait(false);\r\n    remaining.Remove(t);\r\n    t.GetAwaiter().GetResult();\r\n}\r\n```\r\nbut with a more efficient implementation.\r\n\r\nI\u0027m not sure I love the name either, but I\u0027m sure we can come up with something.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOU76Saw==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDMwMDUyNzcyMQ==",
                                           "createdAt":  "2017-05-10T15:53:56Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOA8ez2Q==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "strangeman375",
                                                                               "createdAt":  "2020-02-25T16:09:07Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "benaadams",
                                           "body":  "Alternative suggestion for completeness \r\n```csharp\r\npublic class Task\r\n{\r\n    public static Task When(TaskStatus all, TaskStatus any, params Task[] tasks);\r\n    public static Task When(TaskStatus all, TaskStatus any, IEnumerable\u003cTask\u003e tasks);\r\n    ...\r\n}\r\n```\r\n\r\n```csharp\r\nawait Task.When(TaskStatus.RanToCompletion, TaskStatus.Faulted, remaining).ConfigureAwait(false);\r\n```\r\n\r\nWith common wrapper for AllSuccessful+AnyFailed (with better name 😉 )",
                                           "updatedAt":  "2017-05-10T15:53:56Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDMwMDU0NTc1MQ==",
                                           "createdAt":  "2017-05-10T16:55:57Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "omariom",
                                           "body":  "Wouldn\u0027t it be it more extensible  with a enum parameter?",
                                           "updatedAt":  "2017-05-10T16:55:57Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDMwMDU0NzE5MQ==",
                                           "createdAt":  "2017-05-10T17:01:25Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e Wouldn\u0027t it be it more extensible with a enum parameter?\r\n\r\nHow is that different from Ben\u0027s proposal?",
                                           "updatedAt":  "2017-05-10T17:01:25Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDMwMDU1MDQwNA==",
                                           "createdAt":  "2017-05-10T17:12:39Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "omariom",
                                           "body":  "I thought about a single param of a new enum.\r\nBen\u0027s proposal is more powerful and more difficult to understand.\r\n",
                                           "updatedAt":  "2017-05-10T17:12:39Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5TmO3K",
                                           "createdAt":  "2023-01-24T19:59:07Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "terrajobst",
                                           "body":  "[Video](https://www.youtube.com/watch?v=3rhPF0C_Z7o\u0026t=1h40m25s)\n\n@stephentoub wants to think about the naming and shape a bit more.\r\n\r\n```C#\r\npublic partial class Task\r\n{\r\n    public static Task WhenAllSuccessfulOrAnyFailed(params Task[] tasks);\r\n    public static Task WhenAllSuccessfulOrAnyFailed(IEnumerable\u003cTask\u003e tasks);\r\n}\r\n```",
                                           "updatedAt":  "2023-01-24T20:03:25Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Tu7G1",
                                           "createdAt":  "2023-01-26T10:27:40Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "egil",
                                           "body":  "I recently asked about something like this on [Twitter](https://twitter.com/egilhansen/status/1609892964590919683) and one of your colleagues pointed to an [existing implementation in this repository](https://github.com/dotnet/runtime/blob/2619d1c8eeef4a881c3910c87c1a8903ed742c24/src/libraries/Common/tests/System/Threading/Tasks/TaskTimeoutExtensions.cs#L60).\r\n\r\nI like the name they use, `WhenAllOrAnyFailed`, since it nicely combines the name of the two existing helper methods that are already well-understood in the community. I do not think it\u0027s necessary to include the word \"successful\" as it seems implied by the \"OrAnyFailed\" part.\r\n\r\nHere is my variation of implementation from this repo for reference:\r\n\r\n```C#\r\npublic static Task WhenAllOrAnyFailed(params Task[] tasks)\r\n{\r\n    if (tasks.Length == 0)\r\n    {\r\n        return Task.CompletedTask;\r\n    }\r\n\r\n    var remaining = tasks.Length;\r\n    var tcs = new TaskCompletionSource();\r\n\r\n    foreach (var task in tasks)\r\n    {\r\n        task.ContinueWith(\r\n            a =\u003e\r\n            {\r\n                if (GetRealException(a) is Exception e)\r\n                {\r\n                    tcs.TrySetException(e);\r\n                }\r\n                else if (Interlocked.Decrement(ref remaining) == 0)\r\n                {\r\n                    tcs.TrySetResult();\r\n                }\r\n            },\r\n            CancellationToken.None,\r\n            TaskContinuationOptions.None,\r\n            TaskScheduler.Default);\r\n    }\r\n\r\n    return tcs.Task;\r\n\r\n    // Gets the exception (if any) from the Task, for both faulted and canceled tasks\r\n    static Exception? GetRealException(Task task)\r\n    {\r\n        try\r\n        {\r\n            task.GetAwaiter().GetResult();\r\n        }\r\n        catch (Exception e)\r\n        {\r\n            return e;\r\n        }\r\n\r\n        return null;\r\n    }\r\n}\r\n```",
                                           "updatedAt":  "2023-01-26T10:27:40Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5TvR-I",
                                           "createdAt":  "2023-01-26T12:00:12Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "theodorzoulias",
                                           "body":  "@egil be aware that in case one of the tasks fails, the `WhenAllOrAnyFailed` task will complete with failure without detaching the `ContinueWith` continuations that have been attached to the incomplete tasks. This can be a problem in case the `WhenAllOrAnyFailed` is called repeatedly in a loop for the same set of tasks. To fix this you could use a `CancellationTokenSource`, and cancel the continuations when a task fails.",
                                           "updatedAt":  "2023-01-26T12:00:12Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5TvpJr",
                                           "createdAt":  "2023-01-26T13:19:42Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "egil",
                                           "body":  "\u003e @egil be aware that in case one of the tasks fails, the `WhenAllOrAnyFailed` task will complete with failure without detaching the `ContinueWith` continuations that have been attached to the incomplete tasks. This can be a problem in case the `WhenAllOrAnyFailed` is called repeatedly in a loop for the same set of tasks. To fix this you could use a `CancellationTokenSource`, and cancel the continuations when a task fails.\n\nGood point. I actually do that in the code that calls it, but it\u0027s better to make that part of the `WhenAllOrAnyFailed` itself.",
                                           "updatedAt":  "2023-01-26T13:19:42Z"
                                       }
                                   ],
                         "totalCount":  8
                     },
        "title":  "Proposal: Task.WhenAllSuccessfulOrAnyFailed",
        "labels":  [
                       "api-needs-work",
                       "area-System.Threading.Tasks"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/26565",
        "createdAt":  "2018-06-21T18:35:22Z",
        "number":  26565,
        "author":  "alandoherty",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-07-14T18:13:17Z",
        "body":  "I\u0027ve had to fix numerous problems in my projects using `BufferBlock\u003cT\u003e` leaking memory, I can\u0027t tell if this is by design or if it\u0027s actually unintended behaviour. Creating a `BufferBlock\u003cT\u003e` without completing it seems to leak both memory and scheduled tasks slowly grinding the application to a halt.\r\n\r\nQuick example to trigger problem, results in memory leak:\r\n\r\n```csharp\r\nclass Program\r\n{\r\n    static void Main(string[] args)\r\n    {\r\n        int gcStep = 0;\r\n        \r\n        while(true) {\r\n            BufferBlock\u003cTest\u003e test = new BufferBlock\u003cTest\u003e();\r\n            gcStep++;\r\n\r\n            if (gcStep % 1000 == 0)\r\n                GC.Collect(GC.MaxGeneration, GCCollectionMode.Forced, true);\r\n        }\r\n    }\r\n}\r\n\r\nclass Test { }\r\n```\r\n\r\nQuick example to remedy problem:\r\n\r\n```csharp\r\nclass Program\r\n{\r\n    static void Main(string[] args)\r\n    {\r\n        int gcStep = 0;\r\n        \r\n        while(true) {\r\n            BufferBlock\u003cTest\u003e test = new BufferBlock\u003cTest\u003e();\r\n            test.Complete();\r\n            gcStep++;\r\n\r\n            if (gcStep % 1000 == 0)\r\n                GC.Collect(GC.MaxGeneration, GCCollectionMode.Forced, true);\r\n        }\r\n    }\r\n}\r\n\r\nclass Test { }\r\n```\r\n\r\nIt\u0027s not obvious in the documentation that this occurs, and seems like a really easy mistake that can have drastic effects on async performance and memory. My guess is that the Task is keeping the `BufferBlock\u003cT\u003e` reference alive.\r\n\r\nThe task which is leaked for every buffer block:\r\n\r\n```\r\nNot Flagged\t\t68006\tScheduled\t[Scheduled and waiting to run]\tTask.ContinueWith: \u003c.ctor\u003eb__7_2\r\n```",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOZAGVWA==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDM5OTI3MDYwMQ==",
                                           "createdAt":  "2018-06-21T23:05:19Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Clockwork-Muse",
                                           "body":  "...what makes you think that BufferBlock is leaking anything, Task or otherwise?\r\n",
                                           "updatedAt":  "2018-06-21T23:05:19Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDM5OTI3MTU2OQ==",
                                           "createdAt":  "2018-06-21T23:11:11Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "alandoherty",
                                           "body":  "I stripped the application down to just that code, I\u0027ve found this to be a problem in some of my other code but it occurs even when I call BufferBlock\u003cTest\u003e constructor with nothing else (in .NET Console App project). I find that this problem leaks memory and tasks as shown below. It is resolved if you call `Complete` however.\r\n\r\nMy best theory is that the `Completion` task is never completed, so stays in memory forever and holds a reference to the `BufferBlock\u003cT\u003e`.\r\n\r\n![image](https://user-images.githubusercontent.com/2723639/41749778-56a2f682-75b0-11e8-8331-8b1b2efba59d.png)\r\n\r\n![image](https://user-images.githubusercontent.com/2723639/41749854-c305ff36-75b0-11e8-8031-47cd4a3e422e.png)\r\n\r\n![image](https://user-images.githubusercontent.com/2723639/41749888-ec096346-75b0-11e8-8902-095fd2e437a1.png)\r\n",
                                           "updatedAt":  "2018-06-21T23:34:24Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDM5OTI3Njg4OQ==",
                                           "createdAt":  "2018-06-21T23:43:54Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "svick",
                                           "body":  "When I run your code using the `dotnet` command line on .Net Core 2.1 or .Net Framework 4.7.2 and System.Threading.Tasks.Dataflow 4.9.0 on Windows 10, I don\u0027t see the behavior you\u0027re describing: memory usage according to Task Manager stays stable at few megabytes.\r\n\r\nThe only thing I can think of: are you using a recent version of the System.Threading.Tasks.Dataflow package (and *not* the deprecated Microsoft.Tpl.Dataflow package)?\r\n\r\nAlso, is there anything special about your setup?",
                                           "updatedAt":  "2018-06-21T23:44:47Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDM5OTI4MDIyMg==",
                                           "createdAt":  "2018-06-22T00:05:00Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "alandoherty",
                                           "body":  "I\u0027m using .NET Core 2.0 currently, let me try 2.1 and see if that fixes the issue. I\u0027m using the `System.Threading.Tasks.Dataflow` package, and there isn\u0027t anything special about my setup. I\u0027ve found this issue to occur on Linux as well.",
                                           "updatedAt":  "2018-06-22T00:05:00Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDM5OTI4NDc0MQ==",
                                           "createdAt":  "2018-06-22T00:34:02Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "alandoherty",
                                           "body":  "Just tested and it doesn\u0027t occur with `dotnet` but it does occur when running from Visual Studio 2017 and .NET Core 2.0/2.1 with both Debug or Release configurations. ",
                                           "updatedAt":  "2018-06-22T00:46:36Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDM5OTI4ODY4OQ==",
                                           "createdAt":  "2018-06-22T01:02:40Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e it does occur when running from Visual Studio 2017 and .NET Core 2.0/2.1 with both Debug or Release configurations\r\n\r\nF5 or ctrl-F5? i.e. with the debugger attached or not?",
                                           "updatedAt":  "2018-06-22T01:02:40Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDM5OTI4OTIyNQ==",
                                           "createdAt":  "2018-06-22T01:06:22Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "alandoherty",
                                           "body":  "Only with the debugger attached it seems.",
                                           "updatedAt":  "2018-06-22T01:06:22Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDM5OTI4OTgyNg==",
                                           "createdAt":  "2018-06-22T01:10:29Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "When the debugger is attached (or, more specifically, when the Task ETW-based debugging is enabled by Visual Studio), Tasks are tracked in a static table and kept alive until they\u0027re completed, e.g.\r\nhttps://github.com/dotnet/coreclr/blob/7196a7f62ba4047ddd51523cc4a253ba44201033/src/System.Private.CoreLib/src/System/Threading/Tasks/TaskContinuation.cs#L304-L307\r\nhttps://github.com/dotnet/coreclr/blob/7196a7f62ba4047ddd51523cc4a253ba44201033/src/System.Private.CoreLib/src/System/Threading/Tasks/Task.cs#L201-L203",
                                           "updatedAt":  "2018-06-22T01:11:52Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDM5OTI5MDMwNA==",
                                           "createdAt":  "2018-06-22T01:13:42Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "alandoherty",
                                           "body":  "Is there any way to disable this behaviour? Or mitigate rouge libraries from creating tasks which never complete? It makes it quite difficult to debug memory/performance issues since it adds noise when you specifically are aiming to look for those sorts of issues.",
                                           "updatedAt":  "2018-06-22T01:13:42Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDM5OTI5MTIyNA==",
                                           "createdAt":  "2018-06-22T01:19:24Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e Is there any way to disable this behaviour?\r\n\r\nI don\u0027t know if there\u0027s a way to disable the debugger turning on those async causality events.  @gregg-miskelly, do you know?",
                                           "updatedAt":  "2018-06-22T01:19:24Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDM5OTQ2ODIxOQ==",
                                           "createdAt":  "2018-06-22T14:48:08Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "svick",
                                           "body":  "@stephentoub Would it make sense to track them using weak pointers (or a similar approach) instead? That way, abandoned tasks could be GCed.",
                                           "updatedAt":  "2018-06-22T14:48:08Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDM5OTQ5NzYwOA==",
                                           "createdAt":  "2018-06-22T16:16:39Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Clockwork-Muse",
                                           "body":  "\u003e Or mitigate rouge libraries from creating tasks which never complete?\r\n\r\nUm, no.  You\u0027re asking to solve the [halting problem](https://en.wikipedia.org/wiki/Halting_problem).\r\nYou could probably clean up abandoned tasks that aren\u0027t started yet (cannot do work), or abandoned and running that don\u0027t have external references or modify no outside-the-task-state (no visible effect) - the behavior of the program suggests that at least the first is being performed.",
                                           "updatedAt":  "2018-06-22T16:16:39Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDM5OTUwMzc3NA==",
                                           "createdAt":  "2018-06-22T16:34:57Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Clockwork-Muse",
                                           "body":  "@svick - to me it sounds like the goal was to prevent them just immediately being GC\u0027d, so you could track down where they came from, because creating a large number of abandoned tasks would normally be considered a programmer error.\r\n\r\n@alandoherty - Is the code you\u0027re working on really creating a block in a tight loop like that?  And normally you are expected to call `Complete` (and allow it to clean up), so you should at least be doing that.",
                                           "updatedAt":  "2018-06-22T16:34:57Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDM5OTUyMzAwNw==",
                                           "createdAt":  "2018-06-22T17:44:03Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e Would it make sense to track them using weak pointers (or a similar approach) instead? That way, abandoned tasks could be GCed.\r\n\r\nTo answer that I will need to go back and review what purpose the static table serves; I don\u0027t remember at this point.",
                                           "updatedAt":  "2018-06-22T17:44:03Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDM5OTUyNDc2Ng==",
                                           "createdAt":  "2018-06-22T17:50:39Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "alandoherty",
                                           "body":  "I think there\u0027s a couple of problems here, firstly it\u0027s really not obvious at all in the documentation for `BufferBlock\u003cT\u003e` that you must Complete the block. I got the idea that it would be safe to discard unused blocks without completing, especially since it\u0027s offered in some places as a asynchronous concurrent queue.\r\n\r\nAlso it was my understanding that it was good practice to always complete tasks eventually, so perhaps the weak reference and auto completion of the task would be an idea? And it would be nice if there was a way to turn off this static table, so that you can prevent uncompleted tasks from causing issues during debugging for other issues.",
                                           "updatedAt":  "2018-06-22T17:50:39Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDM5OTUzNjc1Mg==",
                                           "createdAt":  "2018-06-22T18:27:35Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Clockwork-Muse",
                                           "body":  "\u003e I think there\u0027s a couple of problems here, firstly it\u0027s really not obvious at all in the documentation for BufferBlock\u003cT\u003e that you must Complete the block. I got the idea that it would be safe to discard unused blocks without completing, especially since it\u0027s offered in some places as a asynchronous concurrent queue.\r\n\r\nYes, it would probably be good to update the documentation to mention that.  It\u0027s not really \"unsafe\" to leave them uncompleted, but it is a good idea: If you don\u0027t mark it complete, consumers aren\u0027t going know they can finish (or producers might keep trying to add things).\r\n\r\n\u003eAlso it was my understanding that it was good practice to always complete tasks eventually, so perhaps the weak reference and auto completion of the task would be an idea? And it would be nice if there was a way to turn off this static table, so that you can prevent uncompleted tasks from causing issues during debugging for other issues.\r\n\r\nSure, `BufferBlock` will complete the task... if you call `Complete()`.  There\u0027s no other way for it to know that it **can**.  Until you call that method, it\u0027s possible to add additional processing items (note that the task won\u0027t necessarily complete immediately - it hangs around until everything has been processed).  It also can\u0027t auto-complete the task, because (I think) the real task is part of the completion process, so auto-completing it would interfere with real use.\r\n\r\n\r\n",
                                           "updatedAt":  "2018-06-22T18:27:35Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDM5OTgxMDYyMw==",
                                           "createdAt":  "2018-06-25T02:06:32Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "@gregg-miskelly, does VS still use the private Task.GetActiveTaskFromId method (https://github.com/dotnet/coreclr/blob/0fbd855e38bc3ec269479b5f6bf561dcfd67cbb6/src/System.Private.CoreLib/src/System/Threading/Tasks/Task.cs#L6189)?  What would the impact be if we were to remove it?  Or, what would the impact be if VS passed in the id of a Task that would have otherwise been garbage collected by then?",
                                           "updatedAt":  "2018-06-25T02:06:59Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQwMDAzNDgxOA==",
                                           "createdAt":  "2018-06-25T17:39:13Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "gregg-miskelly",
                                           "body":  "CC @r-ramesh\r\n\r\nFrom reading the code what would happen is that VS will have a row in the tasks window that has whatever original name the task had (from the ETW event) and no location. We might want a new ETW event to notify that a uncompleted task was GC\u0027ed?\r\n\r\nTo answer your question from Friday - no, we don\u0027t have a knob to prevent setting s_asyncDebuggingEnabled.\r\n",
                                           "updatedAt":  "2018-06-25T17:39:13Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQwMDAzNjA0MA==",
                                           "createdAt":  "2018-06-25T17:43:25Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e We might want a new ETW event to notify that a uncompleted task was GC\u0027ed?\r\n\r\nI don\u0027t think we can do that. This would be *super* expensive, as Task would need a finalizer, and even if we GC.SuppressFinalize\u0027d it if the ETW event wasn\u0027t enabled, there\u0027s still measurable cost there. In .NET Core 2.1 we added something similar for async methods, but there the runtime controls the instantiation of the async method boxing object, and thus if events are enabled, it can choose to construct one that has a finalizer, whereas the one normally constructed won\u0027t.\r\nhttps://github.com/dotnet/coreclr/blob/df78ae72d5cf3f2c2dbe4ff972732d418497f9bc/src/System.Private.CoreLib/src/System/Runtime/CompilerServices/AsyncMethodBuilder.cs#L505-L514",
                                           "updatedAt":  "2018-06-25T17:43:25Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQwMDA0Njg0Mw==",
                                           "createdAt":  "2018-06-25T18:18:15Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "gregg-miskelly",
                                           "body":  "Perhaps we could solve it by better handling a `null` result from `Task.GetActiveTaskFromId` to understand that the task has been collected...",
                                           "updatedAt":  "2018-06-25T18:20:30Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQwMDkwMTIzMA==",
                                           "createdAt":  "2018-06-28T03:41:42Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e Perhaps we could solve it by better handling a null result from Task.GetActiveTaskFromId to understand that the task has been collected\r\n\r\nIf that\u0027s feasible, then we could change it to use a weak collection.\r\n\r\nIs it?",
                                           "updatedAt":  "2018-06-28T03:41:42Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQwMTA5MzQ2Nw==",
                                           "createdAt":  "2018-06-28T16:25:33Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOBsGYrw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "alandoherty",
                                                                               "createdAt":  "2018-06-29T13:33:03Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "markusschaber",
                                                                               "createdAt":  "2021-05-25T12:56:12Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "gregg-miskelly",
                                           "body":  "As long as we are okay with breaking older debuggers (.NET Core 3?) I don\u0027t see any reason why we can\u0027t improve this.\r\n\r\nDo you think the right experience is that collected tasks should disappear from the tasks window? Or is this a bug that we should be alerting users to?\r\n\r\nThere is a comment in our code about getting null back for \u0027async void\u0027 methods. Does that make sense to you? (in other words - do async void methods get a task id)\r\n\r\nThe debugger interprets GetActiveTaskFromId, so if we switch to some sort of weak collection we will likely need to enhance either VIL and/or ICorDebug to be able to decode the weak collection.\r\n\r\nIf async void methods get a task id, I might suggest making s_currentActiveTasks a `Dictionary\u003cint, WeakReference\u003cTask\u003e\u003e` and throw an exception in the collected case so that a debugger can differentiate the two cases. Otherwise we could just return null in that case.",
                                           "updatedAt":  "2018-06-28T16:25:33Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg0Nzk3MDAwNw==",
                                           "createdAt":  "2021-05-25T15:27:24Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "markusschaber",
                                           "body":  "As the latest comment on this is from 2018, and I\u0027ve just spent some hours debugging such \"Heisen-Leaks\", I wanted to ask what the current state of this issue is.\r\n\r\n(Why \"Heisen-Leaks\": The leaks in question did not happen on my machine, but on the coworkers machine when he tried to test my fixes for some other leaks. Turned out I\u0027ve been using JetBrains DotMemory, and the \"private bytes\" view of SysInternals Process explorer, while my coworker just pressed F5 in VS 2019 and used the VS Diagnostic tools, so he still found leaks which I could not reproduce.)",
                                           "updatedAt":  "2021-08-16T15:02:53Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5TZ-53",
                                           "createdAt":  "2023-01-21T19:46:09Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "Going through old issues. I\u0027d like us to address this for .NET 8.  Sorry for the super long delay here... I lost track of this issue.\r\n\r\n\u003e Do you think the right experience is that collected tasks should disappear from the tasks window? Or is this a bug that we should be alerting users to?\r\n\r\nThey shouldn\u0027t show up as active in the Tasks window.  Easiest thing is for them to just disappear, but there is likely a value-add for them showing up ala \"oops, something here is a miss that would benefit from investigation\".\r\n\r\n\u003e There is a comment in our code about getting null back for \u0027async void\u0027 methods. Does that make sense to you? (in other words - do async void methods get a task id)\r\n\r\nIt likely used to make sense, but since .NET Core 2.0 or so, I\u0027d expect async void methods to have an associated task.  It\u0027s an implementation detail, though.\r\n\r\n\u003e The debugger interprets GetActiveTaskFromId, so if we switch to some sort of weak collection we will likely need to enhance either VIL and/or ICorDebug to be able to decode the weak collection.\r\n\r\nCan you point to what would need to change where?",
                                           "updatedAt":  "2023-01-21T19:46:09Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5kAY7N",
                                           "createdAt":  "2023-08-14T18:01:08Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "@stephentoub, are you fine with this being future again? We\u0027re very unlikely to complete the work for .NET 8 at this point.",
                                           "updatedAt":  "2023-08-14T18:01:08Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5kAZVY",
                                           "createdAt":  "2023-08-14T18:02:18Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "Yes. We need to tackle this earlier in a release.",
                                           "updatedAt":  "2023-08-14T18:02:18Z"
                                       }
                                   ],
                         "totalCount":  26
                     },
        "title":  "Use weak table for storing active tasks with debugger attached",
        "labels":  [
                       "bug",
                       "area-System.Threading.Tasks",
                       "tenet-performance"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/29593",
        "createdAt":  "2019-05-17T17:42:52Z",
        "number":  29593,
        "author":  "ReubenBond",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOCPfQxQ==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "JeffCyr",
                                            "createdAt":  "2019-05-17T19:35:07Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "veikkoeeva",
                                            "createdAt":  "2019-05-18T06:14:23Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "ifle",
                                            "createdAt":  "2019-05-18T18:46:13Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "pinkfloydx33",
                                            "createdAt":  "2019-05-21T09:23:42Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "debmdale",
                                            "createdAt":  "2019-05-21T17:39:12Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "badrishc",
                                            "createdAt":  "2019-07-13T04:59:53Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "drub0y",
                                            "createdAt":  "2019-07-13T05:40:36Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Daniel-Svensson",
                                            "createdAt":  "2019-07-13T06:52:15Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "wanton7",
                                            "createdAt":  "2019-07-13T07:18:15Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "KarenTazayan",
                                            "createdAt":  "2019-07-13T12:43:04Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "jdom",
                                            "createdAt":  "2019-07-23T22:08:44Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "stgolem",
                                            "createdAt":  "2019-08-03T16:24:35Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Aaronontheweb",
                                            "createdAt":  "2020-11-21T18:43:07Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Zoxive",
                                            "createdAt":  "2021-03-07T20:37:34Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "icanhasjonas",
                                            "createdAt":  "2021-03-07T20:55:29Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "jthelin",
                                            "createdAt":  "2021-03-07T21:39:38Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "ShreyasJejurkar",
                                            "createdAt":  "2021-03-08T07:34:27Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "KSemenenko",
                                            "createdAt":  "2021-03-08T21:05:23Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "pentp",
                                            "createdAt":  "2021-03-08T21:16:46Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "highlyunavailable",
                                            "createdAt":  "2021-03-10T20:14:22Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "artemiusgreat",
                                            "createdAt":  "2022-02-19T15:48:47Z"
                                        }
                                    ],
                          "totalCount":  21
                      },
        "updatedAt":  "2023-01-21T19:51:29Z",
        "body":  "Orleans is one of the (seemingly few) frameworks which makes heavy use of custom `TaskScheduler`s. We use them to implement single-threaded execution for grains (~distributed objects). Each grain has its own [`ActivationTaskScheduler`](https://github.com/dotnet/orleans/blob/f878ea03196b63c9f279b6f72ba754746379bcc8/src/Orleans.Runtime/Scheduler/ActivationTaskScheduler.cs), so there may be 10^5 or 10^6 `TaskScheduler` instances in a process at any one time (on the high end).\r\n\r\n`ActivationTaskScheduler` is a wrapper around `WorkItemGroup`, a collection of work items to execute serially. When a work item (eg, a `Task`) is scheduled, the `WorkItemGroup` itself is scheduled onto a dedicated thread pool for execution. This is very similar to `IThreadPoolWorkItem`, so there\u0027s room for us to support `IThreadPoolWorkItem` and also use the default thread pool in future. EDIT 2021: Those `WorkItemGroup` instances are now scheduled on the `ThreadPool` via `IThreadPoolWorkItem`.\r\n\r\nEach grain sends/receives calls via RPC interfaces. We schedule those messages onto the grain\u0027s `WorkItemGroup`, but we have to wrap these work items in a `Task` so we can maintain single-threadedness in the case that the user\u0027s code doesn\u0027t complete synchronously or kicks off some background work (fire-and-forget style). For example, a `JoinGame(id)` call might contact some other grains and write to storage. This wrapping is not ideal.\r\n\r\nIf we could set \u0026 reset `TaskScheduler.Current` from within our `WorkItemGroup` then we could avoid this wrapping while still being able to have single-threadedness.\r\n\r\nIs exposing a `TaskScheduler.Current` setter a possibility? Failing that, what other options should we consider?\r\n\r\nI recognize potential pitfalls associated with broadly exposing a setter for `TaskScheduler.Current`. If that is a major concern then perhaps we could expose some scary-looking API like `TaskScheduler.UnsafeSetCurrent(TaskScheduler)` or some alternative means to control the ambient scheduler which doesn\u0027t require allocating a task.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOU2fxRQ==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5TZ_FF",
                                           "createdAt":  "2023-01-21T19:50:51Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "In theory I\u0027m not against the idea of a TaskScheduler.SetCurrent.  In practice I\u0027m not sure how it would work, at least not without an overhaul of this area of tasks.  Today TaskScheduler.get_Current is effectively just:\r\n```C#\r\nTask t = Task.CurrentTask; // gets whatever innermost Task is currently executing on this thread\r\nreturn t?.Scheduler ?? TaskScheduler.Default;\r\n```\r\nso there isn\u0027t really a notion of a stored current scheduler like you\u0027d need to implement SetCurrent.  Someone would need to prototype this in corelib to get a sense for the implications... I don\u0027t know if it\u0027d end up being trivial or a rewrite or somewhere in between.",
                                           "updatedAt":  "2023-01-21T19:51:29Z"
                                       }
                                   ],
                         "totalCount":  1
                     },
        "title":  "Allow setting TaskScheduler.Current",
        "labels":  [
                       "api-suggestion",
                       "area-System.Threading.Tasks"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/31315",
        "createdAt":  "2019-10-27T06:05:23Z",
        "number":  31315,
        "author":  "davidfowl",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHODHAh6A==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "MaceWindu",
                                            "createdAt":  "2021-02-26T10:23:52Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "DaveSenn",
                                            "createdAt":  "2021-04-15T21:38:45Z"
                                        },
                                        {
                                            "content":  "HEART",
                                            "user":  "DaveSenn",
                                            "createdAt":  "2021-04-15T21:38:58Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "kronic",
                                            "createdAt":  "2021-05-24T21:45:55Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "norvegec",
                                            "createdAt":  "2021-08-18T18:33:21Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "neilrees",
                                            "createdAt":  "2021-12-06T14:34:40Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "queil",
                                            "createdAt":  "2022-01-15T14:03:07Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "tylermichael",
                                            "createdAt":  "2022-01-26T19:20:39Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Fresa",
                                            "createdAt":  "2022-01-27T12:40:05Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "cyungmann",
                                            "createdAt":  "2022-04-13T18:32:04Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Sibusten",
                                            "createdAt":  "2022-06-16T15:45:05Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "khayes",
                                            "createdAt":  "2022-06-22T10:50:37Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "alienwareone",
                                            "createdAt":  "2022-07-25T09:05:32Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "siawkz",
                                            "createdAt":  "2022-08-10T01:20:16Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "General-Fault",
                                            "createdAt":  "2022-11-07T20:01:16Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "kirsan31",
                                            "createdAt":  "2023-01-21T20:45:25Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "ufcpp",
                                            "createdAt":  "2023-01-24T05:07:48Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "aeb-dev",
                                            "createdAt":  "2023-05-24T05:30:30Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "jholt456",
                                            "createdAt":  "2023-07-26T12:55:05Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "julealgon",
                                            "createdAt":  "2024-07-08T14:27:30Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "iotalambda",
                                            "createdAt":  "2024-07-30T07:20:24Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "picolino",
                                            "createdAt":  "2024-09-12T06:58:12Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "esso23",
                                            "createdAt":  "2024-10-08T18:34:19Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "scabana",
                                            "createdAt":  "2024-12-12T20:26:22Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "aetos382",
                                            "createdAt":  "2024-12-16T08:09:24Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "aco-mreble",
                                            "createdAt":  "2025-07-15T08:20:11Z"
                                        }
                                    ],
                          "totalCount":  26
                      },
        "updatedAt":  "2024-07-05T13:38:18Z",
        "body":  "EDITED by @stephentoub  on 1/21/2023:\r\n\r\nI\u0027ve updated the proposal based on:\r\n- We already have DisposeAsync.\r\n- CancelAsync is covered by https://github.com/dotnet/runtime/issues/23405.\r\n- Since this proposal was made, we added Register methods that pass the CancellationToken to the callback.\r\n- We should have an UnsafeRegister to go along with the Register to avoid ExecutionContext capture, just like we do for the sync overloads.\r\n- We don\u0027t need to add every combination of everything, so I\u0027ve stuck with just a single Register and Unregister... if you don\u0027t like the token being passed in, you can just ignore it.\r\n- I changed the TState back to an object.  Implementation-wise it\u0027d end up adding non-trivial overheads to use TState, and the argument here is almost always a reference type.\r\n- There\u0027s a _big_ issue with these still, which is that the methods need to invoke the callback if cancellation was already requested; as sync methods, they\u0027d need to invoke them and then block on them.  We can make them RegisterAsync, but then there\u0027s still the issue of Cancel calls would need to do sync-over-async to invoke these callbacks.\r\n  \r\n```diff\r\npublic struct CancellationToken\r\n{\r\n+    public CancellationTokenRegistration Register(Func\u003cobject?, CancellationToken, Task\u003e callback, object? state);\r\n+    public CancellationTokenRegistration UnsafeRegister(Func\u003cobject?, CancellationToken, Task\u003e callback, object? state);\r\n}\r\n```\r\n\r\n---\r\n\r\nRelated to https://github.com/dotnet/corefx/issues/23716 but just in general the ability to run asynchronous work in a cancellation token callback is needed.\r\n\r\n```C#\r\npublic partial struct CancellationToken\r\n{\r\n    public CancellationTokenRegistration Register\u003cTState\u003e(Func\u003cTask\u003e callback);\r\n    public CancellationTokenRegistration Register\u003cTState\u003e(Func\u003cTState, Task\u003e callback, TState state);\r\n}\r\n```\r\n\r\n```C#\r\npublic partial struct CancellationToken\r\n{\r\n    public Task CancelAsync();\r\n}\r\n```\r\n\r\n```C#\r\npublic partial struct CancellationTokenRegistration \r\n{\r\n    public ValueTask DisposeAsync();\r\n}\r\n```\r\n\r\nCancelAsync allows the caller to wait asynchronously on the callbacks to fire.\r\n\r\nOpen questions:\r\n- What happens when there\u0027s an async callback registered but the user calls Cancel (this will turn into another gotcha), it\u0027ll result in a sync over async task.Wait() on that callback.\r\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOg8eZww==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU0NjcyMzEwOA==",
                                           "createdAt":  "2019-10-27T18:57:27Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tarekgh",
                                           "body":  "CC @stephentoub ",
                                           "updatedAt":  "2019-10-27T18:57:27Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU0NjkzNjgwOQ==",
                                           "createdAt":  "2019-10-28T13:06:46Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCoEcnw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "GSPP",
                                                                               "createdAt":  "2022-07-22T14:07:20Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e ability to run asynchronous work in a cancellation token callback is needed\r\n\r\nPlease share several example places it would be used.  Otherwise it\u0027s difficult to validate that the designed feature actually meets the need.\r\n\r\n\u003e Open questions\r\n\r\nIn additional to Cancel also presumably needing to wait for async operations to complete, CancellationTokenRegistration.Dispose() must also wait if the registration it\u0027s disposing is for an async callback that\u0027s currently executing.\r\n\r\nThe inverse is also a question: should CancelAsync invoke the synchronous delegates synchronously or should it queue their invocation?\r\n\r\n\u003e bool useSynchronizationContext\r\n\r\nDo we really need this?  It\u0027s a feature I wish we\u0027d never added to CancellationToken, and from what I\u0027ve seen, almost no one sets it to true.  It\u0027s also something that can be done by the caller instead if truly needed.  I\u0027d just assume not add overloads that take it.\r\n\r\n\u003e RegisterAsync(Func\u003cTask\u003e callback);\r\n\r\nThis is an example of why I asked for use cases.  Do we actually expect this overload would be used, or any time we saw its usage in a code review would we be likely to say \"don\u0027t use a closure, pass in the state as the state argument\".\r\n\r\n\u003e RegisterAsync(Func\u003cobject?, Task\u003e callback, object? state);\r\n\r\nI don\u0027t think it should be \"XxAsync\"... the register method isn\u0027t doing any asynchronous work.  It should just be Register that takes a different signature delegate than it takes today.\r\n\r\nAlso, there\u0027s a separate issue open about taking `TState` instead of `object`.  Per my question earlier about the use cases, what kind of state will typically be provided here?  Sticking with \u0027object\u0027 is going to result in a simpler/cheaper implementation, and if the state is already generally a reference type, it won\u0027t add any overhead, plus it\u0027s consistent with the current overloads.  But if some of the common use cases involve boxing value types or involve needing to allocate an object to pass in multiple pieces of state, then we should consider making it TState.",
                                           "updatedAt":  "2019-10-28T13:06:46Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU0NzAyMDEzMA==",
                                           "createdAt":  "2019-10-28T16:08:06Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "davidfowl",
                                           "body":  "\u003e Please share several example places it would be used. Otherwise it\u0027s difficult to validate that the designed feature actually meets the need.\r\n\r\nWhat sort of examples are you looking for? Examples where people are calling .Wait today? Here\u0027s a place where it will be used:\r\n\r\nhttps://github.com/aspnet/Extensions/blob/f00078cf2ccfa878083e8fb11e01fdd1fef1cf7d/src/Hosting/Abstractions/src/IHostApplicationLifetime.cs#L16-L28\r\n\r\nWe would trigger the async verisons of these token callbacks (the code path is already asynchronous).\r\n\r\nhttps://github.com/aspnet/Extensions/blob/f00078cf2ccfa878083e8fb11e01fdd1fef1cf7d/src/Hosting/Hosting/src/Internal/Host.cs#L54\r\n\r\nhttps://github.com/aspnet/Extensions/blob/f00078cf2ccfa878083e8fb11e01fdd1fef1cf7d/src/Hosting/Hosting/src/Internal/Host.cs#L91\r\n\r\nImpl:\r\nhttps://github.com/aspnet/Extensions/blob/f00078cf2ccfa878083e8fb11e01fdd1fef1cf7d/src/Hosting/Hosting/src/Internal/ApplicationLifetime.cs#L112\r\n\r\n\r\n\u003e In additional to Cancel also presumably needing to wait for async operations to complete, CancellationTokenRegistration.Dispose() must also wait if the registration it\u0027s disposing is for an async callback that\u0027s currently executing.\r\n\r\nRight, that would mean `CancellationTokenRegistration` also needs a DisposeAsync?\r\n\r\n\u003e The inverse is also a question: should CancelAsync invoke the synchronous delegates synchronously or should it queue their invocation?\r\n\r\nI think that\u0027s a different feature. An options like it is on TCS. `CancellationTokenOptions.RunCallbacksAsynchronously`\r\n\r\n\u003e Do we really need this? It\u0027s a feature I wish we\u0027d never added to CancellationToken, and from what I\u0027ve seen, almost no one sets it to true. It\u0027s also something that can be done by the caller instead if truly needed. I\u0027d just assume not add overloads that take it.\r\n\r\nNo, it\u0027s for parity. I have no love of this overload 😄 .\r\n\r\n\u003e This is an example of why I asked for use cases. Do we actually expect this overload would be used, or any time we saw its usage in a code review would we be likely to say \"don\u0027t use a closure, pass in the state as the state argument\".\r\n\r\nIt\u0027s easier to keep parity with what is already there rather an arbitrarily remove things because we wouldn\u0027t use it that way. That said, closures are fine, just not in the code that I personally write 😄 .\r\n\r\n\u003e Also, there\u0027s a separate issue open about taking TState instead of object. Per my question earlier about the use cases, what kind of state will typically be provided here? Sticking with \u0027object\u0027 is going to result in a simpler/cheaper implementation, and if the state is already generally a reference type, it won\u0027t add any overhead, plus it\u0027s consistent with the current overloads. But if some of the common use cases involve boxing value types or involve needing to allocate an object to pass in multiple pieces of state, then we should consider making it TState.\r\n\r\nAgreed. We should just make it a rule to use TState from now on in callback APIs, or stop designing callback APIs...",
                                           "updatedAt":  "2019-10-28T16:08:06Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU5MDkzMDQ2MQ==",
                                           "createdAt":  "2020-02-25T15:40:37Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e Right, that would mean CancellationTokenRegistration also needs a DisposeAsync?\r\n\r\nAlready has it:\r\nhttps://github.com/dotnet/runtime/blob/6de3cd306cd052b1b7c5443a220b5d83a18d8c09/src/libraries/System.Private.CoreLib/src/System/Threading/CancellationTokenRegistration.cs#L48",
                                           "updatedAt":  "2020-02-25T15:40:37Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU5MDkzMDg3MQ==",
                                           "createdAt":  "2020-02-25T15:41:23Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "@davidfowl, how important are the Register/CancelAsync overloads for .NET 5?  Are they blocking anything critical?  Nice to have?  Etc.  Thanks.",
                                           "updatedAt":  "2020-02-25T15:41:23Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc46WsOr",
                                           "createdAt":  "2021-11-25T09:35:56Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Rayzbam",
                                           "body":  "Hi,\r\n\r\nI had the same \"issue\" about one case here that, in my opinion, is missing in the current implementation :\r\n\r\n`public CancellationTokenRegistration Register\u003cTState\u003e(Func\u003cTState, Task\u003e callback, TState state);`\r\n\r\nWhy can\u0027t we set a Task delegate ? The callback fired can\u0027t run asynchronously ? If so, can we tell why ?\r\n\r\nThanks",
                                           "updatedAt":  "2021-11-25T09:36:20Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5TaBz2",
                                           "createdAt":  "2023-01-21T21:03:00Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "kirsan31",
                                           "body":  "Please when (if) will work on it, pay attention to these scenarios: https://github.com/dotnet/runtime/issues/23405#issuecomment-905297801",
                                           "updatedAt":  "2023-01-21T21:03:00Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5TfIjY",
                                           "createdAt":  "2023-01-23T16:57:05Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "I just went to prototype this, and immediately hit a problem.  The Register method needs to invoke the callback if cancellation has already been requested.  That means it either needs to:\r\na) Synchronously block waiting for the `Func\u003c..., Task\u003e` to complete.\r\nb) Invoke the delegate as fire-and-forget.\r\nc) Make Register instead be RegisterAsync and return a `ValueTask\u003cCancellationTokenRegistration\u003e`.\r\n\r\n(a) and (b) are bad.\r\n\r\nUnless we can think of a better option than (c), I think that\u0027s the only feasible route.",
                                           "updatedAt":  "2023-01-23T16:57:05Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5TfKX7",
                                           "createdAt":  "2023-01-23T17:02:29Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e Unless we can think of a better option than (c), I think that\u0027s the only feasible route.\r\n\r\n@davidfowl, this goes back to my questions about where this will be used.  Will such a RegisterAsync be usable by ASP.NET in all the places you wanted to use it?",
                                           "updatedAt":  "2023-01-23T17:02:29Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5TfMl9",
                                           "createdAt":  "2023-01-23T17:08:06Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "And the more I plumb this through, the more I\u0027m getting nervous about these async registrations.  As touched on previously, we\u0027re making it really easy here to accidentally do sync-over-async, as Cancel would need to block waiting for any such async registrations to complete.  CancelAsync will enable avoiding that, but the whole design of CancellationToken is based on the separation of the canceler and the cancelee.\r\n\r\nI\u0027m going to move on to instead prototyping CancelAsync; I think that should have fewer issues. While I understand the goal of Register with an async delegate, I\u0027m tempted to scrap it.",
                                           "updatedAt":  "2023-01-23T17:08:06Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Thz2w",
                                           "createdAt":  "2023-01-24T04:12:23Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "davidfowl",
                                           "body":  "Good catch, there are some places that ASP.NET Core could use RegisterAsync but not all. Remind me, what would CancelAsync do without the async callback? ",
                                           "updatedAt":  "2023-01-24T04:12:23Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Th0Ez",
                                           "createdAt":  "2023-01-24T04:13:59Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e Remind me, what would CancelAsync do without the async callback?\r\n\r\nhttps://github.com/dotnet/runtime/compare/main...stephentoub:runtime:cancelasync",
                                           "updatedAt":  "2023-01-24T04:13:59Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Th7T6",
                                           "createdAt":  "2023-01-24T05:07:10Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "davidfowl",
                                           "body":  "Ah yes, the equivalent of RunContinuationsAsynchronously. I still think this is valuable.",
                                           "updatedAt":  "2023-01-24T05:07:10Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6Dx5nD",
                                           "createdAt":  "2024-07-05T13:38:17Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOD918sg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "iotalambda",
                                                                               "createdAt":  "2024-07-30T07:20:17Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "cryocz",
                                                                               "createdAt":  "2024-12-06T09:00:07Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "Rayzbam",
                                           "body":  "Do you have any update on this one ?\r\nWas previously planned for .NET 8, guess it was not unfortunately.\r\nThe main usecase is still the \"IHostApplicationLifetime.ApplicationStopping.Register(...)\" on my side.",
                                           "updatedAt":  "2024-07-05T13:38:17Z"
                                       }
                                   ],
                         "totalCount":  14
                     },
        "title":  "API Proposal: Add Async support CancellationToken/CancellationTokenSource",
        "labels":  [
                       "api-needs-work",
                       "area-System.Threading.Tasks"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/2078",
        "createdAt":  "2020-01-23T14:23:47Z",
        "number":  2078,
        "author":  "ficzerepeti",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2024-01-24T03:58:05Z",
        "body":  "Hi,\r\n\r\nI\u0027ve been migrating a dotnet framework application to dotnet core and during the process I\u0027ve found a possible issue.\r\n\r\nOn dotnet core in case all ThreadPool threads are blocked (waiting for computation to be finished for example) then Parallel.For doesn\u0027t return however it does on framework. In the app I\u0027m working on the maximum ThreadPool thread count is limited to processor count (`ThreadPool.SetMaxThreads(Environment.ProcessorCount, Environment.ProcessorCount);`).\r\n\r\nI\u0027ve been able to reproduce the issue with ~60 lines of code [which you can find here](https://github.com/ficzerepeti/Parallel.For_blocks_on_dotnet_core).\r\n\r\nMy question is: is this the expected behaviour? If yes then how can I get it to work like in framework?\r\n\r\nThanks,\r\nPeter",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOca9JcA==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU3NzcyMDcwMQ==",
                                           "createdAt":  "2020-01-23T15:04:34Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOBc9MKA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "theodorzoulias",
                                                                               "createdAt":  "2021-01-19T18:55:01Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "Thank you for the repro.\r\n\r\nParallel.For works to spread itself over however many threads are available / allowed in the pool by creating a single task.  That task immediately creates and queues a copy of itself and then starts running work for the loop.  If another thread becomes available, that thread picks up the copy, which in turn creates another copy and starts joining in on the processing of the loop.  Etc.  The very first Parallel.For creates doesn\u0027t actually get scheduled to the pool (assuming the TaskScheduler hasn\u0027t been changed to something that works differently); rather, it gets run on the current thread (after all, why block the current thread waiting for another thread to do work when it could just be done by the current thread).  In the case where all of the thread pool threads are blocked, that main thread will end up doing all of the work.  However, it will also have already queued a copy of itself, and it needs to ensure that such a copy won\u0027t actually run, such that everything associated with the Parallel.For invocation will have quiesced by the time the For call returns to its caller.  In .NET Framework, Parallel lives in the same assembly as Task, and has access to its internals; it\u0027s calling an internal method on the replica to cancel it.  In .NET Core, Parallel is a standalone implementation, and that call (or an equivalent) is missing.  That means the Parallel.For in your repro does all the work, but then blocks waiting for the single task it queued to complete; that task is just sitting in the thread pool\u0027s queue, waiting to be picked up by a thread from the pool, but you\u0027ve blocked all threads in the pool until the Parallel.For completes and prohibited the thread pool from injecting more, thereby creating a deadlock.\r\n\r\nThe obvious workaround for you is: don\u0027t do that ;-)  Parallel.For has been implemented like this since the earliest days of .NET Core (well before, actually), so the fact that we\u0027re only learning about this issue now highlights its rarity.\r\n\r\nHowever, it\u0027s still worth looking at fixing the implementation of Parallel.For to be able to cancel the replica tasks it creates.  I\u0027m not sure how easy it will be to do, though.  The \"easy\" fix would likely lead to an exception being thrown and caught on every Parallel.For invocation, which isn\u0027t ideal.  We might need https://github.com/dotnet/corefx/issues/8142 to do this correctly.",
                                           "updatedAt":  "2020-01-23T15:24:02Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU3NzcyNTgxOA==",
                                           "createdAt":  "2020-01-23T15:16:16Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCx9PDg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "theodorzoulias",
                                                                               "createdAt":  "2022-12-31T19:18:57Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "ps As another possible workaround to unblock you, you could try adding a class like this to your project:\r\n```C#\r\nprivate sealed class AlwaysInlineScheduler : TaskScheduler\r\n{\r\n    protected override void QueueTask(Task task) =\u003e ThreadPool.QueueUserWorkItem(s =\u003e TryExecuteTask((Task)s), task);\r\n    protected override bool TryExecuteTaskInline(Task task, bool taskWasPreviouslyQueued) =\u003e TryExecuteTask(task);\r\n    protected override IEnumerable\u003cTask\u003e GetScheduledTasks() =\u003e null;\r\n}\r\n```\r\nand then changing your `Parallel.For` to pass in a `ParallelOptions` that uses it:\r\n```C#\r\nParallel.For(0, 20, new ParallelOptions { TaskScheduler = new AlwaysInlineScheduler() }, ...);\r\n```\r\nI suspect that will workaround the issue.  When the main task finishes its work, it then waits on each created replica task using Task.Wait().  Task.Wait() tries to employ a similar \"use this thread if possible\" optimization as previously mentioned, where if the task being waited on hasn\u0027t started yet, it will try to run that task on the current thread instead of on a pool thread.  To do that, though, it asks the TaskScheduler if it\u0027s ok (since the scheduler might have certain requirements for the threads tasks queued to it run on).  The default scheduler will allow such \"inlining\" if it can find the requested task in the current thread pool thread\u0027s local queue, but in this case, it\u0027s not a thread pool thread that\u0027s queueing the initial task but rather the main thread of the app, so when we do the initial Task.Wait, the scheduler will say \"nope\" and we\u0027ll end up blocking waiting on the task rather than inlining it.  The class I pasted above overrides TryExecuteTaskInline to just always try to run the task, and as such, it should avoid the blocking that\u0027s leading to the deadlock.\r\n\r\nAnother workaround would be to run the Parallel.For from a thread pool thread (though in your repro you\u0027d need to change the number of dummy tasks you queue to block pool threads, since you\u0027d be using one of the thread pool threads already).  Then the initial replica Parallel.For creates will be in that thread pool thread\u0027s local queue, and the Task.Wait on it should be able to inline it successfully without further workarounds.",
                                           "updatedAt":  "2020-01-23T15:16:16Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU3ODA2ODQ0Mw==",
                                           "createdAt":  "2020-01-24T10:11:15Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ficzerepeti",
                                           "body":  "What an insightful response, very much appreciated. It makes reporting bugs a very positive experience.\r\nI like the idea of the replica tasks and now I finally understand what I saw during debugging :)\r\n\r\n\u003e The obvious workaround for you is: don\u0027t do that ;-)\r\n\r\nI know you\u0027re half joking but I tried that. Sadly it\u0027d be a massive amount of work which has now been put on our backlog. I guess you know what that means :)\r\n\r\nGood news is that you were right, `AlwaysInlineScheduler` solves our problem. For me at this point this is good enough as we\u0027re in full control of our codebase and Parallel.For is not directly used but hidden behind a lib to allow switching between various implementations.\r\n\r\nI\u0027m happy to wait for [dotnet/corefx#8142](https://github.com/dotnet/corefx/issues/8142) to be resolved and get low cost cancellation.",
                                           "updatedAt":  "2020-01-24T10:12:06Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY1NTYzNjY1Mw==",
                                           "createdAt":  "2020-07-08T16:53:13Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @tarekgh\nNotify danmosemsft if you want to be subscribed.",
                                           "updatedAt":  "2020-07-08T16:53:13Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5w0_1u",
                                           "createdAt":  "2024-01-16T01:28:19Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-threading-tasks\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nHi,\r\n\r\nI\u0027ve been migrating a dotnet framework application to dotnet core and during the process I\u0027ve found a possible issue.\r\n\r\nOn dotnet core in case all ThreadPool threads are blocked (waiting for computation to be finished for example) then Parallel.For doesn\u0027t return however it does on framework. In the app I\u0027m working on the maximum ThreadPool thread count is limited to processor count (`ThreadPool.SetMaxThreads(Environment.ProcessorCount, Environment.ProcessorCount);`).\r\n\r\nI\u0027ve been able to reproduce the issue with ~60 lines of code [which you can find here](https://github.com/ficzerepeti/Parallel.For_blocks_on_dotnet_core).\r\n\r\nMy question is: is this the expected behaviour? If yes then how can I get it to work like in framework?\r\n\r\nThanks,\r\nPeter\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eficzerepeti\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003estephentoub\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`bug`, `area-System.Threading.Tasks`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e9.0.0\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2024-01-16T01:28:19Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5xr0lw",
                                           "createdAt":  "2024-01-24T03:57:59Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e The \"easy\" fix would likely lead to an exception being thrown and caught on every Parallel.For invocation, which isn\u0027t ideal. We might need https://github.com/dotnet/corefx/issues/8142 to do this correctly.\r\n\r\nNow that we have SuppressThrowing, I gave this a quick go, but it\u0027s unfortunately not as easy as I\u0027d hoped. We can easily create a CancellationTokenSource, create the tasks with its CancellationToken, Cancel the CTS once the initial replica task completes, and ignore any cancellation while waiting via SuppressThrowing. But in order for the Task being waited on to actually transition to the canceled state after it\u0027s been started, the scheduler\u0027s TryDequeue needs to return true, and that can only happen for the default scheduler if the task being dequeued is queued to the work-stealing queue for the thread calling Cancel. And that\u0027s frequently not going to be the case here.",
                                           "updatedAt":  "2024-01-24T03:57:59Z"
                                       }
                                   ],
                         "totalCount":  6
                     },
        "title":  "Parallel.For blocks when no ThreadPool threads are available on dotnet core but works on framework",
        "labels":  [
                       "bug",
                       "area-System.Threading.Tasks"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/33804",
        "createdAt":  "2020-03-19T16:43:09Z",
        "number":  33804,
        "author":  "terrajobst",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOC3h7EA==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "AmrAlSayed0",
                                            "createdAt":  "2020-06-03T22:46:48Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "WeihanLi",
                                            "createdAt":  "2023-05-18T10:07:03Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "MineCake147E",
                                            "createdAt":  "2023-11-04T04:45:04Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "colejohnson66",
                                            "createdAt":  "2024-04-27T15:29:12Z"
                                        }
                                    ],
                          "totalCount":  4
                      },
        "updatedAt":  "2024-03-12T22:47:09Z",
        "body":  "Flag `internal`/`private` methods that returns `T`s that won\u0027t be entirely cached (e.g. bool) and where every caller of the method only ever awaits its result directly.\n\n**Category**: Performance",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOYphT2Q==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDYwMTk2OTA3Mg==",
                                           "createdAt":  "2020-03-21T00:54:48Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jeffhandley",
                                           "body":  "Estimates:\r\n* Analyzer: Large\r\n* Fixer: Large",
                                           "updatedAt":  "2020-03-21T00:54:48Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDYyMDk3MTIyMQ==",
                                           "createdAt":  "2020-04-29T03:30:50Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "weitzhandler",
                                           "body":  "The problem with `ValueTask` is that it\u0027s hard to be used in generics since they don\u0027t implement a shared interface, so if you make a static class with some generics, you\u0027ll have to write out all types if one of the types can\u0027t be inferred.\r\nSee https://github.com/xunit/xunit/issues/1919 and https://github.com/dotnet/runtime/issues/25654.",
                                           "updatedAt":  "2020-04-29T03:33:57Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDYyMTA0MTcxMw==",
                                           "createdAt":  "2020-04-29T07:42:33Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOBCk86Q==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "weitzhandler",
                                                                               "createdAt":  "2020-04-29T08:21:00Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "Joe4evr",
                                           "body":  "@weitzhandler If the only thing you\u0027re concerned with is not having to write unnecessary type arguments, then dotnet/csharplang#1349 has you covered.",
                                           "updatedAt":  "2020-04-29T07:42:33Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg2NjMzMjE4Mg==",
                                           "createdAt":  "2021-06-22T21:04:01Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "carlossanlop",
                                           "body":  "\u003e  that won\u0027t be entirely cached (e.g. bool)\r\n\r\n@terrajobst can you please expand on this? What do you mean by \"entirely cached\"?\r\n\r\n\u003e every caller of the method only ever awaits its result directly\r\n\r\nDo you mean the analyzer should only flag cases where the `await` keyword is next to the invocation itself?\r\n\r\nFor example, if you have:\r\n```cs\r\nprivate Task\u003cMyType\u003e MyMethodAsync() { ... }\r\n```\r\n\r\nDo you mean the analyzer should only suggest changing to `ValueTask\u003cT\u003e` when _all_ the invocations of the method look like this?:\r\n```cs\r\nMyType myType = await MyMethodAsync();\r\n```\r\n\r\nBut if the analyzer finds at least _one_ invocation that looks like this, then we don\u0027t suggest changing to `ValueTask\u003cT\u003e`?:\r\n```cs\r\nTask\u003cMyType\u003e myTask = MyMethodAsync();\r\nawait myTask;\r\n```",
                                           "updatedAt":  "2021-06-22T21:04:52Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5imFPZ",
                                           "createdAt":  "2023-07-27T18:12:15Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "bartonjs",
                                           "body":  "[Video](https://www.youtube.com/watch?v=ULSmH4ZxolA\u0026t=0h34m56s)\n\nGenerally seems good as proposed.  A few notes from the discussion\r\n\r\n* It should follow existing conventions for InternalsVisibleTo with internal members.\r\n* It should probably ignore virtual members in the initial implementation, then add them in later.\r\n* The general rule is \"if any caller code would have to change, don\u0027t recommend this change\"\r\n* It only applies to methods with the `async` keyword.\r\n\r\nCategory: Performance\r\nLevel: Info",
                                           "updatedAt":  "2023-07-27T19:39:27Z"
                                       }
                                   ],
                         "totalCount":  5
                     },
        "title":  "Consider using ValueTask\u003cT\u003e instead of Task\u003cT\u003e",
        "labels":  [
                       "api-approved",
                       "area-System.Threading.Tasks",
                       "help wanted",
                       "code-analyzer",
                       "code-fixer"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/33805",
        "createdAt":  "2020-03-19T16:43:10Z",
        "number":  33805,
        "author":  "terrajobst",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOCxns-w==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Kryptos-FR",
                                            "createdAt":  "2020-03-20T12:41:48Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "strangeman375",
                                            "createdAt":  "2020-03-20T17:09:24Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "pentp",
                                            "createdAt":  "2020-06-05T17:37:07Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "NN---",
                                            "createdAt":  "2020-10-01T17:38:15Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "WeihanLi",
                                            "createdAt":  "2021-08-18T04:55:00Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "halter73",
                                            "createdAt":  "2022-09-06T18:54:39Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "colejohnson66",
                                            "createdAt":  "2023-07-30T00:14:11Z"
                                        }
                                    ],
                          "totalCount":  7
                      },
        "updatedAt":  "2023-08-19T20:43:52Z",
        "body":  "Flag places where a `Task.Delay` is used as an argument to `WhenAny` and where that `Task.Delay` doesn\u0027t take a cancellation token, in which case the `Task.Delay` is likely leaving a timer running for longer than is necessary.\n\n**Category**: Performance",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOZHC6UA==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDYwMTk2OTExNQ==",
                                           "createdAt":  "2020-03-21T00:55:03Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jeffhandley",
                                           "body":  "Estimates:\r\n* Analyzer: Medium\r\n* Fixer: Not Applicable",
                                           "updatedAt":  "2020-03-21T00:55:03Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDYwMjAyNDAzNQ==",
                                           "createdAt":  "2020-03-21T10:25:25Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCOB5gw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "pentp",
                                                                               "createdAt":  "2020-06-05T17:37:20Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "GSPP",
                                                                               "createdAt":  "2022-02-10T12:08:56Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e Fixer: Not Applicable\r\n\r\nI think a fixer could reasonably be done here.\r\n\r\nAlso, it\u0027s such a common pattern, we could consider introducing new overloads to simplify it.",
                                           "updatedAt":  "2020-03-21T10:25:25Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY4NTk2MDAxNA==",
                                           "createdAt":  "2020-09-02T19:50:41Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Mrnikbobjeff",
                                           "body":  "\u003e \u003e Fixer: Not Applicable\r\n\u003e \r\n\u003e I think a fixer could reasonably be done here.\r\n\u003e \r\n\u003e Also, it\u0027s such a common pattern, we could consider introducing new overloads to simplify it.\r\n\r\nWould a fixer simply check if the current method has a cancellationtoken parameter? Otherwise where would our cancellationtoken come from?",
                                           "updatedAt":  "2020-09-02T19:50:41Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY5MjMzNDE3Mg==",
                                           "createdAt":  "2020-09-14T21:53:24Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCOB6Gg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "theodorzoulias",
                                                                               "createdAt":  "2021-01-25T21:59:02Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "GSPP",
                                                                               "createdAt":  "2022-02-10T12:09:45Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e Would a fixer simply check if the current method has a cancellationtoken parameter? Otherwise where would our cancellationtoken come from?\r\n\r\nThe fixer would manufacture it.  Essentially this:\r\n```C#\r\nif (task != await Task.WhenAny(Task.Delay(timeout), task))\r\n    throw new TimeoutException();\r\n```\r\nwould become\r\n```C#\r\nusing (var cts = new CancellationTokenSource())\r\n{\r\n    Task t = await Task.WhenAny(Task.Delay(timeout, cts.Token), task);\r\n    cts.Cancel();\r\n    if (t != task)\r\n        throw new TimeoutException();\r\n}\r\n```\r\nor something along those lines.\r\n\r\nThat said, a better approach might instead be to just add an API like https://github.com/dotnet/runtime/issues/27723, as I expect that represents the 99% case for this pattern, and then a fixer here could offer to just switch to use that API if it\u0027s available.",
                                           "updatedAt":  "2020-09-14T21:53:24Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY5MzU1MzEwMA==",
                                           "createdAt":  "2020-09-16T17:33:11Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Mrnikbobjeff",
                                           "body":  "I believe the new API would be vastly superior as the intent is perfectly clear, while analysing the longer snippet costs some time. I would leave the fixer blank for now as the earliest an analyzer could ship appears to be .net 6 and I would hope the Task Timeout extension method becomes standardised by then.",
                                           "updatedAt":  "2020-09-16T17:33:11Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDczMTQxMDAyMA==",
                                           "createdAt":  "2020-11-20T21:13:12Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "carlossanlop",
                                           "body":  "@Mrnikbobjeff @stephentoub this analyzer seems to be already covered with the one I wrote (CA2016), which passes a `CancellationToken` to methods that can take it: https://github.com/dotnet/runtime/issues/33774 ([PR](https://github.com/dotnet/roslyn-analyzers/pull/3720))\r\n\r\nThe case that analyzer CA2016 wouldn\u0027t cover is the one shared by Stephen in the [example above](https://github.com/dotnet/runtime/issues/33805#issuecomment-692334172), where we detect a newly created `CancellationTokenSource` in the same context and then pass its underlying `cts.Token` to the method that can take it.\r\n\r\nWe could enhance CA2016 to cover that case as well. I don\u0027t think we need another analyzer for this. Anyone thinks differently?",
                                           "updatedAt":  "2020-11-20T21:14:00Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDczMTQ0OTI2MQ==",
                                           "createdAt":  "2020-11-20T22:57:17Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOBdowfQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "pentp",
                                                                               "createdAt":  "2020-11-23T02:41:47Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "eiriktsarpalis",
                                                                               "createdAt":  "2020-11-23T10:56:11Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "theodorzoulias",
                                                                               "createdAt":  "2021-01-25T22:00:13Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  3
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "This is different from CA2016.  In fact if CA2016 fired for the shown pattern, it would be doing the wrong thing (or at least it wouldn\u0027t be doing as well as it should).  The idiom being used is simply trying to time out an await, and using a Task.Delay combined with a Task.WhenAny to do it, but then not disposing of the resources created for that timeout, namely the timer underneath the Task.Delay.  So a dedicated CancellationTokenSource needs to be created that can be used to cancel the Task.Delay after the operation completes.\r\n\r\nI think the right answer here is shipping some form of https://github.com/dotnet/runtime/issues/27723, and then the analyzer would flag patterns like `await Task.WhenAny(task, Task.Delay(timeout))` and recommend switching to that new API.\r\ncc: @eiriktsarpalis ",
                                           "updatedAt":  "2020-11-20T22:57:17Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgxOTAzMDI5MA==",
                                           "createdAt":  "2021-04-13T20:26:42Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "carlossanlop",
                                           "body":  "So there were a bunch of APIs that got [approved](https://github.com/dotnet/runtime/issues/47525) and them [merged](https://github.com/dotnet/runtime/pull/48842) (Mar 11) to help with tasks and timeouts.\r\n\r\nBased on this comment:\r\n\r\n\u003e I think the right answer here is shipping some form of ~~#27723~~ #47525, and then the analyzer would flag patterns like `await Task.WhenAny(task, Task.Delay(timeout))` and recommend switching to that new API.\r\n\r\nMaybe there\u0027s more than one pattern this analyzer could potentially flag. @stephentoub @eiriktsarpalis would you mind helping determine the cases to flag and what the fixer should suggest?",
                                           "updatedAt":  "2021-04-13T20:26:42Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgyMjEwNzM2Mw==",
                                           "createdAt":  "2021-04-19T01:21:07Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCGZ38Q==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "buyaa-n",
                                                                               "createdAt":  "2021-12-13T20:21:52Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "There are lots of variations to the erroneous pattern, so it might be hard to flag them all as well as come up with a good fixer.  But we could probably just flag cases where `Task.Delay(timeout)` (no cancellation token argument) is passed to Task.WhenAny with just one other task, e.g.\r\n```C#\r\nTask.WhenAny(task, Task.Delay(timeout))\r\n```\r\nand suggest that it\u0027s likely an issue and Task.WaitAsync should be used instead.",
                                           "updatedAt":  "2021-04-19T01:21:07Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc47LfPq",
                                           "createdAt":  "2021-12-13T20:30:09Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "buyaa-n",
                                           "body":  "Based on the above comments the analyzer/fixer behavior could look like this:\r\n\r\n- Suggested severity: Info\r\n- Suggested category: Performance\r\n- Suggested milestone: Future\r\n\r\n```cs\r\npublic static void CancellationNotProvidedFlag(Task task, int timeout)\r\n{\r\n    Task.WhenAny(task, Task.Delay(timeout)); // warn\r\n}\r\n\r\npublic static void CancellationNotProvidedAfterFix(Task task, int timeout)\r\n{\r\n    task.WaitAsync(TimeSpan.FromMilliseconds(timeout));\r\n}\r\n```\r\n\r\n```cs\r\npublic static void CancellationNotProvidedFlag(Task task, TimeSpan timeout)\r\n{\r\n    Task.WhenAny(task, Task.Delay(timeout)); // warn\r\n}\r\n\r\npublic static void CancellationNotProvidedAfterFix(Task task, TimeSpan timeout)\r\n{\r\n    task.WaitAsync(timeout);\r\n}\r\n```\r\n\r\n```cs\r\npublic static void CancellationProvidedButNotPassedFlag(Task task, int timeout, CancellationToken token)\r\n{\r\n    Task.WhenAny(task, Task.Delay(timeout)); // warn\r\n}\r\n\r\npublic static void CancellationProvidedButNotPassedAfterFix(Task task, int timeout, CancellationToken token)\r\n{\r\n    task.WaitAsync(TimeSpan.FromMilliseconds(timeout), token);\r\n}\r\n```\r\n\r\n```cs\r\npublic static void CancellationProvidedButNotPassedFlag(Task task, TimeSpan timeout, CancellationToken token)\r\n{\r\n    Task.WhenAny(task, Task.Delay(timeout));\r\n}\r\n\r\npublic static void CancellationProvidedButNotPassedAfterFix(Task task, TimeSpan timeout, CancellationToken token)\r\n{\r\n    task.WaitAsync(timeout, token);\r\n}\r\n```\r\n\r\n```cs\r\n// I assume if the `CancellationToken` is passed into `Task.Delay` as needed we should not flag\r\npublic static void CancellationProvidedAndPassedDoNotFlag(Task task, int timeout, CancellationToken token)\r\n{\r\n    Task.WhenAny(task, Task.Delay(timeout, token)); // no warning\r\n}\r\n\r\npublic static void CancellationProvidedAndPassedDoNotFlag(Task task, TimeSpan timeout, CancellationToken token)\r\n{\r\n    Task.WhenAny(task, Task.Delay(timeout, token)); // no warning\r\n}\r\n```\r\ncc @carlossanlop @stephentoub ",
                                           "updatedAt":  "2022-02-01T21:16:51Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5J0qPU",
                                           "createdAt":  "2022-09-06T19:04:23Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "bartonjs",
                                           "body":  "[Video](https://www.youtube.com/watch?v=xsWMkQ5QNjM\u0026t=1h42m39s)\n\nSeems good as proposed.  Steve and Stephen pointed out that it\u0027s eventually a problem beyond performance, so the category is now Reliability.\r\n\r\n* Analyzer to detect when Task.Delay with no cancellation token is used in Task.WhenAny, using the next available diagnostic ID.\r\n* A fixer which suggests to use WaitAsync with a timeout over the WhenAny approach, in the cases where it is safe to do so (and the TFM has WaitAsync available).\r\n* The docs page for the diagnostic should demonstrate with \"with cancellation token\" pattern for older TFMs, and perhaps talk about when some other token is available.\r\n\r\nSeverity: Info\r\nCategory: Reliability",
                                           "updatedAt":  "2022-09-06T19:21:06Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5OcbPx",
                                           "createdAt":  "2022-11-16T00:22:58Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "buyaa-n",
                                           "body":  "Estimates:\r\n\r\n - Analyzer: Medium\r\n - Fixer: Medium",
                                           "updatedAt":  "2022-11-16T00:22:58Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5kcLpQ",
                                           "createdAt":  "2023-08-19T20:43:51Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "mpidash",
                                           "body":  "@buyaa-n I\u0027ve ran a prototype analyzer against `dotnet/aspnetcore` to see how the pattern is used, and I am not so sure if a fixer makes sense for this analyzer:\r\n\r\nReplacing `WhenAny` with `WaitAsync` changes the behavior, as `WaitAsync` fails the Task with a `TimeoutException`.\r\nTo preserve non-throwing, the exception must be caught, but for test code a simple replacement might be ok (though catching the exception and failing with a more descriptive message is probably preferable):\r\n\r\n```cs\r\n[Fact]\r\npublic async Task ReloadingThePage_GracefullyDisconnects_TheCurrentCircuit()\r\n{\r\n    // Arrange \u0026 Act\r\n    Browser.Navigate().Refresh();\r\n    await Task.WhenAny(Task.Delay(10000), GracefulDisconnectCompletionSource.Task);\r\n\r\n    // Assert\r\n    Assert.Contains((Extensions.Logging.LogLevel.Debug, \"CircuitTerminatedGracefully\"), Messages.ToArray());\r\n    Assert.Contains((Extensions.Logging.LogLevel.Debug, \"CircuitDisconnectedPermanently\"), Messages.ToArray());\r\n}\r\n```\r\n\r\nBut `WaitAsync` also states that the returned task could be a different task than the instance:\r\n\u003e Returns\r\n\u003e [Task](https://learn.microsoft.com/en-us/dotnet/api/system.threading.tasks.task?view=net-7.0)\r\n\u003e The [Task](https://learn.microsoft.com/en-us/dotnet/api/system.threading.tasks.task?view=net-7.0) representing the asynchronous wait. It may or may not be the same instance as the current instance.\r\n\r\nSo a simple replacement in the following cases could lead to broken code:\r\n\r\n```cs\r\nvar task = await Task.WhenAny(_allBlocksReturned.Task, Task.Delay(timeout));\r\nif (task != _allBlocksReturned.Task)\r\n```\r\n\r\nor\r\n\r\n```cs\r\n// Verify that the response isn\u0027t flushed by verifying the TCS isn\u0027t set\r\nvar res = await Task.WhenAny(tcs.Task, Task.Delay(1000)) == tcs.Task;\r\nAssert.False(res);\r\n```\r\n\r\nor\r\n\r\n```cs\r\nif (await Task.WhenAny(exitedTcs.Task, Task.Delay(TimeSpan.FromSeconds(TimeoutSeconds * 2))) != exitedTcs.Task)\r\n{\r\n    try\r\n    {\r\n        process.Kill();\r\n    }\r\n    catch (Exception ex)\r\n    {\r\n        throw new TimeoutException($\"h2spec didn\u0027t exit within {TimeoutSeconds * 2} seconds.\", ex);\r\n    }\r\n    throw new TimeoutException($\"h2spec didn\u0027t exit within {TimeoutSeconds * 2} seconds.\");\r\n}\r\n```\r\n\r\nor\r\n\r\n```cs\r\npublic async Task WhenAllBlocksReturnedAsync(TimeSpan timeout)\r\n{\r\n    var task = await Task.WhenAny(_allBlocksReturned.Task, Task.Delay(timeout));\r\n    if (task != _allBlocksReturned.Task)\r\n    {\r\n        MemoryPoolThrowHelper.ThrowInvalidOperationException_BlocksWereNotReturnedInTime(_totalBlocks - _blocks.Count, _totalBlocks, _blocks.ToArray());\r\n    }\r\n\r\n    await task;\r\n}\r\n```\r\n\r\nMost of these examples could be written more clearly with a bit more (individual) refactoring, so I am not sure if a fixer could do this automatically. Also seen in the changes in #48842.\r\n\r\n\u003cdetails\u003e\r\n  \u003csummary\u003eAll findings\u003c/summary\u003e\r\n\r\n1. W:\\aspnetcore\\src\\Components\\test\\E2ETest\\ServerExecutionTests\\CircuitGracefulTerminationTests.cs(57,15): info CA2022: Do not use \u0027WhenAny\u0027 with a noncancelable Task created by \u0027Delay\u0027\r\n2. W:\\aspnetcore\\src\\Components\\test\\E2ETest\\ServerExecutionTests\\CircuitGracefulTerminationTests.cs(70,15): info CA2022: Do not use \u0027WhenAny\u0027 with a noncancelable Task created by \u0027Delay\u0027\r\n3. W:\\aspnetcore\\src\\Components\\test\\E2ETest\\ServerExecutionTests\\CircuitGracefulTerminationTests.cs(83,26): info CA2022: Do not use \u0027WhenAny\u0027 with a noncancelable Task created by \u0027Delay\u0027\r\n4. W:\\aspnetcore\\src\\Components\\test\\E2ETest\\ServerExecutionTests\\CircuitGracefulTerminationTests.cs(97,15): info CA2022: Do not use \u0027WhenAny\u0027 with a noncancelable Task created by \u0027Delay\u0027\r\n5. W:\\aspnetcore\\src\\Components\\test\\E2ETest\\ServerExecutionTests\\CircuitGracefulTerminationTests.cs(110,15): info CA2022: Do not use \u0027WhenAny\u0027 with a noncancelable Task created by \u0027Delay\u0027\r\n6. W:\\aspnetcore\\src\\Components\\test\\E2ETest\\ServerExecutionTests\\CircuitGracefulTerminationTests.cs(123,15): info CA2022: Do not use \u0027WhenAny\u0027 with a noncancelable Task created by \u0027Delay\u0027\r\n7. W:\\aspnetcore\\src\\Hosting\\Hosting\\test\\WebHostTests.cs(228,38): info CA2022: Do not use \u0027WhenAny\u0027 with a noncancelable Task created by \u0027Delay\u0027\r\n8. W:\\aspnetcore\\src\\Middleware\\Spa\\SpaServices.Extensions\\src\\Util\\TaskTimeoutExtensions.cs(10,27): info CA2022: Do not use \u0027WhenAny\u0027 with a noncancelable Task created by \u0027Delay\u0027\r\n9. W:\\aspnetcore\\src\\Servers\\HttpSys\\test\\FunctionalTests\\Listener\\Utilities.cs(130,35): info CA2022: Do not use \u0027WhenAny\u0027 with a noncancelable Task created by \u0027Delay\u0027\r\n10. W:\\aspnetcore\\src\\Servers\\Kestrel\\Core\\src\\Internal\\Infrastructure\\TransportConnectionManager.cs(86,22): info CA2022: Do not use \u0027WhenAny\u0027 with a noncancelable Task created by \u0027Delay\u0027\r\n11. W:\\aspnetcore\\src\\Servers\\Kestrel\\test\\InMemory.FunctionalTests\\Http2\\Http2StreamTests.cs(1602,29): info CA2022: Do not use \u0027WhenAny\u0027 with a noncancelable Task created by \u0027Delay\u0027\r\n12. W:\\aspnetcore\\src\\Servers\\Kestrel\\test\\InMemory.FunctionalTests\\ResponseTests.cs(3106,29): info CA2022: Do not use \u0027WhenAny\u0027 with a noncancelable Task created by \u0027Delay\u0027\r\n13. W:\\aspnetcore\\src\\Servers\\Kestrel\\test\\Interop.FunctionalTests\\H2SpecCommands.cs(254,23): info CA2022: Do not use \u0027WhenAny\u0027 with a noncancelable Task created by \u0027Delay\u0027\r\n14. W:\\aspnetcore\\src\\Shared\\Buffers.MemoryPool\\DiagnosticMemoryPool.cs(157,26): info CA2022: Do not use \u0027WhenAny\u0027 with a noncancelable Task created by \u0027Delay\u0027\r\n\r\n\u003c/details\u003e",
                                           "updatedAt":  "2023-08-19T20:43:51Z"
                                       }
                                   ],
                         "totalCount":  13
                     },
        "title":  "Detect non-cancelable Task.Delay passed to Task.WhenAny",
        "labels":  [
                       "api-approved",
                       "area-System.Threading.Tasks",
                       "help wanted",
                       "code-analyzer",
                       "code-fixer"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/47802",
        "createdAt":  "2021-02-03T16:42:09Z",
        "number":  47802,
        "author":  "CXuesong",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHODGg_Hg==",
                          "nodes":  [
                                        {
                                            "content":  "EYES",
                                            "user":  "warappa",
                                            "createdAt":  "2021-02-05T22:08:45Z"
                                        },
                                        {
                                            "content":  "EYES",
                                            "user":  "mitoihs",
                                            "createdAt":  "2021-04-22T08:33:13Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "vchirikov",
                                            "createdAt":  "2021-09-20T18:59:35Z"
                                        },
                                        {
                                            "content":  "EYES",
                                            "user":  "vchirikov",
                                            "createdAt":  "2021-09-20T18:59:41Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "botinko",
                                            "createdAt":  "2021-09-20T19:00:07Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "BrunoJuchli",
                                            "createdAt":  "2021-11-19T17:50:55Z"
                                        },
                                        {
                                            "content":  "EYES",
                                            "user":  "BrunoJuchli",
                                            "createdAt":  "2021-11-19T17:50:56Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "momvart",
                                            "createdAt":  "2022-01-19T14:05:10Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "N-Olbert",
                                            "createdAt":  "2022-05-20T08:24:21Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "riesvriend",
                                            "createdAt":  "2022-08-16T11:26:01Z"
                                        },
                                        {
                                            "content":  "CONFUSED",
                                            "user":  "mdonatas-trafi",
                                            "createdAt":  "2023-01-25T11:40:29Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "alexbereznikov",
                                            "createdAt":  "2023-02-27T14:14:12Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "ProTip",
                                            "createdAt":  "2023-02-28T20:10:28Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "austindrenski",
                                            "createdAt":  "2023-06-03T22:08:50Z"
                                        },
                                        {
                                            "content":  "CONFUSED",
                                            "user":  "onyxmaster",
                                            "createdAt":  "2023-10-11T08:54:58Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "litenova",
                                            "createdAt":  "2023-10-31T07:57:31Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "zdenek-jelinek",
                                            "createdAt":  "2024-01-26T19:06:34Z"
                                        },
                                        {
                                            "content":  "EYES",
                                            "user":  "zdenek-jelinek",
                                            "createdAt":  "2024-01-30T10:02:10Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "wazzamatazz",
                                            "createdAt":  "2024-02-06T13:50:51Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "lsoft",
                                            "createdAt":  "2024-03-04T05:47:48Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Pennidren",
                                            "createdAt":  "2024-03-05T22:17:41Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "ivan-v-tarasov",
                                            "createdAt":  "2024-07-02T17:19:13Z"
                                        },
                                        {
                                            "content":  "CONFUSED",
                                            "user":  "ivan-v-tarasov",
                                            "createdAt":  "2024-07-02T17:30:54Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Hookyns",
                                            "createdAt":  "2024-11-12T09:42:11Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "aradalvand",
                                            "createdAt":  "2025-03-23T14:54:45Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "dmillerkeyfive",
                                            "createdAt":  "2025-05-21T15:29:55Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "kevin-s-diaz",
                                            "createdAt":  "2025-05-21T15:30:00Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "m-balous",
                                            "createdAt":  "2025-07-10T15:08:24Z"
                                        }
                                    ],
                          "totalCount":  28
                      },
        "updatedAt":  "2025-07-14T18:10:10Z",
        "body":  "\u003c!--This is just a template - feel free to delete any and all of it and replace as appropriate.--\u003e\r\n\r\n### Description\r\n\r\n\u003c!--\r\n* Please share a clear and concise description of the problem.\r\n* Include minimal steps to reproduce the problem if possible. E.g.: the smallest possible code snippet; or a small repo to clone, with steps to run it.\r\n* What behavior are you seeing, and what behavior would you expect?\r\n  --\u003e\r\n\r\nI\u0027m not sure this is bug or by-design. Consider the following use case of `AsyncLocal\u003cT\u003e`. Should I expect `stringLocal.Value` to be `\"Test\"` or `null`?\r\n```c#\r\nvar stringLocal = new AsyncLocal\u003cstring\u003e();\r\n\r\nasync IAsyncEnumerable\u003cint\u003e IntSequence()\r\n{\r\n    stringLocal.Value = \"Test\";\r\n    yield return 10;\r\n    // Now what should happen if we do not explicitly capture the execution context???\r\n    Console.WriteLine(\"stringLocal.Value: {0}\", stringLocal.Value);\r\n}\r\n```\r\nFrom what I can observe currently, `stringLocal.Value` after `yield return` is `null`. \u003c!-- Note that this means there would be problem if you are using [MEL scoped logging](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/logging/?view=aspnetcore-5.0#log-scopes) in [async stream](https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-8#asynchronous-streams) function. --\u003e\r\n\r\n### Configuration\r\n\u003c!--\r\n* Which version of .NET is the code running on?\r\n* What OS and version, and what distro if applicable?\r\n* What is the architecture (x64, x86, ARM, ARM64)?\r\n* Do you know whether it is specific to that configuration?\r\n* If you\u0027re using Blazor, which web browser(s) do you see this issue in?\r\n  --\u003e\r\n.NET 5 / .NET 6.0.100-preview.1.21103.9\r\n\r\n### Regression?\r\n\r\n\u003c!--\r\n* Did this work in a previous build or release of .NET Core, or from .NET Framework? If you can try a previous release or build to find out, that can help us narrow down the problem. If you don\u0027t know, that\u0027s OK.\r\n  --\u003e\r\nN / A\r\n\r\n### Other information\r\n\r\n\u003c!--\r\n* Please include any relevant stack traces or error messages. If possible please include text as text rather than images (so it shows up in searches).\r\n* If you have an idea where the problem might lie, let us know that here. Please include any pointers to code, relevant changes, or related issues you know of.\r\n* Do you know of any workarounds?\r\n  --\u003e\r\n\r\nHere is an extensive test around the persistence of `AsyncLocal\u003cT\u003e`. [[.NET Fiddle](https://dotnetfiddle.net/wMDV8P)]\r\n\r\n```c#\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing System.Diagnostics;\r\nusing System.Threading;\r\nusing System.Threading.Tasks;\r\n\r\nvar stringLocal = new AsyncLocal\u003cstring\u003e();\r\n\r\nasync IAsyncEnumerable\u003cint\u003e IntSequence(string localValue)\r\n{\r\n    stringLocal.Value = localValue;\r\n    Console.WriteLine(\"Set up stringLocal: {0}.\", localValue);\r\n    await Task.Delay(100).ConfigureAwait(false);\r\n    // await didn\u0027t affect AsyncLocal flow\r\n    Console.WriteLine(\"stringLocal.Value: {0}\", stringLocal.Value);\r\n\r\n    using var execContext = ExecutionContext.Capture();\r\n    Debug.Assert(execContext != null);      // i.e. ExecutionContext.IsFlowSuppressed() == false\r\n    yield return 10;\r\n    ExecutionContext.Restore(execContext);\r\n    // This gives us the correct value, as we have restored execution context.\r\n    Console.WriteLine(\"stringLocal.Value: {0}\", stringLocal.Value);\r\n\r\n    // Now what should happen if we do not explicitly capture the execution context???\r\n    yield return 20;\r\n    Console.WriteLine(\"stringLocal.Value: {0}\", stringLocal.Value);\r\n    yield return 30;\r\n    Console.WriteLine(\"stringLocal.Value: {0}\", stringLocal.Value);\r\n}\r\n\r\nasync Task PrintSequence1()\r\n{\r\n    await foreach (var i in IntSequence(\"value 1\"))\r\n    {\r\n        Console.WriteLine(\"Sequence: {0}\", i);\r\n        await Task.Delay(100);\r\n    }\r\n}\r\n\r\nasync Task PrintSequence2()\r\n{\r\n    await using var it = IntSequence(\"value 2\").GetAsyncEnumerator();\r\n    while (await it.MoveNextAsync())\r\n    {\r\n        Console.WriteLine(\"Sequence: {0}\", it.Current);\r\n    }\r\n}\r\n\r\nPrintSequence1().Wait();\r\nConsole.WriteLine();\r\nPrintSequence2().Wait();\r\n```\r\n\r\nHere is the output\r\n```\r\nSet up stringLocal: value 1.\r\nstringLocal.Value: value 1\r\nSequence: 10\r\nstringLocal.Value: value 1\r\nSequence: 20\r\nstringLocal.Value: \r\nSequence: 30\r\nstringLocal.Value: \r\n\r\nSet up stringLocal: value 2.\r\nstringLocal.Value: value 2\r\nSequence: 10\r\nstringLocal.Value: value 2\r\nSequence: 20\r\nstringLocal.Value: \r\nSequence: 30\r\nstringLocal.Value: \r\n```\r\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOrMHSxw==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc3MjY0OTkxNQ==",
                                           "createdAt":  "2021-02-03T16:42:12Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "I couldn\u0027t figure out the best area label to add to this issue. If you have write-permissions please help me learn by adding exactly one [area label](https://github.com/dotnet/runtime/blob/master/docs/area-owners.md).",
                                           "updatedAt":  "2021-02-03T16:42:12Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc3MjY2NjAwMA==",
                                           "createdAt":  "2021-02-03T17:03:37Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @tarekgh\nSee info in area-owners.md if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n\u003c!--This is just a template - feel free to delete any and all of it and replace as appropriate.--\u003e\r\n\r\n### Description\r\n\r\n\u003c!--\r\n* Please share a clear and concise description of the problem.\r\n* Include minimal steps to reproduce the problem if possible. E.g.: the smallest possible code snippet; or a small repo to clone, with steps to run it.\r\n* What behavior are you seeing, and what behavior would you expect?\r\n  --\u003e\r\n\r\nI\u0027m not sure this is bug or by-design. Consider the following use case of `AsyncLocal\u003cT\u003e`. Should I expect `stringLocal.Value` to be `\"Test\"` or `null`?\r\n```c#\r\nvar stringLocal = new AsyncLocal\u003cstring\u003e();\r\n\r\nasync IAsyncEnumerable\u003cint\u003e IntSequence()\r\n{\r\n    stringLocal.Value = \"Test\";\r\n    yield return 10;\r\n    // Now what should happen if we do not explicitly capture the execution context???\r\n    Console.WriteLine(\"stringLocal.Value: {0}\", stringLocal.Value);\r\n}\r\n```\r\nFrom what I can observe currently, `stringLocal.Value` after `yield return` is `null`. \u003c!-- Note that this means there would be problem if you are using [MEL scoped logging](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/logging/?view=aspnetcore-5.0#log-scopes) in [async stream](https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-8#asynchronous-streams) function. --\u003e\r\n\r\n### Configuration\r\n\u003c!--\r\n* Which version of .NET is the code running on?\r\n* What OS and version, and what distro if applicable?\r\n* What is the architecture (x64, x86, ARM, ARM64)?\r\n* Do you know whether it is specific to that configuration?\r\n* If you\u0027re using Blazor, which web browser(s) do you see this issue in?\r\n  --\u003e\r\n.NET 5 / .NET 6.0.100-preview.1.21103.9\r\n\r\n### Regression?\r\n\r\n\u003c!--\r\n* Did this work in a previous build or release of .NET Core, or from .NET Framework? If you can try a previous release or build to find out, that can help us narrow down the problem. If you don\u0027t know, that\u0027s OK.\r\n  --\u003e\r\nN / A\r\n\r\n### Other information\r\n\r\n\u003c!--\r\n* Please include any relevant stack traces or error messages. If possible please include text as text rather than images (so it shows up in searches).\r\n* If you have an idea where the problem might lie, let us know that here. Please include any pointers to code, relevant changes, or related issues you know of.\r\n* Do you know of any workarounds?\r\n  --\u003e\r\n\r\nHere is an extensive test around the persistence of `AsyncLocal\u003cT\u003e`. [[.NET Fiddle](https://dotnetfiddle.net/wMDV8P)]\r\n\r\n```c#\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing System.Diagnostics;\r\nusing System.Threading;\r\nusing System.Threading.Tasks;\r\n\r\nvar stringLocal = new AsyncLocal\u003cstring\u003e();\r\n\r\nasync IAsyncEnumerable\u003cint\u003e IntSequence(string localValue)\r\n{\r\n    stringLocal.Value = localValue;\r\n    Console.WriteLine(\"Set up stringLocal: {0}.\", localValue);\r\n    await Task.Delay(100).ConfigureAwait(false);\r\n    // await didn\u0027t affect AsyncLocal flow\r\n    Console.WriteLine(\"stringLocal.Value: {0}\", stringLocal.Value);\r\n\r\n    using var execContext = ExecutionContext.Capture();\r\n    Debug.Assert(execContext != null);      // i.e. ExecutionContext.IsFlowSuppressed() == false\r\n    yield return 10;\r\n    ExecutionContext.Restore(execContext);\r\n    // This gives us the correct value, as we have restored execution context.\r\n    Console.WriteLine(\"stringLocal.Value: {0}\", stringLocal.Value);\r\n\r\n    // Now what should happen if we do not explicitly capture the execution context???\r\n    yield return 20;\r\n    Console.WriteLine(\"stringLocal.Value: {0}\", stringLocal.Value);\r\n    yield return 30;\r\n    Console.WriteLine(\"stringLocal.Value: {0}\", stringLocal.Value);\r\n}\r\n\r\nasync Task PrintSequence1()\r\n{\r\n    await foreach (var i in IntSequence(\"value 1\"))\r\n    {\r\n        Console.WriteLine(\"Sequence: {0}\", i);\r\n        await Task.Delay(100);\r\n    }\r\n}\r\n\r\nasync Task PrintSequence2()\r\n{\r\n    await using var it = IntSequence(\"value 2\").GetAsyncEnumerator();\r\n    while (await it.MoveNextAsync())\r\n    {\r\n        Console.WriteLine(\"Sequence: {0}\", it.Current);\r\n    }\r\n}\r\n\r\nPrintSequence1().Wait();\r\nConsole.WriteLine();\r\nPrintSequence2().Wait();\r\n```\r\n\r\nHere is the output\r\n```\r\nSet up stringLocal: value 1.\r\nstringLocal.Value: value 1\r\nSequence: 10\r\nstringLocal.Value: value 1\r\nSequence: 20\r\nstringLocal.Value: \r\nSequence: 30\r\nstringLocal.Value: \r\n\r\nSet up stringLocal: value 2.\r\nstringLocal.Value: value 2\r\nSequence: 10\r\nstringLocal.Value: value 2\r\nSequence: 20\r\nstringLocal.Value: \r\nSequence: 30\r\nstringLocal.Value: \r\n```\r\n\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eCXuesong\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Threading.Tasks`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2021-02-03T17:03:37Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc3MjY3MjM4Nw==",
                                           "createdAt":  "2021-02-03T17:12:28Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "CXuesong",
                                           "body":  "Note that this means there would be problem if you are using [MEL scoped logging](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/logging/?view=aspnetcore-5.0#log-scopes) in [async stream](https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-8#asynchronous-streams) function.\r\n\r\nConsider the following usage scenario\r\n```c#\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing Microsoft.Extensions.Logging;\r\n\r\nasync IAsyncEnumerable\u003cint\u003e IntSequence(ILogger logger)\r\n{\r\n    using var scope = logger.BeginScope(\"My scope\");\r\n    logger.LogWarning(\"Log 1\");\r\n    yield return 10;\r\n    logger.LogWarning(\"Log 2\");\r\n    yield return 20;\r\n    logger.LogWarning(\"Log 3\");\r\n    yield return 30;\r\n}\r\n\r\nusing var lf = LoggerFactory.Create(b =\u003e b.AddSimpleConsole(o =\u003e o.IncludeScopes = true));\r\nawait foreach (var i in IntSequence(lf.CreateLogger(\"Root\")))\r\n{\r\n    Console.WriteLine(i);\r\n}\r\n```\r\n\r\nThe expected output is\r\n```\r\n10\r\n20\r\n30\r\nwarn: Root[0]\r\n      =\u003e My scope\r\n      Log 1\r\nwarn: Root[0]\r\n      =\u003e My scope\r\n      Log 2\r\nwarn: Root[0]\r\n      =\u003e My scope\r\n      Log 3\r\n```\r\n\r\nThe actual output is\r\n```\r\n10\r\n20\r\n30\r\nwarn: Root[0]\r\n      =\u003e My scope\r\n      Log 1\r\nwarn: Root[0]\r\n      Log 2\r\nwarn: Root[0]\r\n      Log 3\r\n```\r\n\r\nScopes are lost for Log 2 and Log 3.",
                                           "updatedAt":  "2021-02-03T17:12:28Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc3MjcwMDk3Nw==",
                                           "createdAt":  "2021-02-03T17:53:41Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "It\u0027s \"by design\" in that it was done this way on purpose, with ExecutionContext flowing across await points just as in regular async methods and nothing special being done about yield returns, which logically exit and transfer control to something else (not exactly the same, but putting state into a thread local for example prior to a yield return in a normal sync iterator is in no way guaranteed to be there upon re-entering the iterator).\r\n\r\nChanging that would theoretically be possible but also non-trivial.  Either the Roslyn compiler-generated state machine would need to do the ExecutionContext capture and restore around yields, storing the ExecutionContext into the state machine, or AsyncIteratorMethodBuilder would somehow need to be informed whether the compiler-generated IAsyncStateMachine.MoveNext method was returning because of a yield or an await, which would require both compiler and runtime changes (and probably significant ones at that).  It would also have a potential performance impact, adding an ExecutionContext.Capture() at every yield (right now we only pay that cost when awaiting a task that hasn\u0027t yet completed).\r\ncc: @jcouv",
                                           "updatedAt":  "2021-02-03T17:53:41Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc3MzA0NjA0NA==",
                                           "createdAt":  "2021-02-04T05:42:44Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODB-SMA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "riesvriend",
                                                                               "createdAt":  "2022-08-16T11:28:03Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "BrunoJuchli",
                                                                               "createdAt":  "2023-07-27T10:53:01Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "CXuesong",
                                           "body":  "Thanks for your explanation @stephentoub, and that makes some sense.\r\n\r\nHowever, aside from the MEL logging scope problem that I have bumped into, I\u0027d like to comment on the following statement\r\n\r\n\u003e It would also have a potential performance impact, adding an ExecutionContext.Capture() at every yield\r\n\r\nI\u0027ve checked the source code of [ExecutionContext.Capture](https://source.dot.net/#System.Private.CoreLib/ExecutionContext.cs,74ca881566caecfa) (or the CaptureForRestore method lying beside), it looks trivial and even might get inlined during runtime. The only place that may introduce overhead is the access to `CurrentThread`.\r\n\r\nI think the point is, we should have well-defined (and consistent, unsurprising, if possible) behavior on `AsycLocal`. For now I fail to see any caution of usage with async stream on [docs](https://docs.microsoft.com/en-us/dotnet/api/system.threading.asynclocal-1?view=net-5.0), and from the fashion MEL loggers use (or continue to use) `AsyncLocal`, I guess they didn\u0027t see this coming, either.\r\n\r\nBtw, as of now, what is the recommended pattern for me to temporarily mitigate the issue? I have to call `ExecutionContext.Capture` before `yield return`, but should I either use `ExecutionContext.Restore` or `ExecutionContext.Run` after reentry? When (or whether) should I dispose the captured `ExecutionContext`?",
                                           "updatedAt":  "2021-02-04T05:42:44Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc3MzM1OTg0OA==",
                                           "createdAt":  "2021-02-04T14:41:11Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e I\u0027ve checked the source code of ExecutionContext.Capture (or the CaptureForRestore method lying beside), it looks trivial and even might get inlined during runtime. The only place that may introduce overhead is the access to CurrentThread.\r\n\r\nTLS is not free.  For example, here\u0027s a simple benchmark comparing it against a (well predicted) interface dispatch:\r\n```C#\r\n    [ThreadStatic]\r\n    public static object t_obj;\r\n\r\n    public IList\u003cint\u003e _list = new List\u003cint\u003e();\r\n\r\n    [Benchmark] public object Get() =\u003e t_obj;\r\n    [Benchmark] public int Count() =\u003e _list.Count;\r\n```\r\nwhich on my machine shows it to be twice as expensive:\r\n| Method |     Mean |     Error |    StdDev | Code Size |\r\n|------- |---------:|----------:|----------:|----------:|\r\n|    Get | 2.557 ns | 0.0218 ns | 0.0194 ns |      32 B |\r\n|  Count | 1.335 ns | 0.0068 ns | 0.0064 ns |      30 B |",
                                           "updatedAt":  "2021-02-04T14:41:11Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc3MzQ1MDc4OQ==",
                                           "createdAt":  "2021-02-04T16:49:09Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "CXuesong",
                                           "body":  "\u003e TLS is not free.\r\n\r\nI see.\r\n\r\nThen perhaps the correct approach to address the `ILogger` scope loss problem is to expect `Microsoft.Extensions.Logging` implement `LoggerFactoryScopeProvider`  without `AsyncLocal`… Do I need to open another issue for this extension library (in the same repo)?\r\n\r\nhttps://github.com/dotnet/runtime/blob/f93fee40a84e04c3a28bc4b41b182ca38424c69a/src/libraries/Microsoft.Extensions.Logging/src/LoggerFactoryScopeProvider.cs#L14-L21\r\n",
                                           "updatedAt":  "2021-02-04T16:49:09Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc3MzQ2ODc3Nw==",
                                           "createdAt":  "2021-02-04T17:14:19Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "CXuesong",
                                           "body":  "Also, it seems that [`ExecutionContext.Restore`](https://docs.microsoft.com/en-us/dotnet/api/system.threading.executioncontext.restore?view=net-5.0) is available only on .NET 5.0. I\u0027ll have to go with [`ExecutionContext.Run`](https://docs.microsoft.com/en-us/dotnet/api/system.threading.executioncontext.run?view=net-5.0) on .NET Core 3 / .NET Standard 2.1.",
                                           "updatedAt":  "2021-02-04T17:14:19Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc3NDY4NjQyOQ==",
                                           "createdAt":  "2021-02-07T14:48:39Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEgd8KA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "davidfowl",
                                                                               "createdAt":  "2021-02-07T15:05:09Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "SommerEngineering",
                                                                               "createdAt":  "2021-02-08T07:56:32Z"
                                                                           },
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "CXuesong",
                                                                               "createdAt":  "2021-02-08T14:54:40Z"
                                                                           },
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "D3-LucaPiombino",
                                                                               "createdAt":  "2021-02-08T23:42:36Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "mitoihs",
                                                                               "createdAt":  "2021-05-06T10:04:28Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "vchirikov",
                                                                               "createdAt":  "2021-09-20T19:01:08Z"
                                                                           },
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "vchirikov",
                                                                               "createdAt":  "2021-09-20T19:01:11Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "gbykov-servicetitan",
                                                                               "createdAt":  "2021-09-21T04:54:53Z"
                                                                           },
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "gbykov-servicetitan",
                                                                               "createdAt":  "2021-09-21T04:54:57Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "BrunoJuchli",
                                                                               "createdAt":  "2021-11-19T17:52:40Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "dotnetjunkie",
                                                                               "createdAt":  "2021-11-20T16:52:34Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "momvart",
                                                                               "createdAt":  "2022-01-21T13:35:40Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "N-Olbert",
                                                                               "createdAt":  "2022-05-20T08:24:29Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "riesvriend",
                                                                               "createdAt":  "2022-08-16T11:28:28Z"
                                                                           },
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "riesvriend",
                                                                               "createdAt":  "2022-08-16T11:28:29Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "alexbereznikov",
                                                                               "createdAt":  "2023-02-27T14:16:13Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "austindrenski",
                                                                               "createdAt":  "2023-06-03T22:08:17Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "kaffee-kocher",
                                                                               "createdAt":  "2023-10-28T10:57:52Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Pennidren",
                                                                               "createdAt":  "2024-03-05T22:17:56Z"
                                                                           },
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "Pennidren",
                                                                               "createdAt":  "2024-03-05T22:19:51Z"
                                                                           },
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "zadykian",
                                                                               "createdAt":  "2024-05-15T10:43:48Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "zadykian",
                                                                               "createdAt":  "2024-05-15T10:43:49Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "aradalvand",
                                                                               "createdAt":  "2025-05-21T15:13:47Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "elan-rmaw",
                                                                               "createdAt":  "2025-05-29T08:29:27Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "kzu",
                                                                               "createdAt":  "2025-06-19T05:56:40Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "sanamhub",
                                                                               "createdAt":  "2025-06-23T03:23:12Z"
                                                                           },
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "sanamhub",
                                                                               "createdAt":  "2025-06-23T03:23:12Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "vanbukin",
                                                                               "createdAt":  "2025-08-27T09:48:06Z"
                                                                           },
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "elan-rmaw",
                                                                               "createdAt":  "2025-09-02T08:46:45Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  29
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "I do agree the behavior is unintuitive. I will look into what it would take to change it at the runtime level and what impact that would have.",
                                           "updatedAt":  "2021-02-07T14:48:39Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc3NDY4OTUwMg==",
                                           "createdAt":  "2021-02-07T15:06:30Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEXhEXQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "CXuesong",
                                                                               "createdAt":  "2021-02-08T14:54:35Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "botinko",
                                                                               "createdAt":  "2021-09-19T03:26:04Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "riesvriend",
                                                                               "createdAt":  "2022-08-16T11:28:42Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "austindrenski",
                                                                               "createdAt":  "2023-06-03T22:08:12Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Pennidren",
                                                                               "createdAt":  "2024-03-05T22:20:01Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "zadykian",
                                                                               "createdAt":  "2024-05-15T10:43:44Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "sanamhub",
                                                                               "createdAt":  "2025-06-23T03:23:14Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  7
                                                         },
                                           "author":  "davidfowl",
                                           "body":  "@CXuesong fixing it in logging is the wrong layer. It should be done as part of the runtime. Which @stephentoub is going to look at.",
                                           "updatedAt":  "2021-02-07T15:06:30Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg3Nzc0Nzg2Mw==",
                                           "createdAt":  "2021-07-11T06:14:21Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOETBoQg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "austindrenski",
                                                                               "createdAt":  "2023-06-03T22:07:58Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "t03apt",
                                                                               "createdAt":  "2023-07-26T00:49:57Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "thinkbeforecoding",
                                                                               "createdAt":  "2024-02-13T15:14:51Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "zadykian",
                                                                               "createdAt":  "2024-05-15T10:43:54Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "elan-rmaw",
                                                                               "createdAt":  "2025-05-09T09:33:38Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "aradalvand",
                                                                               "createdAt":  "2025-05-21T15:13:59Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  6
                                                         },
                                           "author":  "aelij",
                                           "body":  "Another compelling use case for this is distributed tracing using `Activity`, which also relies on `AsyncLocal`, e.g.:\r\n\r\n```cs\r\n{\r\n  using var activity = new Activity(\"A\");\r\n  activity.Start();\r\n  yield return item;\r\n}\r\n```",
                                           "updatedAt":  "2021-07-11T06:14:21Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc43BtPO",
                                           "createdAt":  "2021-09-20T18:59:50Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOETBoSA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "vchirikov",
                                                                               "createdAt":  "2021-09-20T20:31:40Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "gbykov-servicetitan",
                                                                               "createdAt":  "2021-09-21T04:55:49Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "BrunoJuchli",
                                                                               "createdAt":  "2021-11-19T17:53:00Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "dotnetjunkie",
                                                                               "createdAt":  "2021-11-20T16:53:13Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "N-Olbert",
                                                                               "createdAt":  "2022-05-20T08:24:32Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "riesvriend",
                                                                               "createdAt":  "2022-08-16T11:28:54Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "mdonatas-trafi",
                                                                               "createdAt":  "2023-01-25T11:39:20Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "austindrenski",
                                                                               "createdAt":  "2023-06-03T22:07:44Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "tstojecki",
                                                                               "createdAt":  "2023-08-25T12:52:27Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "kaffee-kocher",
                                                                               "createdAt":  "2023-10-28T10:58:19Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Pennidren",
                                                                               "createdAt":  "2024-03-05T22:18:02Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "zadykian",
                                                                               "createdAt":  "2024-05-15T10:44:00Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "elan-rmaw",
                                                                               "createdAt":  "2025-05-09T09:33:49Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "dgw2jr",
                                                                               "createdAt":  "2025-05-13T18:34:13Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "aradalvand",
                                                                               "createdAt":  "2025-05-21T15:14:00Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  15
                                                         },
                                           "author":  "botinko",
                                           "body":  "IHttpContextAcessor also will not work properly. Having such a behavior make AsyncLocal very unreliable thing to use. \r\nI would prefer a performance tradeoff to this behavior. ",
                                           "updatedAt":  "2021-09-20T18:59:50Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc46GGym",
                                           "createdAt":  "2021-11-20T17:01:13Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEUPLSA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "BrunoJuchli",
                                                                               "createdAt":  "2022-02-02T09:36:44Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "riesvriend",
                                                                               "createdAt":  "2022-09-10T17:10:33Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "austindrenski",
                                                                               "createdAt":  "2023-06-03T22:07:07Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Pennidren",
                                                                               "createdAt":  "2024-03-05T22:18:25Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "dgw2jr",
                                                                               "createdAt":  "2025-05-13T18:34:35Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "aradalvand",
                                                                               "createdAt":  "2025-05-21T15:25:03Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "elan-rmaw",
                                                                               "createdAt":  "2025-05-29T08:29:48Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  7
                                                         },
                                           "author":  "dotnetjunkie",
                                           "body":  "IMO it\u0027s important to fix this behavior; not just to get the behavior intuitive. Libraries like Castle Windsor and Simple Injector (two DI Containers) depend on Async Local as storage mechanism to allow their DI scopes to flow through asynchronous operations. ",
                                           "updatedAt":  "2021-11-20T17:01:13Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Et-cQ",
                                           "createdAt":  "2022-06-11T11:26:13Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "BigBadBleuCheese",
                                           "body":  "Does this also call into question third-party code using `yield return`, such as LINQ extension methods like `Select`?",
                                           "updatedAt":  "2022-06-11T11:26:13Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5iZTlQ",
                                           "createdAt":  "2023-07-26T00:52:49Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "t03apt",
                                           "body":  "Is there any update on this issue?",
                                           "updatedAt":  "2023-07-26T00:52:49Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5iZawy",
                                           "createdAt":  "2023-07-26T01:31:53Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODB0afA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "t03apt",
                                                                               "createdAt":  "2023-07-26T07:22:39Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "No. It\u0027s still as it was in https://github.com/dotnet/runtime/issues/47802#issuecomment-772700977.",
                                           "updatedAt":  "2023-07-26T01:31:53Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5k7mMs",
                                           "createdAt":  "2023-08-25T13:13:55Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOETBwtw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "austindrenski",
                                                                               "createdAt":  "2023-08-25T17:39:40Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "aradalvand",
                                                                               "createdAt":  "2025-05-21T15:25:17Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "tstojecki",
                                           "body":  "\u003e No. It\u0027s still as it was in [#47802 (comment)](https://github.com/dotnet/runtime/issues/47802#issuecomment-772700977).\r\n\r\n@stephentoub can you please expand? There is @davidfowl comment from 2.2021 and the one you\u0027ve linked to in your response above but not much in a way of an update on what was decided. Is this something the team is evaluating/actively looking into?\r\n\r\nBased on @ericstj milestone bump, safe to assume no changes in the near future (year or so)?",
                                           "updatedAt":  "2023-08-25T13:14:18Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5k8chu",
                                           "createdAt":  "2023-08-25T15:46:46Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODE0B7Q==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "austindrenski",
                                                                               "createdAt":  "2023-08-25T17:39:30Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "ericstj",
                                           "body":  "I moved this out based on @stephentoub\u0027s comment that this was by design and any change would require compiler and runtime changes - we\u0027re not at a point in the 8.0 release where such coordinated changes would be possible - or meet the bar for something like this.  @stephentoub - what are your thoughts on doing something in 9.0?",
                                           "updatedAt":  "2023-08-25T15:46:46Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5k9BUa",
                                           "createdAt":  "2023-08-25T17:39:18Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEXS3uA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "baal2000",
                                                                               "createdAt":  "2023-08-26T03:04:53Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "tstojecki",
                                                                               "createdAt":  "2023-08-26T05:59:41Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "onyxmaster",
                                                                               "createdAt":  "2023-10-11T08:55:48Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "t03apt",
                                                                               "createdAt":  "2024-07-18T21:12:16Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "FrodeOnSea",
                                                                               "createdAt":  "2025-05-27T09:46:10Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "belousovbb",
                                                                               "createdAt":  "2025-06-20T08:17:57Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  6
                                                         },
                                           "author":  "austindrenski",
                                           "body":  "\u003e I moved this out based on @stephentoub\u0027s comment that this was by design and any change would require compiler and runtime changes - we\u0027re not at a point in the 8.0 release where such coordinated changes would be possible - or meet the bar for something like this. @stephentoub - what are your thoughts on doing something in 9.0?\r\n\r\nRecognize the coordination constraints at play, but if this behavior is by-design and expected to remain so through (at least) `net9.0`, it would be really nice to see a coordinated docs update to call this out from some of the relevant pages folks might be looking at when migrating existing code from `foreach` to `await foreach`:\r\n\r\n- https://learn.microsoft.com/dotnet/csharp/language-reference/operators/await#asynchronous-streams-and-disposables\r\n- https://learn.microsoft.com/dotnet/csharp/language-reference/statements/iteration-statements#await-foreach\r\n- https://learn.microsoft.com/dotnet/api/system.collections.generic.iasyncenumerable-1\r\n- https://learn.microsoft.com/dotnet/api/system.threading.asynclocal-1\r\n",
                                           "updatedAt":  "2023-08-25T17:39:18Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5k-2HU",
                                           "createdAt":  "2023-08-26T06:37:03Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODJSCQQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "tstojecki",
                                                                               "createdAt":  "2023-08-26T08:20:42Z"
                                                                           },
                                                                           {
                                                                               "content":  "EYES",
                                                                               "user":  "tstojecki",
                                                                               "createdAt":  "2023-08-26T08:20:49Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "onyxmaster",
                                                                               "createdAt":  "2023-10-11T08:55:49Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  3
                                                         },
                                           "author":  "KalleOlaviNiemitalo",
                                           "body":  "Would a fix for this involve a new ExecutionContextPreservingAsyncIteratorMethodBuilder type as an alternative to [AsyncIteratorMethodBuilder](https://learn.microsoft.com/dotnet/api/system.runtime.compilerservices.asynciteratormethodbuilder), and then an attribute with which the new builder type can be selected in those methods that need it?  Similar to how .NET Runtime uses [AsyncMethodBuilderAttribute](https://learn.microsoft.com/dotnet/api/system.runtime.compilerservices.asyncmethodbuilderattribute) on methods to choose between the default [AsyncValueTaskMethodBuilder\\\u003cTResult\u003e](https://learn.microsoft.com/dotnet/api/system.runtime.compilerservices.asyncvaluetaskmethodbuilder-1) and the alternative [PoolingAsyncValueTaskMethodBuilder\\\u003cTResult\u003e](https://learn.microsoft.com/dotnet/api/system.runtime.compilerservices.poolingasyncvaluetaskmethodbuilder-1).",
                                           "updatedAt":  "2023-08-26T06:37:03Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5npj8R",
                                           "createdAt":  "2023-09-28T11:14:15Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEUPL6Q==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "riesvriend",
                                                                               "createdAt":  "2023-09-28T11:27:53Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "kaffee-kocher",
                                                                               "createdAt":  "2023-10-28T10:59:34Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "aradalvand",
                                                                               "createdAt":  "2025-05-21T15:25:42Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "FrodeOnSea",
                                                                               "createdAt":  "2025-05-27T09:46:48Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "elan-rmaw",
                                                                               "createdAt":  "2025-05-29T08:30:53Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  5
                                                         },
                                           "author":  "ThomasHilbertAtCervis",
                                           "body":  "This is a very general problem. Of course there are third party libraries which will cause unexpected issues because of this, but I managed to run into this issue with my own code. I use AsyncLocal to store my DbContext so I can conveniently access it in my async code. Now I added a method returning an IAsyncEnumerator and yield returning records and stuff stops working without any obvious, reasonable explanation.\r\n\r\nIt\u0027s a shame this won\u0027t work in 8.0, but please at least put it in 9.0. @KalleOlaviNiemitalo \u0027s suggestion sounds fine to me, and shouldn\u0027t even be a problem to get into the 8.0 release. There should be a warning in the docs, and if possible, Visual Studio should detect such cases and issue a warning.",
                                           "updatedAt":  "2023-09-28T11:14:15Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5npqPy",
                                           "createdAt":  "2023-09-28T11:34:51Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "KalleOlaviNiemitalo",
                                           "body":  "I don\u0027t believe a feature that allows AsyncIteratorMethodBuilder to be replaced with a different type has any chance to be approved for .NET 8 and C# 12.  Simpler and safer fixes for other issues are being postponed to .NET 9.\r\n\r\nMaking an analyzer that detects such cases seems difficult, too.  In \u003chttps://github.com/dotnet/runtime/issues/47802#issuecomment-772672387\u003e, the iterator function itself does not mention AsyncLocal\\\u003cT\\\u003e at all.  The analyzer would have to somehow figure out that the `logger.LogWarning` calls need AsyncLocal\\\u003cT\\\u003e to be preserved.  The logging methods could be marked with an attribute for the analyzer, but logging is often called indirectly via other methods and it would be difficult to prove that a method does not depend on AsyncLocal\\\u003cT\\\u003e.",
                                           "updatedAt":  "2023-09-28T11:34:51Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5zvPcS",
                                           "createdAt":  "2024-02-13T15:18:36Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOETBxMw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "elan-rmaw",
                                                                               "createdAt":  "2025-05-09T09:36:17Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "aradalvand",
                                                                               "createdAt":  "2025-05-21T15:25:55Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "thinkbeforecoding",
                                           "body":  "\u003e Another compelling use case for this is distributed tracing using `Activity`, which also relies on `AsyncLocal`, e.g.:\r\n\u003e \r\n\u003e ```cs\r\n\u003e {\r\n\u003e   using var activity = new Activity(\"A\");\r\n\u003e   activity.Start();\r\n\u003e   yield return item;\r\n\u003e }\r\n\u003e ```\r\nI\u0027m exactly in this case.... the `Activity.Current` is set before yielding, and would be disposed when asking for the next item (or when reaching the end). However, for now, the caller doesn\u0027t see the change in its local context, Activity.Current is null. Annoying.",
                                           "updatedAt":  "2024-02-13T15:18:36Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc51L2d_",
                                           "createdAt":  "2024-02-27T08:39:29Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEc3lQg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "LAUGH",
                                                                               "user":  "ivan-v-tarasov",
                                                                               "createdAt":  "2025-08-02T01:30:57Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "BlackGad",
                                           "body":  "Just +1 for this unexpected behavior.\r\n\r\nFixed in my code via manual context control (capture before and restore after each yield return entry). But it is very annoying.  Hope this will be fixed.",
                                           "updatedAt":  "2024-02-27T08:39:29Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc51iUcP",
                                           "createdAt":  "2024-02-29T20:46:21Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "baal2000",
                                           "body":  "@mrpmorris \r\nWhile I agree the issue is annoying and everyone is looking forward to it get fixed by the team, please note that the original example by @CXuesong has no parallel execution in it: it\u0027s serial. Executing multiple asynchronous Tasks in parallel may be outside of `AsyncLocal\u003cT\u003e`\u0027s valid use case. If this is still a valid framework bug then a quick repro example would help them. ",
                                           "updatedAt":  "2024-02-29T20:46:21Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc51jped",
                                           "createdAt":  "2024-03-01T01:27:42Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e I was seeing the error simply by changing this line\r\n\u003e return Task.FromResult(result);\r\n\u003e to this\r\n\u003e return await Task.FromResult(result).\r\n\r\nThat\u0027s different and is not related to this discussion around async iterators and yield.\r\n\r\nChanges to execution context do not flow out of async methods to their callers. By changing your method from non-async to async (which was implied by stating that you changed your code from returning a task to returning an await\u0027d value), you effectively erected a guard around the method that prevents any changes made to async locals in the method from flowing out of the method to its caller or another continuation.",
                                           "updatedAt":  "2024-03-01T01:27:42Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc51pQQn",
                                           "createdAt":  "2024-03-01T18:53:30Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODY-t9Q==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "stephentoub",
                                                                               "createdAt":  "2024-03-01T19:10:06Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "mrpmorris",
                                           "body":  "@stephentoub As my comments were unrelated to this issue I have deleted them so as not to introduce unnecessary noise.\r\n\r\nI\u0027ve created a new ticket here https://github.com/dotnet/runtime/issues/99153",
                                           "updatedAt":  "2024-03-01T18:53:30Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc57Q3Tu",
                                           "createdAt":  "2024-04-21T12:00:41Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Farenheith",
                                           "body":  "@CXuesong I got interested in this issue, but I\u0027m unable to test it right now: would creating log scope at upper level work?\r\nBased on your example:\r\n```cs\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing Microsoft.Extensions.Logging;\r\n\r\nasync IAsyncEnumerable\u003cint\u003e IntSequence(ILogger logger)\r\n{\r\n    logger.LogWarning(\"Log 1\");\r\n    yield return 10;\r\n    logger.LogWarning(\"Log 2\");\r\n    yield return 20;\r\n    logger.LogWarning(\"Log 3\");\r\n    yield return 30;\r\n}\r\n\r\nusing var lf = LoggerFactory.Create(b =\u003e b.AddSimpleConsole(o =\u003e o.IncludeScopes = true));\r\nvar logger = lf.CreateLogger(\"Root\");\r\nusing var scope = logger.BeginScope(\"My scope\");\r\nawait foreach (var i in IntSequence(logger))\r\n{\r\n    Console.WriteLine(i);\r\n}\r\n```\r\n\r\nI know it\u0027s not a solution, I\u0027m just curious if the yielding would mess up the scope in this scenario too",
                                           "updatedAt":  "2024-04-24T02:19:06Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc57Q9di",
                                           "createdAt":  "2024-04-21T13:27:43Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "BlackGad",
                                           "body":  "@Farenheith Below issue reproduction and trick to fix it with manual context restore\r\n\r\n```cs\r\ninternal class Program\r\n{\r\n    private const string CHILD = \"Child\";\r\n    private const string ROOT = \"Root \";\r\n    private static readonly AsyncLocal\u003cstring\u003e LOCAL = new();\r\n\r\n    public static async Task Main()\r\n    {\r\n        Dump(\"Main method before change\", null);\r\n        LOCAL.Value = ROOT;\r\n        Dump(\"Main method after change\", ROOT);\r\n        await foreach (var i in SequenceAsync())\r\n        {\r\n        }\r\n\r\n        Dump(\"Main method after enumeration\", ROOT);\r\n    }\r\n\r\n    private static async IAsyncEnumerable\u003cint\u003e SequenceAsync()\r\n    {\r\n        Dump(\"Sequence method before change\", ROOT); // Must be from parent scope\r\n        LOCAL.Value = CHILD;\r\n        Dump(\"Sequence method after change\", CHILD); // Changed value\r\n        await Task.Delay(100).ConfigureAwait(false);\r\n        Dump(\"Sequence method after generic task await\", CHILD); // Changed value persist\r\n\r\n        // Capture current context\r\n        var execContext = ExecutionContext.Capture();\r\n\r\n        yield return 10;\r\n        Dump(\"Sequence method after yield return\", CHILD); // Local context broken\r\n\r\n        // Restore context\r\n        ExecutionContext.Restore(execContext!);\r\n        Dump(\"Sequence method after context restore\", CHILD);\r\n        yield return 20;\r\n        Dump(\"Sequence method after second yield\", CHILD); // Local context broken\r\n    }\r\n\r\n    private static void Dump(string title, string expected)\r\n    {\r\n        var match = string.Equals(expected, LOCAL.Value) ? \"+\" : \"-\";\r\n        Console.WriteLine(\"{0} E: \u0027{1,5}\u0027 C: \u0027{2,5}\u0027 - {3}\", match, expected, LOCAL.Value, title);\r\n    }\r\n}\r\n```\r\n\r\nOutput from code:\r\n```\r\n+ E: \u0027     \u0027 C: \u0027     \u0027 - Main method before change\r\n+ E: \u0027Root \u0027 C: \u0027Root \u0027 - Main method after change\r\n+ E: \u0027Root \u0027 C: \u0027Root \u0027 - Sequence method before change\r\n+ E: \u0027Child\u0027 C: \u0027Child\u0027 - Sequence method after change\r\n+ E: \u0027Child\u0027 C: \u0027Child\u0027 - Sequence method after generic task await\r\n- E: \u0027Child\u0027 C: \u0027Root \u0027 - Sequence method after yield return\r\n+ E: \u0027Child\u0027 C: \u0027Child\u0027 - Sequence method after context restore\r\n- E: \u0027Child\u0027 C: \u0027Root \u0027 - Sequence method after second yield\r\n+ E: \u0027Root \u0027 C: \u0027Root \u0027 - Main method after enumeration\r\n```\r\n",
                                           "updatedAt":  "2024-04-21T13:27:43Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc57Q9u6",
                                           "createdAt":  "2024-04-21T13:31:34Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODe-Vkg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Farenheith",
                                                                               "createdAt":  "2024-04-21T13:56:26Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "BlackGad",
                                           "body":  "@Farenheith, just to clarify in your example, everything will function correctly. The problem arises when you alter your local async variable within the enumeration method and then perform a yield return. After this, the local async variable that was set within this method assumes the value from the parent scope.\r\n\r\nSo move `using var scope = logger.BeginScope(\"My scope\");` to `IntSequence` method. First warning will be scoped. Second and third will not.",
                                           "updatedAt":  "2024-04-21T13:32:59Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6swdLH",
                                           "createdAt":  "2025-05-21T15:29:31Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEXhEkA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "LAUGH",
                                                                               "user":  "belousovbb",
                                                                               "createdAt":  "2025-06-20T08:30:37Z"
                                                                           },
                                                                           {
                                                                               "content":  "LAUGH",
                                                                               "user":  "sanamhub",
                                                                               "createdAt":  "2025-06-23T03:24:20Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "aradalvand",
                                           "body":  "@stephentoub Sorry for the ping, but is this likely to be addressed in .NET 10? (Please say yes...)",
                                           "updatedAt":  "2025-05-21T15:29:37Z"
                                       }
                                   ],
                         "totalCount":  31
                     },
        "title":  "AsyncLocal\u003cT\u003e does not survive across `yield return` statement",
        "labels":  [
                       "area-System.Threading.Tasks",
                       "needs-further-triage"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/52348",
        "createdAt":  "2021-05-06T00:05:03Z",
        "number":  52348,
        "author":  "kmcclellan",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOC1b-KA==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "theodorzoulias",
                                            "createdAt":  "2021-05-07T03:28:22Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "ronnieoverby",
                                            "createdAt":  "2024-01-25T22:18:40Z"
                                        }
                                    ],
                          "totalCount":  2
                      },
        "updatedAt":  "2024-10-15T18:12:32Z",
        "body":  "### Description\r\n\r\nOnce you call `Complete()` on certain dataflow blocks (like `System.Threading.Tasks.Dataflow.BufferBlock\u003cT\u003e`), cancellation is no longer possible. This is inconvenient since problems can occur downstream and there is no way to exit gracefully.\r\n\r\n```c#\r\nusing var cancellation = new CancellationTokenSource();\r\nvar buffer = new BufferBlock\u003cstring\u003e(new DataflowBlockOptions { CancellationToken = cancellation.Token });\r\n\r\n// Non-empty buffer blocks will never complete.\r\nbuffer.Post(\"hello\");\r\nbuffer.Complete();\r\n\r\n// Even though I said complete, something changed and now I want to cancel.\r\ncancellation.CancelAfter(1000);\r\n\r\n// Cancellation is not respected.\r\nawait buffer.Completion;\r\nConsole.Write(\"We\u0027ll never get here!\");\r\n```\r\n\r\n### Additional Information\r\n\r\nA workaround is to siphon the block into `DataflowBlock.NullTarget\u003cT\u003e()` once cancellation is desired. Faulting doesn\u0027t work, though this appears to be by design.\r\n\r\n(.NET version 5.0)",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOj-1ZEg==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgzMzEyNjA4MQ==",
                                           "createdAt":  "2021-05-06T00:05:07Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @carlossanlop\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Description\r\n\r\nOnce you call `Complete()` on a certain dataflow blocks (like `System.Threading.Tasks.Dataflow.BufferBlock\u003cT\u003e`), cancellation is no longer possible. This is inconvenient since problems can occur downstream and there is no way to exit gracefully.\r\n\r\n```c#\r\nusing var cancellation = new CancellationTokenSource();\r\nvar buffer = new BufferBlock\u003cstring\u003e(new DataflowBlockOptions { CancellationToken = cancellation.Token });\r\n\r\n// Non-empty buffer blocks will never complete.\r\nbuffer.Post(\"hello\");\r\nbuffer.Complete();\r\n\r\n// Even though I said complete, something changed and now I want to cancel.\r\ncancellation.CancelAfter(1000);\r\n\r\n// Cancellation is not respected.\r\nawait buffer.Completion;\r\nConsole.Write(\"We\u0027ll never get here!\");\r\n```\r\n\r\n### Additional Information\r\n\r\nA workaround is to siphon the block into `DataflowBlock.NullTarget\u003cT\u003e()` once cancellation is desired. Faulting doesn\u0027t work, though this appears to be by design.\r\n\r\n(.NET version 5.0)\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003ekmcclellan\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Threading.Tasks`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2021-05-06T00:05:07Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc45t-3v",
                                           "createdAt":  "2021-11-14T20:09:29Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODUJIBw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "kmcclellan",
                                                                               "createdAt":  "2022-05-22T01:02:31Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "ronnieoverby",
                                                                               "createdAt":  "2024-01-25T22:18:37Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "theodorzoulias",
                                           "body":  "I did a bit of testing with the [`TransformBlock\u003cTInput,TOutput\u003e`](https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.dataflow.transformblock-2) class as well, and observed a similar behavior with a little twist. The behavior of a `TransformBlock\u003cTInput,TOutput\u003e` that is first `Complete`d and then `Cancel`ed depends on whether it is doing work at the moment it is canceled:\r\n1. In case it is doing work, the cancellation results to the purging of its output buffer, so the block eventually completes.\r\n2. In case it has completed all the work and it\u0027s currently idle, the cancellation does not affect its output buffer, so the block never completes.\r\n\r\nSo the `TransformBlock\u003cTInput,TOutput\u003e` behaves like the `BufferBlock\u003cT\u003e` only when it\u0027s currently idle.\r\n\r\nHere is a minimal demonstration of this behavior:\r\n\r\n```C#\r\n{\r\n    Console.WriteLine($\"Complete then Cancel while working\");\r\n    var cts = new CancellationTokenSource();\r\n    var block = new TransformBlock\u003cint, int\u003e(\r\n        async x =\u003e { if (x == 2) await Task.Delay(500); return x; },\r\n        new() { CancellationToken = cts.Token });\r\n    block.Post(1);\r\n    block.Post(2);\r\n    block.Post(3);\r\n    block.Complete();\r\n    cts.CancelAfter(200);\r\n    await Task.Delay(100);\r\n    Console.WriteLine($\"Before Wait, OutputCount: {block.OutputCount}\");\r\n    try { await block.Completion.WaitAsync(TimeSpan.FromMilliseconds(1000)); } catch { }\r\n    Console.WriteLine($\"After WaitAsync(1000), OutputCount: {block.OutputCount}, Status: {block.Completion.Status}\");\r\n}\r\nConsole.WriteLine();\r\n{\r\n    Console.WriteLine($\"Complete then Cancel while idle\");\r\n    var cts = new CancellationTokenSource();\r\n    var block = new TransformBlock\u003cint, int\u003e(\r\n        x =\u003e x,\r\n        new() { CancellationToken = cts.Token });\r\n    block.Post(1);\r\n    block.Post(2);\r\n    block.Post(3);\r\n    block.Complete();\r\n    cts.CancelAfter(200);\r\n    await Task.Delay(100);\r\n    Console.WriteLine($\"Before Wait, OutputCount: {block.OutputCount}\");\r\n    try { await block.Completion.WaitAsync(TimeSpan.FromMilliseconds(1000)); } catch { }\r\n    Console.WriteLine($\"After WaitAsync(1000), OutputCount: {block.OutputCount}, Status: {block.Completion.Status}\");\r\n}\r\n```\r\n\r\nOutput:\r\n\r\n```\r\nComplete then Cancel while working\r\nBefore Wait, OutputCount: 1\r\nAfter WaitAsync(1000), OutputCount: 0, Status: Canceled\r\n\r\nComplete then Cancel while idle\r\nBefore Wait, OutputCount: 3\r\nAfter WaitAsync(1000), OutputCount: 3, Status: WaitingForActivation\r\n```\r\n\r\n[Try it on Fiddle](https://dotnetfiddle.net/sk423Z).\r\n\r\nGiven that the behavior of the block is inconsistent, it seems to me that one of the two behaviors is not by design. IMHO the correct behavior would be to purge its output buffer and complete as `Canceled`, just like it would do if the `Complete` had not been called previously.\r\n\r\nBtw the behavior of the dataflow blocks, regarding their output buffer, when the `Complete` is followed by `Fault`, is currently unspecified and ambiguous as well.",
                                           "updatedAt":  "2021-11-14T21:44:34Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6P7VkS",
                                           "createdAt":  "2024-10-15T18:12:31Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "npodbielski",
                                           "body":  "For TransformBlock ( and probably other ISourceBlock blocks) in order to complete while idle is to empty output buffer. So either link it to some target or try to call `Receive` on the block.",
                                           "updatedAt":  "2024-10-15T18:12:31Z"
                                       }
                                   ],
                         "totalCount":  3
                     },
        "title":  "No way to cancel completing dataflow blocks",
        "labels":  [
                       "area-System.Threading.Tasks"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/57331",
        "createdAt":  "2021-08-13T03:27:11Z",
        "number":  57331,
        "author":  "danmoseley",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2021-08-24T10:27:46Z",
        "body":  "There is a dump uploaded, and the usual markdown instruction file to get the payload and symbols\r\nhttps://dev.azure.com/dnceng/public/_build/results?buildId=1291092\u0026view=ms.vss-test-web.build-test-results-tab\u0026runId=38106242\u0026paneView=dotnet-dnceng.dnceng-build-release-tasks.helix-test-information-tab\u0026resultId=198734\r\n\r\nConsole log: \u0027System.Threading.Tasks.Tests\u0027 from job df4bd733-ac6f-43b9-aa20-4db008f69725 workitem 02303039-2752-4888-a303-ac1e36d56fa7 (windows.81.amd64.open.rt) executed on machine a001BRJ\r\n\r\nFailFast is here https://github.com/dotnet/runtime/blob/main/src/libraries/System.Threading.Tasks/tests/Task/ExecutionContextFlowTest.cs#L65\r\n```\r\nProcess terminated. Look at the created dump\r\n   at System.Environment.FailFast(System.String)\r\n   at System.Threading.Tasks.Tests.ExecutionContextFlowTest+\u003cTaskDropsExecutionContextUponCompletion\u003ed__1.MoveNext()\r\n   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1+AsyncStateMachineBox`1[[System.Threading.Tasks.VoidTaskResult, System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e],[System.__Canon, System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].ExecutionContextCallback(System.Object)\r\n   at System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object)\r\n   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1+AsyncStateMachineBox`1[[System.Threading.Tasks.VoidTaskResult, System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e],[System.__Canon, System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].MoveNext(System.Threading.Thread)\r\n   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1+AsyncStateMachineBox`1[[System.Threading.Tasks.VoidTaskResult, System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e],[System.__Canon, System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].MoveNext()\r\n   at System.Threading.Tasks.SynchronizationContextAwaitTaskContinuation+\u003c\u003ec.\u003c.cctor\u003eb__8_0(System.Object)\r\n   at Xunit.Sdk.AsyncTestSyncContext+\u003c\u003ec__DisplayClass7_0.\u003cPost\u003eb__0()\r\n   at Xunit.Sdk.XunitWorkerThread+\u003c\u003ec.\u003cQueueUserWorkItem\u003eb__5_0(System.Object)\r\n   at System.Threading.Tasks.Task.InnerInvoke()\r\n   at System.Threading.Tasks.Task+\u003c\u003ec.\u003c.cctor\u003eb__271_0(System.Object)\r\n   at System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object)\r\n   at System.Threading.Tasks.Task.ExecuteWithThreadLocal(System.Threading.Tasks.Task ByRef, System.Threading.Thread)\r\n   at System.Threading.Tasks.Task.ExecuteEntryUnsafe(System.Threading.Thread)\r\n   at System.Threading.Tasks.ThreadPoolTaskScheduler+\u003c\u003ec.\u003c.cctor\u003eb__10_0(System.Object)\r\n   at System.Threading.Thread+StartHelper.RunWorker()\r\n   at System.Threading.Thread+StartHelper.Run()\r\n   at System.Threading.Thread.StartCallback()\r\n----- end Thu 08/12/2021 22:54:39.72 ----- exit code -2146232797 ----------------------------------------------------------\r\n```\r\n\r\n@tarekgh @stephentoub seems you have worked on this test. I verified I can open the dump and resolve symbols, but I\u0027m not familiar with this area.\r\n\r\nwas in https://github.com/dotnet/runtime/pull/57313/checks",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHONcsO6Q==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc41iOQA",
                                           "createdAt":  "2021-08-13T03:27:13Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-threading-tasks\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nThere is a dump uploaded, and the usual markdown instruction file to get the payload and symbols\r\nhttps://dev.azure.com/dnceng/public/_build/results?buildId=1291092\u0026view=ms.vss-test-web.build-test-results-tab\u0026runId=38106242\u0026paneView=dotnet-dnceng.dnceng-build-release-tasks.helix-test-information-tab\u0026resultId=198734\r\n\r\nConsole log: \u0027System.Threading.Tasks.Tests\u0027 from job df4bd733-ac6f-43b9-aa20-4db008f69725 workitem 02303039-2752-4888-a303-ac1e36d56fa7 (windows.81.amd64.open.rt) executed on machine a001BRJ\r\n\r\nFailFast is here https://github.com/dotnet/runtime/blob/main/src/libraries/System.Threading.Tasks/tests/Task/ExecutionContextFlowTest.cs#L65\r\n```\r\nProcess terminated. Look at the created dump\r\n   at System.Environment.FailFast(System.String)\r\n   at System.Threading.Tasks.Tests.ExecutionContextFlowTest+\u003cTaskDropsExecutionContextUponCompletion\u003ed__1.MoveNext()\r\n   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1+AsyncStateMachineBox`1[[System.Threading.Tasks.VoidTaskResult, System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e],[System.__Canon, System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].ExecutionContextCallback(System.Object)\r\n   at System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object)\r\n   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1+AsyncStateMachineBox`1[[System.Threading.Tasks.VoidTaskResult, System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e],[System.__Canon, System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].MoveNext(System.Threading.Thread)\r\n   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1+AsyncStateMachineBox`1[[System.Threading.Tasks.VoidTaskResult, System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e],[System.__Canon, System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].MoveNext()\r\n   at System.Threading.Tasks.SynchronizationContextAwaitTaskContinuation+\u003c\u003ec.\u003c.cctor\u003eb__8_0(System.Object)\r\n   at Xunit.Sdk.AsyncTestSyncContext+\u003c\u003ec__DisplayClass7_0.\u003cPost\u003eb__0()\r\n   at Xunit.Sdk.XunitWorkerThread+\u003c\u003ec.\u003cQueueUserWorkItem\u003eb__5_0(System.Object)\r\n   at System.Threading.Tasks.Task.InnerInvoke()\r\n   at System.Threading.Tasks.Task+\u003c\u003ec.\u003c.cctor\u003eb__271_0(System.Object)\r\n   at System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object)\r\n   at System.Threading.Tasks.Task.ExecuteWithThreadLocal(System.Threading.Tasks.Task ByRef, System.Threading.Thread)\r\n   at System.Threading.Tasks.Task.ExecuteEntryUnsafe(System.Threading.Thread)\r\n   at System.Threading.Tasks.ThreadPoolTaskScheduler+\u003c\u003ec.\u003c.cctor\u003eb__10_0(System.Object)\r\n   at System.Threading.Thread+StartHelper.RunWorker()\r\n   at System.Threading.Thread+StartHelper.Run()\r\n   at System.Threading.Thread.StartCallback()\r\n----- end Thu 08/12/2021 22:54:39.72 ----- exit code -2146232797 ----------------------------------------------------------\r\n```\r\n\r\n@tarekgh @stephentoub seems you have worked on this test. I verified I can open the dump and resolve symbols, but I\u0027m not familiar with this area.\r\n\r\nwas in https://github.com/dotnet/runtime/pull/57313/checks\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003edanmoseley\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Threading.Tasks`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2021-08-13T03:27:13Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc41yw7p",
                                           "createdAt":  "2021-08-20T07:40:39Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "karelz",
                                           "body":  "Hit again in PR #57747 - see [logs](https://helixre8s23ayyeko0k025g8.blob.core.windows.net/dotnet-runtime-refs-pull-57747-merge-3600f6c8430f4f4ea3/System.Threading.Tasks.Tests/1/console.1a7e1da3.log?sv=2019-07-07\u0026se=2021-09-08T19%3A54%3A35Z\u0026sr=c\u0026sp=rl\u0026sig=X5uca7OZN15MnflHJyMYq6KXQ3eKR2rrtEdEUDpLJIc%3D)",
                                           "updatedAt":  "2021-08-20T07:40:52Z"
                                       }
                                   ],
                         "totalCount":  2
                     },
        "title":  "FailFast in System.Threading.Tasks.Tests.ExecutionContextFlowTest",
        "labels":  [
                       "area-System.Threading.Tasks",
                       "disabled-test"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/63973",
        "createdAt":  "2022-01-18T11:40:08Z",
        "number":  63973,
        "author":  "NikVladi",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOCy-sFg==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "StanislavPrusac",
                                            "createdAt":  "2023-10-02T14:25:46Z"
                                        }
                                    ],
                          "totalCount":  1
                      },
        "updatedAt":  "2022-02-05T01:45:23Z",
        "body":  "As I understand it, all three static methods in Parallel (For, ForEach and Invoke) create tasks in the background.\r\n\r\nYou can stop creating these tasks with cancel a token inside ParallelOptions.\r\n\r\nI made two simple examples.\r\n\r\nIn the first uses the For method in the second Invoke.\r\n\r\nIn the case of the For method, the behavior is expected, after canceling the token, the creation of new tasks is stopped. In the case of the Invoke method, this does not happen. No matter how many methods I put in the Invoke method, they are always executed after the token is canceled. And I don\u0027t understand why this is happening.\r\n\r\nOn [docs.microsoft.com](https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.parallel.invoke?view=net-6.0) in Parallel.Invoke Method It\u0027s been said:\r\n\r\nThe cancellation token passed in with the ParallelOptions structure enables the caller to cancel the entire operation.\r\n\r\n**Question**: Why in the case of the Invoke method, all tasks are executed and canceling the token does nothing? Or maybe I\u0027m doing something wrong, then tell me what.\r\n\r\n```\r\nusing System;\r\nusing System.Threading;\r\nusing System.Threading.Tasks;\r\n\r\nnamespace ConsoleApp1\r\n{\r\n    class MyClass\r\n    {\r\n        public int a = 0;\r\n        public void Add()\r\n        {\r\n            lock (this)\r\n            {\r\n                Thread.Sleep(100);\r\n                Console.WriteLine($\"Do Add {DateTime.Now}\");\r\n                a++;\r\n            }\r\n        }\r\n    }\r\n\r\n    class Program\r\n    {\r\n        static void Main(string[] args)\r\n        {\r\n            void MyMethodForCancel(CancellationTokenSource cancellationTokenSource)\r\n            {\r\n                Random random = new Random();\r\n\r\n                while (true)\r\n                {\r\n                    if (random.Next(1, 100) == 50)\r\n                    {\r\n                        cancellationTokenSource.Cancel();\r\n                        Console.WriteLine($\"Cancel token {DateTime.Now}\");\r\n                        return;\r\n                    }\r\n                }\r\n            }\r\n\r\n            CancellationTokenSource cancellationTokenSource = new CancellationTokenSource();\r\n            ParallelOptions parallelOptions = new ParallelOptions();\r\n            parallelOptions.CancellationToken = cancellationTokenSource.Token;\r\n\r\n            MyClass myClass2 = new MyClass();\r\n            Action[] actions = new Action[50];\r\n\r\n            for (int i = 0; i \u003c actions.Length; i++)\r\n            {\r\n                actions[i] = myClass2.Add;\r\n            }\r\n\r\n            Task MyTask1 = Task.Run(() =\u003e Parallel.Invoke(parallelOptions, actions));\r\n            Task MyTask2 = Task.Run(() =\u003e { Thread.Sleep(1); MyMethodForCancel(cancellationTokenSource); });\r\n\r\n            try\r\n            {\r\n                Task.WaitAll(MyTask1, MyTask2);\r\n            }\r\n            catch\r\n            {\r\n\r\n            }\r\n\r\n            Console.WriteLine($\"a = {myClass2.a}\"); //a = 50. Always.               \r\n        }\r\n    }\r\n}\r\n```\r\n\r\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOPWwSVg==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc48jZzd",
                                           "createdAt":  "2022-01-18T23:07:22Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "I couldn\u0027t figure out the best area label to add to this issue. If you have write-permissions please help me learn by adding exactly one [area label](https://github.com/dotnet/runtime/blob/master/docs/area-owners.md).",
                                           "updatedAt":  "2022-01-18T23:07:22Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc48jZ3H",
                                           "createdAt":  "2022-01-18T23:07:38Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-threading-tasks\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nAs I understand it, all three static methods in Parallel (For, ForEach and Invoke) create tasks in the background.\r\n\r\nYou can stop creating these tasks with cancel a token inside ParallelOptions.\r\n\r\nI made two simple examples.\r\n\r\nIn the first uses the For method in the second Invoke.\r\n\r\nIn the case of the For method, the behavior is expected, after canceling the token, the creation of new tasks is stopped. In the case of the Invoke method, this does not happen. No matter how many methods I put in the Invoke method, they are always executed after the token is canceled. And I don\u0027t understand why this is happening.\r\n\r\nOn [docs.microsoft.com](https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.parallel.invoke?view=net-6.0) in Parallel.Invoke Method It\u0027s been said:\r\n\r\nThe cancellation token passed in with the ParallelOptions structure enables the caller to cancel the entire operation.\r\n\r\n**Question**: Why in the case of the Invoke method, all tasks are executed and canceling the token does nothing? Or maybe I\u0027m doing something wrong, then tell me what.\r\n\r\n```\r\nusing System;\r\nusing System.Threading;\r\nusing System.Threading.Tasks;\r\n\r\nnamespace ConsoleApp1\r\n{\r\n    class MyClass\r\n    {\r\n        public int a = 0;\r\n        public void Add()\r\n        {\r\n            lock (this)\r\n            {\r\n                Thread.Sleep(100);\r\n                Console.WriteLine($\"Do Add {DateTime.Now}\");\r\n                a++;\r\n            }\r\n        }\r\n    }\r\n\r\n    class Program\r\n    {\r\n        static void Main(string[] args)\r\n        {\r\n            void MyMethodForCancel(CancellationTokenSource cancellationTokenSource)\r\n            {\r\n                Random random = new Random();\r\n\r\n                while (true)\r\n                {\r\n                    if (random.Next(1, 100) == 50)\r\n                    {\r\n                        cancellationTokenSource.Cancel();\r\n                        Console.WriteLine($\"Cancel token {DateTime.Now}\");\r\n                        return;\r\n                    }\r\n                }\r\n            }\r\n\r\n            CancellationTokenSource cancellationTokenSource = new CancellationTokenSource();\r\n            ParallelOptions parallelOptions = new ParallelOptions();\r\n            parallelOptions.CancellationToken = cancellationTokenSource.Token;\r\n\r\n            MyClass myClass2 = new MyClass();\r\n            Action[] actions = new Action[50];\r\n\r\n            for (int i = 0; i \u003c actions.Length; i++)\r\n            {\r\n                actions[i] = myClass2.Add;\r\n            }\r\n\r\n            Task MyTask1 = Task.Run(() =\u003e Parallel.Invoke(parallelOptions, actions));\r\n            Task MyTask2 = Task.Run(() =\u003e { Thread.Sleep(1); MyMethodForCancel(cancellationTokenSource); });\r\n\r\n            try\r\n            {\r\n                Task.WaitAll(MyTask1, MyTask2);\r\n            }\r\n            catch\r\n            {\r\n\r\n            }\r\n\r\n            Console.WriteLine($\"a = {myClass2.a}\"); //a = 50. Always.               \r\n        }\r\n    }\r\n}\r\n```\r\n\r\n\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eNikVladi\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Threading.Tasks`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-01-18T23:07:38Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc48kBoO",
                                           "createdAt":  "2022-01-19T04:43:05Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "NikVladi",
                                           "body":  "Out of curiosity, I created project under the 4.7.2 framework for the x64 target platform. Solution work correctly as expected. \r\nWhat can not be said about .NET 5.0.",
                                           "updatedAt":  "2022-01-19T07:13:03Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc49XLdV",
                                           "createdAt":  "2022-02-03T23:11:46Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "buyaa-n",
                                           "body":  "\u003e In the case of the `For` method, the behavior is expected, after canceling the token, the creation of new tasks is stopped. In the case of the Invoke method, this does not happen. No matter how many methods I put in the Invoke method, they are always executed after the token is canceled. And I don\u0027t understand why this is happening.\r\n\r\nCancellation token works same for `Invoke` method, i assume its just all tasks already have been created/scheduled when the cancellation requested. I would imagine that for the `Paraller.For` case it would create the tasks sequentially starting from `fromInclusive` to `toExclusive`, therefore you can see that it stops creating new tasks with cancellation.\r\n\r\n\u003e Question: Why in the case of the Invoke method, all tasks are executed and canceling the token does nothing? Or maybe I\u0027m doing something wrong, then tell me what.\r\n\r\nI suggest to set the [ParallelOptions.MaxDegreeOfParallelism](https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.paralleloptions.maxdegreeofparallelism?view=net-6.0#system-threading-tasks-paralleloptions-maxdegreeofparallelism) to some value less than 50 within your code to restrict createing all tasks at once, then you will see that task creation stops with cancellation for `Parallel.Invoke`\r\n\r\n",
                                           "updatedAt":  "2022-02-03T23:11:46Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc49XLlF",
                                           "createdAt":  "2022-02-03T23:12:40Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "This issue has been marked `needs-author-action` since it may be missing important information. Please refer to our [contribution guidelines](https://github.com/dotnet/runtime/blob/main/CONTRIBUTING.md#writing-a-good-bug-report) for tips on how to report issues effectively.",
                                           "updatedAt":  "2022-02-03T23:12:40Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc49XNH8",
                                           "createdAt":  "2022-02-03T23:20:38Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "NikVladi",
                                           "body":  "\u003e Cancellation token works same for Invoke method, i assume its just all tasks already have been created/scheduled when the cancellation requested. I would imagine that for the Paraller.For case it would create the tasks sequentially starting from fromInclusive to toExclusive, therefore you can see that it stops creating new tasks with cancellation.\r\n\r\nYou should test your hypothesis by setting the array to 1000 elements. You will see that all 1000 run even on a dual core machine. This method does not stop the initialization of new tasks at all. Setting the MaxDegreeOfParallelism property helps, but the fact remains that if we compare the for, foreach and invoke methods in terms of stopping the initialization of tasks, the invoke method works so that without setting the MaxDegreeOfParallelism property it does not stop the initialization of new tasks at all. In my opinion, this is an obvious bug in the framework.\r\n\r\n\r\n",
                                           "updatedAt":  "2022-02-03T23:21:19Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc49XQgs",
                                           "createdAt":  "2022-02-03T23:47:40Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "buyaa-n",
                                           "body":  "I know it would not stop even for array with 1000 elements, even though for me it makes sense, I don\u0027t think it is a bug. Anyway i would defer this questions to the experts in this area CC @stephentoub",
                                           "updatedAt":  "2022-02-03T23:47:40Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc49bBJW",
                                           "createdAt":  "2022-02-05T01:45:13Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODIXxlA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "StanislavPrusac",
                                                                               "createdAt":  "2023-10-02T14:25:22Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "StanislavPrusac",
                                                                               "createdAt":  "2023-10-02T14:25:27Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "NikVladi",
                                           "body":  "I agree. It would be nice to have an answer:\r\nA) Yes, this is a bug and we will fix it.\r\nB) No, this is not a bug. It\u0027s done on purpose. This is done for the following purpose, it gives the following result.",
                                           "updatedAt":  "2022-02-05T01:45:23Z"
                                       }
                                   ],
                         "totalCount":  8
                     },
        "title":  "Cancel tasks in Parallel.Invoke",
        "labels":  [
                       "question",
                       "area-System.Threading.Tasks",
                       "needs-further-triage"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/66354",
        "createdAt":  "2022-03-08T19:43:40Z",
        "number":  66354,
        "author":  "WizardBrony",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOCSLjEQ==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "grbell-ms",
                                            "createdAt":  "2022-03-09T20:13:41Z"
                                        }
                                    ],
                          "totalCount":  1
                      },
        "updatedAt":  "2022-10-10T19:17:22Z",
        "body":  "There was a recent change made to `Task.DelayPromiseWithCancellation` to invoke any continuations from the task as part of a `Cancel` call asynchronously:\r\n\r\nhttps://github.com/dotnet/runtime/blob/446a0d610d4479fa9ba58ec14a89132a18ed33c4/src/libraries/System.Private.CoreLib/src/System/Threading/Tasks/Task.cs#L5639-L5662\r\n\r\nHowever, there are other APIs that invoke continuations within a `Cancel` call synchronously, including the recently added `Task.CancellationPromise\u003cTResult\u003e` (for use by `Task[\u003cTResult\u003e].WaitAsync`):\r\n\r\nhttps://github.com/dotnet/runtime/blob/446a0d610d4479fa9ba58ec14a89132a18ed33c4/src/libraries/System.Private.CoreLib/src/System/Threading/Tasks/Task.cs#L2823-L2830\r\n\r\nI don\u0027t understand the reason for this discrepancy. Was this just missed, or is there a rationale for APIs like `Task[\u003cTResult\u003e].WaitAsync` to keep invoking continuations in `Cancel` calls synchronously?",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOS-tddA==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc4_TvD9",
                                           "createdAt":  "2022-03-08T19:43:44Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-threading-tasks\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nThere was a recent change made to `Task.DelayPromiseWithCancellation` to invoke any continuations from the task as part of a `Cancel` call asynchronously:\r\n\r\nhttps://github.com/dotnet/runtime/blob/446a0d610d4479fa9ba58ec14a89132a18ed33c4/src/libraries/System.Private.CoreLib/src/System/Threading/Tasks/Task.cs#L5639-L5662\r\n\r\nHowever, there are other APIs that invoke continuations within a `Cancel` call synchronously, including the recently added `Task.CancellationPromise\u003cTResult\u003e` (for use by `Task[\u003cTResult\u003e].WaitAsync`):\r\n\r\nhttps://github.com/dotnet/runtime/blob/446a0d610d4479fa9ba58ec14a89132a18ed33c4/src/libraries/System.Private.CoreLib/src/System/Threading/Tasks/Task.cs#L2823-L2830\r\n\r\nI don\u0027t understand the reason for this discrepancy. Was this just missed, or is there a rationale for APIs like `Task[\u003cTResult\u003e].WaitAsync` to keep invoking continuations in `Cancel` calls synchronously?\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eWizardBrony\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Threading.Tasks`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-03-08T19:43:44Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5L6110",
                                           "createdAt":  "2022-10-10T19:17:22Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "joperezr",
                                           "body":  "cc: @stephentoub ",
                                           "updatedAt":  "2022-10-10T19:17:22Z"
                                       }
                                   ],
                         "totalCount":  2
                     },
        "title":  "Rationale for invoking continuations synchronously vs. asynchronously as part of a call to CancellationTokenSource.Cancel",
        "labels":  [
                       "question",
                       "area-System.Threading.Tasks"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/67392",
        "createdAt":  "2022-03-31T17:05:24Z",
        "number":  67392,
        "author":  "TonyValenti",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOC8YLIw==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Mrxx99",
                                            "createdAt":  "2022-05-30T21:43:53Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "svdHero",
                                            "createdAt":  "2022-06-03T07:12:06Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "julian-di",
                                            "createdAt":  "2022-06-20T08:49:39Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "deeprobin",
                                            "createdAt":  "2022-07-11T09:16:48Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "zs-dima",
                                            "createdAt":  "2022-09-02T13:24:14Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "vahpetr",
                                            "createdAt":  "2022-09-11T11:28:35Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "freistli",
                                            "createdAt":  "2022-10-04T02:18:29Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "reduckted",
                                            "createdAt":  "2022-12-08T06:41:27Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "amnadev",
                                            "createdAt":  "2023-01-16T17:12:22Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "maxreb",
                                            "createdAt":  "2023-02-08T14:25:46Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "nanuthal",
                                            "createdAt":  "2023-02-14T23:27:09Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "RytisLT",
                                            "createdAt":  "2024-02-07T08:40:52Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "ExakisNeliteGBU",
                                            "createdAt":  "2024-02-21T13:06:39Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "macias",
                                            "createdAt":  "2024-03-11T08:15:26Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Slepoyi",
                                            "createdAt":  "2024-10-01T07:22:31Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "olizor",
                                            "createdAt":  "2024-10-08T22:18:07Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "joseluisct",
                                            "createdAt":  "2024-11-04T09:56:04Z"
                                        }
                                    ],
                          "totalCount":  17
                      },
        "updatedAt":  "2022-07-11T19:16:06Z",
        "body":  "### Background and motivation\n\nCurrently there is no way to cancel a Task.WhenAll(..).  It would be great if the current overloads also accepted a cancellation token.\n\n### API Proposal\n\n```C#\r\nnamespace System.Treading.Tasks\r\n{\r\n    public class Task \r\n    {\r\n        public Task WhenAll(IEnumerable\u003cTask\u003e tasks, CancellationToken token);\r\n        public Task WhenAll\u003cTResult\u003e(IEnumerable\u003cTask\u003cTResult\u003e\u003e tasks, CancellationToken token);\r\n    }\r\n}\r\n```\r\n\n\n### API Usage\n\n```C#\r\n// Fancy the value\r\nvar T1 = Task.Run(...);\r\nvar T2 = Task.Run(...);\r\n\r\nawait Task.WhenAll(new[]{T1, T2}, token);\r\n\r\n```\r\n\n\n### Alternative Designs\n\nNone that I can think of.\n\n### Risks\n\nNone",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOQMZ39g==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5AqbCY",
                                           "createdAt":  "2022-03-31T17:05:29Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-threading-tasks\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Background and motivation\n\nCurrently there is no way to cancel a Task.WhenAll(..).  It would be great if the current overloads also accepted a cancellation token.\n\n### API Proposal\n\n```C#\r\nnamespace System.Treading.Tasks\r\n{\r\n    public class Task \r\n    {\r\n        public Task WhenAll(IEnumerable\u003cTask\u003e tasks, CancellationToken token);\r\n        public Task WhenAll\u003cTResult\u003e(IEnumerable\u003cTask\u003cTResult\u003e\u003e tasks, CancellationToken token);\r\n    }\r\n}\r\n```\r\n\n\n### API Usage\n\n```C#\r\n// Fancy the value\r\nvar T1 = Task.Run(...);\r\nvar T2 = Task.Run(...);\r\n\r\nawait Task.WhenAll(new[]{T1, T2}, token);\r\n\r\n```\r\n\n\n### Alternative Designs\n\nNone that I can think of.\n\n### Risks\n\nNone\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eTonyValenti\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`api-suggestion`, `area-System.Threading.Tasks`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-03-31T17:05:29Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5AqvF_",
                                           "createdAt":  "2022-03-31T18:14:28Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOD5S2OA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "TheCodeTraveler",
                                                                               "createdAt":  "2022-10-06T05:29:40Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "xakep139",
                                                                               "createdAt":  "2023-09-01T15:03:45Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "inklesspen1rus",
                                                                               "createdAt":  "2024-08-10T15:04:53Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "joseluisct",
                                                                               "createdAt":  "2024-11-04T09:56:02Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  4
                                                         },
                                           "author":  "theodorzoulias",
                                           "body":  "Isn\u0027t this scenario covered by the [`Task.WaitAsync`](https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.task.waitasync) method?\r\n\r\n```c#\r\nawait Task.WhenAll(T1, T2).WaitAsync(token);\r\n```",
                                           "updatedAt":  "2022-03-31T18:14:28Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5ArkYN",
                                           "createdAt":  "2022-03-31T21:54:38Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "deeprobin",
                                           "body":  "@theodorzoulias \r\nI think so.\r\n\r\nBut should we stay consistent with `Task.WaitAll` and `Task.WaitAny`?\r\nBecause these accept a `CancellationToken`.\r\n\r\nI\u0027m currently just not sure for what reason this makes sense implementation-wise.\r\nYes we could check for cancellation in `TaskFactory.CommonCWAnyLogic` but is that good? I don\u0027t know.",
                                           "updatedAt":  "2022-03-31T21:54:38Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Ar-6H",
                                           "createdAt":  "2022-04-01T00:43:36Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOD5S2hQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "GSPP",
                                                                               "createdAt":  "2022-04-11T07:30:02Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "joseluisct",
                                                                               "createdAt":  "2024-11-04T09:56:31Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "theodorzoulias",
                                           "body":  "@deeprobin a disadvantage of using the `Task.WhenAll`+`WaitAsync` combination is that the continuations attached to the tasks are (most probably) not detached when the token is canceled. So if it\u0027s called repeatedly in a loop, and the tasks are long running, a serious memory leak might emerge.\r\n\r\nHard to imagine a scenario where someone would need to do something like this though.",
                                           "updatedAt":  "2022-04-01T00:43:36Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Auc0n",
                                           "createdAt":  "2022-04-01T13:42:53Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "MihaZupan",
                                           "body":  "\u003e a disadvantage of using the Task.WhenAll+WaitAsync combination is that the continuations attached to the tasks are (most probably) not detached when the token is canceled\r\n\r\nHow would the behavior of `Task.WhenAll(tasks, CT)` overload differ here?\r\n`CancellationToken` uses a cooperative approach, so the work the `Task` represents would have to react to the cancellation token and stop itself. `Task.WhenAll` can\u0027t force an arbitrary task to abort.",
                                           "updatedAt":  "2022-04-01T13:42:53Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5AvI0k",
                                           "createdAt":  "2022-04-01T16:10:48Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "theodorzoulias",
                                           "body":  "\u003e How would the behavior of `Task.WhenAll(tasks, CT)` overload differ here?\r\n\r\n@MihaZupan absolutely no behavioral difference. the `Task.WhenAll(tasks, token)` would behave exactly the same with the `Task.WhenAll(tasks).WaitAsync(token)`. The only difference would be in the memory consumption after a canceled  `await`. The `GC.GetTotalMemory(true)` would return a smaller number.",
                                           "updatedAt":  "2022-04-01T17:02:15Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Axnf2",
                                           "createdAt":  "2022-04-03T00:25:07Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOD5S4mg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "theodorzoulias",
                                                                               "createdAt":  "2022-04-03T00:36:01Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "joseluisct",
                                                                               "createdAt":  "2024-11-04T10:01:07Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e the continuations attached to the tasks are (most probably) not detached when the token is canceled\r\n\r\nThey\u0027re not.  They can\u0027t be.  If they were, it would break a use like:\r\n```C#\r\nTask t = Task.WhenAll(t1, t2);\r\nwhile (true)\r\n{\r\n    try\r\n    {\r\n        await t.WaitAsync(pollInterval);\r\n        break;\r\n    }\r\n    catch {}\r\n\r\n    ... // do something \r\n}\r\n```\r\nas the continuations the WhenAll hooked up to t1 and t2 would then be removed when the first WaitAsync fails, after which point `t` would never complete.",
                                           "updatedAt":  "2022-04-03T00:25:07Z"
                                       }
                                   ],
                         "totalCount":  7
                     },
        "title":  "[API Proposal]: Task.WhenAll(... CancellationToken)",
        "labels":  [
                       "api-suggestion",
                       "area-System.Threading.Tasks"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/71700",
        "createdAt":  "2022-04-29T06:42:46Z",
        "number":  71700,
        "author":  "heathbm",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOClTYjA==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "cremor",
                                            "createdAt":  "2022-05-04T08:56:01Z"
                                        }
                                    ],
                          "totalCount":  1
                      },
        "updatedAt":  "2023-01-20T23:11:17Z",
        "body":  "\u003c!-- Please refer to https://github.com/dotnet/roslyn-analyzers/blob/main/GuidelinesForNewRules.md --\u003e\r\n\r\n### Describe the problem you are trying to solve\r\n\r\n## Issue 1: Code appears correct, however actual outcome can be unexpected:\r\n\r\nAn async lambda `async () =\u003e ...` will resolve to be a `Func\u003cTask\u003e`. \r\nWhen this is provided to a method that only expects an `Action`, the method will treat it as an `Action` with no visible warnings. This can cause unexpected behavior from the perspective of a developer / API consumer.\r\n\r\nThe following example below will fail because `Task.cs` does not have a constructor with a `Func\u003cTask\u003e` parameter, only `Action`: https://github.com/microsoft/referencesource/blob/master/mscorlib/system/threading/Tasks/Task.cs\r\nThe section `Task.Delay(oneSecond)` is not awaited because the `Func\u003cTask\u003e` is treated as an `Action`.\r\n\r\nExample:\r\n\r\n```C#\r\n[Fact]\r\nasync Task TaskStartFails()\r\n{\r\n    int taskProgress = 0;\r\n    var oneSecond = TimeSpan.FromSeconds(1);\r\n\r\n    var aTask = new Task(async () =\u003e\r\n    {\r\n        await Task.Delay(oneSecond);\r\n        Interlocked.Increment(ref taskProgress);\r\n    });\r\n\r\n    aTask.Start();\r\n    await aTask;\r\n\r\n    Assert.Equal(1, taskProgress); // Fail: taskProgress will be 0\r\n}\r\n```\r\n\r\n## Issue 2: Inconsistency:\r\n\r\nThe following example does not compile due to an error.\r\nProviding an async lambda directly and providing a reference to it do not behave consistently as one would expect.\r\n\r\n```C#\r\nusing System;\r\nusing System.Threading.Tasks;\r\n\t\r\npublic class Program\r\n{\r\n    public static void Main()\r\n    {\r\n        OtherMethod(async () =\u003e await Task.Delay(100)); // No errors as it is passed directly and treated as an Action.\r\n\r\n        var anAsyncAnonFunc = async () =\u003e await Task.Delay(100);\r\n        OtherMethod(anAsyncAnonFunc); // Error: CS1503: Argument 1: cannot convert from \u0027System.Func\u003cSystem.Threading.Tasks.Task\u003e\u0027 to \u0027System.Action\u0027\r\n    }\r\n\r\n    static void OtherMethod(Action anAction)\r\n    {\r\n        anAction();\r\n    }\r\n}\r\n```\r\n\r\n\u003c!-- A clear and concise description of what you want to the rule to prevent. --\u003e\r\n\r\n### Describe suggestions on how to achieve the rule\r\n\r\nI believe a warning would be appropriate, along the lines of `Func\u003cTask\u003e is being treated as an Action and will not be awaited.`;\r\n\r\n\u003c!-- A clear description to how to achieve the rule. Suggest how a code-fix could automatically fix the issue/problem --\u003e\r\n\r\n### Additional context\r\n\r\n\u003c!-- Add any other context or screenshots about the rule request here. --\u003e\r\n\r\nNone.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOU2PyNA==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5GFPRq",
                                           "createdAt":  "2022-07-06T04:50:01Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "mavasani",
                                           "body":  "This needs to be triaged by dotnet/runtime. Transferring the issue.",
                                           "updatedAt":  "2022-07-06T04:50:01Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5GFPS0",
                                           "createdAt":  "2022-07-06T04:50:23Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-threading-tasks\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n\u003c!-- Please refer to https://github.com/dotnet/roslyn-analyzers/blob/main/GuidelinesForNewRules.md --\u003e\r\n\r\n### Describe the problem you are trying to solve\r\n\r\n## Issue 1: Code appears correct, however actual outcome can be unexpected:\r\n\r\nAn async lambda `async () =\u003e ...` will resolve to be a `Func\u003cTask\u003e`. \r\nWhen this is provided to a method that only expects an `Action`, the method will treat it as an `Action` with no visible warnings. This can cause unexpected behavior from the perspective of a developer / API consumer.\r\n\r\nThe following example below will fail because `Task.cs` does not have a constructor with a `Func\u003cTask\u003e` parameter, only `Action`: https://github.com/microsoft/referencesource/blob/master/mscorlib/system/threading/Tasks/Task.cs\r\nThe section `Task.Delay(oneSecond)` is not awaited because the `Func\u003cTask\u003e` is treated as an `Action`.\r\n\r\nExample:\r\n\r\n```C#\r\n[Fact]\r\nasync Task TaskStartFails()\r\n{\r\n    int taskProgress = 0;\r\n    var oneSecond = TimeSpan.FromSeconds(1);\r\n\r\n    var aTask = new Task(async () =\u003e\r\n    {\r\n        await Task.Delay(oneSecond);\r\n        Interlocked.Increment(ref taskProgress);\r\n    });\r\n\r\n    aTask.Start();\r\n    await aTask;\r\n\r\n    Assert.Equal(1, taskProgress); // Fail: taskProgress will be 0\r\n}\r\n```\r\n\r\n## Issue 2: Inconsistency:\r\n\r\nThe following example does not compile due to an error.\r\nProviding an async lambda directly and providing a reference to it do not behave consistently as one would expect.\r\n\r\n```C#\r\nusing System;\r\nusing System.Threading.Tasks;\r\n\t\r\npublic class Program\r\n{\r\n    public static void Main()\r\n    {\r\n        OtherMethod(async () =\u003e await Task.Delay(100)); // No errors as it is passed directly and treated as an Action.\r\n\r\n        var anAsyncAnonFunc = async () =\u003e await Task.Delay(100);\r\n        OtherMethod(anAsyncAnonFunc); // Error: CS1503: Argument 1: cannot convert from \u0027System.Func\u003cSystem.Threading.Tasks.Task\u003e\u0027 to \u0027System.Action\u0027\r\n    }\r\n\r\n    static void OtherMethod(Action anAction)\r\n    {\r\n        anAction();\r\n    }\r\n}\r\n```\r\n\r\n\u003c!-- A clear and concise description of what you want to the rule to prevent. --\u003e\r\n\r\n### Describe suggestions on how to achieve the rule\r\n\r\nI believe a warning would be appropriate, along the lines of `Func\u003cTask\u003e is being treated as an Action and will not be awaited.`;\r\n\r\n\u003c!-- A clear description to how to achieve the rule. Suggest how a code-fix could automatically fix the issue/problem --\u003e\r\n\r\n### Additional context\r\n\r\n\u003c!-- Add any other context or screenshots about the rule request here. --\u003e\r\n\r\nNone.\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eheathbm\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Threading.Tasks`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-07-06T04:50:23Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5TY_I0",
                                           "createdAt":  "2023-01-20T23:11:17Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "Is this essentially just asking for a warning whenever a lambda is used as an async void?  The vs-threading analyzer package has such an analyzer:\r\nhttps://github.com/microsoft/vs-threading/blob/main/doc/analyzers/VSTHRD101.md\r\n\r\n@jmarolf, we had some meetings a few years back which I think you were driving, and if I remember correctly, VSTHREAD101 on the list of the few analyzers we were willing to port to roslyn-analyzers from vs-threading.  Did we make progress on that?",
                                           "updatedAt":  "2023-01-20T23:11:17Z"
                                       }
                                   ],
                         "totalCount":  3
                     },
        "title":  "Passing an async lamba and passing a reference to its Func\u003cTask\u003e do not behave the same",
        "labels":  [
                       "api-suggestion",
                       "area-System.Threading.Tasks",
                       "code-analyzer"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/70905",
        "createdAt":  "2022-06-17T17:57:06Z",
        "number":  70905,
        "author":  "carlossanlop",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOCxb1ug==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "xsoheilalizadeh",
                                            "createdAt":  "2022-07-06T07:58:31Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "cremor",
                                            "createdAt":  "2023-07-20T15:46:13Z"
                                        }
                                    ],
                          "totalCount":  2
                      },
        "updatedAt":  "2024-07-31T12:49:41Z",
        "body":  "Sparked from this question: https://github.com/dotnet/runtime/pull/70574#discussion_r900368652 \r\n\r\nExceptions thrown inside methods that return `Task` or `ValueTask` should be wrapped by `Task.FromException`, except if they are `ArgumentNullException` or `ArgumentException`.\r\n\r\nIf the method is marked as `async`, we could also `await` the `Task.FromException`.\r\n\r\nSuggested category: Reliability\r\nSuggested level: Warning (Same as [CA2007](https://docs.microsoft.com/en-us/dotnet/fundamentals/code-analysis/quality-rules/ca2007))\r\nSuggested milestone: 8.0\r\n\r\n## Examples\r\n\r\n### Method that returns Task\r\n#### Before\r\n```cs\r\n// Task\r\nprivate Task MyMethodAsync(string arg, CancellationToken cancellationToken)\r\n{\r\n    ArgumentException.ThrowIfNullOrEmpty(arg);\r\n    if (/* some condition */)\r\n    {\r\n        throw new InvalidOperationException(\"Some message\");\r\n    }\r\n    return SomethingAsync(cancellationToken);\r\n}\r\n\r\n// async Task\r\nprivate async Task MyMethodAsync(string arg, CancellationToken cancellationToken)\r\n{\r\n    ArgumentException.ThrowIfNullOrEmpty(arg);\r\n    if (/* some condition */)\r\n    {\r\n        throw new InvalidOperationException(\"Some message\");\r\n    }\r\n    await SomethingAsync(cancellationToken).ConfigureAwait(false);\r\n}\r\n```\r\n#### After\r\n```cs\r\n// Task\r\nprivate Task MyMethodAsync(string arg, CancellationToken cancellationToken)\r\n{\r\n    ArgumentException.ThrowIfNullOrEmpty(arg); // Do not change this\r\n    if (/* some condition */)\r\n    {\r\n        return Task.FromException(new InvalidOperationException(\"Some message\")); // wrap this\r\n    }\r\n    return SomethingAsync(cancellationToken);\r\n}\r\n\r\n// async Task\r\nprivate Task MyMethodAsync(string arg, CancellationToken cancellationToken)\r\n{\r\n    ArgumentException.ThrowIfNullOrEmpty(arg); // Do not change this\r\n    if (/* some condition */)\r\n    {\r\n        // wrap this, await it, but don\u0027t add ConfigureAwait(false), that should be added by CA2007 separately\r\n        await Task.FromException(new InvalidOperationException(\"Some message\"));\r\n    }\r\n    await SomethingAsync(cancellationToken).ConfigureAwait(false);\r\n}\r\n```\r\n\r\n\r\n### Method that returns ValueTask\r\n#### Before\r\n```cs\r\n// ValueTask\r\nprivate ValueTask MyMethodAsync(string arg, CancellationToken cancellationToken)\r\n{\r\n    ArgumentException.ThrowIfNullOrEmpty(arg);\r\n    if (/* some condition */)\r\n    {\r\n        throw new InvalidOperationException(\"Some message\");\r\n    }\r\n    return SomethingAsync(cancellationToken);\r\n}\r\n\r\n// async ValueTask\r\nprivate async ValueTask MyMethodAsync(string arg, CancellationToken cancellationToken)\r\n{\r\n    ArgumentException.ThrowIfNullOrEmpty(arg);\r\n    if (/* some condition */)\r\n    {\r\n        throw new InvalidOperationException(\"Some message\");\r\n    }\r\n    await SomethingAsync(cancellationToken).ConfigureAwait(false);\r\n}\r\n```\r\n#### After\r\n```cs\r\nprivate ValueTask MyMethodAsync(string arg, CancellationToken cancellationToken)\r\n{\r\n    ArgumentException.ThrowIfNullOrEmpty(arg); // Do not change this\r\n    if (/* some condition */)\r\n    {\r\n        return ValueTask.FromException(new InvalidOperationException(\"Some message\")); // wrap this\r\n    }\r\n    return SomethingAsync(cancellationToken);\r\n}\r\n\r\n// async ValueTask\r\nprivate async ValueTask MyMethodAsync(string arg, CancellationToken cancellationToken)\r\n{\r\n    ArgumentException.ThrowIfNullOrEmpty(arg);\r\n    if (/* some condition */)\r\n    {\r\n        // wrap this, await it, but don\u0027t add ConfigureAwait(false), that should be added by CA2007 separately\r\n        await ValueTask.FromException(new InvalidOperationException(\"Some message\"));\r\n    }\r\n    await SomethingAsync(cancellationToken).ConfigureAwait(false);\r\n}\r\n```\r\n\r\ncc @buyaa-n ",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOhrurKA==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5FFqbd",
                                           "createdAt":  "2022-06-17T17:57:26Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-threading-tasks\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nSparked from this question: https://github.com/dotnet/runtime/pull/70574#discussion_r900368652 \r\n\r\nExceptions thrown inside methods that return `Task` or `ValueTask` should be wrapped by `Task.FromException`, except if they are `ArgumentNullException` or `ArgumentException`.\r\n\r\nIf the method is marked as `async`, we could also `await` the `Task.FromException`.\r\n\r\nSuggested category: Reliability\r\nSuggested level: Warning (Same as [CA2007](https://docs.microsoft.com/en-us/dotnet/fundamentals/code-analysis/quality-rules/ca2007))\r\nSuggested milestone: 8.0\r\n\r\n## Examples\r\n\r\n### Method that returns Task\r\n#### Before\r\n```cs\r\n// Task\r\nprivate Task MyMethodAsync(string arg, CancellationToken cancellationToken)\r\n{\r\n    ArgumentException.ThrowIfNullOrEmpty(arg);\r\n    if (/* some condition */)\r\n    {\r\n        throw new InvalidOperationException(\"Some message\");\r\n    }\r\n    return SomethingAsync(cancellationToken);\r\n}\r\n\r\n// async Task\r\nprivate async Task MyMethodAsync(string arg, CancellationToken cancellationToken)\r\n{\r\n    ArgumentException.ThrowIfNullOrEmpty(arg);\r\n    if (/* some condition */)\r\n    {\r\n        throw new InvalidOperationException(\"Some message\");\r\n    }\r\n    await SomethingAsync(cancellationToken).ConfigureAwait(false);\r\n}\r\n```\r\n#### After\r\n```cs\r\n// Task\r\nprivate Task MyMethodAsync(string arg, CancellationToken cancellationToken)\r\n{\r\n    ArgumentException.ThrowIfNullOrEmpty(arg); // Do not change this\r\n    if (/* some condition */)\r\n    {\r\n        return Task.FromException(new InvalidOperationException(\"Some message\")); // wrap this\r\n    }\r\n    return SomethingAsync(cancellationToken);\r\n}\r\n\r\n// async Task\r\nprivate Task MyMethodAsync(string arg, CancellationToken cancellationToken)\r\n{\r\n    ArgumentException.ThrowIfNullOrEmpty(arg); // Do not change this\r\n    if (/* some condition */)\r\n    {\r\n        // wrap this, await it, but don\u0027t add ConfigureAwait(false), that should be added by CA2007 separately\r\n        await Task.FromException(new InvalidOperationException(\"Some message\"));\r\n    }\r\n    await SomethingAsync(cancellationToken).ConfigureAwait(false);\r\n}\r\n```\r\n\r\n\r\n### Method that returns ValueTask\r\n#### Before\r\n```cs\r\n// ValueTask\r\nprivate ValueTask MyMethodAsync(string arg, CancellationToken cancellationToken)\r\n{\r\n    ArgumentException.ThrowIfNullOrEmpty(arg);\r\n    if (/* some condition */)\r\n    {\r\n        throw new InvalidOperationException(\"Some message\");\r\n    }\r\n    return SomethingAsync(cancellationToken);\r\n}\r\n\r\n// async ValueTask\r\nprivate async ValueTask MyMethodAsync(string arg, CancellationToken cancellationToken)\r\n{\r\n    ArgumentException.ThrowIfNullOrEmpty(arg);\r\n    if (/* some condition */)\r\n    {\r\n        throw new InvalidOperationException(\"Some message\");\r\n    }\r\n    await SomethingAsync(cancellationToken).ConfigureAwait(false);\r\n}\r\n```\r\n#### After\r\n```cs\r\nprivate ValueTask MyMethodAsync(string arg, CancellationToken cancellationToken)\r\n{\r\n    ArgumentException.ThrowIfNullOrEmpty(arg); // Do not change this\r\n    if (/* some condition */)\r\n    {\r\n        return ValueTask.FromException(new InvalidOperationException(\"Some message\")); // wrap this\r\n    }\r\n    return SomethingAsync(cancellationToken);\r\n}\r\n\r\n// async ValueTask\r\nprivate async ValueTask MyMethodAsync(string arg, CancellationToken cancellationToken)\r\n{\r\n    ArgumentException.ThrowIfNullOrEmpty(arg);\r\n    if (/* some condition */)\r\n    {\r\n        // wrap this, await it, but don\u0027t add ConfigureAwait(false), that should be added by CA2007 separately\r\n        await ValueTask.FromException(new InvalidOperationException(\"Some message\"));\r\n    }\r\n    await SomethingAsync(cancellationToken).ConfigureAwait(false);\r\n}\r\n```\r\n\r\ncc @buyaa-n \n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003ecarlossanlop\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`api-suggestion`, `area-System.Threading.Tasks`, `code-analyzer`, `code-fixer`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e8.0.0\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-06-17T17:57:26Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5FFrlE",
                                           "createdAt":  "2022-06-17T18:04:34Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODBUFQA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "f1nzer",
                                                                               "createdAt":  "2022-06-18T13:06:18Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Joelius300",
                                                                               "createdAt":  "2022-06-19T07:43:01Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "theodorzoulias",
                                                                               "createdAt":  "2022-06-19T19:08:48Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "rjgotten",
                                                                               "createdAt":  "2022-06-22T13:31:40Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "cremor",
                                                                               "createdAt":  "2023-07-20T15:53:06Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  5
                                                         },
                                           "author":  "bartonjs",
                                           "body":  "If the method is built with the `async` keyword, then any throws are already wrapped by the task(-like) that was returned (which is wrong for argument validation, and why argument validation should be in a non-`async`-keyword wrapper call).\r\n\r\n`await Task.FromException(...)` is unnecessary (and probably an anti-pattern)",
                                           "updatedAt":  "2022-06-17T18:04:34Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5PS5en",
                                           "createdAt":  "2022-11-29T09:44:39Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "carlreinke",
                                           "body":  "\u003e argument validation should be in a non-`async`-keyword wrapper call\r\n\r\nSeems like there could be an analyzer for this. Or does that already exist?",
                                           "updatedAt":  "2022-11-29T09:44:39Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5TY-F2",
                                           "createdAt":  "2023-01-20T23:06:01Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "I\u0027ve marked this as ready for review, but I suspect we\u0027re going to find it\u0027s a bit noisy.  If this is approved, whoever tackles it will likely need to do a bit of work to tune the rule to get it to the point where it can be on by default in runtime.",
                                           "updatedAt":  "2023-01-20T23:06:01Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5ThuP5",
                                           "createdAt":  "2023-01-24T03:25:45Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "(It\u0027s also very likely to have a lot of false negatives, due to exceptions getting thrown indirectly via method calls.)",
                                           "updatedAt":  "2023-01-24T03:25:45Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5XLntj",
                                           "createdAt":  "2023-03-09T19:35:57Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "terrajobst",
                                           "body":  "[Video](https://www.youtube.com/watch?v=-MBZGdnYPGA\u0026t=1h2m11s)\n\n* Seems reasonable. We should have a list of exceptions for which we don\u0027t warn (exceptions derived from `ArgumentException` for instance).\r\n* Should not apply to methods marked `async`\r\n\r\n**Category**: Reliability\r\n**Severity**: Warning",
                                           "updatedAt":  "2023-03-09T20:05:40Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6Gu6so",
                                           "createdAt":  "2024-07-31T12:48:19Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "rjgotten",
                                           "body":  "\u003e If the method is built with the `async` keyword, then any throws are already wrapped by the task(-like) that was returned (which is wrong for argument validation, and why argument validation should be in a non-`async`-keyword wrapper call).\r\n\r\nOne could just as easily argue that it\u0027s bad and may catch users off guard, and require them to handle both asynchronous and synchronous exceptions, instead of just asynchronous.\r\n\r\nWhich in fact are two bullet points that come up in other async guidance communicated for ASP.NET Core applications by e.g. David Fowl, in the context of preferring `async`-`await` over directly returning `Task` instances: https://github.com/davidfowl/AspNetCoreDiagnosticScenarios/blob/master/AsyncGuidance.md#prefer-asyncawait-over-directly-returning-task\r\n\r\nSetting up wrapping methods that synchronously throw on argument exceptions also fall afoul of exactly this guidance, because the way it\u0027s implemented is a task-returning method which is not async-await, but delegates to one that is.\r\n\r\nI.e. there\u0027s no cut and dry single point of view that applies here.\r\n",
                                           "updatedAt":  "2024-07-31T12:49:41Z"
                                       }
                                   ],
                         "totalCount":  7
                     },
        "title":  "[Analyzer/fixer suggestion]: Exceptions thrown inside async methods should be wrapped by Task.FromException",
        "labels":  [
                       "api-approved",
                       "area-System.Threading.Tasks",
                       "help wanted",
                       "code-analyzer",
                       "code-fixer"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/71415",
        "createdAt":  "2022-06-29T02:06:50Z",
        "number":  71415,
        "author":  "theodorzoulias",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2022-07-06T17:19:45Z",
        "body":  "### Description\r\n\r\nHi! I am trying to run a [`Parallel.ForEachAsync`](https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.parallel.foreachasync) loop on the UI thread of a WinForms application, in order to update a `TextBox` as part of the asynchronous operation. For this purpose I am configuring the loop with a [`TaskScheduler.FromCurrentSynchronizationContext`](https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.taskscheduler.fromcurrentsynchronizationcontext) scheduler, as suggested in [this](https://github.com/dotnet/runtime/pull/46943#issuecomment-766390401) comment (by @stephentoub):\r\n\r\n\u003e Ah, you\u0027re trying to overlap the awaits but run all work on the UI thread.\r\n\u003e \r\n\u003e TaskScheduler and SychronizationContext are both effectively schedulers, so when there\u0027s work to be queued, really only one can be used. If what you want is for all scheduling to be back to the original SynchronizationContext, try using TaskScheduler.FromCurrentSynchronizationContext.\r\n\r\nUnfortunately by doing so I witnessed that the level of concurrency of the asynchronous operations is reduced to one. My [`ParallelOptions.MaxDegreeOfParallelism`](https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.paralleloptions.maxdegreeofparallelism) configuration is effectively overruled.\r\n\r\n### Reproduction Steps\r\n\r\n```C#\r\nprivate async void button1_Click(object sender, EventArgs e)\r\n{\r\n    ParallelOptions options = new()\r\n    {\r\n        MaxDegreeOfParallelism = 2,\r\n        TaskScheduler = TaskScheduler.FromCurrentSynchronizationContext()\r\n    };\r\n\r\n    textBox1.AppendText(@$\"MaxDegreeOfParallelism: {options\r\n        .MaxDegreeOfParallelism}, MaximumConcurrencyLevel: {options\r\n        .TaskScheduler.MaximumConcurrencyLevel}\" + \"\\r\\n\\r\\n\");\r\n\r\n    await Parallel.ForEachAsync(Enumerable.Range(1, 5), options, async (x, _) =\u003e\r\n    {\r\n        textBox1.AppendText($\"Processing #{x}\\r\\n\");\r\n        await Task.Delay(200); // Simulate an I/O-bound operation.\r\n        textBox1.AppendText($\"Completed #{x}\\r\\n\");\r\n    });\r\n    MessageBox.Show(\"Done!\");\r\n}\r\n```\r\n\r\n[Online demo](https://dotnetfiddle.net/U2iSRp).\r\n\r\n### Expected behavior\r\n\r\nTwo items should be processed concurrently at the same time.\r\n\r\n```none\r\nMaxDegreeOfParallelism: 2, MaximumConcurrencyLevel: 1\r\n\r\nProcessing #1\r\nProcessing #2\r\nCompleted #1\r\nCompleted #2\r\nProcessing #3\r\nProcessing #4\r\nCompleted #3\r\nCompleted #4\r\nProcessing #5\r\nCompleted #5\r\n```\r\n\r\n### Actual behavior\r\n\r\nThe items are processed sequentially, one item at a time.\r\n\r\n\u003cimg width=\"271\" alt=\"WinFormsApp1_Screenshot\" src=\"https://user-images.githubusercontent.com/48834899/176330513-6bbbb710-41bc-4c58-9787-69e93b3e727a.png\"\u003e\r\n\r\n```none\r\nMaxDegreeOfParallelism: 2, MaximumConcurrencyLevel: 1\r\n\r\nProcessing #1\r\nCompleted #1\r\nProcessing #2\r\nCompleted #2\r\nProcessing #3\r\nCompleted #3\r\nProcessing #4\r\nCompleted #4\r\nProcessing #5\r\nCompleted #5\r\n```\r\n\r\n### Regression?\r\n\r\nThe `Parallel.ForEachAsync` API was introduced in the latest .NET release (.NET 6). So no regression.\r\n\r\n### Known Workarounds\r\n\r\nDon\u0027t use the `ParallelOptions.TaskScheduler`, and create new tasks with `Task.Factory.StartNew` inside the `body` delegate.\r\n\r\n### Configuration\r\n\r\n- .NET 6.0\r\n- WinForms application\r\n- Release built\r\n- 64-bit operating system, x64-based processor\r\n\r\n### Other information\r\n\r\nIn the TPL Dataflow library, the [`ExecutionDataflowBlockOptions`](https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.dataflow.executiondataflowblockoptions) class has also `TaskScheduler` and `MaxDegreeOfParallelism` properties, that according to my experiments are behaving as expected (they don\u0027t interfere with each other).\r\n\r\nCorrecting this behavior will also allow to configure independently the maximum concurrency (number of async operations) and the maximum parallelism (number of threads), of a parallel loop. The number of threads will be configurable by setting the `ParallelOptions.TaskScheduler` to an instance of the [`ConcurrentExclusiveSchedulerPair`](https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.concurrentexclusiveschedulerpair) class:\r\n\r\n```C#\r\noptions.TaskScheduler = new ConcurrentExclusiveSchedulerPair(\r\n    TaskScheduler.Default, maxConcurrencyLevel: 2).ConcurrentScheduler;\r\n```\r\n\r\nFor this to work, there should be no `.ConfigureAwait(false)` inside the `body` delegate.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHORdk3fw==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5FtHay",
                                           "createdAt":  "2022-06-29T02:07:02Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-threading-tasks\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Description\r\n\r\nHi! I am trying to run a [`Parallel.ForEachAsync`](https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.parallel.foreachasync) loop on the UI thread of a WinForms application, in order to update a `TextBox` as part of the asynchronous operation. For this purpose I am configuring the loop with a [`TaskScheduler.FromCurrentSynchronizationContext`](https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.taskscheduler.fromcurrentsynchronizationcontext) scheduler, as suggested in [this](https://github.com/dotnet/runtime/pull/46943#issuecomment-766390401) comment (by @stephentoub):\r\n\r\n\u003e Ah, you\u0027re trying to overlap the awaits but run all work on the UI thread.\r\n\u003e \r\n\u003e TaskScheduler and SychronizationContext are both effectively schedulers, so when there\u0027s work to be queued, really only one can be used. If what you want is for all scheduling to be back to the original SynchronizationContext, try using TaskScheduler.FromCurrentSynchronizationContext.\r\n\r\nUnfortunately by doing so I witnessed that the level of concurrency of the asynchronous operations is reduced to one. My [`ParallelOptions.MaxDegreeOfParallelism`](https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.paralleloptions.maxdegreeofparallelism) configuration is effectively overruled.\r\n\r\n### Reproduction Steps\r\n\r\n```C#\r\nprivate async void button1_Click(object sender, EventArgs e)\r\n{\r\n    ParallelOptions options = new()\r\n    {\r\n        MaxDegreeOfParallelism = 2,\r\n        TaskScheduler = TaskScheduler.FromCurrentSynchronizationContext()\r\n    };\r\n\r\n    textBox1.AppendText(@$\"MaxDegreeOfParallelism: {options\r\n        .MaxDegreeOfParallelism}, MaximumConcurrencyLevel: {options\r\n        .TaskScheduler.MaximumConcurrencyLevel}\" + \"\\r\\n\\r\\n\");\r\n\r\n    await Parallel.ForEachAsync(Enumerable.Range(1, 5), options, async (x, _) =\u003e\r\n    {\r\n        textBox1.AppendText($\"Processing #{x}\\r\\n\");\r\n        await Task.Delay(200); // Simulate an I/O-bound operation.\r\n        textBox1.AppendText($\"Completed #{x}\\r\\n\");\r\n    });\r\n    MessageBox.Show(\"Done!\");\r\n}\r\n```\r\n\r\n[Online demo](https://dotnetfiddle.net/U2iSRp).\r\n\r\n### Expected behavior\r\n\r\nTwo items should be processed concurrently at the same time.\r\n\r\n```none\r\nMaxDegreeOfParallelism: 2, MaximumConcurrencyLevel: 1\r\n\r\nProcessing #1\r\nProcessing #2\r\nCompleted #1\r\nCompleted #2\r\nProcessing #3\r\nProcessing #4\r\nCompleted #3\r\nCompleted #4\r\nProcessing #5\r\nCompleted #5\r\n```\r\n\r\n### Actual behavior\r\n\r\nThe items are processed sequentially, one item at a time.\r\n\r\n\u003cimg width=\"271\" alt=\"WinFormsApp1_Screenshot\" src=\"https://user-images.githubusercontent.com/48834899/176330513-6bbbb710-41bc-4c58-9787-69e93b3e727a.png\"\u003e\r\n\r\n```none\r\nMaxDegreeOfParallelism: 2, MaximumConcurrencyLevel: 1\r\n\r\nProcessing #1\r\nCompleted #1\r\nProcessing #2\r\nCompleted #2\r\nProcessing #3\r\nCompleted #3\r\nProcessing #4\r\nCompleted #4\r\nProcessing #5\r\nCompleted #5\r\n```\r\n\r\n### Regression?\r\n\r\nThe `Parallel.ForEachAsync` API was introduced in the latest .NET release (.NET 6). So no regression.\r\n\r\n### Known Workarounds\r\n\r\nDon\u0027t use the `ParallelOptions.TaskScheduler`, and create new tasks with `Task.Factory.StartNew` inside the `body` delegate.\r\n\r\n### Configuration\r\n\r\n- .NET 6.0\r\n- WinForms application\r\n- Release built\r\n- 64-bit operating system, x64-based processor\r\n\r\n### Other information\r\n\r\nCorrecting this behavior will also allow to configure independently the maximum concurrency (number of async operations) and the maximum parallelism (number of threads), of a parallel loop. The number of threads will be configurable by setting the `ParallelOptions.TaskScheduler` to an instance of the [`ConcurrentExclusiveSchedulerPair`](https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.concurrentexclusiveschedulerpair) class:\r\n\r\n```C#\r\noptions.TaskScheduler = new ConcurrentExclusiveSchedulerPair(\r\n    TaskScheduler.Default, maxConcurrencyLevel: 2).ConcurrentScheduler;\r\n```\r\n\r\nFor this to work, there should be no `.ConfigureAwait(false)` inside the `body` delegate.\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003etheodorzoulias\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Threading.Tasks`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-06-29T02:07:02Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5FtKEk",
                                           "createdAt":  "2022-06-29T02:29:06Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "This is by design. A TaskScheduler-derived type can override MaxConcurrencyLevel to limit any degree of parallelism supplied to a Parallel loop, and the TaskScheduler returned from FromCurrentSynchronizationContext returns 1. If you need a different value, you can provide your own custom scheduler to do whatever you like. All that scheduler does is call SynchronizationContext.Post to execute the task. ",
                                           "updatedAt":  "2022-06-29T02:29:06Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5FtTNO",
                                           "createdAt":  "2022-06-29T03:47:55Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCkVzmQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "mayorovp",
                                                                               "createdAt":  "2022-06-29T12:17:00Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "theodorzoulias",
                                           "body":  "Hi @stephentoub! Thanks for the quick feedback. I can understand the existing behavior for the synchronous `Parallel.ForEach` API, but does it make sense for the asynchronous `Parallel.ForEachAsync` too? My understanding is that this method is intended for mostly asynchronous workloads. An asynchronous operation that has been launched and is in-flight does not use threads, so why is the `MaxDegreeOfParallelism` overruled by the `MaxConcurrencyLevel` of the scheduler? Schedulers are all about threads. When it comes to asynchrony, they are pretty much unaware of what\u0027s happening above them.\r\n\r\nLook at the TPL Dataflow for example, that AFAIK was async-enabled from the beginning. There is no such interference there.",
                                           "updatedAt":  "2022-06-29T03:47:55Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5FxKKj",
                                           "createdAt":  "2022-06-29T21:33:56Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e My understanding is that this method is intended for mostly asynchronous workloads.\r\n\r\nIt\u0027s for workloads that involve async I/O, either in the retrieval of data to process or in the processing itself, but that doesn\u0027t mean it\u0027s dominated by I/O.\r\n\r\n\u003e Look at the TPL Dataflow for example, that AFAIK was async-enabled from the beginning. There is no such interference there.\r\n\r\nPlenty of what Dataflow does is schedule synchronous work. Not respecting MaximumConcurrencyLevel is a bug we long ago decided not to address.\r\n\r\n\u003e does it make sense for the asynchronous Parallel.ForEachAsync too?\r\n\r\nIt\u0027s a trivial change, basically in this line (and one other):\r\nhttps://github.com/dotnet/runtime/blob/844b0999fde67cdbaa7acb0f398ea1b066a2b8c7/src/libraries/System.Threading.Tasks.Parallel/src/System/Threading/Tasks/Parallel.ForEachAsync.cs#L55\r\nthe `parallelOptions.EffectiveMaxConcurrencyLevel` would be changed to `parallelOptions.MaxDegreeOfParallelism`.  I\u0027m just not sure it\u0027s the right change, as it could end up inundating the scheduler (the UI thread in your case) with lots of work items due to unnecessary partitioning.\r\n\r\nI don\u0027t feel strongly about the design decision, but what it does today is consistent with the rest of the Parallel APIs, and if it\u0027s really an issue for you, as I mentioned you can easily avoid the issue with your own scheduler, e.g.\r\n```C#\r\ninternal sealed class SyncCtxScheduler : TaskScheduler\r\n{\r\n    private readonly SynchronizationContext _ctx;\r\n    public SyncCtxScheduler(SynchronizationContext ctx) =\u003e _ctx = ctx;\r\n    protected override void QueueTask(Task task) =\u003e _ctx.Post(s =\u003e TryExecuteTask((Task)s), task);\r\n    protected override bool TryExecuteTaskInline(Task task, bool taskWasPreviouslyQueued) =\u003e  SynchronizationContext.Current == _ctx ? TryExecuteTask(task) : false;\r\n    protected override IEnumerable\u003cTask\u003e? GetScheduledTasks() =\u003e null;\r\n}\r\n```",
                                           "updatedAt":  "2022-06-29T21:33:56Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5F2Td_",
                                           "createdAt":  "2022-07-01T02:37:02Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "theodorzoulias",
                                           "body":  "\u003e Plenty of what Dataflow does is schedule synchronous work. Not respecting MaximumConcurrencyLevel is a bug we long ago decided not to address.\r\n\r\n@stephentoub interesting. Personally I have used to my advantage that I can configure independently the `MaxDegreeOfParallelism` and `MaximumConcurrencyLevel` in the TPL Dataflow, in at least two occasions. It didn\u0027t pass through my mind that I was exploiting a bug!\r\n\r\n\u003e I don\u0027t feel strongly about the design decision, but what it does today is consistent with the rest of the Parallel APIs, and if it\u0027s really an issue for you, as I mentioned you can easily avoid the issue with your own scheduler, e.g.\r\n\r\nThe point is that when we talk about the synchronous `Parallel` APIs, choosing between the two designs doesn\u0027t matter. The scheduler itself will enforce its de facto concurrency level, and the `MaxDegreeOfParallelism` being either equal or larger will not make any difference. That\u0027s because everything runs on the scheduler\u0027s threads. There is no asynchronous dimension in that case.\r\n\r\nAs a proof I used the `SyncCtxScheduler` class in a demo similar to the original, switching only from `Parallel.ForEachAsync` to `Parallel.ForEach`. [Here](https://dotnetfiddle.net/bJaLXN) is the demo, and here is the output:\r\n\r\n\u003cimg width=\"264\" alt=\"ParallelForEach_SyncCtxScheduler\" src=\"https://user-images.githubusercontent.com/48834899/176811920-59ea0b64-13d9-4ed4-84fb-96ccfbf99878.png\"\u003e\r\n\r\nAlthough the `SyncCtxScheduler` fakes an unlimited concurrency level, the processing is serialized because it\u0027s happening on the UI thread.\r\n\r\nAre there any scenarios that I am missing, where changing the design would affect the synchronous `Parallel` APIs?",
                                           "updatedAt":  "2022-07-01T02:37:02Z"
                                       }
                                   ],
                         "totalCount":  5
                     },
        "title":  "Parallel.ForEachAsync the TaskScheduler and MaxDegreeOfParallelism options interfere with each other",
        "labels":  [
                       "area-System.Threading.Tasks"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/74966",
        "createdAt":  "2022-09-01T22:16:46Z",
        "number":  74966,
        "author":  "trampster",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-03-04T18:08:41Z",
        "body":  "EDITED by @stephentoub on 1/20/2023:\r\nThe issue at this point tracks an analyzer that would flag use of GC.KeepAlive(local) usage in the context of C# iterators, async methods, and anywhere else the C# compiler does a significant method rewrite such that a \"local\" isn\u0027t actually local, e.g. where that local is lifted to a state machine and the use of GC.KeepAlive has little to no impact, e.g.\r\n```C#\r\nobject o = new object();\r\nyield return o;\r\nGC.KeepAlive(o);\r\n```\r\n\r\n---\r\n\r\n### Description\r\n\r\nAccording to Eric Lippert there is no need to pin a local delegate or keep a GCHandle when passing a delegate via PInvoke as long as you use GC.KeepAlive to keep the delegate alive for as long as the native code could call it. https://stackoverflow.com/a/5465380/78561\r\n\r\nHowever while this seems to be true for the dotnet runtime in mono this does not work and we are getting crashes when the callback happens.\r\n\r\nWe have found that in mono we need to keep a Normal GCHandle to the delegate GC.KeepAlive does not seem to be enough.\r\n\r\nThis behaviour needs to be consistent across the mono/dotnet runtimes.\r\n\r\nThis issue was found when using Xamarin.Android\r\n\r\n### Reproduction Steps\r\n\r\n```\r\nvar taskCompletionSource = new TaskCompletionSource();\r\n\r\nMyDelegateType myDelegate = () =\u003e taskCompletionSource.SetResult(true);\r\n\r\nNativeMethods.MyNativeMethod(myDelegate);\r\n\r\nawait taskCompletionSource.Task;\r\n\r\nGC.KeepAlive(myDelegate);\r\n```\r\n\r\n\r\n\r\n### Expected behavior\r\n\r\nGC.KeepAlive should prevent the delegate from being collected until the delegate callback has happened.\r\n\r\n### Actual behavior\r\n\r\nCrash, usually with NullReferenceException\r\n\r\n### Regression?\r\n\r\n_No response_\r\n\r\n### Known Workarounds\r\n\r\nGet a normal GCHandle to the delegate instead of using GC.KeepAlive\r\n\r\n```\r\nvar taskCompletionSource = new TaskCompletionSource();\r\n\r\nMyDelegateType myDelegate = () =\u003e taskCompletionSource.SetResult(true);\r\n\r\nvar gcHandle = GCHandle.Alloc(myDelegate, GCHandleType.Normal);\r\n\r\nNativeMethods.MyNativeMethod(myDelegate);\r\n\r\nawait taskCompletionSource.Task;\r\n\r\ngcHandle.Free();\r\n```\r\n\r\n### Configuration\r\n\r\n_No response_\r\n\r\n### Other information\r\n\r\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOX5Af5A==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5Jmjhg",
                                           "createdAt":  "2022-09-01T22:16:54Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-threading-tasks\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Description\n\nAccording to Eric Lippert there is no need to pin a local delegate or keep a GCHandle when passing a delegate via PInvoke as long as you use GC.KeepAlive to keep the delegate alive for as long as the native code could call it. https://stackoverflow.com/a/5465380/78561\r\n\r\nHowever while this seems to be true for the dotnet runtime in mono this does not work and we are getting crashes when the callback happens.\r\n\r\nWe have found that in mono we need to keep a Normal GCHandle to the delegate GC.KeepAlive does not seem to be enough.\r\n\r\nThis behaviour need to be consistent across the mono/dotnet runtimes.\r\n\r\nThis issue was found when using Xamarin.Android\n\n### Reproduction Steps\n\n```\r\nvar taskCompletionSource = new TaskCompletionSource();\r\n\r\nvar myDelegate = () =\u003e taskCompletionSource.SetResult(true);\r\n\r\nvar taskCompletionSource = new TaskCompletionSource();\r\n\r\nvar myDelegate = () =\u003e taskCompletionSource.SetResult(true);\r\n\r\nNativeMethods.MyNativeMethod(myDelegate);\r\n\r\nawait taskCompletionSource.Task;\r\n\r\nNativeMethods.MyNativeMethod(myDelegate);\r\n\r\nawait taskCompletionSource.Task;\r\n\r\nGC.KeepAlive(myDelegate);\r\n```\r\n\r\n\n\n### Expected behavior\n\nGC.KeepAlive should prevent the delegate from being collected until the delegate callback has happened.\n\n### Actual behavior\n\nCrash, usually with NullReferenceException\n\n### Regression?\n\n_No response_\n\n### Known Workarounds\n\nGet a normal GCHandle to the delegate instead of using GC.KeepAlive\r\n\r\n```\r\nvar taskCompletionSource = new TaskCompletionSource();\r\n\r\nMyDelegateType myDelegate = () =\u003e taskCompletionSource.SetResult(true);\r\n\r\nvar gcHandle = GCHandle.Alloc(myDelegate, GCHandleType.Normal);\r\n\r\nvar taskCompletionSource = new TaskCompletionSource();\r\n\r\nvar myDelegate = () =\u003e taskCompletionSource.SetResult(true);\r\n\r\nNativeMethods.MyNativeMethod(myDelegate);\r\n\r\nawait taskCompletionSource.Task;\r\n\r\nNativeMethods.MyNativeMethod(myDelegate);\r\n\r\nawait taskCompletionSource.Task;\r\n\r\ngcHandle.Free();\r\n```\n\n### Configuration\n\n_No response_\n\n### Other information\n\n_No response_\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003etrampster\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Threading.Tasks`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-09-01T22:16:54Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5JmmDD",
                                           "createdAt":  "2022-09-01T22:32:56Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to \u0027arch-android\u0027: @steveisok, @akoeplinger\nSee info in area-owners.md if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Description\r\n\r\nAccording to Eric Lippert there is no need to pin a local delegate or keep a GCHandle when passing a delegate via PInvoke as long as you use GC.KeepAlive to keep the delegate alive for as long as the native code could call it. https://stackoverflow.com/a/5465380/78561\r\n\r\nHowever while this seems to be true for the dotnet runtime in mono this does not work and we are getting crashes when the callback happens.\r\n\r\nWe have found that in mono we need to keep a Normal GCHandle to the delegate GC.KeepAlive does not seem to be enough.\r\n\r\nThis behaviour needs to be consistent across the mono/dotnet runtimes.\r\n\r\nThis issue was found when using Xamarin.Android\r\n\r\n### Reproduction Steps\r\n\r\n```\r\nvar taskCompletionSource = new TaskCompletionSource();\r\n\r\nvar myDelegate = () =\u003e taskCompletionSource.SetResult(true);\r\n\r\nvar taskCompletionSource = new TaskCompletionSource();\r\n\r\nvar myDelegate = () =\u003e taskCompletionSource.SetResult(true);\r\n\r\nNativeMethods.MyNativeMethod(myDelegate);\r\n\r\nawait taskCompletionSource.Task;\r\n\r\nNativeMethods.MyNativeMethod(myDelegate);\r\n\r\nawait taskCompletionSource.Task;\r\n\r\nGC.KeepAlive(myDelegate);\r\n```\r\n\r\n\r\n\r\n### Expected behavior\r\n\r\nGC.KeepAlive should prevent the delegate from being collected until the delegate callback has happened.\r\n\r\n### Actual behavior\r\n\r\nCrash, usually with NullReferenceException\r\n\r\n### Regression?\r\n\r\n_No response_\r\n\r\n### Known Workarounds\r\n\r\nGet a normal GCHandle to the delegate instead of using GC.KeepAlive\r\n\r\n```\r\nvar taskCompletionSource = new TaskCompletionSource();\r\n\r\nMyDelegateType myDelegate = () =\u003e taskCompletionSource.SetResult(true);\r\n\r\nvar gcHandle = GCHandle.Alloc(myDelegate, GCHandleType.Normal);\r\n\r\nvar taskCompletionSource = new TaskCompletionSource();\r\n\r\nvar myDelegate = () =\u003e taskCompletionSource.SetResult(true);\r\n\r\nNativeMethods.MyNativeMethod(myDelegate);\r\n\r\nawait taskCompletionSource.Task;\r\n\r\nNativeMethods.MyNativeMethod(myDelegate);\r\n\r\nawait taskCompletionSource.Task;\r\n\r\ngcHandle.Free();\r\n```\r\n\r\n### Configuration\r\n\r\n_No response_\r\n\r\n### Other information\r\n\r\n_No response_\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003etrampster\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Threading.Tasks`, `os-android`, `untriaged`, `runtime-mono`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-09-01T22:32:56Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5JmrTG",
                                           "createdAt":  "2022-09-01T23:05:24Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "steveisok",
                                           "body":  "/cc @SamMonoRT @BrzVlad ",
                                           "updatedAt":  "2022-09-01T23:05:24Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Jn2lG",
                                           "createdAt":  "2022-09-02T07:50:36Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "BrzVlad",
                                           "body":  "@trampster I\u0027m skeptical that this is a real issue. What makes you so sure that coreclr has different behavior ? In the post that you linked there is no mention of async methods, which completely change the apparent storage of locals so I expect `GC.KeepAlive` doesn\u0027t work because of this. \r\n\r\n@trampster Also what happens if you put the keep alive before the await operation. I suspect the await is breaking the method so the keep alive probably no longer has any effect.",
                                           "updatedAt":  "2022-09-02T07:54:15Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5JoiWb",
                                           "createdAt":  "2022-09-02T11:02:16Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e which completely change the apparent storage of locals so I expect GC.KeepAlive doesn\u0027t work because of this.\r\n\r\nRight. The C# compiler rewrites iterators, async methods, etc., such that locals whose use spans a yield/await boundary are lifted to be fields, such that they\u0027re not actually locals. GC.KeepAlive will be a nop on such usage. It did not create a GC handle, just keeps an actual local referenced and alive until that point. ",
                                           "updatedAt":  "2022-09-02T11:02:42Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5JolVi",
                                           "createdAt":  "2022-09-02T11:16:44Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "trampster",
                                           "body":  "Thanks for your reply.\r\n\r\nWe run our integrations tests with dotnet 6 and GC.KeepAlive fixed a crash we where having there. The same code when run on Xamarin.Android crashes without a normal GCHandle. That particular example may not have had async in it, I can check when I\u0027m back at work on monday.\r\n\r\nIf the locals are lifted to be fields then the field should keep the value alive (instance variables do no need GC.KeepAlive or GCHandles, again this is from Eric Lippert\u0027s post and therefore no Handle or keep alive should be required, However we know that with a normal GCHandle the code does not crash and without it it does.\r\n\r\nDo guys know why a GCHandle would be required to keep the delegate alive with async in this situation on mono?",
                                           "updatedAt":  "2022-09-02T11:20:49Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Jomui",
                                           "createdAt":  "2022-09-02T11:23:36Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "Async state machines are kept alive by the thing being awaited, e.g. the thing that will complete the awaited task. But in your case, that\u0027s a native call, which upon returning won\u0027t keep anything managed rooted, so as with most interop, you need to create a GC handle to keep that call\u0027s state alive, and that will in turn keep the state machine alive. ",
                                           "updatedAt":  "2022-09-02T11:24:02Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5JsmFc",
                                           "createdAt":  "2022-09-04T22:32:52Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "trampster",
                                           "body":  "I just read the docs for GC.KeepAlive  https://docs.microsoft.com/en-us/dotnet/api/system.gc.keepalive?view=net-6.0\r\n\r\nAnd I quote \"The purpose of the KeepAlive method is to ensure the existence of a reference to an object that is at risk of being prematurely reclaimed by the garbage collector.\"\r\n\r\nThere is nothing on that page that says it doesn\u0027t work with async code.\r\n\r\nWhile I understand your explanation about why it didn\u0027t work in this case, I still consider it a bug. Yes your explanation explains why the internal implementation is broken, but this in no way makes it not be a bug.\r\n\r\nThe fact that the reference is promoted to a field and then turned back into a local is an internal implementation detail. I told GC.KeepAlive to keep my thing alive and the async await implementation broke that contract such that it wasn\u0027t kept alive.\r\n\r\nEither update the documenation for GC.KeepAlive to say that it doesn\u0027t work past an await. Or fix the implementation so that it can keep the reference alive through the state changes required to resume after an await.",
                                           "updatedAt":  "2022-09-04T22:36:46Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5JsmdR",
                                           "createdAt":  "2022-09-04T22:43:18Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "From the runtime\u0027s perspective, it\u0027s doing exactly what the docs say it does: it extends the lifetime from the start of the current routine.  It\u0027s just that the C# compiler is rewriting the method, so what looks like a single method and single method call isn\u0027t.\r\n\r\nThe docs are open source and welcoming of contributions.  They could certainly be expanded upon.",
                                           "updatedAt":  "2022-09-04T22:43:18Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5JsmiY",
                                           "createdAt":  "2022-09-04T22:45:49Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "trampster",
                                           "body":  "Maybe the c# compiler needs to create a GCHandle for the reference in this case? So the behaviour one would expect as a c# programmer is preserved.",
                                           "updatedAt":  "2022-09-04T22:45:49Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5JsnJ1",
                                           "createdAt":  "2022-09-04T23:04:23Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "I don\u0027t think that\u0027s particularly feasible. In addition to the performance implications, the generated code would need to ensure the handle was always freed at and prior to that point, even if control flow exited at arbitrary points (returns, throws, etc), which would yield non-trivial complication to the generated code.  And more importantly, it would lead to leaks if control flow never returned to the method, e.g. imagine an iterator where the consuming loop called MoveNext and then didn\u0027t finish iterating and just ignored the enumerator.\r\n\r\nI think it\u0027s fine to improve the docs.  I think it\u0027d be fine to consider an analyzer that flagged GC.KeepAlive usage in iterators, in async methods, in local functions, and anywhere else there\u0027s material rewriting happening as part of lowering where locals are lifted to fields.  But it\u0027s not a bug and it is behaving as designed.",
                                           "updatedAt":  "2022-09-04T23:04:23Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5JsnQI",
                                           "createdAt":  "2022-09-04T23:06:56Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "trampster",
                                           "body":  "In that case, I think improving the docs and adding an Analyzer would be good additions, it would definitely have saved me a lot of time and also would have resulted in me not needing to bug you about it and also waste your time.",
                                           "updatedAt":  "2022-09-04T23:06:56Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5TY5ob",
                                           "createdAt":  "2023-01-20T22:40:03Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/gc\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Description\r\n\r\nAccording to Eric Lippert there is no need to pin a local delegate or keep a GCHandle when passing a delegate via PInvoke as long as you use GC.KeepAlive to keep the delegate alive for as long as the native code could call it. https://stackoverflow.com/a/5465380/78561\r\n\r\nHowever while this seems to be true for the dotnet runtime in mono this does not work and we are getting crashes when the callback happens.\r\n\r\nWe have found that in mono we need to keep a Normal GCHandle to the delegate GC.KeepAlive does not seem to be enough.\r\n\r\nThis behaviour needs to be consistent across the mono/dotnet runtimes.\r\n\r\nThis issue was found when using Xamarin.Android\r\n\r\n### Reproduction Steps\r\n\r\n```\r\nvar taskCompletionSource = new TaskCompletionSource();\r\n\r\nMyDelegateType myDelegate = () =\u003e taskCompletionSource.SetResult(true);\r\n\r\nNativeMethods.MyNativeMethod(myDelegate);\r\n\r\nawait taskCompletionSource.Task;\r\n\r\nGC.KeepAlive(myDelegate);\r\n```\r\n\r\n\r\n\r\n### Expected behavior\r\n\r\nGC.KeepAlive should prevent the delegate from being collected until the delegate callback has happened.\r\n\r\n### Actual behavior\r\n\r\nCrash, usually with NullReferenceException\r\n\r\n### Regression?\r\n\r\n_No response_\r\n\r\n### Known Workarounds\r\n\r\nGet a normal GCHandle to the delegate instead of using GC.KeepAlive\r\n\r\n```\r\nvar taskCompletionSource = new TaskCompletionSource();\r\n\r\nMyDelegateType myDelegate = () =\u003e taskCompletionSource.SetResult(true);\r\n\r\nvar gcHandle = GCHandle.Alloc(myDelegate, GCHandleType.Normal);\r\n\r\nNativeMethods.MyNativeMethod(myDelegate);\r\n\r\nawait taskCompletionSource.Task;\r\n\r\ngcHandle.Free();\r\n```\r\n\r\n### Configuration\r\n\r\n_No response_\r\n\r\n### Other information\r\n\r\n_No response_\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003etrampster\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003eBrzVlad\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-GC-coreclr`, `code-analyzer`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e8.0.0\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-01-20T22:40:03Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5UHfCo",
                                           "createdAt":  "2023-02-01T00:10:39Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "\u003e We run our integrations tests with dotnet 6 and GC.KeepAlive fixed a crash we where having there. The same code when run on Xamarin.Android crashes without a normal GCHandle\r\n\r\nThat sounds like a bug in Mono.\r\n\r\n\u003e locals whose use spans a yield/await boundary are lifted to be fields, such that they\u0027re not actually locals. GC.KeepAlive will be a nop on such usage.\r\n\r\nI do not think that `GC.KeepAlive` is guaranteed to be nop in this case. The last reference of the state machine can occur before the `GC.KeepAlive` call, and so the state machine may not be keeping the reference alive.",
                                           "updatedAt":  "2023-02-01T00:10:39Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5UHiSe",
                                           "createdAt":  "2023-02-01T00:25:12Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e The last reference of the state machine can occur before the GC.KeepAlive call, and so the state machine may not be keeping the reference alive.\r\n\r\nSure. My point was it does nothing to keep anything alive across a yield/await that returns out of the method that contains it. It might successfully keep a reference alive until that await, but if that await yields, at that point the KeepAlive is meaningless. ",
                                           "updatedAt":  "2023-02-01T00:25:12Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5UHlwg",
                                           "createdAt":  "2023-02-01T00:42:51Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "I am not following why it is it meaningless.\r\n\r\nIn this example, `GC.KeepAlive` should keep the `myDelegate` alive until after the await completes and execution of the async method continues.\r\n```\r\nMyDelegateType myDelegate = () =\u003e taskCompletionSource.SetResult(true);\r\n\r\nNativeMethods.MyNativeMethod(myDelegate);\r\n\r\nawait taskCompletionSource.Task;\r\n\r\nGC.KeepAlive(myDelegate);\r\n```\r\nIf `GC.KeepAlive` is deleted in this example, `myDelegate` can be collected right after returning from `NativeMethods.MyNativeMethod` method before the await yields.",
                                           "updatedAt":  "2023-02-01T00:46:04Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5UHnSx",
                                           "createdAt":  "2023-02-01T00:51:02Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "Ok, I see. The problem in this example is that this is calling into native code that should have used GCHandle instead.\r\n\r\nIf the method being called was a managed method, the `GC.KeepAlive` can be meaningful.",
                                           "updatedAt":  "2023-02-01T01:08:37Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5UHn4B",
                                           "createdAt":  "2023-02-01T00:55:09Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "I think the actual problem are marshalled delegates. Marshalled delegates are a bug farm. Should we rather build an analyzer that tells people to not use marshalled delegates and use function pointers + GCHandles instead?",
                                           "updatedAt":  "2023-02-01T00:55:09Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5UH0F6",
                                           "createdAt":  "2023-02-01T01:57:31Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e The problem in this example is that this is calling into native code that should have used GCHandle instead.\r\n\r\nRight.\r\n\r\n\u003e If the method being called was a managed method, the GC.KeepAlive can be meaningful.\r\n\r\nYes, although even then if the goal is to keep the delegate alive during that call, it should be closer to the call and not spanning the await.  Having it after the await suggests it\u0027s somehow going to keep myDelegate alive until that point, which isn\u0027t necessarily the case, even without native interop.  In an extreme case, consider:\r\n```C#\r\nvar o = new MyFinalizableObject();\r\nawait new TaskCompletionSource().Task;\r\nGC.KeepAlive(o);\r\n```\r\nIf someone thinks this KeepAlive is going to somehow keep that MyFinalizableObject from being collected, they\u0027ll be sorely mistaken: the object will be allocated, the method will await a task that isn\u0027t rooted by anyone, and the state machine will eventually become available for collection, along with the MyFinalizableObject instance.\r\n\r\n\u003e Should we rather build an analyzer that tells people to not use marshalled delegates and use function pointers + GCHandles instead?\r\n\r\nThat sounds like a valuable thing to do in addition.",
                                           "updatedAt":  "2023-02-01T01:57:59Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5UH4sW",
                                           "createdAt":  "2023-02-01T02:16:47Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "Agree. On the other hand, this is an example where KeepAlive should works as expected:\r\n```\r\nvar taskCompletionSource = new TaskCompletionSource();\r\n\r\nMyDelegateType myDelegate = () =\u003e taskCompletionSource.SetResult(true);\r\n\r\nvar gcHandle = GCHandle.Alloc(myDelegate, GCHandleType.Normal);\r\n\r\nNativeMethods.MyNativeMethod(myDelegate, finalizableResource.Handle);\r\n\r\nawait taskCompletionSource.Task;\r\n\r\nGC.KeepAlive(finalizableResource); // make sure that finalizableResource is not finalized while the async operation is in progress.\r\n\r\ngcHandle.Free();\r\n```",
                                           "updatedAt":  "2023-02-01T02:16:47Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5UH7IT",
                                           "createdAt":  "2023-02-01T02:26:40Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e Agree. On the other hand, this is an example where KeepAlive should works as expected:\r\n\r\nYup, because it forces finalizeResource to be lifted to the state machine.  The state machine gets hooked up as a continuation onto taskCompletionSource.Task such that GCHandle to the delegate references the taskCompletionSource which references the Task which references the state machine which references finalizableResource, keeping it rooted.",
                                           "updatedAt":  "2023-02-01T02:26:40Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5W8i8n",
                                           "createdAt":  "2023-03-07T19:33:54Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "bartonjs",
                                           "body":  "It\u0027s unclear from the top post what the analyzer is intended to do.  Please update the top post before the next review session.  (Not marking as needs-work right now in case it breaks our new sorting algorithm)",
                                           "updatedAt":  "2023-03-07T19:33:54Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5XLcON",
                                           "createdAt":  "2023-03-09T19:04:50Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "terrajobst",
                                           "body":  "[Video](https://www.youtube.com/watch?v=-MBZGdnYPGA\u0026t=0h36m46s)\n\n* Looks good as proposed\r\n    - There is some objection to using `GCHandle` as the recommended mitigation over rooted the delegate in a static, but that feels orthogonal to the analyzer.\r\n    - We think there is a high chance this code pattern indicates as bug, justifying it be a warning\r\n    - When a reverse P/Invoke is called, is the delegate rooted while its executed? If it doesn\u0027t, is a problem?\r\n\r\n**Category**: Reliability\r\n**Severity**: Warning\r\n",
                                           "updatedAt":  "2023-03-09T20:05:39Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5fkB_k",
                                           "createdAt":  "2023-06-22T20:34:16Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-threading-tasks\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nEDITED by @stephentoub on 1/20/2023:\r\nThe issue at this point tracks an analyzer that would flag use of GC.KeepAlive(local) usage in the context of C# iterators, async methods, and anywhere else the C# compiler does a significant method rewrite such that a \"local\" isn\u0027t actually local, e.g. where that local is lifted to a state machine and the use of GC.KeepAlive has little to no impact, e.g.\r\n```C#\r\nobject o = new object();\r\nyield return o;\r\nGC.KeepAlive(o);\r\n```\r\n\r\n---\r\n\r\n### Description\r\n\r\nAccording to Eric Lippert there is no need to pin a local delegate or keep a GCHandle when passing a delegate via PInvoke as long as you use GC.KeepAlive to keep the delegate alive for as long as the native code could call it. https://stackoverflow.com/a/5465380/78561\r\n\r\nHowever while this seems to be true for the dotnet runtime in mono this does not work and we are getting crashes when the callback happens.\r\n\r\nWe have found that in mono we need to keep a Normal GCHandle to the delegate GC.KeepAlive does not seem to be enough.\r\n\r\nThis behaviour needs to be consistent across the mono/dotnet runtimes.\r\n\r\nThis issue was found when using Xamarin.Android\r\n\r\n### Reproduction Steps\r\n\r\n```\r\nvar taskCompletionSource = new TaskCompletionSource();\r\n\r\nMyDelegateType myDelegate = () =\u003e taskCompletionSource.SetResult(true);\r\n\r\nNativeMethods.MyNativeMethod(myDelegate);\r\n\r\nawait taskCompletionSource.Task;\r\n\r\nGC.KeepAlive(myDelegate);\r\n```\r\n\r\n\r\n\r\n### Expected behavior\r\n\r\nGC.KeepAlive should prevent the delegate from being collected until the delegate callback has happened.\r\n\r\n### Actual behavior\r\n\r\nCrash, usually with NullReferenceException\r\n\r\n### Regression?\r\n\r\n_No response_\r\n\r\n### Known Workarounds\r\n\r\nGet a normal GCHandle to the delegate instead of using GC.KeepAlive\r\n\r\n```\r\nvar taskCompletionSource = new TaskCompletionSource();\r\n\r\nMyDelegateType myDelegate = () =\u003e taskCompletionSource.SetResult(true);\r\n\r\nvar gcHandle = GCHandle.Alloc(myDelegate, GCHandleType.Normal);\r\n\r\nNativeMethods.MyNativeMethod(myDelegate);\r\n\r\nawait taskCompletionSource.Task;\r\n\r\ngcHandle.Free();\r\n```\r\n\r\n### Configuration\r\n\r\n_No response_\r\n\r\n### Other information\r\n\r\n_No response_\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003etrampster\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003eBrzVlad\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`api-approved`, `area-System.Threading.Tasks`, `code-analyzer`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e8.0.0\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-06-22T20:34:16Z"
                                       }
                                   ],
                         "totalCount":  24
                     },
        "title":  "GC.KeepAlive doesn\u0027t keep local delegate alive in mono (Xamarin.Android)",
        "labels":  [
                       "api-approved",
                       "area-System.Threading.Tasks",
                       "help wanted",
                       "code-analyzer"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/78397",
        "createdAt":  "2022-11-15T16:59:49Z",
        "number":  78397,
        "author":  "stephentoub",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHODK9sLg==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "sergeks",
                                            "createdAt":  "2022-11-21T13:41:26Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "amiru3f",
                                            "createdAt":  "2023-07-15T15:03:29Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "oriol-pg",
                                            "createdAt":  "2023-07-20T23:37:53Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "alexrp",
                                            "createdAt":  "2023-07-21T03:45:48Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "WeihanLi",
                                            "createdAt":  "2023-07-21T04:06:26Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "colejohnson66",
                                            "createdAt":  "2023-07-30T00:20:44Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "tarantoj",
                                            "createdAt":  "2024-12-02T11:14:40Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "allantargino",
                                            "createdAt":  "2025-03-02T22:04:00Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "menees",
                                            "createdAt":  "2025-08-13T01:32:23Z"
                                        }
                                    ],
                          "totalCount":  9
                      },
        "updatedAt":  "2025-07-31T19:54:37Z",
        "body":  "Cancellation is often important to the scalability of an app / service.  If an async method has no way to cancel it, that can impact scalability and responsiveness.  We should consider adding an analyzer (likely off by default due to noise) that flags async methods (`async` and/or `Task`/`ValueTask`-returning) that have no overloads which accept a `CancellationToken`, and issue a diagnostic to consider taking one.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOuzp3cg==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5OapAu",
                                           "createdAt":  "2022-11-15T16:59:59Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-threading-tasks\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nCancellation is often important to the scalability of an app / service.  If an async method has no way to cancel it, that can impact scalability and responsiveness.  We should consider adding an analyzer (likely off by default due to noise) that flags async methods (`async` and/or `Task`/`ValueTask`-returning) that have no overloads which accept a `CancellationToken`, and issue a diagnostic to consider taking one.\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003estephentoub\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Threading.Tasks`, `code-analyzer`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-11-15T16:59:59Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5W8duv",
                                           "createdAt":  "2023-03-07T19:14:55Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "bartonjs",
                                           "body":  "[Video](https://www.youtube.com/watch?v=wagxiBYZn-A\u0026t=1h6m35s)\n\nLooks good as proposed (finding Task-like returning method groups with no overloads that accept a CancellationToken).\r\n\r\nCategory: Design\r\nSeverity: None (off by default)",
                                           "updatedAt":  "2023-03-07T20:30:37Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5iC73w",
                                           "createdAt":  "2023-07-21T03:34:13Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODCDVBg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "buyaa-n",
                                                                               "createdAt":  "2023-07-28T00:25:30Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "pedrodeandrade",
                                           "body":  "I would like to be assigned to this, please",
                                           "updatedAt":  "2023-07-21T03:34:13Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5ioi5X",
                                           "createdAt":  "2023-07-28T00:26:07Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODCD-uA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "pedrodeandrade",
                                                                               "createdAt":  "2023-07-28T03:45:06Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "buyaa-n",
                                           "body":  "Thanks @pedrodeandrade, assigned to you",
                                           "updatedAt":  "2023-07-28T00:26:07Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc67Ondy",
                                           "createdAt":  "2025-07-31T19:54:37Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "menees",
                                           "body":  "I went looking for a rule like this today, and I found some prior, related work that\u0027s worth mentioning:\n- @sharwell implemented a similar rule in 2015 in the (now archived) [AsyncUsageAnalyzers](https://github.com/DotNetAnalyzers/AsyncUsageAnalyzers) project:\n  - [Issue Comment](https://github.com/DotNetAnalyzers/AsyncUsageAnalyzers/issues/32#issuecomment-168112627) - Discusses some exclusions he made for private, override, and unit test methods.\n  - [Source Code](https://github.com/DotNetAnalyzers/AsyncUsageAnalyzers/blob/master/AsyncUsageAnalyzers/AsyncUsageAnalyzers/Usage/IncludeCancellationParameterAnalyzer.cs)\n- @AArnott proposed a similar rule in 2018 in the [vs-threading](https://github.com/microsoft/vs-threading) analyzers, which [superseded the AsyncUsageAnalyzers](https://github.com/microsoft/vs-threading/issues/382):\n  - [Issue Comment](https://github.com/microsoft/vs-threading/issues/394#issuecomment-423850706) - CancellationToken propagation is now checked by [CA2016](https://learn.microsoft.com/en-us/dotnet/fundamentals/code-analysis/quality-rules/ca2016).",
                                           "updatedAt":  "2025-07-31T19:54:37Z"
                                       }
                                   ],
                         "totalCount":  5
                     },
        "title":  "[Analyzer] Async methods that don\u0027t take a CancellationToken",
        "labels":  [
                       "api-approved",
                       "area-System.Threading.Tasks",
                       "help wanted",
                       "code-analyzer"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/78502",
        "createdAt":  "2022-11-17T11:35:30Z",
        "number":  78502,
        "author":  "svick",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOC_0cTA==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "bennoremec",
                                            "createdAt":  "2022-12-23T07:08:57Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "janseris",
                                            "createdAt":  "2023-01-10T22:06:28Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "theodorzoulias",
                                            "createdAt":  "2023-01-21T06:24:29Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "0x526f6d656f",
                                            "createdAt":  "2023-03-13T10:33:51Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "MV10",
                                            "createdAt":  "2023-04-23T17:27:04Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "HermanEldering",
                                            "createdAt":  "2024-05-28T08:46:02Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "BernhardNinaus",
                                            "createdAt":  "2025-03-07T14:01:30Z"
                                        }
                                    ],
                          "totalCount":  7
                      },
        "updatedAt":  "2023-05-08T18:52:56Z",
        "body":  "### Describe the problem you are trying to solve\r\n\r\nWhen the `[STAThread]` attribute is applied to an `async Main` method, it does not have the intended effect (the main thread of the application is not created with the single-threaded apartment state). Since this gotcha seems to be fairly common (see e.g. https://github.com/dotnet/roslyn/issues/22112 and the issues linked to it), users should be made aware of it.\r\n\r\n### Describe suggestions on how to achieve the rule\r\n\r\nI\u0027m not certain if a code fix is necessary, but it could remove `[STAThread]` from the `async Main` method and then do one of the following:\r\n\r\n1. Add `Thread.CurrentThread.SetApartmentState(ApartmentState.STA);` at the start of the `async Main` method.\r\n2. Rename the `async Main` method to `MainAsync` and then add `[STAThread] static void Main() =\u003e MainAsync().GetAwaiter().GetResult();`.\r\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOWrvcnQ==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5Ol2P5",
                                           "createdAt":  "2022-11-17T12:10:27Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "I couldn\u0027t figure out the best area label to add to this issue. If you have write-permissions please help me learn by adding exactly one [area label](https://github.com/dotnet/runtime/blob/master/docs/area-owners.md).",
                                           "updatedAt":  "2022-11-17T12:10:27Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5OnKGc",
                                           "createdAt":  "2022-11-17T16:25:12Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-threading-tasks\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Describe the problem you are trying to solve\r\n\r\nWhen the `[STAThread]` attribute is applied to an `async Main` method, it does not have the intended effect (the main thread of the application is not created with the single-threaded apartment state). Since this gotcha seems to be fairly common (see e.g. https://github.com/dotnet/roslyn/issues/22112 and the issues linked to it), users should be made aware of it.\r\n\r\n### Describe suggestions on how to achieve the rule\r\n\r\nI\u0027m not certain if a code fix is necessary, but it could remove `[STAThread]` from the `async Main` method and then do one of the following:\r\n\r\n1. Add `Thread.CurrentThread.SetApartmentState(ApartmentState.STA);` at the start of the `async Main` method.\r\n2. Rename the `async Main` method to `MainAsync` and then add `[STAThread] static void Main() =\u003e MainAsync().GetAwaiter().GetResult();`.\r\n\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003esvick\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Threading.Tasks`, `untriaged`, `code-analyzer`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-11-17T16:25:12Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5au9yd",
                                           "createdAt":  "2023-04-25T18:51:10Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "terrajobst",
                                           "body":  "* **Category**: Reliability\r\n* **Severity**: Warning\r\n* The analyzer will trigger if either an `async` method has the `STAThread` attribute or if you call `SetApartmentState()`. Top level statements with `await` are treated as an async method.\r\n    - We don\u0027t look for `MTAThread`\r\n* We should also trigger if `STAThread` or `SetApartmentState()` is called from a method that isn\u0027t the entry point, assuming that is actually wrong",
                                           "updatedAt":  "2023-04-25T18:55:55Z"
                                       }
                                   ],
                         "totalCount":  3
                     },
        "title":  "Analyzer for STAThread attribute applied to async Main",
        "labels":  [
                       "api-approved",
                       "area-System.Threading.Tasks",
                       "help wanted",
                       "code-analyzer"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/78753",
        "createdAt":  "2022-11-23T09:05:18Z",
        "number":  78753,
        "author":  "bill-poole",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2024-05-03T03:19:28Z",
        "body":  "### Background and motivation\n\nThe maximum degree of parallelism of a `Parallel.ForEachAsync` invocation is constrained by setting the `ParallelOptions.MaxDegreeOfParallelism` property. However, this constrains the degree of parallelism _per invocation_; not globally.\r\n\r\nIf a method that invokes `Parallel.ForEachAsync` is itself invoked on multiple threads (e.g., per received HTTP request), then this has a multiplying effect and can overwhelm the server. For example, a web server may use a `ConcurrencyLimiter` to constrain to handling no more than 100 simultaneous requests, each of which invoking a method that invokes `Parallel.ForEachAsync` with `ParallelOptions.MaxDegreeOfParallelism` also set to 100. This results in the `body` function passed to the `Parallel.ForEachAsync` method being invoked with a maximum effective concurrency of 10,000.\r\n\r\nIdeally, each invocation of `Parallel.ForEachAsync` could be constrained using a global `ConcurrencyLimiter` for that invocation. This could be achieved by adding a `ConcurrencyLimiter` property to the `ParallelOptions` class. Thus in the above example, a static/global `ConcurrencyLimiter` could be defined in the class that contains the method that invokes `Parallel.ForEachAsync` and given to the `ParallelOptions` parameter, providing a global (process-wide) limit to the number of concurrent tasks invoked by that invocation of `Parallel.ForEachAsync` across all HTTP requests.\r\n\r\nFurthermore, other invocations of `Parallel.ForEachAsync` in other places in the code can each set/use their own global limits, each governed by its own `ConcurrencyLimiter` instance.\r\n\r\nNote that while the `body` function passed to the `Parallel.ForEachAsync` method can use a `ConcurrencyLimiter` internally to limit the global concurrency of given `body` function, the `Parallel.ForEachAsync` method would continue to consume items from the given `source` enumerable parameter up until the permitted degree of parallelism specified by the `ParallelOptions.MaxDegreeOfParallelism` property. Thus if the `source` enumerable is `IAsyncEnumerable\u003cT\u003e`, and the items being enumerated are very large in number and not all in memory (i.e., streamed from network/storage), and the `Parallel.ForEachAsync` consumes items from the given `source` enumerable faster than the given `body` function can process them, then this could lead to the server running out of memory.\r\n\r\nHowever, if the `Parallel.ForEachAsync` method is `ConcurrencyLimiter`-aware, then it knows to only consume the next item from the given `source` enumerable when there is sufficient capacity to process it.\n\n### API Proposal\n\n```csharp\r\nnamespace System.Threading.Tasks;\r\n\r\npublic class ParallelOptions\r\n{\r\n    public ConcurrencyLimiter ConcurrencyLimiter { get; set; }\r\n}\r\n```\r\n\n\n### API Usage\n\n```csharp\r\npublic class RequestHandler\r\n{\r\n  private static readonly ConcurrencyLimiter s_concurrencyLimiter = new(new() \r\n  { \r\n    PermitLimit = 100, \r\n    QueueLimit = 0, \r\n    QueueProcessingOrder = QueueProcessingOrder.OldestFirst\r\n  });\r\n\r\n  public async Task Handle(Request request, CancellationToken cancellationToken)\r\n  {\r\n    await Parallel.ForEachAsync(request.Items, new ParallelOptions\r\n    {\r\n      CancellationToken = cancellationToken,\r\n      ConcurrencyLimiter = s_concurrencyLimiter\r\n    }, async (item, cancellationToken) =\u003e\r\n    {\r\n      // Handle each item\r\n    });\r\n  }\r\n}\r\n```\r\n\n\n### Alternative Designs\n\n_No response_\n\n### Risks\n\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOfLJGTQ==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5O9eeb",
                                           "createdAt":  "2022-11-23T09:05:26Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-collections\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Background and motivation\n\nThe maximum degree of parallelism of a `Parallel.ForEachAsync` invocation is constrained by setting the `ParallelOptions.MaxDegreeOfParallelism` property. However, this constrains the degree of parallelism _per invocation_; not globally.\r\n\r\nIf a method that invokes `Parallel.ForEachAsync` is itself invoked on multiple threads (e.g., per received HTTP request), then this has a multiplying effect and can overwhelm the server. For example, a web server may use a `ConcurrencyLimiter` to constrain to handling no more than 100 simultaneous requests, each of which invoking a method that invokes `Parallel.ForEachAsync` with `ParallelOptions.MaxDegreeOfParallelism` also set to 100. This results in the `body` function passed to the `Parallel.ForEachAsync` method being invoked with a maximum effective concurrency of 10,000.\r\n\r\nIdeally, each invocation of `Parallel.ForEachAsync` could be constrained using a global `ConcurrencyLimiter` for that invocation. This could be achieved by adding a `ConcurrencyLimiter` property to the `ParallelOptions` class. Thus in the above example, a static/global `ConcurrencyLimiter` could be defined in the class that contains the method that invokes `Parallel.ForEachAsync` and given to the `ParallelOptions` parameter, providing a global (process-wide) limit to the number of concurrent tasks invoked by that invocation of `Parallel.ForEachAsync` across all HTTP requests.\r\n\r\nFurthermore, other invocations of `Parallel.ForEachAsync` in other places in the code can each set/use their own global limits, each governed by its own `ConcurrencyLimiter` instance.\r\n\r\nNote that while the `body` function passed to the `Parallel.ForEachAsync` method can use a `ConcurrencyLimiter` internally to limit the global concurrency of given `body` function, the `Parallel.ForEachAsync` method would continue to consume items from the given `source` enumerable parameter up until the permitted degree of parallelism specified by the `ParallelOptions.MaxDegreeOfParallelism` property. Thus if the `source` enumerable is `IAsyncEnumerable\u003cT\u003e`, and the items being enumerated are very large in number and not all in memory (i.e., streamed from network/storage), and the `Parallel.ForEachAsync` consumes items from the given `source` enumerable faster than the given `body` function can process them, then this could lead to the server running out of memory.\r\n\r\nHowever, if the `Parallel.ForEachAsync` method is `ConcurrencyLimiter`-aware, then it knows to only consume the next item from the given `source` enumerable when there is sufficient capacity to process it.\n\n### API Proposal\n\n```csharp\r\nnamespace System.Threading.Tasks;\r\n\r\npublic class ParallelOptions\r\n{\r\n    public ConcurrencyLimiter ConcurrencyLimiter { get; set; }\r\n}\r\n```\r\n\n\n### API Usage\n\n```csharp\r\npublic class RequestHandler\r\n{\r\n  private static readonly ConcurrencyLimiter s_concurrencyLimiter = new(new() \r\n  { \r\n    PermitLimit = 100, \r\n    QueueLimit = 0, \r\n    QueueProcessingOrder = QueueProcessingOrder.OldestFirst\r\n  });\r\n\r\n  public async Task Handle(Request request, CancellationToken cancellationToken)\r\n  {\r\n    await Parallel.ForEachAsync(request.Items, new ParallelOptions\r\n    {\r\n      CancellationToken = cancellationToken,\r\n      ConcurrencyLimiter = s_concurrencyLimiter\r\n    }, async (item, cancellationToken) =\u003e\r\n    {\r\n      // Handle each item\r\n    });\r\n  }\r\n}\r\n```\r\n\n\n### Alternative Designs\n\n_No response_\n\n### Risks\n\n_No response_\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003ebill-poole\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`api-suggestion`, `area-System.Collections`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-11-23T09:05:26Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5O953X",
                                           "createdAt":  "2022-11-23T10:36:45Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-threading-tasks\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Background and motivation\n\nThe maximum degree of parallelism of a `Parallel.ForEachAsync` invocation is constrained by setting the `ParallelOptions.MaxDegreeOfParallelism` property. However, this constrains the degree of parallelism _per invocation_; not globally.\r\n\r\nIf a method that invokes `Parallel.ForEachAsync` is itself invoked on multiple threads (e.g., per received HTTP request), then this has a multiplying effect and can overwhelm the server. For example, a web server may use a `ConcurrencyLimiter` to constrain to handling no more than 100 simultaneous requests, each of which invoking a method that invokes `Parallel.ForEachAsync` with `ParallelOptions.MaxDegreeOfParallelism` also set to 100. This results in the `body` function passed to the `Parallel.ForEachAsync` method being invoked with a maximum effective concurrency of 10,000.\r\n\r\nIdeally, each invocation of `Parallel.ForEachAsync` could be constrained using a global `ConcurrencyLimiter` for that invocation. This could be achieved by adding a `ConcurrencyLimiter` property to the `ParallelOptions` class. Thus in the above example, a static/global `ConcurrencyLimiter` could be defined in the class that contains the method that invokes `Parallel.ForEachAsync` and given to the `ParallelOptions` parameter, providing a global (process-wide) limit to the number of concurrent tasks invoked by that invocation of `Parallel.ForEachAsync` across all HTTP requests.\r\n\r\nFurthermore, other invocations of `Parallel.ForEachAsync` in other places in the code can each set/use their own global limits, each governed by its own `ConcurrencyLimiter` instance.\r\n\r\nNote that while the `body` function passed to the `Parallel.ForEachAsync` method can use a `ConcurrencyLimiter` internally to limit the global concurrency of given `body` function, the `Parallel.ForEachAsync` method would continue to consume items from the given `source` enumerable parameter up until the permitted degree of parallelism specified by the `ParallelOptions.MaxDegreeOfParallelism` property. Thus if the `source` enumerable is `IAsyncEnumerable\u003cT\u003e`, and the items being enumerated are very large in number and not all in memory (i.e., streamed from network/storage), and the `Parallel.ForEachAsync` consumes items from the given `source` enumerable faster than the given `body` function can process them, then this could lead to the server running out of memory.\r\n\r\nHowever, if the `Parallel.ForEachAsync` method is `ConcurrencyLimiter`-aware, then it knows to only consume the next item from the given `source` enumerable when there is sufficient capacity to process it.\n\n### API Proposal\n\n```csharp\r\nnamespace System.Threading.Tasks;\r\n\r\npublic class ParallelOptions\r\n{\r\n    public ConcurrencyLimiter ConcurrencyLimiter { get; set; }\r\n}\r\n```\r\n\n\n### API Usage\n\n```csharp\r\npublic class RequestHandler\r\n{\r\n  private static readonly ConcurrencyLimiter s_concurrencyLimiter = new(new() \r\n  { \r\n    PermitLimit = 100, \r\n    QueueLimit = 0, \r\n    QueueProcessingOrder = QueueProcessingOrder.OldestFirst\r\n  });\r\n\r\n  public async Task Handle(Request request, CancellationToken cancellationToken)\r\n  {\r\n    await Parallel.ForEachAsync(request.Items, new ParallelOptions\r\n    {\r\n      CancellationToken = cancellationToken,\r\n      ConcurrencyLimiter = s_concurrencyLimiter\r\n    }, async (item, cancellationToken) =\u003e\r\n    {\r\n      // Handle each item\r\n    });\r\n  }\r\n}\r\n```\r\n\n\n### Alternative Designs\n\n_No response_\n\n### Risks\n\n_No response_\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003ebill-poole\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`api-suggestion`, `area-System.Threading.Tasks`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-11-23T10:36:45Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5TYxBo",
                                           "createdAt":  "2023-01-20T21:58:33Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "This is reasonable in theory; whereas the ParallelOptions.TaskScheduler can be used to coordinate how many tasks are allowed to execute across any number of consumers at a time, the proposed ParallelOptions.ConcurrencyLimiter would enable doing so even when there was no work to actually run.\r\n\r\nThat said, it could add non-trivial overhead to the processing (which might otherwise be very fine-grained).  It would also add complexity in understanding the mind-bending relationship between what limits the scheduler might put in place, what limits the concurrency limiter might put in place, and MaxDegreeOfParallelism.  And as you\u0027ve outlined, someone can achieve the majority of the benefits just by using the concurrency limiter in the body of the loop; you mentioned a downside of large memory consumption, but worst case is you\u0027re holding onto MaxDegreeOfParallelism items from the source, and if that\u0027s too large for the scenario, lower the MaxDegreeOfParallelism.  Finally, there\u0027s also a practical issue, which is that Parallel is in the netcoreapp shared framework and ConcurrencyLimiter is not; taking this dependency would require pulling it in.\r\n\r\nI\u0027m not opposed to keeping this issue open to consider it again in the future, but I wouldn\u0027t rush to try to do something here now.",
                                           "updatedAt":  "2023-01-20T21:58:33Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc58sjuB",
                                           "createdAt":  "2024-05-03T03:13:51Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "bill-poole",
                                           "body":  "Thanks @stephentoub for considering this proposal.\r\n\r\n\u003e if that\u0027s too large for the scenario, lower the MaxDegreeOfParallelism\r\n\r\nLowering the `MaxDegreeOfParallelism` isn\u0027t really a practical option in my case. In my case, the system needs a certain degree of parallelism to meet its performance requirements.\r\n\r\nFor example, let\u0027s say the system writes records to a database, each write has a latency of ~10 ms, and the system needs to write 100,000 records per second. Therefore, the required degree of parallelism is 1,000. If we lower the max degree of parallelism, then system won\u0027t meet its performance requirements.\r\n\r\nLet\u0027s also say that the system performs many different types of operations that each writes a batch of an arbitrary number of records to the database. Furthermore, these operations are also performed concurrently. If `Parallel.ForEachAsync` is used to write each batch of records to the database, then there is no `MaxDegreeOfParallelism` parameter that we can use that will:\r\n- guarantee the global degree of parallelism never exceeds 1,000; and\r\n- write all records to the database with the required global degree of parallelism of 1,000.\r\n\r\nThat then leaves us with the option of rate limiting inside the `body` provided to `Parallel.ForEachAsync`, but that can cause the system to run out of memory as we previously discussed.\r\n\r\nI have however after some additional consideration found a third option, which is to rate limit the source enumerable given to `Parallel.ForEachAsync`:\r\n\r\n```csharp\r\npublic static async Task ForEachAsync\u003cTSource\u003e(IAsyncEnumerable\u003cTSource\u003e source,\r\n    Func\u003cTSource, CancellationToken, ValueTask\u003e body, RateLimiter rateLimiter,\r\n    CancellationToken cancellationToken)\r\n{\r\n    ArgumentNullException.ThrowIfNull(source);\r\n    ArgumentNullException.ThrowIfNull(body);\r\n    ArgumentNullException.ThrowIfNull(rateLimiter);\r\n\r\n    await Parallel.ForEachAsync(RateLimited(source, rateLimiter, cancellationToken),\r\n        new ParallelOptions\r\n        {\r\n            MaxDegreeOfParallelism = int.MaxValue,\r\n            CancellationToken = cancellationToken\r\n        }, async (element, cancellationToken) =\u003e\r\n        {\r\n            try\r\n            {\r\n                await body(element.Source, cancellationToken);\r\n            }\r\n            finally\r\n            {\r\n                element.Lease.Dispose();\r\n            }\r\n        });\r\n\r\n    static async IAsyncEnumerable\u003c(TSource Source, RateLimitLease Lease)\u003e RateLimited(\r\n        IAsyncEnumerable\u003cTSource\u003e source, RateLimiter rateLimiter,\r\n        [EnumeratorCancellation] CancellationToken cancellationToken)\r\n    {\r\n        await foreach (var element in source.WithCancellation(cancellationToken))\r\n        {\r\n            // Wait until there is sufficient capacity and then yield the next element to\r\n            // be processed. This ensures we don\u0027t consume any additional elements from the\r\n            // given source enumerable until there is sufficient capacity to process the\r\n            // current element. i.e., this transmits backpressure from the rate limiter to\r\n            // the source enumerable.\r\n            var lease = await rateLimiter.AcquireAsync(permitCount: 1, cancellationToken);\r\n            yield return (element, lease);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nHowever, this relies on:\r\n- the `RateLimited` enumerable guaranteeing that the `lease` once acquired is always yielded to the consumer of the enumerable (i.e., this cannot be intercepted by an exception or cancellation); and\r\n- The `Parallel.ForEachAsync` method guaranteeing that once its `source` enumerable yields an element (i.e., once `MoveNextAsync` has returned true), the `body` is invoked with the yielded element.\r\n\r\nThis is necessary to ensure that every lease acquired from the rate limiter is disposed.\r\n\r\nI have taken a look at the source code of the `Parallel.ForEachAsync` method and it seems to provide the required guarantee. However, that\u0027s an implementation detail that is not guaranteed to hold true in the future. But it seems this is my only option, other than to copy/modify the `Parallel.ForEachAsync` implementation.",
                                           "updatedAt":  "2024-05-03T03:13:51Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc58skZN",
                                           "createdAt":  "2024-05-03T03:19:27Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "bill-poole",
                                           "body":  "\u003e Parallel is in the netcoreapp shared framework and ConcurrencyLimiter is not; taking this dependency would require pulling it in\r\n\r\nUnderstood. The requirements would also be met by allowing a `SemaphoreSlim` to be provided (as opposed to a `ConcurrencyLimiter`).",
                                           "updatedAt":  "2024-05-03T03:19:27Z"
                                       }
                                   ],
                         "totalCount":  5
                     },
        "title":  "[API Proposal]: Support specifying global degree of parallelism for Parallel.ForEachAsync by providing a ConcurrencyLimiter",
        "labels":  [
                       "api-suggestion",
                       "area-System.Threading.Tasks"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/79535",
        "createdAt":  "2022-12-12T10:39:18Z",
        "number":  79535,
        "author":  "theodorzoulias",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOC2imlQ==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "akrotov",
                                            "createdAt":  "2024-03-14T21:50:14Z"
                                        }
                                    ],
                          "totalCount":  1
                      },
        "updatedAt":  "2024-06-28T14:36:32Z",
        "body":  "Hi! Recently I tried to use the [`DataflowBlock.ReceiveAllAsync`](https://learn.microsoft.com/en-us/dotnet/api/system.threading.tasks.dataflow.dataflowblock.receiveallasync) API for the first time, but I ended up not using it because it didn\u0027t have the desirable behavior [for my case](https://stackoverflow.com/questions/74756252/custom-dataflow-transform-block-with-dynamic-maxdegreeofparallelism \"Custom Dataflow transform block with dynamic MaxDegreeOfParallelism\"). My expectation was that after completing the enumeration of the asynchronous sequence, an exception stored in the consumed `BufferBlock\u003cT\u003e` would be surfaced. But this is not what happens. Here is a minimal demo:\r\n\r\n```C#\r\nBufferBlock\u003cint\u003e block = new();\r\n((IDataflowBlock)block).Fault(new Exception());\r\ntry\r\n{\r\n    await foreach (var item in block.ReceiveAllAsync()) { }\r\n    Console.WriteLine($\"Done: {block.Completion.Status}\");\r\n}\r\ncatch (Exception ex) { Console.WriteLine(ex.Message); }\r\n```\r\n\r\nActual output:\r\n\r\n```\r\nDone: Faulted\r\n```\r\n\r\nThe output that I expected was:\r\n\r\n```\r\nException of type \u0027System.Exception\u0027 was thrown.\r\n```\r\n\r\nThe `ReceiveAllAsync` API was introduced in .NET 6. My expectation for its behavior was based on the preexisting API [`ChannelReader\u003cT\u003e.ReadAllAsync`](https://learn.microsoft.com/en-us/dotnet/api/system.threading.channels.channelreader-1.readallasync) (Core 3.0+), which plays a similar role in the Channels library. That API is used to consume a `Channel\u003cT\u003e`, and it **does** propagate the error that is stored in the channel. Here is a minimal demo:\r\n\r\n```C#\r\nChannel\u003cint\u003e channel = Channel.CreateUnbounded\u003cint\u003e();\r\nchannel.Writer.Complete(new Exception());\r\ntry\r\n{\r\n    await foreach (var item in channel.Reader.ReadAllAsync()) { }\r\n    Console.WriteLine($\"Done: {channel.Reader.Completion.Status}\");\r\n}\r\ncatch (Exception ex) { Console.WriteLine(ex.Message); }\r\n```\r\n\r\nOutput:\r\n\r\n```\r\nException of type \u0027System.Exception\u0027 was thrown.\r\n```\r\n\r\n[Both demos online](https://dotnetfiddle.net/VnJaOA).\r\n\r\nMy perception is that the [`Channel\u003cT\u003e`](https://learn.microsoft.com/en-us/dotnet/api/system.threading.channels.channel-1) class is an optimized version of the older [`BufferBlock\u003cT\u003e`](https://learn.microsoft.com/en-us/dotnet/api/system.threading.tasks.dataflow.bufferblock-1) class, with some extra features (like the ability to drop old messages when the channel is full). So I was surprised by the difference in behavior. I would like to ask if the non-error-propagating behavior of the newer API (`ReceiveAllAsync`) is by design. Also, in case it is, I would be interested to know whether the behavioral difference reflects a difference on how the two components (`BufferBlock\u003cT\u003e` \u0026 `Channel\u003cT\u003e`) are intended to be used in producer-consumer scenarios.\r\n\r\nThanks!",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOU2oJJw==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5QPif-",
                                           "createdAt":  "2022-12-12T10:39:24Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-threading-channels\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nHi! Recently I tried to use the [`DataflowBlock.ReceiveAllAsync`](https://learn.microsoft.com/en-us/dotnet/api/system.threading.tasks.dataflow.dataflowblock.receiveallasync) API for the first time, but I ended up not using it because it didn\u0027t have the desirable behavior [for my case](https://stackoverflow.com/questions/74756252/custom-dataflow-transform-block-with-dynamic-maxdegreeofparallelism \"Custom Dataflow transform block with dynamic MaxDegreeOfParallelism\"). My expectation was that after completing the enumeration of the asynchronous sequence, an exception stored in the consumed `BufferBlock\u003cT\u003e` would be surfaced. But this is not what happens. Here is a minimal demo:\r\n\r\n```C#\r\nBufferBlock\u003cint\u003e block = new();\r\n((IDataflowBlock)block).Fault(new Exception());\r\ntry\r\n{\r\n    await foreach (var item in block.ReceiveAllAsync()) { }\r\n    Console.WriteLine($\"Done: {block.Completion.Status}\");\r\n}\r\ncatch (Exception ex) { Console.WriteLine(ex.Message); }\r\n```\r\n\r\nActual output:\r\n\r\n```\r\nDone: Faulted\r\n```\r\n\r\nThe output that I expected was:\r\n\r\n```\r\nException of type \u0027System.Exception\u0027 was thrown.\r\n```\r\n\r\nThe `ReceiveAllAsync` API was introduced in .NET 6. My expectation for its behavior was based on the preexisting API [`ChannelReader\u003cT\u003e.ReadAllAsync`](https://learn.microsoft.com/en-us/dotnet/api/system.threading.channels.channelreader-1.readallasync) (Core 3.0+), which plays a similar role in the Channels library. That API is used to consume a `Channel\u003cT\u003e`, and it **does** propagate the error that is stored in the channel. Here is a minimal demo:\r\n\r\n```C#\r\nChannel\u003cint\u003e channel = Channel.CreateUnbounded\u003cint\u003e();\r\nchannel.Writer.Complete(new Exception());\r\ntry\r\n{\r\n    await foreach (var item in channel.Reader.ReadAllAsync()) { }\r\n    Console.WriteLine($\"Done: {channel.Reader.Completion.Status}\");\r\n}\r\ncatch (Exception ex) { Console.WriteLine(ex.Message); }\r\n```\r\n\r\nOutput:\r\n\r\n```\r\nException of type \u0027System.Exception\u0027 was thrown.\r\n```\r\n\r\n[Both demos online](https://dotnetfiddle.net/VnJaOA).\r\n\r\nMy perception is that the [`Channel\u003cT\u003e`](https://learn.microsoft.com/en-us/dotnet/api/system.threading.channels.channel-1) class is an optimized version of the older [`BufferBlock\u003cT\u003e`](https://learn.microsoft.com/en-us/dotnet/api/system.threading.tasks.dataflow.bufferblock-1) class, with some extra features (like the ability to drop old messages when the channel is full). So I was surprised by the difference in behavior. I would like to ask if the non-error-propagating behavior of the newer API (`ReceiveAllAsync`) is by design. Also, in case it is, I would be interested to know whether the behavioral difference reflects a difference on how the two components (`BufferBlock\u003cT\u003e` \u0026 `Channel\u003cT\u003e`) are intended to be used in producer-consumer scenarios.\r\n\r\nThanks!\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003etheodorzoulias\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Threading.Channels`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-12-12T10:39:24Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5TaN2v",
                                           "createdAt":  "2023-01-22T01:42:23Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nHi! Recently I tried to use the [`DataflowBlock.ReceiveAllAsync`](https://learn.microsoft.com/en-us/dotnet/api/system.threading.tasks.dataflow.dataflowblock.receiveallasync) API for the first time, but I ended up not using it because it didn\u0027t have the desirable behavior [for my case](https://stackoverflow.com/questions/74756252/custom-dataflow-transform-block-with-dynamic-maxdegreeofparallelism \"Custom Dataflow transform block with dynamic MaxDegreeOfParallelism\"). My expectation was that after completing the enumeration of the asynchronous sequence, an exception stored in the consumed `BufferBlock\u003cT\u003e` would be surfaced. But this is not what happens. Here is a minimal demo:\r\n\r\n```C#\r\nBufferBlock\u003cint\u003e block = new();\r\n((IDataflowBlock)block).Fault(new Exception());\r\ntry\r\n{\r\n    await foreach (var item in block.ReceiveAllAsync()) { }\r\n    Console.WriteLine($\"Done: {block.Completion.Status}\");\r\n}\r\ncatch (Exception ex) { Console.WriteLine(ex.Message); }\r\n```\r\n\r\nActual output:\r\n\r\n```\r\nDone: Faulted\r\n```\r\n\r\nThe output that I expected was:\r\n\r\n```\r\nException of type \u0027System.Exception\u0027 was thrown.\r\n```\r\n\r\nThe `ReceiveAllAsync` API was introduced in .NET 6. My expectation for its behavior was based on the preexisting API [`ChannelReader\u003cT\u003e.ReadAllAsync`](https://learn.microsoft.com/en-us/dotnet/api/system.threading.channels.channelreader-1.readallasync) (Core 3.0+), which plays a similar role in the Channels library. That API is used to consume a `Channel\u003cT\u003e`, and it **does** propagate the error that is stored in the channel. Here is a minimal demo:\r\n\r\n```C#\r\nChannel\u003cint\u003e channel = Channel.CreateUnbounded\u003cint\u003e();\r\nchannel.Writer.Complete(new Exception());\r\ntry\r\n{\r\n    await foreach (var item in channel.Reader.ReadAllAsync()) { }\r\n    Console.WriteLine($\"Done: {channel.Reader.Completion.Status}\");\r\n}\r\ncatch (Exception ex) { Console.WriteLine(ex.Message); }\r\n```\r\n\r\nOutput:\r\n\r\n```\r\nException of type \u0027System.Exception\u0027 was thrown.\r\n```\r\n\r\n[Both demos online](https://dotnetfiddle.net/VnJaOA).\r\n\r\nMy perception is that the [`Channel\u003cT\u003e`](https://learn.microsoft.com/en-us/dotnet/api/system.threading.channels.channel-1) class is an optimized version of the older [`BufferBlock\u003cT\u003e`](https://learn.microsoft.com/en-us/dotnet/api/system.threading.tasks.dataflow.bufferblock-1) class, with some extra features (like the ability to drop old messages when the channel is full). So I was surprised by the difference in behavior. I would like to ask if the non-error-propagating behavior of the newer API (`ReceiveAllAsync`) is by design. Also, in case it is, I would be interested to know whether the behavioral difference reflects a difference on how the two components (`BufferBlock\u003cT\u003e` \u0026 `Channel\u003cT\u003e`) are intended to be used in producer-consumer scenarios.\r\n\r\nThanks!\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003etheodorzoulias\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Threading`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-01-22T01:42:23Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5TaN5f",
                                           "createdAt":  "2023-01-22T01:43:42Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-threading-tasks\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nHi! Recently I tried to use the [`DataflowBlock.ReceiveAllAsync`](https://learn.microsoft.com/en-us/dotnet/api/system.threading.tasks.dataflow.dataflowblock.receiveallasync) API for the first time, but I ended up not using it because it didn\u0027t have the desirable behavior [for my case](https://stackoverflow.com/questions/74756252/custom-dataflow-transform-block-with-dynamic-maxdegreeofparallelism \"Custom Dataflow transform block with dynamic MaxDegreeOfParallelism\"). My expectation was that after completing the enumeration of the asynchronous sequence, an exception stored in the consumed `BufferBlock\u003cT\u003e` would be surfaced. But this is not what happens. Here is a minimal demo:\r\n\r\n```C#\r\nBufferBlock\u003cint\u003e block = new();\r\n((IDataflowBlock)block).Fault(new Exception());\r\ntry\r\n{\r\n    await foreach (var item in block.ReceiveAllAsync()) { }\r\n    Console.WriteLine($\"Done: {block.Completion.Status}\");\r\n}\r\ncatch (Exception ex) { Console.WriteLine(ex.Message); }\r\n```\r\n\r\nActual output:\r\n\r\n```\r\nDone: Faulted\r\n```\r\n\r\nThe output that I expected was:\r\n\r\n```\r\nException of type \u0027System.Exception\u0027 was thrown.\r\n```\r\n\r\nThe `ReceiveAllAsync` API was introduced in .NET 6. My expectation for its behavior was based on the preexisting API [`ChannelReader\u003cT\u003e.ReadAllAsync`](https://learn.microsoft.com/en-us/dotnet/api/system.threading.channels.channelreader-1.readallasync) (Core 3.0+), which plays a similar role in the Channels library. That API is used to consume a `Channel\u003cT\u003e`, and it **does** propagate the error that is stored in the channel. Here is a minimal demo:\r\n\r\n```C#\r\nChannel\u003cint\u003e channel = Channel.CreateUnbounded\u003cint\u003e();\r\nchannel.Writer.Complete(new Exception());\r\ntry\r\n{\r\n    await foreach (var item in channel.Reader.ReadAllAsync()) { }\r\n    Console.WriteLine($\"Done: {channel.Reader.Completion.Status}\");\r\n}\r\ncatch (Exception ex) { Console.WriteLine(ex.Message); }\r\n```\r\n\r\nOutput:\r\n\r\n```\r\nException of type \u0027System.Exception\u0027 was thrown.\r\n```\r\n\r\n[Both demos online](https://dotnetfiddle.net/VnJaOA).\r\n\r\nMy perception is that the [`Channel\u003cT\u003e`](https://learn.microsoft.com/en-us/dotnet/api/system.threading.channels.channel-1) class is an optimized version of the older [`BufferBlock\u003cT\u003e`](https://learn.microsoft.com/en-us/dotnet/api/system.threading.tasks.dataflow.bufferblock-1) class, with some extra features (like the ability to drop old messages when the channel is full). So I was surprised by the difference in behavior. I would like to ask if the non-error-propagating behavior of the newer API (`ReceiveAllAsync`) is by design. Also, in case it is, I would be interested to know whether the behavioral difference reflects a difference on how the two components (`BufferBlock\u003cT\u003e` \u0026 `Channel\u003cT\u003e`) are intended to be used in producer-consumer scenarios.\r\n\r\nThanks!\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003etheodorzoulias\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Threading.Tasks`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-01-22T01:43:42Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5TaOPD",
                                           "createdAt":  "2023-01-22T01:54:48Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOC0mI7g==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "theodorzoulias",
                                                                               "createdAt":  "2023-01-22T10:50:23Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e So I was surprised by the difference in behavior. I would like to ask if the non-error-propagating behavior of the newer API (ReceiveAllAsync) is by design.\r\n\r\nYes and no.  It\u0027s by design only in that it\u0027s inheriting the behavior of OutputAvailableAsync.  Whereas ChannelReader\u0027s WaitToReadAsync will fail with an exception if the channel has faulted, OutputAvailableAsync doesn\u0027t propagate exceptions from the block, so if the block has completed with a failure, the task returned from OutputAvailableAsync just yields false rather than faults.\r\n\r\nWe could consider taking a breaking change to await the block\u0027s Completion task upon exiting the loop to accomodate the difference.  I don\u0027t have a good sense for how many folks we\u0027d break, as the method was shipped new in the .NET 6 timeframe.  It\u0027s also simple enough for the consumer to do exactly the same thing if they care about the exception being propagated.",
                                           "updatedAt":  "2023-01-22T01:54:48Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Tagkn",
                                           "createdAt":  "2023-01-22T11:21:11Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "theodorzoulias",
                                           "body":  "\u003e I don\u0027t have a good sense for how many folks we\u0027d break, as the method was shipped new in the .NET 6 timeframe.\r\n\r\nIn StackOverflow [there are currently three posts](https://stackoverflow.com/search?q=%5Bc%23%5D+ReceiveAllAsync \"Results for receiveallasync tagged with c#\") that are mentioning the `ReceiveAllAsync` method, one by @pkanavos and two by myself. My guess is that few people have used it, even fewer have used it with blocks that might fail, and even fewer will have their code broken if this bug is fixed. It\u0027s not impossible that by fixing this bug, some currently buggy code will be fixed.",
                                           "updatedAt":  "2023-01-22T11:21:11Z"
                                       }
                                   ],
                         "totalCount":  5
                     },
        "title":  "ReceiveAllAsync, ReadAllAsync and propagation of errors",
        "labels":  [
                       "area-System.Threading.Tasks",
                       "needs-further-triage"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/81874",
        "createdAt":  "2023-02-09T06:27:00Z",
        "number":  81874,
        "author":  "agocke",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2023-11-12T00:41:29Z",
        "body":  "# Cancel scopes\r\n\r\nThis is the first proposal in what I hope to be a few proposals around a paradigm called \"structured concurrency.\" The fundamental idea is that, by encouraging concurrent code to follow strict control flow and scoping rules, the overall code structure can be better understood and managed.\r\n\r\nIf you\u0027re not familiar with the concept I recommend reading the following articles by Nathan J. Smith, whose Trio library pioneered many of these concepts.\r\n\r\n- [Timeouts and cancellation for humans](https://vorpus.org/blog/notes-on-structured-concurrency-or-go-statement-considered-harmful/)\r\n- [Structured concurrency](https://vorpus.org/blog/notes-on-structured-concurrency-or-go-statement-considered-harmful/)\r\n\r\nThis proposal focuses on the theme in the first article: cancellation.\r\n\r\n## Background -- C# cancellation\r\n\r\nFirst, some background on cancellation in C#. Cancellation in C# is almost entirely a library-level concept with no language integration. Users are expected to manually create and pass around CancellationTokens, which are then passed to library methods which have been written to take CancellationToken parameters. Methods which support cancellation are meant to regularly check the token for cancellation and throw if it has been cancelled, and consumers are meant to wrap code in `try-catch` blocks to capture `OperationCanceledException`s.\r\n\r\nThis creates various problems, as described in the article, including:\r\n\r\n* Passing cancellation tokens through code is laborious and easily overlooked\r\n* API writers can often forget to wire through cancellation even though they should\r\n* Libraries that wish to support cancellation must manually add checks to see if the cancellation token has been triggered\r\n* Callers must manually handle `OperationCanceledException`\r\n\r\n## Proposal\r\n\r\nTo address these problems, I propose we introduce a new CancelScope type. The type definition looks like following.\r\n\r\n```C#\r\nsealed class CancelScope\r\n{\r\n    public static CancelScope? CurrentScope { get; }\r\n\r\n    public static Task OpenScope(Func\u003cCancelScope, Task\u003e func);\r\n\r\n    public CancellationTokenSource Cts { get; }\r\n    ...\r\n}\r\n```\r\n\r\nThis is an incomplete definition, meant to introduce the proposal, rather than explain all the details.\r\n\r\nUsing a CancelScope is similar to using a CancellationToken and CancellationTokenSource today, except that instead of passing the token to nested async calls, you open a new nested CancelScope with `CancelScope.OpenScope`.\r\n\r\n```C#\r\nasync Task UserMethod()\r\n{\r\n    await CancelScope.OpenScope(newScope =\u003e\r\n    {\r\n        // Do whatever you would normally do\r\n        // newScope.Cts.CancelAfter(50);\r\n        // await Task.Delay(20);\r\n        // await client.GetAsync();\r\n        // await UserMethod2();\r\n    });\r\n}\r\n```\r\n\r\nNow, instead of having to pass a cancellation token to each method, transitively, a user only has to pass the token once, to the `WithScope` method. In addition to holding and passing tokens and token sources, CancelScope also provides a mechanism for handling cancellation. When cancellation is triggered for a given CancelScope, that CancelScope catches OperationCanceledException for its token source.\r\n\r\nThis addresses how to store cancellation tokens -- the next question is how to access them.\r\n\r\nIn general, the current cancellation token is always accessible via `CancelScope.CurrentScope?.Cts.CancellationToken`. If a method wanted to query the current token for cancellation, it could access the above property manually. However, this is laborious and is one of the problems we\u0027d like to solve.\r\n\r\nInstead of directing every library author to manually check for cancellation, I propose that we check for cancellation on every `await`. As described in the above article on the Trio library, this provides an easily syntactically identifiable place for cancellation to happen, and it should be a place where users expect their method to potentially leave their control.\r\n\r\nWith automatic checking for cancellation, most cancellation tasks should now be fairly easy. Of course, manual use of CancellationTokenSource and CancellationToken will be required for advanced scenarios, but that should rightly be the minority of uses.\r\n\r\n## Implementation details\r\n\r\nI do not know the async machinery in full detail, so this is only one option for implementation. Most importantly, `CancelScope.CurrentScope` would be backed by an `AsyncLocal` variable that is updated every time a new scope is introduced. In particular, the implementation looks like this:\r\n\r\n```C#\r\nclass CancelScope\r\n{\r\n    [AsyncLocal]\r\n    private static AsyncLocal\u003cCancelScope?\u003e s_currentScope = null;\r\n    public static CancelScope? CurrentScope =\u003e s_currentScope.Value;\r\n\r\n    public CancellationTokenSource Cts { get; }\r\n\r\n    private CancelScope()\r\n    {\r\n        Cts = new CancellationTokenSource();\r\n    }\r\n\r\n    public static Task OpenScope(async Func\u003cCancelScope, Task\u003e func)\r\n    {\r\n        var oldScope = s_currentScope;\r\n        var newScope = new CancelScope();\r\n        try\r\n        {\r\n            s_currentScope.Value = newScope;\r\n            await func(newScope);\r\n        }\r\n        catch (OperationCanceledException e) when (e.CancellationToken == newScope)\r\n        {\r\n            // Do nothing, we could add an overload with another func to run here\r\n        }\r\n        finally\r\n        {\r\n            s_currentScope = oldScope;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nThis implementation should allow scopes to be nested and for each task to retrieve the appropriate value.\r\n\r\nAs mentioned above, the other piece of this proposal is to check for cancellation on every `await`. This could be accomplished by calling `CancelScope.CurrentScope?.Cts.CancellationToken.ThrowIfCancellationRequested()` at the beginning of the `GetAwaiter()` method.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOa7QH2A==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5U2_WY",
                                           "createdAt":  "2023-02-09T06:27:14Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-threading-tasks\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n\r\n# Cancel scopes\r\n\r\nThis is the first proposal in what I hope to be a few proposals around a paradigm called \"structured concurrency.\" The fundamental idea is that, by encouraging concurrent code to follow strict control flow and scoping rules, the overall code structure can be better understood and managed.\r\n\r\nIf you\u0027re not familiar with the concept I recommend reading the following articles by Nathan J. Smith, who\u0027s Trio library pioneered many of these concepts.\r\n\r\n- [Timeouts and cancellation for humans](https://vorpus.org/blog/notes-on-structured-concurrency-or-go-statement-considered-harmful/)\r\n- [Structured concurrency](https://vorpus.org/blog/notes-on-structured-concurrency-or-go-statement-considered-harmful/)\r\n\r\nThis proposal focuses on the theme in the first article: cancellation.\r\n\r\n## Background -- C# cancellation\r\n\r\nFirst, some background on cancellation in C#. Cancellation in C# is almost entirely a library-level concept with no language integration. Users are expected to manually create and pass around CancellationTokens, which are then passed to library methods which have been written to take CancellationToken parameters. Methods which support cancellation are meant to regularly check the token for cancellation and throw if it has been cancelled, and consumers are meant to wrap code in `try-catch` blocks to capture `OperationCanceledException`s.\r\n\r\nThis creates various problems, as described in the article, including:\r\n\r\n* Passing cancellation tokens through code is laborious and easily overlooked\r\n* API writers can often forget to wire through cancellation even though they should\r\n* Libraries that wish to support cancellation must manually add checks to see if the cancellation token has been triggered\r\n* Callers must manually handle `OperationCanceledException`\r\n\r\n## Proposal\r\n\r\nTo address these problems, I propose we introduce a new CancelScope type. The type definition looks like following.\r\n\r\n```C#\r\nsealed class CancelScope\r\n{\r\n    public static CancelScope? CurrentScope { get; }\r\n\r\n    public static Task OpenScope(Func\u003cCancelScope, Task\u003e func);\r\n\r\n    public CancellationTokenSource Cts { get; }\r\n    ...\r\n}\r\n```\r\n\r\nThis is an incomplete definition, meant to introduce the proposal, rather than explain all the details.\r\n\r\nUsing a CancelScope is similar to using a CancellationToken and CancellationTokenSource today, except that instead of passing the token to nested async calls, you open a new nested CancelScope with `CancelScope.OpenScope`.\r\n\r\n```C#\r\nasync Task UserMethod()\r\n{\r\n    await CancelScope.OpenScope(newScope =\u003e\r\n    {\r\n        // Do whatever you would normally do\r\n        // newScope.Cts.CancelAfter(50);\r\n        // await Task.Delay(20);\r\n        // await client.GetAsync();\r\n        // await UserMethod2();\r\n    });\r\n}\r\n```\r\n\r\nNow, instead of having to pass a cancellation token to each method, transitively, a user only has to pass the token once, to the `WithScope` method. In addition to holding and passing tokens and token sources, CancelScope also provides a mechanism for handling cancellation. When cancellation is triggered for a given CancelScope, that CancelScope catches OperationCanceledException for its token source.\r\n\r\nThis addresses how to store cancellation tokens -- the next question is how to access them.\r\n\r\nIn general, the current cancellation token is always accessible via `CancelScope.CurrentScope?.Cts.CancellationToken`. If a method wanted to query the current token for cancellation, it could access the above property manually. However, this is laborious and is one of the problems we\u0027d like to solve.\r\n\r\nInstead of directing every library author to manually check for cancellation, I propose that we check for cancellation on every `await`. As described in the above article on the Trio library, this provides an easily syntactically identifiable place for cancellation to happen, and it should be a place where users expect their method to potentially leave their control.\r\n\r\nWith automatic checking for cancellation, most cancellation tasks should now be fairly easy. Of course, manual use of CancellationTokenSource and CancellationToken will be required for advanced scenarios, but that should rightly be the minority of uses.\r\n\r\n## Implementation details\r\n\r\nI do not know the async machinery in full detail, so this is only one option for implementation. Most importantly, `CancelScope.CurrentScope` would be backed by an `AsyncLocal` variable that is updated every time a new scope is introduced. In particular, the implementation looks like this:\r\n\r\n```C#\r\nclass CancelScope\r\n{\r\n    [AsyncLocal]\r\n    private static AsyncLocal\u003cCancelScope?\u003e s_currentScope = null;\r\n    public static CancelScope? CurrentScope =\u003e s_currentScope.Value;\r\n\r\n    public CancellationTokenSource Cts { get; }\r\n\r\n    private CancelScope()\r\n    {\r\n        Cts = new CancellationTokenSource();\r\n    }\r\n\r\n    public static Task OpenScope(async Func\u003cCancelScope, Task\u003e func)\r\n    {\r\n        var oldScope = s_currentScope;\r\n        var newScope = new CancelScope();\r\n        try\r\n        {\r\n            s_currentScope.Value = newScope;\r\n            await func(newScope);\r\n        }\r\n        catch (OperationCanceledException e) when (e.CancellationToken == newScope)\r\n        {\r\n            // Do nothing, we could add an overload with another func to run here\r\n        }\r\n        finally\r\n        {\r\n            s_currentScope = oldScope;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nThis implementation should allow scopes to be nested and for each task to retrieve the appropriate value.\r\n\r\nAs mentioned above, the other piece of this proposal is to check for cancellation on every `await`. This could be accomplished by calling `CancelScope.CurrentScope?.Cts.CancellationToken.ThrowIfCancellationRequested()` at the beginning of the `GetAwaiter()` method.\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eagocke\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Threading.Tasks`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-02-09T06:27:14Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5U3bXd",
                                           "createdAt":  "2023-02-09T08:34:03Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Clockwork-Muse",
                                           "body":  "\u003e When cancellation is triggered for a given CancelScope, that CancelScope catches OperationCanceledException for its token source.\r\n\r\nDoes it just swallow it?  Or something else?  Note that the point of the type is already to be deliberately caught.  OCE/`TaskCanceledException` are \"expected exceptions\" (like most I/O exceptions), and one you\u0027re encouraged to have control flow for.\r\n\r\nThat said, this is actually a duplicate: https://github.com/dotnet/runtime/issues/29881",
                                           "updatedAt":  "2023-02-09T08:34:03Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5U4FMr",
                                           "createdAt":  "2023-02-09T10:50:07Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "agocke",
                                           "body":  "\u003e Does it just swallow it? Or something else\r\n\r\nSee the implementation details. Basic API just swallows and moves on. Another delegate could be provided for cancel-specific behavior. \r\n\r\n\u003e That said, this is actually a duplicate: https://github.com/dotnet/runtime/issues/29881\r\n\r\nNot the same. This proposal is much more comprehensive with stricter semantics. ",
                                           "updatedAt":  "2023-02-09T10:50:07Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5U5M1n",
                                           "createdAt":  "2023-02-09T14:31:08Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODMYvmQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "strangeman375",
                                                                               "createdAt":  "2023-02-10T09:39:34Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Joe4evr",
                                                                               "createdAt":  "2023-02-13T12:54:39Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "TheAIBot",
                                                                               "createdAt":  "2023-11-11T19:30:58Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  3
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "We\u0027ve tried this multiple times in the past, once with a CancellationRegion and once with a CancellationScope, the latter of which was almost identical to what\u0027s being proposed (though it accepted a CancellationToken to a scope constructor instead of creating a CancellationTokenSource implicitly, and it had alternate designs for whether to run all the work in a delegate, in which case it could choose to eat cancellation exceptions, or just a using block that didn\u0027t have the overhead of the extra async lambda but didn\u0027t eat exceptions).  We didn\u0027t ship them because there were too many problems with the design.\r\n\r\nMany of the problems are to do with composability, in a variety of ways.  It\u0027s not uncommon that an operation needs to perform some work using something that is cancelable but that must not be canceled even if the overall operation is, e.g. queueing a work item to handle asynchronous completion, regardless of the reason for that completion (which could include cancellation), such that if the work item were canceled, the whole thing would deadlock.  It\u0027s also not uncommon to have multiple sources of cancellation, e.g. some external trigger as well as an internal trigger, for example someone wanting to be able to explicitly cancel an HTTP request but the HTTP implementation also needing to respect a timeout.  The ambient nature of a proposal like this makes it incredibly difficult for implementations to get all variations of this \"right\".  Should they ignore the ambient token if one exists?  Should they combine it with one explicitly provided?  There\u0027s no one right answer for everything.  And this is made all the more complicated by us now having over a decade of libraries built with assumptions around this that will be violated based on whatever decisions were to be made.\r\n\r\nThere\u0027s also performance ramifications.  Flowing state via ExecutionContext / AsyncLocals is not free.  Every mutation to an AsyncLocal\u0027s value results in an allocation, creating a new immutable object to store the new state.  And with the current implementation, which has evolved over the years to fine-tune it for current uses, the more async locals you have, the more expensive they all become: the async local values are all stored together in a single immutable object, such that changing any of them requires allocating a new object large enough to store the values for all of them.  The proposed design would make it more common to both use and mutate AsyncLocals, and would thereby put increased pressure on the rest of the system.  There\u0027s also the read cost; practically every method that today accepts a CancellationToken would effectively need to query a [ThreadLocal] that stores the current ExecutionContext containing those AsyncLocals, and perform a dictionary lookup to find the right state.  That\u0027s going to be an increase in the peanut butter across the system.  It\u0027s also not something that can easily be made lazy; many methods that accept CancellationTokens do an upfront cancellation check, and for consistency you\u0027d want them to be checking the ambient token, plus doing whatever combination logic was needed to check against both the passed in token and the ambient one.  On top of that you have the costs of the extra async state machine for the lambda, plus delegate allocation / closure allocation, etc. each time one of those delegate-based scopes is created.\r\n\r\nYou also have all existing code to contend with.  Existing code won\u0027t be paying attention to the ambient scope, and folks just switching from passing in a token to instead using a scope will be sorely disappointed when many of the things they were hoping to be canceled aren\u0027t.  With regards to \"I propose that we check for cancellation on every await\", that hits all the same problems previously described.  It also doesn\u0027t help with leaf implementations that aren\u0027t using async/await because async/await is only applicable to composition, not to implementing the leaf operations that represent the actual I/O.\r\n\r\nI understand the benefits of the proposed approach, and I understand why it\u0027s attractive in some ways.  It\u0027s why we\u0027ve invested in such an approach multiple times in the past.  I\u0027m not particularly excited about trying again, and I\u0027m not optimistic the outcome would be any better.",
                                           "updatedAt":  "2023-02-09T14:34:48Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5U7dyf",
                                           "createdAt":  "2023-02-09T21:40:23Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODMY6tA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "timonkrebs",
                                                                               "createdAt":  "2023-11-11T22:48:50Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "timonkrebs",
                                                                               "createdAt":  "2023-11-11T22:48:54Z"
                                                                           },
                                                                           {
                                                                               "content":  "HOORAY",
                                                                               "user":  "timonkrebs",
                                                                               "createdAt":  "2023-11-11T22:48:58Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  3
                                                         },
                                           "author":  "agocke",
                                           "body":  "@stephentoub Thanks for the comment! It has tons of useful detail and background.\r\n\r\nOne big takeaway I have, though, is that you didn\u0027t seem to disagree with the top-level points about problems in our cancellation story. It costs us a lot as we need to add, plum through, and check tokens, it costs libraries authors a lot to do the same, and it costs users who have to do all that, plus navigate the clutter that it adds to their APIs.\r\n\r\nOverall, it feels like the vast majority of user cases are not being satisfied by our current system. I would bet that the vast majority of customers only deal with one token that they pass down to all their callees.\r\n\r\nI know the challenge seems impossible, but I don\u0027t see how we can avoid continuing to try to solve this. Other platforms and tools have seemed to demonstrate that a simpler model is possible and having ours remain super complicated feels like stagnation.\r\n\r\nTo that end, I\u0027d really like to try to really pan out and start thinking of solutions that we might have ruled out before. For instance, you mentioned that AsyncLocal perf was an impediment. Is there a change that we could make in the language, the runtime, or both to make AsyncLocal a lot cheaper? Or, maybe it\u0027s expensive in the very general case, but is there a really common case (say, where every async call is immediately awaited) where we could make it substantially cheaper?\r\n\r\nI\u0027m open to a lot of solutions here, I\u0027d just like to see us build something transformative for users.",
                                           "updatedAt":  "2023-02-09T21:40:39Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5U7ecI",
                                           "createdAt":  "2023-02-09T21:43:12Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "agocke",
                                           "body":  "Btw, one example\r\n\r\n\u003e , or just a using block that didn\u0027t have the overhead of the extra async lambda but didn\u0027t eat exceptions)\r\n\r\nThis is a super, super simple thing to fix in C# -- we should just add the ability for `IDisposable`, or a new inheriting interface, to handle exceptions. It seems like a minor oversight that we could easily fix if we were really worried about delegate cost.",
                                           "updatedAt":  "2023-02-09T21:43:12Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5U8b7b",
                                           "createdAt":  "2023-02-10T03:36:56Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODMYvsw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "strangeman375",
                                                                               "createdAt":  "2023-02-10T09:39:48Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Joe4evr",
                                                                               "createdAt":  "2023-02-13T12:56:29Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "TheAIBot",
                                                                               "createdAt":  "2023-11-11T19:32:22Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  3
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e One big takeaway I have, though, is that you didn\u0027t seem to disagree with the top-level points about problems in our cancellation story.\r\n\r\nI do disagree, actually.  You cited the following:\r\n\r\n\u003e Callers must manually handle OperationCanceledException\r\n\r\nRegardless of the model, callers need to react to cancellation happening just as they react to other failures that caused the code to not run to completion; just eating cancellation on behalf of someone and making the difference between success and cancellation evaporate leads to reliability problems.  Developers writing such code to react to cancellation is not a flaw, it\u0027s a necessity; moreover, it would continue to be required with the proposal, even if there\u0027s ultimately a back stop for such exceptions.  Catching the exceptions automatically would just make it more likely programs have bugs by papering over the fact that something which was supposed to happen didn\u0027t actually happen.  There are of course cases where nothing need be done to react to cancellation occurring, but in my experience that\u0027s the significant minority case, not the majority.\r\n\r\n\u003e Libraries that wish to support cancellation must manually add checks to see if the cancellation token has been triggered\r\n\r\nNot really.  Manual polling for cancellation is optional.  If you\u0027re just composing other operations, the 99% case is you just pass along the token to those other operations.  As an optimization, APIs will often do an upfront check for cancellation, but that\u0027s just to avoid doing any work if it\u0027s likely cancellation will have already been requested. And sometimes devs will add additional polling locations strategically placed just to increase responsiveness to cancellation in otherwise uninterruptable blocks. But you only _need_ to write special code to react to cancellation when you\u0027re transitioning into something that doesn\u0027t already represent cancellation via CancellationToken, at which point you Register with the token to write the code that will forward along the cancellation signal in some manner.  That code is necessary to bridge the worlds, and it would continue to be necessary with this proposal.\r\n\r\n\u003e API writers can often forget to wire through cancellation even though they should\r\n\r\nYes, if you have a cancellation token, you might neglect to pass it to another method that expects one.  That\u0027s why rules like CA2016 now exist:\r\n\u003cimg width=\"791\" alt=\"image\" src=\"https://user-images.githubusercontent.com/2642209/217993218-db692564-b047-466d-84d8-1b3930eb2b3a.png\"\u003e\r\nhttps://learn.microsoft.com/en-us/dotnet/fundamentals/code-analysis/quality-rules/ca2016\r\nIf there are tweaks to this rule we need to make to help developers more, or if there are others rules we should be putting in place to aid developers, I\u0027m all for improvements in the area.\r\n\r\n\u003e Passing cancellation tokens through code is laborious and easily overlooked\r\n\r\nI can sympathize with not loving passing the cancellation token around.  I personally wouldn\u0027t, however, call it \"laborious\".  If we could make this easier without incurring other negatives, I\u0027d be interested in understanding what are those options.  But I do believe something that can cause arbitrary code to fail needs to be forefront in the code, and I worry that having ambient signals affecting API calls without that showing up at all sites will actually be a significant net negative on reliability.  If every function someone writes might be interrupted with exceptions at effectively arbitrary points, we\u0027re dangerously approaching a world of thread interrupts and thread aborts.",
                                           "updatedAt":  "2023-02-10T04:01:38Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5VAyqM",
                                           "createdAt":  "2023-02-10T19:57:20Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODMY7Bg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "stephentoub",
                                                                               "createdAt":  "2023-02-10T20:11:22Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "timonkrebs",
                                                                               "createdAt":  "2023-11-11T22:54:56Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "agocke",
                                           "body":  "Good feedback. I disagree that dealing with cancellation tokens isn\u0027t laborious. It\u0027s a mostly mechanical operation that slows down my development and requires extra thought.\r\n\r\nThat said, I appreciate the feedback that the cure might be worse than the disease. I think the next step is for me to try to come up with a compelling sample of problems where a scoped solution makes things better without making anything else worse.\r\n\r\nMy suspicion is that your bar is pretty high here, so I\u0027ll try to write an actual library to demo this experience. Getting things to be accurate may be difficult, since I have to find clever ways to hack into the existing system, so it might take a little time.",
                                           "updatedAt":  "2023-02-10T19:57:20Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5rtAfY",
                                           "createdAt":  "2023-11-12T00:41:29Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "timonkrebs",
                                           "body":  "What about going more into a declarative direction? I made this library that explores a more declarative way to concurrency: https://github.com/timonkrebs/MemoizR#declarative-structured-concurrency\r\n\r\nThis approach should take away a lot of the burden of handling complex concurrent cancellation/error-handling.\r\nIt is still in development but I think it already can add value for some cases.\r\n\r\nThis approach should also be able to handle resources for concurrency scenarios with the same cancellation and error-handling capabilities. Something like: https://github.com/StephenCleary/StructuredConcurrency#resources\r\n\r\nPS: The Link in the description should be: https://vorpus.org/blog/timeouts-and-cancellation-for-humans/",
                                           "updatedAt":  "2023-11-12T00:41:29Z"
                                       }
                                   ],
                         "totalCount":  9
                     },
        "title":  "[API Proposal]: Cancel scopes",
        "labels":  [
                       "api-suggestion",
                       "area-System.Threading.Tasks"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/81876",
        "createdAt":  "2023-02-09T08:31:20Z",
        "number":  81876,
        "author":  "RAAvenger",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2024-07-19T16:35:03Z",
        "body":  "### Background and motivation\n\nI\u0027m writing a code that exposes an NpgsqlDataReader. I would like to use async methods of DataReader and also be able to test my code by mocking DataReader, so i prefer to expose an IDataReader that can be mocked but if i do this i can\u0027t use async methods. Of course there is workaround like writing wrapper and ... but it would be great if the interface contains async methods.\n\n### API Proposal\n\n```csharp\r\nnamespace System.Data\r\n{\r\n    public interface IDataReader : IDisposable, IDataRecord\r\n    {\r\n        int Depth { get; }\r\n        bool IsClosed { get; }\r\n        int RecordsAffected { get; }\r\n        void Close();\r\n        Task CloseAsync();\r\n        DataTable? GetSchemaTable();\r\n        Task\u003cDataTable?\u003e GetSchemaTableAsync(CancellationToken cancellationToken);\r\n        bool NextResult();\r\n        Task\u003cbool\u003e NextResultAsync(CancellationToken cancellationToken);\r\n        bool Read();\r\n        Task\u003cbool\u003e ReadAsync(CancellationToken cancellationToken);\r\n    }\r\n}\r\n```\r\n\n\n### API Usage\n\n```csharp\r\n\r\nvar connection = new NpgsqlConnection(connectionString);\r\nawait connection.OpenAsync(cancellationToken).ConfigureAwait(false);\r\nvar command = connection.CreateCommand();\r\ncommand.CommandText = query;\r\nIDataReader reader = await command.ExecuteReaderAsync(cancellationToken).ConfigureAwait(false);\r\nwhile(await reader.ReadAsync(connectionString).ConfigureAwait(false))\r\n{\r\n// get data\r\n}\r\n```\r\n\n\n### Alternative Designs\n\n_No response_\n\n### Risks\n\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOVONj_A==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5U3aq6",
                                           "createdAt":  "2023-02-09T08:31:28Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-threading-tasks\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Background and motivation\n\nI\u0027m writing a code that exposes an NpgsqlDataReader. I would like to use async methods of DataReader and also be able to test my code by mocking DataReader, so i prefer to expose an IDataReader that can be mocked but if i do this i can\u0027t use async methods. Of course there is workaround like writing wrapper and ... but it would be great if the interface contains async methods.\n\n### API Proposal\n\n```csharp\r\nnamespace System.Data\r\n{\r\n    public interface IDataReader : IDisposable, IDataRecord\r\n    {\r\n        int Depth { get; }\r\n        bool IsClosed { get; }\r\n        int RecordsAffected { get; }\r\n        void Close();\r\n        Task CloseAsync();\r\n        DataTable? GetSchemaTable();\r\n        Task\u003cDataTable?\u003e GetSchemaTableAsync(CancellationToken cancellationToken);\r\n        bool NextResult();\r\n        Task\u003cbool\u003e NextResultAsync(CancellationToken cancellationToken);\r\n        bool Read();\r\n        Task\u003cbool\u003e ReadAsync(CancellationToken cancellationToken);\r\n    }\r\n}\r\n```\r\n\n\n### API Usage\n\n```csharp\r\n\r\nvar connection = new NpgsqlConnection(connectionString);\r\nawait connection.OpenAsync(cancellationToken).ConfigureAwait(false);\r\nvar command = connection.CreateCommand();\r\ncommand.CommandText = query;\r\nIDataReader reader = await command.ExecuteReaderAsync(cancellationToken).ConfigureAwait(false);\r\nwhile(await reader.ReadAsync(connectionString).ConfigureAwait(false))\r\n{\r\n// get data\r\n}\r\n```\r\n\n\n### Alternative Designs\n\n_No response_\n\n### Risks\n\n_No response_\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eRAAvenger\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`api-suggestion`, `area-System.Threading.Tasks`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-02-09T08:31:28Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5U4FCz",
                                           "createdAt":  "2023-02-09T10:49:34Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "svick",
                                           "body":  "Just adding methods to an interface is a massive breaking change, so it\u0027s not going to happen.\r\n\r\nAdding them as default interface methods is much less of a breaking change, but then the question becomes what the default implementation should be and I\u0027m not sure there is a good answer to that.\r\n\r\nCan\u0027t you mock `DbDataReader` for your tests instead?",
                                           "updatedAt":  "2023-02-09T10:49:34Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5U42P8",
                                           "createdAt":  "2023-02-09T13:24:26Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "RAAvenger",
                                           "body":  "thanks for your suggestion. using `DbDataReader` will resolve my issue.\r\nA non-breaking option that comes to mind is to define a new Interface (e.g. `IAsyncDataReader`) for all those async method overloads of `DbDataReader` class and let `DbDataReader` implement the aforementioned interface alongside the existing `IDataReader`",
                                           "updatedAt":  "2023-02-09T13:24:26Z"
                                       }
                                   ],
                         "totalCount":  3
                     },
        "title":  "[API Proposal]: Add Async Methods to IDataReader",
        "labels":  [
                       "api-suggestion",
                       "area-System.Threading.Tasks",
                       "needs-further-triage"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/83159",
        "createdAt":  "2023-03-08T20:35:17Z",
        "number":  83159,
        "author":  "cretz",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOCuxfQQ==",
                          "nodes":  [
                                        {
                                            "content":  "CONFUSED",
                                            "user":  "theodorzoulias",
                                            "createdAt":  "2023-03-08T21:00:47Z"
                                        }
                                    ],
                          "totalCount":  1
                      },
        "updatedAt":  "2024-06-28T14:32:35Z",
        "body":  "### Description\n\n`ReceiveAsync` creates a `ReceiveTarget` at https://github.com/dotnet/runtime/blob/14123c989d6de088ac0ea24bc1d7f1d6b507f06f/src/libraries/System.Threading.Tasks.Dataflow/src/Base/DataflowBlock.cs#L1073 that does not allow any configuration of a task scheduler like https://learn.microsoft.com/en-us/dotnet/standard/parallel-programming/how-to-specify-a-task-scheduler-in-a-dataflow-block would have one believe.\n\n### Reproduction Steps\n\nCreate block, e.g. `var block = new BufferBlock\u003cbool\u003e(new() { TaskScheduler = TaskScheduler.Current });` and confirm that `block.ReceiveAsync()` does not use it..\n\n### Expected behavior\n\nShould use configured task scheduler or at least be well documented that there is no configuration of task scheduling for some dataflow extension methods.\n\n### Actual behavior\n\nSurprising behavior of using unconfigurable global default scheduler. While global default may be sensible default, should either allow customization or document the limitation.\n\n### Regression?\n\n_No response_\n\n### Known Workarounds\n\nNone, have to not use the extension methods.\n\n### Configuration\n\n_No response_\n\n### Other information\n\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHObk8n5w==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5XErKm",
                                           "createdAt":  "2023-03-08T20:35:24Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-threading-tasks\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Description\n\n`ReceiveAsync` creates a `ReceiveTarget` at https://github.com/dotnet/runtime/blob/14123c989d6de088ac0ea24bc1d7f1d6b507f06f/src/libraries/System.Threading.Tasks.Dataflow/src/Base/DataflowBlock.cs#L1073 that does not allow any configuration of a task scheduler like https://learn.microsoft.com/en-us/dotnet/standard/parallel-programming/how-to-specify-a-task-scheduler-in-a-dataflow-block would have one believe.\n\n### Reproduction Steps\n\nCreate block, e.g. `var block = new BufferBlock\u003cbool\u003e(new() { TaskScheduler = TaskScheduler.Current });` and confirm that `block.ReceiveAsync()` does not use it..\n\n### Expected behavior\n\nShould use configured task scheduler or at least be well documented that there is no configuration of task scheduling for some dataflow extension methods.\n\n### Actual behavior\n\nSurprising behavior of using unconfigurable global default scheduler. While global default may be sensible default, should either allow customization or document the limitation.\n\n### Regression?\n\n_No response_\n\n### Known Workarounds\n\nNone, have to not use the extension methods.\n\n### Configuration\n\n_No response_\n\n### Other information\n\n_No response_\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003ecretz\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Threading.Tasks`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-03-08T20:35:24Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5XFrCz",
                                           "createdAt":  "2023-03-09T01:01:46Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "Which tasks aren\u0027t being scheduled to the block\u0027s scheduler that you\u0027d expect to be?",
                                           "updatedAt":  "2023-03-09T01:01:46Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5XJm4A",
                                           "createdAt":  "2023-03-09T14:14:11Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "cretz",
                                           "body":  "`SendAsync` causes it for a receive target on `ReceiveAsync`. I can explain my use case.\r\n\r\nI am making a deterministic manual task scheduler for Temporal workflows at https://github.com/temporalio/sdk-dotnet. I already have a custom event source listener that checks that all tasks are created on my scheduler when running with my scheduler as the current scheduler to prevent anyone from using the default scheduler in workflows. And of course https://learn.microsoft.com/en-us/dotnet/fundamentals/code-analysis/quality-rules/ca2008 catches some (though I request they actually _do_ use `Current`).\r\n\r\nBut this triggered my detector because the task for `SendAsync`/`ReceiveAsync` schedules a task on a different scheduler. https://learn.microsoft.com/en-us/dotnet/standard/parallel-programming/how-to-specify-a-task-scheduler-in-a-dataflow-block implies I can customize the scheduler for dataflow block use. Here\u0027s the stack:\r\n\r\n```\r\nTemporalio.Exceptions.InvalidWorkflowOperationException: Task scheduled during workflow run was not scheduled on workflow scheduler\r\n   at System.Environment.get_StackTrace()\r\n   at Temporalio.Worker.WorkflowTaskEventListener.OnEventWritten(EventWrittenEventArgs eventData) in c:\\work\\tem\\sdk-dotnet\\temporal-sdk-dotnet\\src\\Temporalio\\Worker\\WorkflowTaskEventListener.cs:line 120\r\n   at System.Diagnostics.Tracing.EventSource.DispatchToAllListeners(EventWrittenEventArgs eventCallbackArgs)\r\n   at System.Diagnostics.Tracing.EventSource.WriteToAllListeners(EventWrittenEventArgs eventCallbackArgs, Int32 eventDataCount, EventData* data)\r\n   at System.Diagnostics.Tracing.EventSource.WriteEventWithRelatedActivityIdCore(Int32 eventId, Guid* relatedActivityId, Int32 eventDataCount, EventData* data)\r\n   at System.Threading.Tasks.TplEventSource.TaskScheduled(Int32 OriginatingTaskSchedulerID, Int32 OriginatingTaskID, Int32 TaskID, Int32 CreatingTaskID, Int32 TaskCreationOptions, Int32 appDomain)\r\n   at System.Threading.Tasks.Task.FireTaskScheduledIfNeeded(TaskScheduler ts)\r\n   at System.Threading.Tasks.TaskScheduler.InternalQueueTask(Task task)\r\n   at System.Threading.Tasks.Task.ScheduleAndStart(Boolean needsProtection)\r\n   at System.Threading.Tasks.Task.InternalStartNew(Task creatingTask, Delegate action, Object state, CancellationToken cancellationToken, TaskScheduler scheduler, TaskCreationOptions options, InternalTaskOptions internalOptions)\r\n   at System.Threading.Tasks.TaskFactory.StartNew(Action`1 action, Object state, CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskScheduler scheduler)\r\n   at System.Threading.Tasks.Dataflow.DataflowBlock.ReceiveTarget`1.CleanupAndComplete(ReceiveCoreByLinkingCleanupReason reason)\r\n   at System.Threading.Tasks.Dataflow.DataflowBlock.ReceiveTarget`1.System.Threading.Tasks.Dataflow.ITargetBlock\u003cT\u003e.OfferMessage(DataflowMessageHeader messageHeader, T messageValue, ISourceBlock`1 source, Boolean consumeToAccept)\r\n   at System.Threading.Tasks.Dataflow.Internal.SourceCore`1.OfferToTargets(ITargetBlock`1 linkToTarget)\r\n   at System.Threading.Tasks.Dataflow.Internal.SourceCore`1.OfferMessagesLoopCore()\r\n   at System.Threading.Tasks.Dataflow.Internal.SourceCore`1.\u003c\u003ec.\u003cOfferAsyncIfNecessary_Slow\u003eb__44_0(Object thisSourceCore)\r\n   at System.Threading.Tasks.Task.InnerInvoke()\r\n   at System.Threading.Tasks.Task.\u003c\u003ec.\u003c.cctor\u003eb__272_0(Object obj)\r\n   at System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state)\r\n   at System.Threading.Tasks.Task.ExecuteWithThreadLocal(Task\u0026 currentTaskSlot, Thread threadPoolThread)\r\n   at System.Threading.Tasks.Task.ExecuteEntry()\r\n   at System.Threading.Tasks.TaskScheduler.TryExecuteTask(Task task)\r\n```\r\n\r\nI can understand if this won\u0027t be supported, but maybe at least some docs saying dataflow extension calls cannot use custom scheduling.",
                                           "updatedAt":  "2023-03-09T14:16:03Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5XJt8Z",
                                           "createdAt":  "2023-03-09T14:33:17Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "cretz",
                                           "body":  "Specifically https://github.com/dotnet/runtime/blob/5f94bffeff62f4b767a311a4505d6d40d86279d9/src/libraries/System.Threading.Tasks.Dataflow/src/Base/DataflowBlock.cs#L1323-L1329",
                                           "updatedAt":  "2023-03-09T14:33:17Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5jycva",
                                           "createdAt":  "2023-08-11T03:27:46Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ericstj",
                                           "body":  "@stephentoub what\u0027s your thought on this one.  Is there an issue here with the scheduling or should we just document this?",
                                           "updatedAt":  "2023-08-11T03:27:46Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5uTvPf",
                                           "createdAt":  "2023-12-11T18:38:37Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e @stephentoub what\u0027s your thought on this one. Is there an issue here with the scheduling or should we just document this?\r\n\r\nThis is behaving as designed, so from that perspective, it would just be further clarification as needed in the docs. Factoring in a different scheduler would require new APIs / overloads; if that\u0027s what\u0027s desired, it\u0027d be good to go through the API proposal route.\r\n\r\n\u003e I can explain my use case.\r\n\r\nThanks for the details. If you\u0027d like to propose a new overload, please feel free to open an API issue for that.",
                                           "updatedAt":  "2023-12-11T18:39:11Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5uTyfn",
                                           "createdAt":  "2023-12-11T18:47:08Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "cretz",
                                           "body":  ":+1: I don\u0027t have a concrete proposal, so just some docs clarity would be ideal (thanks!)",
                                           "updatedAt":  "2023-12-11T18:47:08Z"
                                       }
                                   ],
                         "totalCount":  7
                     },
        "title":  "System.Threading.Tasks.Dataflow.DataflowBlock.ReceiveAsync does not use custom scheduler",
        "labels":  [
                       "documentation",
                       "area-System.Threading.Tasks"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/83520",
        "createdAt":  "2023-03-16T15:50:40Z",
        "number":  83520,
        "author":  "mhinkka",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOC-phxw==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "tsiipola",
                                            "createdAt":  "2023-03-16T21:07:41Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "theodorzoulias",
                                            "createdAt":  "2023-03-22T18:49:40Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "dshinkarev",
                                            "createdAt":  "2024-02-22T15:44:07Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "dartasen",
                                            "createdAt":  "2025-01-31T16:08:59Z"
                                        }
                                    ],
                          "totalCount":  4
                      },
        "updatedAt":  "2025-07-15T14:36:27Z",
        "body":  "### Description\r\n\r\nI have a Web API application hosted in IIS that sorts rows of an array (actually a two-dimensional array/table of objects: object[][]) using expressions similar to this:\r\n\r\n`rows.AsParallel().AsOrdered().WithCancellation(cts.Token).OrderBy(...).ThenBy(...).ToList()` \r\n\r\nThe application has built-in support for canceling any running sorting operation at any point. This cancellation performs cancellation for the thread that is sorting the array using a call to Thread.Interrupt-function as well as calling CancellationTokenSource.Cancel for the CancellationTokenSource (cts). I want to use both methods as I can\u0027t pass the cancellation token into all the places these cancellable operations could call (Including, e.g., third-party components).\r\n\r\nWe have been getting intermittent unhandled System.InvalidCastException exceptions from System.Threading.Tasks.Task.RunContinuations crashing the whole application in situations that have the following issues in common:\r\n\r\n1. PLINQ sorting operation is being run.\r\n2. The sorting operation has been interrupted with the ThreadInterruptException.\r\n3. An unhandled exception was thrown from System.Threading.Tasks.Task.RunContinuations.\r\nThis exception has the following details:\r\n\r\n```\r\nSystem.InvalidCastException: Unable to cast object of type \u0027System.Object\u0027 to type \u0027System.Collections.Generic.List`1[System.Object]\u0027.\r\n   at System.Threading.Tasks.Task.RunContinuations(Object continuationObject)\r\n   at System.Threading.Tasks.Task.ProcessChildCompletion(Task childTask)\r\n   at System.Threading.Tasks.Task.FinishStageTwo()\r\n   at System.Threading.Tasks.Task.FinishSlow(Boolean userDelegateExecute)\r\n   at System.Threading.Tasks.Task.ExecuteWithThreadLocal(Task\u0026 currentTaskSlot, Thread threadPoolThread)\r\n   at System.Threading.ThreadPoolWorkQueue.Dispatch()\r\n   at System.Threading.PortableThreadPool.WorkerThread.WorkerThreadStart() \r\n```\r\n\r\nIn some cases, if the worker thread is using the thread that initiated the PLINQ operation, this stack trace looks different and in that case, this exception could be caught, but this situation seems quite rare as usually parallel tasks are being processed by other threads than the PLINQ caller. Thus, there is no way to catch the exception that occurred in System.Threading.Tasks.Task.RunContinuations, the application terminates.\r\n\r\nTo me, this seems like a problem in the .NET 6 runtime as I don\u0027t see how I can directly affect the continuationObjects being passed to System.Threading.Tasks.Task.RunContinuations.\r\n\r\nCan you confirm whether this is an issue in .NET 6 runtime and/or is there some way for me to adjust my application so that this does not occur anymore?\r\n\r\nNote also that in the reproducion step-function shown below, the stack trace is slightly different, but the situation is still as fatal as in this production environment case:\r\n```\r\nApplication: testhost.exe\r\nCoreCLR Version: 6.0.1523.11507\r\n.NET Version: 6.0.15\r\nDescription: The process was terminated due to an unhandled exception.\r\nException Info: System.InvalidCastException: Unable to cast object of type \u0027System.Object\u0027 to type \u0027System.Collections.Generic.List`1[System.Object]\u0027.\r\n   at System.Threading.Tasks.Task.RunContinuations(Object continuationObject)\r\n   at System.Threading.Tasks.Task.FinishContinuations()\r\n   at System.Threading.Tasks.Task.FinishStageThree()\r\n   at System.Threading.Tasks.Task.FinishStageTwo()\r\n   at System.Threading.Tasks.Task.ProcessChildCompletion(Task childTask)\r\n   at System.Threading.Tasks.Task.NotifyParentIfPotentiallyAttachedTask()\r\n   at System.Threading.Tasks.Task.FinishStageThree()\r\n   at System.Threading.Tasks.Task.FinishStageTwo()\r\n   at System.Threading.Tasks.Task.FinishSlow(Boolean userDelegateExecute)\r\n   at System.Threading.Tasks.Task.ExecuteWithThreadLocal(Task\u0026 currentTaskSlot, Thread threadPoolThread)\r\n   at System.Threading.Tasks.Task.ExecuteEntryUnsafe(Thread threadPoolThread)\r\n   at System.Threading.ThreadPoolWorkQueue.Dispatch()\r\n   at System.Threading.PortableThreadPool.WorkerThread.WorkerThreadStart()\r\n   at System.Threading.Thread.StartCallback()\r\n```\r\n\r\n\r\n### Reproduction Steps\r\n\r\nI\u0027m not sure if this is minimal, nor whether it replicates in all the environments, but at least in my test environment using .NET 6.0.15 (CoreCLR 6.0.1523.11507) I can replicate this issue reliably by running the code in the following C# function:\r\n```\r\n\t\tpublic void CrashTest()\r\n\t\t{\r\n\t\t\tvar rnd = new Random();\r\n\t\t\tvar rows = Enumerable.Range(1, 1000000)\r\n\t\t\t\t.Select(x =\u003e new object[] { $\"T{rnd.Next()}\" })\r\n\t\t\t\t.ToArray();\r\n\t\t\tvar cts = new CancellationTokenSource();\r\n\r\n\t\t\tfor (var i = 0; i \u003c 10000; ++i)\r\n\t\t\t{\r\n\t\t\t\tvar thread1 = new Thread(() =\u003e\r\n\t\t\t\t{\r\n\t\t\t\t\ttry\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\twhile (true)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tvar _ = rows\r\n\t\t\t\t\t\t\t\t.AsParallel()\r\n\t\t\t\t\t\t\t\t.AsOrdered()\r\n\t\t\t\t\t\t\t\t.WithCancellation(cts.Token)\r\n\t\t\t\t\t\t\t\t.OrderBy(row =\u003e row[0])\r\n\t\t\t\t\t\t\t\t.ToList();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcatch (ThreadInterruptedException)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\r\n\t\t\t\tthread1.Start();\r\n\t\t\t\tThread.Sleep(rnd.Next(100));\r\n\t\t\t\tthread1.Interrupt();\r\n\t\t\t\tcts.Cancel();\r\n\t\t\t\tthread1.Join();\r\n\t\t\t}\r\n\t\t}\r\n\r\n```\r\n\r\n### Expected behavior\r\n\r\nApplication does not crash. \r\nPLINQ operation is cancelled without threads being killed.\r\n\r\n### Actual behavior\r\n\r\nAn unhandled InvlidCastException is thrown from System.Threading.Tasks.Task.RunContinuations crashing the whole application.\r\n\r\n```\r\nException generated into windows event log:\r\nLog Name:      Application\r\nSource:        .NET Runtime\r\nDate:          16/03/2023 17.27.19\r\nEvent ID:      1026\r\nTask Category: None\r\nLevel:         Error\r\nKeywords:      Classic\r\nUser:          N/A\r\nDescription:\r\nApplication: testhost.exe\r\nCoreCLR Version: 6.0.1523.11507\r\n.NET Version: 6.0.15\r\nDescription: The process was terminated due to an unhandled exception.\r\nException Info: System.InvalidCastException: Unable to cast object of type \u0027System.Object\u0027 to type \u0027System.Collections.Generic.List`1[System.Object]\u0027.\r\n   at System.Threading.Tasks.Task.RunContinuations(Object continuationObject)\r\n   at System.Threading.Tasks.Task.FinishContinuations()\r\n   at System.Threading.Tasks.Task.FinishStageThree()\r\n   at System.Threading.Tasks.Task.FinishStageTwo()\r\n   at System.Threading.Tasks.Task.ProcessChildCompletion(Task childTask)\r\n   at System.Threading.Tasks.Task.NotifyParentIfPotentiallyAttachedTask()\r\n   at System.Threading.Tasks.Task.FinishStageThree()\r\n   at System.Threading.Tasks.Task.FinishStageTwo()\r\n   at System.Threading.Tasks.Task.FinishSlow(Boolean userDelegateExecute)\r\n   at System.Threading.Tasks.Task.ExecuteWithThreadLocal(Task\u0026 currentTaskSlot, Thread threadPoolThread)\r\n   at System.Threading.Tasks.Task.ExecuteEntryUnsafe(Thread threadPoolThread)\r\n   at System.Threading.ThreadPoolWorkQueue.Dispatch()\r\n   at System.Threading.PortableThreadPool.WorkerThread.WorkerThreadStart()\r\n   at System.Threading.Thread.StartCallback()\r\n\r\nEvent Xml:\r\n\u003cEvent xmlns=\"http://schemas.microsoft.com/win/2004/08/events/event\"\u003e\r\n  \u003cSystem\u003e\r\n    \u003cProvider Name=\".NET Runtime\" /\u003e\r\n    \u003cEventID Qualifiers=\"0\"\u003e1026\u003c/EventID\u003e\r\n    \u003cVersion\u003e0\u003c/Version\u003e\r\n    \u003cLevel\u003e2\u003c/Level\u003e\r\n    \u003cTask\u003e0\u003c/Task\u003e\r\n    \u003cOpcode\u003e0\u003c/Opcode\u003e\r\n    \u003cKeywords\u003e0x80000000000000\u003c/Keywords\u003e\r\n    \u003cTimeCreated SystemTime=\"2023-03-16T15:27:19.4485051Z\" /\u003e\r\n    \u003cEventRecordID\u003e160159\u003c/EventRecordID\u003e\r\n    \u003cCorrelation /\u003e\r\n    \u003cExecution ProcessID=\"12224\" ThreadID=\"0\" /\u003e\r\n    \u003cChannel\u003eApplication\u003c/Channel\u003e\r\n    \u003cComputer\u003eNB474\u003c/Computer\u003e\r\n    \u003cSecurity /\u003e\r\n  \u003c/System\u003e\r\n  \u003cEventData\u003e\r\n    \u003cData\u003eApplication: testhost.exe\r\nCoreCLR Version: 6.0.1523.11507\r\n.NET Version: 6.0.15\r\nDescription: The process was terminated due to an unhandled exception.\r\nException Info: System.InvalidCastException: Unable to cast object of type \u0027System.Object\u0027 to type \u0027System.Collections.Generic.List`1[System.Object]\u0027.\r\n   at System.Threading.Tasks.Task.RunContinuations(Object continuationObject)\r\n   at System.Threading.Tasks.Task.FinishContinuations()\r\n   at System.Threading.Tasks.Task.FinishStageThree()\r\n   at System.Threading.Tasks.Task.FinishStageTwo()\r\n   at System.Threading.Tasks.Task.ProcessChildCompletion(Task childTask)\r\n   at System.Threading.Tasks.Task.NotifyParentIfPotentiallyAttachedTask()\r\n   at System.Threading.Tasks.Task.FinishStageThree()\r\n   at System.Threading.Tasks.Task.FinishStageTwo()\r\n   at System.Threading.Tasks.Task.FinishSlow(Boolean userDelegateExecute)\r\n   at System.Threading.Tasks.Task.ExecuteWithThreadLocal(Task\u0026amp; currentTaskSlot, Thread threadPoolThread)\r\n   at System.Threading.Tasks.Task.ExecuteEntryUnsafe(Thread threadPoolThread)\r\n   at System.Threading.ThreadPoolWorkQueue.Dispatch()\r\n   at System.Threading.PortableThreadPool.WorkerThread.WorkerThreadStart()\r\n   at System.Threading.Thread.StartCallback()\r\n\u003c/Data\u003e\r\n  \u003c/EventData\u003e\r\n\u003c/Event\u003e\r\n```\r\n\r\n### Regression?\r\n\r\nWe didn\u0027t have this issue with the same application in .NET Framework 4.7.1.\r\n\r\n### Known Workarounds\r\n\r\n_No response_\r\n\r\n### Configuration\r\n\r\n```\r\n.NET version:       replicates with 6.0.5, 6.0.14, and 6.0.15\r\nOperating system:   \"Microsoft Windows NT 10.0.17763.0\" and \"Microsoft Windows NT 10.0.22621.0\"\r\nProcess:            64 bit\r\nOperating System:   64 bit\r\nCPU:                \"Intel(R) Xeon(R) Platinum 8375C CPU @ 2.90GHz\" and \"12th Gen Intel(R) Core(TM) i7-12800H Cores: 20\"\r\nCores:              32 and 20 \r\nMemory:             256 GB and 64 GB\r\n```\r\n\r\n### Other information\r\n\r\nFor me it seems that this is most probably thrown from this line in System.Threading.Tasks.Task.RunContinuations:\r\n\r\n`List\u003cobject?\u003e` continuations = (List\u003cobject?\u003e)continuationObject;\r\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOtzfL3g==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5XwJC_",
                                           "createdAt":  "2023-03-16T15:50:48Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Description\n\nI have a Web API application hosted in IIS that sorts rows of an array (actually a two-dimensional array/table of objects: object[][]) using expressions similar to this:\r\n\r\n`rows.AsParallel().AsOrdered().WithCancellation(cts.Token).OrderBy(...).ThenBy(...).ToList()` \r\n\r\nThe application has built-in support for canceling any running sorting operation at any point. This cancellation performs cancellation for the thread that is sorting the array using a call to Thread.Interrupt-function as well as calling CancellationTokenSource.Cancel for the CancellationTokenSource (cts). I want to use both methods as I can\u0027t pass the cancellation token into all the places these cancellable operations could call (Including, e.g., third-party components).\r\n\r\nWe have been getting intermittent unhandled System.InvalidCastException exceptions from System.Threading.Tasks.Task.RunContinuations crashing the whole application in situations that have the following issues in common:\r\n\r\n1. PLINQ sorting operation is being run.\r\n2. The sorting operation has been interrupted with the ThreadInterruptException.\r\n3. An unhandled exception was thrown from System.Threading.Tasks.Task.RunContinuations.\r\nThis exception has the following details:\r\n\r\n```\r\nSystem.InvalidCastException: Unable to cast object of type \u0027System.Object\u0027 to type \u0027System.Collections.Generic.List`1[System.Object]\u0027.\r\n   at System.Threading.Tasks.Task.RunContinuations(Object continuationObject)\r\n   at System.Threading.Tasks.Task.ProcessChildCompletion(Task childTask)\r\n   at System.Threading.Tasks.Task.FinishStageTwo()\r\n   at System.Threading.Tasks.Task.FinishSlow(Boolean userDelegateExecute)\r\n   at System.Threading.Tasks.Task.ExecuteWithThreadLocal(Task\u0026 currentTaskSlot, Thread threadPoolThread)\r\n   at System.Threading.ThreadPoolWorkQueue.Dispatch()\r\n   at System.Threading.PortableThreadPool.WorkerThread.WorkerThreadStart() \r\n```\r\n\r\nIn some cases, if the worker thread is using the thread that initiated the PLINQ operation, this stack trace looks different and in that case, this exception could be caught, but this situation seems quite rare as usually parallel tasks are being processed by other threads than the PLINQ caller. Thus, there is no way to catch the exception that occurred in System.Threading.Tasks.Task.RunContinuations, the application terminates.\r\n\r\nTo me, this seems like a problem in the .NET 6 runtime as I don\u0027t see how I can directly affect the continuationObjects being passed to System.Threading.Tasks.Task.RunContinuations.\r\n\r\nCan you confirm whether this is an issue in .NET 6 runtime or is there some way for me to adjust my application so that this does not occur anymore?\r\n\r\nNote also that in the reproducion step-function shown below, the stack trace is slightly different, but the situation is still as fatal as in this production environment case:\r\n```\r\nApplication: testhost.exe\r\nCoreCLR Version: 6.0.1523.11507\r\n.NET Version: 6.0.15\r\nDescription: The process was terminated due to an unhandled exception.\r\nException Info: System.InvalidCastException: Unable to cast object of type \u0027System.Object\u0027 to type \u0027System.Collections.Generic.List`1[System.Object]\u0027.\r\n   at System.Threading.Tasks.Task.RunContinuations(Object continuationObject)\r\n   at System.Threading.Tasks.Task.FinishContinuations()\r\n   at System.Threading.Tasks.Task.FinishStageThree()\r\n   at System.Threading.Tasks.Task.FinishStageTwo()\r\n   at System.Threading.Tasks.Task.ProcessChildCompletion(Task childTask)\r\n   at System.Threading.Tasks.Task.NotifyParentIfPotentiallyAttachedTask()\r\n   at System.Threading.Tasks.Task.FinishStageThree()\r\n   at System.Threading.Tasks.Task.FinishStageTwo()\r\n   at System.Threading.Tasks.Task.FinishSlow(Boolean userDelegateExecute)\r\n   at System.Threading.Tasks.Task.ExecuteWithThreadLocal(Task\u0026 currentTaskSlot, Thread threadPoolThread)\r\n   at System.Threading.Tasks.Task.ExecuteEntryUnsafe(Thread threadPoolThread)\r\n   at System.Threading.ThreadPoolWorkQueue.Dispatch()\r\n   at System.Threading.PortableThreadPool.WorkerThread.WorkerThreadStart()\r\n   at System.Threading.Thread.StartCallback()\r\n```\r\n\n\n### Reproduction Steps\n\nI\u0027m not sure if this is minimal, nor whether it replicates in all the environments, but at least in my test environment using .NET 6.0.15 (CoreCLR 6.0.1523.11507) I can replicate this issue reliably by running the code in the following C# function:\r\n```\r\n\t\tpublic void CrashTest()\r\n\t\t{\r\n\t\t\tvar rnd = new Random();\r\n\t\t\tvar rows = Enumerable.Range(1, 1000000)\r\n\t\t\t\t.Select(x =\u003e new object[] { $\"T{rnd.Next()}\" })\r\n\t\t\t\t.ToArray();\r\n\t\t\tvar cts = new CancellationTokenSource();\r\n\r\n\t\t\tfor (var i = 0; i \u003c 10000; ++i)\r\n\t\t\t{\r\n\t\t\t\tvar thread1 = new Thread(() =\u003e\r\n\t\t\t\t{\r\n\t\t\t\t\ttry\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\twhile (true)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tvar _ = rows\r\n\t\t\t\t\t\t\t\t.AsParallel()\r\n\t\t\t\t\t\t\t\t.AsOrdered()\r\n\t\t\t\t\t\t\t\t.WithCancellation(cts.Token)\r\n\t\t\t\t\t\t\t\t.OrderBy(row =\u003e row[0])\r\n\t\t\t\t\t\t\t\t.ToList();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcatch (ThreadInterruptedException)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\r\n\t\t\t\tthread1.Start();\r\n\t\t\t\tThread.Sleep(rnd.Next(100));\r\n\t\t\t\tthread1.Interrupt();\r\n\t\t\t\tcts.Cancel();\r\n\t\t\t\tthread1.Join();\r\n\t\t\t}\r\n\t\t}\r\n\r\n```\n\n### Expected behavior\n\nApplication does not crash. \r\nPLINQ operation is cancelled without threads being killed.\n\n### Actual behavior\n\nAn unhandled InvlidCastException is thrown from System.Threading.Tasks.Task.RunContinuations crashing the whole application.\r\n\r\nException generated into windows event log:\r\nLog Name:      Application\r\nSource:        .NET Runtime\r\nDate:          16/03/2023 17.27.19\r\nEvent ID:      1026\r\nTask Category: None\r\nLevel:         Error\r\nKeywords:      Classic\r\nUser:          N/A\r\nDescription:\r\nApplication: testhost.exe\r\nCoreCLR Version: 6.0.1523.11507\r\n.NET Version: 6.0.15\r\nDescription: The process was terminated due to an unhandled exception.\r\nException Info: System.InvalidCastException: Unable to cast object of type \u0027System.Object\u0027 to type \u0027System.Collections.Generic.List`1[System.Object]\u0027.\r\n   at System.Threading.Tasks.Task.RunContinuations(Object continuationObject)\r\n   at System.Threading.Tasks.Task.FinishContinuations()\r\n   at System.Threading.Tasks.Task.FinishStageThree()\r\n   at System.Threading.Tasks.Task.FinishStageTwo()\r\n   at System.Threading.Tasks.Task.ProcessChildCompletion(Task childTask)\r\n   at System.Threading.Tasks.Task.NotifyParentIfPotentiallyAttachedTask()\r\n   at System.Threading.Tasks.Task.FinishStageThree()\r\n   at System.Threading.Tasks.Task.FinishStageTwo()\r\n   at System.Threading.Tasks.Task.FinishSlow(Boolean userDelegateExecute)\r\n   at System.Threading.Tasks.Task.ExecuteWithThreadLocal(Task\u0026 currentTaskSlot, Thread threadPoolThread)\r\n   at System.Threading.Tasks.Task.ExecuteEntryUnsafe(Thread threadPoolThread)\r\n   at System.Threading.ThreadPoolWorkQueue.Dispatch()\r\n   at System.Threading.PortableThreadPool.WorkerThread.WorkerThreadStart()\r\n   at System.Threading.Thread.StartCallback()\r\n\r\nEvent Xml:\r\n\u003cEvent xmlns=\"http://schemas.microsoft.com/win/2004/08/events/event\"\u003e\r\n  \u003cSystem\u003e\r\n    \u003cProvider Name=\".NET Runtime\" /\u003e\r\n    \u003cEventID Qualifiers=\"0\"\u003e1026\u003c/EventID\u003e\r\n    \u003cVersion\u003e0\u003c/Version\u003e\r\n    \u003cLevel\u003e2\u003c/Level\u003e\r\n    \u003cTask\u003e0\u003c/Task\u003e\r\n    \u003cOpcode\u003e0\u003c/Opcode\u003e\r\n    \u003cKeywords\u003e0x80000000000000\u003c/Keywords\u003e\r\n    \u003cTimeCreated SystemTime=\"2023-03-16T15:27:19.4485051Z\" /\u003e\r\n    \u003cEventRecordID\u003e160159\u003c/EventRecordID\u003e\r\n    \u003cCorrelation /\u003e\r\n    \u003cExecution ProcessID=\"12224\" ThreadID=\"0\" /\u003e\r\n    \u003cChannel\u003eApplication\u003c/Channel\u003e\r\n    \u003cComputer\u003eQPR-NB474\u003c/Computer\u003e\r\n    \u003cSecurity /\u003e\r\n  \u003c/System\u003e\r\n  \u003cEventData\u003e\r\n    \u003cData\u003eApplication: testhost.exe\r\nCoreCLR Version: 6.0.1523.11507\r\n.NET Version: 6.0.15\r\nDescription: The process was terminated due to an unhandled exception.\r\nException Info: System.InvalidCastException: Unable to cast object of type \u0027System.Object\u0027 to type \u0027System.Collections.Generic.List`1[System.Object]\u0027.\r\n   at System.Threading.Tasks.Task.RunContinuations(Object continuationObject)\r\n   at System.Threading.Tasks.Task.FinishContinuations()\r\n   at System.Threading.Tasks.Task.FinishStageThree()\r\n   at System.Threading.Tasks.Task.FinishStageTwo()\r\n   at System.Threading.Tasks.Task.ProcessChildCompletion(Task childTask)\r\n   at System.Threading.Tasks.Task.NotifyParentIfPotentiallyAttachedTask()\r\n   at System.Threading.Tasks.Task.FinishStageThree()\r\n   at System.Threading.Tasks.Task.FinishStageTwo()\r\n   at System.Threading.Tasks.Task.FinishSlow(Boolean userDelegateExecute)\r\n   at System.Threading.Tasks.Task.ExecuteWithThreadLocal(Task\u0026amp; currentTaskSlot, Thread threadPoolThread)\r\n   at System.Threading.Tasks.Task.ExecuteEntryUnsafe(Thread threadPoolThread)\r\n   at System.Threading.ThreadPoolWorkQueue.Dispatch()\r\n   at System.Threading.PortableThreadPool.WorkerThread.WorkerThreadStart()\r\n   at System.Threading.Thread.StartCallback()\r\n\u003c/Data\u003e\r\n  \u003c/EventData\u003e\r\n\u003c/Event\u003e\n\n### Regression?\n\nWe didn\u0027t have this issue with the same application in .NET Framework 4.7.1.\n\n### Known Workarounds\n\n_No response_\n\n### Configuration\n\n```\r\n.NET version:       replicates with 6.0.5, 6.0.14, and 6.0.15\r\nOperating system:   \"Microsoft Windows NT 10.0.17763.0\" and \"Microsoft Windows NT 10.0.22621.0\"\r\nProcess:            64 bit\r\nOperating System:   64 bit\r\nCPU:                \"Intel(R) Xeon(R) Platinum 8375C CPU @ 2.90GHz\" and \"12th Gen Intel(R) Core(TM) i7-12800H Cores: 20\"\r\nCores:              32 and 20 \r\nMemory:             256 GB and 64 GB\r\n```\n\n### Other information\n\nFor me it seems that this is most probably thrown from this line in System.Threading.Tasks.Task.RunContinuations:\r\n\r\n`List\u003cobject?\u003e` continuations = (List\u003cobject?\u003e)continuationObject;\r\n\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003emhinkka\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Threading`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-03-16T15:50:48Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5X2Bcg",
                                           "createdAt":  "2023-03-17T12:46:52Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "Note that the _vast_ majority of code, including in the core libraries, is not hardened against use of thread interrupts.  These can cause exceptions to emerge from practically any place the thread is in a wait/sleep/join state, which means almost any blocking operation, time acquiring a lock, etc, and most code is not written to accomodate such asynchronous exceptions.",
                                           "updatedAt":  "2023-03-17T12:46:52Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5X2bjO",
                                           "createdAt":  "2023-03-17T13:58:44Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOC4E73w==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "theodorzoulias",
                                                                               "createdAt":  "2023-03-17T22:34:20Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "mhinkka",
                                           "body":  "We originally used Thread.Abort in .NET Framework 4.7.1 but as this was documented to not be a good practice, and as it is no longer supported by .NET 5, we switched to use the often recommended replacement of Thread.Interrupt. Also, we didn\u0027t find any clear indication in the .NET documentation that you should avoid using thread interrupts too.\r\n\r\nPerhaps some kind of a warning about this issue should then be added to the documentation, e.g., [here](https://learn.microsoft.com/en-us/dotnet/api/system.threading.thread.interrupt) or [here](https://learn.microsoft.com/en-us/dotnet/standard/threading/pausing-and-resuming-threads)?\r\n\r\nAlso, some kind of workaround proposals in situations where you can\u0027t pass cancellation tokens to the code that is blocking in wait/sleep/join state (e.g., code in a third-party component) would be very useful.",
                                           "updatedAt":  "2023-03-17T13:58:44Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5X2vwc",
                                           "createdAt":  "2023-03-17T14:56:16Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Clockwork-Muse",
                                           "body":  "\u003eAlso, some kind of workaround proposals in situations where you can\u0027t pass cancellation tokens to the code that is blocking in wait/sleep/join state (e.g., code in a third-party component) would be very useful.\r\n\r\nStart it as a separate process, kill the process.  Or yell at those third parties to properly support cancellation.\r\n\r\nThat said....\r\n\r\n\u003e I have a Web API application\r\n\r\nWeb frameworks usually want to be in control of all the threads that are started (for a variety of reasons), so this feels like a code smell.  Additionally, assuming your web api has any reasonable amount of concurrent requests, the only thing PLINQ is doing is adding overhead to everybody\u0027s requests, and making things slower than if you\u0027d done it with regular LINQ.  ",
                                           "updatedAt":  "2023-03-17T14:56:16Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5YM5uh",
                                           "createdAt":  "2023-03-22T15:26:24Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-threading-tasks\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Description\r\n\r\nI have a Web API application hosted in IIS that sorts rows of an array (actually a two-dimensional array/table of objects: object[][]) using expressions similar to this:\r\n\r\n`rows.AsParallel().AsOrdered().WithCancellation(cts.Token).OrderBy(...).ThenBy(...).ToList()` \r\n\r\nThe application has built-in support for canceling any running sorting operation at any point. This cancellation performs cancellation for the thread that is sorting the array using a call to Thread.Interrupt-function as well as calling CancellationTokenSource.Cancel for the CancellationTokenSource (cts). I want to use both methods as I can\u0027t pass the cancellation token into all the places these cancellable operations could call (Including, e.g., third-party components).\r\n\r\nWe have been getting intermittent unhandled System.InvalidCastException exceptions from System.Threading.Tasks.Task.RunContinuations crashing the whole application in situations that have the following issues in common:\r\n\r\n1. PLINQ sorting operation is being run.\r\n2. The sorting operation has been interrupted with the ThreadInterruptException.\r\n3. An unhandled exception was thrown from System.Threading.Tasks.Task.RunContinuations.\r\nThis exception has the following details:\r\n\r\n```\r\nSystem.InvalidCastException: Unable to cast object of type \u0027System.Object\u0027 to type \u0027System.Collections.Generic.List`1[System.Object]\u0027.\r\n   at System.Threading.Tasks.Task.RunContinuations(Object continuationObject)\r\n   at System.Threading.Tasks.Task.ProcessChildCompletion(Task childTask)\r\n   at System.Threading.Tasks.Task.FinishStageTwo()\r\n   at System.Threading.Tasks.Task.FinishSlow(Boolean userDelegateExecute)\r\n   at System.Threading.Tasks.Task.ExecuteWithThreadLocal(Task\u0026 currentTaskSlot, Thread threadPoolThread)\r\n   at System.Threading.ThreadPoolWorkQueue.Dispatch()\r\n   at System.Threading.PortableThreadPool.WorkerThread.WorkerThreadStart() \r\n```\r\n\r\nIn some cases, if the worker thread is using the thread that initiated the PLINQ operation, this stack trace looks different and in that case, this exception could be caught, but this situation seems quite rare as usually parallel tasks are being processed by other threads than the PLINQ caller. Thus, there is no way to catch the exception that occurred in System.Threading.Tasks.Task.RunContinuations, the application terminates.\r\n\r\nTo me, this seems like a problem in the .NET 6 runtime as I don\u0027t see how I can directly affect the continuationObjects being passed to System.Threading.Tasks.Task.RunContinuations.\r\n\r\nCan you confirm whether this is an issue in .NET 6 runtime and/or is there some way for me to adjust my application so that this does not occur anymore?\r\n\r\nNote also that in the reproducion step-function shown below, the stack trace is slightly different, but the situation is still as fatal as in this production environment case:\r\n```\r\nApplication: testhost.exe\r\nCoreCLR Version: 6.0.1523.11507\r\n.NET Version: 6.0.15\r\nDescription: The process was terminated due to an unhandled exception.\r\nException Info: System.InvalidCastException: Unable to cast object of type \u0027System.Object\u0027 to type \u0027System.Collections.Generic.List`1[System.Object]\u0027.\r\n   at System.Threading.Tasks.Task.RunContinuations(Object continuationObject)\r\n   at System.Threading.Tasks.Task.FinishContinuations()\r\n   at System.Threading.Tasks.Task.FinishStageThree()\r\n   at System.Threading.Tasks.Task.FinishStageTwo()\r\n   at System.Threading.Tasks.Task.ProcessChildCompletion(Task childTask)\r\n   at System.Threading.Tasks.Task.NotifyParentIfPotentiallyAttachedTask()\r\n   at System.Threading.Tasks.Task.FinishStageThree()\r\n   at System.Threading.Tasks.Task.FinishStageTwo()\r\n   at System.Threading.Tasks.Task.FinishSlow(Boolean userDelegateExecute)\r\n   at System.Threading.Tasks.Task.ExecuteWithThreadLocal(Task\u0026 currentTaskSlot, Thread threadPoolThread)\r\n   at System.Threading.Tasks.Task.ExecuteEntryUnsafe(Thread threadPoolThread)\r\n   at System.Threading.ThreadPoolWorkQueue.Dispatch()\r\n   at System.Threading.PortableThreadPool.WorkerThread.WorkerThreadStart()\r\n   at System.Threading.Thread.StartCallback()\r\n```\r\n\r\n\r\n### Reproduction Steps\r\n\r\nI\u0027m not sure if this is minimal, nor whether it replicates in all the environments, but at least in my test environment using .NET 6.0.15 (CoreCLR 6.0.1523.11507) I can replicate this issue reliably by running the code in the following C# function:\r\n```\r\n\t\tpublic void CrashTest()\r\n\t\t{\r\n\t\t\tvar rnd = new Random();\r\n\t\t\tvar rows = Enumerable.Range(1, 1000000)\r\n\t\t\t\t.Select(x =\u003e new object[] { $\"T{rnd.Next()}\" })\r\n\t\t\t\t.ToArray();\r\n\t\t\tvar cts = new CancellationTokenSource();\r\n\r\n\t\t\tfor (var i = 0; i \u003c 10000; ++i)\r\n\t\t\t{\r\n\t\t\t\tvar thread1 = new Thread(() =\u003e\r\n\t\t\t\t{\r\n\t\t\t\t\ttry\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\twhile (true)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tvar _ = rows\r\n\t\t\t\t\t\t\t\t.AsParallel()\r\n\t\t\t\t\t\t\t\t.AsOrdered()\r\n\t\t\t\t\t\t\t\t.WithCancellation(cts.Token)\r\n\t\t\t\t\t\t\t\t.OrderBy(row =\u003e row[0])\r\n\t\t\t\t\t\t\t\t.ToList();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcatch (ThreadInterruptedException)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\r\n\t\t\t\tthread1.Start();\r\n\t\t\t\tThread.Sleep(rnd.Next(100));\r\n\t\t\t\tthread1.Interrupt();\r\n\t\t\t\tcts.Cancel();\r\n\t\t\t\tthread1.Join();\r\n\t\t\t}\r\n\t\t}\r\n\r\n```\r\n\r\n### Expected behavior\r\n\r\nApplication does not crash. \r\nPLINQ operation is cancelled without threads being killed.\r\n\r\n### Actual behavior\r\n\r\nAn unhandled InvlidCastException is thrown from System.Threading.Tasks.Task.RunContinuations crashing the whole application.\r\n\r\n```\r\nException generated into windows event log:\r\nLog Name:      Application\r\nSource:        .NET Runtime\r\nDate:          16/03/2023 17.27.19\r\nEvent ID:      1026\r\nTask Category: None\r\nLevel:         Error\r\nKeywords:      Classic\r\nUser:          N/A\r\nDescription:\r\nApplication: testhost.exe\r\nCoreCLR Version: 6.0.1523.11507\r\n.NET Version: 6.0.15\r\nDescription: The process was terminated due to an unhandled exception.\r\nException Info: System.InvalidCastException: Unable to cast object of type \u0027System.Object\u0027 to type \u0027System.Collections.Generic.List`1[System.Object]\u0027.\r\n   at System.Threading.Tasks.Task.RunContinuations(Object continuationObject)\r\n   at System.Threading.Tasks.Task.FinishContinuations()\r\n   at System.Threading.Tasks.Task.FinishStageThree()\r\n   at System.Threading.Tasks.Task.FinishStageTwo()\r\n   at System.Threading.Tasks.Task.ProcessChildCompletion(Task childTask)\r\n   at System.Threading.Tasks.Task.NotifyParentIfPotentiallyAttachedTask()\r\n   at System.Threading.Tasks.Task.FinishStageThree()\r\n   at System.Threading.Tasks.Task.FinishStageTwo()\r\n   at System.Threading.Tasks.Task.FinishSlow(Boolean userDelegateExecute)\r\n   at System.Threading.Tasks.Task.ExecuteWithThreadLocal(Task\u0026 currentTaskSlot, Thread threadPoolThread)\r\n   at System.Threading.Tasks.Task.ExecuteEntryUnsafe(Thread threadPoolThread)\r\n   at System.Threading.ThreadPoolWorkQueue.Dispatch()\r\n   at System.Threading.PortableThreadPool.WorkerThread.WorkerThreadStart()\r\n   at System.Threading.Thread.StartCallback()\r\n\r\nEvent Xml:\r\n\u003cEvent xmlns=\"http://schemas.microsoft.com/win/2004/08/events/event\"\u003e\r\n  \u003cSystem\u003e\r\n    \u003cProvider Name=\".NET Runtime\" /\u003e\r\n    \u003cEventID Qualifiers=\"0\"\u003e1026\u003c/EventID\u003e\r\n    \u003cVersion\u003e0\u003c/Version\u003e\r\n    \u003cLevel\u003e2\u003c/Level\u003e\r\n    \u003cTask\u003e0\u003c/Task\u003e\r\n    \u003cOpcode\u003e0\u003c/Opcode\u003e\r\n    \u003cKeywords\u003e0x80000000000000\u003c/Keywords\u003e\r\n    \u003cTimeCreated SystemTime=\"2023-03-16T15:27:19.4485051Z\" /\u003e\r\n    \u003cEventRecordID\u003e160159\u003c/EventRecordID\u003e\r\n    \u003cCorrelation /\u003e\r\n    \u003cExecution ProcessID=\"12224\" ThreadID=\"0\" /\u003e\r\n    \u003cChannel\u003eApplication\u003c/Channel\u003e\r\n    \u003cComputer\u003eNB474\u003c/Computer\u003e\r\n    \u003cSecurity /\u003e\r\n  \u003c/System\u003e\r\n  \u003cEventData\u003e\r\n    \u003cData\u003eApplication: testhost.exe\r\nCoreCLR Version: 6.0.1523.11507\r\n.NET Version: 6.0.15\r\nDescription: The process was terminated due to an unhandled exception.\r\nException Info: System.InvalidCastException: Unable to cast object of type \u0027System.Object\u0027 to type \u0027System.Collections.Generic.List`1[System.Object]\u0027.\r\n   at System.Threading.Tasks.Task.RunContinuations(Object continuationObject)\r\n   at System.Threading.Tasks.Task.FinishContinuations()\r\n   at System.Threading.Tasks.Task.FinishStageThree()\r\n   at System.Threading.Tasks.Task.FinishStageTwo()\r\n   at System.Threading.Tasks.Task.ProcessChildCompletion(Task childTask)\r\n   at System.Threading.Tasks.Task.NotifyParentIfPotentiallyAttachedTask()\r\n   at System.Threading.Tasks.Task.FinishStageThree()\r\n   at System.Threading.Tasks.Task.FinishStageTwo()\r\n   at System.Threading.Tasks.Task.FinishSlow(Boolean userDelegateExecute)\r\n   at System.Threading.Tasks.Task.ExecuteWithThreadLocal(Task\u0026amp; currentTaskSlot, Thread threadPoolThread)\r\n   at System.Threading.Tasks.Task.ExecuteEntryUnsafe(Thread threadPoolThread)\r\n   at System.Threading.ThreadPoolWorkQueue.Dispatch()\r\n   at System.Threading.PortableThreadPool.WorkerThread.WorkerThreadStart()\r\n   at System.Threading.Thread.StartCallback()\r\n\u003c/Data\u003e\r\n  \u003c/EventData\u003e\r\n\u003c/Event\u003e\r\n```\r\n\r\n### Regression?\r\n\r\nWe didn\u0027t have this issue with the same application in .NET Framework 4.7.1.\r\n\r\n### Known Workarounds\r\n\r\n_No response_\r\n\r\n### Configuration\r\n\r\n```\r\n.NET version:       replicates with 6.0.5, 6.0.14, and 6.0.15\r\nOperating system:   \"Microsoft Windows NT 10.0.17763.0\" and \"Microsoft Windows NT 10.0.22621.0\"\r\nProcess:            64 bit\r\nOperating System:   64 bit\r\nCPU:                \"Intel(R) Xeon(R) Platinum 8375C CPU @ 2.90GHz\" and \"12th Gen Intel(R) Core(TM) i7-12800H Cores: 20\"\r\nCores:              32 and 20 \r\nMemory:             256 GB and 64 GB\r\n```\r\n\r\n### Other information\r\n\r\nFor me it seems that this is most probably thrown from this line in System.Threading.Tasks.Task.RunContinuations:\r\n\r\n`List\u003cobject?\u003e` continuations = (List\u003cobject?\u003e)continuationObject;\r\n\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003emhinkka\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Threading.Tasks`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-03-22T15:26:24Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5YOfA8",
                                           "createdAt":  "2023-03-22T20:03:49Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "theodorzoulias",
                                           "body":  "\u003e Also, some kind of workaround proposals in situations where you can\u0027t pass cancellation tokens to the code that is blocking in wait/sleep/join state (e.g., code in a third-party component) would be very useful.\r\n\r\n.NET 7 introduced the [`ControlledExecution.Run`](https://learn.microsoft.com/en-us/dotnet/api/system.runtime.controlledexecution.run) API, that can be used to abort an `Action` using a `CancellationToken`. This method uses [internally](https://github.com/dotnet/runtime/blob/3286b32e11dcd5b55994a193c6d0716c581724e3/src/coreclr/System.Private.CoreLib/src/System/Runtime/ControlledExecution.CoreCLR.cs#L43) the `Thread.Abort` mechanism to stop the action, and then resets the abort so that the thread doesn\u0027t actually die. It\u0027s a dangerous API, and Microsoft does not recommend using it in production code. You can find [here](https://stackoverflow.com/questions/75087774/thread-or-task-stopping-a-hung-single-line-of-code/75090418#75090418 \"Thread or Task (stopping a hung single line of code)\") a variant of this API that uses the `Thread.Interrupt` instead of the `Thread.Abort` (the `RunInterruptible` method).",
                                           "updatedAt":  "2023-03-22T20:03:49Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5YPGJA",
                                           "createdAt":  "2023-03-22T22:45:31Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Clockwork-Muse",
                                           "body":  "@theodorzoulias - as mentioned earlier, a version that uses `Thread.Interrupt()` is going to run into many of the same problems as the one that uses `Thread.Abort()`, so both of those are still dangerous.",
                                           "updatedAt":  "2023-03-22T22:45:31Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5YTUtt",
                                           "createdAt":  "2023-03-23T16:02:22Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "As mentioned above, this is effectively \"by design\" and the user-code should be updated to not use/rely on Thread.Interrupt.\r\n\r\nWe\u0027re going to leave the issue open for the time being so that we can look a bit deeper into \"why\" this particular behavior is surfacing the way it is.\r\n\r\nCC. @stephentoub ",
                                           "updatedAt":  "2023-03-23T16:02:22Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6lyCgg",
                                           "createdAt":  "2025-04-06T10:45:12Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "sleushunou",
                                           "body":  "I faced with similar issue, bot I don\u0027t use PLINQ / Thread.Interrupt / Thread.Abort\n\n\nhttps://github.com/dotnet/runtime/issues/114262",
                                           "updatedAt":  "2025-04-06T12:10:37Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6sDaEM",
                                           "createdAt":  "2025-05-16T12:24:03Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jjacksoncapula",
                                           "body":  "We experienced a similar issue. Running on dotnet 9.0.1 on Windows. Stack trace as follows:\n\n```\n2025-05-15 14:44:07,672 [347] FATAL ServiceHost\u003cPosition\u003e - Fatal unhandled exception! Service will be terminated\nSystem.InvalidCastException: Unable to cast object of type \u0027System.Object\u0027 to type \u0027System.Collections.Generic.List`1[System.Object]\u0027.\n   at System.Threading.Tasks.Task.RunContinuations(Object continuationObject)\n   at System.Threading.Tasks.Task.FinishSlow(Boolean userDelegateExecute)\n   at System.Threading.Tasks.Task.ExecuteWithThreadLocal(Task\u0026 currentTaskSlot, Thread threadPoolThread)\n   at System.Threading.ThreadPoolWorkQueue.Dispatch()\n   at System.Threading.PortableThreadPool.WorkerThread.WorkerThreadStart()\n```\n\nI previously commented on [https://github.com/dotnet/runtime/issues/114262](url) but was informed by @lateralusX that this is more at home here.\n\nGiven lateralusX\u0027s comment:\n\n_That is the line that gets hit if you end up in a scenario where continuations have already been executed on the task and replaced it with s_taskCompletionSentinel object (so it not a list anymore)_\n\nOur theory is that because our code is -in essence- doing:\nwhile (true)\n{\nawait DoSomething();\nawait DoStuffAsync();\n}\nasync Task DoStuffAsync()\n{\nif (false)\nawait DoMoreStuffAsync();\n}\n\nThe \"await DoStuffAsync();\" is in effect awaiting on a NOP which is very very fast and maybe even removed completely by the compiler and/or the JIT. We speculate that this is fast enough to trigger a race condition so the continuation is finished and we do hit the issue as described.\n\nSo - in our own code - we have replaced \"await NOP\" with \"await Task.Completed\" which we hope will help, but we don\u0027t have a way to prove it. ",
                                           "updatedAt":  "2025-05-16T12:26:30Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6sDwsP",
                                           "createdAt":  "2025-05-16T13:03:57Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "Are you using Thread.Interrupt?",
                                           "updatedAt":  "2025-05-16T13:03:57Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6sDx0g",
                                           "createdAt":  "2025-05-16T13:05:44Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jjacksoncapula",
                                           "body":  "No - we do not use that anywhere",
                                           "updatedAt":  "2025-05-16T13:05:44Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6sDyzG",
                                           "createdAt":  "2025-05-16T13:07:21Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "Can you share a repro?",
                                           "updatedAt":  "2025-05-16T13:07:21Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6sD0SX",
                                           "createdAt":  "2025-05-16T13:09:47Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jjacksoncapula",
                                           "body":  "We can\u0027t reproduce - we just saw the error on our production server (after the app died due to unhandled exception). Unfortunately all we have to go off is the logs posted above. ",
                                           "updatedAt":  "2025-05-16T13:09:47Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc63MYYt",
                                           "createdAt":  "2025-07-15T12:50:18Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jjacksoncapula",
                                           "body":  "We experienced the same issue again today. This time I can see it was during a 4s garbage collection. Mentioning in case the provides any further useful context. \n\n```\n2025-07-15 13:06:05,648 [41] FATAL ServiceHost\u003cPosition\u003e - Fatal unhandled exception! Service will be terminated\nSystem.InvalidCastException: Unable to cast object of type \u0027System.Object\u0027 to type \u0027System.Collections.Generic.List`1[System.Object]\u0027.\n   at System.Threading.Tasks.Task.RunContinuations(Object continuationObject)\n   at System.Threading.Tasks.Task.FinishSlow(Boolean userDelegateExecute)\n   at System.Threading.Tasks.Task.ExecuteWithThreadLocal(Task\u0026 currentTaskSlot, Thread threadPoolThread)\n   at System.Threading.ThreadPoolWorkQueue.Dispatch()\n   at System.Threading.PortableThreadPool.WorkerThread.WorkerThreadStart()\n2025-07-15 13:06:09,709 [GC Notifications] INFO  Alvitas.Common.Util.GcManagement - FullGCComplete: Succeeded\n2025-07-15 13:06:09,710 [GC Notifications] INFO  Alvitas.Common.Util.GcManagement - Index: 5193, Pauses: 00:00:04.0602930,00:00:00, Compacted: True, Generation: 2, Total memory available: 96635740160\n```\n",
                                           "updatedAt":  "2025-07-15T12:50:18Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc63N8ve",
                                           "createdAt":  "2025-07-15T14:36:27Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "I think this is the same as https://github.com/dotnet/runtime/issues/114262 which was repro\u0027ing on iOS.\n\nA small fix was applied via https://github.com/dotnet/runtime/pull/115659 and recently backported\n\nCC. @stephentoub",
                                           "updatedAt":  "2025-07-15T14:36:27Z"
                                       }
                                   ],
                         "totalCount":  16
                     },
        "title":  "PLINQ query crashes a .NET Core 6 application due to unhandled InvalidCastException thrown from System.Threading.Tasks.Task.RunContinuations.",
        "labels":  [
                       "area-System.Threading.Tasks"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/89667",
        "createdAt":  "2023-07-29T11:39:54Z",
        "number":  89667,
        "author":  "sakno",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2024-07-19T16:21:09Z",
        "body":  "### Background and motivation\r\n\r\n`Task\u003cT\u003e` can be converted to untyped `Task` naturally because typed task derives from untyped one. However, it cannot be done for `ValueTask\u003cT\u003e`. When I implementing some async API, I would like to reuse my internal implementation of `IValueTaskSource\u003cT\u003e` for API with untyped version of `ValueTask`. Instead, I have to implement `IValueTaskSource` and `IValueTaskSource\u003cT\u003e` both.\r\n\r\nMoreover, `ValueTask` type has internal `ValueTask DangerousCreateFromTypedValueTask\u003cTResult\u003e(ValueTask\u003cTResult\u003e valueTask)` method already for the same purposes.\r\n\r\n### API Proposal\r\n\r\nWe can have two options here:\r\n* Provide a method that implements conversion if possible\r\n* Provide a method that implements conversion in any case (through internal `IValueTaskSource\u003cT\u003e` to `IValueTaskSource` proxy). It may be a bad idea, anyway I would like to consider this approach as well.\r\n* Both variants\r\n\r\n```csharp\r\npublic struct ValueTask\u003cT\u003e\r\n{\r\n    public static explicit operator ValueTask(ValueTask\u003cT\u003e task); // may allocate to create a proxy\r\n    public bool TryGetUntypedTask(out ValueTask task); // never allocates\r\n}\r\n```\r\n\r\n`TryGetUntypedTask` should return **true** if underlying typed task is completed at the time of method invocation.\r\n\r\n### API Usage\r\n\r\n```csharp\r\npublic ValueTask ReadExactlyAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken = default)\r\n{\r\n    ValidateBufferArguments(buffer, offset, count);\r\n\r\n    ValueTask\u003cint\u003e vt = ReadAtLeastAsyncCore(buffer.AsMemory(offset, count), count, throwOnEndOfStream: true, cancellationToken);\r\n\r\n    return (ValueTask)vt;\r\n    // or\r\n    vt.TryGetUntypedTask(out ValueTask result);\r\n    return result;\r\n}\r\n```\r\n\r\n### Alternative Designs\r\n\r\nAdd static methods that are very similar to what we have already to work with `ReadOnlyMemory\u003cT\u003e` in `MemoryMarshal` class:\r\n```csharp\r\npublic struct ValueTask\r\n{\r\n    public static bool TryGetTask(ValueTask vt, [NotNullWhen(true)] out Task? task);\r\n    public static bool TryGetTaskSource(ValueTask vt, [NotNullWhen(true)] out IValueTaskSource? source);\r\n    public static bool TryGetTask\u003cT\u003e(ValueTask\u003cT\u003e vt, [NotNullWhen(true)] out Task\u003cT\u003e? task);\r\n    public static bool TryGetTaskSource\u003cT\u003e(ValueTask\u003cT\u003e vt, [NotNullWhen(true)] out IValueTaskSource\u003cT\u003e? source);\r\n}\r\n```\r\n\r\nWorkaround exists as well (but not efficient):\r\n```csharp\r\nValueTask\u003cT\u003e vt;\r\nValueTask uvt = new(vt.AsTask()); // allocates\r\n```\r\n\r\n### Risks\r\n\r\nI don\u0027t see any.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOYuE59g==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5iv2f8",
                                           "createdAt":  "2023-07-29T11:40:02Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-threading-tasks\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Background and motivation\n\n`Task\u003cT\u003e` can be converted to untyped `Task` naturally because typed task derives from untyped one. However, it cannot be done for `ValueTask\u003cT\u003e`. When I implementing some async API, I would like to reuse my internal implementation of `IValueTaskSource\u003cT\u003e` for API with untyped version of `ValueTask`. Instead, I have to implement `IValueTaskSource` and `IValueTaskSource\u003cT\u003e` both.\r\n\r\nMoreover, `ValueTask` type has internal `ValueTask DangerousCreateFromTypedValueTask\u003cTResult\u003e(ValueTask\u003cTResult\u003e valueTask)` method already for the same purposes.\n\n### API Proposal\n\nWe can have two options here:\r\n* Provide a method that implements conversion if possible\r\n* Provide a method that implements conversion in any case (through internal `IValueTaskSource\u003cT\u003e` to `IValueTaskSource` proxy). It may be a bad idea, anyway I would like to consider this approach as well.\r\n* Both variants\r\n\r\n```csharp\r\npublic struct ValueTask\u003cT\u003e\r\n{\r\n    public static explicit operator ValueTask(ValueTask\u003cT\u003e task); // may allocate to create a proxy\r\n    public static bool TryGetUntypedTask(out ValueTask task); // never allocates\r\n}\r\n```\r\n\r\n`TryGetUntypedTask` should return **true** if underlying typed task is completed at the time of method invocation.\n\n### API Usage\n\n```csharp\r\npublic ValueTask ReadExactlyAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken = default)\r\n{\r\n    ValidateBufferArguments(buffer, offset, count);\r\n\r\n    ValueTask\u003cint\u003e vt = ReadAtLeastAsyncCore(buffer.AsMemory(offset, count), count, throwOnEndOfStream: true, cancellationToken);\r\n\r\n    return (ValueTask)vt;\r\n    // or\r\n    vt.TryGetUntypedTask(out ValueTask result);\r\n    return result;\r\n}\r\n```\n\n### Alternative Designs\n\nAdd static methods that are very similar to what we have already to work with `ReadOnlyMemory\u003cT\u003e` in `MemoryMarshal` class:\r\n```csharp\r\npublic struct ValueTask\r\n{\r\n    public static bool TryGetTask(ValueTask vt, [NotNullWhen(true)] out Task? task);\r\n    public static bool TryGetTaskSource(ValueTask vt, [NotNullWhen(true)] out IValueTaskSource? source);\r\n    public static bool TryGetTask\u003cT\u003e(ValueTask\u003cT\u003e vt, [NotNullWhen(true)] out Task\u003cT\u003e? task);\r\n    public static bool TryGetTaskSource\u003cT\u003e(ValueTask\u003cT\u003e vt, [NotNullWhen(true)] out IValueTaskSource\u003cT\u003e? source);\r\n}\r\n```\n\n### Risks\n\nI don\u0027t see any.\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003esakno\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`api-suggestion`, `area-System.Threading.Tasks`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-07-29T11:40:02Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5iv5Vz",
                                           "createdAt":  "2023-07-29T12:46:56Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "hrrrrustic",
                                           "body":  "Similar to \r\nhttps://github.com/dotnet/runtime/issues/67212\r\nhttps://github.com/dotnet/runtime/issues/31503",
                                           "updatedAt":  "2023-07-29T12:47:22Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5iyGLQ",
                                           "createdAt":  "2023-07-30T23:57:13Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "teo-tsirpanis",
                                           "body":  "I would love to see just these two APIs. They would allow low-level interactions with ValueTask like the most efficient possible conversion to F#\u0027s `Async`:\r\n\r\n```csharp\r\nnamespace System.Runtime.InteropServices;\r\n\r\npublic static class ValueTaskMarshal\r\n{\r\n    public static bool TryGetValueTaskSource(ValueTask vt, [NotNullWhen(true)] out IValueTaskSource? source, out short token);\r\n    public static bool TryGetValueTaskSource\u003cT\u003e(ValueTask\u003cT\u003e vt, [NotNullWhen(true)] out IValueTaskSource\u003cT\u003e? source, out short token);\r\n}\r\n```\r\n\r\nHere\u0027s how they would be used:\r\n\r\n```csharp\r\nValueTask\u003cT\u003e vt = …;\r\n\r\nif (vt.IsCompleted)\r\n{\r\n    // Get result and handle case when already completed.\r\n}\r\n\r\nif (ValueTaskMarshal.TryGetValueTaskSource(vt, out var source, out short token)\r\n{\r\n    // Handle case when backed by IValueTaskSource.\r\n}\r\n\r\nTask\u003cT\u003e task = vt.AsTask();\r\n// Handle case when backed by Task or a potentially future unknown source.\r\n// This pattern makes TryGetTask unnecessary.\r\n```",
                                           "updatedAt":  "2023-07-30T23:57:33Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5i3x91",
                                           "createdAt":  "2023-07-31T17:07:25Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "sakno",
                                           "body":  "@teo-tsirpanis , what\u0027s the reason to place this API to `InteropServices` namespace?",
                                           "updatedAt":  "2023-07-31T17:07:25Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5i341V",
                                           "createdAt":  "2023-07-31T17:18:58Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "sakno",
                                           "body":  "Maybe it\u0027s better to place a new API to `System.Threading.Tasks.Sources`?\r\n```csharp\r\npublic interface IValueTaskSource\r\n{\r\n    public static bool TryGetValueTaskSource(ValueTask vt, [NotNullWhen(true)] out IValueTaskSource? source, out short token);\r\n}\r\n\r\npublic interface IValueTaskSource\u003cT\u003e\r\n{\r\n    public static bool TryGetValueTaskSource\u003cT\u003e(ValueTask\u003cT\u003e vt, [NotNullWhen(true)] out IValueTaskSource\u003cT\u003e? source, out short token);\r\n}\r\n```",
                                           "updatedAt":  "2023-07-31T17:18:58Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5i36J1",
                                           "createdAt":  "2023-07-31T17:20:11Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "teo-tsirpanis",
                                           "body":  "Other low-level and potentially unsafe operations are in a `***Marshal` class in `System.Runtime.InteropServices`.",
                                           "updatedAt":  "2023-07-31T17:20:22Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5i39Cu",
                                           "createdAt":  "2023-07-31T17:24:35Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "sakno",
                                           "body":  "Can\u0027t say that `TryGetValueTaskSource` is unsafe (at least in the context of unsafe memory access). `MemoryMarshal` can be used in interop scenarios (through pointer marshalling), `CollectionsMarshal` the same. `TryGetValueTaskSource` cannot be used for interop with native code, unless you have some internal convention about placing such kind of API.",
                                           "updatedAt":  "2023-07-31T17:24:35Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5i4Tn2",
                                           "createdAt":  "2023-07-31T18:25:38Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "teo-tsirpanis",
                                           "body":  "Like many `***Marshal` APIs, the proposed ones expose internal details that can be misused, and more importantly very few people will find a need to use them.",
                                           "updatedAt":  "2023-07-31T18:25:38Z"
                                       }
                                   ],
                         "totalCount":  8
                     },
        "title":  "[API Proposal]: Ability to convert ValueTask\u003cT\u003e to ValueTask",
        "labels":  [
                       "api-suggestion",
                       "area-System.Threading.Tasks",
                       "needs-further-triage"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/89778",
        "createdAt":  "2023-08-01T13:40:08Z",
        "number":  89778,
        "author":  "alrz",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOC4Z1TA==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "JakeYallop",
                                            "createdAt":  "2024-06-05T14:30:19Z"
                                        }
                                    ],
                          "totalCount":  1
                      },
        "updatedAt":  "2023-08-08T13:07:55Z",
        "body":  "### Background and motivation\r\n\r\nTask does not support covariant type args. This would be similar to `ImmutableArray\u003cT\u003e.CastUp`.\r\n\r\nThe current workaround is to simply `await` the task or use `ContinueWith` to cast.\r\n\r\n### API Proposal\r\n\r\n```diff\r\npublic class Task\u003cT\u003e\r\n{\r\n+     public static Task\u003cT\u003e CastUp\u003cTDerived\u003e(Task\u003cTDerived\u003e task) where TDerived : class?, T;\r\n}\r\n\r\npublic struct ValueTask\u003cT\u003e\r\n{\r\n+     public static ValueTask\u003cT\u003e CastUp\u003cTDerived\u003e(ValueTask\u003cTDerived\u003e task) where TDerived : class?, T;\r\n}\r\n```\r\n\r\n\r\n### API Usage\r\n\r\n```csharp\r\nTask\u003cstring\u003e task1 = e;\r\nTask\u003cobject\u003e task2 = Task\u003cobject\u003e.CastUp(task);\r\n```\r\n\r\n\r\n### Alternative Designs\r\n\r\n_No response_\r\n\r\n### Risks\r\n\r\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOY3c0sw==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5i9wL8",
                                           "createdAt":  "2023-08-01T13:40:18Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-threading-tasks\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Background and motivation\n\nTask does not support covariant type args. This would be similar to `ImmutableArray\u003cT\u003e.CastUp`.\r\n\r\nThe current workaround is to simply `await` the task or use `ContinueWith` to cast.\n\n### API Proposal\n\n```diff\r\npublic class Task\u003cT\u003e\r\n{\r\n+     public static Task\u003cT\u003e CastUp\u003cTDerived\u003e(Task\u003cTDerived\u003e task) where TDerived : class?, T;\r\n}\r\n```\r\n\n\n### API Usage\n\n```csharp\r\nTask\u003cstring\u003e task1 = e;\r\nTask\u003cobject\u003e task2 = Task\u003cobject\u003e.CastUp(task);\r\n```\r\n\n\n### Alternative Designs\n\n_No response_\n\n### Risks\n\n_No response_\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003ealrz\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`api-suggestion`, `area-System.Threading.Tasks`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-08-01T13:40:18Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5jBz0E",
                                           "createdAt":  "2023-08-02T03:04:14Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "huoyaoyuan",
                                           "body":  "A covariant interface may be useful for `Task`, but for `ValueTask` a `CastUp` may help better.",
                                           "updatedAt":  "2023-08-02T03:04:14Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5jdzSz",
                                           "createdAt":  "2023-08-08T00:54:52Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ericstj",
                                           "body":  "cc @stephentoub ",
                                           "updatedAt":  "2023-08-08T00:54:52Z"
                                       }
                                   ],
                         "totalCount":  3
                     },
        "title":  "[API Proposal]: `Task\u003cT\u003e.CastUp`",
        "labels":  [
                       "api-suggestion",
                       "area-System.Threading.Tasks",
                       "needs-further-triage"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/89921",
        "createdAt":  "2023-08-03T09:06:33Z",
        "number":  89921,
        "author":  "akoeplinger",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2024-06-28T14:34:14Z",
        "body":  "These tests are failing on Mono on musl but not on other Linux runs:\r\n\r\n```\r\n  Discovering: System.Threading.Tasks.Tests (method display = ClassAndMethod, method display options = None)\r\n  Discovered:  System.Threading.Tasks.Tests (found 177 of 777 test cases)\r\n  Starting:    System.Threading.Tasks.Tests (parallel test collections = on, max threads = 2)\r\n    System.Threading.Tasks.Tests.TaskRunSyncTests.TaskRunSyncTest18 [FAIL]\r\n      Assert.Equal() Failure\r\n      Expected: 1\r\n      Actual:   13\r\n      Stack Trace:\r\n        /_/src/libraries/System.Threading.Tasks/tests/Task/TaskRunSyncTests.cs(275,0): at System.Threading.Tasks.Tests.TaskRunSyncTest.RealRun()\r\n        /_/src/libraries/System.Threading.Tasks/tests/Task/TaskRunSyncTests.cs(558,0): at System.Threading.Tasks.Tests.TaskRunSyncTests.TaskRunSyncTest18()\r\n        /_/src/mono/System.Private.CoreLib/src/System/Reflection/MethodBaseInvoker.Mono.cs(22,0): at System.Reflection.MethodBaseInvoker.InterpretedInvoke_Method(Object obj, IntPtr* args)\r\n        /_/src/libraries/System.Private.CoreLib/src/System/Reflection/MethodBaseInvoker.cs(57,0): at System.Reflection.MethodBaseInvoker.InvokeWithNoArgs(Object obj, BindingFlags invokeAttr)\r\n      Assert.Equal() Failure\r\n      Expected: 1\r\n      Actual:   9\r\n      Stack Trace:\r\n        /_/src/libraries/System.Threading.Tasks/tests/Task/TaskRunSyncTests.cs(275,0): at System.Threading.Tasks.Tests.TaskRunSyncTest.RealRun()\r\n    System.Threading.Tasks.Tests.TaskRunSyncTests.TaskRunSyncTest15 [FAIL]\r\n        /_/src/libraries/System.Threading.Tasks/tests/Task/TaskRunSyncTests.cs(532,0): at System.Threading.Tasks.Tests.TaskRunSyncTests.TaskRunSyncTest15()\r\n        /_/src/mono/System.Private.CoreLib/src/System/Reflection/MethodBaseInvoker.Mono.cs(22,0): at System.Reflection.MethodBaseInvoker.InterpretedInvoke_Method(Object obj, IntPtr* args)\r\n        /_/src/libraries/System.Private.CoreLib/src/System/Reflection/MethodBaseInvoker.cs(57,0): at System.Reflection.MethodBaseInvoker.InvokeWithNoArgs(Object obj, BindingFlags invokeAttr)\r\n      Task wasn\u0027t RunSynchronously with TaskScheduler specified\r\n      Expected: True\r\n      Actual:   False\r\n      Stack Trace:\r\n    System.Threading.Tasks.Tests.TaskRunSyncTests.TaskRunSyncTest23 [FAIL]\r\n        /_/src/libraries/System.Threading.Tasks/tests/Task/TaskRunSyncTests.cs(305,0): at System.Threading.Tasks.Tests.TaskRunSyncTest.RealRun()\r\n        /_/src/libraries/System.Threading.Tasks/tests/Task/TaskRunSyncTests.cs(599,0): at System.Threading.Tasks.Tests.TaskRunSyncTests.TaskRunSyncTest23()\r\n        /_/src/mono/System.Private.CoreLib/src/System/Reflection/MethodBaseInvoker.Mono.cs(22,0): at System.Reflection.MethodBaseInvoker.InterpretedInvoke_Method(Object obj, IntPtr* args)\r\n        /_/src/libraries/System.Private.CoreLib/src/System/Reflection/MethodBaseInvoker.cs(57,0): at System.Reflection.MethodBaseInvoker.InvokeWithNoArgs(Object obj, BindingFlags invokeAttr)\r\n      Task wasn\u0027t RunSynchronously with TaskScheduler specified\r\n      Expected: True\r\n      Actual:   False\r\n      Stack Trace:\r\n    System.Threading.Tasks.Tests.TaskRunSyncTests.TaskRunSyncTest19 [FAIL]\r\n        /_/src/libraries/System.Threading.Tasks/tests/Task/TaskRunSyncTests.cs(305,0): at System.Threading.Tasks.Tests.TaskRunSyncTest.RealRun()\r\n        /_/src/libraries/System.Threading.Tasks/tests/Task/TaskRunSyncTests.cs(566,0): at System.Threading.Tasks.Tests.TaskRunSyncTests.TaskRunSyncTest19()\r\n        /_/src/mono/System.Private.CoreLib/src/System/Reflection/MethodBaseInvoker.Mono.cs(22,0): at System.Reflection.MethodBaseInvoker.InterpretedInvoke_Method(Object obj, IntPtr* args)\r\n        /_/src/libraries/System.Private.CoreLib/src/System/Reflection/MethodBaseInvoker.cs(57,0): at System.Reflection.MethodBaseInvoker.InvokeWithNoArgs(Object obj, BindingFlags invokeAttr)\r\n      Task wasn\u0027t RunSynchronously with TaskScheduler specified\r\n      Expected: True\r\n      Actual:   False\r\n      Stack Trace:\r\n    System.Threading.Tasks.Tests.TaskRunSyncTests.TaskRunSyncTest20 [FAIL]\r\n        /_/src/libraries/System.Threading.Tasks/tests/Task/TaskRunSyncTests.cs(305,0): at System.Threading.Tasks.Tests.TaskRunSyncTest.RealRun()\r\n        /_/src/libraries/System.Threading.Tasks/tests/Task/TaskRunSyncTests.cs(575,0): at System.Threading.Tasks.Tests.TaskRunSyncTests.TaskRunSyncTest20()\r\n        /_/src/mono/System.Private.CoreLib/src/System/Reflection/MethodBaseInvoker.Mono.cs(22,0): at System.Reflection.MethodBaseInvoker.InterpretedInvoke_Method(Object obj, IntPtr* args)\r\n        /_/src/libraries/System.Private.CoreLib/src/System/Reflection/MethodBaseInvoker.cs(57,0): at System.Reflection.MethodBaseInvoker.InvokeWithNoArgs(Object obj, BindingFlags invokeAttr)\r\n      Assert.Equal() Failure\r\n      Expected: 1\r\n      Actual:   22\r\n      Stack Trace:\r\n        /_/src/libraries/System.Threading.Tasks/tests/Task/TaskRunSyncTests.cs(275,0): at System.Threading.Tasks.Tests.TaskRunSyncTest.RealRun()\r\n        /_/src/libraries/System.Threading.Tasks/tests/Task/TaskRunSyncTests.cs(549,0): at System.Threading.Tasks.Tests.TaskRunSyncTests.TaskRunSyncTest17()\r\n        /_/src/mono/System.Private.CoreLib/src/System/Reflection/MethodBaseInvoker.Mono.cs(22,0): at System.Reflection.MethodBaseInvoker.InterpretedInvoke_Method(Object obj, IntPtr* args)\r\n        /_/src/libraries/System.Private.CoreLib/src/System/Reflection/MethodBaseInvoker.cs(57,0): at System.Reflection.MethodBaseInvoker.InvokeWithNoArgs(Object obj, BindingFlags invokeAttr)\r\n    System.Threading.Tasks.Tests.TaskRunSyncTests.TaskRunSyncTest17 [FAIL]\r\n      Did not expect a new Post to underlying SynchronizationContext\r\n      Expected: True\r\n      Actual:   False\r\n      Stack Trace:\r\n        /_/src/libraries/System.Threading.Tasks/tests/TaskScheduler/TaskSchedulerTests.cs(267,0): at System.Threading.Tasks.Tests.TaskSchedulerTests.RunSynchronizationContextTaskSchedulerTests()\r\n    System.Threading.Tasks.Tests.TaskSchedulerTests.RunSynchronizationContextTaskSchedulerTests [FAIL]\r\n        /_/src/mono/System.Private.CoreLib/src/System/Reflection/MethodBaseInvoker.Mono.cs(22,0): at System.Reflection.MethodBaseInvoker.InterpretedInvoke_Method(Object obj, IntPtr* args)\r\n        /_/src/libraries/System.Private.CoreLib/src/System/Reflection/MethodBaseInvoker.cs(57,0): at System.Reflection.MethodBaseInvoker.InvokeWithNoArgs(Object obj, BindingFlags invokeAttr)\r\n    System.Threading.Tasks.Tests.AsyncTaskMethodBuilderTests.DroppedIncompleteStateMachine_RaisesIncompleteAsyncMethodEvent [SKIP]\r\n      Test requires precise GC\r\n  Finished:    System.Threading.Tasks.Tests\r\n=== TEST EXECUTION SUMMARY ===\r\n   System.Threading.Tasks.Tests  Total: 181, Errors: 0, Failed: 7, Skipped: 1, Time: 24.092s\r\n```",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOcf_XPQ==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5x_9c9",
                                           "createdAt":  "2024-01-26T19:37:30Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-threading-tasks\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nThese tests are failing on Mono on musl but not on other Linux runs:\r\n\r\n```\r\n  Discovering: System.Threading.Tasks.Tests (method display = ClassAndMethod, method display options = None)\r\n  Discovered:  System.Threading.Tasks.Tests (found 177 of 777 test cases)\r\n  Starting:    System.Threading.Tasks.Tests (parallel test collections = on, max threads = 2)\r\n    System.Threading.Tasks.Tests.TaskRunSyncTests.TaskRunSyncTest18 [FAIL]\r\n      Assert.Equal() Failure\r\n      Expected: 1\r\n      Actual:   13\r\n      Stack Trace:\r\n        /_/src/libraries/System.Threading.Tasks/tests/Task/TaskRunSyncTests.cs(275,0): at System.Threading.Tasks.Tests.TaskRunSyncTest.RealRun()\r\n        /_/src/libraries/System.Threading.Tasks/tests/Task/TaskRunSyncTests.cs(558,0): at System.Threading.Tasks.Tests.TaskRunSyncTests.TaskRunSyncTest18()\r\n        /_/src/mono/System.Private.CoreLib/src/System/Reflection/MethodBaseInvoker.Mono.cs(22,0): at System.Reflection.MethodBaseInvoker.InterpretedInvoke_Method(Object obj, IntPtr* args)\r\n        /_/src/libraries/System.Private.CoreLib/src/System/Reflection/MethodBaseInvoker.cs(57,0): at System.Reflection.MethodBaseInvoker.InvokeWithNoArgs(Object obj, BindingFlags invokeAttr)\r\n      Assert.Equal() Failure\r\n      Expected: 1\r\n      Actual:   9\r\n      Stack Trace:\r\n        /_/src/libraries/System.Threading.Tasks/tests/Task/TaskRunSyncTests.cs(275,0): at System.Threading.Tasks.Tests.TaskRunSyncTest.RealRun()\r\n    System.Threading.Tasks.Tests.TaskRunSyncTests.TaskRunSyncTest15 [FAIL]\r\n        /_/src/libraries/System.Threading.Tasks/tests/Task/TaskRunSyncTests.cs(532,0): at System.Threading.Tasks.Tests.TaskRunSyncTests.TaskRunSyncTest15()\r\n        /_/src/mono/System.Private.CoreLib/src/System/Reflection/MethodBaseInvoker.Mono.cs(22,0): at System.Reflection.MethodBaseInvoker.InterpretedInvoke_Method(Object obj, IntPtr* args)\r\n        /_/src/libraries/System.Private.CoreLib/src/System/Reflection/MethodBaseInvoker.cs(57,0): at System.Reflection.MethodBaseInvoker.InvokeWithNoArgs(Object obj, BindingFlags invokeAttr)\r\n      Task wasn\u0027t RunSynchronously with TaskScheduler specified\r\n      Expected: True\r\n      Actual:   False\r\n      Stack Trace:\r\n    System.Threading.Tasks.Tests.TaskRunSyncTests.TaskRunSyncTest23 [FAIL]\r\n        /_/src/libraries/System.Threading.Tasks/tests/Task/TaskRunSyncTests.cs(305,0): at System.Threading.Tasks.Tests.TaskRunSyncTest.RealRun()\r\n        /_/src/libraries/System.Threading.Tasks/tests/Task/TaskRunSyncTests.cs(599,0): at System.Threading.Tasks.Tests.TaskRunSyncTests.TaskRunSyncTest23()\r\n        /_/src/mono/System.Private.CoreLib/src/System/Reflection/MethodBaseInvoker.Mono.cs(22,0): at System.Reflection.MethodBaseInvoker.InterpretedInvoke_Method(Object obj, IntPtr* args)\r\n        /_/src/libraries/System.Private.CoreLib/src/System/Reflection/MethodBaseInvoker.cs(57,0): at System.Reflection.MethodBaseInvoker.InvokeWithNoArgs(Object obj, BindingFlags invokeAttr)\r\n      Task wasn\u0027t RunSynchronously with TaskScheduler specified\r\n      Expected: True\r\n      Actual:   False\r\n      Stack Trace:\r\n    System.Threading.Tasks.Tests.TaskRunSyncTests.TaskRunSyncTest19 [FAIL]\r\n        /_/src/libraries/System.Threading.Tasks/tests/Task/TaskRunSyncTests.cs(305,0): at System.Threading.Tasks.Tests.TaskRunSyncTest.RealRun()\r\n        /_/src/libraries/System.Threading.Tasks/tests/Task/TaskRunSyncTests.cs(566,0): at System.Threading.Tasks.Tests.TaskRunSyncTests.TaskRunSyncTest19()\r\n        /_/src/mono/System.Private.CoreLib/src/System/Reflection/MethodBaseInvoker.Mono.cs(22,0): at System.Reflection.MethodBaseInvoker.InterpretedInvoke_Method(Object obj, IntPtr* args)\r\n        /_/src/libraries/System.Private.CoreLib/src/System/Reflection/MethodBaseInvoker.cs(57,0): at System.Reflection.MethodBaseInvoker.InvokeWithNoArgs(Object obj, BindingFlags invokeAttr)\r\n      Task wasn\u0027t RunSynchronously with TaskScheduler specified\r\n      Expected: True\r\n      Actual:   False\r\n      Stack Trace:\r\n    System.Threading.Tasks.Tests.TaskRunSyncTests.TaskRunSyncTest20 [FAIL]\r\n        /_/src/libraries/System.Threading.Tasks/tests/Task/TaskRunSyncTests.cs(305,0): at System.Threading.Tasks.Tests.TaskRunSyncTest.RealRun()\r\n        /_/src/libraries/System.Threading.Tasks/tests/Task/TaskRunSyncTests.cs(575,0): at System.Threading.Tasks.Tests.TaskRunSyncTests.TaskRunSyncTest20()\r\n        /_/src/mono/System.Private.CoreLib/src/System/Reflection/MethodBaseInvoker.Mono.cs(22,0): at System.Reflection.MethodBaseInvoker.InterpretedInvoke_Method(Object obj, IntPtr* args)\r\n        /_/src/libraries/System.Private.CoreLib/src/System/Reflection/MethodBaseInvoker.cs(57,0): at System.Reflection.MethodBaseInvoker.InvokeWithNoArgs(Object obj, BindingFlags invokeAttr)\r\n      Assert.Equal() Failure\r\n      Expected: 1\r\n      Actual:   22\r\n      Stack Trace:\r\n        /_/src/libraries/System.Threading.Tasks/tests/Task/TaskRunSyncTests.cs(275,0): at System.Threading.Tasks.Tests.TaskRunSyncTest.RealRun()\r\n        /_/src/libraries/System.Threading.Tasks/tests/Task/TaskRunSyncTests.cs(549,0): at System.Threading.Tasks.Tests.TaskRunSyncTests.TaskRunSyncTest17()\r\n        /_/src/mono/System.Private.CoreLib/src/System/Reflection/MethodBaseInvoker.Mono.cs(22,0): at System.Reflection.MethodBaseInvoker.InterpretedInvoke_Method(Object obj, IntPtr* args)\r\n        /_/src/libraries/System.Private.CoreLib/src/System/Reflection/MethodBaseInvoker.cs(57,0): at System.Reflection.MethodBaseInvoker.InvokeWithNoArgs(Object obj, BindingFlags invokeAttr)\r\n    System.Threading.Tasks.Tests.TaskRunSyncTests.TaskRunSyncTest17 [FAIL]\r\n      Did not expect a new Post to underlying SynchronizationContext\r\n      Expected: True\r\n      Actual:   False\r\n      Stack Trace:\r\n        /_/src/libraries/System.Threading.Tasks/tests/TaskScheduler/TaskSchedulerTests.cs(267,0): at System.Threading.Tasks.Tests.TaskSchedulerTests.RunSynchronizationContextTaskSchedulerTests()\r\n    System.Threading.Tasks.Tests.TaskSchedulerTests.RunSynchronizationContextTaskSchedulerTests [FAIL]\r\n        /_/src/mono/System.Private.CoreLib/src/System/Reflection/MethodBaseInvoker.Mono.cs(22,0): at System.Reflection.MethodBaseInvoker.InterpretedInvoke_Method(Object obj, IntPtr* args)\r\n        /_/src/libraries/System.Private.CoreLib/src/System/Reflection/MethodBaseInvoker.cs(57,0): at System.Reflection.MethodBaseInvoker.InvokeWithNoArgs(Object obj, BindingFlags invokeAttr)\r\n    System.Threading.Tasks.Tests.AsyncTaskMethodBuilderTests.DroppedIncompleteStateMachine_RaisesIncompleteAsyncMethodEvent [SKIP]\r\n      Test requires precise GC\r\n  Finished:    System.Threading.Tasks.Tests\r\n=== TEST EXECUTION SUMMARY ===\r\n   System.Threading.Tasks.Tests  Total: 181, Errors: 0, Failed: 7, Skipped: 1, Time: 24.092s\r\n```\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eakoeplinger\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Threading.Tasks`, `disabled-test`, `os-linux-musl`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e9.0.0\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2024-01-26T19:37:30Z"
                                       }
                                   ],
                         "totalCount":  1
                     },
        "title":  " System.Threading.Tasks.Tests.TaskRunSyncTests outerloop tests fail on Mono on Linux MUSL",
        "labels":  [
                       "area-System.Threading.Tasks",
                       "disabled-test",
                       "os-linux-musl"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/91527",
        "createdAt":  "2023-09-04T02:29:44Z",
        "number":  91527,
        "author":  "KumoKyaku",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2024-07-19T16:21:15Z",
        "body":  "### Background and motivation\r\n\r\nIValueTaskSource token type changed from short to generic type. \r\n\r\nThere are some business scenarios where I have my own data types, such as string, date. I need to generate some asynchronous tasks for each element of these types and cache them for other business use.\r\n\r\nNow I need to create a token of type short for each element and create a dictionary lookup table instead of using my data directly as a token.\r\n\r\nGeneric apis can improve this.\r\n\r\n\r\n### API Proposal\r\n\r\n```csharp\r\npublic interface IValueTaskSource\u003cout TResult, KToken\u003e\r\n{\r\n    TResult GetResult(KToken token);\r\n    ValueTaskSourceStatus GetStatus(KToken token);\r\n    void OnCompleted(Action\u003cobject\u003e continuation, object state, KToken token, ValueTaskSourceOnCompletedFlags flags);\r\n}\r\n\r\npublic readonly struct ValueTask\u003cTResult, KToken\u003e\r\n{\r\n    public ValueTask(IValueTaskSource\u003cTResult, KToken\u003e source, KToken token)\r\n    {\r\n\r\n    }\r\n}\r\n```\r\n\r\n\r\n### API Usage\r\n\r\n```csharp\r\npublic class MyValueTaskSource\u003cTResult, KToken\u003e : IValueTaskSource\u003cTResult, KToken\u003e\r\n{\r\n    public TResult GetResult(KToken token)\r\n    {\r\n        throw new NotImplementedException();\r\n    }\r\n\r\n    public ValueTaskSourceStatus GetStatus(KToken token)\r\n    {\r\n        throw new NotImplementedException();\r\n    }\r\n\r\n    public void OnCompleted(Action\u003cobject\u003e continuation, object state, KToken token, ValueTaskSourceOnCompletedFlags flags)\r\n    {\r\n        throw new NotImplementedException();\r\n    }\r\n}\r\n\r\n\r\npublic void APIUsage()\r\n{\r\n    List\u003cstring\u003e myFriends = new List\u003cstring\u003e()\r\n    {\r\n        \"Tom\",\"Jerry\"\r\n    };\r\n\r\n    //Token type is string instead of short\r\n    //I no longer need to convert my type to short\r\n    foreach (string fri in myFriends)\r\n    {\r\n        IValueTaskSource\u003cbool, string\u003e dinnerTaskSource = new MyValueTaskSource\u003cbool, string\u003e();\r\n        ValueTask\u003cbool, string\u003e dinnerTask = new ValueTask\u003cbool, string\u003e(dinnerTaskSource, fri);\r\n    }\r\n}\r\n```\r\n\r\n\r\n### Alternative Designs\r\n\r\n```csharp\r\nnamespace System.Threading.Tasks.Sources\r\n{\r\n    public interface IValueTaskSource\u003cout TResult\u003e\r\n    {\r\n        TResult GetResult(short token);\r\n        ValueTaskSourceStatus GetStatus(short token);\r\n        void OnCompleted(Action\u003cobject\u003e continuation, object state, short token, ValueTaskSourceOnCompletedFlags flags);\r\n    }\r\n}\r\n```\r\n\r\nMaybe can change to\r\n\r\n```csharp\r\npublic interface IValueTaskSource\u003cout TResult\u003e : IValueTaskSource\u003cTResult, short\u003e { }\r\n```\r\n\r\n### Risks\r\n\r\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOZZvfGA==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5lmQQ3",
                                           "createdAt":  "2023-09-04T02:29:52Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-threading-tasks\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Background and motivation\n\nIValueTaskSource token type changed from short to generic type. \r\n\r\nThere are some business scenarios where I have my own data types, such as string, date. I need to generate some asynchronous tasks for each element of these types and cache them for other business use.\r\n\r\nNow I need to create a token of type short for each element and create a dictionary lookup table instead of using my data directly as a token.\r\n\r\nGeneric apis can improve this.\r\n\n\n### API Proposal\n\n```csharp\r\npublic interface IValueTaskSource\u003cout TResult, TokenK\u003e\r\n{\r\n    TResult GetResult(TokenK token);\r\n    ValueTaskSourceStatus GetStatus(TokenK token);\r\n    void OnCompleted(Action\u003cobject\u003e continuation, object state, TokenK token, ValueTaskSourceOnCompletedFlags flags);\r\n}\r\n\r\npublic readonly struct ValueTask\u003cTResult, TokenK\u003e\r\n{\r\n    public ValueTask(IValueTaskSource\u003cTResult, TokenK\u003e source, TokenK token)\r\n    {\r\n\r\n    }\r\n}\r\n```\r\n\n\n### API Usage\n\n```csharp\r\npublic class MyValueTaskSource\u003cTResult, TokenK\u003e : IValueTaskSource\u003cTResult, TokenK\u003e\r\n{\r\n    public TResult GetResult(TokenK token)\r\n    {\r\n        throw new NotImplementedException();\r\n    }\r\n\r\n    public ValueTaskSourceStatus GetStatus(TokenK token)\r\n    {\r\n        throw new NotImplementedException();\r\n    }\r\n\r\n    public void OnCompleted(Action\u003cobject\u003e continuation, object state, TokenK token, ValueTaskSourceOnCompletedFlags flags)\r\n    {\r\n        throw new NotImplementedException();\r\n    }\r\n}\r\n\r\n\r\npublic void APIUsage()\r\n{\r\n    List\u003cstring\u003e myFriends = new List\u003cstring\u003e()\r\n    {\r\n        \"Tom\",\"Jerry\"\r\n    };\r\n\r\n    //Token type is string instead of short\r\n    //I no longer need to convert my type to short\r\n    foreach (string fri in myFriends)\r\n    {\r\n        IValueTaskSource\u003cbool, string\u003e dinnerTaskSource = new MyValueTaskSource\u003cbool, string\u003e();\r\n        ValueTask\u003cbool, string\u003e dinnerTask = new ValueTask\u003cbool, string\u003e(dinnerTaskSource, fri);\r\n    }\r\n}\r\n```\r\n\n\n### Alternative Designs\n\n```csharp\r\nnamespace System.Threading.Tasks.Sources\r\n{\r\n    public interface IValueTaskSource\u003cout TResult\u003e\r\n    {\r\n        TResult GetResult(short token);\r\n        ValueTaskSourceStatus GetStatus(short token);\r\n        void OnCompleted(Action\u003cobject\u003e continuation, object state, short token, ValueTaskSourceOnCompletedFlags flags);\r\n    }\r\n}\r\n```\r\n\r\nMaybe can change to\r\n\r\n```csharp\r\npublic interface IValueTaskSource\u003cout TResult\u003e : IValueTaskSource\u003cTResult, short\u003e { }\r\n```\n\n### Risks\n\n_No response_\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eKumoKyaku\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`api-suggestion`, `area-System.Threading.Tasks`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-09-04T02:29:52Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5lmsbn",
                                           "createdAt":  "2023-09-04T05:39:34Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "huoyaoyuan",
                                           "body":  "\u003e cache them for other business use.\r\n\r\nNote that `ValueTask` **should not be cached**. Only `Task` can be cached.\r\n\r\nThe design purpose of `short token` of `ValueTask` is to distinguish reused objects, which is in the opposite way of caching.",
                                           "updatedAt":  "2023-09-04T05:39:34Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5lm98Y",
                                           "createdAt":  "2023-09-04T06:55:55Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "KumoKyaku",
                                           "body":  "\u003e Note that **should not be cached**. Only can be cached.`ValueTask``Task`\r\n\r\nYes, I know that. \r\nHowever, IValueTaskSource can be cached, and if IValueTaskSource wants to use a generic token type, it must be used in conjunction with the corresponding ValueTask.\r\n\r\n\r\nIn the current API design, there must be a conversion process from my token type to short.\r\n```csharp\r\npublic ValueTask\u003cint\u003e GetOrCreate(string key)\r\n{\r\n    //If you want to implement this function\r\n\r\n    IValueTaskSource\u003cint\u003e source = MyValueTaskSource.Default;\r\n\r\n    short token = 0;\r\n    if (key == \"Tom\")\r\n    {\r\n        token = 1;\r\n    }\r\n    else if (key == \"Jerry\")\r\n    {\r\n        token = 2;\r\n    }\r\n\r\n    return new ValueTask\u003cint\u003e(source, token);\r\n}\r\n```",
                                           "updatedAt":  "2023-09-04T07:16:10Z"
                                       }
                                   ],
                         "totalCount":  3
                     },
        "title":  "[API Proposal]: ValueTask\u003cTResult, KToken\u003e and IValueTaskSource\u003cout TResult, KToken\u003e",
        "labels":  [
                       "api-suggestion",
                       "area-System.Threading.Tasks",
                       "needs-further-triage"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/92412",
        "createdAt":  "2023-09-21T15:17:07Z",
        "number":  92412,
        "author":  "TonyValenti",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2024-07-19T16:21:16Z",
        "body":  "### Background and motivation\n\nSometimes tasks must be completed in a time-sensitive manner.  For example, if I receive an OAUTH code from a system, I might only have a 10-second window during which the originating system will allow me to convert the code into an access/refresh token.\r\n\r\nIn low concurrency systems, this is not a problem, but in high-concurrency apps, there can be a significant delay between the two continuations running.  ie.\r\n```csharp\r\nvar Code = await GetCodeAsync(...);\r\n//Due to lots of tasks, there is a 20 second window here.\r\nvar Token = await GetTokenAsync(...)\r\n```\r\n\r\nIt would be nice if there was a ```ConfigureAwaitOptions.TimeSensitive``` that I could use to inform the task scheduler that I\u0027d like certain tasks to be run as soon as possible.\r\n\n\n### API Proposal\n\n```csharp\r\nnamespace System.Threading.Tasks\r\n\r\npublic enum ConfigureAwaitOptions\r\n{\r\n  TimeSensitive = 16,\r\n}\r\n```\r\n\n\n### API Usage\n\n```csharp\r\nawait SomeTask\r\n    .ConfigureAwait(ConfigureAwaitOptions.TimeSensitive)\r\n    ;\r\n```\r\n\n\n### Alternative Designs\n\nI could spin up a dedicated thread or thread pool to run my time-sensitive task.  That seems like a lot of overhead for something that could just be another flag.\n\n### Risks\n\nUsers could abuse TimeSensitive by thinking that all their tasks should be time sensitive really only special ones should be.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOZxqUYw==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5nGpRj",
                                           "createdAt":  "2023-09-21T15:17:16Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-threading-tasks\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Background and motivation\n\nSometimes tasks must be completed in a time-sensitive manner.  For example, if I receive an OAUTH code from a system, I might only have a 10-second window during which the originating system will allow me to convert the code into an access/refresh token.\r\n\r\nIn low concurrency systems, this is not a problem, but in high-concurrency apps, there can be a significant delay between the two continuations running.  ie.\r\n```csharp\r\nvar Code = await GetCodeAsync(...);\r\n//Due to lots of tasks, there is a 20 second window here.\r\nvar Token = await GetTokenAsync(...)\r\n```\r\n\r\nIt would be nice if there was a ```ConfigureAwaitOptions.TimeSensitive``` that I could use to inform the task scheduler that I\u0027d like certain tasks to be run as soon as possible.\r\n\n\n### API Proposal\n\n```csharp\r\nnamespace System.Threading.Tasks\r\n\r\npublic enum ConfigureAwaitOptions\r\n{\r\n  TimeSensitive = 16,\r\n}\r\n```\r\n\n\n### API Usage\n\n```csharp\r\nawait SomeTask\r\n    .ConfigureAwait(ConfigureAwaitOptions.TimeSensitive)\r\n    ;\r\n```\r\n\n\n### Alternative Designs\n\nI could spin up a dedicated thread or thread pool to run my time-sensitive task.  That seems like a lot of overhead for something that could just be another flag.\n\n### Risks\n\nUsers could abuse TimeSensitive by thinking that all their tasks should be time sensitive really only special ones should be.\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eTonyValenti\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`api-suggestion`, `area-System.Threading.Tasks`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-09-21T15:17:16Z"
                                       }
                                   ],
                         "totalCount":  1
                     },
        "title":  "[API Proposal]: ConfigureAwaitOptions.TimeSensitive",
        "labels":  [
                       "api-suggestion",
                       "area-System.Threading.Tasks",
                       "needs-further-triage"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/93073",
        "createdAt":  "2023-10-05T15:32:01Z",
        "number":  93073,
        "author":  "Khhs167",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2024-07-19T16:21:17Z",
        "body":  "### Background and motivation\r\n\r\nCoroutines are a staple of many development pipelines, whether that\u0027d be UI or games, as long as you\u0027ve got real-time mixed in there coroutines are effectively essential.\r\n\r\nSome of the issues can be fixed with state machines, but the most universal solution would most likely be the IEnumerable-generator approach. Whilst this works fine 80% of the time, the best option would simply be to add coroutines to the .NET runtime(and C#), since there are a number of things that would be weird to do with IEnumerables, and the syntax can get quite messy.\r\n\r\n### API Proposal\r\n\r\n`yield;` - Used to pause execution of coroutine - New keyword usage\r\n`await [coroutine];` - Used to \"fork\" into another coroutine - New keyword usage\r\n`invoke [coroutine];` - Used to run a coroutine fully\r\n`coroutine` - Either used like the `async` modifier to declare a coroutine function, or used to declare a coroutine object.\r\n\r\n`coroutine` may have one type argument, `T`. This specifies the return value of the coroutine.\r\n\r\n`coroutine` specifies the function `bool Proceed()`, or for coroutines with return values,  `bool Proceed(out T? @return)`.\r\n\r\n`Proceed` returns true if the coroutine is finished or just hit the end.\r\n\r\n`@return` in `Proceed` is always null if the return value is false, otherwise it is only null if the coroutine returned null.\r\n\r\n### API Usage\r\n\r\n```csharp\r\ncoroutine string ReturningCoroutine() {\r\n    // Do some magic...\r\n    return \"myString\"\r\n}\r\n\r\ncoroutine void AwaitingCoroutine() {\r\n    // Any \".Proceed()\" calls will be inside of ReturningCoroutine until that finishes.\r\n    string reurnValue = await ReturningCoroutine();\r\n}\r\n\r\ncoroutine void BasicCoroutine() {\r\n    while(!stmt) {\r\n        yield; // Pause execution\r\n    }\r\n}\r\n\r\nvoid Main() {\r\n    coroutine awaited = AwaitingCoroutine(); // Create a coroutine instance\r\n    while(true) {\r\n         // Run until next yield\r\n         if(awaited.Proceed())\r\n             break;\r\n    }\r\n\r\n    // Run the entire coroutine without stopping at \"yield\"\r\n    invoke AwaitingCoroutine();\r\n\r\n    // Create a coroutine object with return type\r\n    coroutine\u003cstring\u003e returning = ReturningCoroutine();\r\n    \r\n    // New fancy way of invoking.\r\n    returning.Proceed(out string? retVal);\r\n}\r\n```\r\n\r\n### Alternative Designs\r\n\r\nSimilar effect could be done via a change to `IEnumerable` generators(in ways which I do not recommend), to `Task` or maybe to `async`.\r\n\r\nI personally believe it would be best to keep separate.\r\n\r\n### Risks\r\n\r\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHObqJgLA==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5oSpdQ",
                                           "createdAt":  "2023-10-05T22:05:42Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "huoyaoyuan",
                                           "body":  "Related to dotnet/runtimelab#2398",
                                           "updatedAt":  "2023-10-05T22:05:42Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5oTjhv",
                                           "createdAt":  "2023-10-06T04:11:05Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODKfzBQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "acaly",
                                                                               "createdAt":  "2023-10-21T05:09:40Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "nike4613",
                                           "body":  "I believe this can already be done with `async` at the language level. It just needs a custom task type.",
                                           "updatedAt":  "2023-10-06T04:11:05Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5oXuh_",
                                           "createdAt":  "2023-10-06T16:25:12Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-threading-tasks\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Background and motivation\r\n\r\nCoroutines are a staple of many development pipelines, whether that\u0027d be UI or games, as long as you\u0027ve got real-time mixed in there coroutines are effectively essential.\r\n\r\nSome of the issues can be fixed with state machines, but the most universal solution would most likely be the IEnumerable-generator approach. Whilst this works fine 80% of the time, the best option would simply be to add coroutines to the .NET runtime(and C#), since there are a number of things that would be weird to do with IEnumerables, and the syntax can get quite messy.\r\n\r\n### API Proposal\r\n\r\n`yield;` - Used to pause execution of coroutine - New keyword usage\r\n`await [coroutine];` - Used to \"fork\" into another coroutine - New keyword usage\r\n`invoke [coroutine];` - Used to run a coroutine fully\r\n`coroutine` - Either used like the `async` modifier to declare a coroutine function, or used to declare a coroutine object.\r\n\r\n`coroutine` may have one type argument, `T`. This specifies the return value of the coroutine.\r\n\r\n`coroutine` specifies the function `bool Proceed()`, or for coroutines with return values,  `bool Proceed(out T? @return)`.\r\n\r\n`Proceed` returns true if the coroutine is finished or just hit the end.\r\n\r\n`@return` in `Proceed` is always null if the return value is false, otherwise it is only null if the coroutine returned null.\r\n\r\n### API Usage\r\n\r\n```csharp\r\ncoroutine string ReturningCoroutine() {\r\n    // Do some magic...\r\n    return \"myString\"\r\n}\r\n\r\ncoroutine void AwaitingCoroutine() {\r\n    // Any \".Proceed()\" calls will be inside of ReturningCoroutine until that finishes.\r\n    string reurnValue = await ReturningCoroutine();\r\n}\r\n\r\ncoroutine void BasicCoroutine() {\r\n    while(!stmt) {\r\n        yield; // Pause execution\r\n    }\r\n}\r\n\r\nvoid Main() {\r\n    coroutine awaited = AwaitingCoroutine(); // Create a coroutine instance\r\n    while(true) {\r\n         // Run until next yield\r\n         if(awaited.Proceed())\r\n             break;\r\n    }\r\n\r\n    // Run the entire coroutine without stopping at \"yield\"\r\n    invoke AwaitingCoroutine();\r\n\r\n    // Create a coroutine object with return type\r\n    coroutine\u003cstring\u003e returning = ReturningCoroutine();\r\n    \r\n    // New fancy way of invoking.\r\n    returning.Proceed(out string? retVal);\r\n}\r\n```\r\n\r\n### Alternative Designs\r\n\r\nSimilar effect could be done via a change to `IEnumerable` generators(in ways which I do not recommend), to `Task` or maybe to `async`.\r\n\r\nI personally believe it would be best to keep separate.\r\n\r\n### Risks\r\n\r\n_No response_\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eKhhs167\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`api-suggestion`, `area-System.Threading.Tasks`, `untriaged`, `needs-area-label`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-10-06T16:25:12Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5pTG_y",
                                           "createdAt":  "2023-10-17T15:08:52Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Khhs167",
                                           "body":  "\u003e I believe this can already be done with `async` at the language level. It just needs a custom task type.\r\n\r\nI would be more than happy if you could help me out with implementing that, just some general guidance would be nice.\r\n\r\n:)",
                                           "updatedAt":  "2023-10-17T15:08:52Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5puBot",
                                           "createdAt":  "2023-10-21T05:12:53Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "acaly",
                                           "body":  "\u003e \u003e I believe this can already be done with `async` at the language level. It just needs a custom task type.\n\u003e \n\u003e I would be more than happy if you could help me out with implementing that, just some general guidance would be nice.\n\u003e \n\u003e :)\n\nYou should find this blog series useful: https://devblogs.microsoft.com/premier-developer/dissecting-the-async-methods-in-c/",
                                           "updatedAt":  "2023-10-21T05:12:53Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5uomAs",
                                           "createdAt":  "2023-12-14T16:12:40Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODPoGMQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "CONFUSED",
                                                                               "user":  "acaly",
                                                                               "createdAt":  "2023-12-14T17:17:21Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "Khhs167",
                                           "body":  "I more or less pushed this to the back of my mind, until I found a library that more or less seemed to implement what I wanted(with some minor drawbacks due to how C# seems to work)(https://github.com/seanofw/HalfMaid.Async), however it is not entirely stable, and a lot of that can be attributed to *a lack of documentation* for how async/await works, as well as general jank. I believe that this shouldn\u0027t have to be the case, and whilst it might not be entirely related to this issue, may I suggest that, if we don\u0027t get coroutines, we at least get some good documentation for how awaiting works, as well as some helper functions or a possible rework to allow people who don\u0027t want to spend months reading various sources implement their own async task types?\r\n\r\nEdit:\r\n\r\nI\u0027m sorry about the above message.\r\n\r\nI was angry at the fact that my entire game\u0027s development speed crawled to a halt because of a small issue, and let it out in a related issue(hence the rant-like nature of it all).\r\nIt basically boiled down to me being mad about something as big as this lacking docs, and the nature of this becoming overly complex for a single person.\r\n\r\nSorry. It won\u0027t happen again.",
                                           "updatedAt":  "2023-12-17T17:30:42Z"
                                       }
                                   ],
                         "totalCount":  6
                     },
        "title":  "[API Proposal]: A native(ish) coroutine integration",
        "labels":  [
                       "api-suggestion",
                       "area-System.Threading.Tasks",
                       "needs-further-triage"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/94158",
        "createdAt":  "2023-10-26T08:37:00Z",
        "number":  94158,
        "author":  "Evangelink",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOC-UOBQ==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Joe4evr",
                                            "createdAt":  "2024-07-22T16:54:35Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Youssef1313",
                                            "createdAt":  "2025-01-21T09:09:35Z"
                                        }
                                    ],
                          "totalCount":  2
                      },
        "updatedAt":  "2024-07-22T16:23:09Z",
        "body":  "\u003c!-- Please refer to https://github.com/dotnet/roslyn-analyzers/blob/main/GuidelinesForNewRules.md --\u003e\r\n\r\n### Describe the problem you are trying to solve\r\n\r\nIf you define a method that returns `Task`, `Task\u003cT\u003e` and I assume the same is true (not tested) for `ValueTask` and `ValueTask\u003cT\u003e` that contains some out parameter you will have no issue but when trying to provide an async implementation you will get some compiler error.\r\n\r\nIt would be interesting to get a rule that would flag a non-async declaration with Task + out on an interface, abstract or virtual member so that the user designing this API realize that it will prevent async implementation and so the design is incorrect.\r\n\r\n### Describe suggestions on how to achieve the rule\r\n\r\nFlag any interface method, abstract method or virtual method returning `Task`, `Task\u003cT\u003e`, `ValueTask` or `ValueTask\u003cT\u003e` that has some `out` parameter.\r\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOal0N7A==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5qXQ1y",
                                           "createdAt":  "2023-10-30T04:58:57Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODLTbKA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Evangelink",
                                                                               "createdAt":  "2023-10-30T07:59:06Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "mavasani",
                                           "body":  "Moving to dotnet/runtime for triaging new analyzer suggestion.",
                                           "updatedAt":  "2023-10-30T04:58:57Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5qXQ3s",
                                           "createdAt":  "2023-10-30T04:59:17Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-threading-tasks\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n\u003c!-- Please refer to https://github.com/dotnet/roslyn-analyzers/blob/main/GuidelinesForNewRules.md --\u003e\r\n\r\n### Describe the problem you are trying to solve\r\n\r\nIf you define a method that returns `Task`, `Task\u003cT\u003e` and I assume the same is true (not tested) for `ValueTask` and `ValueTask\u003cT\u003e` that contains some out parameter you will have no issue but when trying to provide an async implementation you will get some compiler error.\r\n\r\nIt would be interesting to get a rule that would flag a non-async declaration with Task + out on an interface, abstract or virtual member so that the user designing this API realize that it will prevent async implementation and so the design is incorrect.\r\n\r\n### Describe suggestions on how to achieve the rule\r\n\r\nFlag any interface method, abstract method or virtual method returning `Task`, `Task\u003cT\u003e`, `ValueTask` or `ValueTask\u003cT\u003e` that has some `out` parameter.\r\n\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eEvangelink\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Threading.Tasks`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-10-30T04:59:17Z"
                                       }
                                   ],
                         "totalCount":  2
                     },
        "title":  "Method returning Task/Task\u003cT\u003e should not have out parameters",
        "labels":  [
                       "area-System.Threading.Tasks",
                       "code-analyzer",
                       "needs-further-triage"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/94653",
        "createdAt":  "2023-11-13T06:59:39Z",
        "number":  94653,
        "author":  "MichalStrehovsky",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-07-16T06:27:37Z",
        "body":  "Seen in Native AOT Alpine x64 test legs only so far.\r\n\r\n## Build Information\r\nBuild: https://dev.azure.com/dnceng-public/cbb18261-c48f-4abb-8651-8cdcb5474649/_build/results?buildId=465740\r\nBuild error leg or test failing: System.Threading.Tasks.Tests.TaskRunSyncTests.TaskRunSyncTest11\r\nPull request: https://github.com/dotnet/runtime/pull/94515\r\n\u003c!-- Error message template  --\u003e\r\n## Error Message\r\n\r\nFill the error message using [step by step known issues guidance](https://github.com/dotnet/arcade/blob/main/Documentation/Projects/Build%20Analysis/KnownIssues.md#how-to-fill-out-a-known-issue-error-section).\r\n\r\n\u003c!-- Use ErrorMessage for String.Contains matches. Use ErrorPattern for regex matches (single line/no backtracking). Set BuildRetry to `true` to retry builds with this error. Set ExcludeConsoleLog to `true` to skip helix logs analysis. --\u003e\r\n\r\n```json\r\n{\r\n  \"ErrorMessage\": \"Task wasn\u0027t RunSynchronously with TaskScheduler specified\",\r\n  \"ErrorPattern\": \"\",\r\n  \"BuildRetry\": false,\r\n  \"ExcludeConsoleLog\": false\r\n}\r\n```\r\n\r\n\r\n\u003c!-- Known issue validation start --\u003e\r\n ### Known issue validation\r\n**Build: :mag_right:** https://dev.azure.com/dnceng-public/public/_build/results?buildId=465740\r\n**Error message validated:** `Task wasn\u0027t RunSynchronously with TaskScheduler specified`\r\n**Result validation: :white_check_mark:** Known issue matched with the provided build.\r\n**Validation performed at:** 11/13/2023 7:00:11 AM UTC\r\n\u003c!-- Known issue validation end --\u003e\r\n\u003c!--Known issue error report start --\u003e\r\n### Report\r\n\r\n|Build|Definition|Test|Pull Request|\r\n|---|---|---|---|\r\n|[565658](https://dev.azure.com/dnceng-public/public/_build/results?buildId=565658)|dotnet/runtime|[System.Threading.Tasks.Tests.TaskRunSyncTests.TaskRunSyncTest10](https://dev.azure.com/dnceng-public/public/_build/results?buildId=565658\u0026view=ms.vss-test-web.build-test-results-tab\u0026runId=13521140\u0026resultId=152220)|dotnet/runtime#98022|\r\n|[561688](https://dev.azure.com/dnceng-public/public/_build/results?buildId=561688)|dotnet/runtime|[System.Threading.Tasks.Tests.TaskRunSyncTests.TaskRunSyncTest10](https://dev.azure.com/dnceng-public/public/_build/results?buildId=561688\u0026view=ms.vss-test-web.build-test-results-tab\u0026runId=13407584\u0026resultId=119077)||\r\n|[560825](https://dev.azure.com/dnceng-public/public/_build/results?buildId=560825)|dotnet/runtime|[System.Threading.Tasks.Tests.TaskRunSyncTests.TaskRunSyncTest10](https://dev.azure.com/dnceng-public/public/_build/results?buildId=560825\u0026view=ms.vss-test-web.build-test-results-tab\u0026runId=13383080\u0026resultId=152800)||\r\n|[559095](https://dev.azure.com/dnceng-public/public/_build/results?buildId=559095)|dotnet/runtime|[System.Threading.Tasks.Tests.WorkItemExecution](https://dev.azure.com/dnceng-public/public/_build/results?buildId=559095\u0026view=ms.vss-test-web.build-test-results-tab\u0026runId=13333074\u0026resultId=164003)||\r\n|[552888](https://dev.azure.com/dnceng-public/public/_build/results?buildId=552888)|dotnet/runtime|[System.Threading.Tasks.Tests.TaskRunSyncTests.TaskRunSyncTest12](https://dev.azure.com/dnceng-public/public/_build/results?buildId=552888\u0026view=ms.vss-test-web.build-test-results-tab\u0026runId=13153722\u0026resultId=150897)||\r\n|[549969](https://dev.azure.com/dnceng-public/public/_build/results?buildId=549969)|dotnet/runtime|[System.Threading.Tasks.Tests.TaskRunSyncTests.TaskRunSyncTest10](https://dev.azure.com/dnceng-public/public/_build/results?buildId=549969\u0026view=ms.vss-test-web.build-test-results-tab\u0026runId=13070736\u0026resultId=151164)||\r\n#### Summary\r\n|24-Hour Hit Count|7-Day Hit Count|1-Month Count|\r\n|---|---|---|\r\n|0|0|6|\r\n\u003c!--Known issue error report end --\u003e",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOhbb4aw==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5rvU4n",
                                           "createdAt":  "2023-11-13T06:59:44Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @agocke, @MichalStrehovsky, @jkotas\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nSeen in Native AOT Alpine x64 test legs only so far.\r\n\r\n## Build Information\r\nBuild: https://dev.azure.com/dnceng-public/cbb18261-c48f-4abb-8651-8cdcb5474649/_build/results?buildId=465740\r\nBuild error leg or test failing: System.Threading.Tasks.Tests.TaskRunSyncTests.TaskRunSyncTest11\r\nPull request: https://github.com/dotnet/runtime/pull/94515\r\n\u003c!-- Error message template  --\u003e\r\n## Error Message\r\n\r\nFill the error message using [step by step known issues guidance](https://github.com/dotnet/arcade/blob/main/Documentation/Projects/Build%20Analysis/KnownIssues.md#how-to-fill-out-a-known-issue-error-section).\r\n\r\n\u003c!-- Use ErrorMessage for String.Contains matches. Use ErrorPattern for regex matches (single line/no backtracking). Set BuildRetry to `true` to retry builds with this error. Set ExcludeConsoleLog to `true` to skip helix logs analysis. --\u003e\r\n\r\n```json\r\n{\r\n  \"ErrorMessage\": \"Task wasn\u0027t RunSynchronously with TaskScheduler specified\",\r\n  \"ErrorPattern\": \"\",\r\n  \"BuildRetry\": false,\r\n  \"ExcludeConsoleLog\": false\r\n}\r\n```\r\n\r\n\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eMichalStrehovsky\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`blocking-clean-ci`, `area-NativeAOT-coreclr`, `Known Build Error`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-11-13T06:59:44Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc51VM-S",
                                           "createdAt":  "2024-02-28T08:44:22Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "MichalStrehovsky",
                                           "body":  "Disabling this test on musl in #99031.\r\n\r\nThis test has several different failure modes.",
                                           "updatedAt":  "2024-02-28T08:44:22Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5-QUuu",
                                           "createdAt":  "2024-05-17T18:56:13Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-threading-tasks\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2024-05-17T18:56:13Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6FtufK",
                                           "createdAt":  "2024-07-22T16:26:07Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ericstj",
                                           "body":  "It looks like the entirety of `System.Threading.Tasks.Tests.csproj` has been excluded from MUSL as part of this.  @stephentoub @dotnet/area-system-threading-tasks are you OK with that?",
                                           "updatedAt":  "2024-07-22T16:26:07Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6Ftvhr",
                                           "createdAt":  "2024-07-22T16:28:36Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "There\u0027s little-to-no logic in Tasks that\u0027s OS-specific. I\u0027ve not investigated the failure or the reason for it, but if it\u0027s disabled only on MUSL with NativeAOT, we have plenty of other validation in place such that I\u0027m not concerned for now.",
                                           "updatedAt":  "2024-07-22T16:28:36Z"
                                       }
                                   ],
                         "totalCount":  5
                     },
        "title":  "Task wasn\u0027t RunSynchronously with TaskScheduler specified",
        "labels":  [
                       "area-System.Threading.Tasks",
                       "disabled-test",
                       "os-linux-musl",
                       "needs-further-triage"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/96987",
        "createdAt":  "2024-01-15T13:50:50Z",
        "number":  96987,
        "author":  "Temp1ar",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2024-07-22T17:13:51Z",
        "body":  "\u003c!--This is just a template - feel free to delete any and all of it and replace as appropriate.--\u003e\r\n\r\n### Description\r\n\r\nSuppose I have a chain of multiple tasks. The first task allocates an array, lets say 10Mb of data and passes it to the next task in a chain.\r\nEvery next task allocates 10Mb of their own buffer, transforms the data from the previous stage into its own buffer and passes it further down the chain.\r\nI\u0027m having troubles with releasing the memory of intermediate stages.\r\n\r\nHere is a code to reproduce the issue (built in **Release mode**)\r\n```csharp\r\n#define ASYNC\r\n\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing System.Threading;\r\nusing System.Threading.Tasks;\r\n\r\nnamespace AsyncResourceReleaseCore\r\n{\r\n    internal class Program\r\n    {\r\n        private static WeakReference\u003cList\u003csbyte\u003e\u003e myRef;\r\n        \r\n#if ASYNC        \r\n        public static async Task Main(string[] args)\r\n        {\r\n            var result = CreateAsyncs();\r\n            await result;\r\n        }\r\n        \r\n        private static Task\u003cint\u003e CreateAsyncs()\r\n        {\r\n            var step1 = Step1Async();\r\n            var step2 = Step2Async(step1);\r\n            var step3 = Step3Async(step2);\r\n            return step3;\r\n        }\r\n        \r\n        static async Task\u003cList\u003csbyte\u003e\u003e Step1Async()\r\n        {\r\n            await Task.Delay(1);\r\n            var step1 = new List\u003csbyte\u003e(10 * 1024 * 1024);\r\n            myRef = new WeakReference\u003cList\u003csbyte\u003e\u003e(step1);\r\n            return step1;\r\n        }\r\n        \r\n        private static async Task\u003cList\u003cbyte\u003e\u003e Step2Async(Task\u003cList\u003csbyte\u003e\u003e step1)\r\n        {\r\n            await step1;\r\n            // Here we are transforming step1 result to step2 result\r\n            return new List\u003cbyte\u003e(10 * 1024 * 1024);\r\n        }\r\n        \r\n        private static async Task\u003cint\u003e Step3Async(Task\u003cList\u003cbyte\u003e\u003e step2)\r\n        {\r\n            await step2;\r\n            var step2Result = step2.Result;\r\n            Console.WriteLine(GC.GetTotalMemory(true));\r\n            Console.WriteLine(\"Reference is alive: \" + myRef.TryGetTarget(out List\u003csbyte\u003e _));\r\n            \r\n            // Point of interest is here\r\n            // Thread.Sleep(60000); // Uncomment to take a dump here\r\n            \r\n            return step2Result.Capacity;\r\n        }\r\n        \r\n#else // ASYNC is undefined\r\n        \r\n        public static void Main(string[] args)\r\n        {\r\n            var result = CreateTasks();\r\n            result.Wait();\r\n        }\r\n        \r\n        private static Task\u003cint\u003e CreateTasks()\r\n        {\r\n            var step1Task = Task.Delay(100).ContinueWith(_ =\u003e Step1Task());\r\n            var step2Task = step1Task.ContinueWith(step1Task_ =\u003e Step2Task(step1Task_.Result));\r\n            var step3Task = step2Task.ContinueWith(step2Task_ =\u003e Step3Task(step2Task_.Result));\r\n            return step3Task;\r\n        }\r\n        \r\n        static List\u003csbyte\u003e Step1Task()\r\n        {\r\n            var step1 = new List\u003csbyte\u003e(10 * 1024 * 1024);\r\n            myRef = new WeakReference\u003cList\u003csbyte\u003e\u003e(step1);\r\n            return step1;\r\n        }\r\n\r\n        private static List\u003cbyte\u003e Step2Task(List\u003csbyte\u003e step1TaskResult)\r\n        {\r\n            // Here we are transforming step1 result to step2 result\r\n            return new List\u003cbyte\u003e(step1TaskResult.Capacity);\r\n        }\r\n\r\n        private static int Step3Task(List\u003cbyte\u003e step2)\r\n        {\r\n            Console.WriteLine(GC.GetTotalMemory(true));\r\n            Console.WriteLine(\"Reference is alive: \" + myRef.TryGetTarget(out List\u003csbyte\u003e _));\r\n\r\n            // Point of interest is here\r\n            // Thread.Sleep(60000); // Uncomment to take a dump here\r\n            return step2.Capacity;\r\n        }\r\n#endif // ASYNC\r\n    }\r\n}\r\n```\r\n\r\nThe problem I\u0027m having is that at the point of interest in Step3Async there are active references to all the buffers of the previous stages.\r\nSo GC reports 20MB of memory used. However, results from the Step1Async are no longer have to be referenced. \r\n\r\n### Configuration\r\n\r\nThe issue is reproduced both on .NET Framework 4.7.2 and .NET 7.0, Release x64\r\n\r\nHW Info from an unrelated benchmark:\r\n```\r\n// Benchmark Process Environment Information:\r\n// BenchmarkDotNet v0.13.12\r\n// Runtime=.NET 8.0.0 (8.0.23.47906), X64 RyuJIT AVX-512F+CD+BW+DQ+VL+VBMI\r\n// GC=Concurrent Workstation\r\n// HardwareIntrinsics=AVX-512F+CD+BW+DQ+VL+VBMI,AES,BMI1,BMI2,FMA,LZCNT,PCLMUL,POPCNT VectorSize=256\r\n// Job: .NET 8.0\r\n\r\n...\r\n\r\nBenchmarkDotNet v0.13.12, Windows 11 (10.0.22621.3007/22H2/2022Update/SunValley2)\r\nAMD Ryzen 9 7950X, 1 CPU, 32 logical and 16 physical cores\r\n  [Host]               : .NET Framework 4.8.1 (4.8.9181.0), X64 RyuJIT VectorSize=256\r\n  .NET 8.0             : .NET 8.0.0 (8.0.23.47906), X64 RyuJIT AVX-512F+CD+BW+DQ+VL+VBMI\r\n  .NET Framework 4.7.2 : .NET Framework 4.8.1 (4.8.9181.0), X64 RyuJIT VectorSize=256\r\n```\r\n\r\n### Regression?\r\n\r\nNot a regression\r\n\r\n### Analysis\r\n\r\ndotMemory and WinDbg are showing that at the point of interest, we still have references to the Step1Async result via the following paths:\r\n```\r\n0:000\u003e !gcroot -all 0000022810009cc0\r\nThread 1363c:\r\n    000000e140bfeb90 00007ff900231372 AsyncResourceRelease.Program+\u003cStep2Async\u003ed__4.MoveNext() [C:\\work\\other\\AsyncResourceRelease\\Program.cs @ 50]\r\n        rbp-10: 000000e140bfebc0\r\n            -\u003e  0000022800007310 System.Threading.Tasks.Task`1[[System.Collections.Generic.List`1[[System.SByte, mscorlib]], mscorlib]]\r\n            -\u003e  000002280000a138 System.Collections.Generic.List`1[[System.SByte, mscorlib]]\r\n            -\u003e  0000022810009cc0 System.SByte[]\r\n\r\n    000000e140bfebe0 00007ff95ddbfbe8 System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object, Boolean)\r\n        r14: \r\n            -\u003e  0000022800009688 AsyncResourceRelease.Program+\u003cStep2Async\u003ed__4\r\n            -\u003e  0000022800007310 System.Threading.Tasks.Task`1[[System.Collections.Generic.List`1[[System.SByte, mscorlib]], mscorlib]]\r\n            -\u003e  000002280000a138 System.Collections.Generic.List`1[[System.SByte, mscorlib]]\r\n            -\u003e  0000022810009cc0 System.SByte[]\r\n\r\n    000000e140bfece0 00007ff95de1decf System.Runtime.CompilerServices.AsyncMethodBuilderCore+MoveNextRunner.Run()\r\n        rbp+10: 000000e140bfed30\r\n            -\u003e  00000228000095d8 System.Runtime.CompilerServices.AsyncMethodBuilderCore+MoveNextRunner\r\n            -\u003e  0000022800009688 AsyncResourceRelease.Program+\u003cStep2Async\u003ed__4\r\n            -\u003e  0000022800007310 System.Threading.Tasks.Task`1[[System.Collections.Generic.List`1[[System.SByte, mscorlib]], mscorlib]]\r\n            -\u003e  000002280000a138 System.Collections.Generic.List`1[[System.SByte, mscorlib]]\r\n            -\u003e  0000022810009cc0 System.SByte[]\r\n\r\n    000000e140bfed30 00007ff95de22d13 System.Threading.Tasks.AwaitTaskContinuation.RunOrScheduleAction(System.Action, Boolean, System.Threading.Tasks.Task ByRef)\r\n        rsi: \r\n            -\u003e  00000228000095f8 System.Action\r\n            -\u003e  00000228000095d8 System.Runtime.CompilerServices.AsyncMethodBuilderCore+MoveNextRunner\r\n            -\u003e  0000022800009688 AsyncResourceRelease.Program+\u003cStep2Async\u003ed__4\r\n            -\u003e  0000022800007310 System.Threading.Tasks.Task`1[[System.Collections.Generic.List`1[[System.SByte, mscorlib]], mscorlib]]\r\n            -\u003e  000002280000a138 System.Collections.Generic.List`1[[System.SByte, mscorlib]]\r\n            -\u003e  0000022810009cc0 System.SByte[]\r\n\r\n    000000e140bfed80 00007ff95dd9cb40 System.Threading.Tasks.Task.FinishContinuations()\r\n        rdi: \r\n            -\u003e  00000228000095f8 System.Action\r\n            -\u003e  00000228000095d8 System.Runtime.CompilerServices.AsyncMethodBuilderCore+MoveNextRunner\r\n            -\u003e  0000022800009688 AsyncResourceRelease.Program+\u003cStep2Async\u003ed__4\r\n            -\u003e  0000022800007310 System.Threading.Tasks.Task`1[[System.Collections.Generic.List`1[[System.SByte, mscorlib]], mscorlib]]\r\n            -\u003e  000002280000a138 System.Collections.Generic.List`1[[System.SByte, mscorlib]]\r\n            -\u003e  0000022810009cc0 System.SByte[]\r\n\r\n    000000e140bfed80 00007ff95dd9cb40 System.Threading.Tasks.Task.FinishContinuations()\r\n        rbp+10: 000000e140bfee10\r\n            -\u003e  0000022800007310 System.Threading.Tasks.Task`1[[System.Collections.Generic.List`1[[System.SByte, mscorlib]], mscorlib]]\r\n            -\u003e  000002280000a138 System.Collections.Generic.List`1[[System.SByte, mscorlib]]\r\n            -\u003e  0000022810009cc0 System.SByte[]\r\n\r\n    000000e140bfed80 00007ff95dd9cb40 System.Threading.Tasks.Task.FinishContinuations()\r\n        rbp-38: 000000e140bfedc8\r\n            -\u003e  00000228000095f8 System.Action\r\n            -\u003e  00000228000095d8 System.Runtime.CompilerServices.AsyncMethodBuilderCore+MoveNextRunner\r\n            -\u003e  0000022800009688 AsyncResourceRelease.Program+\u003cStep2Async\u003ed__4\r\n            -\u003e  0000022800007310 System.Threading.Tasks.Task`1[[System.Collections.Generic.List`1[[System.SByte, mscorlib]], mscorlib]]\r\n            -\u003e  000002280000a138 System.Collections.Generic.List`1[[System.SByte, mscorlib]]\r\n            -\u003e  0000022810009cc0 System.SByte[]\r\n\r\n    000000e140bfeef0 00007ff95ddbfbe8 System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object, Boolean)\r\n        r14: \r\n            -\u003e  0000022800007360 AsyncResourceRelease.Program+\u003cStep1Async\u003ed__3\r\n            -\u003e  0000022800007310 System.Threading.Tasks.Task`1[[System.Collections.Generic.List`1[[System.SByte, mscorlib]], mscorlib]]\r\n            -\u003e  000002280000a138 System.Collections.Generic.List`1[[System.SByte, mscorlib]]\r\n            -\u003e  0000022810009cc0 System.SByte[]\r\n\r\n    000000e140bfeff0 00007ff95de1decf System.Runtime.CompilerServices.AsyncMethodBuilderCore+MoveNextRunner.Run()\r\n        rbp+10: 000000e140bff040\r\n            -\u003e  00000228000072b0 System.Runtime.CompilerServices.AsyncMethodBuilderCore+MoveNextRunner\r\n            -\u003e  0000022800007360 AsyncResourceRelease.Program+\u003cStep1Async\u003ed__3\r\n            -\u003e  0000022800007310 System.Threading.Tasks.Task`1[[System.Collections.Generic.List`1[[System.SByte, mscorlib]], mscorlib]]\r\n            -\u003e  000002280000a138 System.Collections.Generic.List`1[[System.SByte, mscorlib]]\r\n            -\u003e  0000022810009cc0 System.SByte[]\r\n\r\n    000000e140bff040 00007ff95de22d13 System.Threading.Tasks.AwaitTaskContinuation.RunOrScheduleAction(System.Action, Boolean, System.Threading.Tasks.Task ByRef)\r\n        rsi: \r\n            -\u003e  00000228000072d0 System.Action\r\n            -\u003e  00000228000072b0 System.Runtime.CompilerServices.AsyncMethodBuilderCore+MoveNextRunner\r\n            -\u003e  0000022800007360 AsyncResourceRelease.Program+\u003cStep1Async\u003ed__3\r\n            -\u003e  0000022800007310 System.Threading.Tasks.Task`1[[System.Collections.Generic.List`1[[System.SByte, mscorlib]], mscorlib]]\r\n            -\u003e  000002280000a138 System.Collections.Generic.List`1[[System.SByte, mscorlib]]\r\n            -\u003e  0000022810009cc0 System.SByte[]\r\n\r\n    000000e140bff090 00007ff95dd9cb40 System.Threading.Tasks.Task.FinishContinuations()\r\n        rdi: \r\n            -\u003e  00000228000072d0 System.Action\r\n            -\u003e  00000228000072b0 System.Runtime.CompilerServices.AsyncMethodBuilderCore+MoveNextRunner\r\n            -\u003e  0000022800007360 AsyncResourceRelease.Program+\u003cStep1Async\u003ed__3\r\n            -\u003e  0000022800007310 System.Threading.Tasks.Task`1[[System.Collections.Generic.List`1[[System.SByte, mscorlib]], mscorlib]]\r\n            -\u003e  000002280000a138 System.Collections.Generic.List`1[[System.SByte, mscorlib]]\r\n            -\u003e  0000022810009cc0 System.SByte[]\r\n\r\n    000000e140bff090 00007ff95dd9cb40 System.Threading.Tasks.Task.FinishContinuations()\r\n        rbp-38: 000000e140bff0d8\r\n            -\u003e  00000228000072d0 System.Action\r\n            -\u003e  00000228000072b0 System.Runtime.CompilerServices.AsyncMethodBuilderCore+MoveNextRunner\r\n            -\u003e  0000022800007360 AsyncResourceRelease.Program+\u003cStep1Async\u003ed__3\r\n            -\u003e  0000022800007310 System.Threading.Tasks.Task`1[[System.Collections.Generic.List`1[[System.SByte, mscorlib]], mscorlib]]\r\n            -\u003e  000002280000a138 System.Collections.Generic.List`1[[System.SByte, mscorlib]]\r\n            -\u003e  0000022810009cc0 System.SByte[]\r\n\r\nFound 12 roots.\r\n```\r\n\r\nSo it looks like there are plenty of references held by the async/await state machine objects. Is there a way to change the code in some way to achieve releasing of the intermediate results?\r\nI can use Tasks API where I control all the closures (comment first define on line 1), and achieve the goal, but it requires rewriting the code and carefully isolating all the closures, which is cumbersome.\r\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOcNvI8Q==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5w0JhL",
                                           "createdAt":  "2024-01-15T20:11:47Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Clockwork-Muse",
                                           "body":  "\u003e I\u0027m having troubles with releasing the memory of intermediate stages.\r\n\r\nBecause you\u0027re not:\r\n\u003e```csharp\r\n\u003eprivate static Task\u003cint\u003e CreateAsyncs()\r\n\u003e{\r\n\u003e    var step1 = Step1Async();\r\n\u003e    var step2 = Step2Async(step1);\r\n\u003e    var step3 = Step3Async(step2);\r\n\u003e    return step3;\r\n\u003e}\r\n\u003e```\r\n\r\nAll three of the arrays are still a valid reference, because all three of the tasks that reference them are still valid references (and putting it inside a `WeakReference` doesn\u0027t change that, since you don\u0027t pass that anywhere, and that might go out of scope too early anyways).\r\n\r\nYou could try setting the references to `null`, but note that even if you do the GC isn\u0027t guaranteed to reclaim it \"immediately\".\r\n\r\nNote that `CreateAsync` itself should still be calling the steps with `await`, and should itself be called with `await` as well.\r\n\r\nThat said, what you really want to do is rearchitect things so that you don\u0027t manage the results, but rather just the connection between the steps.  There\u0027s a few different options here, including [`Channel`](https://learn.microsoft.com/en-us/dotnet/api/system.threading.channels.channel-1?view=net-8.0) and [Dataflow](https://learn.microsoft.com/en-us/dotnet/standard/parallel-programming/walkthrough-creating-a-dataflow-pipeline).  Note that instead of passing explicitly constructed arrays around, you almost certainly want to be using at least an [`ArrayPool`](https://learn.microsoft.com/en-us/dotnet/api/system.buffers.arraypool-1?view=net-8.0), or possibly [`MemoryManager`](https://learn.microsoft.com/en-us/dotnet/api/system.buffers.memorymanager-1?view=net-8.0) - however managing memory like this is more complicated, especially if you have multiple concurrent steps that need to read the same intermediate results.",
                                           "updatedAt":  "2024-01-15T20:11:47Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5w0X2j",
                                           "createdAt":  "2024-01-15T21:22:12Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-threading-tasks\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n\u003c!--This is just a template - feel free to delete any and all of it and replace as appropriate.--\u003e\r\n\r\n### Description\r\n\r\nSuppose I have a chain of multiple tasks. The first task allocates an array, lets say 10Mb of data and passes it to the next task in a chain.\r\nEvery next task allocates 10Mb of their own buffer, transforms the data from the previous stage into its own buffer and passes it further down the chain.\r\nI\u0027m having troubles with releasing the memory of intermediate stages.\r\n\r\nHere is a code to reproduce the issue (built in **Release mode**)\r\n```csharp\r\n#define ASYNC\r\n\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing System.Threading;\r\nusing System.Threading.Tasks;\r\n\r\nnamespace AsyncResourceReleaseCore\r\n{\r\n    internal class Program\r\n    {\r\n        private static WeakReference\u003cList\u003csbyte\u003e\u003e myRef;\r\n        \r\n#if ASYNC        \r\n        public static async Task Main(string[] args)\r\n        {\r\n            var result = CreateAsyncs();\r\n            await result;\r\n        }\r\n        \r\n        private static Task\u003cint\u003e CreateAsyncs()\r\n        {\r\n            var step1 = Step1Async();\r\n            var step2 = Step2Async(step1);\r\n            var step3 = Step3Async(step2);\r\n            return step3;\r\n        }\r\n        \r\n        static async Task\u003cList\u003csbyte\u003e\u003e Step1Async()\r\n        {\r\n            await Task.Delay(1);\r\n            var step1 = new List\u003csbyte\u003e(10 * 1024 * 1024);\r\n            myRef = new WeakReference\u003cList\u003csbyte\u003e\u003e(step1);\r\n            return step1;\r\n        }\r\n        \r\n        private static async Task\u003cList\u003cbyte\u003e\u003e Step2Async(Task\u003cList\u003csbyte\u003e\u003e step1)\r\n        {\r\n            await step1;\r\n            // Here we are transforming step1 result to step2 result\r\n            return new List\u003cbyte\u003e(10 * 1024 * 1024);\r\n        }\r\n        \r\n        private static async Task\u003cint\u003e Step3Async(Task\u003cList\u003cbyte\u003e\u003e step2)\r\n        {\r\n            await step2;\r\n            var step2Result = step2.Result;\r\n            Console.WriteLine(GC.GetTotalMemory(true));\r\n            Console.WriteLine(\"Reference is alive: \" + myRef.TryGetTarget(out List\u003csbyte\u003e _));\r\n            \r\n            // Point of interest is here\r\n            // Thread.Sleep(60000); // Uncomment to take a dump here\r\n            \r\n            return step2Result.Capacity;\r\n        }\r\n        \r\n#else // ASYNC is undefined\r\n        \r\n        public static void Main(string[] args)\r\n        {\r\n            var result = CreateTasks();\r\n            result.Wait();\r\n        }\r\n        \r\n        private static Task\u003cint\u003e CreateTasks()\r\n        {\r\n            var step1Task = Task.Delay(100).ContinueWith(_ =\u003e Step1Task());\r\n            var step2Task = step1Task.ContinueWith(step1Task_ =\u003e Step2Task(step1Task_.Result));\r\n            var step3Task = step2Task.ContinueWith(step2Task_ =\u003e Step3Task(step2Task_.Result));\r\n            return step3Task;\r\n        }\r\n        \r\n        static List\u003csbyte\u003e Step1Task()\r\n        {\r\n            var step1 = new List\u003csbyte\u003e(10 * 1024 * 1024);\r\n            myRef = new WeakReference\u003cList\u003csbyte\u003e\u003e(step1);\r\n            return step1;\r\n        }\r\n\r\n        private static List\u003cbyte\u003e Step2Task(List\u003csbyte\u003e step1TaskResult)\r\n        {\r\n            // Here we are transforming step1 result to step2 result\r\n            return new List\u003cbyte\u003e(step1TaskResult.Capacity);\r\n        }\r\n\r\n        private static int Step3Task(List\u003cbyte\u003e step2)\r\n        {\r\n            Console.WriteLine(GC.GetTotalMemory(true));\r\n            Console.WriteLine(\"Reference is alive: \" + myRef.TryGetTarget(out List\u003csbyte\u003e _));\r\n\r\n            // Point of interest is here\r\n            // Thread.Sleep(60000); // Uncomment to take a dump here\r\n            return step2.Capacity;\r\n        }\r\n#endif // ASYNC\r\n    }\r\n}\r\n```\r\n\r\nThe problem I\u0027m having is that at the point of interest in Step3Async there are active references to all the buffers of the previous stages.\r\nSo GC reports 20MB of memory used. However, results from the Step1Async are no longer have to be referenced. \r\n\r\n### Configuration\r\n\r\nThe issue is reproduced both on .NET Framework 4.7.2 and .NET 7.0, Release x64\r\n\r\nHW Info from an unrelated benchmark:\r\n```\r\n// Benchmark Process Environment Information:\r\n// BenchmarkDotNet v0.13.12\r\n// Runtime=.NET 8.0.0 (8.0.23.47906), X64 RyuJIT AVX-512F+CD+BW+DQ+VL+VBMI\r\n// GC=Concurrent Workstation\r\n// HardwareIntrinsics=AVX-512F+CD+BW+DQ+VL+VBMI,AES,BMI1,BMI2,FMA,LZCNT,PCLMUL,POPCNT VectorSize=256\r\n// Job: .NET 8.0\r\n\r\n...\r\n\r\nBenchmarkDotNet v0.13.12, Windows 11 (10.0.22621.3007/22H2/2022Update/SunValley2)\r\nAMD Ryzen 9 7950X, 1 CPU, 32 logical and 16 physical cores\r\n  [Host]               : .NET Framework 4.8.1 (4.8.9181.0), X64 RyuJIT VectorSize=256\r\n  .NET 8.0             : .NET 8.0.0 (8.0.23.47906), X64 RyuJIT AVX-512F+CD+BW+DQ+VL+VBMI\r\n  .NET Framework 4.7.2 : .NET Framework 4.8.1 (4.8.9181.0), X64 RyuJIT VectorSize=256\r\n```\r\n\r\n### Regression?\r\n\r\nNot a regression\r\n\r\n### Analysis\r\n\r\ndotMemory and WinDbg are showing that at the point of interest, we still have references to the Step1Async result via the following paths:\r\n```\r\n0:000\u003e !gcroot -all 0000022810009cc0\r\nThread 1363c:\r\n    000000e140bfeb90 00007ff900231372 AsyncResourceRelease.Program+\u003cStep2Async\u003ed__4.MoveNext() [C:\\work\\other\\AsyncResourceRelease\\Program.cs @ 50]\r\n        rbp-10: 000000e140bfebc0\r\n            -\u003e  0000022800007310 System.Threading.Tasks.Task`1[[System.Collections.Generic.List`1[[System.SByte, mscorlib]], mscorlib]]\r\n            -\u003e  000002280000a138 System.Collections.Generic.List`1[[System.SByte, mscorlib]]\r\n            -\u003e  0000022810009cc0 System.SByte[]\r\n\r\n    000000e140bfebe0 00007ff95ddbfbe8 System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object, Boolean)\r\n        r14: \r\n            -\u003e  0000022800009688 AsyncResourceRelease.Program+\u003cStep2Async\u003ed__4\r\n            -\u003e  0000022800007310 System.Threading.Tasks.Task`1[[System.Collections.Generic.List`1[[System.SByte, mscorlib]], mscorlib]]\r\n            -\u003e  000002280000a138 System.Collections.Generic.List`1[[System.SByte, mscorlib]]\r\n            -\u003e  0000022810009cc0 System.SByte[]\r\n\r\n    000000e140bfece0 00007ff95de1decf System.Runtime.CompilerServices.AsyncMethodBuilderCore+MoveNextRunner.Run()\r\n        rbp+10: 000000e140bfed30\r\n            -\u003e  00000228000095d8 System.Runtime.CompilerServices.AsyncMethodBuilderCore+MoveNextRunner\r\n            -\u003e  0000022800009688 AsyncResourceRelease.Program+\u003cStep2Async\u003ed__4\r\n            -\u003e  0000022800007310 System.Threading.Tasks.Task`1[[System.Collections.Generic.List`1[[System.SByte, mscorlib]], mscorlib]]\r\n            -\u003e  000002280000a138 System.Collections.Generic.List`1[[System.SByte, mscorlib]]\r\n            -\u003e  0000022810009cc0 System.SByte[]\r\n\r\n    000000e140bfed30 00007ff95de22d13 System.Threading.Tasks.AwaitTaskContinuation.RunOrScheduleAction(System.Action, Boolean, System.Threading.Tasks.Task ByRef)\r\n        rsi: \r\n            -\u003e  00000228000095f8 System.Action\r\n            -\u003e  00000228000095d8 System.Runtime.CompilerServices.AsyncMethodBuilderCore+MoveNextRunner\r\n            -\u003e  0000022800009688 AsyncResourceRelease.Program+\u003cStep2Async\u003ed__4\r\n            -\u003e  0000022800007310 System.Threading.Tasks.Task`1[[System.Collections.Generic.List`1[[System.SByte, mscorlib]], mscorlib]]\r\n            -\u003e  000002280000a138 System.Collections.Generic.List`1[[System.SByte, mscorlib]]\r\n            -\u003e  0000022810009cc0 System.SByte[]\r\n\r\n    000000e140bfed80 00007ff95dd9cb40 System.Threading.Tasks.Task.FinishContinuations()\r\n        rdi: \r\n            -\u003e  00000228000095f8 System.Action\r\n            -\u003e  00000228000095d8 System.Runtime.CompilerServices.AsyncMethodBuilderCore+MoveNextRunner\r\n            -\u003e  0000022800009688 AsyncResourceRelease.Program+\u003cStep2Async\u003ed__4\r\n            -\u003e  0000022800007310 System.Threading.Tasks.Task`1[[System.Collections.Generic.List`1[[System.SByte, mscorlib]], mscorlib]]\r\n            -\u003e  000002280000a138 System.Collections.Generic.List`1[[System.SByte, mscorlib]]\r\n            -\u003e  0000022810009cc0 System.SByte[]\r\n\r\n    000000e140bfed80 00007ff95dd9cb40 System.Threading.Tasks.Task.FinishContinuations()\r\n        rbp+10: 000000e140bfee10\r\n            -\u003e  0000022800007310 System.Threading.Tasks.Task`1[[System.Collections.Generic.List`1[[System.SByte, mscorlib]], mscorlib]]\r\n            -\u003e  000002280000a138 System.Collections.Generic.List`1[[System.SByte, mscorlib]]\r\n            -\u003e  0000022810009cc0 System.SByte[]\r\n\r\n    000000e140bfed80 00007ff95dd9cb40 System.Threading.Tasks.Task.FinishContinuations()\r\n        rbp-38: 000000e140bfedc8\r\n            -\u003e  00000228000095f8 System.Action\r\n            -\u003e  00000228000095d8 System.Runtime.CompilerServices.AsyncMethodBuilderCore+MoveNextRunner\r\n            -\u003e  0000022800009688 AsyncResourceRelease.Program+\u003cStep2Async\u003ed__4\r\n            -\u003e  0000022800007310 System.Threading.Tasks.Task`1[[System.Collections.Generic.List`1[[System.SByte, mscorlib]], mscorlib]]\r\n            -\u003e  000002280000a138 System.Collections.Generic.List`1[[System.SByte, mscorlib]]\r\n            -\u003e  0000022810009cc0 System.SByte[]\r\n\r\n    000000e140bfeef0 00007ff95ddbfbe8 System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object, Boolean)\r\n        r14: \r\n            -\u003e  0000022800007360 AsyncResourceRelease.Program+\u003cStep1Async\u003ed__3\r\n            -\u003e  0000022800007310 System.Threading.Tasks.Task`1[[System.Collections.Generic.List`1[[System.SByte, mscorlib]], mscorlib]]\r\n            -\u003e  000002280000a138 System.Collections.Generic.List`1[[System.SByte, mscorlib]]\r\n            -\u003e  0000022810009cc0 System.SByte[]\r\n\r\n    000000e140bfeff0 00007ff95de1decf System.Runtime.CompilerServices.AsyncMethodBuilderCore+MoveNextRunner.Run()\r\n        rbp+10: 000000e140bff040\r\n            -\u003e  00000228000072b0 System.Runtime.CompilerServices.AsyncMethodBuilderCore+MoveNextRunner\r\n            -\u003e  0000022800007360 AsyncResourceRelease.Program+\u003cStep1Async\u003ed__3\r\n            -\u003e  0000022800007310 System.Threading.Tasks.Task`1[[System.Collections.Generic.List`1[[System.SByte, mscorlib]], mscorlib]]\r\n            -\u003e  000002280000a138 System.Collections.Generic.List`1[[System.SByte, mscorlib]]\r\n            -\u003e  0000022810009cc0 System.SByte[]\r\n\r\n    000000e140bff040 00007ff95de22d13 System.Threading.Tasks.AwaitTaskContinuation.RunOrScheduleAction(System.Action, Boolean, System.Threading.Tasks.Task ByRef)\r\n        rsi: \r\n            -\u003e  00000228000072d0 System.Action\r\n            -\u003e  00000228000072b0 System.Runtime.CompilerServices.AsyncMethodBuilderCore+MoveNextRunner\r\n            -\u003e  0000022800007360 AsyncResourceRelease.Program+\u003cStep1Async\u003ed__3\r\n            -\u003e  0000022800007310 System.Threading.Tasks.Task`1[[System.Collections.Generic.List`1[[System.SByte, mscorlib]], mscorlib]]\r\n            -\u003e  000002280000a138 System.Collections.Generic.List`1[[System.SByte, mscorlib]]\r\n            -\u003e  0000022810009cc0 System.SByte[]\r\n\r\n    000000e140bff090 00007ff95dd9cb40 System.Threading.Tasks.Task.FinishContinuations()\r\n        rdi: \r\n            -\u003e  00000228000072d0 System.Action\r\n            -\u003e  00000228000072b0 System.Runtime.CompilerServices.AsyncMethodBuilderCore+MoveNextRunner\r\n            -\u003e  0000022800007360 AsyncResourceRelease.Program+\u003cStep1Async\u003ed__3\r\n            -\u003e  0000022800007310 System.Threading.Tasks.Task`1[[System.Collections.Generic.List`1[[System.SByte, mscorlib]], mscorlib]]\r\n            -\u003e  000002280000a138 System.Collections.Generic.List`1[[System.SByte, mscorlib]]\r\n            -\u003e  0000022810009cc0 System.SByte[]\r\n\r\n    000000e140bff090 00007ff95dd9cb40 System.Threading.Tasks.Task.FinishContinuations()\r\n        rbp-38: 000000e140bff0d8\r\n            -\u003e  00000228000072d0 System.Action\r\n            -\u003e  00000228000072b0 System.Runtime.CompilerServices.AsyncMethodBuilderCore+MoveNextRunner\r\n            -\u003e  0000022800007360 AsyncResourceRelease.Program+\u003cStep1Async\u003ed__3\r\n            -\u003e  0000022800007310 System.Threading.Tasks.Task`1[[System.Collections.Generic.List`1[[System.SByte, mscorlib]], mscorlib]]\r\n            -\u003e  000002280000a138 System.Collections.Generic.List`1[[System.SByte, mscorlib]]\r\n            -\u003e  0000022810009cc0 System.SByte[]\r\n\r\nFound 12 roots.\r\n```\r\n\r\nSo it looks like there are plenty of references held by the async/await state machine objects. Is there a way to change the code in some way to achieve releasing of the intermediate results?\r\nI can use Tasks API where I control all the closures (comment first define on line 1), and achieve the goal, but it requires rewriting the code and carefully isolating all the closures, which is cumbersome.\r\n\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eTemp1ar\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Threading.Tasks`, `tenet-performance`, `untriaged`, `needs-area-label`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2024-01-15T21:22:12Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5w28jx",
                                           "createdAt":  "2024-01-16T10:20:40Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Temp1ar",
                                           "body":  "\u003e All three of the arrays are still a valid reference, because all three of the tasks that reference them are still valid references (and putting it inside a WeakReference doesn\u0027t change that, since you don\u0027t pass that anywhere, and that might go out of scope too early anyways).\r\n\u003e \r\n\u003e You could try setting the references to null, but note that even if you do the GC isn\u0027t guaranteed to reclaim it \"immediately\".\r\n\r\nThe whole CreateAsyncs() call frame with local variables goes out from the stack before Step1Async continuation is executed. Note that all steps are doing `await` as the first thing, therefore, they return immediately. So the locals `step1`, `step2`  can\u0027t hold any memory.\r\n\r\n\u003e That said, what you really want to do is rearchitect things so that you don\u0027t manage the results, but rather just the connection between the steps. There\u0027s a few different options here, including [Channel](https://learn.microsoft.com/en-us/dotnet/api/system.threading.channels.channel-1?view=net-8.0) and [Dataflow](https://learn.microsoft.com/en-us/dotnet/standard/parallel-programming/walkthrough-creating-a-dataflow-pipeline). \r\n\r\nThanks, I\u0027m gonna look into that. However, I\u0027d like to understand what\u0027s going on with a simple async/await call chain. Maybe it is a bug, that should be addressed.",
                                           "updatedAt":  "2024-01-16T10:20:40Z"
                                       }
                                   ],
                         "totalCount":  3
                     },
        "title":  "Async/await tasks hold references to the intermediate results ",
        "labels":  [
                       "area-System.Threading.Tasks",
                       "tenet-performance",
                       "needs-further-triage"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/99153",
        "createdAt":  "2024-03-01T10:06:59Z",
        "number":  99153,
        "author":  "mrpmorris",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2024-07-19T16:15:18Z",
        "body":  "### Background and motivation\r\n\r\nThis is based on my own misunderstanding of `AsyncLocal\u003cT\u003e`.\r\n\r\nI was expecting `AsyncLocal\u003cT\u003e` to be a single piece of state that is passed across all classes/methods operating on the same async scope (e.g. a web request all the way down and back up again). This assumption was based on how `ThreadLocal\u003cT\u003e` works - I assumed `AsyncLocal\u003cT\u003e` was an equivalent for `async` code.\r\n\r\nI was using this to add a collection of events in my domain classes that propagate upwards to my web request handler to be recorded in the database. I have now come to understand that the value is cascaded down, but not upwards.\r\n\r\nSo if something down the call chain is the first to access my `ThreadLocal\u003cList\u003cFunc\u003cobject\u003e\u003e\u003e` then the value will never make its way back up to the initiator so it can receive the values added and store them in the database.\r\n\r\nA workaround is to ensure the `TheadLocal\u003cT\u003e.Value` is accessed early on in the request - but as this is a library this is not something I can ensure, and a default `null` value means \"No data was added\" so I can\u0027t guard against `null`.\r\n\r\n#### Example of incorrect assumption\r\n```csharp\r\nSomeClass.Sequence = \u0027A\u0027;\r\nawait SetSecondValueAsync();\r\nConsole.WriteLine($\"Step 5={SomeClass.Sequence}\");\r\n\r\nstatic async Task SetSecondValueAsync()\r\n{\r\n    Console.WriteLine($\"Step 1={SomeClass.Sequence}\");\r\n    SomeClass.Sequence = \u0027B\u0027;\r\n    await SetThirdValueAsync();\r\n    Console.WriteLine($\"Step 4={SomeClass.Sequence}\");\r\n}\r\n\r\nstatic Task SetThirdValueAsync()\r\n{\r\n    Console.WriteLine($\"Step 2={SomeClass.Sequence}\");\r\n    SomeClass.Sequence = \u0027C\u0027;\r\n    Console.WriteLine($\"Step 3={SomeClass.Sequence}\");\r\n    return Task.CompletedTask;\r\n}\r\n\r\npublic static class SomeClass\r\n{\r\n#if UseAsyncLocal\r\n    private static readonly AsyncLocal\u003cchar\u003e SequenceHolder = new();\r\n#else\r\n    private static readonly ThreadLocal\u003cchar\u003e SequenceHolder = new();\r\n#endif\r\n    public static char Sequence\r\n    {\r\n        get =\u003e SequenceHolder.Value; set =\u003e SequenceHolder.Value = value;\r\n    }\r\n}\r\n```\r\n\r\n`ThreadLocal\u003cT\u003e` output\r\n- Step 1=A\r\n- Step 2=B\r\n- Step 3=C\r\n- Step 4=C\r\n- Step 5=C\r\n\r\n`AsyncLocal\u003cT\u003e` output\r\n- Step 1=A\r\n- Step 2=B\r\n- Step 3=C\r\n- Step 4=C\r\n- Step 5=A\r\n\r\n### API Proposal\r\n\r\n```csharp\r\npublic class AsyncLocal\u003cT\u003e\r\n{\r\n  public AsyncLocal(bool propagateUpwards = false)\r\n  {\r\n    ....\r\n  }\r\n  public AsyncLocal(Action\u003cAsyncLocalValueChangedArgs\u003cT\u003e\u003e? valueChangedHandler, bool propagateUpwards = false)\r\n  {\r\n    ...\r\n  }\r\n  // other code\r\n```\r\n\r\n### API Usage\r\n\r\n```csharp\r\n// My static DomainEvents class, using `propagateUpwards = `true`\r\npublic static class DomainEvents\r\n{\r\n  private static readonly AsyncLocal\u003cList\u003cFunc\u003cobject\u003e\u003e Holder = new(propagateUpwards: true);\r\n\r\n  public static void Add(Func\u003cobject\u003e factory)\r\n  {\r\n    if (Holder.Value is null)\r\n      Holder.Value = new List\u003cFunc\u003cobject\u003e\u003e();\r\n    Holder.Value.Add(factory);\r\n  }\r\n\r\n  public static void GetEventAndClear(out Func\u003cobject\u003e[] eventFactories)\r\n  {\r\n    eventFactories = Holder.Value?.ToArray() ?? [];\r\n    Holder.Value.Clear();\r\n  }\r\n}\r\n\r\n// Some code executed from a web request\r\npublic async Task EntryPoint()\r\n{\r\n  await HandleAsync();\r\n  DomainEvents.GetAndClear(out Func\u003cobject\u003e[] eventFactories);\r\n  DbContext.DomainEvents.AddRange(eventFactories.Select(factory =\u003e factory.Invoke());\r\n  await DbContext.SaveChangesAsync();\r\n}\r\n\r\nprivate async Task HandleAsync()\r\n{\r\n  Customer customer = await DbContext.Customers.FirstAsync();\r\n  customer.Deactivate();\r\n}\r\n\r\n// Code in the Customer entity\r\npublic void Deactivate()\r\n{\r\n  Customer.Status = CustomerStatus.Deactivated\r\n  DomainEvents.Add(() =\u003e new CustomerDeactivatedEvent());\r\n}\r\n```\r\n\r\n\r\n### Alternative Designs\r\n\r\nAnother possibility would be to create an alternative class named something like `AsyncStatic\u003cT\u003e` that works in the same way as `ThreadStatic\u003cT\u003e` but across async calls.\r\n\r\n### Risks\r\n\r\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOemlxFw==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc51l_k-",
                                           "createdAt":  "2024-03-01T10:07:06Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Background and motivation\n\nThis is based on my own misunderstanding of `AsyncLocal\u003cT\u003e`.\r\n\r\nI was expecting `AsyncLocal\u003cT\u003e` to be a single piece of state that is passed across all classes/methods operating on the same async scope (e.g. a web request all the way down and back up again). This assumption was based on how `ThreadLocal\u003cT\u003e` works - I assumed `AsyncLocal\u003cT\u003e` was an equivalent for `async` code.\r\n\r\nI was using this to add a collection of events in my domain classes that propagate upwards to my web request handler to be recorded in the database. I have now come to understand that the value is cascaded down, but not upwards.\r\n\r\nSo if something down the call chain is the first to access my `ThreadLocal\u003cList\u003cFunc\u003cobject\u003e\u003e\u003e` then the value will never make its way back up to the initiator so it can receive the values added and store them in the database.\r\n\r\nA workaround is to ensure the `TheadLocal\u003cT\u003e.Value` is accessed early on in the request - but as this is a library this is not something I can ensure, and a default `null` value means \"No data was added\" so I can\u0027t guard against `null`.\n\n### API Proposal\n\n```csharp\r\npublic class AsyncLocal\u003cT\u003e\r\n{\r\n  public AsyncLocal(bool propagateUpwards = false)\r\n  {\r\n    ....\r\n  }\r\n  public AsyncLocal(Action\u003cAsyncLocalValueChangedArgs\u003cT\u003e\u003e? valueChangedHandler, bool propagateUpwards = false)\r\n  {\r\n    ...\r\n  }\r\n  // other code\r\n```\n\n### API Usage\n\n```csharp\r\n// My static DomainEvents class, using `propagateUpwards = `true`\r\npublic static class DomainEvents\r\n{\r\n  private static readonly AsyncLocal\u003cList\u003cFunc\u003cobject\u003e\u003e Holder = new(propagateUpwards: true);\r\n\r\n  public static void Add(Func\u003cobject\u003e factory)\r\n  {\r\n    if (Holder.Value is null)\r\n      Holder.Value = new List\u003cFunc\u003cobject\u003e\u003e();\r\n    Holder.Value.Add(factory);\r\n  }\r\n\r\n  public static void GetEventAndClear(out Func\u003cobject\u003e[] eventFactories)\r\n  {\r\n    eventFactories = Holder.Value?.ToArray() ?? [];\r\n    Holder.Value.Clear();\r\n  }\r\n}\r\n\r\n// Some code executed from a web request\r\npublic async Task EntryPoint()\r\n{\r\n  await HandleAsync();\r\n  DomainEvents.GetAndClear(out Func\u003cobject\u003e[] eventFactories);\r\n  DbContext.DomainEvents.AddRange(eventFactories.Select(factory =\u003e factory.Invoke());\r\n  await DbContext.SaveChangesAsync();\r\n}\r\n\r\nprivate async Task HandleAsync()\r\n{\r\n  Customer customer = await DbContext.Customers.FirstAsync();\r\n  customer.Deactivate();\r\n}\r\n\r\n// Code in the Customer entity\r\npublic void Deactivate()\r\n{\r\n  Customer.Status = CustomerStatus.Deactivated\r\n  DomainEvents.Add(() =\u003e new CustomerDeactivatedEvent());\r\n}\r\n```\r\n\n\n### Alternative Designs\n\nAnother possibility would be to create an alternative class named something like `BiDirectionalAsyncLocal\u003cT\u003e`.\n\n### Risks\n\n_No response_\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003emrpmorris\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`api-suggestion`, `area-System.Threading`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2024-03-01T10:07:06Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc51ngFt",
                                           "createdAt":  "2024-03-01T14:20:11Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-threading-tasks\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Background and motivation\r\n\r\nThis is based on my own misunderstanding of `AsyncLocal\u003cT\u003e`.\r\n\r\nI was expecting `AsyncLocal\u003cT\u003e` to be a single piece of state that is passed across all classes/methods operating on the same async scope (e.g. a web request all the way down and back up again). This assumption was based on how `ThreadLocal\u003cT\u003e` works - I assumed `AsyncLocal\u003cT\u003e` was an equivalent for `async` code.\r\n\r\nI was using this to add a collection of events in my domain classes that propagate upwards to my web request handler to be recorded in the database. I have now come to understand that the value is cascaded down, but not upwards.\r\n\r\nSo if something down the call chain is the first to access my `ThreadLocal\u003cList\u003cFunc\u003cobject\u003e\u003e\u003e` then the value will never make its way back up to the initiator so it can receive the values added and store them in the database.\r\n\r\nA workaround is to ensure the `TheadLocal\u003cT\u003e.Value` is accessed early on in the request - but as this is a library this is not something I can ensure, and a default `null` value means \"No data was added\" so I can\u0027t guard against `null`.\r\n\r\n#### Example of incorrect assumption\r\n```csharp\r\nSomeClass.Sequence = \u0027A\u0027;\r\nawait SetSecondValueAsync();\r\nConsole.WriteLine($\"Step 5={SomeClass.Sequence}\");\r\n\r\nstatic async Task SetSecondValueAsync()\r\n{\r\n    Console.WriteLine($\"Step 1={SomeClass.Sequence}\");\r\n    SomeClass.Sequence = \u0027B\u0027;\r\n    await SetThirdValueAsync();\r\n    Console.WriteLine($\"Step 4={SomeClass.Sequence}\");\r\n}\r\n\r\nstatic Task SetThirdValueAsync()\r\n{\r\n    Console.WriteLine($\"Step 2={SomeClass.Sequence}\");\r\n    SomeClass.Sequence = \u0027C\u0027;\r\n    Console.WriteLine($\"Step 3={SomeClass.Sequence}\");\r\n    return Task.CompletedTask;\r\n}\r\n\r\npublic static class SomeClass\r\n{\r\n#if UseAsyncLocal\r\n    private static readonly AsyncLocal\u003cchar\u003e SequenceHolder = new();\r\n#else\r\n    private static readonly ThreadLocal\u003cchar\u003e SequenceHolder = new();\r\n#endif\r\n    public static char Sequence\r\n    {\r\n        get =\u003e SequenceHolder.Value; set =\u003e SequenceHolder.Value = value;\r\n    }\r\n}\r\n```\r\n\r\n`ThreadLocal\u003cT\u003e` output\r\n- Step 1=A\r\n- Step 2=B\r\n- Step 3=C\r\n- Step 4=C\r\n- Step 5=C\r\n\r\n`AsyncLocal\u003cT\u003e` output\r\n- Step 1=A\r\n- Step 2=B\r\n- Step 3=C\r\n- Step 4=C\r\n- Step 5=A\r\n\r\n### API Proposal\r\n\r\n```csharp\r\npublic class AsyncLocal\u003cT\u003e\r\n{\r\n  public AsyncLocal(bool propagateUpwards = false)\r\n  {\r\n    ....\r\n  }\r\n  public AsyncLocal(Action\u003cAsyncLocalValueChangedArgs\u003cT\u003e\u003e? valueChangedHandler, bool propagateUpwards = false)\r\n  {\r\n    ...\r\n  }\r\n  // other code\r\n```\r\n\r\n### API Usage\r\n\r\n```csharp\r\n// My static DomainEvents class, using `propagateUpwards = `true`\r\npublic static class DomainEvents\r\n{\r\n  private static readonly AsyncLocal\u003cList\u003cFunc\u003cobject\u003e\u003e Holder = new(propagateUpwards: true);\r\n\r\n  public static void Add(Func\u003cobject\u003e factory)\r\n  {\r\n    if (Holder.Value is null)\r\n      Holder.Value = new List\u003cFunc\u003cobject\u003e\u003e();\r\n    Holder.Value.Add(factory);\r\n  }\r\n\r\n  public static void GetEventAndClear(out Func\u003cobject\u003e[] eventFactories)\r\n  {\r\n    eventFactories = Holder.Value?.ToArray() ?? [];\r\n    Holder.Value.Clear();\r\n  }\r\n}\r\n\r\n// Some code executed from a web request\r\npublic async Task EntryPoint()\r\n{\r\n  await HandleAsync();\r\n  DomainEvents.GetAndClear(out Func\u003cobject\u003e[] eventFactories);\r\n  DbContext.DomainEvents.AddRange(eventFactories.Select(factory =\u003e factory.Invoke());\r\n  await DbContext.SaveChangesAsync();\r\n}\r\n\r\nprivate async Task HandleAsync()\r\n{\r\n  Customer customer = await DbContext.Customers.FirstAsync();\r\n  customer.Deactivate();\r\n}\r\n\r\n// Code in the Customer entity\r\npublic void Deactivate()\r\n{\r\n  Customer.Status = CustomerStatus.Deactivated\r\n  DomainEvents.Add(() =\u003e new CustomerDeactivatedEvent());\r\n}\r\n```\r\n\r\n\r\n### Alternative Designs\r\n\r\nAnother possibility would be to create an alternative class named something like `BiDirectionalAsyncLocal\u003cT\u003e`.\r\n\r\n### Risks\r\n\r\n_No response_\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003emrpmorris\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`api-suggestion`, `area-System.Threading`, `area-System.Threading.Tasks`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2024-03-01T14:20:11Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc51pVUR",
                                           "createdAt":  "2024-03-01T19:10:52Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "KalleOlaviNiemitalo",
                                           "body":  "@mrpmorris perhaps [Microsoft.Extensions.AsyncState](https://www.nuget.org/packages/Microsoft.Extensions.AsyncState) and [Microsoft.AspNetCore.AsyncState](https://www.nuget.org/packages/Microsoft.AspNetCore.AsyncState) are more suitable for your scenario.  These let you propagate values out of async functions, with storage either set up explicitly or  tied to the incoming HTTP request.",
                                           "updatedAt":  "2024-03-01T19:10:52Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc51rXsZ",
                                           "createdAt":  "2024-03-02T05:04:33Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "KalleOlaviNiemitalo",
                                           "body":  "Re `bool propagateUpwards`, it\u0027s not clear how it should work in this kind of code\n\n```csharp\nclass C {\n    AsyncLocal\u003cint\u003e al = new AsyncLocal\u003cint\u003e(propagateUpwards: true);\n    AsyncLocal\u003cint\u003e al2 = new AsyncLocal\u003cint\u003e(propagateUpwards: true);\n\n    async Task\u003cint\u003e Inner1() {\n        al.Value = 10;\n        await Task.Yield();\n        al.Value = 11;\n        return 12;\n    }\n\n    async Task\u003cint\u003e Inner2() {\n        al.Value = 20;\n        await Task.Yield();\n        al.Value = 21;\n        return 22;\n    }\n\n    async Task Outer() {\n        al.Value = 1;\n        al2.Value = 101;\n        Task\u003cint\u003e t1 = Inner1();\n        Console.WriteLine(al.Value); // 1 or 10?\n\n        al.Value = 2;\n        Task\u003cint\u003e t2 = Inner2();\n        Console.WriteLine(al.Value); // 2 or 20?\n\n        al.Value = 3;\n        await Task.WhenAll(t1, t2);\n        Console.WriteLine(al.Value); // 3 or 10 or 20?\n\n        al.Value = 4;\n        al2.Value = 104;\n        await t1;\n        Console.WriteLine(al.Value); // 4 or 10?\n        Console.WriteLine(al2.Value); // 104 as set above, or did it return to 101?\n\n        al.Value = 5;\n        _ = t1.Result;\n        Console.WriteLine(al.Value); // 5 or 10?\n\n        al.Value = 6;\n        await t1; // second time\n        Console.WriteLine(al.Value); // 6 or 10?\n    }\n}\n```\n\nWhen should AsyncLocal\\\u003cT\\\u003e.Value propagate to the caller:\n\n- Immediately when set?  Then how does it differ from plain T — surely there must be some boundary through which it does not propagate.  Like from one HTTP request to another.\n- Only in `await`?  Then it could even be controllable with ConfigureAwaitOptions.\n  - Only in the first `await` of that Task, or also in subsequent awaits?\n- Also in Task\\\u003cT\\\u003e.Result?  I don\u0027t think users would expect such a side effect.\n- Also through Task.WhenAll, ContinueWith, and similar?\n\nIf the Task returned by the async function needs to carry the modified values, then that could make async functions slower in general, even when this feature is not used.  This cost could perhaps be avoided if the upwards propagation were only supported in some new UpPropagatingTask\\\u003cT\\\u003e type, similar to how ValueTask\\\u003cT\\\u003e is an alternative to Task\\\u003cT\\\u003e.  But then it would not work through current ASP.NET Core which does not use such a type.",
                                           "updatedAt":  "2024-03-02T05:04:33Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc51tG2k",
                                           "createdAt":  "2024-03-02T10:33:41Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "mrpmorris",
                                           "body":  "@KalleOlaviNiemitalo My goal was to not have to inject dependencies, so the packages wouldn\u0027t give me what I want.\r\n\r\nRe your example, the idea is that it is a way of sharing state within async/await chains in the same way ThreadLocal shares within a single thread.",
                                           "updatedAt":  "2024-03-02T10:33:41Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc51tqwm",
                                           "createdAt":  "2024-03-02T20:50:29Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "weltkante",
                                           "body":  "\u003e the idea is that it is a way of sharing state within async/await chains in the same way ThreadLocal shares within a single thread\r\n\r\nwhere would you make the \"split\" condition, i.e. which code would get its own state? since all code spawns off the programs main method everything would share the same state?\r\n\r\nif you say code run on `new Thread` get its own state, does that include threadpool threads? do threadpool threads get new state for every workload being run on the threadpool? What about Task.Run which is used both to start threadpool workloads and to move existing workloads to the threadpool?\r\n\r\nwhat is with async workloads switching threads across their lifetime? if I await async code on a different thread (having its own AsyncLocal state) would that \"merge\" the states? that is the \"real\" issue with the example code posted above. you just have to assume the different workloads come from different states (however you define differing states to be generated)\r\n\r\nI have run into your very same problem myself because WPF takes a snapshot of AsyncLocal very early in the startup and _never_ merges state back, so _some_ events will always execute with that startup state. I\u0027ve thought a lot about how it could be resolved, as you can see from above questions there is not really a single answer that fits everyone, its relatively easy to construct a relevant example where any fixed splitting/merging strategy fails.\r\n\r\nI\u0027ve come to the conclusion, if you want shared state, then put that shared state into the AsyncLocal (and in case of WPF, early in the startup sequence). Make a mutable object and let it propagate through the AsyncLocal infrastructure, but do not change the AsyncLocal (except when you actually want to split off state!). Just mutate your \"current\" mutable objects state in the AsyncLocal and everyone sharing it will see the changes (you _will_ have to consider thread safety on this shared state).",
                                           "updatedAt":  "2024-03-03T08:03:54Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc51uHGH",
                                           "createdAt":  "2024-03-03T04:53:45Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODZFBZQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "weltkante",
                                                                               "createdAt":  "2024-03-03T07:54:32Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "KalleOlaviNiemitalo",
                                           "body":  "\u003e WPF takes a snapshot of AsyncLocal very early in the startup and never merges state back, so some events will always execute with that startup state. \n\nI had a related problem with a library that creates threads in unmanaged code and then calls managed-code callbacks on them.  .NET Runtime does not know where those threads came from, so they don\u0027t inherit any AsyncLocal\\\u003cT\\\u003e.Value, such as those used by NUnit or Microsoft.Extensions.Logging.  This can be worked around by using ExecutionContext.Capture during initialisation and then ExecutionContext.CreateCopy and ExecutionContext.Run within each callback.\n\n\u003e Just mutate your \"current\" mutable objects state in the AsyncLocal and everyone sharing it will see the changes (you will have to consider thread safety on this shared state).\n\nThis is the approach taken in Microsoft.Extensions.AsyncState.  That package however is less thread-safe than one would expect when porting from AsyncLocal\\\u003cT\\\u003e; \u003chttps://github.com/dotnet/extensions/issues/4623\u003e.\n\nHaving AsyncLocal\\\u003cT\\\u003e.Value refer to a mutable instance also lets you clear out the reference fields of that instance when you finish with the async operation.  If a library started any long-running task or async function that inherited the ExecutionContext, then that will prevent the garbage collector from freeing the AsyncLocal\\\u003cT\\\u003e.Value, even if the library will never read that; but if you clear the fields, then at least this instance won\u0027t keep any other objects alive and consuming memory unnecessarily.",
                                           "updatedAt":  "2024-03-03T18:21:37Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc56aXEX",
                                           "createdAt":  "2024-04-13T18:53:35Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Duranom",
                                           "body":  "Think something similar is stated in the in the [async2](https://github.com/dotnet/runtimelab/blob/e69dda51c7d796b8122d0f55b560bc44094a4bec/docs/design/features/runtime-handled-tasks.md) ([meeting](https://github.com/dotnet/csharplang/blob/main/meetings/2024/LDM-2024-04-01.md))\r\n\r\nThough @mrpmorris is the issue you are running into solvable with a work around with a `ThreadLocal` and `AsyncLocal` working together and act sort of like the `HttpContextAccessor`? It a sort of thing used several times in some personal needed a similar behavior for a bit due to a library till could move away from such ambient states.\r\n\r\n```C#\r\n/// \u003cremarks\u003e\r\n/// Not threading write safe\r\n/// \u003c/remarks\u003e\r\npublic sealed class State\u003cT\u003e\r\nwhere T : class\r\n{\r\n    private static AsyncLocal\u003cContextHolder\u003e _asyncLocal = new(vca =\u003e {\r\n        // Don\u0027t think you need to check ThreadContextChanged as always should have ContextHolder after fist value\r\n        _threadLocal.Value ??= vca.CurrentValue ?? vca.PreviousValue;\r\n    });\r\n\r\n    private static ThreadLocal\u003cContextHolder\u003e _threadLocal = new();\r\n\r\n    public T Value\r\n    {\r\n        get =\u003e _threadLocal.Value?.Context;\r\n        set\r\n        {\r\n            if(_asyncLocal.Value is null)\r\n            {\r\n                _asyncLocal.Value = new ContextHolder{ Context = null };\r\n            }\r\n            else\r\n            {\r\n                _asyncLocal.Value = new ContextHolder{ Context = value };\r\n            }\r\n        }\r\n    }\r\n\r\n    private class ContextHolder\r\n    {\r\n        public T Context {get; set;}\r\n    }\r\n}\r\n```",
                                           "updatedAt":  "2024-04-14T13:28:29Z"
                                       }
                                   ],
                         "totalCount":  8
                     },
        "title":  "[API Proposal]: Additional setting for AsyncLocal Value to cascade upwards",
        "labels":  [
                       "api-suggestion",
                       "area-System.Threading.Tasks",
                       "needs-further-triage"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/100455",
        "createdAt":  "2024-03-29T22:21:50Z",
        "number":  100455,
        "author":  "zlatko-michailov",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2024-07-31T08:22:22Z",
        "body":  "### Description\r\n\r\nTask.Delay(timeout) completes before the specified timeout has expired. This behavior reproes both when a millisecond count is used and when a TimeSpan constructed with ticks is used.\r\n\r\n### Reproduction Steps\r\n\r\nRun the following code. After a minute or so, entries will start popping. \r\nNot passing any cmd line argument will use a millisecond count.\r\nPassing a `ticks` argument will use a TimeSpan constructed from __integer__ clock ticks.\r\nPassing a `stopwatch` argument will use a Stopwatch.\r\n\r\n``` cs\r\nusing System.Diagnostics;\r\n\r\nclass Program\r\n{\r\n    const int expectedMs = 1000;\r\n\r\n    static async Task Main(string[] args)\r\n    {\r\n        bool ticks = false;\r\n        bool stopwatch = false;\r\n        \r\n        foreach (string arg in args)\r\n        {\r\n            ticks = ticks || arg == \"ticks\";\r\n            stopwatch = stopwatch || arg == \"stopwatch\";\r\n        }\r\n\r\n        await RunTest(ticks, stopwatch);\r\n    }\r\n\r\n    static async Task RunTest(bool ticks, bool stopwatch)\r\n    {\r\n        Console.WriteLine($\"Using ticks={ticks}, stopwatch={stopwatch}\");\r\n\r\n        for (int i = 0; i \u003c 1000000; i++)\r\n        {\r\n            DateTime beforeTime = DateTime.UtcNow;\r\n            Stopwatch sw = Stopwatch.StartNew();\r\n            if (ticks)\r\n            {\r\n                await Task.Delay(TimeSpan.FromTicks(expectedMs * TimeSpan.TicksPerMillisecond));\r\n            }\r\n            else\r\n            {\r\n                await Task.Delay(expectedMs);\r\n            }\r\n            sw.Stop();\r\n            DateTime afterTime = DateTime.UtcNow;\r\n\r\n            TimeSpan duration = afterTime - beforeTime;\r\n            double actualMs = duration.TotalMilliseconds;\r\n            if (stopwatch)\r\n            {\r\n                actualMs = sw.ElapsedMilliseconds;\r\n            }\r\n\r\n            if (actualMs \u003c expectedMs)\r\n            {\r\n                Console.WriteLine($\"{i}: actual={actualMs}, expected={expectedMs}, {beforeTime:O}, {afterTime:O}\");\r\n            }\r\n        }\r\n    }\r\n}```\r\n\r\n### Expected behavior\r\n\r\nThe TimeSpan from `beforeTime` to `afterTime` must always be higher than 1,000 ms.\r\nTaking the time before and after the await takes some time. Leaving the initial thread, and scheduling the continuation should also take some time.\r\n\r\n### Actual behavior\r\n\r\nIn some cases the TimeSpan between `beforeTime` and `afterTime` is less than 1,000 ms.\r\n\r\n### Regression?\r\n\r\nDon\u0027t know.\r\n\r\n### Known Workarounds\r\n\r\nSome approximation was considered. It was ruled out. The Task class is at the bottom of async programming. This looks like a bug that should be fixed.\r\n\r\n### Configuration\r\n\r\n_No response_\r\n\r\n### Other information\r\n\r\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOhqFAJg==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5437sE",
                                           "createdAt":  "2024-03-30T05:37:49Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "huoyaoyuan",
                                           "body":  "The `precise` parameter doesn\u0027t matter. `Task.Delay` always converts the time to integer milliseconds.\r\n\r\n`DateTime.UtcNow` has it\u0027s own overhead and inaccuracy. `Stopwatch` should be used for more precise time checking.\r\n\r\n",
                                           "updatedAt":  "2024-03-30T05:37:49Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5450bU",
                                           "createdAt":  "2024-03-30T18:20:41Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Clockwork-Muse",
                                           "body":  "As an example - although it\u0027s less of a case now, it used to be that the system clock would have a resolution of ~15ms (for all languages - this was mostly a hardware/OS problem).  This causes a number of amusing side effects....  I\u0027m not sure that the value the clock would report was guaranteed to be the \"earliest\" value, as opposed to just _a_ value, so duration from getting two clock reads and subtracting them would be up to ~30ms off.....",
                                           "updatedAt":  "2024-03-30T18:20:41Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc546Uqu",
                                           "createdAt":  "2024-03-31T04:58:14Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "zlatko-michailov",
                                           "body":  "I allowed myself to edit the repro by adding an option to use a Stopwatch.\r\n\r\nIndeed, the repro with a Stopwatch is less frequent, but it still exists:\r\n\u003e 591: actual=998, expected=1000, 2024-03-31T04:46:00.3957635Z, 2024-03-31T04:46:01.3937879Z\r\n\u003e 820: actual=999, expected=1000, 2024-03-31T04:49:51.2193977Z, 2024-03-31T04:49:52.2190058Z\r\n\r\n",
                                           "updatedAt":  "2024-03-31T05:24:23Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc546U5g",
                                           "createdAt":  "2024-03-31T05:03:58Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "zlatko-michailov",
                                           "body":  "As this is the `Runtime` project, all three - `Task`, `DateTime`, and `Stopwatch` should fall in here. Make them work together. \r\n\r\nI am not asking that `Task.Delay()` is accurate in absolute/atomic time, not even in machine time. I am asking that it is accurate in dotnet terms within the same dotnet process.",
                                           "updatedAt":  "2024-03-31T05:07:48Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc547ZGB",
                                           "createdAt":  "2024-03-31T17:30:29Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "Could you share which version of .NET, which Operating System (including version), and which CPU you\u0027re running on?\r\n\r\nNotably this doesn\u0027t repro on Windows 10 or 11 for me, across any of my AMD, Intel, or Arm64 systems (all of which are 2015 or later). I haven\u0027t yet tried against any Linux systems.\r\n",
                                           "updatedAt":  "2024-03-31T17:30:29Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc547fdf",
                                           "createdAt":  "2024-03-31T18:29:12Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "huoyaoyuan",
                                           "body":  "It reproduces for me after about 5 minutes. I\u0027m not sure what are affecting the precisions.",
                                           "updatedAt":  "2024-03-31T18:29:12Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5476Ki",
                                           "createdAt":  "2024-04-01T00:34:34Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "zlatko-michailov",
                                           "body":  "@tannergooding\r\n- dotnet: 8.0\r\n- OS: Win 11 23H2 (build 22631.3296) VM. (My teammates tell me it reproes on native Win 11 as well.) I\u0027ve also reproed it on WSL Ubuntu, and I\u0027ve seen it in the Azure build pipeline. \r\n- Processor: AMD Ryzen Threadripper PRO 3955WX 16 cores, hyperthreading enabled.\r\n\r\nPlease don\u0027t blame it on the OS or on the machine clock. I doubt there is a computer whose clock would ever go backwards. Chances are `Task.Delay()` overdoes its effort not to start the continuation too late. ",
                                           "updatedAt":  "2024-04-01T00:34:34Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc548zUM",
                                           "createdAt":  "2024-04-01T05:48:52Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEIJMBQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "cklutz",
                                                                               "createdAt":  "2024-07-02T13:22:48Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "vzarytovskii",
                                                                               "createdAt":  "2025-03-01T20:51:42Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "\u003e Please don\u0027t blame it on the OS or on the machine clock.\r\n\r\n.NET itself isn\u0027t doing any special logic to allow pre-firing, it\u0027s simply querying the underlying system tick count APIs and using the relevant threading and other APIs.\r\n\r\nThe .NET code is fully open and you can go and double check what it does yourself if you want to be sure:\r\n* Task.Delay(int): https://source.dot.net/#System.Private.CoreLib/src/libraries/System.Private.CoreLib/src/System/Threading/Tasks/Task.cs,34b191a243434f6a\r\n* Task.Delay(int, CancellationToken): https://source.dot.net/#System.Private.CoreLib/src/libraries/System.Private.CoreLib/src/System/Threading/Tasks/Task.cs,5fb80297e082b8d6\r\n* Task.Delay(uint, TimeProvider, CancellationToken): https://source.dot.net/#System.Private.CoreLib/src/libraries/System.Private.CoreLib/src/System/Threading/Tasks/Task.cs,14879c32ba2be734\r\n* DelayPromise(uint, TimeProvider): https://source.dot.net/#System.Private.CoreLib/src/libraries/System.Private.CoreLib/src/System/Threading/Tasks/Task.cs,9f97a2778a725516\r\n* TimerQueueTimer(TimerCallback, object, uint, uint, bool): https://source.dot.net/#System.Private.CoreLib/src/libraries/System.Private.CoreLib/src/System/Threading/Timer.cs,57dfdb0922c09c94\r\n* TimerQueueTimer.Change(uint, uint): https://source.dot.net/#System.Private.CoreLib/src/libraries/System.Private.CoreLib/src/System/Threading/Timer.cs,9c6e2403064ef532\r\n* TimerQueue.UpdateTimer(TimerQueueTimer, uint, uint): https://source.dot.net/#System.Private.CoreLib/src/libraries/System.Private.CoreLib/src/System/Threading/Timer.cs,c35c34bf30ba25a2\r\n\r\nThe last of which clearly uses exact thresholds, not fuzziness. Only relying on `TickCount64` which defers to `Environment.TickCount64` on Unix (which defers to `clock_gettime_nsec_np`, `CLOCK_MONOTONIC_COARSE` or `CLOCK_MONOTONIC`) and `QueryUnbiasedInterruptTime` on Windows 8+ (which takes the 100ns count and turns it into ms using integer division, which truncates).\r\n\r\nYou then have `TimerQueue.EnsureTimerFiresBy(uint)`: https://source.dot.net/#System.Private.CoreLib/src/libraries/System.Private.CoreLib/src/System/Threading/Timer.cs,48ca530eebd59912\r\n\r\nThis ensures its scheduled and similarly uses exact tick counts, only firing if greater than or equal.\r\n\r\nYou then have the actual timer thread which is either the portable version (such as on Unix): https://source.dot.net/#System.Private.CoreLib/src/libraries/System.Private.CoreLib/src/System/Threading/TimerQueue.Portable.cs,01f8a0f2623d1904,references\r\n\r\nor uses the windows threadpool (default for windows) which calls `CreateThreadpoolTimer` and `SetThreadpoolTimer`: https://github.com/dotnet/runtime/blob/cc7bf831f02cad241547ebea5c56c82f12a50999/src/libraries/System.Private.CoreLib/src/System/Threading/TimerQueue.WindowsThreadPool.cs\r\n\r\n\u003e I doubt there is a computer whose clock would ever go backwards\r\n\r\nThis is a very common thing and why you have different clock sources only some of which are guaranteed to be monotonic in nature.\r\n\r\n.NET currently ensures we use monotonic clocks. However, many such clocks are not strictly guaranteed to always be monotonic across threads or separate CPU cores.\r\n\r\nDocuments like https://learn.microsoft.com/en-us/windows/win32/api/realtimeapiset/nf-realtimeapiset-queryunbiasedinterrupttime, https://learn.microsoft.com/en-us/windows/win32/winmsg/about-timers, https://learn.microsoft.com/en-us/windows/win32/sysinfo/acquiring-high-resolution-time-stamps, or even the POSIX specific docs around `CLOCK_*` cover a lot of these nuances and what systems can impact the reported measurements, how they can be subject to cross cores considerations, etc.\r\n\r\nWindows specifically calls out, as an example:\r\n\u003e When you compare performance counter results that are acquired from different threads, consider values that differ by ± 1 tick to have an ambiguous ordering. If the time stamps are taken from the same thread, this ± 1 tick uncertainty doesn\u0027t apply. In this context, the term tick refers to a period of time equal to 1 ÷ (the frequency of the performance counter obtained from [QueryPerformanceFrequency](https://learn.microsoft.com/en-us/windows/win32/api/profileapi/nf-profileapi-queryperformancefrequency)).\r\n--------------\r\n\r\nThere are then also other factors to consider, such as whether values displayed using `double` are exact or if values that are computed using division are themselves exact.\r\n\r\nA simple example is that `Stopwatch.ElapsedMilliseconds` does `GetElapsedDateTimeTicks() / TicksPerMillisecond` as an integer division, thus this will truncate. `GetElapsedDateTimeTicks()` is then itself `(long)(GetRawElapsedTicks() * s_tickFrequency)` and thus is taking an `int64` converting it to double, scaling by something which is likely not exactly representabled as a double, and then casting back to `long` (which truncates).  Thus, it is entirely reasonable that due to the double truncation and general inaccuracy of `double` in creating a display value, we take something that was 1000ms in terms of say 100ns ticks and it converts down to 999ms instead when trying to display the value. Therefore more data would need to be displayed to determine if it was actually 1000ms or not.\r\n\r\nGiven how the actual timer APIs are coded and that they aren\u0027t doing anything that would cause underreporting in times, that I can see, I expect you could reproduce the issue in C/C++ on both Linux and Windows and it\u0027s likely coming down to threading and some minor differences in the underlying OS APIs and hardware timers.",
                                           "updatedAt":  "2024-04-01T05:48:52Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc54_-Mx",
                                           "createdAt":  "2024-04-01T15:50:22Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Clockwork-Muse",
                                           "body":  "As a _practical_ matter, if you actually want millisecond accuracy on your task delays, you\u0027re probably doing something awkward or better handled by something else.  What is it you\u0027re doing that you want this accuracy?",
                                           "updatedAt":  "2024-04-01T15:50:22Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc55Aa1a",
                                           "createdAt":  "2024-04-01T16:55:40Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "zlatko-michailov",
                                           "body":  "In Prod, we have a cron-like loop that fires multiple jobs, each of which may have a different frequency. The loop wakes up frequently (every 1 minute) and each job decides whether it should execute or ignore the call, based on its own schedule. In our test, the loop wakes up every 1 second, and there are 2 jobs - one that executes every 1 second, i.e. supposedly on every fire from the loop, and another one that executes every 2 seconds. The first job has misses - a lot more frequently than in the simple repro I provided.\r\n\r\nI figured the simple repro would be more stable, that\u0027s why I reduced the loop delay to 100 ms. Otherwise, it would take too long to repro. 100 ms is coarse-enough for any clock to satisfy, IMO. \r\n\r\nI also provided the \"precise\" option in the repro to avoid inaccuracy from floating point division (at least on my end), but the problem still reproes.",
                                           "updatedAt":  "2024-04-01T16:55:40Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc55AgHM",
                                           "createdAt":  "2024-04-01T17:09:53Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "\u003e 100 ms is coarse-enough for any clock to satisfy, IMO.\r\n\r\nThe consideration wouldn\u0027t be if it\u0027s coarse enough, it\u0027s that if you have say a clock with 15ms granularity, then you can represent 90ms or 105ms, but not 100ms.\r\n\r\n\u003e I figured the simple repro would be more stable, that\u0027s why I reduced the loop delay to 100 ms.\r\n\r\nI ran this all night at 1000ms and got exactly 1 trigger where stopwatch reported `999ms` but where if you observe `sw.ElapsedTicks` and `Stopwatch.Frequency` it was actually 1 second worth of time.\r\n\r\nCould you update your own local repro to dump the following information\r\n```csharp\r\nConsole.WriteLine($\"{i}: actual={actualMs} (ticks={sw.ElapsedTicks}, freq={Stopwatch.Frequency}), expected={expectedMs}, {beforeTime:O}, {afterTime:O} (deltaTicks={(afterTime - beforeTime).Ticks})\");\r\n```\r\n\r\nIn particular, we\u0027re most interested in the raw elapsed ticks/frequency of the stopwatch; and the raw tick delta for the `DateTime` to ensure that there is no issues being shown purely to display reasons.",
                                           "updatedAt":  "2024-04-01T17:09:53Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc55AyKZ",
                                           "createdAt":  "2024-04-01T17:56:14Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "I did get a single trigger with the following program:\r\n```csharp\r\n// See https://aka.ms/new-console-template for more information\r\nusing System.Diagnostics;\r\n\r\nclass Program\r\n{\r\n    const int expectedMs = 100;\r\n\r\n    static async Task Main(string[] args)\r\n    {\r\n        bool ticks = false;\r\n        bool stopwatch = false;\r\n\r\n        foreach (string arg in args)\r\n        {\r\n            ticks = ticks || arg == \"ticks\";\r\n            stopwatch = stopwatch || arg == \"stopwatch\";\r\n        }\r\n\r\n        await RunTest(ticks, stopwatch);\r\n    }\r\n\r\n    static async Task RunTest(bool ticks, bool stopwatch)\r\n    {\r\n        Console.WriteLine($\"Using ticks={ticks}, stopwatch={stopwatch}\");\r\n\r\n        for (int i = 0; i \u003c 1000000; i++)\r\n        {\r\n            if (i % 1000 == 0)\r\n            {\r\n                Console.WriteLine(i);\r\n            }\r\n\r\n            int firstProcId = Thread.GetCurrentProcessorId();\r\n\r\n            long beforeTicks = Environment.TickCount64;\r\n            DateTime beforeTime = DateTime.UtcNow;\r\n            Stopwatch sw = Stopwatch.StartNew();\r\n            if (ticks)\r\n            {\r\n                await Task.Delay(TimeSpan.FromTicks(expectedMs * TimeSpan.TicksPerMillisecond));\r\n            }\r\n            else\r\n            {\r\n                await Task.Delay(expectedMs);\r\n            }\r\n            sw.Stop();\r\n            DateTime afterTime = DateTime.UtcNow;\r\n            long afterTicks = Environment.TickCount64;\r\n\r\n            int lastProcId = Thread.GetCurrentProcessorId();\r\n\r\n            TimeSpan duration = afterTime - beforeTime;\r\n            double actualMs = duration.TotalMilliseconds;\r\n            if (stopwatch)\r\n            {\r\n                actualMs = sw.ElapsedMilliseconds;\r\n            }\r\n\r\n            if (actualMs \u003c expectedMs)\r\n            {\r\n                Console.WriteLine($\"{i}: procId={firstProcId}-\u003e{lastProcId}; Stopwatch - actual={actualMs} (ticks={sw.ElapsedTicks}, freq={Stopwatch.Frequency}), expected={expectedMs}; DateTime: {beforeTime:O}, {afterTime:O} (deltaTicks={(afterTime - beforeTime).Ticks}); TickCount64 - {beforeTicks}, {afterTicks}\");\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nWhere it gave:\r\n```csharp\r\n42: procId=31-\u003e5; Stopwatch - actual=99 (ticks=999915, freq=10000000), expected=100; DateTime: 2024-04-01T17:45:18.4304004Z, 2024-04-01T17:45:18.5303925Z (deltaTicks=999921); TickCount64 - 232966468, 232966578\r\n```\r\n\r\nYou can see that:\r\n* `Stopwatch` reported `99.9915ms`\r\n* `DateTime` reported `99.9921ms`\r\n  * This makes sense since its done before stopwatch\r\n* `TickCount64` reported `110ms`\r\n  * Thus it\u0027s measuring 10 additional ms, potentially related to the procId change\r\n  * procId changes happen very frequently, but this mismeasurement looks to be infrequent",
                                           "updatedAt":  "2024-04-01T17:56:14Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc55AzX6",
                                           "createdAt":  "2024-04-01T17:58:57Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Clockwork-Muse",
                                           "body":  "\u003e The loop wakes up frequently (every 1 minute) and each job decides whether it should execute or ignore the call, based on its own schedule\r\n\r\nSo then you don\u0027t actually care about the precision per se, you\u0027re building a scheduling system, and the usual concerns (spurious wakes, essentially, here) apply.\r\n\r\nIs there a reason you\u0027re building your own, instead of using one of the existing packages/applications available in the ecosystem (eg, Quartz)?",
                                           "updatedAt":  "2024-04-01T17:58:57Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc55Bk0E",
                                           "createdAt":  "2024-04-01T19:55:37Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "zlatko-michailov",
                                           "body":  "@tannergooding I see you have reproed that all timer-based measurements can return \u003c 1000 ms. (To repro Environment.TickCount64, you\u0027ll have to include it in the condition. I haven\u0027t tried it though.) Do you still need any further input from me?",
                                           "updatedAt":  "2024-04-01T19:55:37Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc55Bx8r",
                                           "createdAt":  "2024-04-01T20:34:11Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "This looks to be an OS issue, not a .NET issue, it\u0027s likely something that needs to be filed with Windows/Linux/MacOS, etc\r\n\r\n.NET could potentially use stopwatch explicitly and not the much more coarse tick count as a way to avoid the issue, but that may not strictly be better.",
                                           "updatedAt":  "2024-04-01T20:34:11Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc55B3oX",
                                           "createdAt":  "2024-04-01T20:51:24Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "zlatko-michailov",
                                           "body":  "I was hoping dotnet could use its own clock abstraction on top of the hardware clock, and guarantee fidelity among the time/duration-related APIs.",
                                           "updatedAt":  "2024-04-01T20:51:24Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc55B7DZ",
                                           "createdAt":  "2024-04-01T21:01:07Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "The issue here is that an underlying OS API appears to be returning inaccurate numbers in some cases. There\u0027s nothing that .NET can do to fix that except switch to an entirely different timer source.\r\n\r\nOn Windows 8 and above, all we\u0027re doing is calling `QueryUnbiasedInterruptTime` and dividing the 100ns ticks by `10_000`, thus converting it to milliseconds. Since it\u0027s integer division, we\u0027re then truncating any partial precision.\r\n\r\nSimilarly, we by default simply use `SetThreadpoolTimer` which is meant to operate in 100ns ticks and short of that, fallback to `QueryUnbiasedInterruptTime`.\r\n\r\nThere\u0027s nothing \"better\" we can do, especially that wouldn\u0027t be much more expensive and wouldn\u0027t be subject to the same potential issues if the OS sometimes reports inaccurate numbers.",
                                           "updatedAt":  "2024-04-01T21:01:07Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc55fHDO",
                                           "createdAt":  "2024-04-04T20:53:02Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "zlatko-michailov",
                                           "body":  "I tweaked my repro to use all three methods - `DateTime.UtcNow`, `Stopwatch`, and `Environment.TickCount64`. If any of the three returns a duration that is under 100ms, a message is logged to the console.\r\n\r\nResults on Windows:\r\n\u003e Using ticks=False\r\n780: expected=1000, actualDurationMs=999.9728, actualStopwatchMs=999, actualTickCountMs=1000\r\n1860: expected=1000, actualDurationMs=999.9935, actualStopwatchMs=999, actualTickCountMs=1000\r\n1981: expected=1000, actualDurationMs=1000.0029, actualStopwatchMs=999, actualTickCountMs=1000\r\n2162: expected=1000, actualDurationMs=999.6005, actualStopwatchMs=999, actualTickCountMs=1000\r\n2280: expected=1000, actualDurationMs=999.9874, actualStopwatchMs=999, actualTickCountMs=1000\r\n2600: expected=1000, actualDurationMs=999.9641, actualStopwatchMs=999, actualTickCountMs=1000\r\n2624: expected=1000, actualDurationMs=999.9983, actualStopwatchMs=999, actualTickCountMs=1000\r\n2636: expected=1000, actualDurationMs=999.9606, actualStopwatchMs=999, actualTickCountMs=1000\r\n2687: expected=1000, actualDurationMs=999.9844, actualStopwatchMs=999, actualTickCountMs=1000\r\n3510: expected=1000, actualDurationMs=999.9831, actualStopwatchMs=999, actualTickCountMs=1000\r\n3522: expected=1000, actualDurationMs=1000.0026, actualStopwatchMs=999, actualTickCountMs=1000\r\n\r\n\u003e Using ticks=True\r\n246: expected=1000, actualDurationMs=1000.0081, actualStopwatchMs=999, actualTickCountMs=1000\r\n861: expected=1000, actualDurationMs=999.9981, actualStopwatchMs=999, actualTickCountMs=1000\r\n1014: expected=1000, actualDurationMs=1000.0053, actualStopwatchMs=999, actualTickCountMs=1000\r\n2484: expected=1000, actualDurationMs=999.9792, actualStopwatchMs=999, actualTickCountMs=1000\r\n2558: expected=1000, actualDurationMs=999.995, actualStopwatchMs=999, actualTickCountMs=1000\r\n2896: expected=1000, actualDurationMs=999.9237, actualStopwatchMs=999, actualTickCountMs=1000\r\n2930: expected=1000, actualDurationMs=999.97, actualStopwatchMs=999, actualTickCountMs=1000\r\n3051: expected=1000, actualDurationMs=1000.0041, actualStopwatchMs=999, actualTickCountMs=1000\r\n\r\nApparently using ticks in `Task.Delay()` doesn\u0027t make any difference.\r\nIt looks like both `DateTime.UtcNow` and `Stopwatch` suffer from some rounding, which more severe with `Stopwotch`. That makes `Stopwatch` the worst choice.\r\nThe good news is there is a winner that never failed - `Environment.TickCount64`. I don\u0027t know whether the rounding is different or whether it uses a different underlying mechanism to poll the time. But the net result is it is better than the other two methods.\r\n\r\nOn WSL on the same Windows machine, the results are marginally, but not fundamentally, different:\r\n\u003e Using ticks=False\r\n132: expected=1000, actualDurationMs=990.6424, actualStopwatchMs=990, actualTickCountMs=1000\r\n290: expected=1000, actualDurationMs=991.4873, actualStopwatchMs=991, actualTickCountMs=1000\r\n399: expected=1000, actualDurationMs=990.5667, actualStopwatchMs=990, actualTickCountMs=1000\r\n451: expected=1000, actualDurationMs=992.5291, actualStopwatchMs=992, actualTickCountMs=1000\r\n733: expected=1000, actualDurationMs=990.4435, actualStopwatchMs=990, actualTickCountMs=1000\r\n768: expected=1000, actualDurationMs=992.2823, actualStopwatchMs=992, actualTickCountMs=1000\r\n823: expected=1000, actualDurationMs=993.9202, actualStopwatchMs=993, actualTickCountMs=1001\r\n841: expected=1000, actualDurationMs=990.766, actualStopwatchMs=990, actualTickCountMs=1000\r\n882: expected=1000, actualDurationMs=995.5455, actualStopwatchMs=995, actualTickCountMs=1000\r\n912: expected=1000, actualDurationMs=991.0338, actualStopwatchMs=991, actualTickCountMs=1000\r\n945: expected=1000, actualDurationMs=990.7209, actualStopwatchMs=990, actualTickCountMs=1000\r\n\r\nThe error from `DateTime.UtcNow` and `Stopwatch` is bigger - this is no longer floating-point rounding. But the pattern is the same - both of them suffer from the same inaccuracy. \r\n`Environment.TickCount64` doesn\u0027t fail here either.\r\n\r\nSo, to the statement _\"There\u0027s nothing that .NET can do to fix that except switch to an entirely different timer source.\"_ - \r\nThere is obviously something .NET can do - switch to the same mechanism that `Environment.TickCount64` uses.\r\n\r\nHere\u0027s the current repro:\r\n``` cs\r\nusing System.Diagnostics;\r\n\r\nclass Program\r\n{\r\n    const int expectedMs = 1000;\r\n\r\n    static async Task Main(string[] args)\r\n    {\r\n        bool ticks = false;\r\n        \r\n        foreach (string arg in args)\r\n        {\r\n            ticks = ticks || arg == \"ticks\";\r\n        }\r\n\r\n        await RunTest(ticks);\r\n    }\r\n\r\n    static async Task RunTest(bool ticks)\r\n    {\r\n        Console.WriteLine($\"Using ticks={ticks}\");\r\n\r\n        for (int i = 0; i \u003c 1000000; i++)\r\n        {\r\n            DateTime beforeTime = DateTime.UtcNow;\r\n            Stopwatch sw = Stopwatch.StartNew();\r\n            long beforeTickCount = Environment.TickCount64;\r\n            if (ticks)\r\n            {\r\n                await Task.Delay(TimeSpan.FromTicks(expectedMs * TimeSpan.TicksPerMillisecond));\r\n            }\r\n            else\r\n            {\r\n                await Task.Delay(expectedMs);\r\n            }\r\n            long afterTickCount = Environment.TickCount64;\r\n            sw.Stop();\r\n            DateTime afterTime = DateTime.UtcNow;\r\n\r\n            TimeSpan duration = afterTime - beforeTime;\r\n            double actualDurationMs = duration.TotalMilliseconds;\r\n            long actualStopwatchMs = sw.ElapsedMilliseconds;\r\n            long actualTickCountMs = afterTickCount - beforeTickCount;\r\n\r\n            if (actualDurationMs \u003c expectedMs || actualStopwatchMs \u003c expectedMs || actualTickCountMs \u003c expectedMs)\r\n            {\r\n                Console.WriteLine($\"{i}: expected={expectedMs}, actualDurationMs={actualDurationMs}, actualStopwatchMs={actualStopwatchMs}, actualTickCountMs={actualTickCountMs}\");\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n",
                                           "updatedAt":  "2024-04-04T20:53:02Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc55fNW2",
                                           "createdAt":  "2024-04-04T21:08:58Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "tannergooding",
                                           "body":  "\u003e The good news is there is a winner that never failed - Environment.TickCount64. I don\u0027t know whether the rounding is different or whether it uses a different underlying mechanism to poll the time. But the net result is it is better than the other two methods.\r\n\r\nI think you\u0027re somewhat misinterpreting the results here.\r\n\r\nIt\u0027s not that `actualTickCountMs` (which is to say `Environment.TickCount64`) is more accurate. It\u0027s rather instead likely that its the thing introducing the rounding error and reporting `1000` even though only `999.9728ms` have elapsed. `Task.Delay` then using `Environment.TickCount64` in some cases would cause it to fire less than a millisecond before actually scheduled if such rounding error exists.\r\n\r\nYou should be able to identify this by displaying `sw.ElapsedTicks` + `Stopwatch.Frequence` instead of `sw.ElapsedMilliseconds`, as a simple example, showing there is no rounding error. The same goes for displaying `duration.Ticks` rather than `duration.TotalMilliseconds`.",
                                           "updatedAt":  "2024-04-04T21:09:26Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc55fnbi",
                                           "createdAt":  "2024-04-04T22:07:13Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODdFp4g==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "huoyaoyuan",
                                                                               "createdAt":  "2024-04-05T03:14:30Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "Clockwork-Muse",
                                           "body":  "Also, you seem to be assuming that there\u0027s something in the C# runtime that\u0027s just observing some counter and then firing the tasks that instant.  That\u0027s not (entirely) what\u0027s happening - the thing that\u0027s ultimately firing the tasks is an OS/hardware utility, and due to the layers involved there\u0027s a bit of wiggle in when the task is resumed \"on time\" (for various reasons).  \r\nYou can\u0027t get around this.  The runtime handles some \"very early\" spurious wakes by requeuing them with the remaining time, but anything due before the next \"clock tick\" (of some resolution) is usually just handled immediately so that the task is mostly on time.\r\n\r\nTasks (and `Task.Delay`) are **not meant** for millisecond accuracy - if you actually need something like that, you need media timers, which are implemented differently.\r\n\r\nAs a practical matter, I\u0027ll again ask why you\u0027re implementing your own task scheduler, instead of using one of the (quite robust) existing implementations.",
                                           "updatedAt":  "2024-04-04T22:07:13Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6Gn-93",
                                           "createdAt":  "2024-07-30T15:27:07Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "glen-84",
                                           "body":  "I think that we have the same issue [here](https://github.com/ChilliCream/graphql-platform/actions/runs/10141523825/job/28039053057?pr=7314):\r\n\r\n\u003e Assert.InRange() Failure: Value not in range\r\n\u003e Range:  (1000 - 2000)\r\n\u003e Actual: 998\r\n\r\n[Test](https://github.com/ChilliCream/graphql-platform/blob/50bcfaa845b5760a7716383f3f32011d1f91c91c/src/HotChocolate/Core/test/Subscriptions.Postgres.Tests/BackgroundTaskTests.cs#L97)\r\n[Source](https://github.com/ChilliCream/graphql-platform/blob/50bcfaa845b5760a7716383f3f32011d1f91c91c/src/HotChocolate/Core/src/Subscriptions.Postgres/ContinuousTask.cs#L41)\r\n\r\nI was thinking of using `TimeProvider.Delay` instead, but it seems difficult to mock (being an extension method).\r\n\r\nI might just reduce the range to 995 for now.",
                                           "updatedAt":  "2024-07-31T08:22:22Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6GoUAm",
                                           "createdAt":  "2024-07-30T16:10:39Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODsOeBg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "glen-84",
                                                                               "createdAt":  "2024-07-31T08:22:07Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "Clockwork-Muse",
                                           "body":  "\u003e I was thinking of using `TimeProvider.Delay` instead, but it seems difficult to mock (being an extension method).\r\n\r\nThe way the extension method works, it calls `TimeProvider.CreateTimer`, so you would mock/implement that method instead.\r\n\r\n\u003e I might just reduce the range to 995 for now.\r\n\r\nTraditionally clock resolutions are ~15ms, so you might want `985` instead.",
                                           "updatedAt":  "2024-07-30T16:10:39Z"
                                       }
                                   ],
                         "totalCount":  22
                     },
        "title":  "Task.Delay(timeout) completes before the specified timeout has expired",
        "labels":  [
                       "area-System.Threading.Tasks",
                       "needs-further-triage"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/100504",
        "createdAt":  "2024-04-02T01:10:40Z",
        "number":  100504,
        "author":  "petroemil",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOC4rK5w==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "proudust",
                                            "createdAt":  "2024-06-17T07:57:34Z"
                                        }
                                    ],
                          "totalCount":  1
                      },
        "updatedAt":  "2025-02-27T17:59:55Z",
        "body":  "### Background and motivation\r\n\r\nA very common scenario is to run multiple asynchronous operations in parallel and continue once all of them returned their results. Currently, the only API we have for such scenarios is the `Task.WhenAll`, but it loses the type information of the individual `Task`s because it operates on an array of `Task`s of the same type.\r\n\r\nIf the `Task`s are of different types, await-ing them in parallel and capturing their results becomes cumbersome. \r\n\r\nWith the ability to deconstruct tuples at assignment, there could be an API to run multiple `Task`s of different types in parallel and return their results as a tuple which can be deconstructed immediately without having to hold on to intermediate `Task\u003cT\u003e` references.\r\n\r\n### API Proposal\r\n\r\n```csharp\r\nnamespace System.Threading.Tasks;\r\n\r\nclass Task\r\n{\r\n    public static Task\u003c(T1, T2)\u003e WhenAll\u003cT1, T2\u003e(Task\u003cT1\u003e task1, Task\u003cT2\u003e task2)\r\n    {\r\n        // note: I\u0027m pretty sure there\u0027s a more efficient implementation than this\r\n        return Task.WhenAll(task1, task2).ContinueWith(_ =\u003e (task1.Result, task2.Result));\r\n    }\r\n\r\n    public static Task\u003c(T1, T2, T3)\u003e WhenAll\u003cT1, T2, T3\u003e(Task\u003cT1\u003e task1, Task\u003cT2\u003e task2, Task\u003cT3\u003e task3);\r\n    public static Task\u003c(T1, T2, T3, T4)\u003e WhenAll\u003cT1, T2, T3, T4\u003e(Task\u003cT1\u003e task1, Task\u003cT2\u003e task2, Task\u003cT3\u003e task3, Task\u003cT4\u003e task4);\r\n    public static Task\u003c(T1, T2, T3, T4, T5)\u003e WhenAll\u003cT1, T2, T3, T4, T5\u003e(Task\u003cT1\u003e task1, Task\u003cT2\u003e task2, Task\u003cT3\u003e task3, Task\u003cT4\u003e task4, Task\u003cT5\u003e task5);\r\n}\r\n```\r\n\r\n\r\n### API Usage\r\n\r\n```csharp\r\nasync Task\u003cstring\u003e GetStringAsync() =\u003e \"Hello World\";\r\nasync Task\u003cint\u003e GetIntAsync() =\u003e 42;\r\n\r\nvar (s, i) = await Task.WhenAll(\r\n    GetStringAsync(), \r\n    GetIntAsync());\r\n```\r\n\r\n\r\n### Alternative Designs\r\n\r\nI know that this wouldn\u0027t quite work because the `Task.WhenAll` API already has `params` overload, so there would be ambiguity or unwanted preference between the overloads, but maybe the provided `Task\u003cT\u003e` parameters could be wrapped in a `ValueTuple` to avoid that overload collision, which would look something like this:\r\n\r\n```csharp\r\npublic static Task\u003c(T1, T2)\u003e WhenAll\u003cT1, T2\u003e((Task\u003cT1\u003e, Task\u003cT2\u003e) tasks);\r\n```\r\n\r\nI\u0027ll admit, this does look a little weird from the caller\u0027s perspective though.\r\n\r\nAnother alternative is to use a different method name, such as `WhenEach` (though it rather rhymes with `foreach` and is a new API planned for .NET 9 ( #61959 ) returning `Task`s via an `IAsyncEnumerable` as they complete, so returning a `Tuple` / `ValueTuple` there might be confusing, plus, I\u0027d assume it will also have a `params` overload and would meet with the same problem as the `WhenAll` API).\r\n\r\nSo, `WhenEvery`, `WhenSome`, `WhenAllIndividual`?",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOoEJm4A==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc55PkY5",
                                           "createdAt":  "2024-04-03T10:00:17Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "zlatanov",
                                           "body":  "Here is something better for you:\r\n\r\n```c#\r\npublic static class TaskExtensions\r\n{\r\n    public static TaskAwaiter\u003c(T1, T2)\u003e GetAwaiter\u003cT1, T2\u003e(this (Task\u003cT1\u003e, Task\u003cT2\u003e) tasks)\r\n    {\r\n        return Task.WhenAll(tasks.Item1, tasks.Item2)\r\n                   .ContinueWith(_ =\u003e Task.FromResult((tasks.Item1.Result, tasks.Item2.Result)))\r\n                   .Unwrap()\r\n                   .GetAwaiter();\r\n    }\r\n}\r\n```\r\n\r\nNow you can do this instead:\r\n\r\n```c#\r\nvar t1 = Task.Run(() =\u003e 1);\r\nvar t2 = Task.Run(() =\u003e \"2\");\r\n\r\nvar (r1, r2) = await (t1, t2);\r\n```\r\n\r\nOf course, you can try and write a custom `TaskAwaiter` to avoid the extra allocations, but I doubt it would matter much.",
                                           "updatedAt":  "2024-04-03T10:00:43Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc55XSvr",
                                           "createdAt":  "2024-04-04T04:11:16Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "petroemil",
                                           "body":  "Thanks, I\u0027ve seen this trick before, but while it looks cool, I think it could easily confuse less experienced developers, why you could await a tuple. The same way we don\u0027t have implicit GetAwaiter extension method for Task arrays, I don\u0027t think it\u0027s a good idea to introduce something like this at the BCL level. \r\n\r\nWith the proposed API in place, you could have this `implicit tuple awaiter` with even less effort and potentially error-prone implementation. Your `TaskExtensions` example would be reduced to\r\n\r\n```csharp\r\npublic static class TaskExtensions\r\n{\r\n    public static TaskAwaiter\u003c(T1, T2)\u003e GetAwaiter\u003cT1, T2\u003e(this (Task\u003cT1\u003e, Task\u003cT2\u003e) tasks)\r\n    {\r\n        return Task.WhenAll(tasks.Item1, tasks.Item2).GetAwaiter();\r\n    }\r\n}\r\n```",
                                           "updatedAt":  "2024-05-08T22:29:32Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6gQmbg",
                                           "createdAt":  "2025-02-27T17:59:54Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "petroemil",
                                           "body":  "Could this be considered for .NET 10 by any chance? ",
                                           "updatedAt":  "2025-02-27T17:59:54Z"
                                       }
                                   ],
                         "totalCount":  3
                     },
        "title":  "[API Proposal]: Task.WhenAll to return results in a strongly typed tuple",
        "labels":  [
                       "api-suggestion",
                       "area-System.Threading.Tasks",
                       "needs-further-triage"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/102387",
        "createdAt":  "2024-05-17T16:59:31Z",
        "number":  102387,
        "author":  "ShadedBlink",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOC4Crxg==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "ShadedBlink",
                                            "createdAt":  "2024-05-17T17:04:41Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "kronic",
                                            "createdAt":  "2024-05-19T10:45:13Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "ufcpp",
                                            "createdAt":  "2024-05-19T12:38:20Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "colejohnson66",
                                            "createdAt":  "2024-05-21T10:20:36Z"
                                        }
                                    ],
                          "totalCount":  4
                      },
        "updatedAt":  "2025-07-14T18:19:46Z",
        "body":  "### Background and motivation\r\n\r\nWe got new `ValueTask` types earlier in .Net Core to avoid unnecessary allocations. It covered cases for synchronously-completed tasks and reusable task states. Also we got a new `IValueTaskSource` interface to develop such reusable tasks. Now it is time to reduce number of allocated objects per task.\r\nToday `await` supports only single `Awaiter.OnCompleted()` implementation that requires an instance of `Action` per continuation. This requires us to have an `Action` allocated per instance of task. We can avoid such allocation if we expand `IValueTaskSource.OnCompleted()` way of continuation on `Task` type, i.e. static delegate with continuation state. Static delegate is supposed to be singleton, while asyncState should represent the parent `AsyncStateMachine` that awaits this task.\r\nAccording to the source code, `Task` creates a new object for continuation to capture contexts or saves initial continuation `Action` otherwise. Since a new object is created anyway, we can just append it with a new field of state.\r\nSuch overload works totally fine with existing `TaskAwaiter.OnCompleted()`, since old overload now becomes just a wrapper to call new overload - it is exactly the same way `ValueTaskAwaiter.OnCompleted` works when created from `IValueTaskSource`.\r\n\r\n### API Proposal\r\n\r\nIn basic terms, it is enough to just copy `IValueTaskSource.OnCompleted()` method to `TaskAwaiter` class. It is up to dotnet developers on what to do with `flags` parameter, but I think it would be nice to keep signature closer to `IValueTaskSource` so `ValueTaskAwaiter` won\u0027t need some difficult logic to convert its requests to `TaskAwaiter` signature. **This method should be public**.\r\n```diff\r\nnamespace System.Threading.Tasks;\r\n\r\npublic readonly struct TaskAwaiter\u003cTResult\u003e : ICriticalNotifyCompletion, ITaskAwaiter {\r\n    public void OnCompleted(Action continuation); // Just replace with inline call to new method.\r\n    public void UnsafeOnCompleted(Action continuation); // Just replace with inline call to new method.\r\n+   public void OnCompleted(Action\u003cobject?\u003e continuation, object? state, ValueTaskSourceOnCompletedFlags flags);\r\n}\r\n\r\npublic readonly struct ValueTaskAwaiter\u003cTResult\u003e : ICriticalNotifyCompletion, ITaskAwaiter {\r\n    public void OnCompleted(Action continuation); // Just replace with inline call to new method.\r\n    public void UnsafeOnCompleted(Action continuation); // Just replace with inline call to new method.\r\n+   public void OnCompleted(Action\u003cobject?\u003e continuation, object? state, ValueTaskSourceOnCompletedFlags flags);\r\n}\r\n```\r\n\r\n\r\n### API Usage\r\n\r\nIn first place this API will work out-of-the-box since it changes internal implementation of task awaiters. Also this API now allows us to write proxy IValueTaskSource that can subscribe its external continuations to other tasks directly without need to allocate new delegate.\r\n```csharp\r\npublic class ProxyTask : IValueTaskSource {\r\n\tprivate readonly Task task;\r\n\r\n\tpublic void OnCompleted(Action\u003cobject?\u003e continuation, object? state, short token, ValueTaskSourceOnCompletedFlags flags)\r\n\t\t=\u003e task.GetAwaiter().OnCompleted(continuation, state, flags);\r\n}\r\n```\r\n\r\n\r\n### Alternative Designs\r\n\r\n_No response_\r\n\r\n### Risks\r\n\r\nThese changes don\u0027t interfere with any existing API so there are no breaking changes.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOflMqoA==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5-PqC-",
                                           "createdAt":  "2024-05-17T17:10:37Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "Can you please share a repro showing the allocation you\u0027re concerned about? If in your Task/ValueTask-returning async method the only thing you await are Task or ValueTask, no Action will be allocated to pass to OnCompleted because that mechanism gets bypassed. Are you seeing otherwise? In most async methods now then, there\u0027s at most one allocation for the entirety of the lifecycle, for the task itself if the method completes asynchronously.",
                                           "updatedAt":  "2024-05-17T17:10:37Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5-T--g",
                                           "createdAt":  "2024-05-19T09:27:49Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ShadedBlink",
                                           "body":  "@stephentoub  Here is a heap snapshot showing dead objects count(alive count is 36 for `Action` and 2 for marked state machine box). Application is consequently reading HDD by 1MB batches, thus having thousands of long(not synchronously completed) tasks. You can see that number of `Action` instances is very close to number of `AsyncStateMachineBox` instances. Actually, every `AsyncStateMachineBox` has initialized `MoveNextAction` because of asynchronous completion. It is intended by [current design](https://source.dot.net/#System.Private.CoreLib/src/libraries/System.Private.CoreLib/src/System/Runtime/CompilerServices/IAsyncStateMachineBox.cs,49a5a61226906acf), and it is exactly what I propose to change. Current `OnCompleted()` method doesn\u0027t allow us to go async without creation of such continuation actions.\r\n![Heap snapshot](https://github.com/dotnet/runtime/assets/40367408/e2e10c8e-0129-4140-89f7-3029ea0bba88)\r\nYou can mark that `ValueTask` allows us to use `IValueTaskSource` pooling, so I have to pool this task, but it is not global-applicable. More complex applications can have thousands async methods or async method chains including generics, We can\u0027t mark every `ValueTask` method with such builder attribute since it requires a lot of refactoring and memory to store cached states. On the contrary if we get gid of those excessive action allocations, it will impact every async method instantly since we cover different methods in same approach and don\u0027t need any allocations.",
                                           "updatedAt":  "2024-05-19T10:44:13Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5-T_mX",
                                           "createdAt":  "2024-05-19T09:37:03Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ShadedBlink",
                                           "body":  "By the way, mentioned method returns `ValueTask` and awaits only `ValueTask`. No direct `Task` involvement.",
                                           "updatedAt":  "2024-05-19T09:37:13Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5-UAeh",
                                           "createdAt":  "2024-05-19T09:51:36Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ShadedBlink",
                                           "body":  "@stephentoub I got a great reproduction code for you to test it out. Same case, 36 alive `Action` instances. There obviously would be only one alive box in any time. However, every box has initialized `MoveNextAction`. In both cases with previously mentioned method the `Action` count grows up constantly in same pace with boxes count.\r\nDefault console app, net8.0, release configuration.\r\n![Heap](https://github.com/dotnet/runtime/assets/40367408/ea8bedce-4d77-4798-adac-0ffbc64acdd9)\r\n```\r\n\tprivate static async ValueTask DummyMethodAsync() {\r\n\t\tawait Task.Delay(1);\r\n\t}\r\n\r\n\tinternal static async Task Main(string[] args) {\r\n\t\twhile (true) {\r\n\t\t\tawait DummyMethodAsync();\r\n\t\t}\r\n        }\r\n```\r\n",
                                           "updatedAt":  "2024-05-19T09:51:36Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5-UL_7",
                                           "createdAt":  "2024-05-19T12:33:19Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "What are you using to profile? I suspect it\u0027s enabling ETW events for TPL, which will cause there to be extra allocations. What\u0027s the backtrace of those objects? ",
                                           "updatedAt":  "2024-05-19T12:33:19Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5-UTue",
                                           "createdAt":  "2024-05-19T14:13:18Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "In https://devblogs.microsoft.com/dotnet/how-async-await-really-works/, search for \"That was .NET Framework. This is .NET Core:\", and you\u0027ll see a profile screenshot showing no Action allocations and an explanation for why.",
                                           "updatedAt":  "2024-05-19T14:13:18Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5-UlI_",
                                           "createdAt":  "2024-05-19T18:35:34Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ShadedBlink",
                                           "body":  "Yes, it seems that visual studio debugger really was the reason why those actions were initialized. Yet it still doesn\u0027t cover `IValueTaskSource` case.\r\nI have a class `Writer` that is used for double buffered writes to hdd. It has two internal buffers. When somebody writes to `Writer`, all data is copied to first buffer, then, when first buffer is full, data is going to second buffer, while first buffer is being flushed. If second buffer is already being flushed, then write method has to wait before flush operation is completed. The `Writer` class is a `IValueTaskSource`, but it doesn\u0027t need internal async subscription logic - it always has to wait for(and only for) internal tasks that are created from `RandomAccess.WriteAsync()`. I can\u0027t passthrough external continuation to internal task since `IValueTaskSource` gets a static delegate with state, while public task API allows only task-specific continuations. Of course, I can create a new continuation `Action` per `Writer` instance, but it still looks totally excessive. We already have right working implementation in `ValueTask`, we just need to expand it to `Task`.",
                                           "updatedAt":  "2024-05-19T18:35:34Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5-UlTp",
                                           "createdAt":  "2024-05-19T18:38:17Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ShadedBlink",
                                           "body":  "As you already mentioned, actual implementation is okay only with `Task` and `ValueTask`-returning implementation. What I ask you for is to allow `IValueTaskSource` implementations await such tasks without need for continuation `Action` as well.",
                                           "updatedAt":  "2024-05-19T18:38:17Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5-Ul9B",
                                           "createdAt":  "2024-05-19T18:50:22Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "davidfowl",
                                           "body":  "A code sample of what you\u0027re doing and what you want to do in context would be great. I think I know what you\u0027re getting at with the proxy task scenario but a more spelled out code sample would make it crystal clear. Also, this does not feel like a mainstream scenario.",
                                           "updatedAt":  "2024-05-19T18:50:22Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5-UmYg",
                                           "createdAt":  "2024-05-19T18:58:29Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e As you already mentioned, actual implementation is okay only with `Task` and `ValueTask`-returning implementation. What I ask you for is to allow `IValueTaskSource` implementations await such tasks without need for continuation `Action` as well.\r\n\r\nTask has a single reference for storing a continuation, either directly or in a List of them.  If a consumer were to supply a delegate and associated object in order to avoid allocating a wrapper, Task itself would then need to allocate the same wrapper.",
                                           "updatedAt":  "2024-05-19T18:58:29Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5-UqMv",
                                           "createdAt":  "2024-05-19T20:03:54Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ShadedBlink",
                                           "body":  "@davidfowl , I am sorry, but I don\u0027t have public available code for that.\r\n@stephentoub , what about an interface like a `IThreadPoolWorkItem`? Let\u0027s say some `IAsyncContinuation` with single method `void Execute()`. Then `IValueTaskSource` can just implement such interface. Thus we still have single object, but don\u0027t need allocation of neither an `Action` nor any state wrappers. `Task` internally would store an `object`, which may be either `Action` or `IAsyncContinuation`. This approach is compatible for `IValueTaskSource.OnCompleted()` as well.",
                                           "updatedAt":  "2024-05-19T20:05:16Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5-UsHS",
                                           "createdAt":  "2024-05-19T20:36:45Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "Can you please share a more complete sample of the code you\u0027re hoping to be able to write, including an implementation of said interface and what the consumer of it would look like?",
                                           "updatedAt":  "2024-05-19T20:36:45Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5-Uyqg",
                                           "createdAt":  "2024-05-19T22:27:53Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ShadedBlink",
                                           "body":  "Example code(user code):\r\n```csharp\r\ninternal class ProxyValueTaskSource : IValueTaskSource, IAsyncContinuation {\r\n\tprivate ValueTask task;\r\n\tprivate ManualResetValueTaskSourceCore\u003cint\u003e continuationStore;\r\n\r\n\tpublic ProxyValueTaskSource() {\r\n\t\tcontinuationStore = new ManualResetValueTaskSourceCore\u003cint\u003e() {\r\n\t\t\tRunContinuationsAsynchronously = false\r\n\t\t};\r\n\t}\r\n\r\n\tpublic void Init(ValueTask task) {\r\n\t\tcontinuationStore.Reset();\r\n\t\tthis.task = task;\r\n\t\t// Some synchronous work that we want to perform when task completion is not required yet.\r\n\t}\r\n\r\n\tpublic void Execute() {\r\n\t\tcontinuationStore.SetResult(0); // Just invoke our external continuation inline.\r\n\t}\r\n\tpublic void GetResult(short token) {\r\n\t\t// Some synchronous work that we want to perform when task is completed.\r\n\t\ttask.GetAwaiter().GetResult();\r\n\t}\r\n\tpublic ValueTaskSourceStatus GetStatus(short token)\r\n\t\t// Doesn\u0027t matter now.\r\n\t\t=\u003e task.IsCompletedSuccessfully ? ValueTaskSourceStatus.Succeeded : ValueTaskSourceStatus.Pending;\r\n\tpublic void OnCompleted(Action\u003cobject?\u003e continuation, object? state, short token, ValueTaskSourceOnCompletedFlags flags) {\r\n\t\t// Store external continuation.\r\n\t\tcontinuationStore.OnCompleted(continuation, state, token, flags);\r\n\t\t// Subscribe to internal task.\r\n\t\ttask.GetAwaiter().OnCompleted(this);\r\n\t}\r\n}\r\n```\r\n\r\nInterface code(.NET code):\r\n```csharp\r\npublic interface IAsyncContinuation\r\n{\r\n\tvoid Execute();\r\n}\r\n```\r\n\r\nExpected changes to .NET:\r\n- Add overload `TaskAwaiter.UnsafeOnCompleted(IAsyncContinuation continuation)`. It should work the same, i.e. just pass parameter to `OnCompletedInternal`.\r\n- Change [OnCompletedInternal](https://source.dot.net/System.Private.CoreLib/R/708f9e4158bf1cd3.html) signature: `Action continuation` -\u003e `object continuation`. `object` there is guaranteed to be either `IAsyncContinuation` or `Action`.\r\n- Change [SetContinuationForAwait](https://source.dot.net/System.Private.CoreLib/R/9f0f91d1f68a033c.html) signature: `Action continuationAction` -\u003e `object continuationAction`.\r\n- Update all context wrapper types to support both `Action` or `IAsyncContinuation` type by changing continuation type to `object`.\r\n- [AddTaskContinuation](https://source.dot.net/System.Private.CoreLib/R/362aeac530811357.html) and continuation store variables already declare `object` type for continuation type since there may be context wrappers as well as direct `Action` continuations.\r\n- Add case in [RunContinuations](https://source.dot.net/System.Private.CoreLib/R/3d1b2d7e6ac96ada.html) for `IAsyncContinuation`.",
                                           "updatedAt":  "2024-05-19T22:27:53Z"
                                       }
                                   ],
                         "totalCount":  13
                     },
        "title":  "[API Proposal]: Add TaskAwaiter.OnCompleted() overload to support static delegates.",
        "labels":  [
                       "api-suggestion",
                       "area-System.Threading.Tasks",
                       "needs-further-triage"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/109729",
        "createdAt":  "2024-11-12T15:59:38Z",
        "number":  109729,
        "author":  "VeeraraghavanSrinivasan",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-07-14T18:22:14Z",
        "body":  "\n\u003chtml xmlns:v=\"urn:schemas-microsoft-com:vml\"\nxmlns:o=\"urn:schemas-microsoft-com:office:office\"\nxmlns:w=\"urn:schemas-microsoft-com:office:word\"\nxmlns:x=\"urn:schemas-microsoft-com:office:excel\"\nxmlns:m=\"http://schemas.microsoft.com/office/2004/12/omml\"\nxmlns=\"http://www.w3.org/TR/REC-html40\"\u003e\n\n\u003chead\u003e\n\n\u003cmeta name=ProgId content=Word.Document\u003e\n\u003cmeta name=Generator content=\"Microsoft Word 15\"\u003e\n\u003cmeta name=Originator content=\"Microsoft Word 15\"\u003e\n\u003clink rel=File-List\nhref=\"file:///C:/Users/vesriniv/AppData/Local/Temp/1/msohtmlclip1/01/clip_filelist.xml\"\u003e\n\u003c!--[if gte mso 9]\u003e\u003cxml\u003e\n \u003co:OfficeDocumentSettings\u003e\n  \u003co:AllowPNG/\u003e\n \u003c/o:OfficeDocumentSettings\u003e\n\u003c/xml\u003e\u003c![endif]--\u003e\n\u003clink rel=themeData\nhref=\"file:///C:/Users/vesriniv/AppData/Local/Temp/1/msohtmlclip1/01/clip_themedata.thmx\"\u003e\n\u003clink rel=colorSchemeMapping\nhref=\"file:///C:/Users/vesriniv/AppData/Local/Temp/1/msohtmlclip1/01/clip_colorschememapping.xml\"\u003e\n\u003c!--[if gte mso 9]\u003e\u003cxml\u003e\n \u003cw:WordDocument\u003e\n  \u003cw:View\u003eNormal\u003c/w:View\u003e\n  \u003cw:Zoom\u003e0\u003c/w:Zoom\u003e\n  \u003cw:TrackMoves/\u003e\n  \u003cw:TrackFormatting/\u003e\n  \u003cw:PunctuationKerning/\u003e\n  \u003cw:ValidateAgainstSchemas/\u003e\n  \u003cw:SaveIfXMLInvalid\u003efalse\u003c/w:SaveIfXMLInvalid\u003e\n  \u003cw:IgnoreMixedContent\u003efalse\u003c/w:IgnoreMixedContent\u003e\n  \u003cw:AlwaysShowPlaceholderText\u003efalse\u003c/w:AlwaysShowPlaceholderText\u003e\n  \u003cw:DoNotPromoteQF/\u003e\n  \u003cw:LidThemeOther\u003eEN-GB\u003c/w:LidThemeOther\u003e\n  \u003cw:LidThemeAsian\u003eX-NONE\u003c/w:LidThemeAsian\u003e\n  \u003cw:LidThemeComplexScript\u003eX-NONE\u003c/w:LidThemeComplexScript\u003e\n  \u003cw:Compatibility\u003e\n   \u003cw:BreakWrappedTables/\u003e\n   \u003cw:SnapToGridInCell/\u003e\n   \u003cw:WrapTextWithPunct/\u003e\n   \u003cw:UseAsianBreakRules/\u003e\n   \u003cw:DontGrowAutofit/\u003e\n   \u003cw:SplitPgBreakAndParaMark/\u003e\n   \u003cw:EnableOpenTypeKerning/\u003e\n   \u003cw:DontFlipMirrorIndents/\u003e\n   \u003cw:OverrideTableStyleHps/\u003e\n  \u003c/w:Compatibility\u003e\n  \u003cm:mathPr\u003e\n   \u003cm:mathFont m:val=\"Cambria Math\"/\u003e\n   \u003cm:brkBin m:val=\"before\"/\u003e\n   \u003cm:brkBinSub m:val=\"\u0026#45;-\"/\u003e\n   \u003cm:smallFrac m:val=\"off\"/\u003e\n   \u003cm:dispDef/\u003e\n   \u003cm:lMargin m:val=\"0\"/\u003e\n   \u003cm:rMargin m:val=\"0\"/\u003e\n   \u003cm:defJc m:val=\"centerGroup\"/\u003e\n   \u003cm:wrapIndent m:val=\"1440\"/\u003e\n   \u003cm:intLim m:val=\"subSup\"/\u003e\n   \u003cm:naryLim m:val=\"undOvr\"/\u003e\n  \u003c/m:mathPr\u003e\u003c/w:WordDocument\u003e\n\u003c/xml\u003e\u003c![endif]--\u003e\u003c!--[if gte mso 9]\u003e\u003cxml\u003e\n \u003cw:LatentStyles DefLockedState=\"false\" DefUnhideWhenUsed=\"false\"\n  DefSemiHidden=\"false\" DefQFormat=\"false\" DefPriority=\"99\"\n  LatentStyleCount=\"376\"\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"0\" QFormat=\"true\" Name=\"Normal\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"9\" QFormat=\"true\" Name=\"heading 1\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"9\" SemiHidden=\"true\"\n   UnhideWhenUsed=\"true\" QFormat=\"true\" Name=\"heading 2\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"9\" SemiHidden=\"true\"\n   UnhideWhenUsed=\"true\" QFormat=\"true\" Name=\"heading 3\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"9\" SemiHidden=\"true\"\n   UnhideWhenUsed=\"true\" QFormat=\"true\" Name=\"heading 4\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"9\" SemiHidden=\"true\"\n   UnhideWhenUsed=\"true\" QFormat=\"true\" Name=\"heading 5\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"9\" SemiHidden=\"true\"\n   UnhideWhenUsed=\"true\" QFormat=\"true\" Name=\"heading 6\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"9\" SemiHidden=\"true\"\n   UnhideWhenUsed=\"true\" QFormat=\"true\" Name=\"heading 7\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"9\" SemiHidden=\"true\"\n   UnhideWhenUsed=\"true\" QFormat=\"true\" Name=\"heading 8\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"9\" SemiHidden=\"true\"\n   UnhideWhenUsed=\"true\" QFormat=\"true\" Name=\"heading 9\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"index 1\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"index 2\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"index 3\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"index 4\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"index 5\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"index 6\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"index 7\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"index 8\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"index 9\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"39\" SemiHidden=\"true\"\n   UnhideWhenUsed=\"true\" Name=\"toc 1\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"39\" SemiHidden=\"true\"\n   UnhideWhenUsed=\"true\" Name=\"toc 2\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"39\" SemiHidden=\"true\"\n   UnhideWhenUsed=\"true\" Name=\"toc 3\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"39\" SemiHidden=\"true\"\n   UnhideWhenUsed=\"true\" Name=\"toc 4\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"39\" SemiHidden=\"true\"\n   UnhideWhenUsed=\"true\" Name=\"toc 5\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"39\" SemiHidden=\"true\"\n   UnhideWhenUsed=\"true\" Name=\"toc 6\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"39\" SemiHidden=\"true\"\n   UnhideWhenUsed=\"true\" Name=\"toc 7\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"39\" SemiHidden=\"true\"\n   UnhideWhenUsed=\"true\" Name=\"toc 8\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"39\" SemiHidden=\"true\"\n   UnhideWhenUsed=\"true\" Name=\"toc 9\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"Normal Indent\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"footnote text\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"annotation text\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"header\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"footer\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"index heading\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"35\" SemiHidden=\"true\"\n   UnhideWhenUsed=\"true\" QFormat=\"true\" Name=\"caption\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"table of figures\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"envelope address\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"envelope return\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"footnote reference\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"annotation reference\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"line number\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"page number\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"endnote reference\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"endnote text\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"table of authorities\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"macro\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"toa heading\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"List\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"List Bullet\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"List Number\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"List 2\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"List 3\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"List 4\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"List 5\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"List Bullet 2\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"List Bullet 3\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"List Bullet 4\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"List Bullet 5\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"List Number 2\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"List Number 3\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"List Number 4\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"List Number 5\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"10\" QFormat=\"true\" Name=\"Title\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"Closing\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"Signature\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"1\" SemiHidden=\"true\"\n   UnhideWhenUsed=\"true\" Name=\"Default Paragraph Font\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"Body Text\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"Body Text Indent\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"List Continue\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"List Continue 2\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"List Continue 3\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"List Continue 4\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"List Continue 5\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"Message Header\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"11\" QFormat=\"true\" Name=\"Subtitle\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"Salutation\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"Date\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"Body Text First Indent\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"Body Text First Indent 2\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"Note Heading\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"Body Text 2\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"Body Text 3\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"Body Text Indent 2\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"Body Text Indent 3\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"Block Text\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"Hyperlink\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"FollowedHyperlink\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"22\" QFormat=\"true\" Name=\"Strong\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"20\" QFormat=\"true\" Name=\"Emphasis\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"Document Map\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"Plain Text\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"E-mail Signature\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"HTML Top of Form\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"HTML Bottom of Form\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"Normal (Web)\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"HTML Acronym\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"HTML Address\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"HTML Cite\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"HTML Code\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"HTML Definition\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"HTML Keyboard\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"HTML Preformatted\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"HTML Sample\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"HTML Typewriter\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"HTML Variable\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"Normal Table\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"annotation subject\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"No List\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"Outline List 1\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"Outline List 2\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"Outline List 3\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"Table Simple 1\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"Table Simple 2\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"Table Simple 3\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"Table Classic 1\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"Table Classic 2\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"Table Classic 3\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"Table Classic 4\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"Table Colorful 1\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"Table Colorful 2\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"Table Colorful 3\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"Table Columns 1\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"Table Columns 2\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"Table Columns 3\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"Table Columns 4\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"Table Columns 5\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"Table Grid 1\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"Table Grid 2\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"Table Grid 3\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"Table Grid 4\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"Table Grid 5\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"Table Grid 6\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"Table Grid 7\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"Table Grid 8\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"Table List 1\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"Table List 2\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"Table List 3\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"Table List 4\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"Table List 5\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"Table List 6\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"Table List 7\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"Table List 8\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"Table 3D effects 1\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"Table 3D effects 2\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"Table 3D effects 3\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"Table Contemporary\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"Table Elegant\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"Table Professional\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"Table Subtle 1\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"Table Subtle 2\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"Table Web 1\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"Table Web 2\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"Table Web 3\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"Balloon Text\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"39\" Name=\"Table Grid\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"Table Theme\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" Name=\"Placeholder Text\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"1\" QFormat=\"true\" Name=\"No Spacing\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"60\" Name=\"Light Shading\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"61\" Name=\"Light List\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"62\" Name=\"Light Grid\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"63\" Name=\"Medium Shading 1\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"64\" Name=\"Medium Shading 2\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"65\" Name=\"Medium List 1\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"66\" Name=\"Medium List 2\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"67\" Name=\"Medium Grid 1\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"68\" Name=\"Medium Grid 2\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"69\" Name=\"Medium Grid 3\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"70\" Name=\"Dark List\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"71\" Name=\"Colorful Shading\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"72\" Name=\"Colorful List\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"73\" Name=\"Colorful Grid\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"60\" Name=\"Light Shading Accent 1\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"61\" Name=\"Light List Accent 1\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"62\" Name=\"Light Grid Accent 1\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"63\" Name=\"Medium Shading 1 Accent 1\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"64\" Name=\"Medium Shading 2 Accent 1\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"65\" Name=\"Medium List 1 Accent 1\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" Name=\"Revision\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"34\" QFormat=\"true\"\n   Name=\"List Paragraph\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"29\" QFormat=\"true\" Name=\"Quote\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"30\" QFormat=\"true\"\n   Name=\"Intense Quote\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"66\" Name=\"Medium List 2 Accent 1\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"67\" Name=\"Medium Grid 1 Accent 1\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"68\" Name=\"Medium Grid 2 Accent 1\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"69\" Name=\"Medium Grid 3 Accent 1\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"70\" Name=\"Dark List Accent 1\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"71\" Name=\"Colorful Shading Accent 1\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"72\" Name=\"Colorful List Accent 1\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"73\" Name=\"Colorful Grid Accent 1\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"60\" Name=\"Light Shading Accent 2\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"61\" Name=\"Light List Accent 2\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"62\" Name=\"Light Grid Accent 2\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"63\" Name=\"Medium Shading 1 Accent 2\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"64\" Name=\"Medium Shading 2 Accent 2\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"65\" Name=\"Medium List 1 Accent 2\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"66\" Name=\"Medium List 2 Accent 2\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"67\" Name=\"Medium Grid 1 Accent 2\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"68\" Name=\"Medium Grid 2 Accent 2\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"69\" Name=\"Medium Grid 3 Accent 2\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"70\" Name=\"Dark List Accent 2\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"71\" Name=\"Colorful Shading Accent 2\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"72\" Name=\"Colorful List Accent 2\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"73\" Name=\"Colorful Grid Accent 2\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"60\" Name=\"Light Shading Accent 3\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"61\" Name=\"Light List Accent 3\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"62\" Name=\"Light Grid Accent 3\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"63\" Name=\"Medium Shading 1 Accent 3\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"64\" Name=\"Medium Shading 2 Accent 3\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"65\" Name=\"Medium List 1 Accent 3\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"66\" Name=\"Medium List 2 Accent 3\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"67\" Name=\"Medium Grid 1 Accent 3\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"68\" Name=\"Medium Grid 2 Accent 3\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"69\" Name=\"Medium Grid 3 Accent 3\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"70\" Name=\"Dark List Accent 3\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"71\" Name=\"Colorful Shading Accent 3\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"72\" Name=\"Colorful List Accent 3\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"73\" Name=\"Colorful Grid Accent 3\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"60\" Name=\"Light Shading Accent 4\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"61\" Name=\"Light List Accent 4\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"62\" Name=\"Light Grid Accent 4\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"63\" Name=\"Medium Shading 1 Accent 4\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"64\" Name=\"Medium Shading 2 Accent 4\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"65\" Name=\"Medium List 1 Accent 4\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"66\" Name=\"Medium List 2 Accent 4\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"67\" Name=\"Medium Grid 1 Accent 4\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"68\" Name=\"Medium Grid 2 Accent 4\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"69\" Name=\"Medium Grid 3 Accent 4\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"70\" Name=\"Dark List Accent 4\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"71\" Name=\"Colorful Shading Accent 4\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"72\" Name=\"Colorful List Accent 4\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"73\" Name=\"Colorful Grid Accent 4\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"60\" Name=\"Light Shading Accent 5\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"61\" Name=\"Light List Accent 5\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"62\" Name=\"Light Grid Accent 5\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"63\" Name=\"Medium Shading 1 Accent 5\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"64\" Name=\"Medium Shading 2 Accent 5\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"65\" Name=\"Medium List 1 Accent 5\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"66\" Name=\"Medium List 2 Accent 5\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"67\" Name=\"Medium Grid 1 Accent 5\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"68\" Name=\"Medium Grid 2 Accent 5\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"69\" Name=\"Medium Grid 3 Accent 5\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"70\" Name=\"Dark List Accent 5\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"71\" Name=\"Colorful Shading Accent 5\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"72\" Name=\"Colorful List Accent 5\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"73\" Name=\"Colorful Grid Accent 5\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"60\" Name=\"Light Shading Accent 6\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"61\" Name=\"Light List Accent 6\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"62\" Name=\"Light Grid Accent 6\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"63\" Name=\"Medium Shading 1 Accent 6\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"64\" Name=\"Medium Shading 2 Accent 6\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"65\" Name=\"Medium List 1 Accent 6\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"66\" Name=\"Medium List 2 Accent 6\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"67\" Name=\"Medium Grid 1 Accent 6\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"68\" Name=\"Medium Grid 2 Accent 6\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"69\" Name=\"Medium Grid 3 Accent 6\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"70\" Name=\"Dark List Accent 6\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"71\" Name=\"Colorful Shading Accent 6\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"72\" Name=\"Colorful List Accent 6\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"73\" Name=\"Colorful Grid Accent 6\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"19\" QFormat=\"true\"\n   Name=\"Subtle Emphasis\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"21\" QFormat=\"true\"\n   Name=\"Intense Emphasis\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"31\" QFormat=\"true\"\n   Name=\"Subtle Reference\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"32\" QFormat=\"true\"\n   Name=\"Intense Reference\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"33\" QFormat=\"true\" Name=\"Book Title\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"37\" SemiHidden=\"true\"\n   UnhideWhenUsed=\"true\" Name=\"Bibliography\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"39\" SemiHidden=\"true\"\n   UnhideWhenUsed=\"true\" QFormat=\"true\" Name=\"TOC Heading\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"41\" Name=\"Plain Table 1\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"42\" Name=\"Plain Table 2\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"43\" Name=\"Plain Table 3\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"44\" Name=\"Plain Table 4\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"45\" Name=\"Plain Table 5\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"40\" Name=\"Grid Table Light\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"46\" Name=\"Grid Table 1 Light\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"47\" Name=\"Grid Table 2\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"48\" Name=\"Grid Table 3\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"49\" Name=\"Grid Table 4\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"50\" Name=\"Grid Table 5 Dark\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"51\" Name=\"Grid Table 6 Colorful\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"52\" Name=\"Grid Table 7 Colorful\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"46\"\n   Name=\"Grid Table 1 Light Accent 1\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"47\" Name=\"Grid Table 2 Accent 1\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"48\" Name=\"Grid Table 3 Accent 1\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"49\" Name=\"Grid Table 4 Accent 1\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"50\" Name=\"Grid Table 5 Dark Accent 1\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"51\"\n   Name=\"Grid Table 6 Colorful Accent 1\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"52\"\n   Name=\"Grid Table 7 Colorful Accent 1\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"46\"\n   Name=\"Grid Table 1 Light Accent 2\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"47\" Name=\"Grid Table 2 Accent 2\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"48\" Name=\"Grid Table 3 Accent 2\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"49\" Name=\"Grid Table 4 Accent 2\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"50\" Name=\"Grid Table 5 Dark Accent 2\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"51\"\n   Name=\"Grid Table 6 Colorful Accent 2\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"52\"\n   Name=\"Grid Table 7 Colorful Accent 2\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"46\"\n   Name=\"Grid Table 1 Light Accent 3\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"47\" Name=\"Grid Table 2 Accent 3\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"48\" Name=\"Grid Table 3 Accent 3\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"49\" Name=\"Grid Table 4 Accent 3\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"50\" Name=\"Grid Table 5 Dark Accent 3\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"51\"\n   Name=\"Grid Table 6 Colorful Accent 3\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"52\"\n   Name=\"Grid Table 7 Colorful Accent 3\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"46\"\n   Name=\"Grid Table 1 Light Accent 4\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"47\" Name=\"Grid Table 2 Accent 4\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"48\" Name=\"Grid Table 3 Accent 4\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"49\" Name=\"Grid Table 4 Accent 4\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"50\" Name=\"Grid Table 5 Dark Accent 4\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"51\"\n   Name=\"Grid Table 6 Colorful Accent 4\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"52\"\n   Name=\"Grid Table 7 Colorful Accent 4\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"46\"\n   Name=\"Grid Table 1 Light Accent 5\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"47\" Name=\"Grid Table 2 Accent 5\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"48\" Name=\"Grid Table 3 Accent 5\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"49\" Name=\"Grid Table 4 Accent 5\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"50\" Name=\"Grid Table 5 Dark Accent 5\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"51\"\n   Name=\"Grid Table 6 Colorful Accent 5\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"52\"\n   Name=\"Grid Table 7 Colorful Accent 5\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"46\"\n   Name=\"Grid Table 1 Light Accent 6\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"47\" Name=\"Grid Table 2 Accent 6\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"48\" Name=\"Grid Table 3 Accent 6\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"49\" Name=\"Grid Table 4 Accent 6\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"50\" Name=\"Grid Table 5 Dark Accent 6\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"51\"\n   Name=\"Grid Table 6 Colorful Accent 6\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"52\"\n   Name=\"Grid Table 7 Colorful Accent 6\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"46\" Name=\"List Table 1 Light\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"47\" Name=\"List Table 2\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"48\" Name=\"List Table 3\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"49\" Name=\"List Table 4\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"50\" Name=\"List Table 5 Dark\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"51\" Name=\"List Table 6 Colorful\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"52\" Name=\"List Table 7 Colorful\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"46\"\n   Name=\"List Table 1 Light Accent 1\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"47\" Name=\"List Table 2 Accent 1\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"48\" Name=\"List Table 3 Accent 1\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"49\" Name=\"List Table 4 Accent 1\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"50\" Name=\"List Table 5 Dark Accent 1\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"51\"\n   Name=\"List Table 6 Colorful Accent 1\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"52\"\n   Name=\"List Table 7 Colorful Accent 1\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"46\"\n   Name=\"List Table 1 Light Accent 2\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"47\" Name=\"List Table 2 Accent 2\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"48\" Name=\"List Table 3 Accent 2\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"49\" Name=\"List Table 4 Accent 2\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"50\" Name=\"List Table 5 Dark Accent 2\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"51\"\n   Name=\"List Table 6 Colorful Accent 2\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"52\"\n   Name=\"List Table 7 Colorful Accent 2\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"46\"\n   Name=\"List Table 1 Light Accent 3\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"47\" Name=\"List Table 2 Accent 3\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"48\" Name=\"List Table 3 Accent 3\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"49\" Name=\"List Table 4 Accent 3\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"50\" Name=\"List Table 5 Dark Accent 3\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"51\"\n   Name=\"List Table 6 Colorful Accent 3\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"52\"\n   Name=\"List Table 7 Colorful Accent 3\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"46\"\n   Name=\"List Table 1 Light Accent 4\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"47\" Name=\"List Table 2 Accent 4\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"48\" Name=\"List Table 3 Accent 4\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"49\" Name=\"List Table 4 Accent 4\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"50\" Name=\"List Table 5 Dark Accent 4\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"51\"\n   Name=\"List Table 6 Colorful Accent 4\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"52\"\n   Name=\"List Table 7 Colorful Accent 4\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"46\"\n   Name=\"List Table 1 Light Accent 5\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"47\" Name=\"List Table 2 Accent 5\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"48\" Name=\"List Table 3 Accent 5\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"49\" Name=\"List Table 4 Accent 5\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"50\" Name=\"List Table 5 Dark Accent 5\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"51\"\n   Name=\"List Table 6 Colorful Accent 5\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"52\"\n   Name=\"List Table 7 Colorful Accent 5\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"46\"\n   Name=\"List Table 1 Light Accent 6\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"47\" Name=\"List Table 2 Accent 6\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"48\" Name=\"List Table 3 Accent 6\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"49\" Name=\"List Table 4 Accent 6\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"50\" Name=\"List Table 5 Dark Accent 6\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"51\"\n   Name=\"List Table 6 Colorful Accent 6\"/\u003e\n  \u003cw:LsdException Locked=\"false\" Priority=\"52\"\n   Name=\"List Table 7 Colorful Accent 6\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"Mention\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"Smart Hyperlink\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"Hashtag\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"Unresolved Mention\"/\u003e\n  \u003cw:LsdException Locked=\"false\" SemiHidden=\"true\" UnhideWhenUsed=\"true\"\n   Name=\"Smart Link\"/\u003e\n \u003c/w:LatentStyles\u003e\n\u003c/xml\u003e\u003c![endif]--\u003e\n\u003cstyle\u003e\n\u003c!--\n /* Font Definitions */\n @font-face\n\t{font-family:Wingdings;\n\tpanose-1:5 0 0 0 0 0 0 0 0 0;\n\tmso-font-charset:2;\n\tmso-generic-font-family:auto;\n\tmso-font-pitch:variable;\n\tmso-font-signature:0 268435456 0 0 -2147483648 0;}\n@font-face\n\t{font-family:\"Cambria Math\";\n\tpanose-1:2 4 5 3 5 4 6 3 2 4;\n\tmso-font-charset:0;\n\tmso-generic-font-family:roman;\n\tmso-font-pitch:variable;\n\tmso-font-signature:-536869121 1107305727 33554432 0 415 0;}\n@font-face\n\t{font-family:Calibri;\n\tpanose-1:2 15 5 2 2 2 4 3 2 4;\n\tmso-font-charset:0;\n\tmso-generic-font-family:swiss;\n\tmso-font-pitch:variable;\n\tmso-font-signature:-469750017 -1040178053 9 0 511 0;}\n@font-face\n\t{font-family:\"Cascadia Mono\";\n\tpanose-1:2 11 6 9 2 0 0 2 0 4;\n\tmso-font-charset:0;\n\tmso-generic-font-family:modern;\n\tmso-font-pitch:fixed;\n\tmso-font-signature:-1593824513 -1040123397 262176 0 511 0;}\n /* Style Definitions */\n p.MsoNormal, li.MsoNormal, div.MsoNormal\n\t{mso-style-unhide:no;\n\tmso-style-qformat:yes;\n\tmso-style-parent:\"\";\n\tmargin:0cm;\n\tmso-pagination:widow-orphan;\n\tfont-size:11.0pt;\n\tfont-family:\"Calibri\",sans-serif;\n\tmso-ascii-font-family:Calibri;\n\tmso-ascii-theme-font:minor-latin;\n\tmso-fareast-font-family:Calibri;\n\tmso-fareast-theme-font:minor-latin;\n\tmso-hansi-font-family:Calibri;\n\tmso-hansi-theme-font:minor-latin;\n\tmso-bidi-font-family:\"Times New Roman\";\n\tmso-bidi-theme-font:minor-bidi;\n\tmso-font-kerning:1.0pt;\n\tmso-ligatures:standardcontextual;\n\tmso-fareast-language:EN-US;}\np.MsoListParagraph, li.MsoListParagraph, div.MsoListParagraph\n\t{mso-style-priority:34;\n\tmso-style-unhide:no;\n\tmso-style-qformat:yes;\n\tmargin-top:0cm;\n\tmargin-right:0cm;\n\tmargin-bottom:0cm;\n\tmargin-left:36.0pt;\n\tmso-pagination:widow-orphan;\n\tfont-size:11.0pt;\n\tfont-family:\"Calibri\",sans-serif;\n\tmso-ascii-font-family:Calibri;\n\tmso-ascii-theme-font:minor-latin;\n\tmso-fareast-font-family:Calibri;\n\tmso-fareast-theme-font:minor-latin;\n\tmso-hansi-font-family:Calibri;\n\tmso-hansi-theme-font:minor-latin;\n\tmso-bidi-font-family:\"Times New Roman\";\n\tmso-bidi-theme-font:minor-bidi;\n\tmso-font-kerning:1.0pt;\n\tmso-ligatures:standardcontextual;\n\tmso-fareast-language:EN-US;}\nspan.EmailStyle15\n\t{mso-style-type:personal;\n\tmso-style-noshow:yes;\n\tmso-style-unhide:no;\n\tmso-ansi-font-size:11.0pt;\n\tmso-bidi-font-size:11.0pt;\n\tfont-family:\"Calibri\",sans-serif;\n\tmso-ascii-font-family:Calibri;\n\tmso-ascii-theme-font:minor-latin;\n\tmso-fareast-font-family:Calibri;\n\tmso-fareast-theme-font:minor-latin;\n\tmso-hansi-font-family:Calibri;\n\tmso-hansi-theme-font:minor-latin;\n\tmso-bidi-font-family:\"Times New Roman\";\n\tmso-bidi-theme-font:minor-bidi;\n\tcolor:windowtext;}\n.MsoChpDefault\n\t{mso-style-type:export-only;\n\tmso-default-props:yes;\n\tmso-ascii-font-family:Calibri;\n\tmso-ascii-theme-font:minor-latin;\n\tmso-fareast-font-family:Calibri;\n\tmso-fareast-theme-font:minor-latin;\n\tmso-hansi-font-family:Calibri;\n\tmso-hansi-theme-font:minor-latin;\n\tmso-bidi-font-family:\"Times New Roman\";\n\tmso-bidi-theme-font:minor-bidi;\n\tmso-fareast-language:EN-US;}\n@page WordSection1\n\t{size:612.0pt 792.0pt;\n\tmargin:72.0pt 72.0pt 72.0pt 72.0pt;\n\tmso-header-margin:36.0pt;\n\tmso-footer-margin:36.0pt;\n\tmso-paper-source:0;}\ndiv.WordSection1\n\t{page:WordSection1;}\n /* List Definitions */\n @list l0\n\t{mso-list-id:643899456;\n\tmso-list-type:hybrid;\n\tmso-list-template-ids:940575926 1575392016 134807555 134807557 134807553 134807555 134807557 134807553 134807555 134807557;}\n@list l0:level1\n\t{mso-level-start-at:0;\n\tmso-level-number-format:bullet;\n\tmso-level-text:;\n\tmso-level-tab-stop:none;\n\tmso-level-number-position:left;\n\ttext-indent:-18.0pt;\n\tfont-family:Symbol;\n\tmso-fareast-font-family:Calibri;\n\tmso-fareast-theme-font:minor-latin;\n\tmso-bidi-font-family:\"Times New Roman\";\n\tmso-bidi-theme-font:minor-bidi;}\n@list l0:level2\n\t{mso-level-number-format:bullet;\n\tmso-level-text:o;\n\tmso-level-tab-stop:none;\n\tmso-level-number-position:left;\n\ttext-indent:-18.0pt;\n\tfont-family:\"Courier New\";}\n@list l0:level3\n\t{mso-level-number-format:bullet;\n\tmso-level-text:;\n\tmso-level-tab-stop:none;\n\tmso-level-number-position:left;\n\ttext-indent:-18.0pt;\n\tfont-family:Wingdings;}\n@list l0:level4\n\t{mso-level-number-format:bullet;\n\tmso-level-text:;\n\tmso-level-tab-stop:none;\n\tmso-level-number-position:left;\n\ttext-indent:-18.0pt;\n\tfont-family:Symbol;}\n@list l0:level5\n\t{mso-level-number-format:bullet;\n\tmso-level-text:o;\n\tmso-level-tab-stop:none;\n\tmso-level-number-position:left;\n\ttext-indent:-18.0pt;\n\tfont-family:\"Courier New\";}\n@list l0:level6\n\t{mso-level-number-format:bullet;\n\tmso-level-text:;\n\tmso-level-tab-stop:none;\n\tmso-level-number-position:left;\n\ttext-indent:-18.0pt;\n\tfont-family:Wingdings;}\n@list l0:level7\n\t{mso-level-number-format:bullet;\n\tmso-level-text:;\n\tmso-level-tab-stop:none;\n\tmso-level-number-position:left;\n\ttext-indent:-18.0pt;\n\tfont-family:Symbol;}\n@list l0:level8\n\t{mso-level-number-format:bullet;\n\tmso-level-text:o;\n\tmso-level-tab-stop:none;\n\tmso-level-number-position:left;\n\ttext-indent:-18.0pt;\n\tfont-family:\"Courier New\";}\n@list l0:level9\n\t{mso-level-number-format:bullet;\n\tmso-level-text:;\n\tmso-level-tab-stop:none;\n\tmso-level-number-position:left;\n\ttext-indent:-18.0pt;\n\tfont-family:Wingdings;}\nol\n\t{margin-bottom:0cm;}\nul\n\t{margin-bottom:0cm;}\n--\u003e\n\u003c/style\u003e\n\u003c!--[if gte mso 10]\u003e\n\u003cstyle\u003e\n /* Style Definitions */\n table.MsoNormalTable\n\t{mso-style-name:\"Table Normal\";\n\tmso-tstyle-rowband-size:0;\n\tmso-tstyle-colband-size:0;\n\tmso-style-noshow:yes;\n\tmso-style-priority:99;\n\tmso-style-parent:\"\";\n\tmso-padding-alt:0cm 5.4pt 0cm 5.4pt;\n\tmso-para-margin:0cm;\n\tmso-pagination:widow-orphan;\n\tfont-size:11.0pt;\n\tfont-family:\"Calibri\",sans-serif;\n\tmso-ascii-font-family:Calibri;\n\tmso-ascii-theme-font:minor-latin;\n\tmso-hansi-font-family:Calibri;\n\tmso-hansi-theme-font:minor-latin;\n\tmso-bidi-font-family:\"Times New Roman\";\n\tmso-bidi-theme-font:minor-bidi;\n\tmso-font-kerning:1.0pt;\n\tmso-ligatures:standardcontextual;\n\tmso-fareast-language:EN-US;}\n\u003c/style\u003e\n\u003c![endif]--\u003e\n\u003c/head\u003e\n\n\u003cbody lang=EN-GB style=\u0027tab-interval:36.0pt;word-wrap:break-word\u0027\u003e\n\u003c!--StartFragment--\u003e\n\n\u003cp class=MsoNormal\u003e\u003co:p\u003e\u0026nbsp;\u003c/o:p\u003e\u003c/p\u003e\n\n\u003cp class=MsoNormal\u003e### Description\u003co:p\u003e\u003c/o:p\u003e\u003c/p\u003e\n\n\u003cp class=MsoNormal\u003e\u003co:p\u003e\u0026nbsp;\u003c/o:p\u003e\u003c/p\u003e\n\n\u003cp class=MsoNormal\u003eApplication logic:\u003co:p\u003e\u003c/o:p\u003e\u003c/p\u003e\n\n\u003cp class=MsoNormal\u003eWe have a simple application that picks up the messages from\nAzure Service bus and commits the messages to IBM WebSphere MQ (\u003cspan\nstyle=\u0027font-size:9.5pt;font-family:\"Cascadia Mono\";color:black;mso-font-kerning:\n0pt\u0027\u003eIBMMQDotnetClient v9.3 \u0026amp; v9.4)\u003c/span\u003e. \u003co:p\u003e\u003c/o:p\u003e\u003c/p\u003e\n\n\u003cp class=MsoNormal\u003eThe code has been running successfully in our production\nenvironment for more than a year without any issues. We recently upgraded the target\nframework to .NET 8 and have seen a significant slowness which in turn made us\nto roll back the solution to use .NET 6. \u003co:p\u003e\u003c/o:p\u003e\u003c/p\u003e\n\n\u003cp class=MsoNormal\u003eWhen the below code is accessed in parallel (through 100\nindividual threads say using a function app with ASB trigger) or use a simple ‘\u003ci\u003eParallel.For\u003c/i\u003e’\nthreads in a console app, we are able to replicate the problem. We did open\ncase with Microsoft and IBM team who did point out the fact that this is more for\nthe .NET product group. \u003co:p\u003e\u003c/o:p\u003e\u003c/p\u003e\n\n\u003cp class=MsoNormal\u003e\u003co:p\u003e\u0026nbsp;\u003c/o:p\u003e\u003c/p\u003e\n\n\u003cp class=MsoNormal\u003eSample code : \u003co:p\u003e\u003c/o:p\u003e\u003c/p\u003e\n\n\u003cp class=MsoNormal\u003e{\u003co:p\u003e\u003c/o:p\u003e\u003c/p\u003e\n\n\u003cp class=MsoNormal\u003e\u003cspan style=\u0027mso-spacerun:yes\u0027\u003e \u003c/span\u003estatic void\nMain(string[] args)\u003co:p\u003e\u003c/o:p\u003e\u003c/p\u003e\n\n\u003cp class=MsoNormal\u003e\u003cspan style=\u0027mso-spacerun:yes\u0027\u003e \u003c/span\u003e{\u003co:p\u003e\u003c/o:p\u003e\u003c/p\u003e\n\n\u003cp class=MsoNormal\u003e\u003cspan style=\u0027mso-tab-count:1\u0027\u003e               \u003c/span\u003estatic\nstring qm = \u0026quot;***\u0026quot;; static string channel = \u0026quot;***\u0026quot;;\u003co:p\u003e\u003c/o:p\u003e\u003c/p\u003e\n\n\u003cp class=MsoNormal\u003e\u003cspan style=\u0027mso-tab-count:1\u0027\u003e               \u003c/span\u003estatic\nstring host = \u0026quot;***\u0026quot;; static int port = ***; static string\nsslCipherSpec = \u0026quot;*** \u0026quot;;\u003co:p\u003e\u003c/o:p\u003e\u003c/p\u003e\n\n\u003cp class=MsoNormal\u003e\u003cspan style=\u0027mso-spacerun:yes\u0027\u003e        \u003c/span\u003eMQQueueManager\nqMgr = createQMObject();\u003co:p\u003e\u003c/o:p\u003e\u003c/p\u003e\n\n\u003cp class=MsoNormal\u003e\u003cspan style=\u0027mso-tab-count:1\u0027\u003e               \u003c/span\u003efor (int\ni = 1; i \u0026lt;= 10; i++)\u003co:p\u003e\u003c/o:p\u003e\u003c/p\u003e\n\n\u003cp class=MsoNormal\u003e\u003cspan style=\u0027mso-tab-count:2\u0027\u003e                              \u003c/span\u003e{\u003co:p\u003e\u003c/o:p\u003e\u003c/p\u003e\n\n\u003cp class=MsoNormal\u003e\u003cspan style=\u0027mso-tab-count:3\u0027\u003e                                             \u003c/span\u003evar\nwatch = System.Diagnostics.Stopwatch.StartNew();\u003co:p\u003e\u003c/o:p\u003e\u003c/p\u003e\n\n\u003cp class=MsoNormal\u003e\u003cspan style=\u0027mso-tab-count:3\u0027\u003e                                             \u003c/span\u003e//\nConenct to Queue , establish SSL connection\u003co:p\u003e\u003c/o:p\u003e\u003c/p\u003e\n\n\u003cp class=MsoNormal\u003e\u003cspan style=\u0027mso-tab-count:3\u0027\u003e                                             \u003c/span\u003eMQQueue\nmqQueue = qMgr.AccessQueue(queue, MQC.MQOO_OUTPUT);\u003co:p\u003e\u003c/o:p\u003e\u003c/p\u003e\n\n\u003cp class=MsoNormal\u003e\u003cspan style=\u0027mso-tab-count:3\u0027\u003e                                             \u003c/span\u003ewatch.Stop();\u003co:p\u003e\u003c/o:p\u003e\u003c/p\u003e\n\n\u003cp class=MsoNormal\u003e\u003cspan style=\u0027mso-tab-count:3\u0027\u003e                                             \u003c/span\u003eConsole.WriteLine(\u0026quot;Time\ntaken to access Queue:\u0026quot; + watch.ElapsedMilliseconds + \u0026quot; ms\u0026quot;);\u003co:p\u003e\u003c/o:p\u003e\u003c/p\u003e\n\n\u003cp class=MsoNormal\u003e\u003cspan style=\u0027mso-tab-count:2\u0027\u003e                              \u003c/span\u003e}\u003co:p\u003e\u003c/o:p\u003e\u003c/p\u003e\n\n\u003cp class=MsoNormal\u003e\u003cspan style=\u0027mso-tab-count:1\u0027\u003e               \u003c/span\u003eParallel.For(0,\n20, i =\u0026gt;\u003co:p\u003e\u003c/o:p\u003e\u003c/p\u003e\n\n\u003cp class=MsoNormal\u003e\u003cspan style=\u0027mso-tab-count:2\u0027\u003e                              \u003c/span\u003e{\u003co:p\u003e\u003c/o:p\u003e\u003c/p\u003e\n\n\u003cp class=MsoNormal\u003e\u003cspan style=\u0027mso-tab-count:3\u0027\u003e                                             \u003c/span\u003evar\nwatch = System.Diagnostics.Stopwatch.StartNew();\u003co:p\u003e\u003c/o:p\u003e\u003c/p\u003e\n\n\u003cp class=MsoNormal\u003e\u003cspan style=\u0027mso-tab-count:3\u0027\u003e                                             \u003c/span\u003eMQQueue\nmqQueue = qMgr.AccessQueue(queue, MQC.MQOO_OUTPUT);\u003co:p\u003e\u003c/o:p\u003e\u003c/p\u003e\n\n\u003cp class=MsoNormal\u003e\u003cspan style=\u0027mso-tab-count:3\u0027\u003e                                             \u003c/span\u003ewatch.Stop();\u003co:p\u003e\u003c/o:p\u003e\u003c/p\u003e\n\n\u003cp class=MsoNormal\u003e\u003cspan style=\u0027mso-tab-count:3\u0027\u003e                                             \u003c/span\u003eConsole.WriteLine(\u0026quot;Time\ntaken to access Queue:\u0026quot; + watch.ElapsedMilliseconds + \u0026quot; ms\u0026quot;);\u003co:p\u003e\u003c/o:p\u003e\u003c/p\u003e\n\n\u003cp class=MsoNormal\u003e\u003cspan style=\u0027mso-tab-count:2\u0027\u003e                              \u003c/span\u003e}\u003co:p\u003e\u003c/o:p\u003e\u003c/p\u003e\n\n\u003cp class=MsoNormal\u003e}\u003co:p\u003e\u003c/o:p\u003e\u003c/p\u003e\n\n\u003cp class=MsoNormal\u003e\u003co:p\u003e\u0026nbsp;\u003c/o:p\u003e\u003c/p\u003e\n\n\u003cp class=MsoNormal\u003e\u003co:p\u003e\u0026nbsp;\u003c/o:p\u003e\u003c/p\u003e\n\n\u003cp class=MsoNormal\u003e\u003cspan style=\u0027mso-spacerun:yes\u0027\u003e  \u003c/span\u003epublic static\nMQQueueManager createQMObject()\u003co:p\u003e\u003c/o:p\u003e\u003c/p\u003e\n\n\u003cp class=MsoNormal\u003e\u003cspan style=\u0027mso-spacerun:yes\u0027\u003e  \u003c/span\u003e{\u003co:p\u003e\u003c/o:p\u003e\u003c/p\u003e\n\n\u003cp class=MsoNormal\u003e\u003cspan style=\u0027mso-spacerun:yes\u0027\u003e      \u003c/span\u003eHashtable\nconnectionProp = new Hashtable()\u003co:p\u003e\u003c/o:p\u003e\u003c/p\u003e\n\n\u003cp class=MsoNormal\u003e\u003cspan style=\u0027mso-spacerun:yes\u0027\u003e                             \n\u003c/span\u003e{{MQC.TRANSPORT_PROPERTY,\nMQC.TRANSPORT_MQSERIES_MANAGED},{MQC.HOST_NAME_PROPERTY, host },\u003co:p\u003e\u003c/o:p\u003e\u003c/p\u003e\n\n\u003cp class=MsoNormal\u003e\u003cspan style=\u0027mso-spacerun:yes\u0027\u003e                             \n\u003c/span\u003e{MQC.CHANNEL_PROPERTY, channel},{MQC.PORT_PROPERTY, port\n},{MQC.SSL_CIPHER_SPEC_PROPERTY, sslCipherSpec }};\u003co:p\u003e\u003c/o:p\u003e\u003c/p\u003e\n\n\u003cp class=MsoNormal\u003e\u003cspan style=\u0027mso-spacerun:yes\u0027\u003e      \u003c/span\u003ereturn new\nMQQueueManager(qm, connectionProp);\u003co:p\u003e\u003c/o:p\u003e\u003c/p\u003e\n\n\u003cp class=MsoNormal\u003e\u003cspan style=\u0027mso-spacerun:yes\u0027\u003e  \u003c/span\u003e}\u003co:p\u003e\u003c/o:p\u003e\u003c/p\u003e\n\n\u003cp class=MsoNormal\u003e}\u003co:p\u003e\u003c/o:p\u003e\u003c/p\u003e\n\n\u003cp class=MsoNormal\u003e\u003co:p\u003e\u0026nbsp;\u003c/o:p\u003e\u003c/p\u003e\n\n\u003cp class=MsoNormal\u003e### Configuration\u003co:p\u003e\u003c/o:p\u003e\u003c/p\u003e\n\n\u003cp class=MsoNormal\u003e\u003co:p\u003e\u0026nbsp;\u003c/o:p\u003e\u003c/p\u003e\n\n\u003cp class=MsoNormal\u003e(If you are posting Benchmark.NET results, this info will be\nincluded.)\u003co:p\u003e\u003c/o:p\u003e\u003c/p\u003e\n\n\u003cp class=MsoNormal\u003e* Which version of .NET is the code running on?\u003co:p\u003e\u003c/o:p\u003e\u003c/p\u003e\n\n\u003cp class=MsoNormal\u003eThe working version is .NET 6 and if the code is run against\n.NET 8, it wont work\u003co:p\u003e\u003c/o:p\u003e\u003c/p\u003e\n\n\u003cp class=MsoNormal\u003e* What OS version, and what distro if applicable?\u003co:p\u003e\u003c/o:p\u003e\u003c/p\u003e\n\n\u003cp class=MsoNormal\u003eWindows platform\u003co:p\u003e\u003c/o:p\u003e\u003c/p\u003e\n\n\u003cp class=MsoNormal\u003e* What is the architecture (x64, x86, ARM, ARM64)?\u003co:p\u003e\u003c/o:p\u003e\u003c/p\u003e\n\n\u003cp class=MsoNormal\u003eX64\u003co:p\u003e\u003c/o:p\u003e\u003c/p\u003e\n\n\u003cp class=MsoNormal\u003e\u003co:p\u003e\u0026nbsp;\u003c/o:p\u003e\u003c/p\u003e\n\n\u003cp class=MsoNormal\u003e### Regression?\u003co:p\u003e\u003c/o:p\u003e\u003c/p\u003e\n\n\u003cp class=MsoNormal\u003e\u003co:p\u003e\u0026nbsp;\u003c/o:p\u003e\u003c/p\u003e\n\n\u003cp class=MsoNormal\u003e* .NET 6 with \u003cspan style=\u0027font-size:9.5pt;font-family:\"Cascadia Mono\";\ncolor:black;mso-font-kerning:0pt\u0027\u003eIBMMQDotnetClient v9.3 works perfectly fine \u003co:p\u003e\u003c/o:p\u003e\u003c/span\u003e\u003c/p\u003e\n\n\u003cp class=MsoNormal\u003e* .NET 8 with \u003cspan style=\u0027font-size:9.5pt;font-family:\"Cascadia Mono\";\ncolor:black;mso-font-kerning:0pt\u0027\u003eIBMMQDotnetClient v9.3 or v9.4 doesn’t give\nthe expected performance results. It doesn’t even process like 20 messages in\nparallel quickly \u003c/span\u003e\u003co:p\u003e\u003c/o:p\u003e\u003c/p\u003e\n\n\u003cp class=MsoNormal\u003e\u003co:p\u003e\u0026nbsp;\u003c/o:p\u003e\u003c/p\u003e\n\n\u003cp class=MsoNormal\u003e### Data\u003co:p\u003e\u003c/o:p\u003e\u003c/p\u003e\n\n\u003cp class=MsoNormal\u003e.NET 8 vs .NET 6 performance comparison for the above sample\ncode \u003co:p\u003e\u003c/o:p\u003e\u003c/p\u003e\n\n\u003cp class=MsoNormal\u003e\u003co:p\u003e\u0026nbsp;\u003c/o:p\u003e\u003c/p\u003e\n\n\n.NET 8 | .NET 6\n-- | --\nEstablishing connection | Establishing connection\nTime taken to access Queue:17 ms | Time taken to access Queue:43 ms\nTime taken to access Queue:6 ms | Time taken to access Queue:7 ms\nTime taken to access Queue:6 ms | Time taken to access Queue:3 ms\nTime taken to access Queue:3 ms | Time taken to access Queue:8 ms\nTime taken to access Queue:5 ms | Time taken to access Queue:3 ms\nTime taken to access Queue:5 ms | Time taken to access Queue:3 ms\nTime taken to access Queue:10 ms | Time taken to access Queue:3 ms\nTime taken to access Queue:3 ms | Time taken to access Queue:3 ms\nTime taken to access Queue:10 ms | Time taken to access Queue:3 ms\nTime taken to access Queue:4 ms | Time taken to access Queue:9 ms\nswitching to parallel | switching to parallel\nTime taken to access Queue:87 ms | Time taken to access Queue:110 ms\nTime taken to access Queue:134 ms | Time taken to access Queue:35 ms\nTime taken to access Queue:886 ms | Time taken to access Queue:202 ms\nTime taken to access Queue:1762 ms | Time taken to access Queue:272 ms\nTime taken to access Queue:2823 ms | Time taken to access Queue:351 ms\nTime taken to access Queue:3681 ms | Time taken to access Queue:410 ms\nTime taken to access Queue:4689 ms | Time taken to access Queue:422 ms\nTime taken to access Queue:5865 ms | Time taken to access Queue:50 ms\nTime taken to access Queue:6763 ms | Time taken to access Queue:339 ms\nTime taken to access Queue:7722 ms | Time taken to access Queue:8 ms\nTime taken to access Queue:7971 ms | Time taken to access Queue:411 ms\nTime taken to access Queue:3041 ms | Time taken to access Queue:18 ms\nTime taken to access Queue:2060 ms | Time taken to access Queue:20 ms\nTime taken to access Queue:7831 ms | Time taken to access Queue:19 ms\nTime taken to access Queue:4100 ms | Time taken to access Queue:64 ms\nTime taken to access Queue:6135 ms | Time taken to access Queue:48 ms\nTime taken to access Queue:1103 ms | Time taken to access Queue:33 ms\nTime taken to access Queue:7163 ms | Time taken to access Queue:180 ms\nTime taken to access Queue:126 ms | Time taken to access Queue:153 ms\nTime taken to access Queue:5172 ms | Time taken to access Queue:36 ms\n\n\n\n\u003cp class=MsoNormal\u003e\u003co:p\u003e\u0026nbsp;\u003c/o:p\u003e\u003c/p\u003e\n\n\u003cp class=MsoNormal\u003e\u003co:p\u003e\u0026nbsp;\u003c/o:p\u003e\u003c/p\u003e\n\n\u003cp class=MsoNormal\u003e### Analysis\u003co:p\u003e\u003c/o:p\u003e\u003c/p\u003e\n\n\u003cul style=\u0027margin-top:0cm\u0027 type=disc\u003e\n \u003cli class=MsoListParagraph style=\u0027margin-left:0cm;mso-list:l0 level1 lfo1\u0027\u003eThe\n     issue is noticed only when we try \u0026amp; access the piece of code in parallel\n     or use a asynchronous parallel logic \u003co:p\u003e\u003c/o:p\u003e\u003c/li\u003e\n \u003cli class=MsoListParagraph style=\u0027margin-left:0cm;mso-list:l0 level1 lfo1\u0027\u003eThe\n     problem seems to be with the .NET version 8 and the IBM MQ library which makes\n     the access queue line super slow. Both the IBM and MS team have pointed to\n     the fact that this seems to be an issue with .NET 8 itself (Case reference\n     : 2410230030008938) \u003cspan style=\u0027mso-spacerun:yes\u0027\u003e \u003c/span\u003e\u003co:p\u003e\u003c/o:p\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003c!--EndFragment--\u003e\n\u003c/body\u003e\n\n\u003c/html\u003e\n[MQClass.txt](https://github.com/user-attachments/files/17719151/MQClass.txt)\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOlIpjLA==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6TeZN0",
                                           "createdAt":  "2024-11-13T17:01:47Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @mangod9\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2024-11-13T17:01:47Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6UimMs",
                                           "createdAt":  "2024-11-21T19:34:04Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-threading-tasks\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2024-11-21T19:34:04Z"
                                       }
                                   ],
                         "totalCount":  2
                     },
        "title":  ".NET 8 performance issue with IBMMQDotnetClient (v9.3 \u0026 v9.4)",
        "labels":  [
                       "area-System.Threading.Tasks",
                       "tenet-performance"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/112900",
        "createdAt":  "2025-02-25T09:36:13Z",
        "number":  112900,
        "author":  "bill-poole",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOC_dZ6Q==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "FedeArre",
                                            "createdAt":  "2025-02-25T18:09:10Z"
                                        }
                                    ],
                          "totalCount":  1
                      },
        "updatedAt":  "2025-07-26T09:08:00Z",
        "body":  "### Background and motivation\n\n`Parallel.Invoke` currently provides for concurrently executing a set of `Action`s, but does not provide for executing a set of async actions (`Func\u003cCancellationToken, ValueTask\u003e`). I have found a frequent need to concurrently execute a set of async actions, where if any action fails, all other actions are cancelled and the exception of the failing action is thrown. i.e., similar behavior is required that is provided by `Parallel.ForEachAsync`, but where `ForEachAsync` executes a single function for a collection of inputs, `Parallel.InvokeAsync` would execute a collection of async actions.\n\n### API Proposal\n\n```csharp\nnamespace System.Threading.Tasks\n\npublic static class Parallel\n{\n    public static Task InvokeAsync(params Func\u003cCancellationToken, ValueTask\u003e[] actions);\n\n    public static Task InvokeAsync(CancellationToken cancellationToken, params Func\u003cCancellationToken, ValueTask\u003e[] actions);\n\n    public static Task InvokeAsync(ParallelOptions parallelOptions, params Func\u003cCancellationToken, ValueTask\u003e actions);\n}\n```\n\n### API Usage\n\n```csharp\nawait Parallel.InvokeAsync(\n  async ct =\u003e obj.Id = new(obj.Id.ExternalId, internalId: await idMapper.GetInternalId(obj.Id.ExternalId, ct)),\n  async ct =\u003e obj.ParentId = new(obj.Id.ExternalId, internalId: await idMapper.GetInternalId(obj.ParentId.ExternalId, ct)),\n  async ct =\u003e obj.OrderId = new(obj.Id.ExternalId, internalId: await idMapper.GetInternalId(obj.OrderId.ExternalId, ct)),\n  async ct =\u003e obj.AssignmentId = new(obj.Id.ExternalId, internalId: await idMapper.GetInternalId(obj.AssignmentId.ExternalId, ct)));\n```\n\n\n### Alternative Designs\n\n_No response_\n\n### Risks\n\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOn9G_Tg==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6f0b9O",
                                           "createdAt":  "2025-02-25T09:36:47Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-threading-tasks\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2025-02-25T09:36:47Z"
                                       }
                                   ],
                         "totalCount":  1
                     },
        "title":  "[API Proposal]: Add Parallel.InvokeAsync",
        "labels":  [
                       "api-suggestion",
                       "area-System.Threading.Tasks"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/112971",
        "createdAt":  "2025-02-26T22:19:44Z",
        "number":  112971,
        "author":  "bryanjhogan",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-06-03T23:10:38Z",
        "body":  "### Description\n\nI have a project based on the Worker Service template. When I cancel the application using Ctrl+C, I expect the `CancellationToken` to be canceled and the `Task.Delay(1000, stoppingToken)` to throw a `TaskCanceledException`. This does not happen. \n\nIt seems something is smothering the exception raised when this token is cancelled in the `BackgroundService`. I understand why this might be desirable in some cases to prevent one canceled worker from throwing an exception and stopping the whole application. But it feels inconsistent and unexpected. \n\nA user of the template might expect the while loop to exit when the token is canceled, and run some code outside the loop, but this won\u0027t happen if the token is canceled during the delay. \n\n\n### Reproduction Steps\n\nCreate a Worker Service project using the Worker Service template. \n\nIt has a `BackgroundService`, with an `ExecuteAsync` method that looks like this - \n\n\n```\nprotected override async Task ExecuteAsync(CancellationToken stoppingToken)\n{\n    while (!stoppingToken.IsCancellationRequested)\n    {\n        Console.WriteLine($\"Doing some work {DateTime.Now:HH:mm:ss}\");\n        await Task.Delay(1000, stoppingToken);\n        Console.WriteLine($\"Finishing some work {DateTime.Now:HH:mm:ss}\");\n    }\n    Console.WriteLine(\"Cancellation requested, doing some cleanup.\");\n}\n```\n\nRun the application and stop it using Ctrl+C.\n\n### Expected behavior\n\nA `TaskCancelledException` should be thrown when the `CancellationToken` is canceled during the delay.\n\nThe expected behavior can be seen in a simple console application  - \n\n```\nCancellationTokenSource cancellationTokenSource = new CancellationTokenSource(3000);\nCancellationToken stoppingToken = cancellationTokenSource.Token;\n\nwhile(!stoppingToken.IsCancellationRequested)\n{\n    Console.WriteLine($\"{DateTime.Now:HH:mm:ss}\");\n    await Task.Delay(1000, stoppingToken);\n}\n```\n\n\n### Actual behavior\n\nThe application stops immediately, usually during the delay, but no `TaskCancelledException` is thrown from the `Task.Delay(1000, stoppingToken)`.\n\n### Regression?\n\n_No response_\n\n### Known Workarounds\n\nIf I put a `try...catch` around the `await Task.Delay(1000, stoppingToken)` and catch `TaskCanceledException`, the `catch` will be executed, so it seems an exception is thrown in this case. \n\n### Configuration\n\n_No response_\n\n### Other information\n\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOrxlDog==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6gHj-2",
                                           "createdAt":  "2025-02-26T22:20:17Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-threading-tasks\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2025-02-26T22:20:17Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6gKaxw",
                                           "createdAt":  "2025-02-27T07:06:30Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "KalleOlaviNiemitalo",
                                           "body":  "If a `TaskCancelledException` were thrown from the `Task.Delay(1000, stoppingToken)`, then the Execute method would end without outputting the \"Finishing some work\" and \"Cancellation requested, doing some cleanup\" messages.  Are you saying that these messages **are** output?",
                                           "updatedAt":  "2025-02-27T07:06:30Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6gKeiA",
                                           "createdAt":  "2025-02-27T07:16:13Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEH5pLw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "julealgon",
                                                                               "createdAt":  "2025-02-27T12:31:29Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "colejohnson66",
                                                                               "createdAt":  "2025-02-27T14:42:18Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "KalleOlaviNiemitalo",
                                           "body":  "The Host.TryExecuteBackgroundServiceAsync method swallows OperationCanceledException in the Task created by BackgroundService, if the cancellation seems to have been caused by the host being stopped:\n\n\u003chttps://github.com/dotnet/runtime/blob/94f06fab56327726e6c23b2f018d788a6a34e621/src/libraries/Microsoft.Extensions.Hosting/src/Internal/Host.cs#L183-L194\u003e\n\nIn that case, it does not log the exception.  Also, the exception does not cause the host to stop, regardless of BackgroundServiceExceptionBehavior, but that does not matter because the host was stopping already.",
                                           "updatedAt":  "2025-02-27T07:19:00Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6gUcAI",
                                           "createdAt":  "2025-02-28T04:49:07Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "bryanjhogan",
                                           "body":  "@KalleOlaviNiemitalo Thanks for showing where the exception is smothered. \n\nMy concerns are - \n1. A person using the Worker Service template doesn\u0027t have an obvious way of exiting the while loop when the worker is cancelled during the delay. \nFor anyone wondering, adding a `try...catch` around the `await Task.Delay(...)` will do it, but now I have to use an exception for flow control. Maybe there is another way? \n\n2. The behavior of `await Task.Delay(1000, stoppingToken)` is significantly different in a BackgroundService compared to anywhere else. \n\nSuggestion - update the Worker Service template to make this difference in behavior known.",
                                           "updatedAt":  "2025-02-28T04:50:15Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6gVXac",
                                           "createdAt":  "2025-02-28T07:45:46Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "KalleOlaviNiemitalo",
                                           "body":  "The Worker Service C# template is maintained at: \u003chttps://github.com/dotnet/aspnetcore/blob/704f7cb1d2cea33afb00c2097731216f121c2c73/src/ProjectTemplates/Web.ProjectTemplates/content/Worker-CSharp/Worker.cs#L12-L22\u003e\n\nI imagine one could add a comment like:\n\n```patch\n     protected override async Task ExecuteAsync(CancellationToken stoppingToken)\n     {\n         while (!stoppingToken.IsCancellationRequested)\n         {\n             if (_logger.IsEnabled(LogLevel.Information))\n             {\n                 _logger.LogInformation(\"Worker running at: {time}\", DateTimeOffset.Now);\n             }\n+            // If the host is requested to stop and this await throws\n+            // TaskCanceledException, the host does not log the exception.\n             await Task.Delay(1000, stoppingToken);\n         }\n     }\n```\n\nThe [BackgroundService.ExecuteAsync documentation](https://learn.microsoft.com/dotnet/api/microsoft.extensions.hosting.backgroundservice.executeasync?view=net-9.0-pp) is another place where the behavior could be explained.\n\n(Another option would be to use `await Task.Delay(1000, stoppingToken).ConfigureAwait(ConfigureAwaitOptions.SuppressThrowing)` so that the exception isn\u0027t even thrown.  That would make the exception behavior not depend on whether the cancellation request is detected by the `while (!stoppingToken.IsCancellationRequested)` loop or by Task.Delay.  However, I think it would be a bad change, because developers might then copy the `.ConfigureAwait(ConfigureAwaitOptions.SuppressThrowing)` to awaits of tasks that can throw non-cancellation exceptions that should not be discarded.)\n",
                                           "updatedAt":  "2025-02-28T07:45:46Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6geW0R",
                                           "createdAt":  "2025-03-01T16:42:05Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "colejohnson66",
                                           "body":  "If `stoppingToken` is signaling, your host is indicating that the application is being torn down. It\u0027s reasonable that `host.StopAsync` would suppress the exception from that cancellation token _because you\u0027re shutting down_; The exception isn\u0027t a \"real\" failure, but just a way to bail out of whatever code is executing.",
                                           "updatedAt":  "2025-03-01T16:42:05Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6geeeM",
                                           "createdAt":  "2025-03-01T17:57:47Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "KalleOlaviNiemitalo",
                                           "body":  "If the application has a dozen BackgroundService instances and each of them throws TaskCanceledException when the host is being stopped, it would not be useful to log all of those exceptions.\n\n\u003e It\u0027s reasonable that `host.StopAsync` would suppress the exception from that cancellation token\n\nIt doesn\u0027t actually check whether OperationCanceledException.CancellationToken is equal to the stoppingToken that was passed to BackgroundService.ExecuteAsync; but cancellation via a linked token would not satisfy such a check anyway, so I don\u0027t think it can be implemented.",
                                           "updatedAt":  "2025-03-01T18:00:57Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6ge7rI",
                                           "createdAt":  "2025-03-01T23:13:40Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "colejohnson66",
                                           "body":  "Tangent: Yes, linked tokens makes the `OperationCancelledException.CancellationToken` property useless. The only reliable way to \"know\" if a token caused the exception in the face of linked tokens is to just assume that if your token is cancelled, that\u0027s why.\n\nBack to the issue: if OP desires the ability for `stoppingToken` to bubble out of `host.StopAsync`, they should implement `IHostedService` manually (avoiding `BackgroundService`) and use `IHostedService.StopAsync` to do the logging.",
                                           "updatedAt":  "2025-03-01T23:15:24Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6ggXVh",
                                           "createdAt":  "2025-03-02T18:01:22Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "bryanjhogan",
                                           "body":  "\u003e If `stoppingToken` is signaling, your host is indicating that the application is being torn down. It\u0027s reasonable that `host.StopAsync` would suppress the exception from that cancellation token _because you\u0027re shutting down_; The exception isn\u0027t a \"real\" failure, but just a way to bail out of whatever code is executing.\n\nBut it requires knowledge of how the host is implemented, and there is no suggestion in the template that in this one scenario `Task.Delay(...)` works differently than everywhere else. \n\nMy concern is not so much that this happens, but that it is unexpected and not documented in the template.",
                                           "updatedAt":  "2025-03-02T18:09:10Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6ggebh",
                                           "createdAt":  "2025-03-02T19:21:49Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "colejohnson66",
                                           "body":  "`Task.Delay` is not \"different\" - _any_ `OperationCancelledException` or `TaskCancelledException` will be suppressed IFF `stoppingToken.IsCancellationRequested`. You are only seeing it in `Task.Delay` because (in your code) that\u0027s the only thing that throws when `stoppingToken` is signaling a cancellation. Try this yourself:\n\n```cs\nwhile (true)\n{\n    await Task.Delay(TimeSpan.FromMilliseconds(10), CancellationToken.None);\n    stoppingToken.ThrowIfCancellationRequested();\n}\n```\n\nThe exception will still be suppressed because the token is indicating the app (host container) is shutting down.",
                                           "updatedAt":  "2025-03-02T19:23:00Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6vGUOi",
                                           "createdAt":  "2025-06-03T23:10:26Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ericstj",
                                           "body":  "The exception is thrown and a catch inside ExecuteAsync would see that exception and have the chance to catch it, do something, and rethrow, or itself just gracefully exit.\n\n```C#\n    protected override async Task ExecuteAsync(CancellationToken stoppingToken)\n    {\n        while (!stoppingToken.IsCancellationRequested)\n        {\n            Console.WriteLine($\"Doing some work {DateTime.Now:HH:mm:ss}\");\n\n            try\n            {\n                // Simulate some work\n                await Task.Delay(1000, stoppingToken);\n            }\n            catch (TaskCanceledException)\n            {\n                Console.WriteLine(\"Task was cancelled.\");\n                // either rethrow or just allow fallthrough\n                //throw;\n            }\n            Console.WriteLine($\"Finishing some work {DateTime.Now:HH:mm:ss}\");\n        }\n        Console.WriteLine(\"Cancellation requested, doing some cleanup.\");\n    }\n```\n\nThere\u0027s also [IHostedLifecycleService](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.hosting.ihostedlifecycleservice?view=net-9.0-pp) which can be implemented in a BackgroundService to get more callbacks during the lifecycle of the service.\n\nHave a look at this sample: [bgt.zip](https://github.com/user-attachments/files/20581773/bgt.zip)\n\nHope this clears this up, if you see some docs that are lacking you can contribute to them or open an issue in the docs repo.",
                                           "updatedAt":  "2025-06-03T23:10:26Z"
                                       }
                                   ],
                         "totalCount":  11
                     },
        "title":  "`Task.Delay(1000, stoppingToken)` does not throw a `TaskCanceledException` from a the `ExecuteAsync` method of a `BackgroundService`",
        "labels":  [
                       "question",
                       "area-System.Threading.Tasks"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/113189",
        "createdAt":  "2025-03-06T04:54:29Z",
        "number":  113189,
        "author":  "catamounttechnology",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-07-26T02:38:32Z",
        "body":  "### Description\n\nI have a .NET 9 ASP.NET application running as a service. After the latest upgrades of nuget packages, the application crashes periodically with a StackOverflow exception\n\n![Image](https://github.com/user-attachments/assets/f0af86a8-6a1a-4993-bf03-09a95184b1c5)\n\nI tried to repro it but I couldn\u0027t. So I attached Visual Studio Debugger and let it run until it happened again.\n\nThe call stack does not touch any application code\n\nand looks confined into System.Private.CoreLib.DLL\n\n```\n[Managed to Native Transition]\nSystem.Private.CoreLib.dll!Interop.Advapi32.EventWriteTransfer(long registrationHandle, System.Diagnostics.Tracing.EventDescriptor eventDescriptor, System.Guid* activityId, System.Guid* relatedActivityId, int userDataCount, System.Diagnostics.Tracing.EventProvider.EventData* userData) Line 3853\n\tat -\\Interop.cs(3853)\nSystem.Private.CoreLib.dll!System.Diagnostics.Tracing.EventSource.WriteEventWithRelatedActivityIdCore(int eventId, System.Guid* relatedActivityId, int eventDataCount, System.Diagnostics.Tracing.EventSource.EventData* data) Line 1126\n\tat System.Diagnostics.Tracing\\EventSource.cs(1126)\nSystem.Private.CoreLib.dll!System.Diagnostics.Tracing.EventSource.WriteEvent(int eventId, int arg1, int arg2) Line 681\n\tat System.Diagnostics.Tracing\\EventSource.cs(681)\nSystem.Private.CoreLib.dll!System.Threading.Tasks.Task.FinishStageTwo() Line 2154\n\tat System.Threading.Tasks\\Task.cs(2154)\nSystem.Private.CoreLib.dll!System.Threading.Tasks.Task.ProcessChildCompletion(System.Threading.Tasks.Task childTask) Line 2210\n\tat System.Threading.Tasks\\Task.cs(2210)\nSystem.Private.CoreLib.dll!System.Threading.Tasks.Task.FinishStageTwo() Line 2166\n\tat System.Threading.Tasks\\Task.cs(2166)\n[The 2 frame(s) above this were repeated 6033 times]\nSystem.Private.CoreLib.dll!System.Threading.Tasks.Task.ProcessChildCompletion(System.Threading.Tasks.Task childTask) Line 2210\n\tat System.Threading.Tasks\\Task.cs(2210)\nSystem.Private.CoreLib.dll!System.Threading.Tasks.Task.FinishStageTwo() Line 2166\n\tat System.Threading.Tasks\\Task.cs(2166)\nSystem.Private.CoreLib.dll!System.Threading.Tasks.Task.ProcessChildCompletion(System.Threading.Tasks.Task childTask) Line 2210\n\tat System.Threading.Tasks\\Task.cs(2210)\nSystem.Private.CoreLib.dll!System.Threading.Tasks.Task.FinishStageTwo() Line 2166\n\tat System.Threading.Tasks\\Task.cs(2166)\nSystem.Private.CoreLib.dll!System.Threading.Tasks.Task.ProcessChildCompletion(System.Threading.Tasks.Task childTask) Line 2210\n\tat System.Threading.Tasks\\Task.cs(2210)\nSystem.Private.CoreLib.dll!System.Threading.Tasks.Task.FinishStageTwo() Line 2166\n\tat System.Threading.Tasks\\Task.cs(2166)\nSystem.Private.CoreLib.dll!System.Threading.Tasks.Task.ProcessChildCompletion(System.Threading.Tasks.Task childTask) Line 2210\n\tat System.Threading.Tasks\\Task.cs(2210)\nSystem.Private.CoreLib.dll!System.Threading.Tasks.Task.FinishStageTwo() Line 2166\n\tat System.Threading.Tasks\\Task.cs(2166)\n.\n.\n.\n.\n.\n.\n.\n.\n\tat System.Threading.Tasks\\Task.cs(2210)\nSystem.Private.CoreLib.dll!System.Threading.Tasks.Task.FinishStageTwo() Line 2166\n\tat System.Threading.Tasks\\Task.cs(2166)\nSystem.Private.CoreLib.dll!System.Threading.Tasks.Task.ProcessChildCompletion(System.Threading.Tasks.Task childTask) Line 2210\n\tat System.Threading.Tasks\\Task.cs(2210)\nSystem.Private.CoreLib.dll!System.Threading.Tasks.Task.FinishStageTwo() Line 2166\n\tat System.Threading.Tasks\\Task.cs(2166)\nSystem.Private.CoreLib.dll!System.Threading.Tasks.Task.ProcessChildCompletion(System.Threading.Tasks.Task childTask) Line 2210\n\tat System.Threading.Tasks\\Task.cs(2210)\nSystem.Private.CoreLib.dll!System.Threading.Tasks.Task.FinishStageTwo() Line 2166\n\tat System.Threading.Tasks\\Task.cs(2166)\nSystem.Private.CoreLib.dll!System.Threading.Tasks.Task.ProcessChildCompletion(System.Threading.Tasks.Task childTask) Line 2210\n\tat System.Threading.Tasks\\Task.cs(2210)\nSystem.Private.CoreLib.dll!System.Threading.Tasks.Task.FinishStageTwo() Line 2166\n\tat System.Threading.Tasks\\Task.cs(2166)\nSystem.Private.CoreLib.dll!System.Threading.Tasks.Task.FinishSlow(bool userDelegateExecute) Line 2098\n\tat System.Threading.Tasks\\Task.cs(2098)\nSystem.Private.CoreLib.dll!System.Threading.Tasks.Task.ExecuteWithThreadLocal(ref System.Threading.Tasks.Task currentTaskSlot, System.Threading.Thread threadPoolThread) Line 2328\n\tat System.Threading.Tasks\\Task.cs(2328)\nSystem.Private.CoreLib.dll!System.Threading.ThreadPoolWorkQueue.Dispatch() Line 789\n\tat System.Threading\\ThreadPoolWorkQueue.cs(789)\nSystem.Private.CoreLib.dll!System.Threading.PortableThreadPool.WorkerThread.WorkerThreadStart() Line 1175\n\tat System.Threading\\PortableThreadPool.cs(1175)\n\n```\nThis is the Visual studio screen when it occurs\n\n![Image](https://github.com/user-attachments/assets/12b1b5b5-0510-44c4-90d1-3a298d511352)\n\nand this is the github pilot comment on it\n\n```\nThis error happens because a System.StackOverflowException is being thrown, indicating that the program has exhausted the stack memory due to excessive recursion or an infinite loop.\nThis might be happening because the FinishStageTwo method is being called recursively without a proper termination condition. The stack trace shows that FinishStageTwo calls ProcessChildCompletion, which in turn calls FinishStageTwo again, creating a loop that eventually leads to a stack overflow. This recursion is repeated thousands of times, as indicated by the repeated stack frames.\nTo fix this issue, you need to ensure that the recursion has a proper base case to terminate. Check the logic in FinishStageTwo and ProcessChildCompletion to ensure that they do not call each other indefinitely. You may also want to add logging to understand the flow of execution better and identify the conditions under which the recursion occurs.\nAdditional information needed to solve it:\n•\tThe complete implementation of FinishStageTwo, ProcessChildCompletion, and related methods.\n•\tThe context in which these methods are being called.\n•\tAny custom logic or event handling that might be influencing the recursion.\n```\nIn a previous occurrence, I had also collected a WER crash dump, but it didn\u0027t help me much in troubleshooting. The file compressed is 125 MB, so it  cannot be attached here.\n\n\n### Reproduction Steps\n\nCannot reproduce. Only thing I can do is let it run until it crashes\n\n### Expected behavior\n\nIt shouldn\u0027t crash\n\n### Actual behavior\n\nIt crashes (sometimes after 10 minutes other times it takes many hours\n\n### Regression?\n\nThe application did run correctly in the past 6 months. A new deployment has been released few days ago and it contains multiple source changes and multiple nuget upgrades. So it\u0027s not easy to point to a .NET update that could have brought to this\n\n### Known Workarounds\n\nNo workarounds\n\n### Configuration\n\n```\nC:\\Tools\\procdump\u003edotnet version\n\nWelcome to .NET 9.0!\n---------------------\nSDK Version: 9.0.200\n```\n\nWindows11  (10.0.22631)\nx64\nDo not know whether it is specific to this configuration\n\n### Other information\n\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOugc2Hg==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6hHako",
                                           "createdAt":  "2025-03-06T07:53:02Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "KalleOlaviNiemitalo",
                                           "body":  "The following gets a stack overflow due to recursion between Task.ProcessChildCompletion and Task.FinishStageThree, in both .NET 8.0 and .NET 9.0.\n\n```csharp\nusing System.Threading.Tasks;\n\nnamespace TaskChain\n{\n    internal class Program\n    {\n        private static async Task Main()\n        {\n            Task\u003cTask\u003e task = Task.Factory.StartNew(WorkAsync, state: 0);\n\n            // Await both the outer Task\u003cTask\u003e and the inner Task.\n            // The second await is necessary so that the process does not\n            // exit before the stack overflow.\n            await await task;\n        }\n\n        // Build a long chain of parent and child tasks.\n        // This is intended to reproduce the stack overflow exception at\n        // \u003chttps://github.com/dotnet/runtime/issues/113189\u003e.\n        private static async Task WorkAsync(object? state)\n        {\n            int depth = (int)state!;\n\n            if (depth \u003c 10000)\n            {\n                // Don\u0027t use Task.Run, which sets TaskCreationOptions.DenyChildAttach.\n                Task\u003cTask\u003e task = Task.Factory.StartNew(\n                    WorkAsync,\n                    state: depth + 1,\n                    creationOptions: TaskCreationOptions.AttachedToParent);\n\n                await await task;\n            }\n        }\n    }\n}\n```\n\nThis stack overflow requires parent/child relationships between tasks, i.e. TaskCreationOptions.AttachedToParent or TaskContinuationOptions.AttachedToParent.  I don\u0027t think those options are often used nowadays.  System.Linq.Parallel does use TaskCreationOptions.AttachedToParent so the option might be coming from there.",
                                           "updatedAt":  "2025-03-06T07:53:02Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6hOysC",
                                           "createdAt":  "2025-03-06T21:43:38Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "catamounttechnology",
                                           "body":  "In my case, application is F#, so all tasks are created through computation expressions. The Task Api is almost never called directly, so I have no idea about what methods get actually called.",
                                           "updatedAt":  "2025-03-06T21:43:38Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6hahHh",
                                           "createdAt":  "2025-03-08T07:03:15Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "catamounttechnology",
                                           "body":  "@stephentoub @jkotas @sywhang \nReaching out to you directly as I found you as significant authors of this issue source code.\nHope you can speed up things a little, it\u0027s very critical for us.\nThank you in advance.",
                                           "updatedAt":  "2025-03-08T07:03:15Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6hazko",
                                           "createdAt":  "2025-03-08T09:13:22Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "KalleOlaviNiemitalo",
                                           "body":  "I think the way to proceed is to use a debugger to find out why these attached tasks are created (is it something specific to F# or to the NuGet packages you are using?), and set up a sample that reproduces the stack overflow that way.  Then downgrade the packages and the target framework, and see if the stack overflow goes away.  It will show whether this is a regression that could hit other developers who upgrade their applications, or a pre-existing problem that only occurs in some special case.",
                                           "updatedAt":  "2025-03-08T09:13:22Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6hcMde",
                                           "createdAt":  "2025-03-08T22:55:56Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "catamounttechnology",
                                           "body":  "@KalleOlaviNiemitalo \nWhile the approach you propose could be a way to try a temporary fix or workaround, the issue here is more profound and essential.\nIf it is confirmed (as it appears), that this is a bug in the core of .NET, then it is a really concerning situation.\n.NET is the foundation of Microsoft based software development toolchain, and I think that every business and developer would agree that a bug like this is not acceptable at all.\nI don\u0027t think anyone would commit in using a framework that can crash your application depending on how you use it.",
                                           "updatedAt":  "2025-03-08T22:55:56Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6hcN0G",
                                           "createdAt":  "2025-03-08T23:11:01Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "KalleOlaviNiemitalo",
                                           "body":  "I meant\n\n- use the debugger to find a way to reproduce the stack overflow\n- test with lower target frameworks to find out whether it is a regression\n\nAs for whether the crash is left unfixed, fixed on .NET 10 only, or also fixed in lower versions, I expect it would depend on:\n\n- whether this is a regression in .NET 9\n- whether the code that triggers the crash is something that developers would expect to be able to write\n- whether the fix would slow down normal use of .NET Runtime\n\nIf the stack overflow is caused by something unusual that F# is doing, then perhaps it can be fixed in F# rather than in .NET Runtime.",
                                           "updatedAt":  "2025-03-08T23:11:01Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6hcSA5",
                                           "createdAt":  "2025-03-08T23:44:48Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "catamounttechnology",
                                           "body":  "@KalleOlaviNiemitalo \nAs things stand (and I would be happy to be proved wrong):\n\n_**use the debugger to find a way to reproduce the stack overflow**_: I tried and spent quite some time, no repro. This is likely going to be an expensive exercise, and one that businesses would rightly not want to engage in,\n\n**_test with lower target frameworks to find out whether it is a regression_**: currently in our project it can take hours or days to occur, as it cannot be reproduced. If we test and it doesn\u0027t happen, what would make us sure that if we run the test for another minute or hour it would not happen?\n\n**_As for whether the crash is left unfixed, fixed on .NET 10 only, or also fixed in lower versions, I expect it would depend on:_**\n\n**_whether this is a regression in .NET 9_**: absolutely disagree. If this is a .NET bug, it needs to be fixed immediately and a patch to the .NET runtime needs to be released asap.\n\n**_whether the code that triggers the crash is something that developers would expect to be able to write_**: again absolutely disagree. As it appears, this crash occurs totally inside .NET, no user code call triggers it. The stack trace does not show any user code involved, so there is no way for the application to catch it and prevent the crash. The code in our application, and the repro code you posted are absolutely \"something that developers would expect to be able to write\".\n\n**_whether the fix would slow down normal use of .NET Runtime_**: once again, absolutely disagree. A fundamental piece of framework line .NET should never, in any case, produce uncontrolled crashes like this. Performance is important, but reliability is a must.\n\n**_If the stack overflow is caused by something unusual that F# is doing, then perhaps it can be fixed in F# rather than in .NET Runtime._**: Not at all. Any action should never produce an uncontrolled crash like that. If it is confirmed that this is a .NET internal bug, no one would want to use .NET for a serious business project.\n\nPlease refrain from posting comments that make it look like a trivial nuance. This is a serious issue and reclaims immediate attention.",
                                           "updatedAt":  "2025-03-08T23:48:19Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6hc2IX",
                                           "createdAt":  "2025-03-09T06:20:16Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "KalleOlaviNiemitalo",
                                           "body":  "Re using the debugger, put a breakpoint at Task.AddNewChild() and log the stack traces from that.  Even if the parent/child task chains are so short that the stack overflow does not occur, this should show you where and why the attached tasks are being created.  Whether they are caused by System.Linq.Parallel or by something else.",
                                           "updatedAt":  "2025-03-09T06:20:16Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6heWrn",
                                           "createdAt":  "2025-03-09T21:56:53Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "catamounttechnology",
                                           "body":  "@KalleOlaviNiemitalo \n\n- Please see the following F# code\n\n```\n\n[\u003cStruct\u003e]\ntype private Request = {\n    Stub: IStreamStub\n    Message: objnull\n    Cts: CancellationTokenSource\n    Completion: TaskCompletionSource }\nwith \n    member this.Dispose() = this.Cts.Dispose()\n\n...\n\n    let rec throttleLoop() = \n        let execute request = task {\n            try \n                try\n                    do! request.Stub.Write(request.Message, request.Cts.Token)\n                    request.Completion.SetResult()\n                with x -\u003e request.Completion.SetException(x)\n            finally\n                request.Dispose()\n                _semaphore.Release() |\u003e ignore } |\u003e ignore\n    \n        async {\n            do! _semaphore.WaitAsync()\n            let! request = _requests.Dequeue()\n            \n            if not \u003c| isQuarantined request.Stub.ClientId \n            then execute request\n            else request.Dispose()\n            \n            return! throttleLoop() }\n\n    do Async.Start(throttleLoop())\n```\n\nthis is one of the dozens pieces of code that rely on asynchronous execution. There is not one call to C# Task, still they end up using the .NET Task API. Where would you start troubleshooting? Where would you put a breakpoint? It could take forever to find the one or more points where changing the code avoids the crash, in such an application.\n\n- We are not a research firm\nOur business supplies SAAS solutions to customers. To survive, we need to produce working application software. It\u0027s not an option for us to invest an indefinite amount of time and effort in searching solutions or workarounds to a resource that we (legitimately) expect to be reliable.\n\n- dotnet 9 is officially released for production\nWe are not using a preview, we are relying on a package that has been officially released for use in production, and fully supported by the supplier.\n\n- quoting your sentence \"..whether the crash is left unfixed, fixed on .NET 10 only..\"\nThe question is not this, the question is \"How many days from now will a patch be available that fixes this issue?\" Any answer different from \"it will take X days\", where X is \u003c 10, will legitimately raise a big question mark on whether our business (and, I am sure, many other businesses) should still trust .NET as their workhorse platform for applications.",
                                           "updatedAt":  "2025-03-09T22:00:18Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6hfRBL",
                                           "createdAt":  "2025-03-10T03:18:49Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "catamounttechnology",
                                           "body":  "This seems to be the offending recursion, all in \\libraries\\System.Private.CoreLib\\src\\System\\Threading\\Tasks\\Task.cs\n\n```\n        private void FinishStageTwo()\n        {\n            // At this point, the task is done executing and waiting for its children,\n            // we can transition our task to a completion state.\n\n            ContingentProperties? cp = Volatile.Read(ref m_contingentProperties);\n            if (cp != null)\n            {\n                AddExceptionsFromChildren(cp);\n            }\n\n            int completionState;\n            if (ExceptionRecorded)\n            {\n                completionState = (int)TaskStateFlags.Faulted;\n                if (TplEventSource.Log.IsEnabled())\n                    TplEventSource.Log.TraceOperationEnd(this.Id, AsyncCausalityStatus.Error);\n\n                if (s_asyncDebuggingEnabled)\n                    RemoveFromActiveTasks(this);\n            }\n            else if (IsCancellationRequested \u0026\u0026 IsCancellationAcknowledged)\n            {\n                // We transition into the TaskStateFlags.Canceled final state if the task\u0027s CT was signalled for cancellation,\n                // and the user delegate acknowledged the cancellation request by throwing an OCE,\n                // and the task hasn\u0027t otherwise transitioned into faulted state. (TaskStateFlags.Faulted trumps TaskStateFlags.Canceled)\n                //\n                // If the task threw an OCE without cancellation being requestsed (while the CT not being in signaled state),\n                // then we regard it as a regular exception\n\n                completionState = (int)TaskStateFlags.Canceled;\n                if (TplEventSource.Log.IsEnabled())\n                    TplEventSource.Log.TraceOperationEnd(this.Id, AsyncCausalityStatus.Canceled);\n\n                if (s_asyncDebuggingEnabled)\n                    RemoveFromActiveTasks(this);\n            }\n            else\n            {\n                completionState = (int)TaskStateFlags.RanToCompletion;\n                if (TplEventSource.Log.IsEnabled())\n                    TplEventSource.Log.TraceOperationEnd(this.Id, AsyncCausalityStatus.Completed);\n\n                if (s_asyncDebuggingEnabled)\n                    RemoveFromActiveTasks(this);\n            }\n\n            // Use Interlocked.Exchange() to effect a memory fence, preventing\n            // any SetCompleted() (or later) instructions from sneak back before it.\n            Interlocked.Exchange(ref m_stateFlags, m_stateFlags | completionState);\n\n            // Set the completion event if it\u0027s been lazy allocated.\n            // And if we made a cancellation registration, it\u0027s now unnecessary.\n            cp = Volatile.Read(ref m_contingentProperties); // need to re-read after updating state\n            if (cp != null)\n            {\n                cp.SetCompleted();\n                cp.UnregisterCancellationCallback();\n            }\n\n            // ready to run continuations and notify parent.\n            FinishStageThree(); \u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\n        }\n\n\n        internal void FinishStageThree()\n        {\n            // Release the action so that holding this task object alive doesn\u0027t also\n            // hold alive the body of the task.  We do this before notifying a parent,\n            // so that if notifying the parent completes the parent and causes\n            // its synchronous continuations to run, the GC can collect the state\n            // in the interim.  And we do it before finishing continuations, because\n            // continuations hold onto the task, and therefore are keeping it alive.\n            m_action = null;\n\n            ContingentProperties? cp = m_contingentProperties;\n            if (cp != null)\n            {\n                // Similarly, null out any ExecutionContext we may have captured,\n                // to avoid keeping state like async locals alive unnecessarily\n                // when the Task is kept alive.\n                cp.m_capturedContext = null;\n\n                // Notify parent if this was an attached task\n                NotifyParentIfPotentiallyAttachedTask(); \u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\n            }\n\n            // Activate continuations (if any).\n            FinishContinuations();\n        }\n\n        internal void NotifyParentIfPotentiallyAttachedTask()\n        {\n            Task? parent = m_contingentProperties?.m_parent;\n            if (parent != null\n                 \u0026\u0026 ((parent.CreationOptions \u0026 TaskCreationOptions.DenyChildAttach) == 0)\n                 \u0026\u0026 (((TaskCreationOptions)(m_stateFlags \u0026 (int)TaskStateFlags.OptionsMask)) \u0026 TaskCreationOptions.AttachedToParent) != 0)\n            {\n                parent.ProcessChildCompletion(this); \u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\n            }\n        }\n\n        internal void ProcessChildCompletion(Task childTask)\n        {\n            Debug.Assert(childTask != null);\n            Debug.Assert(childTask.IsCompleted, \"ProcessChildCompletion was called for an uncompleted task\");\n\n            Debug.Assert(childTask.m_contingentProperties?.m_parent == this, \"ProcessChildCompletion should only be called for a child of this task\");\n\n            ContingentProperties? props = Volatile.Read(ref m_contingentProperties);\n\n            // if the child threw and we haven\u0027t observed it we need to save it for future reference\n            if (childTask.IsFaulted \u0026\u0026 !childTask.IsExceptionObservedByParent)\n            {\n                // Lazily initialize the child exception list\n                if (props!.m_exceptionalChildren == null)\n                {\n                    Interlocked.CompareExchange(ref props.m_exceptionalChildren, new List\u003cTask\u003e(), null);\n                }\n\n                // In rare situations involving AppDomainUnload, it\u0027s possible (though unlikely) for FinishStageTwo() to be called\n                // multiple times for the same task.  In that case, AddExceptionsFromChildren() could be nulling m_exceptionalChildren\n                // out at the same time that we\u0027re processing it, resulting in a NullReferenceException here.  We\u0027ll protect\n                // ourselves by caching m_exceptionChildren in a local variable.\n                List\u003cTask\u003e? tmp = props.m_exceptionalChildren;\n                if (tmp != null)\n                {\n                    lock (tmp)\n                    {\n                        tmp.Add(childTask);\n                    }\n                }\n            }\n\n            if (Interlocked.Decrement(ref props!.m_completionCountdown) == 0)\n            {\n                // This call came from the final child to complete, and apparently we have previously given up this task\u0027s right to complete itself.\n                // So we need to invoke the final finish stage.\n\n                FinishStageTwo();^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n            }\n        }\n```\n\nFrom github copilot:\n\n\u003e Based on the search results and the provided context, it appears that the m_completionCountdown field in the ContingentProperties class is accessed and modified in various ways, including using Interlocked operations and Volatile.Read. This inconsistency in access patterns could potentially lead to subtle bugs, especially in a multi-threaded environment.\n\u003e Here is a summary of the relevant code and access patterns:\n\u003e 1.\tInterlocked Operations:\n\u003e •\tInterlocked.Decrement(ref props!.m_completionCountdown): This ensures atomic decrement operations, which is thread-safe.\n\u003e 2.\tVolatile.Read:\n\u003e •\tContingentProperties? props = Volatile.Read(ref m_contingentProperties): This ensures that the most recent value of m_contingentProperties is read.\n\u003e 3.\tDirect Access:\n\u003e •\tThere might be instances where m_completionCountdown is accessed directly without using Interlocked or Volatile.Read, which can lead to race conditions.\n\u003e Potential Bug:\n\u003e The inconsistency in how m_completionCountdown is accessed and modified can lead to race conditions, where multiple threads might read stale or incorrect values, leading to incorrect behavior or even a stack overflow due to recursive loop.",
                                           "updatedAt":  "2025-03-10T03:18:49Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6hgZNX",
                                           "createdAt":  "2025-03-10T07:08:56Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "KalleOlaviNiemitalo",
                                           "body":  "Yes, the recursion is there, but it is not clear why the chain of attached tasks would become so long in your application, which does not directly use TaskCreationOptions.AttachedToParent or TaskContinuationOptions.AttachedToParent.\n\nThe code I posted in \u003chttps://github.com/dotnet/runtime/issues/113189#issuecomment-2703075624\u003e is a way to build such a chain but obviously it is not part of a useful program.\n\n\u003chttps://learn.microsoft.com/en-us/dotnet/fsharp/language-reference/task-expressions#limitations-of-tasks-regarding-tailcalls\u003e warns about the risk of StackOverflowException in task expressions that create \"unbounded chains of tasks\" but I don\u0027t know whether that stack overflow would occur when the chain has been fully created and the tasks are being completed, like in your application, or already while the chain is being created.",
                                           "updatedAt":  "2025-03-10T07:08:56Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6hiAvN",
                                           "createdAt":  "2025-03-10T10:07:46Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "KalleOlaviNiemitalo",
                                           "body":  "In fact, the sample in \u003chttps://learn.microsoft.com/en-us/dotnet/fsharp/language-reference/task-expressions#limitations-of-tasks-regarding-tailcalls\u003e throws StackOverflowException already while the chain is being created.  So it is not the same as what happens in your application.",
                                           "updatedAt":  "2025-03-10T10:07:46Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6hpIuL",
                                           "createdAt":  "2025-03-10T21:43:18Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "catamounttechnology",
                                           "body":  "I am aware that the task CE is not tail recursive. That is why, in the code I posted (and in the rest of the application), the recursion is not on the task CE, but on the async CE, which is tailcall recursive.\n\nasync recursive loops are normal in FS (see https://en.wikibooks.org/wiki/F_Sharp_Programming/MailboxProcessor) .\n\nAnyway, again, the stack trace shows clearly that the offending loop is all confined in that module, if the origin was in the application (because the application makes a recursive call) then the stack trace would show it.\n\nMoreover, the code you posted does not have recursive calls (WorkAsync does not call itself directly), but still triggers the issue.",
                                           "updatedAt":  "2025-03-10T21:43:18Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6hppc1",
                                           "createdAt":  "2025-03-10T23:09:58Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "catamounttechnology",
                                           "body":  "Look at the tip of the stack trace\n\nSystem.Private.CoreLib.dll!System.Threading.PortableThreadPool.WorkerThread.WorkerThreadStart()\n\nand this is the source\n\n```\n            private static readonly ThreadStart s_workerThreadStart = WorkerThreadStart;\n\n            private static void CreateWorkerThread()\n            {\n                // Thread pool threads must start in the default execution context without transferring the context, so\n                // using UnsafeStart() instead of Start()\n                Thread workerThread = new Thread(s_workerThreadStart);\n                workerThread.IsThreadPoolThread = true;\n                workerThread.IsBackground = true;\n                // thread name will be set in thread proc\n                workerThread.UnsafeStart();\n            }\n\n            private static void WorkerThreadStart()\n            {\n                Thread.CurrentThread.SetThreadPoolWorkerThreadName();\n\n                PortableThreadPool threadPoolInstance = ThreadPoolInstance;\n\n```\n\nAll of this is private and it belongs to the .NET Thread Pool management. The crash is occurring on a Thread Pool management thread. There cannot be a direct call from user code into this chain.\n",
                                           "updatedAt":  "2025-03-10T23:10:23Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6h6STC",
                                           "createdAt":  "2025-03-12T04:27:43Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "catamounttechnology",
                                           "body":  "I have patched CoreLib and created a PR (https://github.com/dotnet/runtime/pull/113407)\n\nThe attachment here contains\n- Test.cs with the changes (simply look for comments ending in TIF)\n- The release build of System.Private.CoreLib.dll\n- The debug symbols System.Private.CoreLib.pdb\n\nAt the moment I simply replaced the dll under C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App\\9.0.3 in the target machine. Hasn\u0027t crashed, yet!\n\n@KalleOlaviNiemitalo \nit could be worthwhile to try and see whether your test code still triggers the stack overflow with the attached dll.\n\n[System.Private.CoreLib.zip](https://github.com/user-attachments/files/19202620/System.Private.CoreLib.zip)\n\n (https://github.com/dotnet/runtime/pull/113407)",
                                           "updatedAt":  "2025-03-12T04:41:01Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc66BzYe",
                                           "createdAt":  "2025-07-26T02:38:22Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jeffhandley",
                                           "body":  "Noting here that the #113407 PR was closed with a [comment](https://github.com/dotnet/runtime/pull/113407#issuecomment-2933239608) that the issue could be left open.",
                                           "updatedAt":  "2025-07-26T02:38:22Z"
                                       }
                                   ],
                         "totalCount":  16
                     },
        "title":  "Stack Overflow Exception caused by very deep parent/child Task chains",
        "labels":  [
                       "area-System.Threading.Tasks"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/116420",
        "createdAt":  "2025-06-09T00:04:54Z",
        "number":  116420,
        "author":  "NinoFloris",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHODDhjNw==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "timcassell",
                                            "createdAt":  "2025-06-09T20:31:38Z"
                                        },
                                        {
                                            "content":  "EYES",
                                            "user":  "filipnavara",
                                            "createdAt":  "2025-06-10T06:41:34Z"
                                        }
                                    ],
                          "totalCount":  2
                      },
        "updatedAt":  "2025-09-04T17:36:46Z",
        "body":  ".NET currently employs a race mitigating dispatch inside its Awaiter.{Unsafe}OnCompleted implementations. This is to prevent stack dives when a task was completed between the caller checking IsCompleted and calling OnCompleted.\n\nWould there be any appetite - maybe around the async2 effort - to retrofit something like what was done for C++\u0027s await_suspend to .NET\u0027s async await infrastructure?\n\nSpecifically: \nhttps://en.cppreference.com/w/cpp/language/coroutines.html\n\u003eif await_suspend returns void, control is immediately returned to the caller/resumer of the current coroutine (this coroutine remains suspended), otherwise      \u003c/br\u003e     \n\u003e if await_suspend returns bool, \n\u003e            the value true returns control to the caller/resumer of the current coroutine\n\u003e            the value false resumes the current coroutine. \n\nAs Raymond Chen explains in this blog post https://devblogs.microsoft.com/oldnewthing/20230202-00/ supporting this second form can sidestep the mitigation (or in C++\u0027s case avoid the stack dive) by communicating to the state machine it should resume itself instead.\n\nSupporting this for the BCL awaiters would concretely mean:\n- Landing C# support to recognize bool returning variants of AwaitOnCompleted and AwaitUnsafeOnCompleted methods on async method builders.\n- Adding these new methods - names tbd - to the BCL method builders.\n- Changes to internal implementations: Task.OnCompletedInternal, IStateMachineBoxAwareAwaiter, and other candidates to support the bool returning behavior.\n\nCompletely optionally, bringing this to the public api surface by adding new interface methods with default implementations on I{Critical}NotifyCompletion and IValueTaskSource{T}. I must admit, if there would be any chance for a new method on I{Critical}NotifyCompletion it would be a great moment to consider adding a state argument as well.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOsYZyxA==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6wIMqx",
                                           "createdAt":  "2025-06-09T07:32:40Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-threading-tasks\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2025-06-09T07:32:40Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6wNs6s",
                                           "createdAt":  "2025-06-09T17:05:15Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jkotas",
                                           "body":  "cc @VSadov ",
                                           "updatedAt":  "2025-06-09T17:05:15Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6wlgOQ",
                                           "createdAt":  "2025-06-11T13:03:41Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jakobbotsch",
                                           "body":  "Note that this stack diving is already less of a problem with runtime async due to how continuations are dispatched. In existing async, in the simple cases the continuations stored in a task are called as a result of calling `SetResult` on the task, which happens in the state machine\u0027s `MoveNext` method. Thus `MoveNext` of the _callee_ stays on the stack frame while the caller\u0027s continuation runs.\n\nIn runtime async that does not happen. The callee\u0027s continuation is executed by `DispatchContinuations`, and when it finishes, it returns back to `DispatchContinuations`. That function will proceed with executing the caller\u0027s continuation. So effectively unwinding is already happening for free.\n\nIt doesn\u0027t solve the problem entirely. It is still possible to hit stack overflows, for example by calling an awaiter that always invokes its continuation synchronously in a loop. Existing async also stack overflows in that case, however.",
                                           "updatedAt":  "2025-06-11T13:16:34Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6wl7Ak",
                                           "createdAt":  "2025-06-11T13:32:52Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "NinoFloris",
                                           "body":  "That would be the stack diving happening for a normal completion, though I\u0027m happy to hear it\u0027s reduced with runtime async.\n\nThis issue specifically describes the stack diving that can happen between IsCompleted and OnCompleted that .NET mitigates with an immediate dispatch inside OnCompleted, without attaching the given continuation (as the awaitable is already completed).",
                                           "updatedAt":  "2025-06-11T13:35:01Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6wnMmW",
                                           "createdAt":  "2025-06-11T14:28:00Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jakobbotsch",
                                           "body":  "Can you point me to the mitigation? The mitigation I\u0027m aware of are the calls to `RuntimeHelpers.TryEnsureSufficientExecutionStack()`, where the TPL infrastructure will move continuations to other threads instead of inlining them in some cases.\n\nOn immediate dispatch inside `OnCompleted` it seems the stack would grow, so the stack overflow would still be possible.",
                                           "updatedAt":  "2025-06-11T14:28:00Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6wnWvL",
                                           "createdAt":  "2025-06-11T14:40:00Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "NinoFloris",
                                           "body":  "It\u0027s here in ManualResetValueTaskSourceCore https://github.com/dotnet/runtime/blob/90236b918746148c9ae11ef4fca77fd57e388e74/src/libraries/System.Private.CoreLib/src/System/Threading/Tasks/Sources/ManualResetValueTaskSourceCore.cs#L174-L196 and I\u0027ve previously discussed this in https://github.com/dotnet/runtime/issues/77896\n\nAnd here in Task https://github.com/dotnet/runtime/blob/90236b918746148c9ae11ef4fca77fd57e388e74/src/libraries/System.Private.CoreLib/src/System/Threading/Tasks/Task.cs#L2529-L2536",
                                           "updatedAt":  "2025-06-11T14:40:00Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6wnhgu",
                                           "createdAt":  "2025-06-11T14:52:24Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jakobbotsch",
                                           "body":  "\u003e I\u0027ve previously discussed this in [#77896](https://github.com/dotnet/runtime/issues/77896)\n\nReading this I see the following:\n\n\u003e More problematically however is that after this dispatch is done the original stack unwinds to the next await which will now see IsCompleted false on the task returned (from the StreamPipeReader in this instance). This method will then also try to add its continuation while it\u0027s racing against the extremely simple SetResult continuation from the previously dispatched continuation. It can then fall into the same race branch (this time on the ManualResetValueTaskCore of the pooling method builder) and dispatch again as well.\n\nIn runtime async this does not happen. When the deepest callee suspends the chain of async functions unwind and link all continuations together. Once that linked list is created the continuation is registered into the deepest callee\u0027s awaiter. Assuming the deepest callee\u0027s awaiter completed in the mean time, the entire chain of continuations are then resumed synchronously by `DispatchContinuations`, without the stack growing.\n\nOf course it\u0027s hard to say that one strategy is ultimately best in all situations. The continuations are created eagerly in runtime async which means a longer period of time elapses between the `IsCompleted` check and the callback being queued into the awaiter.",
                                           "updatedAt":  "2025-06-11T17:50:25Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6xO_rm",
                                           "createdAt":  "2025-06-15T05:03:42Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "timcassell",
                                           "body":  "It might be nice to combine this with another improvement. https://github.com/dotnet/csharplang/discussions/8683\n\nI imagine something like this:\n\n```cs\npublic interface INotifyCompletion\u003cTResultGetter\u003e\n{\n    bool OnCompleted(Action continuation, out TResultGetter resultGetter);\n}\n```",
                                           "updatedAt":  "2025-06-15T05:03:42Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6xhnLE",
                                           "createdAt":  "2025-06-16T22:39:32Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "timcassell",
                                           "body":  "Actually, how would this work? The async state machine exists on the stack before `AwaitOnCompleted` is called. The continuation delegate can only be allocated once the state machine is lifted to the heap.\n\nCould the runtime rather tail-call it?",
                                           "updatedAt":  "2025-06-16T22:39:32Z"
                                       }
                                   ],
                         "totalCount":  9
                     },
        "title":  "Obsoleting race mitigating dispatch behavior in BCL awaiters",
        "labels":  [
                       "area-System.Threading.Tasks",
                       "needs-further-triage",
                       "runtime-async"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/118260",
        "createdAt":  "2025-08-01T06:18:47Z",
        "number":  118260,
        "author":  "pupsette",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHODKqbLA==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_DOWN",
                                            "user":  "neon-sunset",
                                            "createdAt":  "2025-08-02T19:33:36Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "mayorovp",
                                            "createdAt":  "2025-08-11T10:45:23Z"
                                        }
                                    ],
                          "totalCount":  2
                      },
        "updatedAt":  "2025-08-17T11:04:11Z",
        "body":  "### Description\n\nWhen using `Task.WhenAll` in more complex scenarios where child tasks of `Task.WhenAll` have other continuations, these continuations might be delayed (to an uncertain extend). Deadlocks are also easily possible, if the continuation of `Task.WhenAll` synchronously waits (blocking wait) for the continuation of the child task to complete.\n\n### Reproduction Steps\n\nThe example is basically one task with 500 ms delay and two follow up tasks.\n```csharp\nusing System;\nusing System.Diagnostics;\nusing System.Threading.Tasks;\nusing System.Threading;\n\npublic class Program\n{\n    public static async Task Main()\n    {\n        Stopwatch sw = Stopwatch.StartNew();\n        var initialTask = Task.Delay(500);\n        var whenAll = Task.WhenAll([initialTask]);\n        var otherTask1 = PrintAfterTask(\"X\", initialTask, sw);\n        var otherTask2 = PrintAfterTask(\"Y\", whenAll, sw);\n        await otherTask1;\n        await otherTask2;\n\n        async Task PrintAfterTask(string desc, Task t, Stopwatch sw)\n        {\n            await t;\n            Console.WriteLine($\"{sw.Elapsed.TotalMilliseconds:0} ms -- now starting {desc}\");\n            Thread.Sleep(1000);\n        }\n    }\n}\n```\n\n### Expected behavior\n\nBoth follow up tasks should be executed immediately after 500 ms delay.\n\n### Actual behavior\n\nThe task continuation directly attached to `initialTask` is blocked: The output is:\n```\n505 ms -- now starting Y\n1527 ms -- now starting X\n```\n\n### Regression?\n\nI tested this in .NET 8 and .NET 9. Seems to be the behavior since the very beginning.\n\n### Known Workarounds\n\nIn this specific case: Either remove the Task.WhenAll wrapper, or attach continuations to the WhenAllPromise using ContinueWith.\n\n### Configuration\n\n_No response_\n\n### Other information\n\n# Explanation attempt\n`Task.WhenAll` (more precisely the `WhenAllPromise`) registers itself (`ITaskCompletionAction`) as continuation at its child tasks. `ITaskCompletionAction` is by design meant to be called synchronously when a child task completes. But the implementation of the `WhenAllPromise` takes immediate action as soon as all child tasks complete and calls `TrySetResult`. Then, continuations of the `WhenAllPromise` are run, potentially syncrhonously (inlined). The current thread is still the one, which called the `ITaskCompletionAction` from the child task. It is blocked before iterating through all other continuations of this child task.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOvICPhQ==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc67Ub7w",
                                           "createdAt":  "2025-08-01T06:19:29Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-threading-tasks\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2025-08-01T06:19:29Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc67WQJi",
                                           "createdAt":  "2025-08-01T07:08:31Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEd0QOA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_DOWN",
                                                                               "user":  "mayorovp",
                                                                               "createdAt":  "2025-08-11T10:43:57Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "huoyaoyuan",
                                           "body":  "The delay actually comes from the `Thread.Sleep` call. If replace with `await Task.Delay`, the second continuation will continue in the same time.\n\nIf you set a break point in `PrintAfterTask`, you will see the two continuations being scheduled in the same worker thread.",
                                           "updatedAt":  "2025-08-01T07:08:31Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc67W52y",
                                           "createdAt":  "2025-08-01T07:22:22Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "pupsette",
                                           "body":  "Sure it does. But instead of `Thread.Sleep(500)` there could be any other CPU-bound work (which should be totally legit). This would unexpectedly block the other task.",
                                           "updatedAt":  "2025-08-01T07:22:22Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc67hzQp",
                                           "createdAt":  "2025-08-02T04:20:22Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "timcassell",
                                           "body":  "`Task.ConfigureAwait(ConfigureAwaitOptions)` exists exactly for this purpose.\n\n```cs\nawait t.ConfigureAwait(ConfigureAwaitOptions.ForceYielding)\n```",
                                           "updatedAt":  "2025-08-02T04:20:22Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc67iHYa",
                                           "createdAt":  "2025-08-02T07:08:49Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "pupsette",
                                           "body":  "For a user, there is no obvious reason to use `ForceYielding` or any other way to force asynchronous execution. Changing\n\n```csharp\nvar whenAll = Task.WhenAll([initialTask]);\n```\nto\n```csharp\nvar whenAll = initialTask;\n```\nmakes the program work correctly. How should a dev know about `Task.WhenAll` to block like that?\n\nSo please let\u0027s discuss the **expected behavior**:\nI think neither the usual developer expects this behavior, nor does the TPL documentation point out that behavior (at least, I could not find anything),\nPlease convince me, that from the code shown above, someone should expect the actual (blocking) behavior to be correct.",
                                           "updatedAt":  "2025-08-03T08:14:59Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc67qYRR",
                                           "createdAt":  "2025-08-03T14:09:55Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "pupsette",
                                           "body":  "For reference, this is a comment from the `Task.cs` source:\n```csharp\n// ITaskCompletionActions are only ever created by the runtime, and we always\n// try to execute them synchronously. For all other continuations (related to await), we only run it synchronously\n// if it\u0027s the first such continuation; otherwise, we force it to run asynchronously so as to not artificially\n// delay an await continuation behind other arbitrary user code created as a previous await continuation.\n```\nContinuations are meant to not be blocked by arbitrary user code from other continuations. Unfortunately, this is the case with my example.",
                                           "updatedAt":  "2025-08-03T14:09:55Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc68gI-F",
                                           "createdAt":  "2025-08-07T05:28:17Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "pupsette",
                                           "body":  "For completeness: `var whenAll = Task.WhenAny([initialTask]);` shows the same blocking behavior. In contrast, a user-defined wrapping task `var whenAll = WrappedTaskAsync(initialTask);` works as expected:\n```\nasync Task WrappedTaskAsync(Task other)\n{\n    await other;\n    Console.WriteLine(\"Continue work in wrapper...\");\n}\n```\nSo, there might be more implementations of `ITaskCompletionAction` which are affected, I haven\u0027t checked.",
                                           "updatedAt":  "2025-08-07T05:28:17Z"
                                       }
                                   ],
                         "totalCount":  7
                     },
        "title":  "Inlined continuation of Task.WhenAll prevents scheduling of child task continuations",
        "labels":  [
                       "area-System.Threading.Tasks",
                       "needs-further-triage"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/118955",
        "createdAt":  "2025-08-21T11:30:54Z",
        "number":  118955,
        "author":  "epeshk",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHODMIQfw==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "VladislavRudakoff",
                                            "createdAt":  "2025-08-21T11:31:26Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "ALTSL",
                                            "createdAt":  "2025-08-21T11:31:30Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "shuraleva",
                                            "createdAt":  "2025-08-21T11:31:48Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "11dot001001",
                                            "createdAt":  "2025-08-21T11:31:49Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "perdub",
                                            "createdAt":  "2025-08-21T11:32:03Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "tirelx",
                                            "createdAt":  "2025-08-21T11:32:19Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "bymse",
                                            "createdAt":  "2025-08-21T11:32:29Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "pengwin",
                                            "createdAt":  "2025-08-21T11:32:31Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "dvdrelin",
                                            "createdAt":  "2025-08-21T11:32:40Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "KirillKornienko",
                                            "createdAt":  "2025-08-21T11:32:54Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "densheludko",
                                            "createdAt":  "2025-08-21T11:32:59Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "KLRBDN",
                                            "createdAt":  "2025-08-21T11:33:04Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "krasninja",
                                            "createdAt":  "2025-08-21T11:33:27Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "spacentropy",
                                            "createdAt":  "2025-08-21T11:33:40Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "spbsmile",
                                            "createdAt":  "2025-08-21T11:34:15Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Svilsa",
                                            "createdAt":  "2025-08-21T11:34:30Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "dds72",
                                            "createdAt":  "2025-08-21T11:36:16Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "TheActualTwinkle",
                                            "createdAt":  "2025-08-21T11:36:17Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "brovig",
                                            "createdAt":  "2025-08-21T11:37:31Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Alexanderbtw",
                                            "createdAt":  "2025-08-21T11:37:50Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "DIMANRUS",
                                            "createdAt":  "2025-08-21T11:38:10Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "doctorw",
                                            "createdAt":  "2025-08-21T11:40:00Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "SonicGD",
                                            "createdAt":  "2025-08-21T11:46:23Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "myn1ckname",
                                            "createdAt":  "2025-08-21T11:46:26Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Tirael",
                                            "createdAt":  "2025-08-21T11:47:35Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "ftceo",
                                            "createdAt":  "2025-08-21T11:47:58Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "PchyolkaZloy",
                                            "createdAt":  "2025-08-21T11:49:06Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Jekyll007",
                                            "createdAt":  "2025-08-21T11:51:13Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "kalduzov",
                                            "createdAt":  "2025-08-21T11:51:43Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Jakimar",
                                            "createdAt":  "2025-08-21T11:53:14Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "shmutalov",
                                            "createdAt":  "2025-08-21T11:59:03Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "vchirikov",
                                            "createdAt":  "2025-08-21T12:06:51Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "vanbukin",
                                            "createdAt":  "2025-08-21T12:07:20Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "FedeArre",
                                            "createdAt":  "2025-08-21T12:13:05Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "fakefeik",
                                            "createdAt":  "2025-08-21T12:16:50Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Alexey-Stolyarov",
                                            "createdAt":  "2025-08-21T12:19:26Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "aafanasev-dodo",
                                            "createdAt":  "2025-08-21T12:20:22Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "ForNeVeR",
                                            "createdAt":  "2025-08-21T12:21:43Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "unsafePtr",
                                            "createdAt":  "2025-08-21T12:23:29Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "i-interested",
                                            "createdAt":  "2025-08-21T12:27:47Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Serg046",
                                            "createdAt":  "2025-08-21T12:39:41Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "wcoder",
                                            "createdAt":  "2025-08-21T12:58:17Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "nulladdict",
                                            "createdAt":  "2025-08-21T12:59:52Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "colejohnson66",
                                            "createdAt":  "2025-08-21T13:03:57Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "arwyl",
                                            "createdAt":  "2025-08-21T13:08:56Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "shvez",
                                            "createdAt":  "2025-08-21T13:23:06Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "rstm-sf",
                                            "createdAt":  "2025-08-21T13:30:19Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "DmitryNizhebovsky",
                                            "createdAt":  "2025-08-21T13:30:22Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "techiedesu",
                                            "createdAt":  "2025-08-21T13:52:52Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "BoundedChenn31",
                                            "createdAt":  "2025-08-21T14:06:19Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "kronic",
                                            "createdAt":  "2025-08-21T14:26:26Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "SeymourRu",
                                            "createdAt":  "2025-08-21T14:37:45Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "OlegZee",
                                            "createdAt":  "2025-08-21T16:32:42Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Yoticc",
                                            "createdAt":  "2025-08-21T17:02:17Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "dmtrnv",
                                            "createdAt":  "2025-08-21T17:43:36Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "istipeti",
                                            "createdAt":  "2025-08-21T20:14:22Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "tim-fay",
                                            "createdAt":  "2025-08-22T06:11:06Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Bazalii",
                                            "createdAt":  "2025-08-22T07:29:44Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Hawkwind250",
                                            "createdAt":  "2025-08-22T09:12:56Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "nsentinel",
                                            "createdAt":  "2025-08-22T11:35:24Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "sharpzilla",
                                            "createdAt":  "2025-08-22T18:40:47Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "AndrewP-GH",
                                            "createdAt":  "2025-08-22T21:36:13Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "WhiteBoll",
                                            "createdAt":  "2025-08-23T14:59:13Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "w7rus",
                                            "createdAt":  "2025-08-24T16:21:46Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "enrichmentt",
                                            "createdAt":  "2025-08-25T17:32:17Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "HaptelmanovArtem",
                                            "createdAt":  "2025-08-30T07:48:16Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "itymofeev",
                                            "createdAt":  "2025-09-08T18:41:31Z"
                                        }
                                    ],
                          "totalCount":  67
                      },
        "updatedAt":  "2025-09-05T17:15:02Z",
        "body":  "\u003c!--This is just a template - feel free to delete any and all of it and replace as appropriate.--\u003e\n\n### Description\n\nWhen a `Task` has more than one continuation, they are stored in `List\u003cobject\u003e`. On continuation removal, a linear search is performed in this `List` under lock. The `List` is shrunk only on additions. This may cause performance degradation and blocking of ThreadPool threads.\n\nOur system consists of several replicas: one leader and a number of reserve replicas. Only the leader processes incoming data. When a replica is running in reserve mode, it stores data in memory, waits for leadership to start stream processing, and drops the data already processed by the leader.\n\nIn code it looks exactly like this:\n```csharp\nvar leadershipCompletionSource = new TaskCompletionSource();\n\nasync Task ProcessData(Job job) {\n  Task jobFinishedTask = job.FinishedTask;\n  var leadershipTask = leadershipCompletionSource.Task;\n\n  if (!leadershipTask.IsCompleted \u0026\u0026 await Task.WhenAny(jobFinishedTask, leadershipTask) == jobFinishedTask)\n    return; // already processed by leader\n\n  // leadership is gained, process a job\n  // ...\n}\n```\n\nUnder high load, due to excessive client traffic, one of the reserve replicas failed. It became unresponsive and couldn\u0027t even answer /metrics requests from Prometheus.\n\nLuckily, this was noticed before an `OutOfMemoryException` occurred, and `dotnet stack` successfully captured stack traces from the unresponsive replica. There were hundreds of ThreadPool threads in `Task.AddTaskContinuationComplex` and `Task.RemoveContinuation` waiting for a lock. One of these threads passed inside the lock and was performing an `IndexOf` search in `Task.RemoveContinuation` on [this](https://github.com/dotnet/runtime/blob/00f1d4312ecd88eb4fe691676a43616220d6f390/src/libraries/System.Private.CoreLib/src/System/Threading/Tasks/Task.cs#L4671) line:\n```csharp\n// Find continuationObject in the continuation list\nint index = continuationsLocalListRef.IndexOf(continuationObject);\n```\n\n### Configuration\n\n.NET 9\n\n### Regression?\n\nNo regression\n\n### Data\n\nSingle threaded benchmark: https://gist.github.com/epeshk/2350b6e8551c25df1ff3c7ddcf1c233f\n\n### Analysis\n\nThe problem is an inefficient algorithm for storage and removal of `Task` continuations, in cases when there are 2 or more continuations for a single Task.\n\nThis algorithm:\n - has `O(list.Count)` complexity for removals\n - performs potentially long operations under lock. List.Resize is also performed under lock\n - has inefficient stale element removal. If the list grows to capacity N, then removal of `null` elements will occur only when `list.Count` has reached this N. Even if big N is a result of a temporary load peak\n - placed inside `Task` class, and intended to be running on threadpool threads. It could cause threadpool starvation.\n\nIt is done much better in `CancellationToken.Registrations` with a linked list. Also with a lock, but at least an O(1) removal.\n\n====\nIt is confusing to face this kind of performance issue in modern .NET. It\u0027s reminiscent of the TimerQueue scalability [issue](https://github.com/dotnet/runtime/issues/9114), which was fixed as soon as .NET went open-source.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOwkL-kQ==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6_VvGO",
                                           "createdAt":  "2025-08-21T11:32:57Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-threading-tasks\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2025-08-21T11:32:57Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6_Vw3e",
                                           "createdAt":  "2025-08-21T11:35:35Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "MihuBot",
                                           "body":  "I\u0027m a bot. Here is a possible related and/or duplicate issue (I may be wrong):\n- https://github.com/dotnet/runtime/issues/7253",
                                           "updatedAt":  "2025-08-21T11:35:35Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc7CNJwe",
                                           "createdAt":  "2025-09-05T12:46:04Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "Can you elaborate on what you are doing that you have so many continuations on the same incomplete task at the same time that this is a problem?",
                                           "updatedAt":  "2025-09-05T12:46:04Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc7CO2Se",
                                           "createdAt":  "2025-09-05T15:02:27Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "epeshk",
                                           "body":  "Usage scenario was already described in the issue:\n\n\u003e Our system consists of several replicas: one leader and a number of reserve replicas. Only the leader processes incoming data. When a replica is running in reserve mode, it stores data in memory, waits for leadership to start stream processing, and drops the data already processed by the leader.\n\u003e\n\u003e In code it looks exactly like this:\n\u003e\n\u003e ```csharp\n\u003e var leadershipCompletionSource = new TaskCompletionSource();\n\u003e \n\u003e async Task ProcessData(Job job) {\n\u003e   Task jobFinishedTask = job.FinishedTask;\n\u003e   var leadershipTask = leadershipCompletionSource.Task;\n\u003e \n\u003e   if (!leadershipTask.IsCompleted \u0026\u0026 await Task.WhenAny(jobFinishedTask, leadershipTask) == jobFinishedTask)\n\u003e     return; // already processed by leader\n\u003e \n\u003e   // leadership is gained, process a job\n\u003e   // ...\n\u003e }\n\u003e ```\n\nThis code worked for two years, and failed absolutely unexpectedly",
                                           "updatedAt":  "2025-09-05T15:02:27Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc7CO9SL",
                                           "createdAt":  "2025-09-05T15:08:10Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEhFaGQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "epeshk",
                                                                               "createdAt":  "2025-09-05T16:07:17Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "NinoFloris",
                                           "body":  "Any kind of async initializer on the request path of a high rps web app could hit this. Think tenant or cache initialization.",
                                           "updatedAt":  "2025-09-05T15:08:10Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc7CPAPE",
                                           "createdAt":  "2025-09-05T15:11:41Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEhUzng==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "kemsky",
                                                                               "createdAt":  "2025-09-08T15:03:40Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e Any kind of async initializer on the request path of a high rps web app could hit this. Think tenant or cache initialization.\n\nIt _could_, but this is only about removals, not additions.\n\nMaking continuation removal `O(1)` would make every non-first continuation addition more expensive, both in allocation and in throughput. I\u0027m not at all convinced that\u0027s a good tradeoff. \n\nThe continuation support already has two cases it handles: the vastly most common case of just one continuation, and the rarer case of multiple continuations. It\u0027s possible the rarer case could be split into a rare and even rarer case, based on number of continuations involved, e.g. where once the continuation count hits some threshold, it switches from using a `List\u003c\u003e` to a `HashSet\u003c\u003e` or something like that. That adds a fair amount of complexity, though.\n\nThe current approach has been in place for over 15 years, and this is the first time I\u0027ve heard of it causing problems.",
                                           "updatedAt":  "2025-09-05T15:29:00Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc7CPWBJ",
                                           "createdAt":  "2025-09-05T15:32:48Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "NinoFloris",
                                           "body":  "I understand but generally these requests would also use a WhenAny over the requestaborted or some other timeout cancellationtoken",
                                           "updatedAt":  "2025-09-05T15:32:48Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc7CPgpK",
                                           "createdAt":  "2025-09-05T15:48:16Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e I understand but generally these requests would also use a WhenAny over the requestaborted or some other timeout cancellationtoken\n\nThere\u0027s only a removal in such cases in the already expensive scenario of the request being aborted / cancellation being requested.\n\nI\u0027m not saying I can\u0027t construct a situation where it would be problematic. I\u0027m saying there\u0027s a good reason I\u0027ve not heard anyone having problems with this in 15 years. ",
                                           "updatedAt":  "2025-09-05T15:48:16Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc7CQjyg",
                                           "createdAt":  "2025-09-05T16:55:27Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "NinoFloris",
                                           "body":  "Agreed, it is an unexpected perf cliff though. \n\nIt has some similarities to the exception perf problems that were fixed for these kinds of high failure situations. \n\nIt has probably been much less of a real problem as it needs to coincide with these task based sync points being heavily saturated.",
                                           "updatedAt":  "2025-09-05T16:55:27Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc7CQv6R",
                                           "createdAt":  "2025-09-05T17:11:21Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "epeshk",
                                           "body":  "It is the same problem that with $O(n^2)$ algorithms. It is good enough until it suddenly isn\u0027t. In this case, it is impossible to guess this kind of issue without reading through System.Threading.Tasks internals, and hard to catch without full production load.\n\nAnd when the problem triggered, system fails without any possibility of recovery. Especially bad, that it is usually a ThreadPool threads that working with Tasks and then got blocked.\n\nI understand that `List\u003cT\u003e` approach have some benefits, but sure that it is possible to implement \"rare and even rarer\" approach without performance overhead for typical (small) scenarios.\n\nE.g., with something like this:\n```cs\nclass ListOrLinkedList\u003cT\u003e { // lock object\n  object items; // T[], or LinkedList, or Task.Continuations (similar to CancellationToken.Registrations)\n  int count;\n}\n```",
                                           "updatedAt":  "2025-09-05T17:15:02Z"
                                       }
                                   ],
                         "totalCount":  10
                     },
        "title":  "Task continuation removal is O(n) under lock, causes threadpool starvation",
        "labels":  [
                       "area-System.Threading.Tasks",
                       "tenet-reliability"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/119232",
        "createdAt":  "2025-08-31T11:20:33Z",
        "number":  119232,
        "author":  "mgravell",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-08-31T18:06:49Z",
        "body":  "### Background and motivation\n\nThere are times when awaitable items are used as \"futures\", but in a pre-pending state. Meaning: trying to await them right now will be a doomed deadlock, unless you have some kind of cancellation/timeout in place. Example:\n\n``` c#\n// SE.Redis\nvar tran = dB.CreateTransaction();\nvar pending = tran.IncrAsync(key);\n//... others\nawait pending; // ERROR\n// the above is doomed until after\nawait tran.ExecuteAsync();\n\n// down here (after the ExecuteAsync): this would be fine\nvar count = await pending;\n```\n\nThis is detectable in custom awaitables, and in valuetasks based on IVTS - we can check the state in OnCompleted etc, and if it is doomed: transition into a faulted state. However, this currently doesn\u0027t work if someone has used AsTask() to get the pending operation as a Task, because the custom Task for IVTS subscribes immediately, [here](https://github.com/dotnet/runtime/blob/1d1bf92fcf43aa6981804dc53c5174445069c9e4/src/libraries/System.Private.CoreLib/src/System/Threading/Tasks/ValueTask.cs#L290) (x2, typed/untyped). This means that the moment they call AsTask, we would transition it to doomed.\n\n### API Proposal\n\nNo public API change.\n\nInternally, use a deferred subscription mechanism for Pending IVTS cases. The IVTS is already stored (otherwise, we could use AsyncState). Proposal: add a new deferred state; when in that state:\n\n- status checks (IsCompleted, etc) should refer to the IVTS instead of locally\n- result related operations (Wait, GetResult, OnCompleted, ContinueWith, etc) would *only then, first time* subscribe to the IVTS via OnCompleted etc, transitioning back into local mode; once in local mode, normal service is resumed\n\n### API Usage\n\nNo public signature change. Behaviourally, the following scenario becomes possible:\n\n``` c#\nvar task = prePendingIVTS.AsTask();\nMakeHappy(prePendingIVTS); //\nawait task; // fine\n```\n\nAnd\n\n``` c#\nvar task = prePendingIVTS.AsTask();\nawait task; // boom, fault detected\n```\n\nThe point here is correctness and simplicity of debugging. Currently, because we can\u0027t prevent people turning VTs to Ts via AsTask(), we have to omit the deadlock detection that would have told them what they did wrong.\n\nProbably a @stephentoub topic!\n\nI can provide examples and tests if this is of interest.\n\n### Alternative Designs\n\n\n### Risks\n\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOwR-EDQ==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc7BH3XX",
                                           "createdAt":  "2025-08-31T11:21:20Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-threading-tasks\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2025-08-31T11:21:20Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc7BH4QN",
                                           "createdAt":  "2025-08-31T11:27:45Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "mgravell",
                                           "body":  "Risk mitigation suggestion: maybe a new marker interface (IDeferredValueTaskSource or similar) would be useful; if it isn\u0027t implemented by the IVTS: do what you\u0027ve always done. If it is implemented: do the new thing. The counter to that is: this then creates more possible states. This could perhaps also have a `IsPrePending` (naming is hard, also: prop? or method with token?) to further narrow the scenarios so that `is IDeferredValueTaskSource { IsPrePending: true }` becomes the test.\n\nAlternatively: maybe a new ValueTaskSourceStatus enum value. Given that very little code *consumes* IValueTaskSource, this might be a reasonable approach. Existing *producers* (IVTS implementations) would not need an update - they\u0027d just not return the new value. Would report the same as Pending in terms of the various IsWhatever ValueTask methods. In terms of Task.... maybe WaitingToRun?\n",
                                           "updatedAt":  "2025-08-31T12:21:40Z"
                                       }
                                   ],
                         "totalCount":  2
                     },
        "title":  "[API Proposal]: ValueTask-\u003eTask: allow deferred callback hook for IVTS scenario",
        "labels":  [
                       "api-suggestion",
                       "area-System.Threading.Tasks",
                       "needs-further-triage"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/119241",
        "createdAt":  "2025-09-01T07:13:35Z",
        "number":  119241,
        "author":  "Kation",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-09-02T10:56:07Z",
        "body":  "### Description\n\ntested in .NET 9.\n\n### Reproduction Steps\n\n```csharp\nvar channel = Channel.CreateUnbounded\u003cint\u003e();\nvar cts = new CancellationTokenSource();\nvar task = channel.Reader.ReadAsync(cts.Token);\nvar tcs = new TaskCompletionSource();\nConsole.CancelKeyPress += (_, e) =\u003e\n{\n    //e.Cancel = true;//without this, ReadAsync never return\n    cts.Cancel();\n    tcs.SetResult();\n};\nConsole.WriteLine(\"Running.\");\nawait tcs.Task;\nConsole.WriteLine(\"Shutting down...\");\ntry\n{\n    await task;\n}\ncatch { }\nConsole.WriteLine(\"Shutdown completed.\");\n```\n\n### Expected behavior\n\nCancel `ReadAsync` task.\n\n### Actual behavior\n\n`ReadAsync` task still running.\n\n### Regression?\n\n_No response_\n\n### Known Workarounds\n\nSet `Cancel` = `true` in `CancelKeyPress` event.\n\n### Configuration\n\n_No response_\n\n### Other information\n\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOwWgiVw==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc7BL8Se",
                                           "createdAt":  "2025-09-01T07:14:19Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-threading-tasks\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2025-09-01T07:14:19Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc7BMkfl",
                                           "createdAt":  "2025-09-01T08:03:19Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Kation",
                                           "body":  "It seems only occur while debugger attached.",
                                           "updatedAt":  "2025-09-01T08:03:19Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc7BVSfd",
                                           "createdAt":  "2025-09-02T02:20:56Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jeffhandley",
                                           "body":  "Thanks for the comment about it only occurring with the debugger attached, and for the minimal repro. I don\u0027t expect our team will investigate this, but we will leave it open with https://github.com/dotnet/runtime/labels/help%20wanted and would consider accepting a pull request if the fix is low-risk.",
                                           "updatedAt":  "2025-09-02T02:20:56Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc7BWb6G",
                                           "createdAt":  "2025-09-02T05:59:41Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "KalleOlaviNiemitalo",
                                           "body":  "Does it make a difference if you put TaskCreationOptions.RunContinuationsAsynchronously on the TaskCompletionSource?",
                                           "updatedAt":  "2025-09-02T05:59:41Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc7BaCJX",
                                           "createdAt":  "2025-09-02T10:56:07Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEggT9w==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "KalleOlaviNiemitalo",
                                                                               "createdAt":  "2025-09-02T13:24:57Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "Kation",
                                           "body":  "@KalleOlaviNiemitalo Same result",
                                           "updatedAt":  "2025-09-02T10:56:07Z"
                                       }
                                   ],
                         "totalCount":  5
                     },
        "title":  "[Channel] Cancel in CancelKeyPress event do not stop read task",
        "labels":  [
                       "area-System.Threading.Tasks",
                       "help wanted"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/119465",
        "createdAt":  "2025-09-08T16:45:02Z",
        "number":  119465,
        "author":  "AR-May",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-09-16T19:06:55Z",
        "body":  "### Background and motivation\n\nMSBuild wants to introduce new API to support migration to a multithreaded mode of operation (today MSBuild multi-process to get parallelism). \n\nMulti-process architecture allows MSBuild tasks to freely access or modify environment variables or the current working directory. MSBuild also changes current directory to directory of the project on the beginning of the project build, so that all relative paths resolve relative to it. Even very basic MSBuild tasks hugely rely on this behavior.\n\nMultithreaded mode changes those assumptions and thus requires a new task design to ensure that multiple tasks do not access/modify shared process state, and the relative paths are resolved correctly. MSBuild will provide API that allows to access thread-wide state and will provide Roslyn analyzer to ban APIs that would not be safe to use in new tasks, like `Path.GetFullPath()` (more details [here](\nhttps://github.com/dotnet/msbuild/blob/52243b2444283020d521d3bd6457e2f9b0c45ddc/documentation/specs/multithreading/thread-safe-tasks-api-analysis.md)).\n\nLink to proposed [spec](https://github.com/dotnet/msbuild/blob/52243b2444283020d521d3bd6457e2f9b0c45ddc/documentation/specs/multithreading/thread-safe-tasks.md) with more details.\n\n\n### API Proposal\n\nTasks will indicate thread-safety capabilities by implementing the `IThreadSafeTask` interface. Task authors will get access to an `ExecutionContext` that holds thread-wide state and provides safe alternatives to global process state APIs.\n```csharp\nnamespace Microsoft.Build.Framework;\npublic interface IThreadSafeTask : ITask\n{\n    TaskExecutionContext? ExecutionContext { get; set; }\n}\n\npublic abstract class TaskExecutionContext\n{ \n    public abstract AbsolutePath CurrentDirectory { get; set; }\n\n    public abstract AbsolutePath GetAbsolutePath(string path);\n    \n    public abstract string? GetEnvironmentVariable(string name);\n    public abstract IReadOnlyDictionary\u003cstring, string\u003e GetEnvironmentVariables();\n    public abstract void SetEnvironmentVariable(string name, string? value);\n\n    public abstract ProcessStartInfo GetProcessStartInfo();\n    public abstract Process StartProcess(ProcessStartInfo startInfo);\n    public abstract Process StartProcess(string fileName);\n    public abstract Process StartProcess(string fileName, IEnumerable\u003cstring\u003e arguments);\n}\n\npublic readonly struct AbsolutePath\n{\n    public string Path { get; }\n    // Tasks authors should not be able to create AbsolutePath object without using TaskExecutionContext object.\n    internal AbsolutePath(string path) { }\n    public AbsolutePath(string path, AbsolutePath basePath) { }\n    public static implicit operator string(AbsolutePath path) { }\n}\n\npublic readonly struct RelativePath\n{\n    public string Path { get; }\n    public RelativePath(string path) { }\n    public AbsolutePath ToAbsolutePath(AbsolutePath basePath) { }\n    // Tasks authors should not be able to cast RelativePath to AbsolutePath without providing the absolute path.\n    internal AbsolutePath ToAbsolutePath() { }\n    public static implicit operator string(RelativePath path) { }\n}\n```\n\nMSBuild will offer a `ThreadSafeTask` abstract class with default implementations for the `IThreadSafeTask` interface to help customers write a thread-safe task.\n```csharp\nnamespace Microsoft.Build.Utilities;\npublic abstract class ThreadSafeTask : Task, IThreadSafeTask\n{\n    public TaskExecutionContext? ExecutionContext { get; set; }\n}\n```\n\nTask authors will be able to indicate thread-safety capabilities using attributes. Tasks marked with this attribute can run in multithreaded builds but do not have access to the `ExecutionContext` APIs.\n\n```csharp\nnamespace Microsoft.Build.Framework;\n[AttributeUsage(AttributeTargets.Class, AllowMultiple = false)]\npublic class ThreadSafeAttribute : Attribute\n{\n    public ThreadSafeAttribute() { }\n}\n```\n\n\n### API Usage\n\n\n```csharp\nusing Microsoft.Build.Framework;\nusing Microsoft.Build.Utilities;\n\npublic class MyTask : ThreadSafeTask\n{\n    public override bool Execute()\n    {\n        ...\n        // Use APIs provided by ExecutionContext\n        string envVar = ExecutionContext.GetEnvironmentVariable(\"EnvVar\");\n       \n        // Convert string properties to strongly-typed paths and use them in standard File/Directory APIs\n        AbsolutePath path = ExecutionContext.GetAbsolutePath(\"SomePath\");\n        string content = File.ReadAllText(path);\n        ...\n    }\n}\n\n[ThreadSafe]\npublic class MyTask2 : Task \n{\n    // Code that is not relying on the process-level state\n}\n```\n\n### Alternative Designs\n\n\nAn alternative approach would be to use a parameter-based design:\n\n```csharp\nnamespace Microsoft.Build.Framework;\npublic interface IThreadSafeTask\n{\n    bool Execute(TaskExecutionContext context);\n}\n```\n```csharp\nnamespace Microsoft.Build.Utilities;\npublic abstract class ThreadSafeTask : IThreadSafeTask\n{\n    bool Execute(TaskExecutionContext context);\n    ... // everything else is same as in Microsoft.Build.Utilities.Task\n}\n```\n**Question:** For this parameter-based approach, we need to decide whether MSBuild should support async task execution (using `ExecuteAsync` methods) to avoid creating multiple overloads of the Execute method in the `IThreadSafeTask` interface.\n\n### Risks\n\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOxLAf-g==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc7DTsLf",
                                           "createdAt":  "2025-09-10T22:18:22Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/area-system-threading-tasks\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2025-09-10T22:18:22Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc7EsB_6",
                                           "createdAt":  "2025-09-16T18:25:25Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "bartonjs",
                                           "body":  "[Video](https://www.youtube.com/watch?v=rsjimPqjyDY\u0026t=0h0m0s)\n\n* `TaskExecutionContext`, sounds like a type deriving from `ExecutionContext`, so a different name might be good.\n  * `TaskState`?  `TaskEnvironment`?\n  * Updated the proposal to reflect TaskEnvironment as the new working name.\n* The `abstract` of TaskExecutionContext doesn\u0027t seem necessary.  On any of the methods.\n* Constructing an AbsolutePath from a string containing an absolute path feels cumbersome.\n  * Moved `internal AbsolutePath(string)` to `internal AbsolutePath(string, bool)`, and added `public AbsolutePath(string)` which can use Path.IsPathRooted(string) and throw if the input is not.\n* In discussion, it seemed like RelativePath is not really needed outside of MSBuild itself, so it has been removed from the proposal.\n* Not all of the overloads of `StartProcess` seem important here.\n  * StartProcess(ProcessStartInfo) is either trivial, and shouldn\u0027t exist, or overwrites CurrentDirectory and environment, which is surprising (so it probably shouldn\u0027t exist).\n  * If the other two overloads are going to eliminate the need to configure ProcessStartInfo for \"99%\" of potential callers, then they\u0027re fine, otherwise recommend cutting them in favor of just calling GetProcessStartInfo()\n* Decide what behavior you want for default(AbsolutePath).\n  * Perhaps the Path property should return string.Empty.\n  * Other suggestions include system root (`/` or `%SYSTEMROOT%\\`), or `GetRootedProjectPathFromMSBuild()`\n* For the analyzer looking at AbsolutePath, be sure to check for the implicit operator, the Path property, or the ToString() method, all are viable ways of converting the struct to a path-string.\n* `[ThreadSafe]` is an overreaching name.\n  * `[MSBuildThreadSafeTask]` seems like a reasonable name.\n  * Consider not shipping the public copy if the expected behavior is that libraries with a high enough compile target just use the new interface.\n* Instead of `ThreadSafeTask` and `IThreadSafeTask`, consider `ParallelAwareTask`, `MultiThreadableTask`, etc.\n\n```C#\nnamespace Microsoft.Build.Framework;\n\npublic interface IMultiThreadableTask : ITask\n{\n    TaskEnvironment TaskEnvironment { get; set; }\n}\n\npublic class TaskEnvironment\n{ \n    public AbsolutePath CurrentDirectory { get; set; }\n\n    public AbsolutePath GetAbsolutePath(string path);\n    \n    public string? GetEnvironmentVariable(string name);\n    public IReadOnlyDictionary\u003cstring, string\u003e GetEnvironmentVariables();\n    public void SetEnvironmentVariable(string name, string? value);\n\n    public ProcessStartInfo GetProcessStartInfo();\n    public Process StartProcess(string fileName);\n    public Process StartProcess(string fileName, IEnumerable\u003cstring\u003e arguments);\n}\n\npublic readonly struct AbsolutePath\n{\n    public string Path { get; }\n    // Tasks authors should not be able to create AbsolutePath object without using TaskExecutionContext object.\n    internal AbsolutePath(string path, bool ignoreRootedCheck) { }\n\n    public AbsolutePath(string path); // Checks Path.IsPathRooted\n    public AbsolutePath(string path, AbsolutePath basePath) { }\n    public static implicit operator string(AbsolutePath path) { }\n    public override string ToString() =\u003e Path;\n}\n\n[AttributeUsage(AttributeTargets.Class, AllowMultiple = false)]\npublic class MSBuildThreadSafeTaskAttribute : Attribute\n{\n    public MSBuildThreadSafeTaskAttribute() { }\n}\n\nnamespace Microsoft.Build.Utilities;\n\npublic abstract class MultiThreadableTask : Task, IMultiThreadableTask\n{\n    public TaskEnvironment? TaskEnvironment{ get; set; }\n}\n```",
                                           "updatedAt":  "2025-09-16T19:06:55Z"
                                       }
                                   ],
                         "totalCount":  2
                     },
        "title":  "[API Proposal]: MSBuild APIs for supporting multithreaded mode of operation",
        "labels":  [
                       "api-approved",
                       "area-System.Threading.Tasks"
                   ]
    }
]
