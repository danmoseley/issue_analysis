[
    {
        "url":  "https://github.com/dotnet/runtime/issues/36551",
        "createdAt":  "2017-12-05T05:25:56Z",
        "number":  36551,
        "author":  "rynowak",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2022-05-13T12:55:58Z",
        "body":  "This item tracks some support for providing a client handler that will do authentication for you and handle token refreshes transparently.  Any mechanism that requires user-intervention during the authentication process is out of scope.\r\n\r\nThis is a future looking tracking item and is not planned for 2.1.0.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOQx3Ptw==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDM1ODY2NDcyNg==",
                                           "createdAt":  "2018-01-18T14:35:44Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "darrelmiller",
                                           "body":  "Can it handle any arbitrary auth scheme like CredenticalCache used to?  Something like https://github.com/tavis-software/Tavis.Auth/blob/master/src/Auth/AuthMessageHandler.cs ?",
                                           "updatedAt":  "2018-01-18T14:35:44Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDM1ODcxOTA4Ng==",
                                           "createdAt":  "2018-01-18T17:24:24Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "rynowak",
                                           "body":  "Open to suggestions. We\u0027re not going to start working on this for a little while.",
                                           "updatedAt":  "2018-01-18T17:24:39Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDM3NDkyNDQyNw==",
                                           "createdAt":  "2018-03-21T12:46:02Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOAYL5_g==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "poke",
                                                                               "createdAt":  "2018-06-20T14:54:44Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "johnkors",
                                           "body":  "I think you can plug any handler you want, for [example the AccessTokenHandler from IdentityModel](https://github.com/IdentityModel/IdentityModel2/blob/de6a9f4bbdc2851568ffc003b49ca2751c845633/src/Client/AccessTokenDelegatingHandler.cs), which handles refreshes..?\r\n\r\nConfiguring the HttpClientFactoryOptions:\r\n```c#\r\noptions.HttpMessageHandlerBuilderActions.Add(b =\u003e\r\n{\r\n   b.PrimaryHandler = new AccessTokenHandler(tokenEndpoint, clientId, clientSecret);\r\n});\r\n```",
                                           "updatedAt":  "2021-02-10T17:28:01Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDM5ODc4MTQ5Mg==",
                                           "createdAt":  "2018-06-20T14:56:23Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "poke",
                                           "body":  "IdentityModel 3.7 adds `AccessTokenDelegatingHandler` and `RefreshTokenDelegatingHandler` which work nicely for this when added as `AdditionalHandlers`.",
                                           "updatedAt":  "2018-06-20T14:56:23Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQyOTc3NTcyMg==",
                                           "createdAt":  "2018-10-15T09:37:48Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "xneg",
                                           "body":  "How do you want to link asynchronous token retrieval with synchronous ```factory.CreateClient()```?\r\nDo you want to extend IHttpClientFactory contract adding something like ```CreateClientAsync()```?",
                                           "updatedAt":  "2018-10-15T09:37:48Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQyOTc4MjY4NQ==",
                                           "createdAt":  "2018-10-15T09:58:16Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "martincostello",
                                           "body":  "The token creation would happen asynchronously as part of the HTTP requests, not as part of the client creation.",
                                           "updatedAt":  "2018-10-15T09:58:16Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQyOTc4NjMzMg==",
                                           "createdAt":  "2018-10-15T10:07:56Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "xneg",
                                           "body":  "@martincostello got you, thanks! Just trying to create something similar using current factory realization...",
                                           "updatedAt":  "2018-10-15T10:07:56Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ3MDE3ODEzNA==",
                                           "createdAt":  "2019-03-06T16:33:49Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "rggammon",
                                           "body":  "One idea - if there were something like a IHttpClientFactory.CreateClient() that accepted additional DelegatingHandler\u0027s for the specific client (in this case, a handler for handling auth / tokens), that would give me the ability to initialize the auth handler from the code creating the http client.\r\n\r\nSimilar to HttpClientFactory.Create() in System.Net.Http.Formatting.",
                                           "updatedAt":  "2019-03-06T16:33:49Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc43nn1V",
                                           "createdAt":  "2021-10-04T04:27:54Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "davidfowl",
                                           "body":  "I\u0027m not sure what needs to be done here to HttpClientFactory itself. ",
                                           "updatedAt":  "2021-10-04T04:27:54Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5DHc-3",
                                           "createdAt":  "2022-05-13T12:55:58Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "gklittlejohn",
                                           "body":  "Is it valid to use IHttpMessageHandlerFactory for this type of scenario i.e. for allowing additional handlers for access tokens to be created  at runtime?:\r\n\r\n```csharp\r\nIHttpMessageHandlerFactory messageHandlerFactory = services.GetRequiredService\u003cIHttpMessageHandlerFactory\u003e();\r\nHttpMessageHandler factoryHandler = factory.CreateHandler();\r\nHttpClient httpClient = new HttpClient(new AccessTokenHandler(factoryHandler), disposeHandler: false)\r\n```",
                                           "updatedAt":  "2022-05-13T12:55:58Z"
                                       }
                                   ],
                         "totalCount":  10
                     },
        "title":  "Handle authorization tokens with a client handler",
        "labels":  [
                       "enhancement",
                       "area-Extensions-HttpClientFactory"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/35997",
        "createdAt":  "2018-09-27T12:42:32Z",
        "number":  35997,
        "author":  "xneg",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHODCGtIw==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "daiplusplus",
                                            "createdAt":  "2019-08-26T07:55:18Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "myFirstway",
                                            "createdAt":  "2019-11-17T16:29:16Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "MigratoryCoconuts",
                                            "createdAt":  "2019-11-21T22:03:18Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "oising",
                                            "createdAt":  "2019-11-22T16:21:40Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "RobSiklos",
                                            "createdAt":  "2021-11-24T20:02:52Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "PMExtra",
                                            "createdAt":  "2022-11-14T08:22:19Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "unseensenpai",
                                            "createdAt":  "2024-12-04T11:21:24Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "CSymes",
                                            "createdAt":  "2025-05-07T04:26:48Z"
                                        }
                                    ],
                          "totalCount":  8
                      },
        "updatedAt":  "2023-01-25T16:03:52Z",
        "body":  "There is need to add new HttpClients to my new APIs when my app is setuped and running. Here is the code from default factory implementation [DefatulHttpClientFactory](https://github.com/aspnet/HttpClientFactory/blob/9edb6d12d039efdda6a8038227b146bfd12f7ab5/src/Microsoft.Extensions.Http/DefaultHttpClientFactory.cs) for creating new handler and client:\r\n\r\n```c#\r\nvar entry = _activeHandlers.GetOrAdd(name, _entryFactory).Value;\r\nvar client = new HttpClient(entry.Handler, disposeHandler: false);\r\n```\r\nKnowing this implementation we can use **name** that was **not** registered via\r\n`services.AddHttpClient(...)` in `ConfigureServices(IServiceCollection services)` of `Startup`.\r\n\r\nBut we still need to configure parameters for returned HttpClient like BaseAddress and Headers. And we can\u0027t setup handler lifetime using this way.\r\n\r\nMy proposal is to add somehow ability to register named clients with the way like `services.AddHttpClient(...)` but not in  `ConfigureServices` and later. \r\n\r\nMy first solution was to create decorator for `DefaultHttpClientFactory` to implement adding actions for httpClient but I still can\u0027t set handler lifetime.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOU60KYQ==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQyODA4NzQyMA==",
                                           "createdAt":  "2018-10-09T07:21:29Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCrVmLQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "aivanov-oneinc",
                                                                               "createdAt":  "2022-08-29T22:20:27Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "theduffmtl",
                                           "body":  "I have the same issue I think that new client should be configurable after the DI phase. I\u0027d rather set up my client in the app building phase. it seems just make more sense. (especially if you don\u0027t  use typed client) \r\n\r\nOn top of that I have apps that implements webhook pattern so unknown customer at bootstrap will subscribe to my Api. Hence I need to create a new httclient base on that new client. With the current setup it is impossible. \r\n\r\n\r\n\r\n",
                                           "updatedAt":  "2018-10-09T07:21:29Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQyODEwNDc1Mw==",
                                           "createdAt":  "2018-10-09T08:24:02Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "davidfowl",
                                           "body":  "Can you show an example of how you would want to use it?",
                                           "updatedAt":  "2018-10-09T08:24:02Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQyODI1NzE3MA==",
                                           "createdAt":  "2018-10-09T16:20:13Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCrVmgA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "myFirstway",
                                                                               "createdAt":  "2019-11-17T16:34:38Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "aivanov-oneinc",
                                                                               "createdAt":  "2022-08-29T22:22:19Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "xneg",
                                           "body":  "Here is my naive implementation (and the way I use it):\r\n\r\n```c#\r\npublic interface ICustomHttpClientFactory : IHttpClientFactory\r\n{\r\n    void AddHttpClientAction(string name, Action\u003cHttpClient\u003e configureClient);\r\n}\r\n```\r\n\r\n```c#\r\npublic class CustomHttpClientFactory : ICustomHttpClientFactory\r\n{\r\n    private readonly ConcurrentDictionary\u003cstring, ConcurrentBag\u003cAction\u003cHttpClient\u003e\u003e\u003e _actionsDictionary =\r\n        new ConcurrentDictionary\u003cstring, ConcurrentBag\u003cAction\u003cHttpClient\u003e\u003e\u003e();\r\n    private readonly IHttpClientFactory _httpClientFactory;\r\n\r\n    public CustomHttpClientFactory(IHttpClientFactory httpClientFactory)\r\n    {\r\n        _httpClientFactory = httpClientFactory;\r\n    }\r\n\r\n    public HttpClient CreateClient(string name)\r\n    {\r\n        var client = _httpClientFactory.CreateClient(name);\r\n        if (_actionsDictionary.TryGetValue(name, out var actions))\r\n        {\r\n            foreach (var action in actions)\r\n            {\r\n                action.Invoke(client);\r\n            }\r\n        }\r\n\r\n        return client;\r\n    }\r\n\r\n    public void AddHttpClientAction(string name, Action\u003cHttpClient\u003e configureClient)\r\n    {\r\n        if (!_actionsDictionary.ContainsKey(name))\r\n            _actionsDictionary[name] = new ConcurrentBag\u003cAction\u003cHttpClient\u003e\u003e(new [] {configureClient});\r\n        else\r\n            _actionsDictionary[name].Add(configureClient);\r\n    }\r\n}\r\n```\r\n\r\n```c#\r\nICustomHttpClientFactory customHttpClientFactory = new CustomHttpClientFactory(...);\r\n\r\ncustomHttpClientFactory.AddHttpClientAction(\u003chostAddress\u003e, \r\n    httpClient =\u003e { httpClient.BaseAddress = new Uri(\u003chostAddress\u003e); });\r\n\r\nvar httpClient = customHttpClientFactory.Get(\u003chostAddress\u003e);\r\n```\r\n\r\nHere I use the fact that distinct \"named\" handler created in DefaultHttpFactory. But it is created with default lifetime, I can\u0027t change this.\r\nHope this will clear what I want.",
                                           "updatedAt":  "2020-05-07T23:53:22Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQyODI1ODYyNw==",
                                           "createdAt":  "2018-10-09T16:24:33Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "rynowak",
                                           "body":  "I think I need to see a really concrete example to understand what problem you are solving. What are some of the things you\u0027re doing with `AddHttpClientAction`?",
                                           "updatedAt":  "2018-10-09T16:24:33Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQyODI1OTc4MQ==",
                                           "createdAt":  "2018-10-09T16:27:52Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "xneg",
                                           "body":  "It is concrete example for now. I\u0027m registering new _hostAddresses_ via REST API at runtime. And then use httpClients to gather information from this hostAddresses.\r\nWith CustomClientFactory I garantee that each obtained httpClient has its own handler.",
                                           "updatedAt":  "2018-10-09T16:27:52Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQyOTQ0OTYyMQ==",
                                           "createdAt":  "2018-10-12T20:15:20Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "rynowak",
                                           "body":  "Moving this to the backlog - I think we should continue the converstation here. I don\u0027t really understand why these requirements need to be implemented in this way.",
                                           "updatedAt":  "2018-10-12T20:15:20Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQzMjE2Mjg5MA==",
                                           "createdAt":  "2018-10-23T09:06:52Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOERGF8g==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "rcollina",
                                                                               "createdAt":  "2019-01-12T23:39:45Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "FarhadJabiyev",
                                                                               "createdAt":  "2019-11-21T13:19:54Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "oising",
                                                                               "createdAt":  "2019-11-22T16:22:34Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "chrissimon-au",
                                                                               "createdAt":  "2019-12-18T09:48:07Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "joelmusheno",
                                                                               "createdAt":  "2023-06-02T19:51:40Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "SiarheiPrivalau",
                                                                               "createdAt":  "2024-03-07T15:07:44Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "CSymes",
                                                                               "createdAt":  "2025-05-07T04:30:02Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  7
                                                         },
                                           "author":  "xneg",
                                           "body":  "I think my issue has relations with this one #36551 (originally https://github.com/aspnet/HttpClientFactory/issues/39).\r\nLet me explain once again: my service use kind of service discovery - it gets list of apis from external source. **The cornerstone here is that new APIs can appear in runtime and clients for them should be registered in the factory at that time.** Moreover this apis are protected with IdentityServer so my service need to get token for each api it will contact. And now when I register new clients with my workaround I have to invent how to pass token for every call. And it looks ugly at the moment.",
                                           "updatedAt":  "2021-01-20T15:13:32Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ1MzIzMjUxOA==",
                                           "createdAt":  "2019-01-10T19:57:42Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "roc916",
                                           "body":  "Seems to have relevance https://github.com/aspnet/Extensions/issues/932.",
                                           "updatedAt":  "2019-01-10T19:57:42Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ1OTQzOTQ2OQ==",
                                           "createdAt":  "2019-01-31T17:48:41Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODI8JQQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "RobSiklos",
                                                                               "createdAt":  "2021-11-24T20:09:57Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "aivanov-oneinc",
                                                                               "createdAt":  "2022-08-30T19:24:21Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "tiggerite",
                                                                               "createdAt":  "2022-12-31T22:29:32Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "ttranter",
                                                                               "createdAt":  "2023-08-11T18:53:32Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "vzsoft",
                                                                               "createdAt":  "2023-10-07T12:13:51Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  5
                                                         },
                                           "author":  "ItsVeryWindy",
                                           "body":  "I\u0027ve also run into this same issue, unfortunately I haven\u0027t been able to find a nice way of dealing with it.\r\n\r\nThis can be worked around to some degree with config, as there doesn\u0027t seem to be a requirement that your named client needs to be registered at startup. This is a rather primitive example. Naturally if you just want to apply these things across the board then the dictionary is not required.\r\n\r\nRegistered in startup\r\n```csharp\r\nservices.AddHttpClient();\r\nservices.AddSingleton\u003cDictionary\u003cstring, Action\u003cHttpClientFactoryOptions\u003e\u003e\u003e();\r\nservices.ConfigureOptions\u003cMyHttpClientFactoryOptions\u003e();\r\n```\r\n\r\nAt runtime you just need to ensure that you add the name of the client you\u0027re about to create to the dictionary before calling CreateClient.\r\n\r\n```csharp\r\n\r\ninternal class Other\r\n{\r\n    public Other(Dictionary\u003cstring, Action\u003cHttpClientFactoryOptions\u003e\u003e options, IHttpClientFactory factory)\r\n    {\r\n        options.Add(\"my-client\", o =\u003e o.HttpClientActions.Add(c =\u003e { c.BaseAddress = new Uri(\"http://example.com\"); });\r\n\r\n        var client = factory.CreateClient(\"my-client\");\r\n    }\r\n}\r\n\r\ninternal class MyHttpClientFactoryOptions : IConfigureNamedOptions\u003cHttpClientFactoryOptions\u003e\r\n{\r\n    private readonly Dictionary\u003cstring, Action\u003cHttpClientFactoryOptions\u003e\u003e _options;\r\n\r\n    public MyHttpClientFactoryOptions(Dictionary\u003cstring, Action\u003cHttpClientFactoryOptions\u003e\u003e options)\r\n    {\r\n        _options = options;\r\n    }\r\n\r\n    public void Configure(HttpClientFactoryOptions options)\r\n    {\r\n        // do nothing\r\n    }\r\n\r\n    public void Configure(string name, HttpClientFactoryOptions options)\r\n    {\r\n        if (!_options.TryGetValue(name, out var configure))\r\n            return;\r\n\r\n        configure(options);\r\n    }\r\n}\r\n```",
                                           "updatedAt":  "2019-01-31T17:48:41Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU1NDc2MzE5OQ==",
                                           "createdAt":  "2019-11-17T16:35:59Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "myFirstway",
                                           "body":  "Do you have any solutions for such problems(#932 dotnet/runtime#35992 dotnet/extensions#2237 )? @rynowak ",
                                           "updatedAt":  "2019-11-17T16:35:59Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDYyNTQ0NTkzOA==",
                                           "createdAt":  "2020-05-07T19:15:41Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/ncl\nNotify danmosemsft if you want to be subscribed.",
                                           "updatedAt":  "2020-05-07T19:15:41Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY2NTc4MTA1OA==",
                                           "createdAt":  "2020-07-29T16:54:23Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ericstj",
                                           "body":  "Given where we are at in 5.0 and that this API is not yet proposed moving out to 6.0.  I think this issue needs more discussion with area-owners (cc @dotnet/ncl).  We need to reach concensus on the scenario and then turn this into a formal API proposal.",
                                           "updatedAt":  "2020-07-29T16:54:23Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc47dzqG",
                                           "createdAt":  "2021-12-20T07:35:53Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "sanzor",
                                           "body":  "Hello , i am trying to add HttpClient (via IHttpClientFactory) with Polly policy at runtime. Is it possible as of now to do this ?\r\nFor more information this is my [post](https://stackoverflow.com/questions/70418637/how-to-add-httpclient-with-polly-policy-at-runtime)",
                                           "updatedAt":  "2021-12-20T07:35:53Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Flxna",
                                           "createdAt":  "2022-06-27T15:56:08Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCraHlw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "aivanov-oneinc",
                                                                               "createdAt":  "2022-08-30T22:14:54Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "dazinator",
                                           "body":  "We have the same problem. The only options we can think of right now:-\r\n1. Register a central / shared named http client that doesn\u0027t have any connection specific configuration - i.e - it doesn\u0027t have a BaseAddress or anything else. It can only be configured with things / handlers that apply to all scenarios. You then always this this particular named http client, but just before making any API calls, you have to configure things like the BaseAddress, Authentication Header etc etc based on the connection details you want to use at that point in time. This means if new connection details are added to your application at runtime, you can leverage the same named http client, but just make sure you apply the new details to the http client before using it. This is problematic for obvious reasons mainly it makes HttpClientFactory and friends largely redundant - you also can\u0027t use HttpMessageHandler\u0027s / DelegatingHandlers as you can\u0027t add these to a HttpClient \"on the fly\" for the purposes of specific http call, the handlers have to be configured on the shared / named httpclient and will therefore be in play regardless of the connection details you want to \"apply\" at runtime.\r\n\r\n2. Create an isolated `IServiceProvider` - add your named http clients based on the connections your application knows of at runtime. If these change, dispose of the IServiceProvider and re-build. Make sure you do this in a safe way such that if httpclients are in use, you don\u0027t dispose of the SP until they are no longer in use and it\u0027s safe. This is difficult and also untested.\r\n\r\n3. The same as option 1, except you also refactor all your HttpMessageHandlers (DelegatingHandlers?) so they are all added to the shared named http client (and this able to impact any requests) but they are able to conditionally configure themselves based on information sent at request time. Extremely hacky and not very pleasing. For example you\u0027d have a BasicAuthHandler and a JwtAuthHandler, both handlers would be added to the shared named http client registerd at startup so they could both come into effect on requests, but at runtime when using the named http client with your specific \"connection details\" i.e connection details: A (which specifies Basic Auth is to be used), you\u0027d need to somehow signal that the  `BasicAuthHandler` should run on this request, and that the `JwtAuthHandler` shouldn\u0027t run, being no easy mechanism to pass such a signal you could set some custom information on the request itself - (like a header) such that both handlers always intercept the request and based on this custom information in the request, the BasicAuthHandler chooses to act in this situation but the JwtAuthHandler chooses to do nothing. Again this is horrid. This lets you vary which http handlers come into effect and potentially their configuration params.\r\n\r\n4. Don\u0027t use IHttpClientFactory. Lose all the benefits it provides like pooling of handlers / handler lifetime. Not great either.",
                                           "updatedAt":  "2022-06-27T16:02:48Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5TrQph",
                                           "createdAt":  "2023-01-25T16:03:52Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "misholson",
                                           "body":  "I found the solution to this at https://github.com/dotnet/extensions/issues/521 . It turns out that `HttpClient` is not really the thing that needs to be reused to take advantage of pooling, but the underlying `SocketsHttpHandler` object. I think what I\u0027m going to do is create my own `IHttpClientFactory` that figures out which of a handful of `SocketsHttpHandler`s I need to use, then return `new HttpClient(handler)` with that handler.\r\n\r\nIn my use case, it\u0027s specifically having different client certificates that requires different connections. The config is stored in the database and the certs are stored in Key Vault. To start, `IHttpClientFactory.CreateClient(name)` will look in a cache to see if `name` is mapped to an existing `SocketsHttpHandler` (a dictionary based on the cert thumbprint). If not, it will look up config from the database and create a new `SocketsHttpHandler` with the settings for that certificate. If no client cert is specified, then it will just use the default handler (also stored in the factory). Then I just return `new HttpClient(handler)` and based on my reading I believe that should meet the requirements.\r\n\r\nTo make it even fancier, I\u0027m thinking about making a subclass of `HttpClient` that will store the non-certificate parts of the configuration (basic auth username/password, OAuth2 settings, API Key, etc). That way, when a client gets the `HttpClient` they can just worry about sending the request to the URL, and the authentication should all be handled inside the `HttpClient`.",
                                           "updatedAt":  "2023-01-25T16:03:52Z"
                                       }
                                   ],
                         "totalCount":  15
                     },
        "title":  "Add ability to register named HttpClient after DI configuration",
        "labels":  [
                       "api-suggestion",
                       "area-Extensions-HttpClientFactory"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/36067",
        "createdAt":  "2019-01-09T19:09:32Z",
        "number":  36067,
        "author":  "dotnetjunkie",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOC-zFYw==",
                          "nodes":  [
                                        {
                                            "content":  "EYES",
                                            "user":  "veikkoeeva",
                                            "createdAt":  "2019-06-24T05:24:24Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "adrianiftode",
                                            "createdAt":  "2019-07-24T16:36:43Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "seangwright",
                                            "createdAt":  "2020-07-07T10:14:57Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "jeroenheijmans",
                                            "createdAt":  "2020-07-23T14:38:04Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Pastafarian",
                                            "createdAt":  "2020-07-28T10:44:54Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "breenbob",
                                            "createdAt":  "2020-09-14T20:47:57Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "HulinCedric",
                                            "createdAt":  "2021-02-18T11:16:28Z"
                                        },
                                        {
                                            "content":  "EYES",
                                            "user":  "dotnetjunkie",
                                            "createdAt":  "2021-07-06T06:25:39Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "7702244",
                                            "createdAt":  "2021-07-20T14:12:12Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "vahpetr",
                                            "createdAt":  "2021-09-09T18:16:38Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "ferantivero",
                                            "createdAt":  "2022-07-11T14:32:02Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "gabrieldominguez",
                                            "createdAt":  "2022-09-22T11:13:41Z"
                                        },
                                        {
                                            "content":  "EYES",
                                            "user":  "romfir",
                                            "createdAt":  "2022-12-05T18:24:24Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "vxkc",
                                            "createdAt":  "2025-02-05T15:26:53Z"
                                        }
                                    ],
                          "totalCount":  14
                      },
        "updatedAt":  "2021-05-25T07:32:22Z",
        "body":  "The current implementation of the `HttpClientBuilderExtensions.AddTypedClient\u003cTClient\u003e` extension method of the `Microsoft.Extensions.Http` project registers the `TClient` with the `Transient` lifestyle. I think this is incorrect and would like drop this here for discussion.\r\n\r\nWith the introduction of ASP.NET Core v2.1, the new `IHttpClientFactory` interface and its related extension methods were added to address the problems with reuse of `HttpClient` instances, as discussed [here](https://aspnetmonsters.com/2016/08/2016-08-27-httpclientwrong/), [here](https://github.com/dotnet/corefx/issues/11224), and [here](https://byterot.blogspot.com/2016/07/singleton-httpclient-dns.html), as [referenced](https://www.stevejgordon.co.uk/introduction-to-httpclientfactory-aspnetcore) by  Steve Gordon in his blog post on this matter.\r\n\r\n**Problem being that HttpClients that are stored for the duration of the app domain can cause several issues, _most obvious one being that a `Singleton` HttpClient doesn\u0027t respect DNS changes._ This, of course, is exactly why the new extension infrastructure is put in place.**\r\n\r\nWhat strikes me, though, is that, although there is seemingly the observation that caching of `HttpClient` for the duration of the application is bad, `AddTypedClient` registers the `HttpClient` consumers as `Transient`, as can be seen in the `AddTypedClient` implementation:\r\n\r\n``` c#\r\npublic static IHttpClientBuilder AddTypedClient\u003cTClient\u003e(this IHttpClientBuilder builder)\r\n    where TClient : class\r\n{\r\n    ...\r\n    builder.Services.AddTransient\u003cTClient\u003e(s =\u003e\r\n    {\r\n        var httpClientFactory = s.GetRequiredService\u003cIHttpClientFactory\u003e();\r\n        var httpClient = httpClientFactory.CreateClient(builder.Name);\r\n        var typedClientFactory = s.GetRequiredService\u003cITypedHttpClientFactory\u003cTClient\u003e\u003e();\r\n        return typedClientFactory.CreateClient(httpClient);\r\n    });\r\n\r\n    return builder;\r\n}\r\n\r\n```\r\n\r\nThe HttpClientFactory sample project shows a usage of this method:\r\n\r\n``` c#\r\nservices.AddHttpClient(\"github\", c =\u003e\r\n  {\r\n      c.BaseAddress = new Uri(\"https://api.github.com/\");\r\n  })\r\n  .AddHttpMessageHandler(() =\u003e new RetryHandler())\r\n  .AddTypedClient\u003cGitHubClient\u003e();//GitHubClient depends on HttpClient and gets the \"github\" client\r\n\r\nservices.AddSingleton\u003cIMyService, MyService\u003e(); // Depends on GitHubClient\r\n```\r\n\r\nI think the registration of `Transient` consumers is problematic, as `Transient`—in term of Microsoft.Extensions.DependencyInjection—means _stateless_; not _short lived_. This means that the container allows those _stateless_ consumers of `HttpClient` to be injected into `Singleton` consumers **without the container\u0027s Scope Verfication feature to get tripped**. For instance, in the case of the `Singleton` `MyService` registration shown above, it will keep the `GitHubClient` alive for the duration of the application, and `GitHubClient` will keep its `HttpClient` alive for the duration of the application. This, as stated above, could lead to missing DNS changes, **effectively causing the application to become corrupted in a way that can only be fixed with a restart of the application**.\r\n\r\nThe injection of `HttpClient` instances into `Singleton` consumers could, therefore, lead to the type of bugs that you so hard tried to prevent using this new design. Because of the way `AddHttpClient` is designed, no warning signs will be given. Because of the way DNS caching works, problems only appear after the application is deployed to production; hardly ever on the developer\u0027s machine, making it crucial to warn developers in an early stage about this issue.\r\n\r\nI think the solution to this problem is, therefore, rather straightforward (although, admittedly, a breaking change). Change the `AddTypedClient` method to change its `TClient` as `Scoped` instead, **because in that case, MS.DI\u0027s Scope Validation feature will prevent the client to be resolved from a root scope**:\r\n\r\n``` c#\r\npublic static IHttpClientBuilder AddTypedClient\u003cTClient\u003e(this IHttpClientBuilder builder)\r\n    where TClient : class\r\n{\r\n    // Register client as Scoped, allowing Captive Dependencies being detected in case the\r\n    // ServiceProvider is built using the validateScopes flag.\r\n    builder.Services.AddScoped\u003cTClient\u003e(s =\u003e\r\n    {\r\n        // same code as before\r\n    });\r\n\r\n    return builder;\r\n}\r\n```\r\n\r\nAlthough changing the lifestyle from `Transient` to `Scoped` can be considered to be a breaking change, due to how Scope Validation is configured in ASP.NET Core applications, exceptions will only be thrown in development mode; not when the application is deployed.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOLaDtTg==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ5NjYwMzI5MQ==",
                                           "createdAt":  "2019-05-28T17:03:19Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "nicklundin08",
                                           "body":  "Rather than registering http clients as scoped, I think you would want to depend on IHttpClientFactory everywhere (including typed clients) and then you have the option register your typed clients in singleton or transient scope.\r\n\r\nIf you do not depend on IHttpClientFactory in your typed client, you have the chance of hanging onto the http client for the lifetime of whatever depends on the typed client.\r\n\r\nOne example of this could be pages in a mobile app. If your navigation framework re-uses page instances, and you depend directly on an http client, then you effectively have an http client that lasts the lifetime of the application. \r\n\r\n[This could result in the client not getting dns updates](https://www.google.com/search?q=http+client+dns+changes\u0026rlz=1C1CHBF_enUS849US849\u0026oq=http+client+dns+changes\u0026aqs=chrome..69i57.3764j0j7\u0026sourceid=chrome\u0026ie=UTF-8)\r\n\r\nFurthermore, if you have an application that where you need to swap between base urls at runtime via a settings page or something like that (a situation that I have seen while working on internal tools), then if you would have to restart the entire application every time you change base urls\r\n\r\nIn this scenario we had to roll our own TypedClientFactory and depend on that instead of the typed client directly. While this got us over the hurdle, I think a better solution would be for typed clients (especially typed client libraries like Refit/RestLess) to depend on the IHttpClientFactory\r\n\r\nI imagine something like this for Refit\r\n```c#\r\npublic static IHttpClientBuilder AddTransientRefitClient\u003cT\u003e(this IServiceCollection services,\r\n    RefitSettings settings = null)\r\n{\r\n    var builder = services.AddHttpClient\u003cT\u003e();\r\n    \r\n    services.AddTransient\u003cT\u003e(serviceProvider =\u003e \r\n        Refit.RestService.For\u003cT\u003e(serviceProvider.GetRequiredServics\u003cIHttpClientFactory\u003e(), settings);\r\n\r\n    return builder;\r\n}\r\n\r\npublic static IHttpClientBuilder AddSingletonRefitClient\u003cT\u003e(this IServiceCollection services,\r\n    RefitSettings settings = null)\r\n{\r\n    var builder = services.AddHttpClient\u003cT\u003e();\r\n    \r\n    services.AddSingleton\u003cT\u003e(serviceProvider =\u003e \r\n        Refit.RestService.For\u003cT\u003e(serviceProvider.GetRequiredServics\u003cIHttpClientFactory\u003e(), settings);\r\n\r\n    return builder;\r\n}\r\n```\r\n\r\n@dotnetjunkie what are your thoughts?\r\n",
                                           "updatedAt":  "2021-01-20T15:28:04Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ5NjY1NTIyNw==",
                                           "createdAt":  "2019-05-28T19:28:06Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnetjunkie",
                                           "body":  "@nicklundin08, not much to add. I think it is a good idea to inject an `IHttpClientFactory` instead of depending on `HttpClient`. Considering all its quirks, the `HttpClient` seems more like [runtime data](https://blogs.cuttingedge.it/steven/p/runtime-data/) anyway.\r\n\r\nBut as Microsoft decided to introduce this `AddTypedClient` extension method and build their advice on using `HttpClient` around that method, we don\u0027t have to expect such extension method to be obsoleted soon. As long as that method is not deprecated, it is important, IMO, for Microsoft to fix this design flaw, even though, admittedly, this fix is a breaking change.",
                                           "updatedAt":  "2021-05-25T06:59:32Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ5OTg0MTEwMA==",
                                           "createdAt":  "2019-06-07T10:46:56Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ItsVeryWindy",
                                           "body":  "One thing I\u0027d like to add is that as they are scoped as transient, scope validation won\u0027t pick it up and alert you.\r\n\r\nhttps://docs.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection?view=aspnetcore-2.2#scope-validation",
                                           "updatedAt":  "2019-06-07T10:46:56Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU1Nzk0MzQwMw==",
                                           "createdAt":  "2019-11-25T00:01:41Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "rynowak",
                                           "body":  "We\u0027ll consider this during 5.0. We didn\u0027t put a ton of thought into whether this should be transient or scoped initially, and picked transient because it seemed \"safe\". It\u0027s clear that there\u0027s more inputs into this equation than we considered in the first draft.",
                                           "updatedAt":  "2019-11-25T00:01:41Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU1OTQ5OTk1Mg==",
                                           "createdAt":  "2019-11-28T13:44:50Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jan-johansson-mr",
                                           "body":  "Hmmm... I\u0027m using typed HttpClient in my Blazor server app. I want my type to be tied to the Blazor circuit and thus it would be great if the instance could be scoped rather than transient (to maintain state as long as the circuit is alive). However, there are tons of workarounds if it can\u0027t be done due to some technical issue.",
                                           "updatedAt":  "2019-11-28T13:45:23Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDYyNTU0MTAxMQ==",
                                           "createdAt":  "2020-05-07T23:07:01Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/ncl\nNotify danmosemsft if you want to be subscribed.",
                                           "updatedAt":  "2020-05-07T23:07:01Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY1NDQ4ODM5Mw==",
                                           "createdAt":  "2020-07-06T22:04:09Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ericstj",
                                           "body":  "Given this fix is breaking I\u0027m reluctant to take it this late in 5.0.  Let\u0027s consider this for 6.0.  One way to make it non-breaking is to add a new method that does the scoped registration, `AddTypedClientScoped`.  @davidfowl @maryamariyan @dotnet/ncl any thoughts on this?",
                                           "updatedAt":  "2020-07-06T22:04:09Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY1NDUxNjExOA==",
                                           "createdAt":  "2020-07-06T23:39:18Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "halter73",
                                           "body":  "I agree this is too risky to take for 5.0. Anyone who was resolving a typed client from a the root provider will be broken.\r\n\r\n\u003e For instance, in the case of the Singleton MyService registration shown above, it will keep the GitHubClient alive for the duration of the application, and GitHubClient will keep its HttpClient alive for the duration of the application.\r\n\r\nYep. And this is the scenario that would break if we make the typed client registrations scoped. What\u0027s wrong with a Signleton service keeping an HttpClient alive for the duration of the application? The IHttpClientFactory which owns all the HttpMessageHandlers and therefore the connection pool is already a singleton.\r\n\r\nI don\u0027t think anyone mentioned IDisposable in this thread yet, but I wonder if that\u0027s really what\u0027s at the heart of this issue. Resolving transient services that happen to implement IDisposable from root provider _is_ very problematic, and a typed client could implement IDisposable which could lead to problems where the container itself, not the singleton service, keeps the typed client alive for the duration of the application, but that\u0027s not unique to typed clients. See #36491.\r\n\r\n\u003e  One way to make it non-breaking is to add a new method that does the scoped registration, `AddTypedClientScoped`.\r\n\r\nI think this would just create more confusion over which method to call. I don\u0027t see the problem with typed clients being transient unless the type implements IDisposable. Not implementing IDisposable is the easy way to work around leaking the typed clients. If there\u0027s some reason the typed client needs to be disposed at the end of the request/scope, manually registering it as a scoped service should be easy enough even without a new extension method.",
                                           "updatedAt":  "2020-07-17T22:44:08Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY1OTg2ODU1NA==",
                                           "createdAt":  "2020-07-17T05:40:54Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOBKrsSA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "dotnetjunkie",
                                                                               "createdAt":  "2020-07-17T13:32:32Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "EnricoMassone",
                                           "body":  "@halter73 just a question. Above you said: \r\n\r\n\u003e What\u0027s wrong with a Signleton service keeping an HttpClient alive for the duration of the application?\r\n\r\nBased on my understanding, having a captive HttpClient keeped alive for the entire duration of the application could lead to **missing reaction to DNS updates**, as pointed out above by @nicklundin08 and @dotnetjunkie. \r\n\r\nThis seems to be confirmed by [this Micorsoft docs on IHttpClientFactory](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/http-requests?view=aspnetcore-3.1#alternatives-to-ihttpclientfactory). \r\n\r\nMy understanding is that the HttpMessageHandler contained in the captive HttpClient is kept alive for the entire application lifetime, which causes the DNS change issue. Put in other words, the whole HTTP client story works fine if and only if each time a consumer needs an HttpClient instance it goes to the IHttpClientFactory and asks for a new instance. At that point, the factory is able to pick up an HttpMessageHandler instance from its pool and to return a new HttpClient using the pooled handler. The pooled handlers have a limited lifetime (2 minutes by default if I remember correctly), so that the DNS change issue is avoided.\r\n\r\nIs my understanding correct ? ",
                                           "updatedAt":  "2020-07-17T05:45:29Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY1OTg4NjI0NQ==",
                                           "createdAt":  "2020-07-17T06:19:00Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "wfurt",
                                           "body":  "As far as I can tell, the HttpClient will not pro-actively pick up new nodes resolving to same name as far as there are available connections. But it does not cache any DNS lookups e.g. when time comes to create new connection, it will do new DNS lookup (subject to OS caching) and it will connect to some IP returned by the lookup. You can use PooledConnectionLifetime to force discovery of new nodes. It seems like the problem with DNS is valid only if given server stops serving content for given name _without_ closing the connection, right? ",
                                           "updatedAt":  "2020-07-17T06:19:00Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY1OTk4NDEwMg==",
                                           "createdAt":  "2020-07-17T09:13:36Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOBKrs3w==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "dotnetjunkie",
                                                                               "createdAt":  "2020-07-17T13:33:46Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "EnricoMassone",
                                           "body":  "\u003e As far as I can tell, the HttpClient will not pro-actively pick up new nodes resolving to same name as far as there are available connections. But it does not cache any DNS lookups e.g. when time comes to create new connection, it will do new DNS lookup (subject to OS caching) and it will connect to some IP returned by the lookup. You can use PooledConnectionLifetime to force discovery of new nodes. It seems like the problem with DNS is valid only if given server stops serving content for given name _without_ closing the connection, right?\r\n\r\nHi, \r\n\r\nI don\u0027t really know the underlying implementation details. My high level understanding is the following:\r\n\r\n- the `HttpClient` delegates the HTTP request handling to the wrapped HttpMessageHandler\r\n- the connections are handled at the HttpMessageHandler level \r\n- HttpMessageHandler must be pooled because creating an arbitrary amount of them could lead to socket exhaustion under heavy loads\r\n- the HttpMessageHandler, by default, keeps the connections open indefinitely and this is the root cause of the DNS change issue\r\n\r\n[This documentation](https://docs.microsoft.com/en-us/dotnet/architecture/microservices/implement-resilient-applications/use-httpclientfactory-to-implement-resilient-http-requests#httpclient-lifetimes) seems to confirm that, by default, HttpMessageHandler implementations keeps the connections open indefinitely, so that they are not able to react to DNS changes: \r\n\r\n\u003e Pooling of handlers is desirable as each handler typically manages its own underlying HTTP connections; creating more handlers than necessary can result in connection delays. Some handlers also keep connections open indefinitely, which can prevent the handler from reacting to DNS changes\r\n\r\nSo basically the issue is related to connections not being closed, as you pointed out above. \r\n",
                                           "updatedAt":  "2020-07-17T09:13:36Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc2MzczNDExNQ==",
                                           "createdAt":  "2021-01-20T16:02:07Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOBdQzYA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_DOWN",
                                                                               "user":  "AroglDarthu",
                                                                               "createdAt":  "2021-01-21T17:55:07Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_DOWN",
                                                                               "user":  "dotnetjunkie",
                                                                               "createdAt":  "2021-01-21T18:33:52Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_DOWN",
                                                                               "user":  "0xced",
                                                                               "createdAt":  "2021-01-21T18:34:19Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  3
                                                         },
                                           "author":  "CarnaViire",
                                           "body":  "Triage:\r\n1) We should not change the current lifetime as it will be a breaking change\r\n2) We shouldn\u0027t add a new method for scoped registration because there\u0027s not enough benefit in doing it that would justify extending API surface\r\n3) we should update documentation with two messages:\r\n    - specify that the container will track `IDisposable` transient services so it is advised not to make your typed clients `IDisposable`, or you should dispose them yourself\r\n    - note that `HttpClient` instances will hold the connection indefinitely (unless you specify the primary handler to be `SocketsHttpHandler` with `PooledConnectionLifetime` - applies to .NET Core). If you want to leverage `HttpClientFactory` recreating the connection, you would need to ask for a new instance of `HttpClient` (and also your Typed client)",
                                           "updatedAt":  "2021-01-20T16:03:23Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc2NDgzMjYzNg==",
                                           "createdAt":  "2021-01-21T18:00:58Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOB3z92A==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "dotnetjunkie",
                                                                               "createdAt":  "2021-01-21T18:33:49Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "0xced",
                                                                               "createdAt":  "2021-01-21T18:34:37Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "brettkc",
                                                                               "createdAt":  "2021-08-26T00:40:31Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  3
                                                         },
                                           "author":  "AroglDarthu",
                                           "body":  "4. How about just deprecating the existing `AddTypedClient` and adding a new extension method that takes an additional, non-optional parameter to specify the desired lifetime? Do this in v6 and drop the original in v7.\r\n\r\nThis issue pre-dates v5 by nearly two years and now it is being delayed to after v6?! Seriously?",
                                           "updatedAt":  "2021-01-21T18:00:58Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc2NTM5NzMwMA==",
                                           "createdAt":  "2021-01-22T13:31:43Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "karelz",
                                           "body":  "@AroglDarthu \r\n\r\n\u003e This issue pre-dates v5 by nearly two years and now it is being delayed to after v6?! Seriously?\r\n\r\nYes, it is old issue and we don\u0027t plan to prioritize it for 6.0 from these reasons:\r\n- The issue is fairly complicated.\r\n- It does not block too many customers.\r\n- The scenarios where it matters are not super clear yet (something to follow up on here).\r\n- There seem to be workarounds.\r\n- Solution does not seem to be super-clear yet.\r\n- Our team (NCL) is still ramping up on the component (which was transferred to us recently) together with learning about DI for the first time, so expertise is limited (especially on edge cases).\r\n- There are 500+ other Networking issues to compete for our investment.\r\n\r\nIf the problem was more impactful, or easier to solve, we would be happy to prioritize it for 6.0. Currently that is not the case.",
                                           "updatedAt":  "2021-01-22T13:31:43Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc2NTQxMDEyOA==",
                                           "createdAt":  "2021-01-22T13:49:58Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "CarnaViire",
                                           "body":  "I admit that it is not great that injecting a Typed client into a singleton is not checked automatically and it may result in a situation with loss of DNS changes. It also make things worse that it is not obvious which lifetime you will get when you register a Typed client via `AddHttpClient` method (without looking into docs of course) so it is difficult to be aware of lifetimes when injecting a Typed client.\r\n\r\nHowever, if there are other unsolvable pains that we did not consider, please let us know. @AroglDarthu what exactly is the problem that you would try to solve by registering a Typed client as scoped?\r\n\r\nJFYI. There are 16 overloads for registering a Typed client. Adding 16 more is A LOT. We would need a really good justification for that.\r\n\r\nP.S.: `HttpClient`s produced by `HttpClientFactory` are transient-like objects, so for me it actually seems reasonable for Typed clients - that receive an instance of `HttpClient` in constructor - to have same lifetime as `HttpClient`. ",
                                           "updatedAt":  "2021-01-22T13:49:58Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc2NTQxMzY2Mw==",
                                           "createdAt":  "2021-01-22T13:54:32Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOC0wMlA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "LAUGH",
                                                                               "user":  "davidfowl",
                                                                               "createdAt":  "2021-01-22T13:55:51Z"
                                                                           },
                                                                           {
                                                                               "content":  "LAUGH",
                                                                               "user":  "krynium",
                                                                               "createdAt":  "2021-03-31T11:06:04Z"
                                                                           },
                                                                           {
                                                                               "content":  "LAUGH",
                                                                               "user":  "Torvin",
                                                                               "createdAt":  "2022-05-18T05:10:02Z"
                                                                           },
                                                                           {
                                                                               "content":  "LAUGH",
                                                                               "user":  "gabrieldominguez",
                                                                               "createdAt":  "2022-09-22T12:44:05Z"
                                                                           },
                                                                           {
                                                                               "content":  "LAUGH",
                                                                               "user":  "mateusnc",
                                                                               "createdAt":  "2023-01-25T00:03:37Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  5
                                                         },
                                           "author":  "dotnetjunkie",
                                           "body":  "\u003e Our team (NCL) is still ... learning about DI for the first time, so expertise is limited\r\n\r\nThis is very honest... but still quite disturbing.\r\n",
                                           "updatedAt":  "2021-01-22T13:54:32Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc2NTUwNzg5Nw==",
                                           "createdAt":  "2021-01-22T15:59:49Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCsp3OQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "gabrieldominguez",
                                                                               "createdAt":  "2022-09-22T12:45:33Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "davidfowl",
                                           "body":  "I think generally we need to deprecate/remove handler rotation from the IHttpClientFactory. Refreshing DNS should be left up to the innermost handler implementation. That would simplify the lifetime semantics of the client factory and remove some of the confusion around when to use it.",
                                           "updatedAt":  "2021-01-22T15:59:49Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc2NTUyMTIzMA==",
                                           "createdAt":  "2021-01-22T16:17:32Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOBdil6A==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "davidfowl",
                                                                               "createdAt":  "2021-01-22T21:45:50Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "karelz",
                                                                               "createdAt":  "2021-01-25T09:53:02Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "CarnaViire",
                                           "body":  "@davidfowl That\u0027s right and we are planning to do that. However there\u0027s still a case when a custom PrimaryHandler is supplied - and we might still want to leave rotation for these ones. We may have a discussion in  https://github.com/dotnet/runtime/issues/35987 if you wish.",
                                           "updatedAt":  "2021-01-22T16:17:32Z"
                                       }
                                   ],
                         "totalCount":  18
                     },
        "title":  "Should IHttpClientBuilder.AddTypedClient\u003cTClient\u003e register the TClient as Scoped?",
        "labels":  [
                       "enhancement",
                       "area-Extensions-HttpClientFactory"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/42143",
        "createdAt":  "2019-01-17T16:26:21Z",
        "number":  42143,
        "author":  "rynowak",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2025-07-24T11:17:18Z",
        "body":  "See discussion here: https://github.com/aspnet/AspNetCore/issues/3470#issuecomment-455001937\r\n\r\n@acds reported that there was an ongoing message handler cleanup cycle with only a few handlers. This is somewhat normal since we can only collect a handler if it\u0027s eligible to be collected (because the `HttpClient` instances have been GC\u0027ed. \r\n\r\nHowever in this case the app didn\u0027t have any traffic going to it and this was causing issues because:\r\n\r\n\u003e The issues is it’s in a Triggered Azure WebJob that fails with a timeout as it has not completed that clean up after the requisite 120 seconds. This can be extended but it seems that switched to a continuous job it continues to clean up for the hour to the next scheduled trigger. Burning up resources for nothing than letting the Job sleep.\r\n\r\nWe should investigate what we can do for cases like this where HttpClient factory is being used in a short-running scenario.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOuY2pcw==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ1NTIzNjQxNg==",
                                           "createdAt":  "2019-01-17T16:28:18Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "rynowak",
                                           "body":  "@fabiocav - does WebJobs dispose the service provider for a case like this? What\u0027s causing the timeout?",
                                           "updatedAt":  "2019-01-17T16:28:18Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ1NTI0MzI2NQ==",
                                           "createdAt":  "2019-01-17T16:46:17Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "acds",
                                           "body":  "Think of the WebJob as a console app with a host builder configuration.\r\n\r\nThe host does not complete (and the console app exit) until the HttpClientFactory completes its cleanup.\r\n\r\nThe Azure App Service container running the WebJob expects as default to triggered jobs that it completes as default in 120secs once it goes idle, so just terminated the WebJob process as a Failure than the Success status that it should be.",
                                           "updatedAt":  "2019-01-17T16:46:17Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ1NTM1NDgzOQ==",
                                           "createdAt":  "2019-01-17T22:25:21Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "fabiocav",
                                           "body":  "@acds are you referring to a timeout waiting for the shutdown/cleanup as a result of a function execution timeout? If so, it does look like WebJobs currently disposes host, but there\u0027s a work item to address that.",
                                           "updatedAt":  "2019-01-17T22:25:21Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ1NTQxNTkzOQ==",
                                           "createdAt":  "2019-01-18T03:30:06Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "acds",
                                           "body":  "Well not an Azure Function but a WebJob Trigged Function, but yes, any insights on the workaround ?\r\n\r\nGive the WebJob v3 API is thoroughly undocumented just now....and is radically different then v2.",
                                           "updatedAt":  "2019-01-18T03:30:06Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ1NTQyOTc5MA==",
                                           "createdAt":  "2019-01-18T05:11:57Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "rynowak",
                                           "body":  "One workaround would be triggering a full GC a few times when your function is shutting down.\r\n\r\n```c#\r\nGC.Collect();\r\nGC.WaitForPendingFinalizers();\r\nGC.Collect();\r\nGC.WaitForPendingFinalizers();\r\nGC.Collect();\r\n```\r\n\r\nAnother workaround would be setting the handler expiry to `Timeout.InfiniteTimeSpan` as documented here: https://github.com/aspnet/Extensions/blob/557995ec322f1175d6d8a72a41713eec2d194871/src/HttpClientFactory/Http/src/DependencyInjection/HttpClientBuilderExtensions.cs#L502 If your job/service is short lived there should be no drawback to that.  The reason why we rotate handlers is because DNS updates don\u0027t work reliably on all existing platforms. ",
                                           "updatedAt":  "2021-01-20T15:33:28Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ1OTA0NTA2Mg==",
                                           "createdAt":  "2019-01-30T18:00:06Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "acds",
                                           "body":  "Hi @rynowak thanks....and apologies I was away, and am just getting back to this.\r\n\r\nthe `CG.Collect();` does to seem to make any difference.\r\n\r\nI already have been experimenting with the Handler Expiry, setting to Infinite, seams to have the effect that the job still seems to not exit/sleep, but does not raise the HttpClientFactory cleanup diagnostics.\r\n\r\nI currently have set to a continuous job, but want to revert to \"triggered\". The job is short lived, and will run every few hours. Having it deployed as \"continuous\" kinds defeats the object of having a triggered job.\r\n\r\nAny other suggestions ?\r\n\r\nThanks!\r\n\r\n ",
                                           "updatedAt":  "2019-02-06T01:32:18Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ2MDg3MDg3NA==",
                                           "createdAt":  "2019-02-06T01:32:32Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "acds",
                                           "body":  "@fabiocav \u0026 @rynowak \u0026 @Eilon - any updates?\r\n\r\nNot sure if this is any use - in Rider I can pull up a memory dump - and notice that the HttpClients are not disposed, even though out of scope:\r\n\r\n\u003cimg width=\"831\" alt=\"screen shot 2019-02-05 at 6 05 47 pm\" src=\"https://user-images.githubusercontent.com/1319833/52316567-cf269900-2970-11e9-972e-4424ef2294da.png\"\u003e\r\n\r\nmy default code patterns is as follows:\r\n```C#\r\nprivate async Task\u003cSystem.Net.HttpStatusCode\u003e PatchCredentials(MyType myType)\r\n{\r\n    HttpClient client = _httpClientFactory.CreateClient(\"graph\"); //using a named client\r\n    HttpContent content = new StringContent(SerializeCredentials.ToJson(myType), Encoding.UTF8, \"application/json\");\r\n\r\n    using (var httpResponse = await client.PatchAsync(\"\", content))\r\n    {\r\n        httpResponse.EnsureSuccessStatusCode();\r\n        return httpResponse.StatusCode;\r\n    }\r\n}\r\n```\r\nthe client factory is configured as follows:\r\n```C#\r\n.ConfigureServices((context, services) =\u003e\r\n{\r\n...\r\n \r\n    services.AddTransient\u003cGraphAuthenticationHandler\u003e();\r\n    services.AddHttpClient(\"graph\", c =\u003e\r\n        {\r\n            c.BaseAddress = new Uri($\"{myURI}\");\r\n        }).AddHttpMessageHandler\u003cGraphAuthenticationHandler().SetHandlerLifetime(Timeout.InfiniteTimeSpan);\r\n\r\n...\r\n}\r\n```\r\n\r\nwhat else should I be looking at...?\r\n\r\n**Edit:**\r\n\r\nAdditional info:\r\n * code is also calling `AzureServiceTokenProvider` in a pair of Delegating Handlers that I believe under the covers makes HttpClient requests - is this somehow messing with things ?\r\n * my code makes 8 requests across 2x registered HttpClients configurations in the HttpClientFactory\r\n\r\nOn review of memory before I garbage collect this is the number of instances:\r\n\u003cimg width=\"1560\" alt=\"screen shot 2019-02-06 at 10 33 10 am\" src=\"https://user-images.githubusercontent.com/1319833/52364698-af3bb780-29fa-11e9-83c5-524faf3b8671.png\"\u003e\r\n\r\nAfter the first `GC.Collect();` \r\n\u003cimg width=\"1526\" alt=\"screen shot 2019-02-06 at 10 35 50 am\" src=\"https://user-images.githubusercontent.com/1319833/52364828-017cd880-29fb-11e9-93a7-300e7b6c521b.png\"\u003e\r\n\r\nSubsequent call to `GC.Collect();` and `GC.WaitForPendingFinalizers();` make no difference...\r\n\r\nWhat is holding on to the HttpClients ?\r\n\r\nThanks for any and all help!",
                                           "updatedAt":  "2019-02-06T18:50:30Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ2MjUxNjQzMA==",
                                           "createdAt":  "2019-02-11T22:14:45Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "rynowak",
                                           "body":  "@acds - sorry for the delay - I\u0027ve been on vacation. \r\n\r\nThe memory dump should be able to show you why those objects are still live. https://www.jetbrains.com/help/dotmemory/Shortest_Paths_to_Roots.html You want to look for the \"path to root\".\r\n\r\n@faviocb - can you provide some background about what\u0027s keeping his function *live*? \r\n\r\n\u003e The host does not complete (and the console app exit) until the HttpClientFactory completes its cleanup.\r\n\r\nWhat is the mechanism that does this? We don\u0027t have a feature for forcing client factory cleanup so how does this work?",
                                           "updatedAt":  "2019-02-11T22:14:45Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ2MzAyMDEyNA==",
                                           "createdAt":  "2019-02-13T01:45:31Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "acds",
                                           "body":  "Hi @rynowak \u0026 @fabiocav \r\n\r\nHere is some output from dotMemory:\r\n- There as before seem to be 6 HttpClients left hanging...\r\n- Here are the Shortest Paths:\r\n\u003cimg width=\"970\" alt=\"screen shot 2019-02-12 at 5 29 52 pm\" src=\"https://user-images.githubusercontent.com/1319833/52680024-e246e500-2eeb-11e9-85a4-ae473165edf4.png\"\u003e\r\n\r\nHere is an Expansion of each:\r\n1. `QuickPulseTelemetartyModule` (2 instances)\r\n\u003cimg width=\"967\" alt=\"screen shot 2019-02-12 at 5 32 36 pm\" src=\"https://user-images.githubusercontent.com/1319833/52680154-58e3e280-2eec-11e9-878b-31b69eb37860.png\"\u003e\r\n1. Configuration Root (Key Vault Connection - 1 Instance)\r\n\u003cimg width=\"976\" alt=\"screen shot 2019-02-12 at 5 34 30 pm\" src=\"https://user-images.githubusercontent.com/1319833/52680238-a1030500-2eec-11e9-93a6-5b7461d8b7e9.png\"\u003e\r\n1. Lazy\u003cHttpClient\u003e (1 Instance)\r\n\u003cimg width=\"987\" alt=\"screen shot 2019-02-12 at 5 36 31 pm\" src=\"https://user-images.githubusercontent.com/1319833/52680316-dc053880-2eec-11e9-92e9-5b2bdf8a505c.png\"\u003e\r\n1. HttpClient - I\u0027m not holing any references....\r\n\u003cimg width=\"976\" alt=\"screen shot 2019-02-12 at 5 37 56 pm\" src=\"https://user-images.githubusercontent.com/1319833/52680345-fb9c6100-2eec-11e9-9e03-7fe76283e4b4.png\"\u003e\r\n\r\nAny thoughts? Look like possible memory leaks (or as you point out \"cleanup\") in the runtime around Application Insights, Key Vault Configuration Integration, and HttpClientFactory (?)\r\n\r\nIt\u0027s a chicken-and-egg, the WebJob `await host.RunAsync();` wont shut down until the references are cleared, but some of these references are being held up by the host...(via Configuration/KeyVault integration, App Insights integration, and it seems the `Lazy\u003c\u003e` references in the HttpClient Factory)!\r\n\r\nI was suspecting that `AzureServiceTokenProvider` as part of `Microsoft.Azure.Services.AppAuthentication` was involved, but seem the .Net Core implementation is *not* leveraging the \u0027HttpClientFactory\u0027 internally. ",
                                           "updatedAt":  "2019-02-13T04:49:08Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ2MzA2NzEwMg==",
                                           "createdAt":  "2019-02-13T05:40:52Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "rynowak",
                                           "body":  "So that last entry points out that there are three `HttpClient` instances held in statics including 1 in a `Lazy\u003cHttpClient`\u003e.\r\n\r\n\u003e It\u0027s a chicken-and-egg, the WebJob `await host.RunAsync();` wont shut down until the references are cleared, but some of these references are being held up by the host...(via Configuration/KeyVault integration, App Insights integration, and it seems the `Lazy\u003c\u003e` references in the HttpClient Factory)!\r\n\r\n@mathewc @fabiocav - is there any more information you can provide? I don\u0027t understand what WebJobs specific mechanism is causing problems here. ",
                                           "updatedAt":  "2019-02-13T05:40:52Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ2MzA3Mzg4Ng==",
                                           "createdAt":  "2019-02-13T06:16:16Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "acds",
                                           "body":  "\r\nTBH: On reflection there seems to be a conflict with using a TimerTrigger job with the expectation that this can be deployed as \"triggered\" not \"continuous\", as The TimeTrigger Job does not end...it just idles for the next trigger time.\r\n\r\nWhist between \"continuous\" time triggered runs, and Idle, the HttpClientFactory is trying to clean up any HttpClient/Handler. It can\u0027t as the WebJob runtime it holding onto at least two of them (in my case, KeyVault integration and App Insights). So at least setting the `SetHandlerLifetime(Timeout.InfiniteTimeSpan)` eliminates the logging noise.\r\n\r\nThere seem to be (undocumented) design decisions/direction to move away from \"triggered\" WebJob deployments (in general): \r\n  * The SDK is it seems geared toward \"continuous\" jobs, and the TimerTrigger job has internalized the scheduling into this model.\r\n  * Despite the Dashboard functionality rhetorically being deprecated \r\n    * With \"continuous\" jobs it becomes less useful as there in no record of each triggered run or the losing associated with it\r\n    * The logging that is available soon fills up...becoming useless.\r\n  * Although App Insights is the rhetorically documented replacement (per other Issues logged), There is no documentation on how to operationally use the App Insights to replace this logging and motoring.\r\n      * App Insights is big and complex and documentation or how best to use it in regards WebJobs would be very helpful.\r\n  * There are no (documented) sample models of how to use the SDK, in a \"triggered\" deployment model with an external schedule file `settings.job`.\r\n  * There is no documented indication that publish support with 3.0 SDK WebJobs will support the \"triggered\" deployment model \r\n  \r\nThat being said, in hindsight it seem that it may be better to move the functionality to a IHostedService  as a background task in the main Web/API App implementation and eliminate to deployment complexity.\r\n\r\nAt the end of the day the problems here all tie back to any real WebJob 3.0 documentation and there is likely no issue here...\r\n\r\nOne hopes that Microsoft do not intend to release future versions with out the requisite documentation, to avoid churn as we learn the hard way.",
                                           "updatedAt":  "2019-02-13T20:40:42Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDQ2NTMwNzAwNQ==",
                                           "createdAt":  "2019-02-19T20:58:23Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "fabiocav",
                                           "body":  "@acds apologies for the delayed response. Somehow, I managed to miss notifications on this issue.\r\n\r\nYou\u0027re correct on what you\u0027ve outlined above.\r\n\r\n- The \"triggered\" WebJobs model is indeed geared towards _non-SDK_ scenarios. Primarily scenarios where you have some existing executable and you just want the App Service/WebJobs infrastructure to trigger that on a schedule (or manually).  SDK scenarios are optimized for _continuous_ WebJobs deployments.\r\n- App Insights is the replacement for the legacy dashboard logging\r\n- For the documentation issues, (including App Insights use and configuration); yes, we are unfortunately behind and some of the problems you\u0027re running into would have likely been prevented if those items were better documented. We\u0027re actively working on updated documentation for WebJobs and those updates should start landing soon.\r\n- This is primarily for @rynowak and @glennc , as it might help answer some of the questions above. There is logic in infrastructure components (App Service/Kudu) to keep WebJobs alive. For continuous WebJobs, Kudu keep the process running and restart it if it exits. For triggered WebJobs, the same components will launch the process based on the trigger events (that really boils down to schedule based scenarios), but they will not be kept running in those cases. There\u0027s nothing the SDK would be doing to intentionally cause the behavior observed above, aside from what I mentioned below where the host is being disposed by the SDK, which really is something it shouldn\u0027t be doing.\r\n\r\nAdding @mathewc as he can also provide more context on the WebJobs infrastructure, if needed.",
                                           "updatedAt":  "2019-02-19T20:58:23Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY0Njc5ODU5NA==",
                                           "createdAt":  "2020-06-19T18:08:28Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOBH_T0w==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "dropsonic",
                                                                               "createdAt":  "2020-06-19T18:09:42Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "srogovtsev",
                                           "body":  "I am terribly sorry for barging in on a distantly connected issue, but I was trying to find a follow up on aspnet/HttpClientFactory#165, which was created from dotnet/aspnetcore#3470, which in turn led to this issue, and they are all closed for comments, and I really don\u0027t think it merits an issue in itself.\r\n\r\nNow, I fully understand what @davidfowl [says](https://github.com/aspnet/HttpClientFactory/issues/165#issuecomment-418232922):\r\n\r\n\u003e The logs seem indicate that things are never going out of scope and hence the supposed leak. What\u0027s happening is the timer that is used to expire the handler has a reference to a callback which seemingly keeps the HttpMessageHandler alive.\r\n\u003e\r\n\u003e When a GC happens things are cleaned up as expected. Until then, the background scanner will keep looping until that happens.\r\n\r\nBut I still am worried: if for some reason GC doesn\u0027t clean things up for some time, I might end up having quite a few of handlers linked there being _undisposed_. Wouldn\u0027t that pose an issue with [socket exhaustion](https://aspnetmonsters.com/2016/08/2016-08-27-httpclientwrong/), which was one of the original reasons for reusing the handlers? Especially that I am on .net 4.8, not Core, so I don\u0027t have access to `SocketsHttpHandler`.",
                                           "updatedAt":  "2020-06-19T18:08:28Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY5MTM1NjA2Ng==",
                                           "createdAt":  "2020-09-11T23:43:16Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/ncl\nSee info in area-owners.md if you want to be subscribed.",
                                           "updatedAt":  "2020-09-11T23:43:16Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY5NDIxMzQ3MA==",
                                           "createdAt":  "2020-09-17T12:58:04Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/ncl\nSee info in area-owners.md if you want to be subscribed.",
                                           "updatedAt":  "2020-09-17T12:58:04Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc65D-UZ",
                                           "createdAt":  "2025-07-22T21:03:38Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Due to lack of recent activity, this issue has been marked as a candidate for backlog cleanup.  It will be closed if no further activity occurs within 14 more days. Any new comment (by anyone, not necessarily the author) will undo this process.\n\nThis process is part of our [issue cleanup automation](https://github.com/dotnet/runtime/blob/main/docs/issue-cleanup.md).\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2025-07-22T21:03:38Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc65jalz",
                                           "createdAt":  "2025-07-24T11:17:18Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "CarnaViire",
                                           "body":  "Idea: We could implement SafeHandler-like ref counting in [LifetimeTrackingHttpMessageHandler](https://github.com/dotnet/runtime/blob/3c94a470bc7fbdabafdf5d224b48dc5500e1b3b3/src/libraries/Microsoft.Extensions.Http/src/LifetimeTrackingHttpMessageHandler.cs).\n\nIt currently just prevents the disposal propagating to the message handler chain, but if we reuse the instance, and track the dispose being called (_and_ if the consumer always promptly disposes the clients), then we could detect the moment the last client is disposed. Meaning, we won\u0027t have to wait for the expired handler to be GCed to initiate the cleanup.",
                                           "updatedAt":  "2025-07-24T11:17:18Z"
                                       }
                                   ],
                         "totalCount":  17
                     },
        "title":  "Investigate whether we can speed up handler cleanup when app is not receiving traffic",
        "labels":  [
                       "area-Extensions-HttpClientFactory"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/36378",
        "createdAt":  "2019-08-27T11:28:05Z",
        "number":  36378,
        "author":  "daiplusplus",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOC68e1A==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "shaynevanasperen",
                                            "createdAt":  "2019-09-26T21:02:29Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "MigratoryCoconuts",
                                            "createdAt":  "2019-11-21T22:01:41Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "rcollina",
                                            "createdAt":  "2019-12-04T23:08:53Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "abdusco",
                                            "createdAt":  "2021-06-13T09:22:18Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "dstarkowski",
                                            "createdAt":  "2021-06-25T10:18:03Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "dhhoang",
                                            "createdAt":  "2022-03-27T05:19:46Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Eli-Black-Work",
                                            "createdAt":  "2022-06-10T06:32:54Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "sergiojrdotnet",
                                            "createdAt":  "2023-01-02T09:26:28Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "sajal-mukherjee-git",
                                            "createdAt":  "2023-07-07T07:05:08Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "spencer741",
                                            "createdAt":  "2024-06-26T23:39:06Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "julealgon",
                                            "createdAt":  "2024-06-27T14:02:00Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "wreuel",
                                            "createdAt":  "2024-09-11T18:53:31Z"
                                        }
                                    ],
                          "totalCount":  12
                      },
        "updatedAt":  "2025-07-26T07:47:10Z",
        "body":  "### Is your feature request related to a problem? Please describe.\r\n\r\nMy application needs runtime-defined named `HttpClient` configuration, and I\u0027m using `IHttpClientFactory`. My application also needs to configure different `DelegatingHandler` chains unique to each named configuration (for injecting configuration-specific Bearer tokens and `access_token` refresh logic).\r\n\r\nMy application is a headless Windows service that stores 1...N-many named `HttpClient` configurations on-disk and it uses an injected-service to read the stored configurations, so the `IServiceProvider` isn\u0027t available to read the configuration while it\u0027s still calling `IServiceCollection.AddHttpClient\u003cMyClient\u003e( ... )` (and the idea of maintaining multiple root `IServiceProvider` instances isn\u0027t appealing either).\r\n\r\nOstensibly, the `IHttpClientFactory` requires all named `HttpClient`s to be set-up during service-configuration - which would make it unsuitable for my application - however I noticed that `DefaultHttpClientFactory`\u0027s pool of `HttpMessageHandler` instances can be added-to even after configuration has completed - this does not seem to be documented either way - so I\u0027m not sure if it\u0027s a bug (i.e. it should be immutable) or a feature (for runtime-configured `HttpClient` and `HttpMessageHandlerBuilder` instances).\r\n\r\n### Describe the solution you\u0027d like\r\n\r\n* A statement from the PM responsible declaring the immutability of `IHttpClient`\u0027s configuration.\r\n* If it is immutable, then fix the bug.\r\n* If it\u0027s mutable, then make it easier to add dynamic configuration of `HttpClient` without jumping through hoops with `IConfigureNamedOptions`.\r\n\r\n### Describe alternatives you\u0027ve considered\r\n\r\nRight now my application depends on the current behaviour for dynamic `HttpClient` configuration, like so:\r\n\r\n```c#\r\n\tinternal class DynamicHttpClientFactoryConfiguration : IConfigureNamedOptions\u003cHttpClientFactoryOptions\u003e\r\n\t{\r\n\t\tpublic void Configure( String httpClientName, HttpClientFactoryOptions options )\r\n\t\t{\r\n\t\t\tIAccessTokenRenewerFactoryStore store = this.sp.GetRequiredService\u003cIAccessTokenRenewerFactoryStore\u003e();\r\n\r\n\t\t\tif( store.TryGetConfiguration( httpClientName: httpClientName, out MyHttpClientConfiguration cfg, out AccessTokenRenewer atr ) )\r\n\t\t\t{\r\n\t\t\t\toptions.HttpClientActions.Add( httpClient =\u003e\r\n\t\t\t\t{\r\n\t\t\t\t\thttpClient.BaseAddress = cfg.Authority;\r\n\t\t\t\t} );\r\n\r\n\t\t\t\toptions.HttpMessageHandlerBuilderActions.Add( httpMessageHandlerBuilder =\u003e\r\n\t\t\t\t{\r\n\t\t\t\t\tAccessTokenRenewDelegatingHandler delegatingHandler = new AccessTokenRenewDelegatingHandler( atr );\r\n\t\t\t\t\thttpMessageHandlerBuilder.AdditionalHandlers.Add( delegatingHandler );\r\n\t\t\t\t} );\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n```\r\n\r\nAnd it \"just works\" whenever code anywhere in my project calls `IHttpClientFactory.CreateClient( configurationName )` (provided that `configurationName` exists in my `IAccessTokenRenewerFactoryStore`).",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOug20eA==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDUyOTk5MzI3NA==",
                                           "createdAt":  "2019-09-10T15:33:42Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODnhLdA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "LAUGH",
                                                                               "user":  "julealgon",
                                                                               "createdAt":  "2024-06-27T14:02:13Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "andresrsanchez",
                                           "body":  "Holy sh!t, u a f!cking genious 🔥🔥🔥\r\nPlease, choose option three!!!",
                                           "updatedAt":  "2019-09-10T15:33:42Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU1NzYwNTIxMg==",
                                           "createdAt":  "2019-11-22T16:43:26Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "oising",
                                           "body":  "Hey @Jehoel -- how exactly do I use DynamicHttpClientFactoryConfiguration ? Where and how do I register it (if needed?) \r\n\r\nEDIT: ah, I think I get it: `services.ConfigureOptions\u003cDynamicHttpClientFactoryConfiguration\u003e()` is needed.",
                                           "updatedAt":  "2019-11-22T16:45:34Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU1NzYzMDg2NQ==",
                                           "createdAt":  "2019-11-22T17:57:29Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "reisenberger",
                                           "body":  "@oising As it\u0027s an `IConfigureNamedOptions\u003cHttpClientFactoryOptions\u003e`, I was assuming one had to do:\r\n\r\n```c#\r\n    services.AddSingleton\u003cIConfigureOptions\u003cHttpClientFactoryOptions\u003e, DynamicHttpClientFactoryConfiguration\u003e();\r\n```\r\n\r\n(but interested if the [shorter version](https://github.com/aspnet/Extensions/issues/2237#issuecomment-557605212) works).\r\n\r\nIt should also be possible to achieve a similar effect [with an `IHttpMessageHandlerBuilderFilter`](https://stackoverflow.com/questions/58953178/how-to-register-polly-on-a-ihttpclient-already-registered).\r\n\r\n",
                                           "updatedAt":  "2021-02-10T17:29:35Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU1Nzk0NDE2MA==",
                                           "createdAt":  "2019-11-25T00:10:04Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "rynowak",
                                           "body":  "\u003e A statement from the PM responsible declaring the immutability of IHttpClient\u0027s configuration.\r\n\u003e If it is immutable, then fix the bug.\r\n\r\nHttpClient factory\u0027s configuration is immutable. This is not a bug, it\u0027s a feature request. \r\n\r\nWhat\u0027s behind your need for N HttpClient configurations? Usually when someone is asking for this kind of feature they asking because they need flexibility related to the use of client certs, proxies, other network settings, etc. Which is it in your case?\r\n\r\n\r\n",
                                           "updatedAt":  "2019-11-25T00:10:04Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU1ODI5Nzc3OA==",
                                           "createdAt":  "2019-11-25T19:10:13Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODnhMMw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "rcollina",
                                                                               "createdAt":  "2019-12-04T23:07:24Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "julealgon",
                                                                               "createdAt":  "2024-06-27T14:03:40Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "oising",
                                           "body":  "@rynowak In my case, I\u0027ve got an event hub and a proxy/relay function that uses information in the message to dynamically determine the REST endpoint to forward the message body. This is represented by a named/typed HttpClient, of which several are cached in a singleton class injected into the function ctor. The problem is that these named clients have to be configured in startup with retry policies, lifetimes etc, when I actually want to configure them dynamically at runtime. ",
                                           "updatedAt":  "2019-11-25T19:10:13Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU1ODc4MjM5MQ==",
                                           "createdAt":  "2019-11-26T19:27:26Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "rynowak",
                                           "body":  "\u003e when I actually want to configure them dynamically at runtime.\r\n\r\nWhen you say you want to configure them dynamically... based on what information? Suppose client factory adds a feature to run code dynamically when a client is requested - what data do you need as input?",
                                           "updatedAt":  "2019-11-26T19:27:26Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU1OTQ1MjkxMw==",
                                           "createdAt":  "2019-11-28T11:16:50Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCKuVWA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "oising",
                                                                               "createdAt":  "2019-12-04T20:03:36Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "rcollina",
                                                                               "createdAt":  "2019-12-04T23:07:04Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Eli-Black-Work",
                                                                               "createdAt":  "2022-01-20T08:03:21Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  3
                                                         },
                                           "author":  "daiplusplus",
                                           "body":  "@rynowak \r\n\r\n\u003e HttpClient factory\u0027s configuration is immutable. This is not a bug, it\u0027s a feature request.\r\n\r\nThat\u0027s not what my post is about. Dynamic configuration **already exists**, it\u0027s just difficult to use.\r\n\r\nIf the configuration is immutable (as you posit it is), then why is it that I _can_ currently have dynamic configuration using only stock .NET Standard types? (i.e. without using any tricks like reflection, so using only `IConfigureOptions\u003cT\u003e` and `IConfigureNamedOptions`).\r\n\r\n\u003e What\u0027s behind your need for N HttpClient configurations? \r\n\r\nIn my case, I have a single headless Windows Service process that supports multi-tenancy (in the client-side, not just the server-side) so it supports having N-many configuration files which are loaded _after_ `ConfigureServices` has completed - so each configuration file has its own web-service base URI, client certificate and/or access-token (or OIDC client credentials) and when the process is initialized it means each configuration instance in-memory has its own private `HttpClient` instance that has the `BaseAddress`, `DefaultRequuestHeaders`, and `Cookies` (via `HttpClientHandler`) properties set. I couldn\u0027t find a good way to get this to work using the stock `IHttpClientFactory`.\r\n\r\nSidenotes:\r\n\r\n* I did consider storing the multi-tenant configuration dictionary inside `app.config` (or a separate file) so it would be exposed via `IConfiguration`, however a project requirement is that the configuration file be editable and reloadable without restarting the entire process.\r\n    * While [I know it\u0027s possible to use `IOptionsSnapshot\u003cT\u003e` and other techniques](https://edi.wang/post/2019/1/5/auto-refresh-settings-changes-in-aspnet-core-runtime), however conforming to that API would require making substantial (and backwards-incompatible) changes to my existing code.\r\n* I also have prior existing library code that uses injected `HttpClient` instances that I wanted to reuse.  \r\n    * And this old library code I mentioned must run on embedded systems running rather obscure builds of Windows that aren\u0027t supported by .NET Standard 2.0 (downgrading to .NET Standard 1.1-compatible versions of `Microsoft.Extensions.*` is not feasible).\r\n* I also wanted to keep \"system configuration\" separate from \"tenant configuration\". The `serviceExe.config.json` file is kept in `C:\\Program Files\\MyService\\ServiceExe.config.json` and can only be edited by administrators, whereas the other configuration files are kept in `C:\\ProgramData\\MyService\\UserEditableConfig.json` and my service\u0027s installation code sets the NTFS ACLs on the `C:\\ProgramData\\MyService` directory to allow any local user to edit it (this is acceptable given our threat-model).\r\n\r\nHere\u0027s a feel for what my application\u0027s `UserEditableConfig.json` configuration file looks like:\r\n\r\n```\r\n\"serviceClientConfigurations\": [\r\n    \"customerFoobar\": {\r\n        \"oidcClientId\": \"foobar123\",\r\n        \"oidcClientPassword\": \"base64value-encrypted-with-DPAPI-machine-key\",\r\n        \"someOtherSetting\": \"foobar\",\r\n        \"pollInterval\": 180,\r\n        \"webSockets\": true\r\n    },\r\n    \"customerBaz\": {\r\n        \"oidcClientId\": \"baz456\",\r\n        \"oidcClientPassword\": \"another-base64value-encrypted-with-DPAPI-machine-key\",\r\n        \"someOtherSetting\": \"foobar\",\r\n        \"pollInterval\": 360,\r\n        \"webSockets\": false\r\n    },\r\n    \"customerQux\": {\r\n        \"oidcClientId\": null,\r\n        \"oidcClientPassword\": null,\r\n        \"someOtherSetting\": \"foobar\",\r\n        \"pollInterval\": 360,\r\n        \"webSockets\": false\r\n    }\r\n]\r\n```\r\n",
                                           "updatedAt":  "2019-12-10T09:08:49Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU2MTgxNjIwNg==",
                                           "createdAt":  "2019-12-04T20:03:31Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODRJ0gg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "daiplusplus",
                                                                               "createdAt":  "2020-04-09T04:37:31Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "yjagota",
                                                                               "createdAt":  "2024-01-03T18:09:50Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "oising",
                                           "body":  "@rynowak My scenario is roughly the same as @Jehoel above. So, that\u0027s a plus one.",
                                           "updatedAt":  "2019-12-04T20:03:31Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDYyNTU1Njk1MQ==",
                                           "createdAt":  "2020-05-08T00:02:57Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "As part of the migration of components from dotnet/extensions to dotnet/runtime (https://github.com/aspnet/Announcements/issues/411) we will be bulk closing some of the older issues. If you are still interested in having this issue addressed, just comment and the issue will be automatically reactivated (even if you aren\u0027t the author). When you do that, I\u0027ll page the team to come take a look. If you\u0027ve moved on or workaround the issue and no longer need this change, just ignore this and the issue will be closed in **7 days**.\n\nIf you know that the issue affects a package that has moved to a different repo, please consider re-opening the issue in that repo. If you\u0027re unsure, that\u0027s OK, someone from the team can help!",
                                           "updatedAt":  "2020-05-08T00:02:57Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDYyNjEyODQ5Nw==",
                                           "createdAt":  "2020-05-09T08:27:14Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEDIk4A==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "oising",
                                                                               "createdAt":  "2020-05-10T02:11:05Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "dstarkowski",
                                                                               "createdAt":  "2021-06-25T10:38:26Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Eli-Black-Work",
                                                                               "createdAt":  "2022-01-20T08:03:39Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "yjagota",
                                                                               "createdAt":  "2024-01-03T18:09:45Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "DAHAG-ArisNourbakhsh",
                                                                               "createdAt":  "2024-03-15T09:51:56Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Neutrino-Sunset",
                                                                               "createdAt":  "2024-03-26T16:43:07Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "B-CCCPcekca-HET",
                                                                               "createdAt":  "2025-01-19T07:54:20Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  7
                                                         },
                                           "author":  "daiplusplus",
                                           "body":  "@msftbot Please keep this issue open.\r\n\r\nPersonal rant: I strongly disagree with the practice of _closing_ bugs simply because they\u0027re stale or seemingly abandoned. Of course bugs/issues should be tagged as stale over time (which allows them to be filtered ) but in my book, bugs should only be Closed after they\u0027re Definitely Resolved - and closing bugs as stale **after only 7 days after moving them** is a bit mean. There are plenty of issues I\u0027ve created on GitHub and elsewhere that I can\u0027t make progress on because they might be in a completely different project or team that I\u0027m currently working-in and I can\u0027t always afford to make the mental context-switch just for a minor update to an issue at very short-notice.\r\n\r\nWhat would be great, especially for API issues like these, if if issues were required to have an attached test-case that demonstrates the issue (if possible). Though requiring people to fork the test project is overkill, perhaps if there was something like an online C# equivalent of LinqPad that could be used to quickly submit quick-and-dirty or proof-of-concept test-cases?",
                                           "updatedAt":  "2020-05-09T08:32:59Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDYyNjEyODUwMw==",
                                           "createdAt":  "2020-05-09T08:27:16Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Paging @dotnet/extensions-migration ! This issue has been revived from staleness. Please take a look and route to the appropriate repository.",
                                           "updatedAt":  "2020-05-09T08:27:16Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg0MTMwMjk5Mg==",
                                           "createdAt":  "2021-05-14T15:08:33Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Vandersteen",
                                           "body":  "Are there any plans to ever support this ?",
                                           "updatedAt":  "2021-05-14T15:08:33Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg1MzY1NTY5MQ==",
                                           "createdAt":  "2021-06-03T07:42:18Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "daiplusplus",
                                           "body":  "@Vandersteen It *is* \"supported\" insofar as _it works_ and Microsoft is duty-bound to not introduce any breaking changes at this point.\r\n\r\nHowever it is \"not supported\" insofar as the behaviour I\u0027ve observed in `DefaultHttpClientFactory` is still not documented.\r\n\r\n",
                                           "updatedAt":  "2021-06-03T07:42:18Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg1MzczMzc2MA==",
                                           "createdAt":  "2021-06-03T09:36:32Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODnhMsA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "daiplusplus",
                                                                               "createdAt":  "2021-06-03T09:37:37Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "dstarkowski",
                                                                               "createdAt":  "2021-06-25T10:24:15Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "PaulRReynolds",
                                                                               "createdAt":  "2021-11-29T12:25:20Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "dhhoang",
                                                                               "createdAt":  "2022-03-27T05:15:15Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "mbrankintrintech",
                                                                               "createdAt":  "2022-06-09T01:32:50Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "sergiojrdotnet",
                                                                               "createdAt":  "2023-01-02T09:30:55Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "jirikoud",
                                                                               "createdAt":  "2023-11-12T10:23:34Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Neutrino-Sunset",
                                                                               "createdAt":  "2024-03-26T16:43:51Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "julealgon",
                                                                               "createdAt":  "2024-06-27T14:04:34Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  9
                                                         },
                                           "author":  "Vandersteen",
                                           "body":  "\u003e \u003e when I actually want to configure them dynamically at runtime.\r\n\u003e \r\n\u003e When you say you want to configure them dynamically... based on what information? Suppose client factory adds a feature to run code dynamically when a client is requested - what data do you need as input?\r\n\r\nIn my case:\r\n\r\n* Configuration is stored in a database (url, auth information, retry policies, certificates, ...)\r\n* So I should be able to \u0027build\u0027 a client at runtime and not at \u0027startup\u0027 time",
                                           "updatedAt":  "2021-06-03T09:36:32Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5EtbiB",
                                           "createdAt":  "2022-06-10T21:48:04Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "nickjmcclure",
                                           "body":  "Has there been any more discussion on this?\r\n\r\nHere is the specific example I\u0027m dealing with:\r\n\r\nWe have an application that pushes users out to our various SAP systems running various SAP products, but running the same base SAP. Our application calls REST web services hosted on the SAP servers to manage users and sync data. When the SAP team sets up a new server, they go to my app to register the server.\r\n\r\nIn my current .net 4.5 app, I\u0027m just using a singleton with a concurrent dictionary to keep instances of `HttpClient`, one for each remote system. I use `TryGetValue()` and `GetOrAdd()` to keep up with the list. Prior to using this method, connection exhaustion was a major issue.\r\n\r\nIs this even needed in .net 6? If I just use the standard `HttpClient` in my process, will it automatically handle connection pooling based on the client config options like `BaseAddress`, or do I need to continue to use my singleton to prevent connection exhaustion?",
                                           "updatedAt":  "2022-06-10T21:48:04Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Gm-0a",
                                           "createdAt":  "2022-07-14T16:04:20Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dazinator",
                                           "body":  "So I also came to the same sort of solution as posted here, independently.\r\nI too, want to be able to re-configure http clients at runtime, for example, changing the base address, or handlers.\r\n\r\nI realised the best way to do this is to \"cache bust\" the `IHttpClientFactory` by requesting a http client, with a new name, so it builds an entirely new http client configuration. There is nothing in it\u0027s design that prohibits this - it\u0027s perfectly valid to request a http client with a new name not \"registered\" ahead of time. The interaction with the `Options` system is the important missing piece in terms of how such a http client will subsequently be built / configured in terms of handlers etc.\r\n\r\nSo for example in your application, you would ask for a http client named `foo-v1` and then later if there was change to the settings for that http client at runtime, you would need to start asking for `foo-v2`. The new name ensures the factory doesn\u0027t return the previous http client configuration and actually builds a new one. When `foo-v1` or `foo-v2` or `foo-vX` is requested, you need to ensure you return a `HttpClientFactoryOptions` instance configured based on the latest settings for the `foo` http client. The suffix or prefix mechanism you use isn\u0027t exactly important just important to use a mechanism that appends some cache busting value that can be changed at runtime.\r\n\r\nThe issue with this is that the `Options` system wants you to supply the `names` or named options at registration time in order to configure each name. However with a system like this, you don\u0027t know all the names at registration time, at runtime the name to be used is incremented and will be therefore, dynamic in nature. So the issue for me became - how do I hook into the Options system such that I can ensure I can configure named Options instances, where the name is changing at runtime, and not specified in advance at registration time.\r\n\r\nThat\u0027s where https://github.com/dazinator/Dazinator.Extensions.Options was born - it supplies this mechansim. \r\n\r\nYou can then achieve the above like this:\r\n\r\n```cs\r\n                services.AddHttpClient();\r\n\r\n               // Add package: Dazinator.Extensions.Options\r\n                services.Configure\u003cHttpClientFactoryOptions\u003e((sp, name, options) =\u003e\r\n                {\r\n                    // name = e.g \"foo-v1\", map this to your http client name e.g \"foo\" and apply the latest configuration.                   \r\n                    options.HttpMessageHandlerBuilderActions.Add(a =\u003e\r\n                    {                       \r\n                        a.PrimaryHandler = new NotImlementedExceptionHttpMessageHandler();\r\n                        // a.BaseAddress = new Uri($\"http://{name}.localhost/\");\r\n                    });\r\n                });\r\n\r\n```\r\n\r\nNote: I did it this way because the ability to register a delegate that can `Configure` a named options instance, where the name is not known at registration time, seems to be useful in its own right. In the case of this issue with `IHttpClientFactory` - it proves it\u0027s use.",
                                           "updatedAt":  "2022-07-14T16:17:56Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5HElgP",
                                           "createdAt":  "2022-07-22T09:41:10Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODnhUrw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "julealgon",
                                                                               "createdAt":  "2024-06-27T14:13:32Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "dazinator",
                                           "body":  "I\u0027ve packaged my solution to this: Import nuget package:\r\n```\r\n    \u003cPackageReference Include=\"Dazinator.Extensions.Options\" Version=\"0.1.0-alpha.8\" /\u003e\r\n```\r\n\r\nAdd ` using Microsoft.Extensions.Options;` then:\r\n\r\n\r\n```cs\r\n                services.AddHttpClient();              \r\n                services.Configure\u003cHttpClientFactoryOptions\u003e((sp, name, options) =\u003e\r\n                {\r\n                    // configure this named http client however you want:\r\n                    // add to it\u0027s handlers:-                \r\n                    options.HttpMessageHandlerBuilderActions.Add(a =\u003e\r\n                    {                      \r\n                        a.PrimaryHandler = new NotImlementedExceptionHttpMessageHandler();                     \r\n                    });\r\n                    // set the http client:\r\n                    options.HttpClientActions.Add(a =\u003e\r\n                    {                       \r\n                        a.BaseAddress = new Uri($\"http://{name}.localhost/\");\r\n                    });\r\n                });\r\n\r\n```\r\n\r\nThen later get clients with the normal `IHttpClientFactory` - if you want a freshly built client use a new name:\r\n\r\n```cs\r\n var fooClient = httpClientFactory.CreateClient(\"foo-v1\");\r\n var barClient = httpClientFactory.CreateClient(\"foo-v2\");\r\n```",
                                           "updatedAt":  "2022-07-22T09:54:22Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5HFIoh",
                                           "createdAt":  "2022-07-22T12:36:00Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dazinator",
                                           "body":  "I\u0027ve also solved a few other problems, may be worth reading: https://github.com/dazinator/Dazinator.Extensions.Http",
                                           "updatedAt":  "2022-07-22T12:36:00Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Rlexh",
                                           "createdAt":  "2023-01-02T09:36:45Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCx_zuw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "nickjmcclure",
                                                                               "createdAt":  "2023-01-02T19:53:27Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "sergiojrdotnet",
                                           "body":  "I think we might still need a final decision since the multi tenancy scenario is becoming more frequently for `HttpClientFactory`",
                                           "updatedAt":  "2023-01-02T09:36:45Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5RmwqQ",
                                           "createdAt":  "2023-01-02T17:42:55Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCx_oIA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "EYES",
                                                                               "user":  "daiplusplus",
                                                                               "createdAt":  "2023-01-02T17:46:23Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "sergiojrdotnet",
                                                                               "createdAt":  "2023-01-02T17:47:09Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "davidfowl",
                                           "body":  "@dazinator Clever. \r\n\r\nThe current factory is unsuitable for this model. Also, the idea of dynamically adding/removing configuration at runtime. The next request that\u0027ll come is that the creation of the client will need to be async because tenant information is lazily accessed and needs to queried from the database.\r\n\r\n",
                                           "updatedAt":  "2023-01-02T17:42:55Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5RnDx5",
                                           "createdAt":  "2023-01-02T20:40:19Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCyH_oA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Eli-Black-Work",
                                                                               "createdAt":  "2023-01-05T02:40:39Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "dazinator",
                                           "body":  "@davidfowl thanks. It was not clear what the alternative / recommended approach was for this and I was reluctant to give up IHttpClientFactory and write my own factory due to the complexities involved. Luckily the approach was possible within the design, but not very obvious, and perhaps not something the team foresaw. Still it works (for now).\r\n\r\n\u003e The next request that\u0027ll come is that the creation of the client will need to be async because tenant information is lazily accessed and needs to queried from the database\r\n\r\nYou can make this request already irrespective of anything to do with this issue - if any app wants to configure an http client asynchronously from the database..? I think one reason you may not see demand for this though is because it\u0027s already clear to many that IConfiguration / Options system is the configuration story for dotnet apps, so typically you\u0027d expect configuration held in a database (or other async store) to be brought in to IConfiguration (and thus IOptions) by a configuration provider? In this \"standard\" model, reloading / refreshing IConfiguration before building new objects with it (http clients) becomes the path of least resistance, there would be no need to support an async http client creation method just because of this github issue.",
                                           "updatedAt":  "2023-01-02T21:30:49Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5RnVqN",
                                           "createdAt":  "2023-01-02T23:17:16Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "davidfowl",
                                           "body":  "I really think it comes down to @rynowak\u0027s original question to get a sense of the types of things people are doing or wanting to do per tenant with the HttpClient. If you end up needing to mutate any properties related to the `HttpMessageHandler` per tenant then everything gets harder, and you need to do [what @nickjmcclure described here](https://github.com/dotnet/runtime/issues/36378#issuecomment-1152759937). Can we enumerate some of these to see what patterns people are using currently? \r\n\r\nI\u0027m also very worried about the default scope mismatch between the incoming request (int ASP.NET Core applications) and the outgoing request. This causes lots of issues today and it\u0027s something I\u0027d like to address as an overall solution in this space.\r\n\r\nCan we pivot to enumerating some of the multitenancy scenarios? We\u0027re interested in learning about:\r\n1. How do you identify the tenant for the outgoing requests? \r\n   - Is it ever based on the incoming requests?\r\n3. Where is tenant information stored?\r\n    - Is it all known up front? Is it lazy? Does it require asynchronous fetch to get this information?\r\n4. Which parts of the HttpClient do you need to change? Client Certs, URLs, headers, etc?\r\n    - Is it all per request information or is it per connection information?\r\n5. Do you need to remove tenant configuration?\r\n    - Do you need the per tenant information to expire at some point?\r\n\r\nI\u0027m sure there are more questions, but we can start with those.",
                                           "updatedAt":  "2023-01-02T23:17:16Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5RnWzY",
                                           "createdAt":  "2023-01-02T23:34:23Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Vandersteen",
                                           "body":  "My 2 cents on the issue:\r\n\r\nMaybe you do not need to solve every possible use case for developers, but rather give them the tools to do so.\r\nAs the code now works, you have a \u0027factory\u0027 that does some caching / pre-configuring for you.\r\n\r\nWhat if, a method is added that accepts:\r\n\r\n* A \u0027cache\u0027 key\r\n  * This key is now automatically generated from configuration or provided by you calling CreateClient(string name);\r\n* An (async) callback to construct / configure the client (handlers) if it is not cached\r\n  * This essentially already exists today but in form of IOptions / Configuration\r\n\r\nThe consumer would be responsible to \u0027bust\u0027 the cache key when appropriate, and the IHttpClientFactory can keep doing it\u0027s thing without polluting it too much trying to solve the whole world\u0027s problems.\r\n\r\nAs far as I can see, this would be a relatively easy addition in the current code base (without introducing breaking changes).\r\n\r\n\r\n* Creating / configuring a client on the fly: Check\r\n* Updating a client on the fly: Check (you create a new one and stop using the old one)\r\n* \u0027Removing\u0027 a client on the fly: Stop using it, the IHttpClientFactory already has a \u0027time\u0027 based way to dispose / close clients to bust DNS cache (which is also configurable)\r\n\r\nOne thing that might require \u0027protecting\u0027 is overwriting a \u0027pre\u0027 configured client (if you accidentally use the same cache key as a client configured from startup)\r\nThrowing an exception that that is not allowed could be an option there",
                                           "updatedAt":  "2023-01-03T00:00:34Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5RnXZy",
                                           "createdAt":  "2023-01-02T23:44:35Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "davidfowl",
                                           "body":  "\u003e Maybe you do not need to solve every possible use case for developers, but rather give them the tools to do so.\r\nAs the code now works, you have a \u0027factory\u0027 that does some caching / pre-configuring for you.\r\n\r\nGiving developers the right tools mean understanding *MANY* scenarios and making sure what\u0027s there works for them, and for future scenarios they haven\u0027t thought about yet.\r\n\r\nPS: Finding a hack and making things work for your scenario is fine, but it\u0027s not how we rubber stamp scenarios. There are likely issues that haven\u0027t been found yet, or ones that break down in other scenarios. \r\n\r\nSo, let\u0027s focus on the what instead of the how, or I can open a new issue to solicit this feedback (since the original issue is about this specific hack).",
                                           "updatedAt":  "2023-01-02T23:44:59Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5RncqR",
                                           "createdAt":  "2023-01-03T00:38:53Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Vandersteen",
                                           "body":  "\u003e Giving developers the right tools mean understanding _MANY_ scenarios and making sure what\u0027s there works for them, and for future scenarios they haven\u0027t thought about yet.\r\n\r\nI understand that all too well, my \u0027impatient\u0027 brain kicks in after 3 years working around this issue and is thinking 80/20.\r\n\r\n\u003e PS: Finding a hack and making things work for your scenario is fine, but it\u0027s not how we rubber stamp scenarios. There are likely issues that haven\u0027t been found yet, or ones that break down in other scenarios.\r\n\r\nTo be clear, I\u0027m not talking about a hack like the \u0027above\u0027 mentioned (hacking into the IOptions that is). I might have poorly explained what I meant. But rather re-using internal IHttpClientFactory logic to provide a new \u0027Factory method\u0027 (without using IOptions)\r\n\r\nIn a poorly explained way, IHttpClientFactory does 2 things: Cache clients and create them. Only today you can only \u0027pre-warm\u0027 the cache using IOptions.\r\n\r\nSo distill that base logic, expose it and let the IOptions pattern build on top of it\r\n\r\nSomething like: (No IOptions), an async version might also be considered\r\n\r\n```\r\nCreateClient(string name, Action\u003cHttpClient\u003e configureClient, Func\u003cHttpClientHandler\u003e provideCustomHandler);\r\n```\r\n\r\nYou could view that method as \u0027core\u0027 logic, where the following *existing* one uses the same logic with those 2 arguments prefilled from IOptions\r\n\r\n```\r\nCreateClient(string name);\r\n```\r\n\r\nNot sure if that clarified anything\r\n\r\n\u003e So, let\u0027s focus on the what instead of the how, or I can open a new issue to solicit this feedback (since the original issue is about this specific hack).\r\n\r\nI won\u0027t sidetrack you with more \u0027how\u0027 after this.",
                                           "updatedAt":  "2023-01-03T00:38:53Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Rng6D",
                                           "createdAt":  "2023-01-03T01:34:02Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODnUtPw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "davidfowl",
                                                                               "createdAt":  "2023-01-03T02:05:23Z"
                                                                           },
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "sergiojrdotnet",
                                                                               "createdAt":  "2023-01-04T22:16:47Z"
                                                                           },
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "spencer741",
                                                                               "createdAt":  "2024-06-26T23:38:54Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  3
                                                         },
                                           "author":  "Vandersteen",
                                           "body":  "\u003e I\u0027m also very worried about the default scope mismatch between the incoming request (int ASP.NET Core applications) and the outgoing request. This causes lots of issues today and it\u0027s something I\u0027d like to address as an overall solution in this space.\r\n\r\nThis one almost bit us as well when we tried to implement a handler using Transient / Scoped services.\r\nWe were able to work around most except for Client Cert Auth \u0026 Trusted SSL Certs\r\n\r\n\r\n\u003e 1. How do you identify the tenant for the outgoing requests?\r\n\r\nIn a message processing solution i\u0027m working on it is based on the content of the message, sender of the message, ... and the specific configuration required for building the client is stored in a database. Depending on the load going through those \u0027clients\u0027, the ability to react to changes \u0027quickly\u0027 without having to resort to (extremely) short lived / used connections could be helpful performance wise.\r\n\r\n\u003e    * Is it ever based on the incoming requests?\r\n\r\nCould you clarify, do you mean the ASP.net core request ?\r\n* In some solutions yes (We built a reverse proxy using IHttpClientFactory)\r\n* In some solutions it\u0027s only used in worker services\r\n\r\n\u003e 2. Where is tenant information stored?\r\n\u003e    * Is it all known up front? Is it lazy? Does it require asynchronous fetch to get this information?\r\n\r\n* In some solutions everything is known up front\r\n* In some solutions it is contained in a store (file / http / db / ...)\r\n  * Acquiring this information is almost always async\r\n  * (Certificates are the biggest pain point in todays implementation)\r\n\r\n\u003e 3. Which parts of the HttpClient do you need to change? Client Certs, URLs, headers, etc?\r\n\r\n* Urls\r\n* Headers\r\n* Timeout\r\n* Not only HttpClient but Handlers as well: \r\n  * Client Authentication Certs\r\n  * Retry /  Throttling Logic\r\n  * Trusted SSL certs (ServerCertificateCustomValidationCallback)\r\n  * Logging Levels\r\n\r\nThe following remain untouched in our use cases:\r\n\r\n* DefaultRequestVersion\r\n* DefaultVersionPolicy\r\n* MaxResponseContentBufferSize\r\n\r\n\u003e    * Is it all per request information or is it per connection information?\r\n\r\n* We haven\u0027t had the need to change configuration on a request to request basis, we are (currently) using multiple connections when that is required. However having the ability to \u0027react\u0027 to changes \u0027quickly\u0027 without rely-ing on expiration would be a welcome feature.\r\n\r\nTo clarify \u0027quickly\u0027: let the current requests flow through that have a reference to the existing configured client but give me an updated client for new \u0027scopes\u0027, or, let me update a client at run time (if that\u0027s possible)\r\nIn places where we expect \u0027long processing\u0027, we currently resort to IHttpClientFactory and request a new client every X iterations / elapsed timespan\r\n\r\n\u003e 4. Do you need to remove tenant configuration?\r\n\u003e    \r\n\u003e    * Do you need the per tenant information to expire at some point?\r\n\r\nSome configurations could be dropped at some point and never re-used again. Being able to clean up (and free resources) would be a good thing.\r\n(We have thousands of different configurations / endpoints in use)\r\n\r\nNot all of those are used at the same pace, some are used continuously. Some are used sporadically or once a minute/ hour / day / ...\r\n\r\nBeing able to \u0027expire\u0027 these at different rates could also save us some resources\r\n",
                                           "updatedAt":  "2023-01-03T01:47:08Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Roiyx",
                                           "createdAt":  "2023-01-03T10:03:36Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCyH_3g==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Eli-Black-Work",
                                                                               "createdAt":  "2023-01-05T02:42:25Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "dazinator",
                                           "body":  "Just wanted to point out obvious that it would cause weird problems to switch out the url (or other settings) for a named http client in current use as im sure everyone is aware. So to do it safely we need to be able to keep old configurations alive whilst being able to rollover to a newer configuration. Using a new http client name works ok for this currently. \r\nWhether its a hack or not depends on perspective as there is nothing about IHttpClientFactory that is being altered, its a valid use and extension of the options system in play and falls within the design even if its undocumented. It\u0027s just a shame to have to jump through such hoops to get a solution that would be nice to have solved out of the box :-)\r\n",
                                           "updatedAt":  "2023-01-03T10:35:49Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5RotYB",
                                           "createdAt":  "2023-01-03T10:50:34Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCyEG5g==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "davidfowl",
                                                                               "createdAt":  "2023-01-04T04:28:04Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "dazinator",
                                           "body":  "@davidfowl \r\n\r\n\u003e How do you identify the tenant for the outgoing requests?\r\n\r\n - outgoing request is made within the scope of a per tenant DI container built when tenant is initialised.\r\n \r\n\u003e Is it ever based on the incoming requests? \r\n\r\nYes sometimes, if the outgoing request is being made inline with an inbound request, the subdomain from inbound request is used to map the handling of the request to a handler within the scope of the correct tenants container.\r\n\r\n\u003e Where is tenant information stored? \r\n\r\nDatabase, cached in memory\r\n\r\n\u003e Is it all known up front? Is it lazy? Does it require asynchronous fetch to get this information?\r\n\r\nYes it\u0027s known up front. We either incorporate it from the database into IConfiguration via config Reload() or in some cases we have a service for the tenant that caches the info from database which we expire after settings are changed. No async fetch required usually.\r\n\r\n\u003e Which parts of the HttpClient do you need to change? Client Certs, URLs, headers, etc.\r\n\r\nAll of above - we completely rebuild http client after any config changes, url and auth headers are main ones, others like enabling diagnostics enable particular additional handlers in pipeline etc.\r\n\r\n\u003e Is it all per request information or is it per connection information?\r\n\r\nNot sure what this means precisely but think it\u0027s both - handlers and url being per connection, optional url path segments being per request level config?\r\n\r\n\u003e Do you need to remove tenant configuration?\r\n\r\nNot explicitly, we need to update it. However we want to do so in way that doesn\u0027t disrupt active processes using the previous configuration. This currently means we rotate to a new configuration and trust the old one to \u0027expire\u0027 or be removed after period of non use or after next application restart.\r\n\r\n\u003e Do you need the per tenant information to expire at some point?\r\n\r\nFrom memory yes but it could technically be required at any point in the future given message queue based processing:-\r\n\r\n1. Two messages placed on queue the first was produced at a time where old http config was in effect and so it\u0027s important its payload is sent using this old http config. The second was produced after new http config was in effect so its important its payload gets sent using the new http client config. The application may have been offline for days since the messages were queued. In another scenario both messages are not config version sensitive and can be fine for \"the latest\" config to be used to process both.",
                                           "updatedAt":  "2023-01-03T10:58:45Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5fFIKA",
                                           "createdAt":  "2023-06-16T19:20:06Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEDIlNA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "daiplusplus",
                                                                               "createdAt":  "2023-06-17T06:12:28Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "MichelZ",
                                                                               "createdAt":  "2024-02-15T10:20:38Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "B-CCCPcekca-HET",
                                                                               "createdAt":  "2025-01-19T07:57:02Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  3
                                                         },
                                           "author":  "nickjmcclure",
                                           "body":  "@davidfowl \r\n\r\n\u003e 1. How do you identify the tenant for the outgoing requests?\r\n\u003e    * Is it ever based on the incoming requests?\r\n\r\nIn my case, it isn\u0027t a multi-tenancy, my situation is more similar to a webhook type scenario, I have an application that is making outbound calls to a set of sites that are registered to receive updates from our central system. The receiver would be identified by the name of the subscriber, it could be one of several SAP instances that we send updates to.\r\n\r\n\u003e 2. Where is tenant information stored?\r\n\u003e    * Is it all known up front? Is it lazy? Does it require asynchronous fetch to get this information?\r\n\r\nIt is stored in a DB table, however subscribers can be added/updated as part of normal runtime, so when a new subscriber comes online, the system will begin to push updates to it. In my situation the subscriber is updated via our front end portal. Then the background system that actually does the work reads the targets when there is an event, if a new target is found, it currently creates a new client and adds it to the dictionary. So the work to pull the config information is already happening, it doesn\u0027t really matter if the data is being loaded lazily because that shouldn\u0027t impact the registration of the new named HttpClient instance. I already have that config using my current process.\r\n\r\n\u003e 3. Which parts of the HttpClient do you need to change? Client Certs, URLs, headers, etc?\r\n\u003e    * Is it all per request information or is it per connection information?\r\n\r\nFor my use it is URLs and Headers. It is per subscriber, so the headers and URLs are always the same per subscriber, so I would have one named HttpClient per subscriber, and that client would have the appropriate configuration for that connection.\r\n\r\n\u003e 4. Do you need to remove tenant configuration?\r\n\u003e    * Do you need the per tenant information to expire at some point?\r\n\r\nYes, if a subscriber goes away, we\u0027d want to have a method that allowed us to remove an unneeded named HttpClient from the factory.",
                                           "updatedAt":  "2023-06-16T19:21:04Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5-yKUr",
                                           "createdAt":  "2024-05-23T13:13:00Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "asturl",
                                           "body":  "Can\u0027t believe this has been essentially untouched for half a decade. I have a scenario similar to @nickjmcclure and it doesn\u0027t seem like a particularly strange or rare requirement to want to define/change named clients after startup.",
                                           "updatedAt":  "2024-05-23T13:13:00Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5-zL_B",
                                           "createdAt":  "2024-05-23T14:54:38Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODnhPSA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "rynowak",
                                                                               "createdAt":  "2024-05-23T16:34:09Z"
                                                                           },
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "CarnaViire",
                                                                               "createdAt":  "2024-05-28T10:20:41Z"
                                                                           },
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "julealgon",
                                                                               "createdAt":  "2024-06-27T14:07:40Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  3
                                                         },
                                           "author":  "davidfowl",
                                           "body":  "Now that we have keyed services it\u0027s much easier to build these sorts of systems using the \"any key\" pattern.\r\n\r\n```C#\r\nbuilder.Services.AddKeyedTransient\u003cHttpClient\u003e(KeyedService.AnyKey, (IServiceProvider sp, object key) =\u003e\r\n{\r\n     // Do something here to get the right http client given the input key. \r\n});\r\n```\r\n\r\nThis avoids the up-front registration problem that the client factory has today.",
                                           "updatedAt":  "2024-05-23T15:29:43Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5-0jg1",
                                           "createdAt":  "2024-05-23T17:34:08Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "daiplusplus",
                                           "body":  "\u003e @davidfowl  Now that we have keyed services\r\n\r\nI just noticed it\u0027s `Object key` - rather than `TObject key` - _aaaaarggghhhh_. \r\n\r\n...does `ServiceKey` use `DefaultComparer\u003cObject\u003e` then - or does it only use strict reference-equality only - or will any `override Boolean Equals(Object? obj)` method do? - or how do we specify a custom `IEqualityComparer` for DI service keys? is `String.Empty` equivalent to `null`? Etc? Etc? [The documentation page is unhelpfully sparse on details](https://learn.microsoft.com/th-TH/dotnet/api/microsoft.extensions.dependencyinjection.servicedescriptor.servicekey?view=net-8.0#microsoft-extensions-dependencyinjection-servicedescriptor-servicekey). \r\n\r\n",
                                           "updatedAt":  "2024-05-23T17:41:04Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5-2yGs",
                                           "createdAt":  "2024-05-24T00:50:00Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODjAvwQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "daiplusplus",
                                                                               "createdAt":  "2024-05-24T01:11:35Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "davidfowl",
                                           "body":  "It uses object.Equals by default but for this you just need strings.",
                                           "updatedAt":  "2024-05-24T00:50:00Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6Cs3E3",
                                           "createdAt":  "2024-06-26T23:46:16Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODngRCQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "sergiojrdotnet",
                                                                               "createdAt":  "2024-06-27T12:19:34Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "spencer741",
                                           "body":  "Bump. Post-Container-Registration needs:\n\n* Add/Remove Client Authentication Certs\n* Add/Remove headers\n* Modify Request Timeouts\n\n(In case you want to know...Mainly driven by hot-reloading fields from config files)  \n\nKeep the train going? IHttpClientFactoryFactory /s",
                                           "updatedAt":  "2024-06-26T23:46:16Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6C0j3y",
                                           "createdAt":  "2024-06-27T14:13:13Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOD0Qjqw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "spencer741",
                                                                               "createdAt":  "2024-06-27T23:12:18Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "justinpenguin45",
                                                                               "createdAt":  "2024-10-01T14:31:34Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "julealgon",
                                           "body":  "\u003e Now that we have keyed services it\u0027s much easier to build these sorts of systems using the \"any key\" pattern.\r\n\u003e \r\n\u003e ```cs\r\n\u003e builder.Services.AddKeyedTransient\u003cHttpClient\u003e(KeyedService.AnyKey, (IServiceProvider sp, object key) =\u003e\r\n\u003e {\r\n\u003e      // Do something here to get the right http client given the input key. \r\n\u003e });\r\n\u003e ```\r\n\u003e \r\n\u003e This avoids the up-front registration problem that the client factory has today.\r\n\r\nI feel dumb now for not knowing this `AnyKey` even existed! Thanks for sharing that @davidfowl .\r\n\r\nI\u0027ve had scenarios in the past similar to some that were described here, where we would allow API consumers to register HTTP callbacks dynamically with our API to notify them back of some action. Obviously, we\u0027d want for each of those HTTP connections to be managed separately by `IHttpClientFactory` so lifetime was taken care of properly for each of them.\r\n\r\nCan you elaborate how one would use the `AnyKey` approach while still leveraging `IHttpClientFactory` behind the scenes? Would that still allow for changes to an existing `HttpClient` after the initial creation/configuration, or would we need to do some \"versioning in the name\" like what @dazinator proposed a few posts above?",
                                           "updatedAt":  "2024-06-27T14:13:13Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6OOVns",
                                           "createdAt":  "2024-10-01T14:26:13Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEUCn6A==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "abosman",
                                                                               "createdAt":  "2024-10-10T22:37:20Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "TeddyAlbina",
                                                                               "createdAt":  "2025-05-22T05:58:21Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "daiplusplus",
                                                                               "createdAt":  "2025-05-28T04:21:56Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  3
                                                         },
                                           "author":  "justinpenguin45",
                                           "body":  "@davidfowl apologies but can you elaborate on how we would use the keyed approach to solve for HttpClients that depend on request scoped data. In my scenario I need to be able to provide HttpClients with a BaseAddress that is dependent on data that is part of the incoming request (auth token has an organization ID) - we use the organization ID to lookup a base address for the HttpClient. Can what you proposed be used to solve this? This needs to be done at runtime and not at service startup",
                                           "updatedAt":  "2024-10-01T14:26:13Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6s2qrZ",
                                           "createdAt":  "2025-05-22T06:00:22Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "TeddyAlbina",
                                           "body":  "\u003e [@davidfowl](https://github.com/davidfowl) apologies but can you elaborate on how we would use the keyed approach to solve for HttpClients that depend on request scoped data. In my scenario I need to be able to provide HttpClients with a BaseAddress that is dependent on data that is part of the incoming request (auth token has an organization ID) - we use the organization ID to lookup a base address for the HttpClient. Can what you proposed be used to solve this? This needs to be done at runtime and not at service startup\n\nSame for me",
                                           "updatedAt":  "2025-05-22T06:00:22Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6tQznY",
                                           "createdAt":  "2025-05-24T14:33:29Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dazinator",
                                           "body":  "One repeated theme is the need to dynamically establish seperate \"pools\" of http clients at runtime I.e due to different tenants or orgs being onboarded.\n\nFor this case\n1. If the http client is seldomly used, it might be simpler to forgo httpclient factory and just new up a http client and build it manually as needed. Because you have to ask yourself what is the real benefit of maintaining a pool if you use 1 http client every 10 mins.\n\nIf you do really need the pool that http client factor gives then the solution starts becoming less clear but the next step up would be\n\n1. Register a single shared http client factory for it, but don\u0027t set the base url. Set the base url on the http client instance before each usage.\n\n.. because if you set the base url for the http client factory on registration then you can\u0027t change it later. If you don\u0027t set one, you need to set it on each http client instance at the point of usage e.g based on your current tenant or org context or whatever.\n\nThe next problem is - what if you don\u0027t want a single shared pool but you really want a seperate http client factory / pool per base url and this base url is created at runtime or even edited at runtime per tenant.\n\n- This is where you need to currently be creative. I got creative with the options system and using a options name that is dynamically versioned as mentioned above. Not sure if keyed services makes this any easier.\n",
                                           "updatedAt":  "2025-05-24T14:35:07Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6trkez",
                                           "createdAt":  "2025-05-27T20:05:22Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEawP0w==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "julealgon",
                                                                               "createdAt":  "2025-05-28T18:45:02Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "davidfowl",
                                                                               "createdAt":  "2025-05-29T09:04:14Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Flaminel",
                                                                               "createdAt":  "2025-07-16T08:54:10Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  3
                                                         },
                                           "author":  "CarnaViire",
                                           "body":  "Following up on what @dazinator said above.\n\nIt comes down to which group your dynamic change falls into:\n\nA. **Single handler can suffice**:\n\n   * The change either:\n\n     * Still fits the [HTTP connection pool key](https://github.com/dotnet/runtime/blob/b04d40e55b3fcaf74dcf0672a2009ec173bcd002/src/libraries/System.Net.Http/src/System/Net/Http/SocketsHttpHandler/HttpConnectionPoolManager.cs#L520-L558) (e.g. a header change), or\n     * Necessitates a new key (e.g. a different host).\n   * Or, it\u0027s a value periodically refreshed but only one version is valid at a time (e.g. refreshing a certificate from the store on connection creation).\n\nB. **Multiple handlers required**:\n\n   * You need to keep several handlers active at once—e.g. parallel connections to the same host using different certificates/proxies, where the set of configs isn’t known in advance.\n\n### A. Single handler can suffice\n\nThe **\"Single handler\" group** can continue using the same client name, and the dynamic changes there can be applied in a (more or less) proper way.\n\n* Some of them are rather obvious:\n\n   * Set up absolute URIs, headers, etc. on `HttpRequestMessage`\n   * Manually handle cookies\n\n* Others might come as advanced:\n\n   * Refresh a certificate on each connection creation in `SocketsHttpHandler.SslOptions.LocalCertificateSelectionCallback` (https://github.com/dotnet/runtime/issues/52779)\n   * Pass scope-related information through `HttpRequestMessage.Options`, and then use it from a \"stateless\" custom DelegatingHandler (instead of injecting scoped services)\n\n### B. Multiple handlers required\n\nIt\u0027s the **\"Multiple handlers\" group** that\u0027s tricky. It doesn\u0027t fit well with the current HttpClientFactory paradigm, as it requires keeping multiple handler instances inside a single configuration key.\n\nWhen I think about it, I\u0027m considering some kind of a composite key. The second part can be a string, or it can even be an object, similar to the Keyed services keys. And, similar to the Keyed services, \"the old way\" would be equal to having `null` as the second part of the composite key. And all the caches can start using the composite key instead of just the name, and this should mostly be it, the code changes should not be that big.\n\nBut anyway, at this moment it is just an idea, and the issue itself, unfortunately, will have to stay in the backlog for some more time, as we have to prioritize due to high load on the team.\n\nFor the time being, at least there are some (hacky) workarounds that you could try.\n\nI came up with this list earlier this year when suggesting workarounds in #110009, and now I thought it might be useful to share here as well, as I see folks still pinging the issue. The problem being solved here is a dynamic certificate selection based on the data from the incoming request.\n\n---\n\n_Originally posted in https://github.com/dotnet/runtime/issues/110009#issuecomment-2723235824_\n\n## 1. Lazy Init\n\nThe first one is applicable only if all of the configs are the same, with the only difference being the client certificate. The most of the setup is done via ConfigureHttpClientDefault, so any client with an \"unconfigured\" name will just inherit the defaults configuration. It cannot access the client name/user id. Thus, the cert setup is deferred to the first request execution, where the context is passed through the request options.\n\n```csharp\nbuilder.Services.ConfigureHttpClientDefaults(b =\u003e b\n    .UseSocketsHttpHandler((h, services) =\u003e { ... })\n    .AddHttpMessageHandler(() =\u003e new LazyInitHandler()) // Set up lazy client cert init\n    .....\n);\n```\n\n```csharp\nclass LazyInitHandler : DelegatingHandler\n{\n\n    protected override async Task\u003cHttpResponseMessage\u003e SendAsync(HttpRequestMessage request, CancellationToken cancellationToken)\n    {\n        InitializeClientCertificate(request);\n        request.Headers.Add(\"X-HttpClient\", $\"Name={_clientName};Strategy=Lazy Init\");\n\n        return await base.SendAsync(request, cancellationToken);\n    }\n\n    private void InitializeClientCertificate(HttpRequestMessage request)\n    {\n        lock (_lock)\n        {\n            ...\n            InitializeClientCertificate(userContext.UserId, httpContext.RequestServices);\n        }\n    }\n\n    private void InitializeClientCertificate(string userId, IServiceProvider services)\n    {\n        ...\n        primaryHandler.SslOptions.LocalCertificateSelectionCallback =\n            delegate { return certRepo.GetCertificate(userId); };\n    }\n\n    // Traverse the handler chain to reach the primary SocketsHttpHandler\n    private SocketsHttpHandler GetPrimaryHandler() { ... }\n```\n\n## 2. Configure options\n\n - An alternative to Lazy Init\n - Directly edits HttpClientFactoryOptions and HttpMessageHandler builder which is not recommended\n - More configuration freedom as technically almost all config can be done via ConfigureOptions, though I\u0027d consider it an implementation detail\n\n```c#\nbuilder.Services.ConfigureHttpClientDefaults(b =\u003e b\n    .UseSocketsHttpHandler((h, services) =\u003e { ... })\n);\n\nbuilder.Services.ConfigureOptions\u003cClientCertificateConfigurator\u003e();\n```\n\n```c#\n// This is a HACK to get access to the name of the client from the callback\n// See https://github.com/dotnet/runtime/issues/110167\n// NOTE: beyond this specific use case, directly using HttpMessageHandlerBuilder\n// in callbacks is NOT recommended\n\nclass ClientCertificateConfigurator : IConfigureNamedOptions\u003cHttpClientFactoryOptions\u003e\n{\n    public void Configure(string? name, HttpClientFactoryOptions options)\n    {\n        if (name is null)\n        {\n            return;\n        }\n        string userId = name;\n\n        options.HttpMessageHandlerBuilderActions.Add(builder =\u003e\n        {\n            var certRepo = builder.Services.GetRequiredService\u003cICertificateRepository\u003e();\n\n            SocketsHttpHandler primaryHandler = (SocketsHttpHandler)builder.PrimaryHandler;\n\n            primaryHandler.SslOptions.LocalCertificateSelectionCallback =\n                delegate { return certRepo.GetCertificate(userId); };\n        });\n\n        options.HttpClientActions.Add(client =\u003e { ... });\n    }\n\n    public void Configure(HttpClientFactoryOptions options) { }\n}\n```\n\n## 3. Multi-handler\n\nManually maintain a pool of SocketsHttpHandlers incapsulated within a special multi-handler\n\n - Move the cert switch to the inside of the handler chain\n - Can have as many different named configs as you like, since the same handler chain is used for all the certs\n - Need to implement manual caching\n\n```c#\nbuilder.Services.AddHttpClient(\"Multi-Handler\")\n    .ConfigurePrimaryHttpMessageHandler(() =\u003e new MultiHandler(\n        (userId, services) =\u003e\n        {\n            // (1) Configure primary handler\n            var certRepo = services.GetRequiredService\u003cICertificateRepository\u003e();\n            var handler = new SocketsHttpHandler() { ... }\n        },\n        TimeSpan.FromMinutes(2))) \n    .SetHandlerLifetime(Timeout.InfiniteTimeSpan) // Disable handler lifetime management by HttpClientFactory\n```\n\n```c#\n    var factory = services.GetRequiredService\u003cIHttpClientFactory\u003e();\n    return factory.CreateClient(\"Multi-Handler\");\n}\n\n#endregion\n\n#region MultiHandler implementation (Multi-Handler strategy)\n\npartial class MultiHandler(\n    Func\u003cstring, IServiceProvider, SocketsHttpHandler\u003e handlerFactory,\n    TimeSpan handlerLifetime)\n    : HttpMessageHandler\n{\n    private readonly NamedCache\u003cCachedHandler\u003e _handlerCache = new(\n        (name, sp) =\u003e new CachedHandler(handlerFactory(name, sp)),\n        handlerLifetime);\n\n    protected override Task\u003cHttpResponseMessage\u003e SendAsync(HttpRequestMessage request, CancellationToken cancellationToken)\n    {\n        CachedHandler handler = SelectHandler(request);\n        return handler.SendAsyncPublic(request, cancellationToken);\n    }\n\n    private CachedHandler SelectHandler(HttpRequestMessage request)\n    {\n        ...\n        var handler = _handlerCache.GetOrCreate(userContext.UserId, httpContext.RequestServices);\n        return handler;\n    }\n    ...\n}\n\n```\n\nThere is a runnable POC in https://github.com/CarnaViire/ClientCertEcho.\n1. Lazy Init: [Program.LazyInit.cs](https://github.com/CarnaViire/ClientCertEcho/blob/c97f0a41f9f6ccb599ce21fe87beb7693773fd16/ClientCertEchoClient/Program.LazyInit.cs)\n2. Cofigure Options: [Program.ConfigureOptions.cs](https://github.com/CarnaViire/ClientCertEcho/blob/c97f0a41f9f6ccb599ce21fe87beb7693773fd16/ClientCertEchoClient/Program.ConfigureOptions.cs)\n3. Multi-Handler: [Program.MultiHandler.cs](https://github.com/CarnaViire/ClientCertEcho/blob/c97f0a41f9f6ccb599ce21fe87beb7693773fd16/ClientCertEchoClient/Program.MultiHandler.cs)",
                                           "updatedAt":  "2025-05-27T20:05:22Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc64MRSf",
                                           "createdAt":  "2025-07-18T17:49:33Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "srothkin",
                                           "body":  "I have a new use case. We would be creating a bunch of named clients based on configuration from a database. There is a requirement to be able to apply configuration updates without restarting the service. This could include adding new named clients (for new partners) as well changing urls, credentials, or Polly settings (e.g. timeout/retry policies) for existing clients.\n\nOur current code (loading config from appSettings) is using services.AddHttpClient for each named client and then using the resulting builder to add Polly handlers. \n\nI see from the above discussion ideas for how to build a chain of new http message handlers without using the IHttpClientBuilder. But what about the Polly handlers?\n\nIdeally I\u0027d like to be able to call services.AddHttpClient (after service startup has already completed) with a new client name (could be a -v2 suffix to replace a previously configured client name as mentioned above) and use the resulting IHttpClientBuilder to add handlers (including Polly handlers) to that new named client factory. What isn\u0027t clear is if this is supported.",
                                           "updatedAt":  "2025-07-18T17:49:33Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc64NeYV",
                                           "createdAt":  "2025-07-18T19:43:10Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEbRwKQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "CarnaViire",
                                                                               "createdAt":  "2025-07-21T11:18:51Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "julealgon",
                                           "body":  "@srothkin \n\u003e Ideally I\u0027d like to be able to call services.AddHttpClient (after service startup has already completed) ... What isn\u0027t clear is if this is supported.\n\nThis is not supported for sure. You can\u0027t manipulate the container further after it is built. The only way to manage this type of \"dynamic\" instantiation is to have a factory that does it for you, so you really can\u0027t use something like `AddHttpClient` at that point.",
                                           "updatedAt":  "2025-07-18T19:43:10Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc65RC3m",
                                           "createdAt":  "2025-07-23T13:12:39Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "CarnaViire",
                                           "body":  "\u003e But what about the Polly handlers?\n\nIf Polly is the main missing piece, you can create Polly handlers without DI as well: [`ResilienceHandler`](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.http.resilience.resiliencehandler) is publicly available in the `Microsoft.Extensions.Http.Resilience` package. There’s an example in the `HttpClient` docs: [Resilience with static clients](https://learn.microsoft.com/en-us/dotnet/fundamentals/networking/http/httpclient-guidelines#resilience-with-static-clients).\n\nBut when it comes to modifying Named client configurations in general — i.e., reusing the existing configuration extensions like `AddStandardResilienceHandler()` — @julealgon is correct: you cannot use `IHttpClientBuilder` after the service provider is built. Even if you try, none of the extensions will work as expected. All of this is designed to only work during the registration phase; anything beyond that is erroneous.",
                                           "updatedAt":  "2025-07-23T13:12:39Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc66DVu0",
                                           "createdAt":  "2025-07-26T07:21:38Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dazinator",
                                           "body":  "@srothkin \nYou can use this approach:\n1. Use option 2 (the options system is the cleanest imho) although I\u0027d have to check my precise implementation to see if it differs anywhere notable from the one shown\n2. When your http client config is changed, append an incremental version suffix to its name in the database e.g \"myclient-v1\"  --\u003e \"myclient-v2\". This serves as a cache busting key so let\u0027s call it that.\n3. In code when using IHttpClientFactory to get a http client by name - don\u0027t use a constant name.. use its current cache busting key e.g \"myclient-v2\"\n\nYou will find though that when using this approach, most of the options system and http client factor options /builder is set up with non async methods / callback where you actually configure the things like it\u0027s handlers, headers etc etc. Why is this a problem? Because - at the point of setting up the new http client factory options, if all you have is a `name` (in this case the cache busting key being requested) and your config is in a database- its usually desirable to do an Async query to the db to load the required config. However these subsystems don\u0027t give you much if any opportunity for async calls at this stage. Possible solutions?\n\n- the options system is really designed to sit on top of the IConfiguration subsystem and that subsystem is capable of independent reloads (although even there, there is an async reloads issue due to change tokens also not supporting async) but what this means is that, if you integrate your database level config as an IConfigurationProvider into IConfiguration - you can  have that reload from your DB as required and signal its change token whenever the config has changed. When IConfiguration reloads it will then carry your http client information. Then when using gapproach 2 the IConfigureNamedOptions doesn\u0027t need to query the database any more, it can get the config needed to set up the http client from IConfiguration\n\n\nYou can find workarounds for the async problem without integrating with IConfiguration of course. But the full solution would be something like\n\n1. User updates http client config in DB, client name = \"foo\", cache busting key = \"foo-v2\"\n2. Application IConfigurationProvider is sensitive to that and reloads it into IConfiguration e.g at section path \"foo\" overwriting the previous configuration\n3. Your application goes to create a new client and now uses \"foo-v2\" as the latest cache busting key.\n4. This causes http client factory to establish a new pool etc for this new http client name - the options subsystem is asked to configure it - including your named options configuration hook\n5. Your options hook had the name \"foo-v2\". It can inject IConfiguration, strip the v2 suffix from the name and get the config section \"foo\" holding the latest values from your database records thanks to the configuration provider. It can use this to set up http client factory options and builder options to configure the client to spec.",
                                           "updatedAt":  "2025-07-26T07:36:02Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc66DbR4",
                                           "createdAt":  "2025-07-26T07:42:26Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dazinator",
                                           "body":  "Note: Cache busting is a topic here.\n\n1. HttpClientFactory let\u0027s you set up an expiry time for cachebusting sockets, once expired they get removed and then on next request, rebuilt.\n\nHowever expiry time is not the only motivation for cache busting - config changes are also a motivation and this is a gap.\n\nI wonder if the team have thought about adding more flexible cachebusting perhaps using change tokens like other subsystems (file provider watch, config reloads, options etc)\n\nFor example; if we could signal the invalidation of a pool from a change token that could.be configured rather than just an expiry time, then we could hook that signalling into config changes or other custom sources. This would have the effect that\n1. Similar to when handlers are invalidated and are rebuilt on expiry (via options) , the invalidation could now be triggered on config reloads.\n\nThis might be a way to remove the need of incrementing the options name just to force cache busting. Applications could use a single and constant http client name, and cache bust the pool to ensure handlers get built using latest config on the next request.",
                                           "updatedAt":  "2025-07-26T07:47:10Z"
                                       }
                                   ],
                         "totalCount":  44
                     },
        "title":  "Is dynamic IHttpClientFactory registration a bug or a feature?",
        "labels":  [
                       "area-Extensions-HttpClientFactory"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/1384",
        "createdAt":  "2020-01-07T22:47:12Z",
        "number":  1384,
        "author":  "dotMorten",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHODChU6g==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "samsosa",
                                            "createdAt":  "2020-01-29T09:19:05Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "ebashmakov",
                                            "createdAt":  "2020-04-11T03:43:05Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "johnkors",
                                            "createdAt":  "2020-09-30T11:57:40Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Daniel-Svensson",
                                            "createdAt":  "2021-06-05T13:49:25Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "kevinbourassahoule",
                                            "createdAt":  "2022-08-02T16:36:23Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "mstefarov",
                                            "createdAt":  "2022-09-29T19:04:48Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "glen-84",
                                            "createdAt":  "2023-05-03T12:24:33Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "xela30",
                                            "createdAt":  "2023-05-23T14:09:58Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "loraderon",
                                            "createdAt":  "2023-08-22T07:00:15Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "DillonN",
                                            "createdAt":  "2024-01-03T23:34:33Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "brantburnett",
                                            "createdAt":  "2024-10-27T12:47:59Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "sliekens",
                                            "createdAt":  "2024-10-30T00:06:23Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "WeihanLi",
                                            "createdAt":  "2025-05-19T07:24:16Z"
                                        }
                                    ],
                          "totalCount":  13
                      },
        "updatedAt":  "2024-11-05T10:00:43Z",
        "body":  "In .NET Framework it was possible to specify that web requests should use the shared browser cache by setting:\r\n`myWebRequestHandler.CachePolicy = new System.Net.Cache.RequestCachePolicy(System.Net.Cache.RequestCacheLevel.Default);`\r\n\r\nThis allows repeated web requests to either be pulled from the local browser cache (if not expired) or do much faster ETag 304 requests/response. This is really really useful for client apps that frequently check for status updates in a resource, image tile requests etc, and can reduce the network overhead tremendously.\r\n\r\nFor example I made a (very) quick and dirty cache implementation showing a 33x perf increase on repeated requests when implementing cache-control max-age and/or etag:\r\n\r\n|                Method |      Mean |     Error |    StdDev |    Median | Ratio | Gen 0 | Gen 1 | Gen 2 | Allocated |\r\n|---------------------- |----------:|----------:|----------:|----------:|------:|------:|------:|------:|----------:|\r\n| UseSocketsHttpHandler | 48.710 ms | 0.4979 ms | 0.4414 ms | 48.694 ms |  1.00 |     - |     - |     - | 243.08 KB |\r\n|  UseHttpClientHandler | 47.781 ms | 0.5331 ms | 0.4451 ms | 47.884 ms |  0.98 |     - |     - |     - | 242.25 KB |\r\n|   UseCacheHttpHandler |  1.252 ms | 0.0665 ms | 0.1907 ms |  1.199 ms |  0.03 |     - |     - |     - | 247.48 KB |\r\n\r\nTest was done on an above-average high-speed internet connection. Effect would of course be A LOT bigger on slower networks.\r\n\r\nHowever building a proper caching mechanism that deals with shared vs private cache, cache expiration, pruning (when it grows too large), lock contention for parallel requests, re-using the shared OS browser cache (like what wininet offers), etc is no trivial task. And even so, not having this at a platform level means there\u0027s no way to make caching possible with 3rd party libraries, because it currently has to be done manually at a very low level of the request.\r\n\r\n/CC @karelz ",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOkcPVAA==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU3NDM5Mzc0NA==",
                                           "createdAt":  "2020-01-14T21:58:51Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "karelz",
                                           "body":  "@dotMorten given that we do not have any tight integration with wininet in SocketsHttpHandler, there is no benefit to have it in the platform. 3rd party library will have same chance to implement it as us.\r\nGiven that there is ton of policy around caching (e.g. store it on file system, or in memory, how much?), we do not think it should be part of SocketsHttpHandler inbox.\r\n\r\nAs such, I recommend to close the issue as Won\u0027t Fix. What do you think?",
                                           "updatedAt":  "2020-01-14T21:58:51Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU3NDM5OTA0Mw==",
                                           "createdAt":  "2020-01-14T22:12:52Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOD5-o7A==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "samsosa",
                                                                               "createdAt":  "2020-01-29T09:18:49Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "SteveDunn",
                                                                               "createdAt":  "2021-09-14T08:28:11Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "sliekens",
                                                                               "createdAt":  "2024-11-08T08:41:23Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  3
                                                         },
                                           "author":  "dotMorten",
                                           "body":  "You know what I would think :-) Caching is an integral part of client apps - it needs an OOB option. We have it in .NET Framework, and we have it in UWP for good reasons. We don\u0027t however have it anywhere in .NET Core.\r\n\r\nFirst of all, I don\u0027t think it\u0027s fair putting this on anyone to build themselves. I\u0027ve only just completed building something that is only just good enough for my specific use-case, and it was a significant amount of work.\r\n\r\n\u003e  3rd party library will have same chance to implement it as us.\r\n\r\nI don\u0027t see how? There are no common extensibility points that a 3rd party library can use that would turn it on for all dependencies. You\u0027d have to build your own handler (or delegate handler around the sockets handler).\r\n\r\n\u003e Given that there is ton of policy around caching\r\n\r\nI\u0027ve been through the RFCs around this a lot lately, and there\u0027s not a ton. It\u0027s actually a quite short list. See https://tools.ietf.org/html/rfc7234#section-3\r\n```\r\n A cache MUST NOT store a response to any request, unless:\r\n\r\n   o  The request method is understood by the cache and defined as being\r\n      cacheable, and\r\n\r\n   o  the response status code is understood by the cache, and\r\n\r\n   o  the \"no-store\" cache directive (see Section 5.2) does not appear\r\n      in request or response header fields, and\r\n\r\n   o  the \"private\" response directive (see Section 5.2.2.6) does not\r\n      appear in the response, if the cache is shared, and\r\n\r\n   o  the Authorization header field (see Section 4.2 of [RFC7235]) does\r\n      not appear in the request, if the cache is shared, unless the\r\n      response explicitly allows it (see Section 3.2), and\r\n\r\n   o  the response either:\r\n\r\n      *  contains an Expires header field (see Section 5.3), or\r\n\r\n      *  contains a max-age response directive (see Section 5.2.2.8), or\r\n\r\n      *  contains a s-maxage response directive (see Section 5.2.2.9)\r\n         and the cache is shared, or\r\n\r\n      *  contains a Cache Control Extension (see Section 5.2.3) that\r\n         allows it to be cached, or\r\n\r\n      *  has a status code that is defined as cacheable by default (see\r\n         Section 4.2.2), or\r\n```\r\nOr to put it more simple: It basically says to only cache `GET`/`HEAD` and only if there\u0027s no `Authorization`* header, it doesn\u0027t specify `NoStore` or `Private`*, there\u0027s an etag or expiration and you get a `200 OK`.\r\n\r\nSecond, it should of course be opt-in, and not on by default (just like it is on netfx).\r\n\r\n* You could store Auth and Private, but the simplest / safest solution is just to no do that, which is also how NETFX behaves.",
                                           "updatedAt":  "2020-01-14T22:12:52Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDU4ODM5MTk5Ng==",
                                           "createdAt":  "2020-02-19T19:04:30Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "thargol1",
                                           "body":  "Perhaps caching can be implemented as on opt in on `HttpClientFactory`?\r\n\r\nSome like this in startup.cs\r\n```csharp\r\nservices.AddHttpClient().AddCacheHandler(options =\u003e\r\n{\r\n     // what ever you guys come up with, but maybe someway to inject an IMemoryCache here\r\n});\r\n```\r\nYou can than use the cache handler when it\u0027s allowed to do, as specified by the cache-headers of the returning response, or leave it up to the programmer.",
                                           "updatedAt":  "2020-02-19T19:04:30Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDYwNDUzMTAzMQ==",
                                           "createdAt":  "2020-03-26T16:28:55Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOA_QasQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "dotMorten",
                                                                               "createdAt":  "2020-03-26T16:51:15Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "karelz",
                                           "body":  "Triage: We believe this kind of opinionated policy (esp. potential wininet integration) does not belong into vanila `HttpClient`, but it makes sense to keep it in `HttpClientFactory`.",
                                           "updatedAt":  "2020-03-26T16:28:55Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDY5ODM3NTUwMw==",
                                           "createdAt":  "2020-09-24T14:19:12Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/ncl\nSee info in area-owners.md if you want to be subscribed.",
                                           "updatedAt":  "2020-09-24T14:19:12Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDcwMTM0NDk1Mw==",
                                           "createdAt":  "2020-09-30T12:00:23Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCgM5QA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Daniel-Svensson",
                                                                               "createdAt":  "2021-06-05T13:50:58Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "TWhidden",
                                                                               "createdAt":  "2022-06-03T21:44:32Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "johnkors",
                                           "body":  "\u003eIt basically says to only cache GET/HEAD and only if there\u0027s no Authorization* header, it doesn\u0027t specify NoStore or Private*, there\u0027s an etag or expiration and you get a 200 OK.\r\n\r\nI have an odd scenario where I\u0027d like caching even though a _Authorization_ header is present, so please make it configurable if you\u0027re considering implementing the rules mentioned by @dotMorten . I don\u0027t mind sensible defaults, as long as it\u0027s allowing for configuration.",
                                           "updatedAt":  "2020-09-30T12:00:23Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg3MzU5NjYyMA==",
                                           "createdAt":  "2021-07-04T13:58:52Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "sliekens",
                                           "body":  "I believe this should be in SocketsHttpHandler because the handler can mutate message headers that participate in cache keys.\r\n\r\nE.g. AutomaticDecompression\r\n\r\n``` csharp\r\nservices.AddHttpClient(\"demo\")\r\n    .ConfigurePrimaryHttpMessageHandler(() =\u003e new SocketsHttpHandler\r\n    {\r\n        AutomaticDecompression = DecompressionMethods.GZip\r\n    });\r\n```\r\n\r\nA side-effect of this configuration is that all requests are sent with `Accept-Encoding: gzip`, but that is not observable in a `DelegatingHandler` _before_ sending the request. A well-behaved server will respond with `Vary: Accept-Encoding` but again there is no way to check it when deciding whether to use a cached response.\r\n\r\nYou could argue that I can just ignore the `Vary: Accept-Encoding` because automatic decompression takes care of decoding the stream... but that\u0027s probably a sin against rfc7234 and I\u0027d prefer caching the gzipped content anyway.\r\n\r\nThis is just one example, I think `PreAuthenticate` and `AllowAutoRedirect` have similar problems. It seems to me that if you want to roll your own caching handler, you also have to reinvent automatic decompression, pre-authenticating and auto-redirects.\r\n\r\nFWIW I don\u0027t think tight platform integration is valuable. I\u0027d rather bring my own storage mechanism.\r\n\r\n``` csharp\r\nservices.AddHttpClient(\"demo\")\r\n    .ConfigurePrimaryHttpMessageHandler(() =\u003e new SocketsHttpHandler\r\n    {\r\n        UseResponseCache = true | false,\r\n        ResponseCache = (System.Net.Http.IResponseCache)userProvided,\r\n\r\n        // Cache compressed responses to make economic use of storage space, but decompress automatically\r\n        AutomaticDecompression = DecompressionMethods.GZip,\r\n\r\n        // Cache 3xx redirects (with respect to Expires and Cache-Control headers)\r\n        AllowAutoRedirect = true,\r\n\r\n        // Don\u0027t cache authenticated responses if the cache is shared, unless the response explicitly allows it\r\n        PreAuthenticate = true\r\n    });\r\n```",
                                           "updatedAt":  "2021-07-04T14:35:35Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg3MzYwODI3MA==",
                                           "createdAt":  "2021-07-04T15:05:57Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotMorten",
                                           "body":  "@StevenLiekens I implemented my own caching at this level as well, and didn\u0027t worry too much about the gzip - I don\u0027t see how that really changes the cache expiration, etags etc. You\u0027d get the same thing in the end anyway. Can you clarify what I\u0027m missing?",
                                           "updatedAt":  "2021-07-04T15:06:23Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg3MzYxMTUwMQ==",
                                           "createdAt":  "2021-07-04T15:26:00Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "sliekens",
                                           "body":  "I would just not recommend caching a projection of what is actually returned by the server, especially when the request is mutated between a cache miss and sending it to the server. I think my case is clearer for the PreAuthenticate feature.\r\n\r\n/edit \r\n\r\n\u003e  I implemented my own caching at this level as well, and didn\u0027t worry too much about the gzip - I don\u0027t see how that really changes the cache expiration, etags etc.\r\n\r\nHow do you deal with `Vary: Accept-Encoding`? Here is my problem step by step:\r\n\r\n1. Before sending the initial request, `Accept-Encoding` is missing\r\n2. After sending the initial request, `Accept-Encoding` is `gzip`\r\n    - This is because SocketsHttpHandler mutates your request object\r\n3. The initial response contains `Vary: Accept-Encoding`\r\n4. A cache entry is created with the `RequestUri` as the primary cache key and `Accept-Encoding: gzip` as the secondary cache key\r\n5. Subsequent requests will always be a cache miss because the `Accept-Encoding` header is **not** set when the cache is checked\r\n\r\nAs far as I\u0027m aware, you can only make this work if you disregard `Vary` which is obviously bad and possibly a violation of the RFC.",
                                           "updatedAt":  "2021-07-05T19:37:52Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg3NTA0ODAyOQ==",
                                           "createdAt":  "2021-07-06T20:08:52Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOB6OGrQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "dotMorten",
                                                                               "createdAt":  "2021-07-06T20:09:47Z"
                                                                           },
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "SteveDunn",
                                                                               "createdAt":  "2021-09-14T09:36:45Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "sliekens",
                                           "body":  "In other words\r\n\r\n![image](https://user-images.githubusercontent.com/1583241/124660594-b35bb000-dea6-11eb-96b6-546fa4b19f5d.png)\r\n",
                                           "updatedAt":  "2021-07-06T20:08:52Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc42xp9m",
                                           "createdAt":  "2021-09-14T09:38:31Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "SteveDunn",
                                           "body":  "Has there been any traction on this?  Is CacheCow still the way to go currently?",
                                           "updatedAt":  "2021-09-14T09:38:31Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc42zS84",
                                           "createdAt":  "2021-09-14T18:38:31Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "sliekens",
                                           "body":  "There is still a gap that needs to be filled. CacheCow isn\u0027t for everyone, it\u0027s most useful when you control both the client and the server.  I did a diagonal scan of the code and it doesn\u0027t seem to implement all the nitty gritty details of RFC 7234.\r\n\r\nI wish MS would come forward with a WebCacheHandler  with pluggable storage (DistributedCache?) that implements the full RFC. They already implemented RFC 7230-7233 so why stop at 7234?",
                                           "updatedAt":  "2021-09-14T18:47:39Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc42zkzf",
                                           "createdAt":  "2021-09-14T20:29:14Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "SteveDunn",
                                           "body":  "@StevenLiekens - that\u0027s a shame.  This stuff is certainly a lot more dificcult since .NET Core / 5.  ",
                                           "updatedAt":  "2021-09-14T20:29:14Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc420vj_",
                                           "createdAt":  "2021-09-15T08:07:47Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODEXXzw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "dotMorten",
                                                                               "createdAt":  "2021-09-15T15:47:01Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "loraderon",
                                                                               "createdAt":  "2023-08-22T06:58:24Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "sliekens",
                                           "body":  "FWIW I\u0027m now doing the same thing as Morten, writing my own cache [handler](https://github.com/StevenLiekens/gw2sdk/blob/ad310e5b98d4db12229f831144617edeb6c4aeab/GW2SDK/Http/Caching/CachingHttpHandler.cs). It\u0027s feasible for me because I\u0027m doing this outside of normal work hours for a pet project... but you can\u0027t honestly expect someone to implement the entire web caching [draft](https://httpwg.org/specs/rfc7234.html) as part of their job building ecommerce apps.\r\n\r\nI somewhat agree with Karel that storage policies shouldn\u0027t become a concern for the SocketsHttpHandler, but then neither is automatic decompression (content negotiation), automatic preauthentication and automatic following redirects. I suspect these things carried over from old HttpClientHandler code, but now they are just in my way. My handler only works reliably when you disable all of these features.\r\n\r\nLong story short, I think caching behavior should be a core feature, whether it is integrated in SocketsHttpHandler or implemented as a stand-alone handler. It doesn\u0027t have to be opinionated code. Storage APIs can be injected through DI with HttpClientFactory. Storage policies can be implemented in user code if the caching handler raises an event whenever it makes a decision about a request (`RequestForwarded` / `ResponseReused` / `ResponseValidated`).",
                                           "updatedAt":  "2021-09-15T11:51:25Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc4246QF",
                                           "createdAt":  "2021-09-16T13:12:07Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODytHUQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "CarnaViire",
                                                                               "createdAt":  "2021-09-16T13:51:11Z"
                                                                           },
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "sliekens",
                                                                               "createdAt":  "2021-09-16T15:01:42Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "mstefarov",
                                                                               "createdAt":  "2024-09-18T17:37:59Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  3
                                                         },
                                           "author":  "geoffkizer",
                                           "body":  "\u003e I somewhat agree with Karel that storage policies shouldn\u0027t become a concern for the SocketsHttpHandler, but then neither is automatic decompression (content negotiation), automatic preauthentication and automatic following redirects. I suspect these things carried over from old HttpClientHandler code, but now they are just in my way. My handler only works reliably when you disable all of these features.\r\n\r\nThis is an interesting point, and worth considering on its own, regardless of whether we end up building caching into SocketsHttpHandler or not.\r\n\r\nCompression, authentication, redirect handling, and caching are all capabilities that logically are layered on top of the core protocol handling. And there are other capabilities too that you could imagine being layered in similar ways, such as retry policy, routing, load balancing, etc.\r\n\r\nBut to work properly, these capabilities typically need to be ordered properly. For example, just focusing on the capabilities built in to SocketsHttpHandler: Redirect handling is logically layered \"above\" authentication, because a redirect can change the target server and thus change how authentication should be performed.\r\n\r\nWe have currently built a set of capabilities into SocketsHttpHandler (decompression, authentication, redirects, cookie handling) and we execute them in the appropriate order for this set of capabilities. And in fact, most of these are implemented similar to a delegating handler internally, though they are not exposed publicly as such.\r\n\r\nWhat we don\u0027t allow you to do is insert your own delegating handler *between* the built-in layered capabilities like decompression, redirect handling, etc. The result is that if you want to implement other layered capabilities, like caching, you may have to entirely forgo the built-in capabilities in order to get an ordering that isn\u0027t broken. And if you want to replace one of the built-in capabilities with your own custom logic -- e.g. control redirect handling or provide your own authentication -- you are similarly impacted.\r\n\r\nLong term we should consider breaking these layered capabilities out into separate delegating handlers so that they can be reused in situations like this.",
                                           "updatedAt":  "2021-09-16T13:12:07Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5cAQJp",
                                           "createdAt":  "2023-05-11T08:32:16Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jacobmohl",
                                           "body":  "Just to chime in on this aswell. It should be in the ASP.Net or .Net package in some way, Either a middleware in ASP.Net or a configurable part of HttpClient(Factory).\r\n\r\nIts a standard with (RFC) so there should not be that much to discus beside storage mechanism.",
                                           "updatedAt":  "2023-05-11T08:32:16Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5cB_uM",
                                           "createdAt":  "2023-05-11T13:44:48Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOD4PeIw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "chrisoverzero",
                                                                               "createdAt":  "2023-05-11T13:57:31Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "sliekens",
                                                                               "createdAt":  "2023-05-11T14:44:07Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "xela30",
                                                                               "createdAt":  "2023-05-22T13:43:03Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "loraderon",
                                                                               "createdAt":  "2023-08-22T07:01:11Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "mstefarov",
                                                                               "createdAt":  "2024-09-18T17:38:12Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "brantburnett",
                                                                               "createdAt":  "2024-10-27T12:53:18Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  6
                                                         },
                                           "author":  "dotMorten",
                                           "body":  "I definitely don’t think it should be in ASP.NET. The biggest use for this would be client applications. Anything .NET could use this, so just .NET is fine.",
                                           "updatedAt":  "2023-05-11T16:13:23Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5cC8YF",
                                           "createdAt":  "2023-05-11T16:08:40Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jacobmohl",
                                           "body":  "As backends for frontends become more and more relevant with SPAs I will also categorize ASP.Net as a client framework (and especially if you use Blazor). ",
                                           "updatedAt":  "2023-05-11T16:08:40Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6Rb7uu",
                                           "createdAt":  "2024-10-27T13:15:35Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "brantburnett",
                                           "body":  "I recognize that caching is complicated, and implementing it is a big ask. That said, I think one of the key takeaways from this thread is that it currently isn\u0027t possible to effectively implement caching in `HttpClient`, at least not without rewriting a whole mass of unrelated code or accepting some odd limitations. This means that even if I wanted to create a NuGet package that extends `HttpClient` with caching, it would be, at best, a mess.\n\nCould we not consider a more manageable middle road? Instead of implementing a complete caching option in .NET, provide an extension point where a cache may be plugged into SocketsHttpHandler at the correct point in the stack (I\u0027d assume after all other \"middleware\" like decompression, redirect, etc). This way 3rd-party authors could implement caching (hopefully as an open-source NuGet for everyone to use). And if the .NET team ever decides to in-box a caching solution it would just be an in-box implementation to plugin to the extension point.\n\nPossible APIs could look something like this:\n\n```c#\nnamespace System.Net.Http;\n\n// The next parameter is the method to forward the request to on cache miss or refresh, potentially modified with `If-Modified-Since`, etc.\npublic delegate ValueTask\u003cHttpResponseMessage\u003e HttpCacheHandler(\n    HttpRequestMessage request, \n    Func\u003cHttpRequestMessage, CancellationToken, Task\u003cHttpResponseMessage\u003e\u003e next, \n    CancellationToken cancellationToken);\n\npublic partial class SocketsHttpHandler\n{\n    public HttpCacheHandler? Cache { get; set; }\n}\n```\n\nOr:\n\n```c#\nnamespace System.Net.Http;\n\npublic interface IHttpClientCache\n{\n    // The next parameter is the method to forward the request to on cache miss or refresh, potentially modified with `If-Modified-Since`, etc.\n    ValueTask\u003cHttpResponseMessage\u003e GetOrSendAsync(\n        HttpRequestMessage request, \n        Func\u003cHttpRequestMessage, CancellationToken, Task\u003cHttpResponseMessage\u003e\u003e next, \n        CancellationToken cancellationToken);\n\n    // Other members here, perhaps Clear or a simple TryGet that doesn\u0027t forward\n}\n\npublic partial class SocketsHttpHandler\n{\n    public IHttpClientCache? Cache { get; set; }\n}\n```",
                                           "updatedAt":  "2024-10-27T13:15:35Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6RcAlN",
                                           "createdAt":  "2024-10-27T14:08:45Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotMorten",
                                           "body":  "@brantburnett I\u0027m not sure why you say it can\u0027t be implemented today. We did it. You just need to overwrite sendasync. \nHowever the main problem with both your suggestion and our solution is it only works for the one 3rd party library that chose to do this. There\u0027s no way to have an entire app and all it\u0027s libraries to all get caching enabled together.\nAlso I wouldn\u0027t want it limited to just socketshttphandler since several other handlers in the ecosystem lack caching as well.\n\nBut if there\u0027s anything implementing caching has taught me it\u0027s that it is hard and error prone and took us quite a few releases before we got it completely right ",
                                           "updatedAt":  "2024-10-27T14:11:43Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6RcPYo",
                                           "createdAt":  "2024-10-27T17:00:15Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "brantburnett",
                                           "body":  "\u003e I\u0027m not sure why you say it can\u0027t be implemented today. We did it. You just need to overwrite sendasync.\n\nI would disagree with this statement (in part). I agree it is possible to implement a caching layer. However, I don\u0027t believe it is possible to *generically* implement an RFC-compliant caching layer that correctly handles `Accept-Encoding` and caches redirects, etc,  without making some significant compromises. \n\nA non-compliant caching layer is primarily useful for cases where you control the server and are therefore certain it will only implement certain patterns. To create a reusable NuGet package (which I\u0027d like to do) that is RFC-compliant and broadly compatible I would probably do something like this today:\n\n1. Implement as a `DelegatingHandler`\n2. Not cache redirects\n3. Instruct the consumer to never enable `AutomaticDecompression` on `SocketsHttpHandler` or `HttpClientHandler`\n4. Either not support automatic decompression at all (bad for perf), or reimplement automatic decompression in the caching handler (bloat and lots of room for bugs and performance missteps)\n\nFor a generic NuGet package, number 3 is especially problematic since it represents a \"pit of failure\" for the consumer. I\u0027d much prefer something that offers a \"pit of success\".\n\nI believe the only way to implement a consistent, easy-to-consume, generic, and RFC-compliant caching layer is to insert it here between the `DiagnosticsHandler` and the `RedirectHandler` as a `HttpMessageHandlerStage`, which is currently internal: https://github.com/dotnet/runtime/blob/2c471afb09122433dc8137a9827e47ff8cedd6ff/src/libraries/System.Net.Http/src/System/Net/Http/SocketsHttpHandler/SocketsHttpHandler.cs#L538-L560\n\nMy proposals above are simply ways to plug into the stack at that point without exposing too many internals.",
                                           "updatedAt":  "2024-10-27T17:00:15Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6RcXe_",
                                           "createdAt":  "2024-10-27T18:42:16Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotMorten",
                                           "body":  "We support all those things. Granted it took many releases to get completely right and handle all edge cases and ensure signed in users won\u0027t share cache with other users etc. Not something the average developer has the time and resources to do and why I logged this issue in the first place (in addition to getting a way that will affect all handler instances). Wish we could open-source the bits but it was a significant investment for us and a compete feature so doubt we\u0027ll be able to. I don\u0027t get your step 3 and 4. The cache doesn\u0027t need to be compressed. In fact that just means you\u0027ll be wasting time decompressing each time. The disk space savings just isn\u0027t worth it.",
                                           "updatedAt":  "2024-10-27T18:42:16Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6RccPq",
                                           "createdAt":  "2024-10-27T19:46:26Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "brantburnett",
                                           "body":  "\u003e I don\u0027t get your step 3 and 4. The cache doesn\u0027t need to be compressed. In fact that just means you\u0027ll be wasting time decompressing each time. The disk space savings just isn\u0027t worth it.\n\nSee the explanation above for varying caching by `Accept-Encoding`: https://github.com/dotnet/runtime/issues/1384#issuecomment-873611501\n\nNot varying based on the encoding requested could cause misbehavior per the RFC. In theory, a well-behaved server would always serve the same response with different compression, but that may not be the case. So a properly implemented cache should cache the compressed variant and follow the returned `Vary` header to vary the cache based on request headers such as `Accept-Encoding`. A generic, reusable implementation should avoid such pitfalls.\n\nAdditionally, you\u0027re assuming that the cache is on disk. Implementations may prefer to cache in memory and the reduced memory utilization may be worthwhile. Or, the consumer may prefer a distributed cache such as Redis or Couchbase, where network latency is a factor and smaller compressed packets are advantageous. Even on disk, depending on disk I/O speed, available CPU cycles, and compression ratio, decompressing each time may provide more throughput in some cases.\n\n\n\n",
                                           "updatedAt":  "2024-10-27T19:46:26Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6RuILd",
                                           "createdAt":  "2024-10-29T16:33:02Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotMorten",
                                           "body":  "You can still handle the vary-by headers even if you uncompress it. If I were to query the same endpoint with two different encodings, and the server says the response varies by encoding, then they would be two separate cache entries.",
                                           "updatedAt":  "2024-10-29T16:33:02Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6Rwnf7",
                                           "createdAt":  "2024-10-29T22:26:52Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "sliekens",
                                           "body":  "I abandoned my caching side-quest because I feel uncomfortable caching a projection of the response,\nrather than the actual response. It doesn\u0027t sit right with me that when the requester does `Accept-Encoding: gzip`,\nthe cache might reply with a compressed response, OR an already-decoded response, depending on the\n`AutomaticDecompression` setting of the client that created the cache entry. This might not even work between \ndifferent instances of `HttpClient` that share a cache, but have different settings for `AutomaticDecompression`.\n\nWhen the cache is populated with a compressed response by a client with\n`SocketsHttpHandler.AutomaticDecompression = DecompressionMethods.None` but which\nmanually sets `Accept-Encoding: gzip`, then other HttpClients with\n`SocketsHttpHandler.AutomaticDecompression = DecompressionMethods.GZip` may still receive\nthe compressed response, since the layering of the caching and decompression behaviors is\nnot in the correct order.\n\n I suspect the same problems exist with `AllowAutoRedirect` and `PreAuthenticate`.\n\n/edit: fixed mistakes\n\n(Granted, if you manually set `Accept-Encoding` then you should also manually check `Content-Encoding` of\nthe response, but the point is that the `AutomaticDecompression` feature stops working as advertised.)\n\nAlso, as I previously mentioned in https://github.com/dotnet/runtime/issues/1384#issuecomment-873611501, with `AutomaticDecompression = DecompressionMethods.GZip`,\nthe  `Accept-Encoding: gzip` header is added to your existing `HttpRequestMessage.Headers` instance by the\n`SocketsHttpHandler`. If you then derive the cache key from the mutated headers, the response will be\ncached with `Vary` headers that don\u0027t match what you originally requested. So, again, the incorrect layering\nof behaviors will bite you. @dotMorten do you use the automatic decompression features? I\u0027d be quite surprised\nif you are not already handling it in a special way, and it still works.",
                                           "updatedAt":  "2024-10-29T23:30:26Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6Rw9UA",
                                           "createdAt":  "2024-10-29T23:53:21Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "sliekens",
                                           "body":  "Code to demonstrate the above: https://dotnetfiddle.net/bEsTW1\n\n```csharp\nvar http = new HttpClient(new SocketsHttpHandler { AutomaticDecompression = System.Net.DecompressionMethods.GZip });\n\nvar request = new HttpRequestMessage(HttpMethod.Get, \"https://github.com/dotnet/runtime/issues/1384\");\n\nConsole.WriteLine(\"Request before sending (this is what you use to search your cache):\\n\");\nLogRequestMessage(request);\n\nusing var response = http.Send(request);\n\nConsole.WriteLine(\"Request after sending (this is what you use to populate your cache, taking Vary from the response into account):\\n\");\nLogRequestMessage(request);\n\nConsole.WriteLine(\"Response from server:\\n\");\nLogResponseMessage(response);\n```\n\nOutput:\n\n```text\nRequest before sending (this is what you use to search your cache):\n\n    GET https://github.com/dotnet/runtime/issues/1384 HTTP/1.1\n\nRequest after sending (this is what you use to populate your cache, taking Vary from the response into account):\n\n    GET https://github.com/dotnet/runtime/issues/1384 HTTP/1.1\n    Accept-Encoding: gzip\n\nResponse from server:\n\n    HTTP/1.1 200 OK\n    Server: GitHub.com\n    Date: Wed, 30 Oct 2024 00:20:11 GMT\n    Cache-Control: must-revalidate, max-age=0, private\n    Content-Security-Policy: default-src \u0027none\u0027; base-uri \u0027self\u0027; child-src github.com/assets-cdn/worker/ github.com/webpack/ github.com/assets/ gist.github.com/assets-cdn/worker/; connect-src \u0027self\u0027 uploads.github.com www.githubstatus.com collector.github.com raw.githubusercontent.com api.github.com github-cloud.s3.amazonaws.com github-production-repository-file-5c1aeb.s3.amazonaws.com github-production-upload-manifest-file-7fdce7.s3.amazonaws.com github-production-user-asset-6210df.s3.amazonaws.com *.rel.tunnels.api.visualstudio.com wss://*.rel.tunnels.api.visualstudio.com objects-origin.githubusercontent.com copilot-proxy.githubusercontent.com proxy.individual.githubcopilot.com proxy.business.githubcopilot.com proxy.enterprise.githubcopilot.com *.actions.githubusercontent.com wss://*.actions.githubusercontent.com productionresultssa0.blob.core.windows.net/ productionresultssa1.blob.core.windows.net/ productionresultssa2.blob.core.windows.net/ productionresultssa3.blob.core.windows.net/ productionresultssa4.blob.core.windows.net/ productionresultssa5.blob.core.windows.net/ productionresultssa6.blob.core.windows.net/ productionresultssa7.blob.core.windows.net/ productionresultssa8.blob.core.windows.net/ productionresultssa9.blob.core.windows.net/ productionresultssa10.blob.core.windows.net/ productionresultssa11.blob.core.windows.net/ productionresultssa12.blob.core.windows.net/ productionresultssa13.blob.core.windows.net/ productionresultssa14.blob.core.windows.net/ productionresultssa15.blob.core.windows.net/ productionresultssa16.blob.core.windows.net/ productionresultssa17.blob.core.windows.net/ productionresultssa18.blob.core.windows.net/ productionresultssa19.blob.core.windows.net/ github-production-repository-image-32fea6.s3.amazonaws.com github-production-release-asset-2e65be.s3.amazonaws.com insights.github.com wss://alive.github.com api.githubcopilot.com api.individual.githubcopilot.com api.business.githubcopilot.com api.enterprise.githubcopilot.com; font-src github.githubassets.com; form-action \u0027self\u0027 github.com gist.github.com copilot-workspace.githubnext.com objects-origin.githubusercontent.com; frame-ancestors \u0027none\u0027; frame-src viewscreen.githubusercontent.com notebooks.githubusercontent.com; img-src \u0027self\u0027 data: blob: github.githubassets.com media.githubusercontent.com camo.githubusercontent.com identicons.github.com avatars.githubusercontent.com private-avatars.githubusercontent.com github-cloud.s3.amazonaws.com objects.githubusercontent.com secured-user-images.githubusercontent.com/ user-images.githubusercontent.com/ private-user-images.githubusercontent.com opengraph.githubassets.com github-production-user-asset-6210df.s3.amazonaws.com customer-stories-feed.github.com spotlights-feed.github.com objects-origin.githubusercontent.com *.githubusercontent.com; manifest-src \u0027self\u0027; media-src github.com user-images.githubusercontent.com/ secured-user-images.githubusercontent.com/ private-user-images.githubusercontent.com github-production-user-asset-6210df.s3.amazonaws.com gist.github.com; script-src github.githubassets.com; style-src \u0027unsafe-inline\u0027 github.githubassets.com; upgrade-insecure-requests; worker-src github.com/assets-cdn/worker/ github.com/webpack/ github.com/assets/ gist.github.com/assets-cdn/worker/\n    Link: \u003c/_graphql?body=%7B%22query%22%3A%22bc81d213bef33096858522d757775720%22%2C%22variables%22%3A%7B%22markAsRead%22%3Atrue%2C%22number%22%3A1384%2C%22owner%22%3A%22dotnet%22%2C%22repo%22%3A%22runtime%22%2C%22useNewTimeline%22%3Afalse%7D%7D\u003e; rel=preload; as=fetch; crossorigin=use-credentials\n    Referrer-Policy: no-referrer-when-downgrade\n    Server-Timing: issue_layout-fragment;desc=\"issue_layout fragment\";dur=180.240093,issue_conversation_content-fragment;desc=\"issue_conversation_content fragment\";dur=631.753243,issue_conversation_sidebar-fragment;desc=\"issue_conversation_sidebar fragment\";dur=62.490997,nginx;desc=\"NGINX\";dur=0.871465,glb;desc=\"GLB\";dur=29.714529\n    Strict-Transport-Security: max-age=31536000; includeSubdomains; preload\n    Vary: X-PJAX, X-PJAX-Container, Turbo-Visit, Turbo-Frame, Accept, Accept-Encoding, Accept, X-Requested-With\n    X-Content-Type-Options: nosniff\n    X-Frame-Options: deny\n    x-voltron-version: 69a2227\n    X-XSS-Protection: 0\n    Set-Cookie: _gh_sess=nOQFOVUEPCfb02qenaN2yaXLKkb4wBVJiPz8TXnw%2Fji4z3Q2IIu6FnD9u0McPMqsjktxsOtryUO9291CjGLNzDBfcL1MqbRLqEa0sRfLbFEhCQeYV4dw%2BsHT5nBLSzRlmeeSroIRgP85dvg4gvXlEmawlznzhNrSRv6iwD0aYCDYigtWU62voTVRNPk27kbvMusM6VXNRPen3UAgh2TGaYmvvUduKAEjjxmJ367r1cTQSDbpgw1%2F26opV%2F0uptItq81sGkmwcoPzo0MAn7CMEw%3D%3D--3UoEEb7GmxEBBKtC--iA93MTOUgS5L6ONajtKUtw%3D%3D; Path=/; HttpOnly; Secure; SameSite=Lax, _octo=GH1.1.990894973.1730247621; Path=/; Domain=github.com; Expires=Thu, 30 Oct 2025 00:20:21 GMT; Secure; SameSite=Lax, logged_in=no; Path=/; Domain=github.com; Expires=Thu, 30 Oct 2025 00:20:21 GMT; HttpOnly; Secure; SameSite=Lax\n    Accept-Ranges: bytes\n    Transfer-Encoding: chunked\n    X-GitHub-Request-Id: E49A:3BFF2B:1BE6F36C:1C6824DC:67217BC5\n    Content-Type: text/html; charset=utf-8\n```\n\nCache key calculations:\n\n- before sending: `GET:https://github.com/dotnet/runtime/issues/1384`\n- after sending: `GET:https://github.com/dotnet/runtime/issues/1384;Accept-Encoding=gzip`",
                                           "updatedAt":  "2024-11-05T10:00:43Z"
                                       }
                                   ],
                         "totalCount":  26
                     },
        "title":  "[HttpClientFactory] Add support for client-side cache-control",
        "labels":  [
                       "api-suggestion",
                       "area-Extensions-HttpClientFactory"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/36061",
        "createdAt":  "2020-01-24T11:54:08Z",
        "number":  36061,
        "author":  "candidodmv",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOBahjVg==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "nicolaspierre1990",
                                            "createdAt":  "2020-02-05T08:09:29Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "manyak-yuriy",
                                            "createdAt":  "2020-12-19T22:49:31Z"
                                        }
                                    ],
                          "totalCount":  2
                      },
        "updatedAt":  "2025-01-07T12:49:09Z",
        "body":  "### Is your feature request related to a problem? Please describe.\r\n\r\nI\u0027m am trying to integrated [Fusillade](https://github.com/reactiveui/Fusillade) with IHttpClientFactory but it\u0027s handler needs a parameter during it\u0027s initialization, as sample code:\r\n\r\n```c#\r\nvar moreThanSpeculativeButLessThanBAckground = new RateLimitedHttpMessageHandler(\r\n                new HttpClientHandler(), \r\n                Priority.Explicit, \r\n                15);\r\n```\r\nSo, to achive this using the current IHttpClient factory is registering one named HttpClient for each Priority, wich the minimum is the following:\r\n\r\n```c#\r\npublic enum Priority\r\n{\r\n\t/// \u003csummary\u003e\r\n\t/// A speculative priority where we aren\u0027t sure.\r\n\t/// \u003c/summary\u003e\r\n\tSpeculative = 10,\r\n\t/// \u003csummary\u003e\r\n\t/// This is a instance which is initiated by the user.\r\n\t/// \u003c/summary\u003e\r\n\tUserInitiated = 100,\r\n\t/// \u003csummary\u003e\r\n\t/// This is background based task.\r\n\t/// \u003c/summary\u003e\r\n\tBackground = 20,\r\n\t/// \u003csummary\u003e\r\n\t/// This is a explicit task.\r\n\t/// \u003c/summary\u003e\r\n\tExplicit = 0\r\n}\r\n```\r\n\r\nThen, the issue is raised: \r\n\r\nSupouse that my application is consuming only one API with their spcifics configurations, I need register at least the number of existing priorities, in that case is 4, but if have two services to consume the math is number of targeting endpoints * number of priorities, currently this cal is :\r\n\r\n`2 targeting API\u0027s X 4 possibile priorieties = 8` \r\n\r\nthis situation become unaccetable, depending the number of target API\u0027s that the application is using.\r\n\r\n### Describe the solution you\u0027d like\r\n\r\nThe most clear solution that I currently can see is create a new overload to CreateClient method in IHttpClientFactory that accept an action to configure the handlers at creating time, so we can pass any kind of parameter to any Handler that is need to configure, providing the correct constructor parameters. \r\n\r\nFuthemore I\u0027m miss a way to instantiate a new HttpClient registered using the type as a generic parameter, what in this currently context make more sense than ever, something like this:\r\n\r\n`IHttpClientFactory.CreateClient\u003cTTypedClient\u003e(Action\u003cHttpMessageHandlerBuilder\u003e configureBuilder)`\r\n\r\nor even better:\r\n\r\n`IHttpClientFactory.CreateClient\u003cTTypedClient, THttpMessageHandler\u003e(Action\u003cIList\u003cTHttpMessageHandler\u003e\u003e configureHandlers)`\r\n\r\n### Describe alternatives you\u0027ve considered\r\n\r\nI don\u0027t find any workaround to solve this limitation.\r\n\r\n### Additional context\r\n\r\nAll of this context described above is related for a Xamarin application.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOmPw6ZA==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDYyNTUzNjk0MQ==",
                                           "createdAt":  "2020-05-07T22:53:15Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/ncl\nNotify danmosemsft if you want to be subscribed.",
                                           "updatedAt":  "2020-05-07T22:53:15Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6Y_Dpk",
                                           "createdAt":  "2024-12-31T19:11:54Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Due to lack of recent activity, this issue has been marked as a candidate for backlog cleanup.  It will be closed if no further activity occurs within 14 more days. Any new comment (by anyone, not necessarily the author) will undo this process.\n\nThis process is part of our [issue cleanup automation](https://github.com/dotnet/runtime/blob/main/docs/issue-cleanup.md).\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2024-12-31T19:11:54Z"
                                       }
                                   ],
                         "totalCount":  2
                     },
        "title":  "ability of to pass parameter for HttpMessageHandler constructor",
        "labels":  [
                       "area-Extensions-HttpClientFactory"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/35987",
        "createdAt":  "2020-02-26T20:49:28Z",
        "number":  35987,
        "author":  "rynowak",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOBma9Vw==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "slang25",
                                            "createdAt":  "2020-02-26T21:11:52Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "rcollina",
                                            "createdAt":  "2020-02-27T20:47:58Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "jstri",
                                            "createdAt":  "2020-08-06T16:49:16Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "DillonN",
                                            "createdAt":  "2020-12-03T04:31:47Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "karelz",
                                            "createdAt":  "2021-01-26T08:00:11Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "drphrozen",
                                            "createdAt":  "2021-04-08T10:17:05Z"
                                        }
                                    ],
                          "totalCount":  6
                      },
        "updatedAt":  "2024-07-11T17:45:38Z",
        "body":  "For .NET 5 we should switch the defaults of the factory:\r\n - configure a connection lifetime for SocketsHttpHandler\r\n- disable handler rotation\r\n\r\nThe problem that\u0027s solved by the current behavior (handler rotation) is solved more elegantly by just using the feature for it.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOhIhVQA==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDYyNTQ0MzY1MA==",
                                           "createdAt":  "2020-05-07T19:10:50Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/ncl\nNotify danmosemsft if you want to be subscribed.",
                                           "updatedAt":  "2020-05-07T19:10:50Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc3OTI2ODU0Mw==",
                                           "createdAt":  "2021-02-15T14:47:42Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "CarnaViire",
                                           "body":  "Triage:\r\nWe cannot disable/remove handler rotation entirely because of 2 reasons:\r\n - it will have to stay for .NET Framework\r\n - it will have to stay for custom primary handlers as it might not be backed by `SocketsHttpHandler` at all, e.g. `WinHttpHandler`\r\n \r\nWe may still use `SocketsHttpHandler` for default primary handlers on .NET Core, but the benefit will not be as big (we cannot remove the rotation entirely).\r\n\r\nMoving to future.",
                                           "updatedAt":  "2021-02-15T14:47:42Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5vUmoQ",
                                           "createdAt":  "2023-12-22T13:12:09Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODRPH4Q==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "CarnaViire",
                                                                               "createdAt":  "2024-01-04T12:00:06Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "\u003e We may still use SocketsHttpHandler for default primary handlers on .NET Core\r\n\r\nWe really should do this. Someone should be able to create and hold on to an HttpClient and have things \"just work\". The fact that it doesn\u0027t today is arguably a bug. With this, at least the important case will \"just work\". \r\n\r\n\u003e we cannot remove the rotation entirely\r\n\r\nWe can when the default handler is used on core, which is the most important case. ",
                                           "updatedAt":  "2023-12-22T13:15:18Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5vUpxR",
                                           "createdAt":  "2023-12-22T13:23:38Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODRPHzw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "ROCKET",
                                                                               "user":  "alexalok",
                                                                               "createdAt":  "2023-12-22T14:33:26Z"
                                                                           },
                                                                           {
                                                                               "content":  "ROCKET",
                                                                               "user":  "rynowak",
                                                                               "createdAt":  "2023-12-22T20:31:23Z"
                                                                           },
                                                                           {
                                                                               "content":  "ROCKET",
                                                                               "user":  "CarnaViire",
                                                                               "createdAt":  "2024-01-04T11:59:57Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  3
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "We should also consider pushing the rotation down into a delegating handler. When the primary handler isn\u0027t SHH, we can wrap the primary in a handler that will do the rotation, rather than doing it as part of the factory. That way, someone holding on to an HttpClient will still get the rotation under the covers.",
                                           "updatedAt":  "2023-12-22T13:23:38Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5v4Syu",
                                           "createdAt":  "2024-01-04T12:35:26Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODRrGKg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "stephentoub",
                                                                               "createdAt":  "2024-01-08T23:21:45Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "CarnaViire",
                                           "body":  "@stephentoub I agree. Both this issue and https://github.com/dotnet/runtime/issues/47091 are crucial to overcome the most common fallouts. The good thing is that the API prerequisites that they both required are already done within https://github.com/dotnet/runtime/issues/87914.\r\n\r\nWe\u0027ve discussed some (potentially ugly 😅) ways to remove rotation from .NET Framework/mobile/browser as well. So it might boil down to just custom primary handlers.\r\n\r\nre: we cannot remove the rotation entirely -- what I meant in the original comment was that we won\u0027t be able to _simplify the codebase_ because we have to leave the code there for certain cases. It will most possibly just make it even more complicated. But I really like the idea of a rotating handler, I will play with this approach to see whether it will work out.\r\n\r\nWe will also have to agree on how much of a breaking change we (and users) could accept. Because technically both changing the default primary handler from `HttpClientHandler` to `SocketsHttpHandler`, and changing the way `HandlerLifetime` applies (recreating the whole chain of handlers vs just recreating the connection within the `SocketsHttpHandler`, leaving the chain as a technical named singleton) could break quite a lot of people, especially the second one -- because handlers from the chain could have scoped dependencies. They are not working well now (yes, https://github.com/dotnet/runtime/issues/47091 😣😭) but implementing _just this_ feature without https://github.com/dotnet/runtime/issues/47091 will break scopes completely.",
                                           "updatedAt":  "2024-01-04T12:35:26Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6A8K6z",
                                           "createdAt":  "2024-06-12T14:56:36Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "CarnaViire",
                                           "body":  "Triage: Not urgent, moving to Future. The two main parts of the issue are\r\n\r\n\u003e configure a connection lifetime for SocketsHttpHandler\r\n\r\n-- brings the biggest value, and is already addressed by https://github.com/dotnet/runtime/pull/101808\r\n\r\n\u003e disable handler rotation\r\n\r\n-- nice to have, not urgent plus there are existing concerns listed above (blocked by https://github.com/dotnet/runtime/issues/47091)",
                                           "updatedAt":  "2024-06-12T14:56:36Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6ETJta",
                                           "createdAt":  "2024-07-10T05:47:25Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODpJ1zg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "julealgon",
                                                                               "createdAt":  "2024-07-10T13:58:50Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "kevinchalet",
                                           "body":  "https://github.com/dotnet/runtime/pull/101808 was locked so I can\u0027t share my feedback there.\r\n\r\n\u003e \u003e Are we concerned about this actually affecting real code? I\u0027d have thought we\u0027d actively discourage folks relying on the pipeline defaulting to a specific never-changing configuration where they could downcast without fear of exception. That\u0027s similar to saying a virtual method typed to return Base and happens to actually return Derived1 today can\u0027t be changed to return Derived2 tomorrow (and we do that).\r\n\u003e\r\n\u003e Thinking more about this, I agree. The fact that `HttpClientHandler` is used by default is clearly an implementation detail, and it doesn\u0027t seem to be mentioned anywhere in the docs, which is good. I did a research anyway, and I wasn\u0027t able to find the real cases of such casts. So I \"remove\" this concern from my list as well, which means we should be good to go :shipit:\r\n\r\nFWIW, this change breaks OpenIddict - according to NuGet.org, the largest project using `Microsoft.Extensions.Http.Polly` and `Microsoft.Extensions.Http.Resilience` (to put things into perspective 😄) - as it downcasts `PrimaryHandler` to `HttpClientHandler` to be able to set properties like `UseCookies`:\r\n\r\n```csharp\r\noptions.HttpMessageHandlerBuilderActions.Add(builder =\u003e\r\n{\r\n    if (builder.PrimaryHandler is not HttpClientHandler handler)\r\n    {\r\n        throw new InvalidOperationException(SR.FormatID0373(typeof(HttpClientHandler).FullName));\r\n    }\r\n\r\n    // Note: automatic content decompression can be enabled by constructing an HttpClient wrapping\r\n    // a generic HttpClientHandler, a SocketsHttpHandler or a WinHttpHandler instance with the\r\n    // AutomaticDecompression property set to the desired algorithms (e.g GZip, Deflate or Brotli).\r\n    //\r\n    // Unfortunately, while convenient and efficient, relying on this property has a downside:\r\n    // setting AutomaticDecompression always overrides the Accept-Encoding header of all requests\r\n    // to include the selected algorithms without offering a way to make this behavior opt-in.\r\n    // Sadly, using HTTP content compression with transport security enabled has security implications\r\n    // that could potentially lead to compression side-channel attacks if the client is used with\r\n    // remote endpoints that reflect user-defined data and contain secret values (e.g BREACH attacks).\r\n    //\r\n    // Since OpenIddict itself cannot safely assume such scenarios will never happen (e.g a token request\r\n    // will typically be sent with an authorization code that can be defined by a malicious user and can\r\n    // potentially be reflected in the token response depending on the configuration of the remote server),\r\n    // it is safer to disable compression by default by not sending an Accept-Encoding header while\r\n    // still allowing encoded responses to be processed (e.g StackExchange forces content compression\r\n    // for all the supported HTTP APIs even if no Accept-Encoding header is explicitly sent by the client).\r\n    //\r\n    // For these reasons, OpenIddict doesn\u0027t rely on the automatic decompression feature and uses\r\n    // a custom event handler to deal with GZip/Deflate/Brotli-encoded responses, so that servers\r\n    // that require using HTTP compression can be supported without having to use it for all servers.\r\n    if (handler.SupportsAutomaticDecompression)\r\n    {\r\n        handler.AutomaticDecompression = DecompressionMethods.None;\r\n    }\r\n\r\n    // OpenIddict uses IHttpClientFactory to manage the creation of the HTTP clients and\r\n    // their underlying HTTP message handlers, that are cached for the specified duration\r\n    // and re-used to process multiple requests during that period. While remote APIs are\r\n    // typically not expected to return cookies, it is in practice a very frequent case,\r\n    // which poses a serious security issue when the cookies are shared across multiple\r\n    // requests (which is the case when the same message handler is cached and re-used).\r\n    //\r\n    // To avoid that, cookies support is explicitly disabled here, for security reasons.\r\n    handler.UseCookies = false;\r\n\r\n    // ...\r\n});\r\n```\r\n\r\nWhile designing that a while ago, I considered downcasting to other well-known handler types, but:\r\n  - They are lots of types to support if you want to cover most cases: `HttpClientHandler`, `SocketsHttpHandler`, `WinHttpHandler`, `CFNetworkHandler`, `NSUrlSessionHandler`, etc.\r\n  - Not all of them are public, e.g `BrowserHttpHandler`.\r\n\r\nI\u0027ll probably add a `HttpMessageHandlerBuilderAction` that resets `PrimaryHandler` to a `HttpClientHandler` and release a new version before .NET 9.0 ships to mitigate that breaking change, but that would have been nice if you had improved that terrible design before adopting this breaking change: it\u0027s basically the same issue that has plagued the `RSA` base class for years before useful methods were added to the base class, eliminating the needs for downcasts.",
                                           "updatedAt":  "2024-07-10T05:47:53Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6ETNSa",
                                           "createdAt":  "2024-07-10T06:01:04Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "kevinchalet",
                                           "body":  "\u003e but that would have been nice if you had improved that terrible design before adopting this breaking change: it\u0027s basically the same issue that has plagued the `RSA` base class for years before useful methods were added to the base class, eliminating the needs for downcasts.\r\n\r\nI can personally think of 3 options to make `HttpClientHandler` easier to compose:\r\n  - Make the `*Handler` implementations derive from `HttpClientHandler` - or a new common class derived from `HttpMessageHandler` - (maybe not ideal from a backcompat\u0027 perspective).\r\n  - Provide a `HttpClientHandler.Wrap(HttpMessageHandler handler)` static method that would return a `HttpClientHandler` using the specified instance as the inner handler (so the `HttpClientHandler` properties would mutate the inner handler).\r\n  - Introduce new interfaces that would be implemented by all the `*Handler` classes.",
                                           "updatedAt":  "2024-07-10T14:56:37Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6ETl_r",
                                           "createdAt":  "2024-07-10T07:11:30Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "kevinchalet",
                                           "body":  "BTW, a quick [GitHub Code search](https://github.com/search?q=lang%3AC%23+PrimaryHandler+HttpClientHandler\u0026type=code) reveals that other projects will be broken too for the same reasons.\r\n\r\nE.g: https://github.com/abraxas-labs/voting-library-dotnet/blob/a1e8115f006a15a630d6632bf72206932ac8a671/src/Voting.Lib.Common/Net/CertificatePinningHandlerBuilder.cs#L45",
                                           "updatedAt":  "2024-07-10T07:11:30Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6EVWN6",
                                           "createdAt":  "2024-07-10T10:52:01Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stephentoub",
                                           "body":  "@CarnaViire, what would you like to do here? ",
                                           "updatedAt":  "2024-07-10T10:52:01Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6EiAdc",
                                           "createdAt":  "2024-07-11T17:33:38Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "CarnaViire",
                                           "body":  "_TL;DR: I still need some time to reach a decision._\r\n\r\nThanks for bringing this up @kevinchalet. I still think that HttpClientFactory using HttpClientHandler by default _is_ an implementation detail that shouldn\u0027t be depended on, but I do see your point -- e.g. we had to do some rather ugly casts ourselves 😞 (it doesn\u0027t break, yeah, it works as expected in all cases, but it _is_ ugly)\r\n\r\n\u003cdetails\u003e\r\n\r\nhttps://github.com/dotnet/runtime/blob/29fe6a89a579f62bddacc8d1b90f569cc573d139/src/libraries/Microsoft.Extensions.Http/src/MetricsFactoryHttpMessageHandlerFilter.cs#L31-L40\r\n\r\n\u003c/details\u003e\r\n\r\nUnfortunately I guess there\u0027s no good solution _in the 9.0 timeframe_.\r\n\r\nI\u0027m inclined to keep the change, but I need some time to think and consider pros and cons. Reverting the change is fast and easy 😅 but it was introduced for a reason, as well.\r\n\r\nI see that you have already implemented a workaround @kevinchalet. I wonder if `ConfigureHttpClientDefaults` could also work for you for that matter, for a cleaner configuration:\r\n\r\n```c#\r\n// all clients will have HttpClientHandler by default\r\nservices.ConfigureHttpClientDefaults(b =\u003e\r\n    b.ConfigurePrimaryHttpMessageHandler(() =\u003e new HttpClientHandler()));\r\n```\r\n\r\nor even\r\n\r\n```c#\r\nservices.ConfigureHttpClientDefaults(b =\u003e\r\n    b.ConfigurePrimaryHttpMessageHandler(() =\u003e\r\n    {\r\n        var handler = new HttpClientHandler() { UseCookies = false };\r\n        if (handler.SupportsAutomaticDecompression)\r\n        {\r\n            handler.AutomaticDecompression = DecompressionMethods.None;\r\n        }\r\n        return handler;\r\n    }));\r\n```",
                                           "updatedAt":  "2024-07-11T17:33:38Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6EiFVA",
                                           "createdAt":  "2024-07-11T17:45:37Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "kevinchalet",
                                           "body":  "\u003e Thanks for bringing this up @kevinchalet.\r\n\r\nMy pleasure! Thanks for taking the time to reply.\r\n\r\n\u003e I still think that HttpClientFactory using HttpClientHandler by default _is_ an implementation detail that shouldn\u0027t be depended on.\r\n\r\nI agree. Unfortunately, downcasting is pretty much required as soon as you want to tweak the properties of the handler (`RSA` and `ECDsa` suffered from the same issue). If there was a better option, we\u0027d definitely use it 😄 \r\n\r\n\u003e it doesn\u0027t break, yeah, it works as expected in all cases, but it _is_ ugly\r\n\r\n\"works as expected in all cases\" seems a bit optimistic to me: it only works if the user doesn\u0027t replace the default primary handler (that can now be a `SocketsHttpHandler` or an `HttpClientHandler` in 9.0+) but it breaks when using a different type: you can of course no-op if the handler type is not recognized as in the snippet you shared, but it\u0027s sadly an absolute no-go for me when you need to set security-related properties such as the ones overridden by OpenIddict.\r\n\r\n\u003e I\u0027m inclined to keep the change, but I need some time to think and consider pros and cons. Reverting the change is fast and easy 😅 but it was introduced for a reason, as well.\r\n\r\nIt\u0027s certainly a positive change, but we really need a better way to amend the handler properties without having to manually downcast to every possible type 😅 \r\nI listed a few possible options but I\u0027m sure there are others. That would be nice if you could think about that as such an API would be a life saver.\r\n\r\n\u003e I see that you have already implemented a workaround @kevinchalet. I wonder if `ConfigureHttpClientDefaults` could also work for you for that matter, for a cleaner configuration:\r\n\r\nNo doubt it would work, but it would affect every HTTP client and not just the clients needed by the OpenIddict libraries, including user-defined clients, which is a bit meh (I don\u0027t want to force users to use `HttpClientHandler` for their own clients).\r\n\r\nThanks!",
                                           "updatedAt":  "2024-07-11T17:45:37Z"
                                       }
                                   ],
                         "totalCount":  12
                     },
        "title":  "Consider updating HttpClientFactory defaults to leverage SocketsHttpHandler",
        "labels":  [
                       "enhancement",
                       "area-Extensions-HttpClientFactory"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/47091",
        "createdAt":  "2021-01-17T23:01:16Z",
        "number":  47091,
        "author":  "CarnaViire",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHODPKySw==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "rhyder",
                                            "createdAt":  "2021-01-30T18:22:56Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "kaluznyt",
                                            "createdAt":  "2022-01-11T14:45:35Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "nartalex",
                                            "createdAt":  "2022-01-18T13:46:28Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "CDuke",
                                            "createdAt":  "2022-01-20T21:44:47Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "JohannesKahl",
                                            "createdAt":  "2022-02-09T19:41:28Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "josh-green",
                                            "createdAt":  "2022-02-17T17:01:15Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "kronic",
                                            "createdAt":  "2022-03-22T13:29:18Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Cobra86",
                                            "createdAt":  "2022-04-15T14:55:32Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "MarS0K",
                                            "createdAt":  "2022-04-20T02:03:56Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "DillonN",
                                            "createdAt":  "2022-07-06T02:40:35Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "ArminShoeibi",
                                            "createdAt":  "2022-08-26T17:02:20Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "ioaznnis",
                                            "createdAt":  "2022-09-16T16:47:44Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "DmitriiPatron",
                                            "createdAt":  "2022-09-20T08:08:49Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "pipllkz",
                                            "createdAt":  "2022-09-20T08:09:01Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "user-nik",
                                            "createdAt":  "2022-09-20T08:14:12Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "SamPersson",
                                            "createdAt":  "2022-09-20T12:04:10Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "cuongnn68",
                                            "createdAt":  "2022-09-23T10:14:13Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "tzongithub",
                                            "createdAt":  "2022-10-12T14:49:51Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "qmfrederik",
                                            "createdAt":  "2022-12-29T23:12:29Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "bfriesen",
                                            "createdAt":  "2023-02-22T17:48:12Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "brendonparker",
                                            "createdAt":  "2023-03-06T21:45:27Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "hennadii-sakhniuk-yapi",
                                            "createdAt":  "2023-04-25T17:59:56Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "uhfath",
                                            "createdAt":  "2023-04-26T08:54:29Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "marius-stanescu",
                                            "createdAt":  "2023-06-28T05:44:52Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "pedroarmando",
                                            "createdAt":  "2023-06-29T14:28:59Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "KonradBralewski",
                                            "createdAt":  "2023-08-23T08:26:29Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "marklagendijk",
                                            "createdAt":  "2023-10-05T08:05:00Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "ChristophHornung",
                                            "createdAt":  "2023-10-11T13:54:04Z"
                                        },
                                        {
                                            "content":  "EYES",
                                            "user":  "aloraman",
                                            "createdAt":  "2023-10-28T12:01:04Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "Seabizkit",
                                            "createdAt":  "2023-12-27T17:47:53Z"
                                        },
                                        {
                                            "content":  "EYES",
                                            "user":  "Seabizkit",
                                            "createdAt":  "2023-12-27T17:47:56Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "zdenek-jelinek",
                                            "createdAt":  "2024-01-30T09:21:34Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "jHabjanMXP",
                                            "createdAt":  "2024-05-09T14:51:43Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "straddle-olly",
                                            "createdAt":  "2024-08-08T13:25:50Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "BobSilent",
                                            "createdAt":  "2024-09-27T08:15:30Z"
                                        },
                                        {
                                            "content":  "EYES",
                                            "user":  "BobSilent",
                                            "createdAt":  "2024-09-27T08:15:34Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "petrovicnemanja",
                                            "createdAt":  "2024-09-30T09:12:26Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "arturgromek-infotrack",
                                            "createdAt":  "2024-10-09T02:28:15Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "cosmic-flood",
                                            "createdAt":  "2025-03-10T15:00:49Z"
                                        },
                                        {
                                            "content":  "EYES",
                                            "user":  "cosmic-flood",
                                            "createdAt":  "2025-03-10T15:00:49Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "jasoneisen",
                                            "createdAt":  "2025-09-08T19:37:11Z"
                                        }
                                    ],
                          "totalCount":  41
                      },
        "updatedAt":  "2025-06-19T13:39:50Z",
        "body":  "_Updated_\r\n\r\nThe scope can be provided via the keyed services infra. The API to opt-in into Keyed services registration is proposed in https://github.com/dotnet/runtime/issues/89755.\r\n\r\n`AddAsKeyedScoped()` API will automatically opt in into the scope-propagating behavior, but _ONLY in case_ keyed services infra (`[FromKeyedServices...]` or `GetRequiredKeyedService`) is used to inject/resolve the client.\r\n\r\n\u003cdetails\u003e\r\n\u003csummary\u003eOpt-in API design considerations -- separate from keyed services\u003c/summary\u003e\r\n\r\n```c#\r\nnamespace Microsoft.Extensions.DependencyInjection;\r\n\r\npublic static partial class HttpClientBuilderExtensions\r\n{\r\n    public static IHttpClientBuilder SetPropagateContextScope(this IHttpClientBuilder builder, bool val) {}\r\n}\r\n```\r\n\r\nUsage:\r\n\r\n```c#\r\nservices.AddHttpClient(\"foo\")\r\n    //.AddAsKeyedScoped()\r\n    .SetPropagateContextScope(true);\r\n\r\nservices.AddHttpClient(\"foo\")\r\n    //.AddAsKeyedTransient()\r\n    .SetPropagateContextScope(true); // if there are any scoped dependencies, won\u0027t resolve in singletons\r\n\r\nservices.AddHttpClient(\"foo\")\r\n    .SetPropagateContextScope(false); // explicitly opt-out\r\n```\r\n\r\nAlternalive namings:\r\n\r\n- `PropagateScope`\r\n- `PropagateExistingScope`\r\n- `SetPreserveExistingScope(true/false)`\r\n- `SetSuppressHandlerScope(true/false)` (there is existing \"hidden\" option with that name, but the usage is a bit different, so technically it _can_ clash with existing usages + and not self-evident name)\r\n\r\n\u003c/details\u003e\r\n\r\n-----\r\n\r\n_Original proposal_\r\n\r\n## Background and Motivation\r\n\r\n`HttpClientFactory` allows users to register one or several `HttpClient` configurations in DI container and then instantiate `HttpClient`s according to the respective configuration.  A configuration can specify that `HttpClient` should use a specific `HttpMessageHandler` or even a chain of such handlers. When creating a client, `HttpClientFactory` caches and reuses `HttpMessageHandler`s to avoid creating too many connections and exhausting sockets, so handlers will live for a configurable timespan `HandlerLifetime`.\r\n\r\nThe problem begins when message handlers forming a chain have dependencies on other services from DI. In case the user wants to inject a **scoped** service into the message handler, they expect the scoped service instance to be from their **existing unit-of-work scope**. However, the current behavior is different -- in the existing implementation, the service instance will be from a new scope bound to message handler lifetime, i.e. it will be a different instance from what the user would expect.\r\n\r\nThis **scope mismatch** is not only confusing to customers, but also produces unsolvable bugs in user code, e.g. when the scoped service is supposed to be stateful within the scope, but this state is impossible to access from the message handler.\r\n\r\nThere is a number of GH issues and StackOverflow questions from users suffering from scope mismatch:\r\n - https://github.com/dotnet/runtime/issues/36574 HttpClientFactory doesn\u0027t respect lifetime of custom message handlers\r\n - https://github.com/dotnet/runtime/issues/42344 DefaultHttpClientFactory working incorrectly with Scoped dependencies\r\n - [c# - Prevent IHttpClientFactory to create DI scope for handlers - Stack Overflow](https://stackoverflow.com/questions/57497710/prevent-ihttpclientfactory-to-create-di-scope-for-handlers)\r\n - [c# - Configure HttpClientFactory to use data from the current request context - Stack Overflow](https://stackoverflow.com/questions/51358870/configure-httpclientfactory-to-use-data-from-the-current-request-context)\r\n - [IHttpClientBuilder with DelegatingHandler creates additional scope in Blazor webassembly - Stack Overflow](https://stackoverflow.com/questions/77904847/ihttpclientbuilder-with-delegatinghandler-creates-additional-scope-in-blazor-web)\r\n\r\nThe solution leverages the following idea: \r\n\r\nIf we want to cache/reuse the connection, it is enough to cache/reuse the bottom-most handler of the chain (aka `PrimaryHandler`). Other handlers in the chain may be re-instantiated for each unit-of-work scope, so they will have the correct instances of the scoped services injected into them (which is desired by customers).\r\n\r\nI believe new behavior should be opt-in, as there will be more allocations than before.\r\n\r\nHowever, in order to leverage existing scope, `HttpClientFactory` should know about it. In the current implementation, the factory is registered in DI a singleton, so it doesn\u0027t have access to scopes.\r\n\r\nThe easiest way to allow `HttpClientFactory` to capture existing scope is to change its lifetime from singleton to transient. Transient services can (as well as singletons) be injected into services of all lifetimes, so all existing code will continue to work. \r\n\r\nTo maintain existing caching behavior, cache part of the factory will be moved out to a separate singleton service, but this is an implementation detail that does not affect API.\r\n\r\n## Proposed API\r\n\r\n```diff\r\nnamespace Microsoft.Extensions.DependencyInjection\r\n{\r\n    public static partial class HttpClientBuilderExtensions\r\n    {\r\n        ...\r\n        public static IHttpClientBuilder SetHandlerLifetime(this IHttpClientBuilder builder, TimeSpan handlerLifetime) { ... }\r\n+       public static IHttpClientBuilder SetPreserveExistingScope(this IHttpClientBuilder builder, bool preserveExistingScope) { ... }\r\n    }\r\n}\r\n\r\nnamespace Microsoft.Extensions.Http\r\n{\r\n    public partial class HttpClientFactoryOptions\r\n    {\r\n        ...\r\n        public TimeSpan HandlerLifetime { get; set; }\r\n+       public bool PreserveExistingScope { get; set; } // default is false = old behavior\r\n    }\r\n}\r\n\r\nnamespace System.Net.Http\r\n{\r\n-   // registered in DI as singleton\r\n+   // registered in DI as transient\r\n    public partial interface IHttpClientFactory\r\n    {\r\n        HttpClient CreateClient(string name);\r\n    }\r\n}\r\n```\r\n\r\n## Usage Examples\r\n\r\nThe only change needed for both named and typed clients is to opt-in via callling `SetPreserveExistingScope(true)`\r\n\r\nNamed client example:\r\n``` diff\r\n// registration\r\nclass Program\r\n{\r\n    private static void ConfigureServices(HostBuilderContext context, IServiceCollection services)\r\n    {\r\n        services.AddScoped\u003cIWorker, NamedClientWorker\u003e();\r\n        services.AddScoped\u003cHandlerWithScopedDependency\u003e();\r\n        services.AddHttpClient(\"github\")\r\n            .AddHttpMessageHandler\u003cHandlerWithScopedDependency\u003e()\r\n+           .SetPreserveExistingScope(true);\r\n        ...\r\n    }\r\n    ...\r\n}\r\n\r\n// usage\r\nclass NamedClientWorker : IWorker\r\n{\r\n   private IHttpClientFactory _clientFactory;\r\n\r\n+   // HttpClientFactory will capture an existing scope where it was resolved\r\n    public NamedClientWorker(IHttpClientFactory clientFactory)\r\n    {\r\n        _clientFactory = clientFactory;\r\n    }\r\n\r\n    public async Task DoWorkAsync()\r\n    {\r\n+       // HandlerWithScopedDependency inside HttpClient will be resolved\r\n+       // within an existing scope \r\n        HttpClient client = _clientFactory.CreateClient(\"github\");\r\n        var response = await client.GetStringAsync(GetRepositoriesUrl(username));\r\n        ...\r\n    }\r\n}\r\n```\r\n\r\nTyped client example:\r\n``` diff\r\n// registration\r\nclass Program\r\n{\r\n    private static void ConfigureServices(HostBuilderContext context, IServiceCollection services)\r\n    {\r\n        services.AddScoped\u003cIWorker, TypedClientWorker\u003e();\r\n        services.AddScoped\u003cHandlerWithScopedDependency\u003e();\r\n        services.AddHttpClient\u003cIGithubClient, GithubClient\u003e\r\n            .AddHttpMessageHandler\u003cHandlerWithScopedDependency\u003e()\r\n+           .SetPreserveExistingScope(true);\r\n        ...\r\n    }\r\n    ...\r\n}\r\n\r\n// usage\r\nclass TypedClientWorker : IWorker\r\n{\r\n    private IGithubClient _githubClient;\r\n\r\n    public TypedClientWorker(IGithubClient githubClient)\r\n    {\r\n        _githubClient = githubClient;\r\n    }\r\n\r\n    public async Task DoWorkAsync()\r\n    {\r\n        var response = await _githubClient.GetRepositories(username);\r\n        ...\r\n    }\r\n}\r\n\r\n// typed client impl\r\nclass GithubClient : IGithubClient\r\n{\r\n    private HttpClient _client;\r\n\r\n    // HttpClient is created by IHttpClientFactory  \r\n+   // HttpClientFactory will capture an existing scope\r\n+   // HandlerWithScopedDependency inside HttpClient will be resolved\r\n+   // within an existing scope \r\n    public GithubClient(HttpClient client)\r\n    {\r\n        _client = client;\r\n    }\r\n\r\n    public async Task\u003cstring\u003e GetRepositories(string username)\r\n    {\r\n        return await _client.GetStringAsync(GetRepositoriesUrl(username));\r\n    }\r\n}\r\n```\r\n\r\n## Alternative Designs\r\n\r\nIf we don\u0027t want to change the current lifetime of `HttpClientFactory` (i.e. let it stay singleton), we should provide the scope to it in some other way.\r\n\r\nIn order to do that, we may have an additional scoped service, which will have access to the current unit-of-work scope *and* to the singleton `HttpClientFactory`.\r\n\r\nLet me note that because of how DI works, we couldn\u0027t use existing interface `IHttpClientFactory` for a new scoped service, because a singleton service is already registered on it. That\u0027s why a new interface `IScopedHttpClientFactory` is added here.\r\n\r\n\r\n\r\n```diff\r\nnamespace Microsoft.Extensions.DependencyInjection\r\n{\r\n    public static partial class HttpClientBuilderExtensions\r\n    {\r\n        ...\r\n        public static IHttpClientBuilder SetHandlerLifetime(this IHttpClientBuilder builder, TimeSpan handlerLifetime) { ... }\r\n+       public static IHttpClientBuilder SetPreserveExistingScope(this IHttpClientBuilder builder, bool preserveExistingScope) { ... }\r\n    }\r\n}\r\n\r\nnamespace Microsoft.Extensions.Http\r\n{\r\n    public partial class HttpClientFactoryOptions\r\n    {\r\n        ...\r\n        public TimeSpan HandlerLifetime { get; set; }\r\n+       public bool PreserveExistingScope { get; set; } // default is false = old behavior\r\n    }\r\n}\r\n\r\nnamespace System.Net.Http\r\n{\r\n    // registered in DI as singleton\r\n    public partial interface IHttpClientFactory\r\n    {\r\n        HttpClient CreateClient(string name);\r\n    }\r\n\r\n+   // registered in DI as scoped\r\n+   public partial interface IScopedHttpClientFactory\r\n+   {\r\n+       HttpClient CreateClient(string name);\r\n+   }\r\n}\r\n```\r\n\r\n### Alternative design\u0027s usage examples:\r\n\r\nFor named clients, user will also need to change the injected factory after opt-in. For typed clients, just opting-in is enough, the magic will happen on its own. \r\n\r\nNamed client example:\r\n``` diff\r\n// registration\r\nclass Program\r\n{\r\n    private static void ConfigureServices(HostBuilderContext context, IServiceCollection services)\r\n    {\r\n        services.AddScoped\u003cIWorker, NamedClientWorker\u003e();\r\n        services.AddScoped\u003cHandlerWithScopedDependency\u003e();\r\n        services.AddHttpClient(\"github\")\r\n            .AddHttpMessageHandler\u003cHandlerWithScopedDependency\u003e()\r\n+           .SetPreserveExistingScope(true);\r\n        ...\r\n    }\r\n    ...\r\n}\r\n\r\n// usage\r\nclass NamedClientWorker : IWorker\r\n{\r\n-   private IHttpClientFactory _clientFactory;\r\n+   private IScopedHttpClientFactory _clientFactory;\r\n\r\n    public NamedClientWorker(\r\n-       IHttpClientFactory clientFactory)\r\n+       IScopedHttpClientFactory clientFactory)\r\n    {\r\n        _clientFactory = clientFactory;\r\n    }\r\n\r\n    public async Task DoWorkAsync()\r\n    {\r\n        HttpClient client = _clientFactory.CreateClient(\"github\");\r\n        var response = await client.GetStringAsync(GetRepositoriesUrl(username));\r\n        ...\r\n    }\r\n}\r\n```\r\n\r\nTyped client example:\r\n``` diff\r\n// registration\r\nclass Program\r\n{\r\n    private static void ConfigureServices(HostBuilderContext context, IServiceCollection services)\r\n    {\r\n        services.AddScoped\u003cIWorker, TypedClientWorker\u003e();\r\n        services.AddScoped\u003cHandlerWithScopedDependency\u003e();\r\n        services.AddHttpClient\u003cIGithubClient, GithubClient\u003e\r\n            .AddHttpMessageHandler\u003cHandlerWithScopedDependency\u003e()\r\n+           .SetPreserveExistingScope(true);\r\n        ...\r\n    }\r\n    ...\r\n}\r\n\r\n// usage\r\nclass TypedClientWorker : IWorker\r\n{\r\n    private IGithubClient _githubClient;\r\n\r\n    public TypedClientWorker(IGithubClient githubClient)\r\n    {\r\n        _githubClient = githubClient;\r\n    }\r\n\r\n    public async Task DoWorkAsync()\r\n    {\r\n        var response = await _githubClient.GetRepositories(username);\r\n        ...\r\n    }\r\n}\r\n\r\n// typed client impl\r\nclass GithubClient : IGithubClient\r\n{\r\n    private HttpClient _client;\r\n\r\n-   // HttpClient is created by IHttpClientFactory \r\n+   // HttpClient is automatically created by IScopedHttpClientFactory after opt-in\r\n    public GithubClient(HttpClient client)\r\n    {\r\n        _client = client;\r\n    }\r\n\r\n    public async Task\u003cstring\u003e GetRepositories(string username)\r\n    {\r\n        return await _client.GetStringAsync(GetRepositoriesUrl(username));\r\n    }\r\n}\r\n```\r\n\r\n## Risks\r\n\r\nFor existing usages - the risk is low. Transient `HttpClientFactory` can be injected in all service lifetimes as well as a singleton, so all existing code will continue to work as before and will maintain old behavior for creating `HttpMessageHandler`s. The only thing that will change is that there will be more allocations (every injection of `HttpClientFactory` will create a new instance).\r\n\r\nNew opt-in behavior is only meaningful within a scope, so `HttpClientFactory` should be resolved within a scope for `PreserveExistingScope=true` to work. However, no need to add any additional checks, this will be checked by DI\u0027s [Scope Validation](https://docs.microsoft.com/en-us/dotnet/core/extensions/dependency-injection#scope-validation).\r\n\r\nSubstituting or modifying `PrimaryHandler` in case of `PreserveExistingScope=true` will be currently forbidden (`InvalidOperationException` during DI configuration). This is due to inability to assess security risks and avoid unnesessary object creations. `HttpMessageHandlerBuilder.Build()` will be called for each scope and not once in a (primary) handler lifetime as before. If it contains substituting or modifying `PrimaryHandler`, it will not work as expected, but will produce potential security risk and impact performance by creating redundant `PrimaryHandler`s to be thrown away. Addressing the risks of allowing `PrimaryHandler` modification will require additional API change.\r\n\r\n----\r\n*2021-02-11 Edit:* Changed main proposal to be about transient `HttpClientFactory`. Moved `IScopedHttpClientFactory` to alternatives. Removed option with `IServiceProvider` completely as it is both a bad practice and inconvenient to use.\r\n\r\n*2021-01-21 Edit:* I\u0027ve removed `IScopedHttpMessageHandlerFactory` from the proposal. It was initially added to correlate with `IHttpMessageHandlerFactory`, but actual usage examples where only scoped message handler would be needed but not `HttpClient` are not clear. It can be easily added later if there will be any demand for that.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOoSjzmA==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc2MTg5NjI0Mw==",
                                           "createdAt":  "2021-01-17T23:01:19Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/ncl\nSee info in area-owners.md if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n## Background and Motivation\r\n\r\n`HttpClientFactory` allows users to register one or several `HttpClient` configurations in DI container and then instantiate `HttpClient`s according to the respective configuration.  A configuration can specify that `HttpClient` should use a specific `HttpMessageHandler` or even a chain of such handlers. When creating a client, `HttpClientFactory` caches and reuses `HttpMessageHandler`s to avoid creating too many connections and exhausting sockets, so handlers will live for a configurable timespan `HandlerLifetime`.\r\n\r\nThe problem begins when message handlers forming a chain have dependencies on other services from DI. In case the user wants to inject a **scoped** service into the message handler, they expect the scoped service instance to be from their **existing unit-of-work scope**. However, the current behavior is different -- in the existing implementation, the service instance will be from a new scope bound to message handler lifetime, i.e. it will be a different instance from what the user would expect.\r\n\r\nThis **scope mismatch** is not only confusing to customers, but also produces unsolvable bugs in user code, e.g. when the scoped service is supposed to be stateful within the scope, but this state is impossible to access from the message handler.\r\n\r\nThere is a number of GH issues and StackOverflow questions from users suffering from scope mismatch:\r\n - https://github.com/dotnet/runtime/issues/36574 HttpClientFactory doesn\u0027t respect lifetime of custom message handlers\r\n - https://github.com/dotnet/runtime/issues/42142 Loss of scoped lifetime service instances when resolving HttpClient services configured through IServiceCollection.AddHttpClient(...)\r\n - https://github.com/dotnet/runtime/issues/42344 DefaultHttpClientFactory working incorrectly with Scoped dependencies\r\n - [c# - Prevent IHttpClientFactory to create DI scope for handlers - Stack Overflow](https://stackoverflow.com/questions/57497710/prevent-ihttpclientfactory-to-create-di-scope-for-handlers)\r\n - [c# - Configure HttpClientFactory to use data from the current request context - Stack Overflow](https://stackoverflow.com/questions/51358870/configure-httpclientfactory-to-use-data-from-the-current-request-context)\r\n\r\nThe solution leverages the following idea: \r\n\r\nIf we want to cache/reuse the connection, it is enough to cache/reuse the bottom-most handler of the chain (aka `PrimaryHandler`). Other handlers in the chain may be re-instantiated for each unit-of-work scope, so they will have the correct instances of the scoped services injected into them (which is desired by customers).\r\n\r\nI believe new behavior should be opt-in, as there will be more allocations than before.\r\n\r\nHowever, in order to leverage existing scope, it should be passed to `HttpClientFactory` from outside. The factory itself is a singleton, so it doesn\u0027t have access to scopes.\r\n\r\nIn order to do that, we may have an additional scoped service, which will have access to the current unit-of-work scope *and* to the singleton `HttpClientFactory` (which is proposed below). The alternative could be to make users provide the specific scoped `IServiceProvider` to the factory themselves.\r\n\r\n## Proposed API\r\n\r\n```diff\r\nnamespace Microsoft.Extensions.DependencyInjection\r\n{\r\n    public static partial class HttpClientBuilderExtensions\r\n    {\r\n        ...\r\n        public static IHttpClientBuilder SetHandlerLifetime(this IHttpClientBuilder builder, TimeSpan handlerLifetime) { ... }\r\n+       public static IHttpClientBuilder SetPreserveExistingScope(this IHttpClientBuilder builder, bool preserveExistingScope) { ... }\r\n    }\r\n}\r\n\r\nnamespace Microsoft.Extensions.Http\r\n{\r\n    public partial class HttpClientFactoryOptions\r\n    {\r\n        ...\r\n        public TimeSpan HandlerLifetime { get; set; }\r\n+       public bool PreserveExistingScope { get; set; } // default is false = old behavior\r\n    }\r\n}\r\n\r\nnamespace System.Net.Http\r\n{\r\n    // registered in DI as singleton\r\n    public partial interface IHttpClientFactory\r\n    {\r\n        HttpClient CreateClient(string name);\r\n    }\r\n\r\n    // registered in DI as singleton\r\n    public partial interface IHttpMessageHandlerFactory\r\n    {\r\n        HttpMessageHandler CreateHandler(string name);\r\n    }\r\n\r\n+   // registered in DI as scoped\r\n+   public partial interface IScopedHttpClientFactory\r\n+   {\r\n+       HttpClient CreateClient(string name);\r\n+   }\r\n\r\n+   // registered in DI as scoped\r\n+   public partial interface IScopedHttpMessageHandlerFactory\r\n+   {\r\n+       HttpMessageHandler CreateHandler(string name);\r\n+   }\r\n}\r\n```\r\n\r\n## Usage Examples\r\n\r\nFor named clients, user will also need to change the injected factory after opt-in. For typed clients, just opting-in is enough, the magic will happen on its own. \r\n\r\n``` diff\r\n// registration\r\nclass Program\r\n{\r\n    private static void ConfigureServices(HostBuilderContext context, IServiceCollection services)\r\n    {\r\n        services.AddScoped\u003cHandlerWithScopedDependency\u003e();\r\n\r\n        // named client\r\n        services.AddHttpClient(\"github\")\r\n            .AddHttpMessageHandler\u003cHandlerWithScopedDependency\u003e()\r\n+           .SetPreserveExistingScope(true);\r\n\r\n        // typed client\r\n        services.AddHttpClient\u003cIGithubClient, GithubClient\u003e\r\n            .AddHttpMessageHandler\u003cHandlerWithScopedDependency\u003e()\r\n+           .SetPreserveExistingScope(true);\r\n        ...\r\n    }\r\n    ...\r\n}\r\n\r\n// usage\r\nclass Worker : IWorker\r\n{\r\n-   private IHttpClientFactory _clientFactory;\r\n+   private IScopedHttpClientFactory _clientFactory;\r\n    private IGithubClient _githubClient;\r\n\r\n    public Worker(\r\n-       IHttpClientFactory clientFactory,\r\n+       IScopedHttpClientFactory clientFactory,\r\n        IGithubClient githubClient)\r\n    {\r\n        _clientFactory = clientFactory;\r\n        _githubClient = githubClient;\r\n    }\r\n\r\n    public async Task DoWorkWithNamedClientAsync()\r\n    {\r\n        HttpClient client = _clientFactory.CreateClient(\"github\");\r\n        var response = await client.GetStringAsync(GetRepositoriesUrl(username));\r\n        ...\r\n    }\r\n\r\n    public async Task DoWorkWithTypedClientAsync()\r\n    {\r\n        var response = await _githubClient.GetRepositories(username);\r\n        ...\r\n    }\r\n}\r\n\r\n// typed client impl\r\nclass GithubClient : IGithubClient\r\n{\r\n    private HttpClient _client;\r\n\r\n    // client is created by IScopedHttpClientFactory after opt-in\r\n    public GithubClient(HttpClient client)\r\n    {\r\n        _client = client;\r\n    }\r\n\r\n    public async Task\u003cstring\u003e GetRepositories(string username)\r\n    {\r\n        return await _client.GetStringAsync(GetRepositoriesUrl(username));\r\n    }\r\n}\r\n```\r\n\r\n## Alternative Designs\r\n\r\nThe alternative could be to make users provide the specific scoped `IServiceProvider` to the factory themselves. This however will require them to inject `IServiceProvider` to every service they use the factory in. In my opinion, this is a bit messy and will dangerously tempt users to leverage a service locator antipattern.\r\n\r\n``` diff\r\nnamespace System.Net.Http\r\n{\r\n    public partial interface IHttpClientFactory\r\n    {\r\n        HttpClient CreateClient(string name);\r\n+       HttpClient CreateClient(string name, IServiceProvider serviceProvider);\r\n    }\r\n\r\n    public partial interface IHttpMessageHandlerFactory\r\n    {\r\n        HttpMessageHandler CreateHandler(string name);\r\n+       HttpMessageHandler CreateHandler(string name, IServiceProvider serviceProvider);\r\n    }\r\n}\r\n```\r\n\r\nUsage example:\r\n``` diff\r\nclass Worker : IWorker\r\n{\r\n+   private IServiceProvider _serviceProvider;\r\n    private IHttpClientFactory _clientFactory;\r\n\r\n    public Worker(\r\n+       IServiceProvider serviceProvider,\r\n        IHttpClientFactory clientFactory)\r\n    {\r\n+       _serviceProvider = serviceProvider;\r\n        _clientFactory = clientFactory;\r\n    }\r\n\r\n    public async Task DoWorkWithNamedClientAsync()\r\n    {\r\n-       HttpClient client = _clientFactory.CreateClient(\"github\");\r\n+       HttpClient client = _clientFactory.CreateClient(\"github\", _serviceProvider);\r\n        var response = await client.GetStringAsync(GetRepositoriesUrl(username));\r\n        ...\r\n    }\r\n}\r\n```\r\nI also want to mention that I did not consider changing `HttpClientFactory`\u0027s own lifetime (e.g. from singleton to scoped) as it will be too much of a breaking change, e.g. scoped services cannot be injected into singletons, but other singletons can, so if current singleton factory was injected into a singleton somewhere, it will break.\r\n\r\n## Risks\r\n\r\nFor existing usages - the risk is low, because new behavior is opt-in. Existing usages will maintain old behavior.\r\n\r\nUsing `IHttpClientFactory` with `PreserveExistingScope=true`, as well as using `IScopedHttpClientFactory` with `PreserveExistingScope=false` will produce an `InvalidOperationException` to avoid confusing behavior (e.g. no scope to preserve in singleton `IHttpClientFactory`).\r\n\r\nSubstituting or modifying `PrimaryHandler` in case of `PreserveExistingScope=true` will be currently forbidden (`InvalidOperationException` during DI configuration). This is due to inability to assess security risks and avoid unnesessary object creations. `HttpMessageHandlerBuilder.Build()` will be called for each scope and not once in a (primary) handler lifetime as before. If it contains substituting or modifying `PrimaryHandler`, it will not work as expected, but will produce potential security risk and impact performance by creating redundant `PrimaryHandler`s to be thrown away. Addressing the risks of allowing `PrimaryHandler` modification will require additional API change.\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eCarnaViire\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`api-suggestion`, `area-Extensions-HttpClientFactory`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2021-01-17T23:01:19Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc2MjIyMzUwMQ==",
                                           "createdAt":  "2021-01-18T12:35:56Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "davidfowl",
                                           "body":  "👀",
                                           "updatedAt":  "2021-01-18T12:35:56Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc2MzAzODkxMg==",
                                           "createdAt":  "2021-01-19T18:33:48Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "halter73",
                                           "body":  "`IScopedHttpClientFactory` and `IScopedHttpMessageHandlerFactory` are interesting. My knee-jerk reaction is that we shouldn\u0027t add these interfaces because there\u0027s no enforcement of the lifetime. What stops someone from registering an `IScopedHttpClientFactory` as a singleton or transient service?\r\n\r\n\u003e If we want to cache/reuse the connection, it is enough to cache/reuse the bottom-most handler of the chain (aka PrimaryHandler). Other handlers in the chain may be re-instantiated for each unit-of-work scope, so they will have the correct instances of the scoped services injected into them (which is desired by customers).\r\n\r\nI guess what makes this a bit unusual in that you want the ability to layer scoped decorators on top of singleton services. Both the singleton and scoped decorators need to implement what\u0027s functionally the same service interface, so we\u0027re not left with many options. [1] I would like to see an end-to-end example for how these scoped decorators would be defined and configured.\r\n\r\nService interfaces with a specific intended lifetime could be a good use case for a Roslyn analyzer. We could add attributes to service interfaces indicating what the intended lifetime is (if any) and warn if it\u0027s registered differently. We could do something similar for service implementations.\r\n\r\n1: It would be nice if our DI system made decorating services easier in general. Today, you have to create custom interfaces/classes for registering the decorated type.\r\n",
                                           "updatedAt":  "2021-01-19T18:33:48Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc2MzE3MzIyOQ==",
                                           "createdAt":  "2021-01-19T22:08:45Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "CarnaViire",
                                           "body":  "You may see the actual implementation of `IScopedHttpClientFactory` in my PR [here](https://github.com/dotnet/runtime/pull/43660/files#diff-52f169cf34b4b0993d4958008857bc00892007aef39c98bc261826a8898f270d) if that\u0027s what you were asking about @halter73 \r\n\r\nI agree, the naming pains me a little bit in a way you say, too. But I honestly couldn\u0027t come up with anything better, as the purpose of this service was to be scoped - to be able to provide scope where it\u0027s needed, opposed to singleton `IHttpClientFactory`. \r\n\r\nBut that\u0027s also touching on an interesting topic. If a person purposely refuses our default implementation by registering their own, in what way and how are we responsible for it?\r\n\r\nIf we are against allowing to substitute this one, we can always forbid it by registering via `AddScoped` instead of `TryAddScoped`, isn\u0027t that right?",
                                           "updatedAt":  "2021-01-19T22:08:45Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc2Mzk5MjcwMw==",
                                           "createdAt":  "2021-01-20T22:27:05Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOC_a-jA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "harshavarg",
                                                                               "createdAt":  "2021-01-21T08:55:42Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "pedroarmando",
                                                                               "createdAt":  "2023-06-29T14:31:08Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  2
                                                         },
                                           "author":  "zmj",
                                           "body":  "+1 for the use case. I wanted to inject some request-scoped values into a delegating handler wrapping the base handler and didn\u0027t find a nice way to do that with the current configuration options for HttpClientFactory.",
                                           "updatedAt":  "2021-01-20T22:27:05Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc3ODIxNzcxMQ==",
                                           "createdAt":  "2021-02-12T14:09:30Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "CarnaViire",
                                           "body":  "*Edit:* Changed main proposal to be about transient `HttpClientFactory` as there\u0027s no need for an additional interface in this case. Moved `IScopedHttpClientFactory` to alternatives. Removed option with `IServiceProvider` parameter completely as it is both a bad practice and inconvenient to use.",
                                           "updatedAt":  "2021-02-12T14:09:30Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc4OTE1OTQzNw==",
                                           "createdAt":  "2021-03-02T19:33:50Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOBiDIeA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "karelz",
                                                                               "createdAt":  "2021-03-03T11:49:05Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "CarnaViire",
                                           "body":  "While discussing this API proposal we\u0027ve found some additional complications.\r\n\r\nUsers that want to use `PreserveExistingScope` scenario might also want to set some Primary Handler parameters like `MaxConnectionsPerServer` or `SslOptions` at the same time, so we need to address that.\r\n\r\nFor users to be able to do that, we will need to separate configuring a primary handler from configuring the rest of the chain. Right now, all handlers configuration is stored in a single collection in `HttpClientFactoryOptions`:\r\n`IList\u003cAction\u003cHttpMessageHandlerBuilder\u003e\u003e HttpMessageHandlerBuilderActions`\r\n\r\nAll handler configuration from methods like `AddHttpMessageHandler` and `ConfigurePrimaryHttpMessageHandler` is translated into actions on `HttpMessageHandlerBuilder`. This `HttpMessageHandlerBuilder` contains both a list of additional message handlers and a primary handler (to build a chain from them in the end). This way a chain is always created as a whole, but we want to be able to create the parts separately.\r\n\r\n\r\n*Additional API change no.1:*\r\nSeparate primary handler changes in another place in `HttpClientFactoryOptions`. Add e.g.\r\n`IList\u003cAction\u003cHttpMessageHandlerBuilder\u003e\u003e PrimaryHttpMessageHandlerBuilderActions`\r\nor even\r\n`Function\u003cIServiceProvider, HttpMessageHandler\u003e PrimaryHttpMessageHandlerFactory`.\r\n\r\n\r\nAfter that, we want to put all primary handler changes into a new collection and additional handler changes into an old collection.\r\n\r\nHowever, this separation is not straightforward. While `AddHttpMessageHandler` and `ConfigurePrimaryHttpMessageHandler` are easy, there are some APIs in `HttpClientFactory` that make it impossible to classify the changes. The APIs I\u0027m speaking about are:\r\n1) `public static IHttpClientBuilder ConfigureHttpMessageHandlerBuilder(this IHttpClientBuilder builder, Action\u003cHttpMessageHandlerBuilder\u003e configureBuilder)`\r\n(this one can be called upon `HttpClient` configuration)\r\nand\r\n2) `public interface IHttpMessageHandlerBuilderFilter` with a method `Action\u003cHttpMessageHandlerBuilder\u003e Configure(Action\u003cHttpMessageHandlerBuilder\u003e next);`\r\n(for this, user can create their own implementation and register it in DI)\r\n\r\nThese both expose `HttpMessageHandlerBuilder` itself. As soon as any of these APIs are used, we can no longer decouple changes of the primary handler from changes of additional message handlers — because both of them may be changed in a single action.\r\n\r\nThat means we cannot support these APIs fully. There is no good way to treat them – see some options below:\r\n\r\n\r\n*Additional API change no.2:*\r\nThe possible options are:\r\n- Deprecate `ConfigureHttpMessageHandlerBuilder` and `IHttpMessageHandlerBuilderFilter` and replace them with new APIs to provide functionality of modifying the list of additional handlers (e.g. put a handler into a specific position in a list)\r\n- Make `ConfigureHttpMessageHandlerBuilder` throw when per-request scope is enabled for `HttpMessageHandlers` - this doesn\u0027t fix `IHttpMessageHandlerBuilderFilter` problem\r\n- Make PrimaryHandler modifications throw at runtime when per-request scope is enabled for `HttpMessageHandlers`\r\n- Ignore any changes to PrimaryHandler – let the objects be allocated, but never used by us (we would overwrite it with the shared/cached primary handler)\r\n\r\n*Conclusion:*\r\nThe combined API changes are quite extensive which is more than what we were planning for solving the initial issue. As a result, we are moving the proposal out of 6.0 to Future. We can reconsider the prioritization when there are more customers asking for this, or if we come up with better solution to the problem.",
                                           "updatedAt":  "2021-03-02T19:33:50Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg2NTQxNTgzNw==",
                                           "createdAt":  "2021-06-21T23:43:06Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "zmj",
                                           "body":  "@CarnaViire given the difficulties you\u0027ve outlined in modifying the builder methods, maybe it\u0027s worth considering what a consumer-side (meaning the code consuming an HttpClient produced by the factory) would look like? My workaround was an extension method `public static void AddDelegatingHandler(this HttpClient httpClient, Func\u003cHttpMessageHandler, DelegatingHandler\u003e createDelegatingHandler)` that is called by a scoped service to inject request-scoped handling.",
                                           "updatedAt":  "2021-06-21T23:43:06Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc47yM2J",
                                           "createdAt":  "2021-12-30T12:50:26Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "kaluznyt",
                                           "body":  "Hi, after some hours of struggling to make that work, I found this issue describing the thing I\u0027m encountering, namely scoped service dependency in custom delegating handler. Is this something being worked on or abandoned ?",
                                           "updatedAt":  "2021-12-30T12:50:26Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc48Mr-o",
                                           "createdAt":  "2022-01-11T13:21:13Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "CarnaViire",
                                           "body":  "@kaluznyt it is not abandoned, but rather deprioritized at the moment, as there\u0027s not enough customer ask.\r\n\r\nIf you are interested in the feature, please upvote the top post, it would help us prioritize!",
                                           "updatedAt":  "2022-01-11T13:21:13Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc48M-DT",
                                           "createdAt":  "2022-01-11T14:44:47Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "kaluznyt",
                                           "body":  "@CarnaViire  thanks for the response! ",
                                           "updatedAt":  "2022-01-11T14:44:47Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5BkxR5",
                                           "createdAt":  "2022-04-15T14:56:47Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Cobra86",
                                           "body":  "I\u0027ve the same issue and my project is using blazor server .net 6",
                                           "updatedAt":  "2022-04-15T14:56:47Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5GFIFG",
                                           "createdAt":  "2022-07-06T03:53:40Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOClmDAA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "CarnaViire",
                                                                               "createdAt":  "2022-07-07T12:40:08Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "DillonN",
                                           "body":  "Chiming in with another use case here, if it\u0027s useful\r\n\r\nWe have a message handler that sets some signature headers, and it requires state from a scoped service. Since we have lots of other configuration going through `IHttpClientBuilder`, we made a workaround that kept compatibility but required re-implementing some internal logic from `Microsoft.Extensions.Http`\r\n\r\nThe workaround is to use a custom method instead of `AddHttpClient\u003cT\u003e`, to capture services from when the typed client is resolved. Then we use `IHttpClientFactory.CreateHandler` to get the bulk of the handler pipeline and wrap it in the stateful handler (which can now use scoped services from the \"good\" service provider). After that it\u0027s pretty much just the same logic as in `DefaultHttpClientFactory.CreateClient`, and a call to `ITypedHttpClientFactory\u003cT\u003e.CreateClient` for the return\r\n\r\n~~This is causing issues however if any of the standard handlers configured via `IHttpClientBuilder` need to mutate the outgoing request. Since the signature handler is outer-most, such mutations result in a signature mismatch. I\u0027ve thought of modifying the workaround so that the outer-most handler just passes state via `HttpRequestMessage.Options` to an inner handler, which can calculate signatures at the end.. either that or just give in to reflection at this point. (We are not using ASP.NET Core so `IHttpContextAccessor` isn\u0027t an option).~~ I did end up swapping to having a dedicated scope capturing outer handler that passes down scope via `HttpRequestMessage.Options`\r\n\r\nNeedless to say, official support for this would be very much appreciated!",
                                           "updatedAt":  "2023-02-26T22:39:59Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5V9TMw",
                                           "createdAt":  "2023-02-23T17:08:14Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOC3m8FQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "CarnaViire",
                                                                               "createdAt":  "2023-03-10T18:17:08Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "bfriesen",
                                           "body":  "Like @Cobra86, I have the same issue. I have a Blazor server-side project that needs a message handler to have access to something registered as Scoped. Specifically, I need to add a message handler that has access to the scoped-registered `TokenProvider` [described in the Blazor server-side documentation](https://learn.microsoft.com/en-us/aspnet/core/blazor/security/server/additional-scenarios?view=aspnetcore-7.0#pass-tokens-to-a-blazor-server-app).\r\n\r\nMy workaround is to scoped-register a custom implementation of `IHttpClientFactory` that behaves like just like the [default implementation](https://github.com/dotnet/dotnet/blob/b8bc661a7429baa89070f3bee636b7fbc1309489/src/runtime/src/libraries/Microsoft.Extensions.Http/src/DefaultHttpClientFactory.cs#L98-L112), except it adds my custom message handler as the outer-most message handler of the resulting `HttpClient`.\r\n\r\n```c#\r\npublic class AuthenticatingHttpClientFactory : IHttpClientFactory\r\n{\r\n    private readonly TokenProvider _tokenProvider;\r\n    private readonly IHttpMessageHandlerFactory _messageHandlerFactory;\r\n    private readonly IOptionsMonitor\u003cHttpClientFactoryOptions\u003e _optionsMonitor;\r\n\r\n    public AuthenticatingHttpClientFactory(\r\n        IHttpMessageHandlerFactory messageHandlerFactory,\r\n        TokenProvider tokenProvider,\r\n        IOptionsMonitor\u003cHttpClientFactoryOptions\u003e optionsMonitor)\r\n    {\r\n        _messageHandlerFactory = messageHandlerFactory;\r\n        _tokenProvider = tokenProvider;\r\n        _optionsMonitor = optionsMonitor;\r\n    }\r\n\r\n    public HttpClient CreateClient(string name)\r\n    {\r\n        ArgumentNullException.ThrowIfNull(name, nameof(name));\r\n\r\n        var handler = _messageHandlerFactory.CreateHandler(name);\r\n        \r\n        // If we have an access token, add an outermost message handler that takes care of authentication.\r\n        if (_tokenProvider.AccessToken != null)\r\n            handler = new AuthenticatingMessageHandler(_tokenProvider, handler);\r\n        \r\n        var client = new HttpClient(handler, disposeHandler: false);\r\n\r\n        HttpClientFactoryOptions options = _optionsMonitor.Get(name);\r\n        for (int i = 0; i \u003c options.HttpClientActions.Count; i++)\r\n        {\r\n            options.HttpClientActions[i](client);\r\n        }\r\n\r\n        return client;\r\n    }\r\n}\r\n```\r\n\r\nThis extension method replaces [the `AddHttpClient` extension method from Microsoft.Extensions.Http](https://github.com/dotnet/dotnet/blob/b8bc661a7429baa89070f3bee636b7fbc1309489/src/runtime/src/libraries/Microsoft.Extensions.Http/src/DependencyInjection/HttpClientFactoryServiceCollectionExtensions.cs#L105-L116).\r\n\r\n```c#\r\npublic static IHttpClientBuilder AddScopedAuthenticatingHttpClient(\r\n    this IServiceCollection services,\r\n     string name,\r\n     Action\u003cHttpClient\u003e configureClient)\r\n{\r\n    services.AddHttpClient();\r\n\r\n    // Replace the registration for IHttpClientFactory...\r\n    var httpClientFactoryRegistration = services.FirstOrDefault(service =\u003e service.ServiceType == typeof(IHttpClientFactory));\r\n    if (httpClientFactoryRegistration is not null)\r\n        services.Remove(httpClientFactoryRegistration);\r\n\r\n    // ...with a scoped registration for our authenticating factory.\r\n    services.AddScoped\u003cIHttpClientFactory, AuthenticatingHttpClientFactory\u003e();\r\n\r\n    var builder = new DefaultHttpClientBuilder(services, name);\r\n    builder.ConfigureHttpClient(configureClient);\r\n    return builder;\r\n}\r\n```\r\n\r\nThe custom message handler itself isn\u0027t very special, it just needs has access to the scoped-registered `TokenProvider`.\r\n\r\n```c#\r\npublic class AuthenticatingMessageHandler : DelegatingHandler\r\n{\r\n    private readonly TokenProvider _tokenProvider;\r\n\r\n    public AuthenticatingMessageHandler(TokenProvider tokenProvider, HttpMessageHandler innerHandler)\r\n        : base(innerHandler)\r\n    {\r\n        _tokenProvider = tokenProvider;\r\n    }\r\n\r\n    protected override async Task\u003cHttpResponseMessage\u003e SendAsync(HttpRequestMessage request, CancellationToken cancellationToken)\r\n    {\r\n        request.Headers.Authorization = new AuthenticationHeaderValue(\"Bearer\", _tokenProvider.AccessToken);\r\n\r\n        return await base.SendAsync(request, cancellationToken);\r\n    }\r\n}\r\n```",
                                           "updatedAt":  "2023-02-23T17:08:14Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5W2Okm",
                                           "createdAt":  "2023-03-06T21:51:02Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOC3m8GQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "CarnaViire",
                                                                               "createdAt":  "2023-03-10T18:17:15Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "brendonparker",
                                           "body":  "I ran into this today. I had some places in code that were building an entirely new `ServiceProvider`. I benchmarked and noticed the overhead, mostly in my loading of remote configuration. So thought to switch it to a single `ServiceProvider` and leverage scopes. This is for a multi-tenant scenario where I effectively want to control some \"context\" for the tenant. Then I noticed my use of `IHttpClientFactory` broke since values of this \"context\u0027 were null. Then eventually figured out my issue.\r\n\r\nIts basically the same use case that is described above by @bfriesen ",
                                           "updatedAt":  "2023-03-06T21:51:02Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5XYx1i",
                                           "createdAt":  "2023-03-13T13:07:39Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOC4gUGg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "CarnaViire",
                                                                               "createdAt":  "2023-03-24T15:01:30Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "tallichet",
                                           "body":  "We are also facing the need to have \"by Scope\" authentication in the Message handler, to be able for our Blazor Server Side to use Refit and all the HttpClientFactory.",
                                           "updatedAt":  "2023-03-13T13:07:39Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5YZNY2",
                                           "createdAt":  "2023-03-24T15:33:49Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODQpghQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "brendonparker",
                                                                               "createdAt":  "2023-03-24T15:53:30Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "DillonN",
                                                                               "createdAt":  "2023-03-28T03:21:13Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "marius-stanescu",
                                                                               "createdAt":  "2023-06-28T05:46:42Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Seabizkit",
                                                                               "createdAt":  "2023-12-27T17:53:33Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  4
                                                         },
                                           "author":  "CarnaViire",
                                           "body":  "Thank you for your insights and workarounds, @DillonN, @bfriesen, @brendonparker, @tallichet!\r\n\r\nThis is rather complicated topic with a non-obvious solution. Even the implementation will be rather complex (once we have agreement on a solution).\r\nGiven all the workload on our team, I don\u0027t see this issue fitting into .NET 8.0. I still want to keep it open in Future and continue working on it after .NET 8.0.\r\n\r\nAs a short-term solution, we will add a workaround into HttpClientFactory docs. That will make it easier for other users to find it.\r\n\r\nIf you are interested in the feature, please upvote the top post, it would help us prioritize!",
                                           "updatedAt":  "2023-03-24T15:33:49Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5amF26",
                                           "createdAt":  "2023-04-24T11:10:46Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODXPRbg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "silkfire",
                                                                               "createdAt":  "2024-02-18T20:24:40Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "CarnaViire",
                                           "body":  "Workaround documented in https://learn.microsoft.com/en-us/dotnet/core/extensions/httpclient-factory#message-handler-scopes-in-ihttpclientfactory",
                                           "updatedAt":  "2023-04-24T11:10:46Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5hhLwp",
                                           "createdAt":  "2023-07-14T16:22:32Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODBXnTw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "ROCKET",
                                                                               "user":  "DillonN",
                                                                               "createdAt":  "2023-07-21T04:46:56Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "CarnaViire",
                                           "body":  "API changes introduced in https://github.com/dotnet/runtime/issues/87914 pretty much cover what was mentioned in https://github.com/dotnet/runtime/issues/47091#issuecomment-789159437 🥳 While the issue still remains in the Future bucket, this does bring it closer.",
                                           "updatedAt":  "2023-07-14T16:22:32Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5v4TnS",
                                           "createdAt":  "2024-01-04T12:38:02Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "CarnaViire",
                                           "body":  "Given the discussion in https://github.com/dotnet/runtime/issues/35987 I will optimistically put this to 9.0 as well.",
                                           "updatedAt":  "2024-01-04T12:38:02Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6E6TRC",
                                           "createdAt":  "2024-07-16T02:20:39Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "CarnaViire",
                                           "body":  "Sorry folks -- this will not fit into 9.0 anymore, even the case when the Keyed DI infra is used 😢\r\n\r\nSome info here https://github.com/dotnet/runtime/issues/89755#issuecomment-2227042391",
                                           "updatedAt":  "2024-07-16T02:20:39Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6F2Oga",
                                           "createdAt":  "2024-07-23T15:37:08Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "julealgon",
                                           "body":  "Is this yet another MEDI-related hack for lack of functionality in the container: in this case, custom object lifetimes?",
                                           "updatedAt":  "2024-07-23T15:37:08Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6HXtwW",
                                           "createdAt":  "2024-08-06T12:11:26Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Seabizkit",
                                           "body":  "Ironically;\r\n\r\nI posted saying it should respect the life time of the scope it was created in, but:\r\n\r\nWhen consuming via Lambda or other applications, I actually want/like the existing behavior.\r\n\r\nbut when consumed via plugin, \r\n\r\nI want to basically ensure everything is disposed, it become confusing when things are still being held onto, and i cant figure out why\r\n\r\nI think keep the existing behavior as the **default**, as to many existing apps, will break and some of opt in for, if you want it to change the life time to be scoped.\r\n\r\nSome of the proposals seem neat.",
                                           "updatedAt":  "2024-08-06T12:11:26Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6hKPOY",
                                           "createdAt":  "2025-03-06T13:11:55Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jvmlet",
                                           "body":  "Suggestion : extend `IHttpClientFactory::CreateClient` with additional arbitrary parameters that will be passed to `AddHttpClient` callback  as well as to `AddHttpMessageHandler` calback : \n```c#\n\npublic interface IHttpClientFactory  {\n    HttpClient CreateClient(string name,\n    IDictionary\u003cstring,object\u003e? additionalParametes = null //optional additional arguments \n);\n }\n\n//setup\nservices.AddHttpClient(\"someName\", (sp,client, additionalParametes)=\u003e{\n\n}))\n.AddHttpMessageHandler( (sp,additionalParametes)=\u003e{\n\n\n})\n\n//usage\n_httpClientFactory.CreateClient(\"someName\" ,new Dictionary{\n{\"currentScope\",childScope},\n{\"otherParam\",1}\n});\n\n````\n\nThis approach not only answers the requirement of the issue , but also provides more  context for creation of http client. For example, it allows to implement filter for http headers propagattion handler when creating impersonated client where header propagation should not  happen. All this without breaking existing behavior and providing maximum flexibility for developers. \nThoughts, @CarnaViire ?\n",
                                           "updatedAt":  "2025-03-07T17:07:26Z"
                                       }
                                   ],
                         "totalCount":  24
                     },
        "title":  "Add API to provide existing DI scope to HttpClientFactory",
        "labels":  [
                       "api-suggestion",
                       "area-Extensions-HttpClientFactory"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/47672",
        "createdAt":  "2021-01-30T06:08:59Z",
        "number":  47672,
        "author":  "moravas",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOC7GzWQ==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "fuszenecker",
                                            "createdAt":  "2021-02-05T09:05:15Z"
                                        },
                                        {
                                            "content":  "CONFUSED",
                                            "user":  "AYss",
                                            "createdAt":  "2022-02-25T09:25:05Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "subhadlearner",
                                            "createdAt":  "2022-09-20T07:50:50Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "sudoudaisuke",
                                            "createdAt":  "2022-11-13T00:28:38Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "pcfco-kmason",
                                            "createdAt":  "2024-02-08T20:06:59Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "asindarov",
                                            "createdAt":  "2024-09-18T11:02:24Z"
                                        }
                                    ],
                          "totalCount":  6
                      },
        "updatedAt":  "2021-06-16T15:56:13Z",
        "body":  "Hi,\r\n\r\nI have a .net core 3.1 based AWS Lambda function with 5 min timeout, that performs some http download \u0026 data transform \u0026 db write.\r\nThe problem is that in same cases, and it is very nondeterministic, an HttpMessageHandler clean-up cycle is fired and the AWS Lambda will time-out. Below is the most recent running where the clean-up takes about 4 minute:\r\n\r\n```\r\n2021-01-30 05:14:58,902 [4] DEBUG Microsoft.Extensions.Http.DefaultHttpClientFactory [(null)] - HttpMessageHandler expired after 120000ms for client \u0027\u0027\r\n2021-01-30 05:15:08,903 [4] DEBUG Microsoft.Extensions.Http.DefaultHttpClientFactory [(null)] - Starting HttpMessageHandler cleanup cycle with 1 items\r\n2021-01-30 05:15:08,903 [4] DEBUG Microsoft.Extensions.Http.DefaultHttpClientFactory [(null)] - Ending HttpMessageHandler cleanup cycle after 0.002ms - processed: 0 items - remaining: 1 items\r\n2021-01-30 05:15:18,904 [9] DEBUG Microsoft.Extensions.Http.DefaultHttpClientFactory [(null)] - Starting HttpMessageHandler cleanup cycle with 1 items\r\n2021-01-30 05:15:18,905 [9] DEBUG Microsoft.Extensions.Http.DefaultHttpClientFactory [(null)] - Ending HttpMessageHandler cleanup cycle after 0.002ms - processed: 0 items - remaining: 1 items\r\n2021-01-30 05:15:28,922 [9] DEBUG Microsoft.Extensions.Http.DefaultHttpClientFactory [(null)] - Starting HttpMessageHandler cleanup cycle with 1 items\r\n2021-01-30 05:15:28,923 [9] DEBUG Microsoft.Extensions.Http.DefaultHttpClientFactory [(null)] - Ending HttpMessageHandler cleanup cycle after 0.0024ms - processed: 0 items - remaining: 1 items\r\n2021-01-30 05:15:38,925 [9] DEBUG Microsoft.Extensions.Http.DefaultHttpClientFactory [(null)] - Starting HttpMessageHandler cleanup cycle with 1 items\r\n2021-01-30 05:15:38,926 [9] DEBUG Microsoft.Extensions.Http.DefaultHttpClientFactory [(null)] - Ending HttpMessageHandler cleanup cycle after 0.0022ms - processed: 0 items - remaining: 1 items\r\n2021-01-30 05:15:48,926 [9] DEBUG Microsoft.Extensions.Http.DefaultHttpClientFactory [(null)] - Starting HttpMessageHandler cleanup cycle with 1 items\r\n2021-01-30 05:15:48,927 [9] DEBUG Microsoft.Extensions.Http.DefaultHttpClientFactory [(null)] - Ending HttpMessageHandler cleanup cycle after 0.0021ms - processed: 0 items - remaining: 1 items\r\n2021-01-30 05:15:58,927 [9] DEBUG Microsoft.Extensions.Http.DefaultHttpClientFactory [(null)] - Starting HttpMessageHandler cleanup cycle with 1 items\r\n2021-01-30 05:15:58,927 [9] DEBUG Microsoft.Extensions.Http.DefaultHttpClientFactory [(null)] - Ending HttpMessageHandler cleanup cycle after 0.0023ms - processed: 0 items - remaining: 1 items\r\n2021-01-30 05:16:08,927 [9] DEBUG Microsoft.Extensions.Http.DefaultHttpClientFactory [(null)] - Starting HttpMessageHandler cleanup cycle with 1 items\r\n2021-01-30 05:16:08,927 [9] DEBUG Microsoft.Extensions.Http.DefaultHttpClientFactory [(null)] - Ending HttpMessageHandler cleanup cycle after 0.0018ms - processed: 0 items - remaining: 1 items\r\n2021-01-30 05:16:18,928 [9] DEBUG Microsoft.Extensions.Http.DefaultHttpClientFactory [(null)] - Starting HttpMessageHandler cleanup cycle with 1 items\r\n2021-01-30 05:16:18,928 [9] DEBUG Microsoft.Extensions.Http.DefaultHttpClientFactory [(null)] - Ending HttpMessageHandler cleanup cycle after 0.0023ms - processed: 0 items - remaining: 1 items\r\n2021-01-30 05:16:28,929 [9] DEBUG Microsoft.Extensions.Http.DefaultHttpClientFactory [(null)] - Starting HttpMessageHandler cleanup cycle with 1 items\r\n2021-01-30 05:16:28,929 [9] DEBUG Microsoft.Extensions.Http.DefaultHttpClientFactory [(null)] - Ending HttpMessageHandler cleanup cycle after 0.002ms - processed: 0 items - remaining: 1 items\r\n2021-01-30 05:16:38,927 [9] DEBUG Microsoft.Extensions.Http.DefaultHttpClientFactory [(null)] - Starting HttpMessageHandler cleanup cycle with 1 items\r\n2021-01-30 05:16:38,927 [9] DEBUG Microsoft.Extensions.Http.DefaultHttpClientFactory [(null)] - Ending HttpMessageHandler cleanup cycle after 0.0019ms - processed: 0 items - remaining: 1 items\r\n2021-01-30 05:16:48,928 [7] DEBUG Microsoft.Extensions.Http.DefaultHttpClientFactory [(null)] - Starting HttpMessageHandler cleanup cycle with 1 items\r\n2021-01-30 05:16:48,928 [7] DEBUG Microsoft.Extensions.Http.DefaultHttpClientFactory [(null)] - Ending HttpMessageHandler cleanup cycle after 0.0021ms - processed: 0 items - remaining: 1 items\r\n2021-01-30 05:16:58,928 [7] DEBUG Microsoft.Extensions.Http.DefaultHttpClientFactory [(null)] - Starting HttpMessageHandler cleanup cycle with 1 items\r\n2021-01-30 05:16:58,929 [7] DEBUG Microsoft.Extensions.Http.DefaultHttpClientFactory [(null)] - Ending HttpMessageHandler cleanup cycle after 0.0021ms - processed: 0 items - remaining: 1 items\r\n2021-01-30 05:17:08,929 [7] DEBUG Microsoft.Extensions.Http.DefaultHttpClientFactory [(null)] - Starting HttpMessageHandler cleanup cycle with 1 items\r\n2021-01-30 05:17:08,930 [7] DEBUG Microsoft.Extensions.Http.DefaultHttpClientFactory [(null)] - Ending HttpMessageHandler cleanup cycle after 0.0022ms - processed: 0 items - remaining: 1 items\r\n2021-01-30 05:17:18,931 [9] DEBUG Microsoft.Extensions.Http.DefaultHttpClientFactory [(null)] - Starting HttpMessageHandler cleanup cycle with 1 items\r\n2021-01-30 05:17:18,931 [9] DEBUG Microsoft.Extensions.Http.DefaultHttpClientFactory [(null)] - Ending HttpMessageHandler cleanup cycle after 0.0023ms - processed: 0 items - remaining: 1 items\r\n2021-01-30 05:17:28,931 [9] DEBUG Microsoft.Extensions.Http.DefaultHttpClientFactory [(null)] - Starting HttpMessageHandler cleanup cycle with 1 items\r\n2021-01-30 05:17:28,931 [9] DEBUG Microsoft.Extensions.Http.DefaultHttpClientFactory [(null)] - Ending HttpMessageHandler cleanup cycle after 0.0024ms - processed: 0 items - remaining: 1 items\r\n2021-01-30 05:17:38,933 [9] DEBUG Microsoft.Extensions.Http.DefaultHttpClientFactory [(null)] - Starting HttpMessageHandler cleanup cycle with 1 items\r\n2021-01-30 05:17:38,934 [9] DEBUG Microsoft.Extensions.Http.DefaultHttpClientFactory [(null)] - Ending HttpMessageHandler cleanup cycle after 0.0024ms - processed: 0 items - remaining: 1 items\r\n2021-01-30 05:17:48,934 [9] DEBUG Microsoft.Extensions.Http.DefaultHttpClientFactory [(null)] - Starting HttpMessageHandler cleanup cycle with 1 items\r\n2021-01-30 05:17:48,935 [9] DEBUG Microsoft.Extensions.Http.DefaultHttpClientFactory [(null)] - Ending HttpMessageHandler cleanup cycle after 0.002ms - processed: 0 items - remaining: 1 items\r\n2021-01-30 05:17:58,943 [9] DEBUG Microsoft.Extensions.Http.DefaultHttpClientFactory [(null)] - Starting HttpMessageHandler cleanup cycle with 1 items\r\n2021-01-30 05:17:58,943 [9] DEBUG Microsoft.Extensions.Http.DefaultHttpClientFactory [(null)] - Ending HttpMessageHandler cleanup cycle after 0.0018ms - processed: 0 items - remaining: 1 items\r\n2021-01-30 05:18:08,945 [9] DEBUG Microsoft.Extensions.Http.DefaultHttpClientFactory [(null)] - Starting HttpMessageHandler cleanup cycle with 1 items\r\n2021-01-30 05:18:08,946 [9] DEBUG Microsoft.Extensions.Http.DefaultHttpClientFactory [(null)] - Ending HttpMessageHandler cleanup cycle after 0.0023ms - processed: 0 items - remaining: 1 items\r\n2021-01-30 05:18:18,947 [9] DEBUG Microsoft.Extensions.Http.DefaultHttpClientFactory [(null)] - Starting HttpMessageHandler cleanup cycle with 1 items\r\n2021-01-30 05:18:18,947 [9] DEBUG Microsoft.Extensions.Http.DefaultHttpClientFactory [(null)] - Ending HttpMessageHandler cleanup cycle after 0.0021ms - processed: 0 items - remaining: 1 items\r\n2021-01-30 05:18:28,948 [9] DEBUG Microsoft.Extensions.Http.DefaultHttpClientFactory [(null)] - Starting HttpMessageHandler cleanup cycle with 1 items\r\n2021-01-30 05:18:28,949 [9] DEBUG Microsoft.Extensions.Http.DefaultHttpClientFactory [(null)] - Ending HttpMessageHandler cleanup cycle after 0.002ms - processed: 0 items - remaining: 1 items\r\n2021-01-30 05:18:38,950 [9] DEBUG Microsoft.Extensions.Http.DefaultHttpClientFactory [(null)] - Starting HttpMessageHandler cleanup cycle with 1 items\r\n2021-01-30 05:18:38,950 [9] DEBUG Microsoft.Extensions.Http.DefaultHttpClientFactory [(null)] - Ending HttpMessageHandler cleanup cycle after 0.0026ms - processed: 0 items - remaining: 1 items\r\n2021-01-30 05:18:48,951 [9] DEBUG Microsoft.Extensions.Http.DefaultHttpClientFactory [(null)] - Starting HttpMessageHandler cleanup cycle with 1 items\r\n2021-01-30 05:18:48,951 [9] DEBUG Microsoft.Extensions.Http.DefaultHttpClientFactory [(null)] - Ending HttpMessageHandler cleanup cycle after 0.0027ms - processed: 0 items - remaining: 1 items\r\n2021-01-30 05:18:58,955 [7] DEBUG Microsoft.Extensions.Http.DefaultHttpClientFactory [(null)] - Starting HttpMessageHandler cleanup cycle with 1 items\r\n2021-01-30 05:18:58,955 [7] DEBUG Microsoft.Extensions.Http.DefaultHttpClientFactory [(null)] - Ending HttpMessageHandler cleanup cycle after 0.0023ms - processed: 0 items - remaining: 1 items\r\nEND RequestId: 9af6e269-5aa7-5515-b32d-bae7b7fe2e95\r\nREPORT RequestId: 9af6e269-5aa7-5515-b32d-bae7b7fe2e95\tDuration: 300087.98 ms\tBilled Duration: 300000 ms\tMemory Size: 1024 MB\tMax Memory Used: 261 MB\r\n```\r\n\r\nBelow I try to collect the relevant part of my code how I use HTTPClient and IHTTPClientFactory:\r\nI tried to disable HTTPMessageHandler rotation, as you see without success. Due to would be a short running AWS LAmbda function, I shouldn\u0027t lost any relevant functionlaty (DNS update)\r\n\r\nSetting up DI:\r\n```c#\r\n      services.AddLogging();\r\n      // Set LifeTime to infinite will disable handler rotation -\u003e don\u0027t respond to DNS changes\r\n      services.AddHttpClient\u003cIDownloader, Downloader\u003e().SetHandlerLifetime(Timeout.InfiniteTimeSpan);\r\n      services.AddSingleton\u003cILoggerFactory\u003e(loggerFactory);\r\n      services.AddTransient\u003cIDownloader, Downloader\u003e();\r\n      services.AddTransient\u003cIReportParser, ReportParser\u003e();\r\n```\r\n\r\nThe Downloader\u0027s source:\r\n```c#\r\n    public class Downloader : IDownloader\r\n    {\r\n        private readonly ILogger\u003cDownloader\u003e _logger;\r\n        private readonly IHttpClientFactory _clientFactory;\r\n        public Downloader(ILogger\u003cDownloader\u003e logger, IHttpClientFactory clientFactory)\r\n        {\r\n            _logger = logger;\r\n            _clientFactory = clientFactory;\r\n        }\r\n        public async Task\u003cStream\u003e DownloadStream(Uri uri)\r\n        {\r\n            _logger.LogTrace(uri.ToString());\r\n            var client = _clientFactory.CreateClient();\r\n            return await client.GetStreamAsync(uri);\r\n        }\r\n    }\r\n```\r\n\r\nAnd it\u0027s usage:\r\n```c#\r\n    private readonly IDownloader _downloader;\r\n    private readonly ILogger\u003cReportParser\u003e _logger;\r\n    public ReportParser(ILogger\u003cReportParser\u003e logger, IDownloader downloader)\r\n    {\r\n        _logger = logger;\r\n        _downloader = downloader;\r\n    }\r\n```\r\n\r\nThe environment:\r\nUbuntu 18.04\r\nVS Code 1.52.1\r\n.NET Core:\r\ndotnet --info\r\n.NET Core SDK (reflecting any global.json):\r\n Version:   3.1.405\r\n Commit:    3fae16e62e\r\n\r\nRuntime Environment:\r\n OS Name:     ubuntu\r\n OS Version:  18.04\r\n OS Platform: Linux\r\n RID:         ubuntu.18.04-x64\r\n Base Path:   /usr/share/dotnet/sdk/3.1.405/\r\n\r\nHost (useful for support):\r\n  Version: 3.1.11\r\n  Commit:  f5eceb8105\r\n\r\n.NET Core SDKs installed:\r\n  3.1.405 [/usr/share/dotnet/sdk]\r\n\r\n.NET Core runtimes installed:\r\n  Microsoft.AspNetCore.App 3.1.11 [/usr/share/dotnet/shared/Microsoft.AspNetCore.App]\r\n  Microsoft.NETCore.App 3.1.11 [/usr/share/dotnet/shared/Microsoft.NETCore.App]\r\n\r\nTo install additional .NET Core runtimes or SDKs:\r\n  https://aka.ms/dotnet-download\r\n\r\nI see in another issues, that you askd for path-to-root diagrams and as I see it, it requires Windows environment. If this is required, please describe the how-to on Linux.\r\nCan anybody help me what did I wrong? How to avoid this timeout?",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOM2ivMQ==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDc3MDE2NDcxOQ==",
                                           "createdAt":  "2021-01-30T06:09:04Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/ncl\nSee info in area-owners.md if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nHi,\r\n\r\nI have a .net core 3.1 based AWS Lambda function with 5 min timeout, that performs some http download \u0026 data transform \u0026 db write.\r\nThe problem is that in same cases, and it is very nondeterministic, an HttpMessageHandler clean-up cycle is fired and the AWS Lambda will time-out. Below is the most recent running where the clean-up takes about 4 minute:\r\n\r\n`2021-01-30 05:14:58,902 [4] DEBUG Microsoft.Extensions.Http.DefaultHttpClientFactory [(null)] - HttpMessageHandler expired after 120000ms for client \u0027\u0027\r\n2021-01-30 05:15:08,903 [4] DEBUG Microsoft.Extensions.Http.DefaultHttpClientFactory [(null)] - Starting HttpMessageHandler cleanup cycle with 1 items\r\n2021-01-30 05:15:08,903 [4] DEBUG Microsoft.Extensions.Http.DefaultHttpClientFactory [(null)] - Ending HttpMessageHandler cleanup cycle after 0.002ms - processed: 0 items - remaining: 1 items\r\n2021-01-30 05:15:18,904 [9] DEBUG Microsoft.Extensions.Http.DefaultHttpClientFactory [(null)] - Starting HttpMessageHandler cleanup cycle with 1 items\r\n2021-01-30 05:15:18,905 [9] DEBUG Microsoft.Extensions.Http.DefaultHttpClientFactory [(null)] - Ending HttpMessageHandler cleanup cycle after 0.002ms - processed: 0 items - remaining: 1 items\r\n2021-01-30 05:15:28,922 [9] DEBUG Microsoft.Extensions.Http.DefaultHttpClientFactory [(null)] - Starting HttpMessageHandler cleanup cycle with 1 items\r\n2021-01-30 05:15:28,923 [9] DEBUG Microsoft.Extensions.Http.DefaultHttpClientFactory [(null)] - Ending HttpMessageHandler cleanup cycle after 0.0024ms - processed: 0 items - remaining: 1 items\r\n2021-01-30 05:15:38,925 [9] DEBUG Microsoft.Extensions.Http.DefaultHttpClientFactory [(null)] - Starting HttpMessageHandler cleanup cycle with 1 items\r\n2021-01-30 05:15:38,926 [9] DEBUG Microsoft.Extensions.Http.DefaultHttpClientFactory [(null)] - Ending HttpMessageHandler cleanup cycle after 0.0022ms - processed: 0 items - remaining: 1 items\r\n2021-01-30 05:15:48,926 [9] DEBUG Microsoft.Extensions.Http.DefaultHttpClientFactory [(null)] - Starting HttpMessageHandler cleanup cycle with 1 items\r\n2021-01-30 05:15:48,927 [9] DEBUG Microsoft.Extensions.Http.DefaultHttpClientFactory [(null)] - Ending HttpMessageHandler cleanup cycle after 0.0021ms - processed: 0 items - remaining: 1 items\r\n2021-01-30 05:15:58,927 [9] DEBUG Microsoft.Extensions.Http.DefaultHttpClientFactory [(null)] - Starting HttpMessageHandler cleanup cycle with 1 items\r\n2021-01-30 05:15:58,927 [9] DEBUG Microsoft.Extensions.Http.DefaultHttpClientFactory [(null)] - Ending HttpMessageHandler cleanup cycle after 0.0023ms - processed: 0 items - remaining: 1 items\r\n2021-01-30 05:16:08,927 [9] DEBUG Microsoft.Extensions.Http.DefaultHttpClientFactory [(null)] - Starting HttpMessageHandler cleanup cycle with 1 items\r\n2021-01-30 05:16:08,927 [9] DEBUG Microsoft.Extensions.Http.DefaultHttpClientFactory [(null)] - Ending HttpMessageHandler cleanup cycle after 0.0018ms - processed: 0 items - remaining: 1 items\r\n2021-01-30 05:16:18,928 [9] DEBUG Microsoft.Extensions.Http.DefaultHttpClientFactory [(null)] - Starting HttpMessageHandler cleanup cycle with 1 items\r\n2021-01-30 05:16:18,928 [9] DEBUG Microsoft.Extensions.Http.DefaultHttpClientFactory [(null)] - Ending HttpMessageHandler cleanup cycle after 0.0023ms - processed: 0 items - remaining: 1 items\r\n2021-01-30 05:16:28,929 [9] DEBUG Microsoft.Extensions.Http.DefaultHttpClientFactory [(null)] - Starting HttpMessageHandler cleanup cycle with 1 items\r\n2021-01-30 05:16:28,929 [9] DEBUG Microsoft.Extensions.Http.DefaultHttpClientFactory [(null)] - Ending HttpMessageHandler cleanup cycle after 0.002ms - processed: 0 items - remaining: 1 items\r\n2021-01-30 05:16:38,927 [9] DEBUG Microsoft.Extensions.Http.DefaultHttpClientFactory [(null)] - Starting HttpMessageHandler cleanup cycle with 1 items\r\n2021-01-30 05:16:38,927 [9] DEBUG Microsoft.Extensions.Http.DefaultHttpClientFactory [(null)] - Ending HttpMessageHandler cleanup cycle after 0.0019ms - processed: 0 items - remaining: 1 items\r\n2021-01-30 05:16:48,928 [7] DEBUG Microsoft.Extensions.Http.DefaultHttpClientFactory [(null)] - Starting HttpMessageHandler cleanup cycle with 1 items\r\n2021-01-30 05:16:48,928 [7] DEBUG Microsoft.Extensions.Http.DefaultHttpClientFactory [(null)] - Ending HttpMessageHandler cleanup cycle after 0.0021ms - processed: 0 items - remaining: 1 items\r\n2021-01-30 05:16:58,928 [7] DEBUG Microsoft.Extensions.Http.DefaultHttpClientFactory [(null)] - Starting HttpMessageHandler cleanup cycle with 1 items\r\n2021-01-30 05:16:58,929 [7] DEBUG Microsoft.Extensions.Http.DefaultHttpClientFactory [(null)] - Ending HttpMessageHandler cleanup cycle after 0.0021ms - processed: 0 items - remaining: 1 items\r\n2021-01-30 05:17:08,929 [7] DEBUG Microsoft.Extensions.Http.DefaultHttpClientFactory [(null)] - Starting HttpMessageHandler cleanup cycle with 1 items\r\n2021-01-30 05:17:08,930 [7] DEBUG Microsoft.Extensions.Http.DefaultHttpClientFactory [(null)] - Ending HttpMessageHandler cleanup cycle after 0.0022ms - processed: 0 items - remaining: 1 items\r\n2021-01-30 05:17:18,931 [9] DEBUG Microsoft.Extensions.Http.DefaultHttpClientFactory [(null)] - Starting HttpMessageHandler cleanup cycle with 1 items\r\n2021-01-30 05:17:18,931 [9] DEBUG Microsoft.Extensions.Http.DefaultHttpClientFactory [(null)] - Ending HttpMessageHandler cleanup cycle after 0.0023ms - processed: 0 items - remaining: 1 items\r\n2021-01-30 05:17:28,931 [9] DEBUG Microsoft.Extensions.Http.DefaultHttpClientFactory [(null)] - Starting HttpMessageHandler cleanup cycle with 1 items\r\n2021-01-30 05:17:28,931 [9] DEBUG Microsoft.Extensions.Http.DefaultHttpClientFactory [(null)] - Ending HttpMessageHandler cleanup cycle after 0.0024ms - processed: 0 items - remaining: 1 items\r\n2021-01-30 05:17:38,933 [9] DEBUG Microsoft.Extensions.Http.DefaultHttpClientFactory [(null)] - Starting HttpMessageHandler cleanup cycle with 1 items\r\n2021-01-30 05:17:38,934 [9] DEBUG Microsoft.Extensions.Http.DefaultHttpClientFactory [(null)] - Ending HttpMessageHandler cleanup cycle after 0.0024ms - processed: 0 items - remaining: 1 items\r\n2021-01-30 05:17:48,934 [9] DEBUG Microsoft.Extensions.Http.DefaultHttpClientFactory [(null)] - Starting HttpMessageHandler cleanup cycle with 1 items\r\n2021-01-30 05:17:48,935 [9] DEBUG Microsoft.Extensions.Http.DefaultHttpClientFactory [(null)] - Ending HttpMessageHandler cleanup cycle after 0.002ms - processed: 0 items - remaining: 1 items\r\n2021-01-30 05:17:58,943 [9] DEBUG Microsoft.Extensions.Http.DefaultHttpClientFactory [(null)] - Starting HttpMessageHandler cleanup cycle with 1 items\r\n2021-01-30 05:17:58,943 [9] DEBUG Microsoft.Extensions.Http.DefaultHttpClientFactory [(null)] - Ending HttpMessageHandler cleanup cycle after 0.0018ms - processed: 0 items - remaining: 1 items\r\n2021-01-30 05:18:08,945 [9] DEBUG Microsoft.Extensions.Http.DefaultHttpClientFactory [(null)] - Starting HttpMessageHandler cleanup cycle with 1 items\r\n2021-01-30 05:18:08,946 [9] DEBUG Microsoft.Extensions.Http.DefaultHttpClientFactory [(null)] - Ending HttpMessageHandler cleanup cycle after 0.0023ms - processed: 0 items - remaining: 1 items\r\n2021-01-30 05:18:18,947 [9] DEBUG Microsoft.Extensions.Http.DefaultHttpClientFactory [(null)] - Starting HttpMessageHandler cleanup cycle with 1 items\r\n2021-01-30 05:18:18,947 [9] DEBUG Microsoft.Extensions.Http.DefaultHttpClientFactory [(null)] - Ending HttpMessageHandler cleanup cycle after 0.0021ms - processed: 0 items - remaining: 1 items\r\n2021-01-30 05:18:28,948 [9] DEBUG Microsoft.Extensions.Http.DefaultHttpClientFactory [(null)] - Starting HttpMessageHandler cleanup cycle with 1 items\r\n2021-01-30 05:18:28,949 [9] DEBUG Microsoft.Extensions.Http.DefaultHttpClientFactory [(null)] - Ending HttpMessageHandler cleanup cycle after 0.002ms - processed: 0 items - remaining: 1 items\r\n2021-01-30 05:18:38,950 [9] DEBUG Microsoft.Extensions.Http.DefaultHttpClientFactory [(null)] - Starting HttpMessageHandler cleanup cycle with 1 items\r\n2021-01-30 05:18:38,950 [9] DEBUG Microsoft.Extensions.Http.DefaultHttpClientFactory [(null)] - Ending HttpMessageHandler cleanup cycle after 0.0026ms - processed: 0 items - remaining: 1 items\r\n2021-01-30 05:18:48,951 [9] DEBUG Microsoft.Extensions.Http.DefaultHttpClientFactory [(null)] - Starting HttpMessageHandler cleanup cycle with 1 items\r\n2021-01-30 05:18:48,951 [9] DEBUG Microsoft.Extensions.Http.DefaultHttpClientFactory [(null)] - Ending HttpMessageHandler cleanup cycle after 0.0027ms - processed: 0 items - remaining: 1 items\r\n2021-01-30 05:18:58,955 [7] DEBUG Microsoft.Extensions.Http.DefaultHttpClientFactory [(null)] - Starting HttpMessageHandler cleanup cycle with 1 items\r\n2021-01-30 05:18:58,955 [7] DEBUG Microsoft.Extensions.Http.DefaultHttpClientFactory [(null)] - Ending HttpMessageHandler cleanup cycle after 0.0023ms - processed: 0 items - remaining: 1 items\r\nEND RequestId: 9af6e269-5aa7-5515-b32d-bae7b7fe2e95\r\nREPORT RequestId: 9af6e269-5aa7-5515-b32d-bae7b7fe2e95\tDuration: 300087.98 ms\tBilled Duration: 300000 ms\tMemory Size: 1024 MB\tMax Memory Used: 261 MB`\r\n\r\nBelow I try to collect the relevant part of my code how I use HTTPClient and IHTTPClientFactory:\r\nI tried to disable HTTPMessageHandler rotation, as you see without success. Due to would be a short running AWS LAmbda function, I shouldn\u0027t lost any relevant functionlaty (DNS update)\r\n\r\nSetting up DI:\r\n`            services.AddLogging();\r\n            // Set LifeTime to infinite will disable handler rotation -\u003e don\u0027t respond to DNS changes\r\n            services.AddHttpClient\u003cIDownloader, Downloader\u003e().SetHandlerLifetime(Timeout.InfiniteTimeSpan);\r\n            services.AddSingleton\u003cILoggerFactory\u003e(loggerFactory);\r\n            services.AddTransient\u003cIDownloader, Downloader\u003e();\r\n            services.AddTransient\u003cIReportParser, ReportParser\u003e();\r\n`\r\n\r\nThe Downloader\u0027s source:\r\n`    public class Downloader : IDownloader\r\n    {\r\n        private readonly ILogger\u003cDownloader\u003e _logger;\r\n        private readonly IHttpClientFactory _clientFactory;\r\n\r\n        public Downloader(ILogger\u003cDownloader\u003e logger, IHttpClientFactory clientFactory)\r\n        {\r\n            _logger = logger;\r\n            _clientFactory = clientFactory;\r\n        }\r\n\r\n        public async Task\u003cStream\u003e DownloadStream(Uri uri)\r\n        {\r\n            _logger.LogTrace(uri.ToString());\r\n            var client = _clientFactory.CreateClient();\r\n            return await client.GetStreamAsync(uri);\r\n        }\r\n    }\r\n`\r\n\r\nAnd it\u0027s usage:\r\n`        private readonly IDownloader _downloader;\r\n        private readonly ILogger\u003cReportParser\u003e _logger;\r\n\r\n        public ReportParser(ILogger\u003cReportParser\u003e logger, IDownloader downloader)\r\n        {\r\n            _logger = logger;\r\n            _downloader = downloader;\r\n        }\r\n`\r\n\r\nThe environment:\r\nUbuntu 18.04\r\nVS Code 1.52.1\r\n.NET Core:\r\ndotnet --info\r\n.NET Core SDK (reflecting any global.json):\r\n Version:   3.1.405\r\n Commit:    3fae16e62e\r\n\r\nRuntime Environment:\r\n OS Name:     ubuntu\r\n OS Version:  18.04\r\n OS Platform: Linux\r\n RID:         ubuntu.18.04-x64\r\n Base Path:   /usr/share/dotnet/sdk/3.1.405/\r\n\r\nHost (useful for support):\r\n  Version: 3.1.11\r\n  Commit:  f5eceb8105\r\n\r\n.NET Core SDKs installed:\r\n  3.1.405 [/usr/share/dotnet/sdk]\r\n\r\n.NET Core runtimes installed:\r\n  Microsoft.AspNetCore.App 3.1.11 [/usr/share/dotnet/shared/Microsoft.AspNetCore.App]\r\n  Microsoft.NETCore.App 3.1.11 [/usr/share/dotnet/shared/Microsoft.NETCore.App]\r\n\r\nTo install additional .NET Core runtimes or SDKs:\r\n  https://aka.ms/dotnet-download\r\n\r\nI see in another issues, that you askd for path-to-root diagrams and as I see it, it requires Windows environment. If this is required, please describe the how-to on Linux.\r\nCan anybody help me what did I wrong? How to avoid this timeout?\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003emoravas\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-Extensions-HttpClientFactory`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2021-01-30T06:09:04Z"
                                       },
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDg2MjQ5ODYwOQ==",
                                           "createdAt":  "2021-06-16T15:55:55Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODyp82Q==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "karelz",
                                                                               "createdAt":  "2021-06-17T10:07:08Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "SankethJain",
                                                                               "createdAt":  "2023-04-26T18:09:17Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "asindarov",
                                                                               "createdAt":  "2024-09-18T11:02:27Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  3
                                                         },
                                           "author":  "CarnaViire",
                                           "body":  "Triage: Cleanup would happen only when underlying HttpMessageHandler gets GC\u0027ed, meaning HttpClient got GC\u0027ed and handler\u0027s lifetime expired. In the similar situation  https://github.com/dotnet/aspnetcore/issues/3470#issuecomment-455001937 the reason was that the lifetime did not expire yet. That being said, it is unclear why it prevents AWS Lambda from finishing. We should investigate in Future. If anyone else also runs into this, please upvote the top post to help us prioritize. Thanks!\r\n\r\nMeanwhile, you could try using a static/singleton HttpClient instead of HttpClientFactory, especially as you don\u0027t care about DNS changes.",
                                           "updatedAt":  "2021-06-16T15:55:55Z"
                                       }
                                   ],
                         "totalCount":  2
                     },
        "title":  "AWS Lambda times out because endless HttpMessageHandler cleanup",
        "labels":  [
                       "area-Extensions-HttpClientFactory"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/50873",
        "createdAt":  "2021-04-07T20:16:33Z",
        "number":  50873,
        "author":  "mdh1418",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2021-07-22T18:03:37Z",
        "body":  "Microsoft.Extensions.Http.Tests\r\n\r\n- [ ] Microsoft.Extensions.Http.Test.HttpMessageHandlerBuilderTest.Build_AdditionalHandlerIsNull_ThrowsException\r\n- [ ] Microsoft.Extensions.Http.Test.HttpMessageHandlerBuilderTest.Build_AdditionalHandlerHasNonNullInnerHandler_ThrowsException\r\n- [ ] Microsoft.Extensions.Http.DefaultHttpMessageHandlerBuilderTest.Build_AdditionalHandlerIsNull_ThrowsException\r\n- [ ] Microsoft.Extensions.Http.DefaultHttpMessageHandlerBuilderTest.Build_AdditionalHandlerHasNonNullInnerHandler_ThrowsException\r\n- [ ] Microsoft.Extensions.Http.DefaultHttpMessageHandlerBuilderTest.Build_PrimaryHandlerIsNull_ThrowsException\r\n\r\nEdit: New Failure\r\nMicrosoft.Extensions.DependencyInjection.HttpClientFactoryServiceCollectionExtensionsTest.AddHttpClient_DoesNotRegisterDefaultClientIfAlreadyRegistered\r\n\r\n```\r\nMicrosoft.Extensions.Http.Tests.dll   Failed: 5\r\n\r\nTest collection for Microsoft.Extensions.Http.Test.HttpMessageHandlerBuilderTest\r\nMicrosoft.Extensions.Http.Test.HttpMessageHandlerBuilderTest.Build_AdditionalHandlerIsNull_ThrowsException\r\n    Assert.Equal() Failure\\n          ↓ (pos 0)\\nExpected: The \u0027additionalHandlers\u0027 must not contain···\\nActual:   HttpMessageHandlerBuilder_AdditionalHandl···\\n          ↑ (pos 0)\r\nMicrosoft.Extensions.Http.Test.HttpMessageHandlerBuilderTest.Build_AdditionalHandlerHasNonNullInnerHandler_ThrowsException\r\n    Assert.Equal() Failure\\n          ↓ (pos 0)\\nExpected: The \u0027InnerHandler\u0027 property must be null.···\\nActual:   HttpMessageHandlerBuilder_AdditionHandler···\\n          ↑ (pos 0)\r\n\r\nTest collection for Microsoft.Extensions.Http.DefaultHttpMessageHandlerBuilderTest\r\nMicrosoft.Extensions.Http.DefaultHttpMessageHandlerBuilderTest.Build_AdditionalHandlerIsNull_ThrowsException\r\n    Assert.Equal() Failure\\n          ↓ (pos 0)\\nExpected: The \u0027additionalHandlers\u0027 must not contain···\\nActual:   HttpMessageHandlerBuilder_AdditionalHandl···\\n          ↑ (pos 0)\r\nMicrosoft.Extensions.Http.DefaultHttpMessageHandlerBuilderTest.Build_AdditionalHandlerHasNonNullInnerHandler_ThrowsException\r\n    Assert.Equal() Failure\\n          ↓ (pos 0)\\nExpected: The \u0027InnerHandler\u0027 property must be null.···\\nActual:   HttpMessageHandlerBuilder_AdditionHandler···\\n          ↑ (pos 0)\r\nMicrosoft.Extensions.Http.DefaultHttpMessageHandlerBuilderTest.Build_PrimaryHandlerIsNull_ThrowsException\r\n    Assert.Equal() Failure\\n          ↓ (pos 0)\\nExpected: The \u0027PrimaryHandler\u0027 must not be null.\\nActual:   HttpMessageHandlerBuilder_PrimaryHandlerI···\\n          ↑ (pos 0)\r\n```\r\n```\r\nTest collection for Microsoft.Extensions.DependencyInjection.HttpClientFactoryServiceCollectionExtensionsTest\r\nMicrosoft.Extensions.DependencyInjection.HttpClientFactoryServiceCollectionExtensionsTest.AddHttpClient_DoesNotRegisterDefaultClientIfAlreadyRegistered\r\n    System.NullReferenceException : Object reference not set to an instance of an object\r\n```\r\n\r\n",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOMJdl8Q==",
                         "nodes":  [
                                       {
                                           "id":  "MDEyOklzc3VlQ29tbWVudDgxNTIyODQwMQ==",
                                           "createdAt":  "2021-04-07T20:16:39Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/ncl\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\nMicrosoft.Extensions.Http.Tests\r\n\r\n- [ ] Microsoft.Extensions.Http.Test.HttpMessageHandlerBuilderTest.Build_AdditionalHandlerIsNull_ThrowsException\r\n- [ ] Microsoft.Extensions.Http.Test.HttpMessageHandlerBuilderTest.Build_AdditionalHandlerHasNonNullInnerHandler_ThrowsException\r\n- [ ] Microsoft.Extensions.Http.DefaultHttpMessageHandlerBuilderTest.Build_AdditionalHandlerIsNull_ThrowsException\r\n- [ ] Microsoft.Extensions.Http.DefaultHttpMessageHandlerBuilderTest.Build_AdditionalHandlerHasNonNullInnerHandler_ThrowsException\r\n- [ ] Microsoft.Extensions.Http.DefaultHttpMessageHandlerBuilderTest.Build_PrimaryHandlerIsNull_ThrowsException\r\n\r\n```\r\nMicrosoft.Extensions.Http.Tests.dll   Failed: 5\r\n\r\nTest collection for Microsoft.Extensions.Http.Test.HttpMessageHandlerBuilderTest\r\nMicrosoft.Extensions.Http.Test.HttpMessageHandlerBuilderTest.Build_AdditionalHandlerIsNull_ThrowsException\r\n    Assert.Equal() Failure\\n          ↓ (pos 0)\\nExpected: The \u0027additionalHandlers\u0027 must not contain···\\nActual:   HttpMessageHandlerBuilder_AdditionalHandl···\\n          ↑ (pos 0)\r\nMicrosoft.Extensions.Http.Test.HttpMessageHandlerBuilderTest.Build_AdditionalHandlerHasNonNullInnerHandler_ThrowsException\r\n    Assert.Equal() Failure\\n          ↓ (pos 0)\\nExpected: The \u0027InnerHandler\u0027 property must be null.···\\nActual:   HttpMessageHandlerBuilder_AdditionHandler···\\n          ↑ (pos 0)\r\n\r\nTest collection for Microsoft.Extensions.Http.DefaultHttpMessageHandlerBuilderTest\r\nMicrosoft.Extensions.Http.DefaultHttpMessageHandlerBuilderTest.Build_AdditionalHandlerIsNull_ThrowsException\r\n    Assert.Equal() Failure\\n          ↓ (pos 0)\\nExpected: The \u0027additionalHandlers\u0027 must not contain···\\nActual:   HttpMessageHandlerBuilder_AdditionalHandl···\\n          ↑ (pos 0)\r\nMicrosoft.Extensions.Http.DefaultHttpMessageHandlerBuilderTest.Build_AdditionalHandlerHasNonNullInnerHandler_ThrowsException\r\n    Assert.Equal() Failure\\n          ↓ (pos 0)\\nExpected: The \u0027InnerHandler\u0027 property must be null.···\\nActual:   HttpMessageHandlerBuilder_AdditionHandler···\\n          ↑ (pos 0)\r\nMicrosoft.Extensions.Http.DefaultHttpMessageHandlerBuilderTest.Build_PrimaryHandlerIsNull_ThrowsException\r\n    Assert.Equal() Failure\\n          ↓ (pos 0)\\nExpected: The \u0027PrimaryHandler\u0027 must not be null.\\nActual:   HttpMessageHandlerBuilder_PrimaryHandlerI···\\n          ↑ (pos 0)\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003emdh1418\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-Extensions-HttpClientFactory`, `os-android`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e6.0.0\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2021-04-07T20:16:39Z"
                                       }
                                   ],
                         "totalCount":  1
                     },
        "title":  "Microsoft.Extensions.Http.Tests Fails on Android",
        "labels":  [
                       "os-android",
                       "area-Extensions-HttpClientFactory"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/64034",
        "createdAt":  "2022-01-20T08:37:24Z",
        "number":  64034,
        "author":  "Eli-Black-Work",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOC-VH1g==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "samuelhewitt",
                                            "createdAt":  "2022-02-17T16:08:13Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "eugene-sh",
                                            "createdAt":  "2022-10-30T23:28:46Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "R0boC0p",
                                            "createdAt":  "2023-04-05T13:40:35Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "lvde0",
                                            "createdAt":  "2025-01-21T15:40:18Z"
                                        }
                                    ],
                          "totalCount":  4
                      },
        "updatedAt":  "2022-12-07T16:59:21Z",
        "body":  "### Background and motivation\n\nWe currently have some code like this:\r\n\r\n**UserService.cs**\r\n```c#\r\npublic class UserService : IUserService\r\n{\r\n    private readonly HttpClient _httpClient;\r\n    \r\n    public UserService(HttpClient httpClient)\r\n    {\r\n        _httpClient = httpClient;\r\n    }\r\n    \r\n    public async Task Example()\r\n    {\r\n        await _httpClient.GetAsync(\"...\");\r\n    }\r\n}\r\n```\r\n\r\n**UserRepo.cs**\r\n```c#\r\npublic class UserRepo : IUserRepo\r\n{\r\n    private readonly IUserService _userService;\r\n\r\n    /// \u003csummary\u003e\r\n    /// Class that allows for managing target lists including CRUD and commands\r\n    /// \u003c/summary\u003e\r\n    public Operator(IUserService userService)\r\n    {\r\n        _userService = userService;\r\n    }\r\n}\r\n```\r\n\r\n**Startup.cs**\r\n```c#\r\nservices\r\n    .AddHttpClient\u003cIUserService, UserService\u003e(httpClient =\u003e\r\n    {\r\n        httpClient.BaseAddress = new Uri(Configuration[\"....\"], UriKind.Absolute);\r\n    })\r\n    .ConfigurePrimaryHttpMessageHandler(sp =\u003e\r\n    {\r\n        return new HttpClientHandler() {\r\n            UseProxy = true,\r\n            DefaultProxyCredentials = CredentialCache.DefaultCredentials\r\n        };\r\n    });\r\n\r\nservices.AddSingleton\u003cIUserRepo, UserRepo\u003e();\r\n```\r\n\r\nThis is a problem, because while `IUserService` is transient, `IUserRepo` is a singleton, so the `HttpClient` that\u0027s passed to `IUserService` will never be refreshed.\r\n\r\nOne fix is to make `IUserRepo` also be transient, but this isn\u0027t always ideal.\n\n### API Proposal\n\nI propose that calling `AddHttpClient()` should no only inject `HttpClient` but should also inject a new interface, `ITypedHttpClientFactory`. The user could then use `ITypedHttpClientFactory` to create new instances of `HttpClient` that have the settings that were configured via `AddHttpClient()`.\r\n\r\nThe advantage is that service singleton services that wrap typed clients could remain singletons instead of needing to be reconfigured to be transient.\r\n\r\n\n\n### API Usage\n\n**UserService.cs**\r\n```c#\r\npublic class UserService : IUserService\r\n{\r\n    private readonly ITypedHttpClientFactory _httpClientFactory;\r\n    \r\n    public UserService(ITypedHttpClientFactory httpClientFactory)\r\n    {\r\n        _httpClientFactory = httpClientFactory;\r\n    }\r\n    \r\n    public async Task Example()\r\n    {\r\n        // This HttpClient will have the BaseUrl, Proxy, etc. that was configured via the AddHttpService() call.\r\n        using var httpClient = _httpClientFactory.CreateClient();\r\n        \r\n        await httpClient.GetAsync(\"...\");\r\n    }\r\n}\r\n```\r\n\r\n**UserRepo.cs** (Same as above – no changes)\r\n```c#\r\npublic class UserRepo : IUserRepo\r\n{\r\n    private readonly IUserService _userService;\r\n\r\n    /// \u003csummary\u003e\r\n    /// Class that allows for managing target lists including CRUD and commands\r\n    /// \u003c/summary\u003e\r\n    public Operator(IUserService userService)\r\n    {\r\n        _userService = userService;\r\n    }\r\n}\r\n```\r\n\r\n**Startup.cs** (Same as above – no changes)\r\n```c#\r\nservices\r\n    .AddHttpClient\u003cIUserService, UserService\u003e(httpClient =\u003e\r\n    {\r\n        httpClient.BaseAddress = new Uri(Configuration[\"....\"], UriKind.Absolute);\r\n    })\r\n    .ConfigurePrimaryHttpMessageHandler(sp =\u003e\r\n    {\r\n        return new HttpClientHandler() {\r\n            UseProxy = true,\r\n            DefaultProxyCredentials = CredentialCache.DefaultCredentials\r\n        };\r\n    });\r\n\r\nservices.AddSingleton\u003cIUserRepo, UserRepo\u003e();\r\n```\n\n### Alternative Designs\n\n_No response_\n\n### Risks\n\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOT_JIMg==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc48och3",
                                           "createdAt":  "2022-01-20T08:37:29Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/ncl\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Background and motivation\n\nWe currently have some code like this:\r\n\r\n**UserService.cs**\r\n```c#\r\npublic class UserService : IUserService\r\n{\r\n    private readonly HttpClient _httpClient;\r\n    \r\n    public UserService(HttpClient httpClient)\r\n    {\r\n        _httpClient = httpClient;\r\n    }\r\n    \r\n    public async Task Example()\r\n    {\r\n        await _httpClient.GetAsync(\"...\");\r\n    }\r\n}\r\n```\r\n\r\n**UserRepo.cs**\r\n```c#\r\npublic class UserRepo : IUserRepo\r\n{\r\n    private readonly IUserService _userService;\r\n\r\n    /// \u003csummary\u003e\r\n    /// Class that allows for managing target lists including CRUD and commands\r\n    /// \u003c/summary\u003e\r\n    public Operator(IUserService userService)\r\n    {\r\n        _userService = userService;\r\n    }\r\n}\r\n```\r\n\r\n**Startup.cs**\r\n```c#\r\nservices\r\n    .AddHttpClient\u003cIUserService, UserService\u003e(httpClient =\u003e\r\n    {\r\n        httpClient.BaseAddress = new Uri(Configuration[\"....\"], UriKind.Absolute);\r\n    })\r\n    .ConfigurePrimaryHttpMessageHandler(sp =\u003e\r\n    {\r\n        return new HttpClientHandler() {\r\n            UseProxy = true,\r\n            DefaultProxyCredentials = CredentialCache.DefaultCredentials\r\n        };\r\n    });\r\n\r\nservices.AddSingleton\u003cIUserRepo, UserRepo\u003e();\r\n```\r\n\r\nThis is a problem, because while `IUserService` is transient, `IUserRepo` is a singleton, so the `HttpClient` that\u0027s passed to `IUserService` will never be refreshed.\r\n\r\nOne fix is to make `IUserRepo` also be transient, but this isn\u0027t always ideal.\n\n### API Proposal\n\nI propose that calling `AddHttpClient()` should no only inject `HttpClient` but should also inject a new interface, `ITypedHttpClientFactory`. The user could then use `ITypedHttpClientFactory` to create new instances of `HttpClient` that have the settings that were configured via `AddHttpClient()`.\r\n\r\nThe advantage is that service singleton services that wrap typed clients could remain singletons instead of needing to be reconfigured to be transient.\r\n\r\n\n\n### API Usage\n\n**UserService.cs**\r\n```c#\r\npublic class UserService : IUserService\r\n{\r\n    private readonly ITypedHttpClientFactory _httpClientFactory;\r\n    \r\n    public UserService(ITypedHttpClientFactory httpClientFactory)\r\n    {\r\n        _httpClientFactory = httpClientFactory;\r\n    }\r\n    \r\n    public async Task Example()\r\n    {\r\n        // This HttpClient will have the BaseUrl, Proxy, etc. that was configured via the AddHttpService() call.\r\n        using var httpClient = _httpClientFactory.CreateClient();\r\n        \r\n        await httpClient.GetAsync(\"...\");\r\n    }\r\n}\r\n```\r\n\r\n**UserRepo.cs** (Same as above – no changes)\r\n```c#\r\npublic class UserRepo : IUserRepo\r\n{\r\n    private readonly IUserService _userService;\r\n\r\n    /// \u003csummary\u003e\r\n    /// Class that allows for managing target lists including CRUD and commands\r\n    /// \u003c/summary\u003e\r\n    public Operator(IUserService userService)\r\n    {\r\n        _userService = userService;\r\n    }\r\n}\r\n```\r\n\r\n**Startup.cs** (Same as above – no changes)\r\n```c#\r\nservices\r\n    .AddHttpClient\u003cIUserService, UserService\u003e(httpClient =\u003e\r\n    {\r\n        httpClient.BaseAddress = new Uri(Configuration[\"....\"], UriKind.Absolute);\r\n    })\r\n    .ConfigurePrimaryHttpMessageHandler(sp =\u003e\r\n    {\r\n        return new HttpClientHandler() {\r\n            UseProxy = true,\r\n            DefaultProxyCredentials = CredentialCache.DefaultCredentials\r\n        };\r\n    });\r\n\r\nservices.AddSingleton\u003cIUserRepo, UserRepo\u003e();\r\n```\n\n### Alternative Designs\n\n_No response_\n\n### Risks\n\n_No response_\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eBosch-Eli-Black\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`api-suggestion`, `area-System.Net.Http`, `untriaged`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-01-20T08:37:29Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc48qQSl",
                                           "createdAt":  "2022-01-20T16:52:27Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/ncl\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Background and motivation\n\nWe currently have some code like this:\r\n\r\n**UserService.cs**\r\n```c#\r\npublic class UserService : IUserService\r\n{\r\n    private readonly HttpClient _httpClient;\r\n    \r\n    public UserService(HttpClient httpClient)\r\n    {\r\n        _httpClient = httpClient;\r\n    }\r\n    \r\n    public async Task Example()\r\n    {\r\n        await _httpClient.GetAsync(\"...\");\r\n    }\r\n}\r\n```\r\n\r\n**UserRepo.cs**\r\n```c#\r\npublic class UserRepo : IUserRepo\r\n{\r\n    private readonly IUserService _userService;\r\n\r\n    /// \u003csummary\u003e\r\n    /// Class that allows for managing target lists including CRUD and commands\r\n    /// \u003c/summary\u003e\r\n    public Operator(IUserService userService)\r\n    {\r\n        _userService = userService;\r\n    }\r\n}\r\n```\r\n\r\n**Startup.cs**\r\n```c#\r\nservices\r\n    .AddHttpClient\u003cIUserService, UserService\u003e(httpClient =\u003e\r\n    {\r\n        httpClient.BaseAddress = new Uri(Configuration[\"....\"], UriKind.Absolute);\r\n    })\r\n    .ConfigurePrimaryHttpMessageHandler(sp =\u003e\r\n    {\r\n        return new HttpClientHandler() {\r\n            UseProxy = true,\r\n            DefaultProxyCredentials = CredentialCache.DefaultCredentials\r\n        };\r\n    });\r\n\r\nservices.AddSingleton\u003cIUserRepo, UserRepo\u003e();\r\n```\r\n\r\nThis is a problem, because while `IUserService` is transient, `IUserRepo` is a singleton, so the `HttpClient` that\u0027s passed to `IUserService` will never be refreshed.\r\n\r\nOne fix is to make `IUserRepo` also be transient, but this isn\u0027t always ideal.\n\n### API Proposal\n\nI propose that calling `AddHttpClient()` should no only inject `HttpClient` but should also inject a new interface, `ITypedHttpClientFactory`. The user could then use `ITypedHttpClientFactory` to create new instances of `HttpClient` that have the settings that were configured via `AddHttpClient()`.\r\n\r\nThe advantage is that service singleton services that wrap typed clients could remain singletons instead of needing to be reconfigured to be transient.\r\n\r\n\n\n### API Usage\n\n**UserService.cs**\r\n```c#\r\npublic class UserService : IUserService\r\n{\r\n    private readonly ITypedHttpClientFactory _httpClientFactory;\r\n    \r\n    public UserService(ITypedHttpClientFactory httpClientFactory)\r\n    {\r\n        _httpClientFactory = httpClientFactory;\r\n    }\r\n    \r\n    public async Task Example()\r\n    {\r\n        // This HttpClient will have the BaseUrl, Proxy, etc. that was configured via the AddHttpService() call.\r\n        using var httpClient = _httpClientFactory.CreateClient();\r\n        \r\n        await httpClient.GetAsync(\"...\");\r\n    }\r\n}\r\n```\r\n\r\n**UserRepo.cs** (Same as above – no changes)\r\n```c#\r\npublic class UserRepo : IUserRepo\r\n{\r\n    private readonly IUserService _userService;\r\n\r\n    /// \u003csummary\u003e\r\n    /// Class that allows for managing target lists including CRUD and commands\r\n    /// \u003c/summary\u003e\r\n    public Operator(IUserService userService)\r\n    {\r\n        _userService = userService;\r\n    }\r\n}\r\n```\r\n\r\n**Startup.cs** (Same as above – no changes)\r\n```c#\r\nservices\r\n    .AddHttpClient\u003cIUserService, UserService\u003e(httpClient =\u003e\r\n    {\r\n        httpClient.BaseAddress = new Uri(Configuration[\"....\"], UriKind.Absolute);\r\n    })\r\n    .ConfigurePrimaryHttpMessageHandler(sp =\u003e\r\n    {\r\n        return new HttpClientHandler() {\r\n            UseProxy = true,\r\n            DefaultProxyCredentials = CredentialCache.DefaultCredentials\r\n        };\r\n    });\r\n\r\nservices.AddSingleton\u003cIUserRepo, UserRepo\u003e();\r\n```\n\n### Alternative Designs\n\n_No response_\n\n### Risks\n\n_No response_\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eBosch-Eli-Black\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`api-suggestion`, `untriaged`, `area-Extensions-HttpClientFactory`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-01-20T16:52:27Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc481NSJ",
                                           "createdAt":  "2022-01-24T21:47:50Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "CarnaViire",
                                           "body":  "Thanks for the suggestion @Bosch-Eli-Black!\r\nTyped Client not being refreshed in a singleton is a valid concern which pains me too.\r\n\r\n`ITypedHttpClientFactory\u003cT\u003e` is actually already being registered, however, it is not doing what you\u0027d like it to do -- it will require a pre-resolved `HttpClient` from `HttpClientFactory` to be passed inside, see [ITypedHttpClientFactory\u003cTClient\u003e.CreateClient(HttpClient)](https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.http.itypedhttpclientfactory-1.createclient?view=dotnet-plat-ext-6.0).\r\nOne of the reasons for that is the variety of ways you can register your Typed Client, including binding it to an already registered Named Client by passing the name, see e.g. [AddHttpClient\\\u003cTClient\\\u003e(IServiceCollection, String)](https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.dependencyinjection.httpclientfactoryservicecollectionextensions.addhttpclient?view=dotnet-plat-ext-6.0#microsoft-extensions-dependencyinjection-httpclientfactoryservicecollectionextensions-addhttpclient-1(microsoft-extensions-dependencyinjection-iservicecollection-system-string)).\r\n\r\nWhile it should be possible to extend `ITypedHttpClientFactory\u003cTClient\u003e` to have a method `CreateClient` without parameter, there is a downside -- It is a breaking change. If anyone used their own implementation of that interface, it will stop compiling.\r\n\r\nP.S.: It would be even better to have `IHttpClientFactory.CreateClient\u003cTClient\u003e()`, but that\u0027s impossible while `HttpClientFactory` is a singleton. However, that may change in https://github.com/dotnet/runtime/issues/47091.",
                                           "updatedAt":  "2022-01-24T21:47:50Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc4_tlxR",
                                           "createdAt":  "2022-03-16T09:32:40Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODZDp1w==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "silkfire",
                                                                               "createdAt":  "2024-03-03T00:50:11Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "stijnherreman",
                                           "body":  "\u003e It would be even better to have `IHttpClientFactory.CreateClient\u003cTClient\u003e()`, but that\u0027s impossible while `HttpClientFactory` is a singleton.\r\n\r\n@CarnaViire why\u0027s that? `HttpClientFactory` can resolve named clients, and aren\u0027t typed clients just named clients under the hood?",
                                           "updatedAt":  "2022-03-16T09:32:40Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc4_uEcf",
                                           "createdAt":  "2022-03-16T11:49:30Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "CarnaViire",
                                           "body":  "\u003e `HttpClientFactory` can resolve named clients, and aren\u0027t typed clients just named clients under the hood?\r\n\r\nIt depends on what you call a Typed client. I would say Typed client is a user-defined transient service which would have an HttpClient automatically injected in constructor. That injected HttpClient - yes, under the hood it is a named client (while that\u0027s an implementation detail). But the Typed client can have and usually has additional dependencies beside HttpClient. And in case a Typed client is resolved within a scope, all it\u0027s dependencies should be resolved within that scope too. But you cannon capture a scope from within a singleton service. That\u0027s why singleton `HttpClientFactory` cannot create Typed clients as-is.\r\n\r\n@stijnherreman does it make sense? Should I elaborate further?",
                                           "updatedAt":  "2022-03-16T11:49:30Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc4_uIdm",
                                           "createdAt":  "2022-03-16T12:09:51Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "stijnherreman",
                                           "body":  "That makes sense yes. I assumed the hypothetical `IHttpClientFactory.CreateClient\u003cTClient\u003e()` would return a `HttpClient`, and I was only considering the case in the OP here (which matches my case).\r\nIndeed when considering scoped dependencies, a possible solution will require more work.",
                                           "updatedAt":  "2022-03-16T12:09:51Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5NQU5e",
                                           "createdAt":  "2022-10-30T06:01:49Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "adcorduneanu",
                                           "body":  "What\u0027s the actual status of this one, as I\u0027m facing the same performance issue?\r\n\r\nAs in the initial request, I need it to happen only once, and not every time, as at this point I\u0027m paying a huge price when comes to initializing a new instance of the service.",
                                           "updatedAt":  "2022-10-30T06:01:49Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5NZBS7",
                                           "createdAt":  "2022-11-01T11:52:52Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOC_QcLQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "Eli-Black-Work",
                                                                               "createdAt":  "2022-11-16T07:36:36Z"
                                                                           },
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "adcorduneanu",
                                                                               "createdAt":  "2022-12-05T20:18:02Z"
                                                                           },
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "marius-stanescu",
                                                                               "createdAt":  "2023-06-28T05:32:28Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  3
                                                         },
                                           "author":  "CarnaViire",
                                           "body":  "@adcorduneanu if the problem you are facing is the one where you need to inject Typed clients into a singleton, you can consider a workaround with `SocketsHttpHandler` and `PooledConnectionLifetime`. Basically, if you replace the factory\u0027s handler management by `SocketsHttpHandler`\u0027s connection pool management, that will make Typed clients safe to be injected into singletones:\r\n\r\n```c#\r\nservices.AddHttpClient\u003cMyTypedClient\u003e()\r\n    .ConfigurePrimaryHttpMessageHandler(() =\u003e\r\n    {\r\n        return new SocketsHttpHandler()\r\n        {\r\n            PooledConnectionLifetime = TimeSpan.FromMinutes(2)\r\n        };\r\n    })\r\n    .SetHandlerLifetime(Timeout.InfiniteTimeSpan); // Disable rotation, as it is handled by PooledConnectionLifetime\r\n```\r\n\r\nYou can read a bit more in the [docs](https://learn.microsoft.com/en-us/dotnet/core/extensions/httpclient-factory#use-typed-clients-in-singleton-services) and you can also check out this [gist](https://gist.github.com/davidfowl/1fa4e1490a698fb38c66e65a85794122).",
                                           "updatedAt":  "2022-11-01T11:52:52Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5PEy2r",
                                           "createdAt":  "2022-11-24T16:26:46Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "gjermystreeva",
                                           "body":  "An alternative \u0027workaround\u0027 suggestion would be to register a `Func\u003cIUserService\u003e` and take a dependency on that in `UserRepo`, storing the `Func\u003cIUserService\u003e` rather than storing a (transient) `IUserService`.\r\n\r\nI\u0027ve put a [gist](https://gist.github.com/gjermystreeva/ee2c155d40ad56706fbd9e88a1efe12f) up based on @CarnaViire gist above.\r\n\r\nFor me it seems (maybe?) cleaner to keep the registration of the typed client cleaner, and leaves it down to the user of the typed client whether they are also transient and take a dependency on the typed client directly, or need to be singleton and use as example below.\r\n\r\nIts similar in concept to approach [here](https://www.stevejgordon.co.uk/ihttpclientfactory-patterns-using-typed-clients-from-singleton-services), but without ~~needing~~ extra factory classes.\r\n\r\n**UserRepo.cs**\r\n```c#\r\npublic class UserRepo : IUserRepo\r\n{\r\n    private readonly Func\u003cIUserService\u003e _userServiceFunc;\r\n\r\n    /// \u003csummary\u003e\r\n    /// Class that allows for managing target lists including CRUD and commands\r\n    /// \u003c/summary\u003e\r\n    public UserRepo(Func\u003cIUserService\u003e userServiceFunc)\r\n    {\r\n        _userServiceFunc = userServiceFunc;\r\n    }\r\n    \r\n    public DoSomething()\r\n    {\r\n        # Create a IUserService typed http client for each request\r\n        _ = await this._userServiceFunc().Example();\r\n    }\r\n}\r\n```\r\n\r\n**Startup.cs** \r\n```c#\r\n    # all the code in original example plus...\r\n\r\n    services.AddSingleton\u003cFunc\u003cIUserService\u003e\u003e(sp =\u003e () =\u003e sp.GetRequiredService\u003cIUserService\u003e());\r\n```\r\n\r\nIt could be all that is needed to be considered a \u0027fix\u0027 is `AddHttpClient` to register the \u0027factory\u0027 function also (plus docs). In fact I\u0027m pretty sure running in Azure Functions the DI already can resolve a `Func\u003cTClient\u003e`, but would need to double check.\r\n\r\nAny thoughts or feedback?\r\n",
                                           "updatedAt":  "2022-11-29T11:39:43Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5PweXg",
                                           "createdAt":  "2022-12-05T20:13:30Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "chunick",
                                           "body":  "@CarnaViire Would the workaround using `SocketsHttpHandler `and `PooledConnectionLifetime` cause any issues if the typed client was injected into a short-lived service as opposed to a singleton? I would like to create an extension method to use in place of all calls to `AddHttpClient` that will be safe for both singletons and short-lived services.",
                                           "updatedAt":  "2022-12-05T20:13:30Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5P8kgy",
                                           "createdAt":  "2022-12-07T16:59:21Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "CarnaViire",
                                           "body":  "@chunick the workaround would work for scoped and transient services as well.\r\n\r\nThe change essentially makes the handler to have a \"singleton\" DI lifetime. Meaning that the same handler instance will be reused in all instances of typed clients of a specific type.",
                                           "updatedAt":  "2022-12-07T16:59:21Z"
                                       }
                                   ],
                         "totalCount":  11
                     },
        "title":  "[API Proposal]: Make AddHttpClient() inject an ITypedHttpClientFactory into instantiated class",
        "labels":  [
                       "api-suggestion",
                       "area-Extensions-HttpClientFactory"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/66863",
        "createdAt":  "2022-03-18T21:54:01Z",
        "number":  66863,
        "author":  "eerhardt",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2022-10-21T11:07:59Z",
        "body":  "### Description\r\n\r\nIn profiling the [.NET Podcasts application](https://github.com/microsoft/dotnet-podcasts) startup time on an Android Pixel 5a, I\u0027m seeing its [usage](https://github.com/microsoft/dotnet-podcasts/blob/392453be5fa55c47ff84b98731d9b71fa6dc489c/src/Mobile/Services/ServicesExtensions.cs#L11-L14) of a named HttpClient using ` builder.Services.AddHttpClient\u003cShowsService\u003e(client =\u003e {})` as taking up 5% of the startup cost of the app.\r\n\r\n### Configuration\r\n\r\n* Which version of .NET is the code running on? `6.0`\r\n* What OS version, and what distro if applicable? `Android 12`\r\n* What is the architecture (x64, x86, ARM, ARM64)? `ARM64`\r\n* If relevant, what are the specs of the machine? `Google Pixel 5a`\r\n\r\n### Regression?\r\n\r\nNo\r\n\r\n### Data\r\n\r\nUsing the startup profiling script at https://github.com/jonathanpeppers/maui-profiling#faq, I\u0027m getting the following results:\r\n\r\n(using a full AOT of the app, so to eliminate any JIT time)\r\n\r\n#### Startup time with AddHttpClient\r\n\r\nAverage(ms): 838.2\r\nAverage(ms): 832.4\r\nAverage(ms): 835.2\r\n\r\n#### Startup time with just creating a shared HttpClient without DI\r\n\r\nAverage(ms): 795.5\r\nAverage(ms): 799.8\r\nAverage(ms): 797.9\r\n\r\n### Analysis\r\n\r\n[dotnet-podcasts.speedscope.zip](https://github.com/dotnet/runtime/files/8307769/dotnet-podcasts.speedscope.zip)\r\n\r\n1. Looking through the attached speedscope, a large chunk of time is spent creating the named Http client service in [AddTransientHelper](https://github.com/dotnet/runtime/blob/0b12d37843e7165fb4c8b794186f19ef43af6c73/src/libraries/Microsoft.Extensions.Http/src/DependencyInjection/HttpClientBuilderExtensions.cs#L260):\r\n\r\n![image](https://user-images.githubusercontent.com/8291187/159086734-4f7f70cd-ef20-404b-b077-ec8f4d2e04e5.png)\r\n\r\nA big chunk of that time is due to calling [ActivatorUtilities.CreateFactory](https://github.com/dotnet/runtime/blob/0b12d37843e7165fb4c8b794186f19ef43af6c73/src/libraries/Microsoft.Extensions.DependencyInjection.Abstractions/src/ActivatorUtilities.cs#L91), which uses System.Linq.Expressions and IL Ref.Emit.\r\n\r\n2. The Logging in Microsoft.Extensions.Http also seems to be adding a decent amount of overhead:\r\n\r\n![image](https://user-images.githubusercontent.com/8291187/159087742-37a4297e-4b14-4f5b-bb21-318acaf77602.png)\r\n\r\n### Discussion\r\n\r\nI wonder if using Microsoft.Extensions.Http on a mobile application is recommended at all. Or if a mobile app should just be following the guidance we give in [our docs](https://docs.microsoft.com/dotnet/api/system.net.http.httpclient):\r\n\r\n\u003e HttpClient is intended to be instantiated once and re-used throughout the life of an application. \r\n\r\n\r\n@davidfowl @jonathanpeppers @dotnet/ncl ",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOQ3YfXw==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc4_8kyq",
                                           "createdAt":  "2022-03-18T21:54:04Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/ncl\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Description\r\n\r\nIn profiling the [.NET Podcasts application](https://github.com/microsoft/dotnet-podcasts) startup time on an Android Pixel 5a, I\u0027m seeing its [usage](https://github.com/microsoft/dotnet-podcasts/blob/392453be5fa55c47ff84b98731d9b71fa6dc489c/src/Mobile/Services/ServicesExtensions.cs#L11-L14) of a named HttpClient using ` builder.Services.AddHttpClient\u003cShowsService\u003e(client =\u003e {})` as taking up 5% of the startup cost of the app.\r\n\r\n### Configuration\r\n\r\n* Which version of .NET is the code running on? `6.0`\r\n* What OS version, and what distro if applicable? `Android 12`\r\n* What is the architecture (x64, x86, ARM, ARM64)? `ARM64`\r\n* If relevant, what are the specs of the machine? `Google Pixel 5a`\r\n\r\n### Regression?\r\n\r\nNo\r\n\r\n### Data\r\n\r\nUsing the startup profiling script at https://github.com/jonathanpeppers/maui-profiling#faq, I\u0027m getting the following results:\r\n\r\n(using a full AOT of the app, so to eliminate any JIT time)\r\n\r\n#### Startup time with AddHttpClient\r\n\r\nAverage(ms): 838.2\r\nAverage(ms): 832.4\r\nAverage(ms): 835.2\r\n\r\n#### Startup time with just creating a shared HttpClient without DI\r\n\r\nAverage(ms): 795.5\r\nAverage(ms): 799.8\r\nAverage(ms): 797.9\r\n\r\n### Analysis\r\n\r\n[dotnet-podcasts.speedscope.zip](https://github.com/dotnet/runtime/files/8307769/dotnet-podcasts.speedscope.zip)\r\n\r\n1. Looking through the attached speedscope, a large chunk of time is spent creating the named Http client service in [AddTransientHelper](https://github.com/dotnet/runtime/blob/0b12d37843e7165fb4c8b794186f19ef43af6c73/src/libraries/Microsoft.Extensions.Http/src/DependencyInjection/HttpClientBuilderExtensions.cs#L260):\r\n\r\n![image](https://user-images.githubusercontent.com/8291187/159086734-4f7f70cd-ef20-404b-b077-ec8f4d2e04e5.png)\r\n\r\nA big chunk of that time is due to calling [ActivatorUtilities.CreateFactory](https://github.com/dotnet/runtime/blob/0b12d37843e7165fb4c8b794186f19ef43af6c73/src/libraries/Microsoft.Extensions.DependencyInjection.Abstractions/src/ActivatorUtilities.cs#L91), which uses System.Linq.Expressions and IL Ref.Emit.\r\n\r\n2. The Logging in Microsoft.Extensions.Http also seems to be adding a decent amount of overhead:\r\n\r\n![image](https://user-images.githubusercontent.com/8291187/159087742-37a4297e-4b14-4f5b-bb21-318acaf77602.png)\r\n\r\n### Discussion\r\n\r\nI wonder if using Microsoft.Extensions.Http on a mobile application is recommended at all. Or if a mobile app should just be following the guidance we give in [our docs](https://docs.microsoft.com/dotnet/api/system.net.http.httpclient):\r\n\r\n\u003e HttpClient is intended to be instantiated once and re-used throughout the life of an application. \r\n\r\n\r\n@davidfowl @jonathanpeppers @dotnet/ncl \n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eeerhardt\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`tenet-performance`, `area-Extensions-HttpClientFactory`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2022-03-18T21:54:04Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5AAqR2",
                                           "createdAt":  "2022-03-21T13:44:16Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jonathanpeppers",
                                           "body":  "For the podcast app, should we maybe go with something like:\r\n```\r\nservices.TryAddSingleton\u003cHttpClient\u003e(sp =\u003e new HttpClient());\r\n```\r\nAnd use 1 instance of `HttpClient` for the entire app?",
                                           "updatedAt":  "2022-03-21T13:44:16Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5AAu8L",
                                           "createdAt":  "2022-03-21T14:00:32Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "eerhardt",
                                           "body":  "That\u0027s similar to what I did: https://github.com/eerhardt/dotnet-podcasts/commit/e0849b2f9444cfc09bab6d3b62ecf2b637946f18\r\n\r\nI just didn\u0027t use DI to inject an HttpClient. Instead, I just made a static variable in `ShowsService`.\r\n\r\nOne issue with injecting an HttpClient is if you are connecting to multiple endpoints. It is easier to set the \"BaseAddress\", or headers, on different instances of HttpClient.",
                                           "updatedAt":  "2022-03-21T14:00:32Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5DR2Kn",
                                           "createdAt":  "2022-05-17T11:27:26Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "CarnaViire",
                                           "body":  "Yes, I would say it\u0027s quite a heavy overhead for the mobile usages - which might not be needed at all.\r\nThe factory means to solve two problems - socket exhaustion (that can be solved by a static/singleton HttpClient) and not losing DNS changes. I am not sure whether the second problem even exists for mobile usages? Given it\u0027s not SocketsHttpHandler that is used there.",
                                           "updatedAt":  "2022-05-17T11:27:26Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5DR24u",
                                           "createdAt":  "2022-05-17T11:30:33Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "This issue has been marked `needs-author-action` and may be missing some important information.",
                                           "updatedAt":  "2022-05-17T11:30:33Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5DWu2k",
                                           "createdAt":  "2022-05-18T13:40:32Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "jonathanpeppers",
                                           "body":  "Socket exhaustion definitely seems like something server scenarios would run into. If mobile app is making enough web requests to hit that problem, I would probably recommend \"don\u0027t do that\". Even if a mobile app was downloading lots of files, they should probably limit to 4 (or some number) of concurrent connections",
                                           "updatedAt":  "2022-05-18T13:40:32Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5DW6K_",
                                           "createdAt":  "2022-05-18T14:18:50Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCuQsDw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "jodydonetti",
                                                                               "createdAt":  "2022-06-08T16:56:37Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "yzbai",
                                                                               "createdAt":  "2022-07-11T01:01:54Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "Xor-el",
                                                                               "createdAt":  "2022-10-21T11:23:09Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  3
                                                         },
                                           "author":  "davidfowl",
                                           "body":  "The IHttpClientFactory isn\u0027t just about socket exhaustion and dns changes, it\u0027s about a DI friendly way to configure and pass around the http client. It just so happens that startup time is affected because of IL emit. I\u0027m pretty sure we could come up with something more mobile friendly configuration wise, but I haven\u0027t thought through how to work around/fix the startup performance problems.",
                                           "updatedAt":  "2022-05-18T14:18:50Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5DXfmu",
                                           "createdAt":  "2022-05-18T16:28:17Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOCdtMnQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "davidfowl",
                                                                               "createdAt":  "2022-05-19T14:45:53Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "eerhardt",
                                           "body":  "\u003e It just so happens that startup time is affected because of IL emit\r\n\r\nThe Logging in Microsoft.Extensions.Http also seems to be adding a decent amount of overhead",
                                           "updatedAt":  "2022-05-18T16:28:17Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Ddh9f",
                                           "createdAt":  "2022-05-19T14:46:17Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOClevFA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "CarnaViire",
                                                                               "createdAt":  "2022-05-19T15:27:03Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "jodydonetti",
                                                                               "createdAt":  "2022-06-08T16:56:34Z"
                                                                           },
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "knight1219",
                                                                               "createdAt":  "2022-07-06T21:50:04Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  3
                                                         },
                                           "author":  "davidfowl",
                                           "body":  "Hmmm, maybe worth making that opt-in.",
                                           "updatedAt":  "2022-05-19T14:46:17Z"
                                       }
                                   ],
                         "totalCount":  9
                     },
        "title":  "Microsoft.Extensions.Http is too heavy-weight for mobile usages",
        "labels":  [
                       "tenet-performance",
                       "area-Extensions-HttpClientFactory"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/80605",
        "createdAt":  "2023-01-13T09:28:40Z",
        "number":  80605,
        "author":  "amittleider",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2023-01-31T20:33:19Z",
        "body":  "### Description\r\n\r\n# Summary\r\nI have opened a PR here: https://github.com/dotnet/runtime/pull/80604 to demonstrate this issue. The PR is not meant to be merged, it\u0027s merely a demonstration of the issue that I\u0027m reporting. The test code runs and demonstrates the issue well. The production code is incomplete, but shows a potential path to fixing the issue.\r\n\r\nThe problem is that DefaultHttpClientFactory doesn\u0027t handle the case where an factory throws an exception well.\r\n\r\nTypically, an HttpClientHandler will be recycled after two minutes (https://github.com/dotnet/runtime/blob/main/src/libraries/Microsoft.Extensions.Http/src/DependencyInjection/HttpClientBuilderExtensions.cs#L499), but, in the case where the building of the handler throws an exception, the exception will be cached indefinitely. \r\n\r\nIn the definition of a Lazy object:\r\n```\r\nException caching When you use factory methods, exceptions are cached. That is, if the factory method throws an exception the first time a thread tries to access the [Value](https://learn.microsoft.com/en-us/dotnet/api/system.lazy-1.value?view=net-7.0) property of the [Lazy\u003cT\u003e](https://learn.microsoft.com/en-us/dotnet/api/system.lazy-1?view=net-7.0) object, the same exception is thrown on every subsequent attempt.\r\n```\r\n\r\nThis Lazy object is accessed in the `CreateHandler` method https://github.com/dotnet/runtime/blob/main/src/libraries/Microsoft.Extensions.Http/src/DefaultHttpClientFactory.cs#L118 , and immediately after it is accessed, the code will start a timer with the `StartHandlerEntry` timer. So, if line 118 throws an exception, a timer will never be set, and there will never be an attempt to re-initialize the object and the handler will be indefinitely in a bad state and irrecoverable.\r\n\r\n# Example scenario\r\nAs an example of how this might occur, consider a factory which takes runtime configuration as input. The runtime configuration changes to a bad state, causing an exception in the handler. The runtime configuration is then updated to a good state, but the factory will never be called again, so the application must be restarted to clear the Lazy object from memory.\r\n\r\n# Proposed solutions\r\n1. One solution is to ensure that the HandlerTimer is set before the factory is called. This will ensure that even if exceptions occur, we will always try to re-initialize it after the two-minute default. In the current implementation, the timer depends on the ActiveHandlerTrackingEntry, so this would require a bit of a re-write in the way the timers are handled. (See the code in the PR https://github.com/dotnet/runtime/compare/main...amittleider:runtime:HttpClientFactory_ExceptionsPersist?expand=1#diff-940dba6ffc5ae548fca7105241869c1a78442c04b968f129ce645407022e83cbR118 . This code doesn\u0027t compile, but it helps to illustrate the proposal).\r\n2. Another solution would be to make a new type of Lazy object that has a timer pre-built in. Like this, there is no need to handle timers at all within the DefaultHttpClientFactory.\r\n3. Last solution may be to modify the thread safety mode to use `LazyThreadSafetyMode.PublicationOnly`, which will not cache exceptions.\r\n\r\n## Labels\r\n@dotnet/area-extensions-dependencyinjection\r\n@dotnet/ncl\r\n\r\n### Reproduction Steps\r\n\r\nSee the test code in the PR: https://github.com/dotnet/runtime/pull/80604/files#diff-7ee446a98cb0ad2039642e909ac0732b37e7f764b534651cd88a3ac910c5b382R20\r\n\r\n### Expected behavior\r\n\r\nSee the test code in the PR: https://github.com/dotnet/runtime/pull/80604/files#diff-7ee446a98cb0ad2039642e909ac0732b37e7f764b534651cd88a3ac910c5b382R45\r\n\r\n### Actual behavior\r\n\r\nSee the test code in the PR: https://github.com/dotnet/runtime/pull/80604/files#diff-7ee446a98cb0ad2039642e909ac0732b37e7f764b534651cd88a3ac910c5b382R53\r\n\r\n### Regression?\r\n\r\n_No response_\r\n\r\n### Known Workarounds\r\n\r\nNever throw exceptions in HttpClientHandlerFactories.\r\n\r\n### Configuration\r\n\r\n_No response_\r\n\r\n### Other information\r\n\r\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOVBqXhw==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5SWIay",
                                           "createdAt":  "2023-01-13T09:28:43Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "I couldn\u0027t figure out the best area label to add to this issue. If you have write-permissions please help me learn by adding exactly one [area label](https://github.com/dotnet/runtime/blob/master/docs/area-owners.md).",
                                           "updatedAt":  "2023-01-13T09:28:43Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5SWJab",
                                           "createdAt":  "2023-01-13T09:32:16Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "amittleider",
                                           "body":  "\u003e I couldn\u0027t figure out the best area label to add to this issue. If you have write-permissions please help me learn by adding exactly one [area label](https://github.com/dotnet/runtime/blob/master/docs/area-owners.md).\r\n\r\n@dotnet/area-extensions-dependencyinjection\r\n@dotnet/ncl",
                                           "updatedAt":  "2023-01-13T09:32:16Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5SXALb",
                                           "createdAt":  "2023-01-13T12:03:53Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/ncl\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Description\r\n\r\n# Summary\r\nI have opened a PR here: https://github.com/dotnet/runtime/pull/80604 to demonstrate this issue. The PR is not meant to be merged, it\u0027s merely a demonstration of the issue that I\u0027m reporting. The test code runs and demonstrates the issue well. The production code is incomplete, but shows a potential path to fixing the issue.\r\n\r\nThe problem is that DefaultHttpClientFactory doesn\u0027t handle the case where an factory throws an exception well.\r\n\r\nTypically, an HttpClientHandler will be recycled after two minutes (https://github.com/dotnet/runtime/blob/main/src/libraries/Microsoft.Extensions.Http/src/DependencyInjection/HttpClientBuilderExtensions.cs#L499), but, in the case where the building of the handler throws an exception, the exception will be cached indefinitely. \r\n\r\nIn the definition of a Lazy object:\r\n```\r\nException caching When you use factory methods, exceptions are cached. That is, if the factory method throws an exception the first time a thread tries to access the [Value](https://learn.microsoft.com/en-us/dotnet/api/system.lazy-1.value?view=net-7.0) property of the [Lazy\u003cT\u003e](https://learn.microsoft.com/en-us/dotnet/api/system.lazy-1?view=net-7.0) object, the same exception is thrown on every subsequent attempt.\r\n```\r\n\r\nThis Lazy object is accessed in the `CreateHandler` method https://github.com/dotnet/runtime/blob/main/src/libraries/Microsoft.Extensions.Http/src/DefaultHttpClientFactory.cs#L118 , and immediately after it is accessed, the code will start a timer with the `StartHandlerEntry` timer. So, if line 118 throws an exception, a timer will never be set, and there will never be an attempt to re-initialize the object and the handler will be indefinitely in a bad state and irrecoverable.\r\n\r\n# Example scenario\r\nAs an example of how this might occur, consider a factory which takes runtime configuration as input. The runtime configuration changes to a bad state, causing an exception in the handler. The runtime configuration is then updated to a good state, but the factory will never be called again, so the application must be restarted to clear the Lazy object from memory.\r\n\r\n# Proposed solutions\r\n1. One solution is to ensure that the HandlerTimer is set before the factory is called. This will ensure that even if exceptions occur, we will always try to re-initialize it after the two-minute default. In the current implementation, the timer depends on the ActiveHandlerTrackingEntry, so this would require a bit of a re-write in the way the timers are handled. (See the code in the PR https://github.com/dotnet/runtime/compare/main...amittleider:runtime:HttpClientFactory_ExceptionsPersist?expand=1#diff-940dba6ffc5ae548fca7105241869c1a78442c04b968f129ce645407022e83cbR118 . This code doesn\u0027t compile, but it helps to illustrate the proposal).\r\n2. Another solution would be to make a new type of Lazy object that has a timer pre-built in. Like this, there is no need to handle timers at all within the DefaultHttpClientFactory.\r\n\r\n## Labels\r\n@dotnet/area-extensions-dependencyinjection\r\n@dotnet/ncl\r\n\r\n### Reproduction Steps\r\n\r\nSee the test code in the PR: https://github.com/dotnet/runtime/pull/80604/files#diff-7ee446a98cb0ad2039642e909ac0732b37e7f764b534651cd88a3ac910c5b382R20\r\n\r\n### Expected behavior\r\n\r\nSee the test code in the PR: https://github.com/dotnet/runtime/pull/80604/files#diff-7ee446a98cb0ad2039642e909ac0732b37e7f764b534651cd88a3ac910c5b382R45\r\n\r\n### Actual behavior\r\n\r\nSee the test code in the PR: https://github.com/dotnet/runtime/pull/80604/files#diff-7ee446a98cb0ad2039642e909ac0732b37e7f764b534651cd88a3ac910c5b382R53\r\n\r\n### Regression?\r\n\r\n_No response_\r\n\r\n### Known Workarounds\r\n\r\nNever throw exceptions in HttpClientHandlerFactories.\r\n\r\n### Configuration\r\n\r\n_No response_\r\n\r\n### Other information\r\n\r\n_No response_\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eamittleider\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`untriaged`, `area-Extensions-HttpClientFactory`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-01-13T12:03:53Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5TNpMM",
                                           "createdAt":  "2023-01-18T21:04:10Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "CarnaViire",
                                           "body":  "Thanks for the report and for detailed analysis @amittleider!\r\n\r\nIt seems to me that it was a design decision to expect configuration callbacks to be no-throw. It is another question on whether it was a good design decision, so we can open that conversation. In my opinion, it is an acceptable behavior. When an exception happens, it is delivered to the user. The factory doesn\u0027t go into an \"undefined\" state after an exception, when you don\u0027t know whether you would get an exception or not, it goes into a \"failed\" state. And there is a workaround to always catch the exceptions inside the user callback. I will not argue that it could be better, though. For example, the callback might be called again on next attempt to create a client, which would solve the problem that you had to restart an application to reset the \"failed\" state. But it seems to be the first time we had this reported -- it seems more of a corner-case scenario and nice-to-have. So I would put it to Future for now.\r\n\r\n\r\nOn the topic of your proposed fix, the Timer bit is an implementation detail, so I believe it is not related to the issue at hand and should not be part of the behavior design. It can change any time e.g. when we would switch to SocketsHttpHandler in #35987, and the primary handler would be only created once, while PooledConnectionLifetime would be used instead of timers. Also, if you are interested, it was a conscious decision to start the timer after the handler is created, to avoid race conditions if case of very short timers, see [this comment](https://github.com/dotnet/runtime/blob/e55c908229e36f99a52745d4ee85316a0e8bb6a2/src/libraries/Microsoft.Extensions.Http/src/DefaultHttpClientFactory.cs#L156-L162).",
                                           "updatedAt":  "2023-01-18T21:04:10Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5Tjsbf",
                                           "createdAt":  "2023-01-24T12:34:18Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "amittleider",
                                           "body":  "\u003e Thanks for the report and for detailed analysis @amittleider!\r\n\u003e \r\n\u003e It seems to me that it was a design decision to expect configuration callbacks to be no-throw. It is another question on whether it was a good design decision, so we can open that conversation. In my opinion, it is an acceptable behavior. When an exception happens, it is delivered to the user. The factory doesn\u0027t go into an \"undefined\" state after an exception, when you don\u0027t know whether you would get an exception or not, it goes into a \"failed\" state. And there is a workaround to always catch the exceptions inside the user callback. I will not argue that it could be better, though. For example, the callback might be called again on next attempt to create a client, which would solve the problem that you had to restart an application to reset the \"failed\" state. But it seems to be the first time we had this reported -- it seems more of a corner-case scenario and nice-to-have. So I would put it to Future for now.\r\n\u003e \r\n\u003e On the topic of your proposed fix, the Timer bit is an implementation detail, so I believe it is not related to the issue at hand and should not be part of the behavior design. It can change any time e.g. when we would switch to SocketsHttpHandler in #35987, and the primary handler would be only created once, while PooledConnectionLifetime would be used instead of timers. Also, if you are interested, it was a conscious decision to start the timer after the handler is created, to avoid race conditions if case of very short timers, see [this comment](https://github.com/dotnet/runtime/blob/e55c908229e36f99a52745d4ee85316a0e8bb6a2/src/libraries/Microsoft.Extensions.Http/src/DefaultHttpClientFactory.cs#L156-L162).\r\n\r\nThanks for taking a look, @CarnaViire . Thanks for pointing out the race condition. I agree that the first suggestion would not be the right solution.\r\n\r\nWhat do you think about the third suggestion? We could use a different method of lazy initialization, one that will not hold onto exceptions if it is failed to initialize (`LazyThreadSafetyMode.PublicationOnly`). In this case, it\u0027s potentially a one-line fix here: https://github.com/dotnet/runtime/blob/main/src/libraries/Microsoft.Extensions.Http/src/DefaultHttpClientFactory.cs#L88 .",
                                           "updatedAt":  "2023-01-24T12:34:47Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5UGpeH",
                                           "createdAt":  "2023-01-31T20:33:18Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "CarnaViire",
                                           "body":  "In case of `LazyThreadSafetyMode.PublicationOnly`, the initialization method can be executed concurrently multiple times per name, which is not acceptable perf-wise, as it would lead to unnecessary allocations (several message handlers being created instead of one). Handler configuration code, which is called within the initialization, can also rely on it being executed in a thread-safe manner, which would break.\r\n\r\nIf we were to modify the behavior here, we would probably need to let go of Lazy and implement synchronization manually by some other means.",
                                           "updatedAt":  "2023-01-31T20:33:18Z"
                                       }
                                   ],
                         "totalCount":  6
                     },
        "title":  "HttpClientFactory holds onto exceptions indefinitely, despite a two-minute timer",
        "labels":  [
                       "area-Extensions-HttpClientFactory"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/84263",
        "createdAt":  "2023-04-03T18:48:04Z",
        "number":  84263,
        "author":  "mkane91301",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHODAJENg==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "latonz",
                                            "createdAt":  "2023-06-07T08:09:21Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "RobThree",
                                            "createdAt":  "2023-11-28T10:02:58Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "huoyaoyuan",
                                            "createdAt":  "2025-03-16T18:46:04Z"
                                        }
                                    ],
                          "totalCount":  3
                      },
        "updatedAt":  "2023-05-17T16:50:30Z",
        "body":  "\u003e Similarly on the client side, there is no standard way to take an IHttpClientBuilder and add an OAuth bearer token to its calls from such-and-such a vendor\u0027s identity server according to some configuration. I wrote much more code than I can snip here to create a standard way for our shop. I\u0027d open source it if my company allowed, but this should already be part of Microsoft.Extensions anyway.\r\n\r\nI\u0027d file another issue for this, with the specifics as well. There\u0027s more detail needed here. It\u0027s unclear to me if you\u0027re trying to set tokens in the request or do something more complex, (like an oauth2 auth flow, that supports getting the token, storing the refresh token and renewing it etc).\r\n\r\n_Originally posted by @davidfowl in https://github.com/dotnet/aspnetcore/issues/47461#issuecomment-1486204571_\r\n \r\nHere\u0027s the scenario: you are exposing a REST API secured with OAuth tokens provided by a 3rd-party identity provider, such as Okta or the like. You need to provide a .NET client SDK that will use IHttpClientBuilder to register a strongly-typed client for your API and it will also inject the needed OAuth token, taking care of retrieving it from the identity server and caching it.\r\n\r\nRight now, you have to hope that your identity provider has an SDK that will handle the token injection (narrator voice: it doesn\u0027t) and even if it does, if you wanted to change identity providers, you would have to rewrite everything.\r\n\r\nWhat would be helpful would be a standard way in Microsoft.Extensions.Http that would let you do something like `.AddOAuthProvider\u003cOktaClientProvider\u003e(configuration)` and each identity provider would make a NuGet package with a class that implements some interface defined in something like Microsoft.Extensions.Http.OAuth, but the configuration would be defined by Microsoft and wouldn\u0027t change if you swapped out a different OAuth client provider. Also, the caching of the tokens would be in the common implementation, not the implementation that is specific to each identity provider.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOXH3K0g==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5ZGPdS",
                                           "createdAt":  "2023-04-03T18:48:13Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/ncl\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n\u003e Similarly on the client side, there is no standard way to take an IHttpClientBuilder and add an OAuth bearer token to its calls from such-and-such a vendor\u0027s identity server according to some configuration. I wrote much more code than I can snip here to create a standard way for our shop. I\u0027d open source it if my company allowed, but this should already be part of Microsoft.Extensions anyway.\r\n\r\nI\u0027d file another issue for this, with the specifics as well. There\u0027s more detail needed here. It\u0027s unclear to me if you\u0027re trying to set tokens in the request or do something more complex, (like an oauth2 auth flow, that supports getting the token, storing the refresh token and renewing it etc).\r\n\r\n_Originally posted by @davidfowl in https://github.com/dotnet/aspnetcore/issues/47461#issuecomment-1486204571_\r\n            \n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003emkane91301\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`area-System.Net.Http`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-04-03T18:48:13Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5ZGapD",
                                           "createdAt":  "2023-04-03T19:23:49Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/ncl\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n\u003e Similarly on the client side, there is no standard way to take an IHttpClientBuilder and add an OAuth bearer token to its calls from such-and-such a vendor\u0027s identity server according to some configuration. I wrote much more code than I can snip here to create a standard way for our shop. I\u0027d open source it if my company allowed, but this should already be part of Microsoft.Extensions anyway.\r\n\r\nI\u0027d file another issue for this, with the specifics as well. There\u0027s more detail needed here. It\u0027s unclear to me if you\u0027re trying to set tokens in the request or do something more complex, (like an oauth2 auth flow, that supports getting the token, storing the refresh token and renewing it etc).\r\n\r\n_Originally posted by @davidfowl in https://github.com/dotnet/aspnetcore/issues/47461#issuecomment-1486204571_\r\n \r\nHere\u0027s the scenario: you are exposing a REST API secured with OAuth tokens provided by a 3rd-party identity provider, such as Okta or the like. You need to provide a .NET client SDK that will use IHttpClientBuilder to register a strongly-typed client for your API and it will also inject the needed OAuth token, taking care of retrieving it from the identity server and caching it.\r\n\r\nRight now, you have to hope that your identity provider has an SDK that will handle the token injection (narrator voice: it doesn\u0027t) and even if it does, if you wanted to change identity providers, you would have to rewrite everything.\r\n\r\nWhat would be helpful would be a standard way in Microsoft.Extensions.Http that would let you do something like `.AddOAuthProvider\u003cOktaClientProvider\u003e(configuration)` and each identity provider would make a NuGet package with a class that implements some interface defined in something like Microsoft.Extensions.Http.OAuth, but the configuration would be defined by Microsoft and wouldn\u0027t change if you swapped out a different OAuth client provider. Also, the caching of the tokens would be in the common implementation, not the implementation that is specific to each identity provider.\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003emkane91301\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`untriaged`, `area-Extensions-HttpClientFactory`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-04-03T19:23:49Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5cfcrS",
                                           "createdAt":  "2023-05-17T16:50:19Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "CarnaViire",
                                           "body":  "Triage: we are not sure it is possible to create universal abstractions, and even if we do, we don\u0027t have any control over third-party identity providers to make sure they implement it.\r\n\r\nWe might investigate some approaches to make it easier in general in the future, if there would be enough customer ask.",
                                           "updatedAt":  "2023-05-17T16:50:19Z"
                                       }
                                   ],
                         "totalCount":  3
                     },
        "title":  "Standardize way to add OAuth tokens via IHttpClientBuilder",
        "labels":  [
                       "area-Extensions-HttpClientFactory"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/88460",
        "createdAt":  "2023-07-06T05:04:52Z",
        "number":  88460,
        "author":  "JamesNK",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOC9XgvA==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "WeihanLi",
                                            "createdAt":  "2024-12-11T06:12:18Z"
                                        }
                                    ],
                          "totalCount":  1
                      },
        "updatedAt":  "2024-01-08T23:12:04Z",
        "body":  "### Background and motivation\r\n\r\n.NET 8 adds metrics and enrichment support to HttpClient. See https://github.com/dotnet/runtime/issues/86281\r\n\r\nThis API proposal is for a new HttpClientFactory API. It\u0027s designed to make it easier to combine enrichment with the factory.\r\n\r\nRight now, there isn\u0027t an ask for this feature. However:\r\n1. It is a low-cost change that makes enrichment easy to use with the client factory.\r\n2. People who want to combine enrichment with HttpClientFactory could use this extension method. Reusing this method would save dotnet/extensions from having to implement this feature internally.\r\n\r\nI expect this feature will be implemented by registering an internal http handler with the client factory. The handler just calls `HttpMetricsEnrichmentContext.AddCallback` with the callback passed to the extension method.\r\n\r\n### API Proposal\r\n\r\n```csharp\r\nnamespace Microsoft.Extensions.DependencyInjection;\r\n\r\npublic static class HttpClientBuilderExtensions\r\n{\r\n    public static IHttpClientBuilder AddMetricsEnrichment(\r\n        this IHttpClientBuilder builder,\r\n        Action\u003cHttpMetricsEnrichmentContext\u003e callback);\r\n}\r\n```\r\n\r\n\r\n### API Usage\r\n\r\n```csharp\r\nservices.AddHttpClient(\"my-cool-client\")\r\n    .AddHttpMessageHandler\u003cCustomHttpHandler\u003e()\r\n    .AddMetricsEnrichment(context =\u003e\r\n    {\r\n        var status = context.Response.Headers.GetValue(\"x-status\");\r\n        context.AddCustomTag(\"x-status\", status);\r\n    });\r\n```\r\n\r\n\r\n### Alternative Designs\r\n\r\n_No response_\r\n\r\n### Risks\r\n\r\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOcCx-cg==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc5gvOhg",
                                           "createdAt":  "2023-07-06T05:05:03Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  null,
                                           "body":  "Tagging subscribers to this area: @dotnet/ncl\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003cdetails\u003e\n\u003csummary\u003eIssue Details\u003c/summary\u003e\n\u003chr /\u003e\n\n### Background and motivation\n\n.NET 8 adds metrics and enrichment support to HttpClient. See https://github.com/dotnet/runtime/issues/86281\r\n\r\nThis API proposal is for a new HttpClientFactory API. It\u0027s designed to make it easier to combine enrichment with the factory.\r\n\r\nRight now, there isn\u0027t an ask for this feature. However, it is a low-cost change that makes enrichment easy to use with the client factory.\r\n\r\nI expect this feature would be implemented by registering an internal http handler with the client factory. The handler just calls `HttpMetricsEnrichmentContext.AddCallback` with the callback passed to the extension method.\n\n### API Proposal\n\n```csharp\r\nnamespace Microsoft.Extensions.DependencyInjection;\r\n\r\npublic static class HttpClientBuilderExtensions\r\n{\r\n    public static IHttpClientBuilder AddMetricsEnrichment(this IHttpClientBuilder builder, Action\u003cHttpMetricsEnrichmentContext\u003e callback);\r\n}\r\n```\r\n\n\n### API Usage\n\n```csharp\r\nservices.AddHttpClient(\"my-cool-client\")\r\n    .AddHttpMessageHandler\u003cCustomHttpHandler\u003e()\r\n    .AddMetricsEnrichment(context =\u003e\r\n    {\r\n        var status = context.Response.Headers.GetValue(\"x-status\");\r\n        context.AddCustomTag(\"x-status\", status);\r\n    });\r\n```\r\n\n\n### Alternative Designs\n\n_No response_\n\n### Risks\n\n_No response_\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAuthor:\u003c/th\u003e\n    \u003ctd\u003eJamesNK\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eAssignees:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eLabels:\u003c/th\u003e\n    \u003ctd\u003e\n\n`api-suggestion`, `area-Extensions-HttpClientFactory`\n\n\u003c/td\u003e\n  \u003c/tr\u003e\n  \u003ctr\u003e\n    \u003cth align=\"left\"\u003eMilestone:\u003c/th\u003e\n    \u003ctd\u003e-\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\u003c/details\u003e",
                                           "updatedAt":  "2023-07-06T05:05:03Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5gvOl0",
                                           "createdAt":  "2023-07-06T05:05:18Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "JamesNK",
                                           "body":  "cc @antonfirsov @CarnaViire @noahfalk @tarekgh ",
                                           "updatedAt":  "2023-07-06T05:06:00Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5gxdHK",
                                           "createdAt":  "2023-07-06T12:14:30Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "CarnaViire",
                                           "body":  "Triage: as discussed with @JamesNK offline, this is a nice-to-have and not critical for .NET 8. Even if dotnet/extensions would need to implement this for enrichment on their side, it is going to be straightforward and wouldn\u0027t need a public API. Moving to Future.",
                                           "updatedAt":  "2023-07-06T12:14:30Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5vW1ZL",
                                           "createdAt":  "2023-12-23T09:55:09Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "davidroth",
                                           "body":  "Will it be possible to also disable metrics on individual named http clients?\r\n\r\nI have a use case where I am only interested in metrics on a specific named http client of my application. I would like to not see the metrics of other http clients.",
                                           "updatedAt":  "2023-12-23T09:55:09Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5v4gN1",
                                           "createdAt":  "2024-01-04T13:18:20Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "CarnaViire",
                                           "body":  "@davidroth that\u0027s a good point.\r\n@antonfirsov is it even possible to do with existing metrics APIs? I can see that enrichment can only add the tags, but not remove them. And SocketsHttpHandler will use some default shared meter even if the meter factory was set to null 🤔",
                                           "updatedAt":  "2024-01-04T13:18:20Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5v6xT6",
                                           "createdAt":  "2024-01-04T19:53:57Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "antonfirsov",
                                           "body":  "When it comes to the .NET libraries, we do provide the infrastructure to enable this: it is possible to initialize `SocketsHttpHandler` and `HttpClientHandler` to use custom `IMeterFactory` instances eg. by using [`ConfigurePrimaryMessageHandler`](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.dependencyinjection.httpclientbuilderextensions.configureprimaryhttpmessagehandler), so you can take control of your `Meter` instances for the clients you do care about. On the listener side, the originating `Meter` and `IMeterFactory == meter.Scope` instances can then be observed and used for filtering in [`MeterListener.InstrumentPublished`](https://learn.microsoft.com/en-us/dotnet/api/system.diagnostics.metrics.meterlistener.instrumentpublished) callbacks.\r\n\r\nHowever, to make this useful in practice, collection/exporter libaries (the stuff that subscribes to these callbacks) need to expose APIs for filtering (eg. to drop recordings for a specific meter or factory). @davidroth what do you use for collection? @vishweshbankwar is there such a filter mechanism in [opentelemetry-dotnet](https://github.com/open-telemetry/opentelemetry-dotnet)?\r\n\r\n",
                                           "updatedAt":  "2024-01-04T19:58:56Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5v7KeO",
                                           "createdAt":  "2024-01-04T21:24:48Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "CarnaViire",
                                           "body":  "\u003e it is possible to initialize SocketsHttpHandler and HttpClientHandler to use custom IMeterFactory instances\r\n\r\nThat was my first thought, but what should such \"no-op\" factory return upon the `meterFactory.Create` call? if it returns null, the code will just use `SharedMeter.Instance` once again:\r\n\r\nhttps://github.com/dotnet/runtime/blob/7269f90cb075cee9fd99fa88060bcf9d83457584/src/libraries/System.Net.Http/src/System/Net/Http/Metrics/MetricsHandler.cs#L22\r\n\r\nIt seems that the returned meter instance should be some kind of mock as well? But `Meter` is a class, not an interface. I didn\u0027t look further, but it already seemed too complicated 🤔",
                                           "updatedAt":  "2024-01-04T21:25:07Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5wJdJ1",
                                           "createdAt":  "2024-01-08T17:29:21Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "antonfirsov",
                                           "body":  "\u003e That was my first thought, but what should such \"no-op\" factory return upon the `meterFactory.Create` call?\r\n\r\nIt should return a functional `Meter`, not a no-op. Listening is enabled per-instrument, typically in  [`MeterListener.InstrumentPublished`](https://learn.microsoft.com/en-us/dotnet/api/system.diagnostics.metrics.meterlistener.instrumentpublished), therefore the instruments a user wants to ignore should be filtered out (not enabled) in [`MeterListener.InstrumentPublished`](https://learn.microsoft.com/en-us/dotnet/api/system.diagnostics.metrics.meterlistener.instrumentpublished) eg. based on the `Meter` instance referenced by the `Instrument` passed to the callback. (Also note that [`Meter.Scope`](https://learn.microsoft.com/en-us/dotnet/api/system.diagnostics.metrics.meter.scope?view=net-8.0) typically references the `IMeterFactory`.)\r\n\r\nIMO this should be implemented by the consumers of that event, eg. in collection libraries like [Prometheus Exporter](https://github.com/open-telemetry/opentelemetry-dotnet/blob/main/src/OpenTelemetry.Exporter.Prometheus.AspNetCore/README.md).",
                                           "updatedAt":  "2024-01-08T17:36:10Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5wJ35J",
                                           "createdAt":  "2024-01-08T18:45:57Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "CarnaViire",
                                           "body":  "Is this correct that the nesting goes as: `MeterFactory` -\u003e `Meter` -\u003e `Instrument`? And -- judging by the [implementation](https://github.com/dotnet/runtime/blob/7269f90cb075cee9fd99fa88060bcf9d83457584/src/libraries/System.Net.Http/src/System/Net/Http/Metrics/MetricsHandler.cs#L22) -- Meter is _always_ `System.Net.Http`, and Instruments are _always_ `http.client.active_requests` and `http.client.request.duration`, regardless of the MeterFactory implementation?..\r\n\r\nThen I really don\u0027t understand how can I differentiate between several HttpClients and say \"only include this one\"... 🤔 Because I don\u0027t have any controls over neither Meter name, nor Instrument names... So when I enable the instrument, e.g. `http.client.request.duration`, I enable listening to _all_ of the HttpClients? Can I even tell them apart in the results? Am I missing something?\r\n\r\nFor comparison -- I know it\u0027s a completely different thing, but e.g. default `HttpClientFactory` logging includes name of the client into the logger name (e.g. \"System.Net.Http.HttpClient._foo_.ClientHandler\"), so you can filter out (or in) specific clients by name in the logging config, like\r\n```\r\n{\r\n  \"Logging\": {\r\n    \"LogLevel\": {\r\n      \"Default\": \"Warning\",\r\n      \"System.Net.Http.HttpClient\": \"None\",\r\n      \"System.Net.Http.HttpClient.foo\": \"Information\"\r\n    }\r\n}\r\n```\r\n",
                                           "updatedAt":  "2024-01-08T18:45:57Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc5wLH5y",
                                           "createdAt":  "2024-01-08T23:09:46Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODRuiwA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "CarnaViire",
                                                                               "createdAt":  "2024-01-09T09:31:40Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "antonfirsov",
                                           "body":  "Given an `Instrument`, the `IMeterFactory` instance is accessible using [`instrument.Meter.Scope`](https://learn.microsoft.com/en-us/dotnet/api/system.diagnostics.metrics.meter.scope?view=net-8.0) (`== theMeterFactory`). This enables comparing the factory instances by reference. For the HttpClient(s) which should *not* be metered, a user can override the `IMeterFactory` assigned to the handler with a custom one in `ConfigurePrimaryMessageHandler`. If the collection library (ie. OpenTelemetry.NET\u0027s Prometheus Exporter) has a way to hook user code into their [`InstrumentPublished` implementation](https://github.com/open-telemetry/opentelemetry-dotnet/blob/88493d257c9e089a52a4a806f9b64430cd7f5d9b/src/OpenTelemetry.Extensions.Hosting/Implementation/OpenTelemetryMetricsListener.cs#L50), it\u0027s possible then to check whether `instrument.Meter.Scope == services.GetRequiredService\u003cIMeterFactory\u003e()`, and enable the instrument only if the comparison returns true. Another way is to make the custom `IMeterFactory` add a [tag](https://learn.microsoft.com/en-us/dotnet/api/system.diagnostics.metrics.meter.tags) to the `Meter` the custom factory creates, which can be then checked in the callback.\r\n\r\nOfc, this is complicated, and assumes that Prometheus Exporter (or other collection libraries) have ways to customize the filtering for their InstrumentPublished implementations. If filtering metrics by originating `HttpClient` instance is a popular feature request, we may need to have a discussion about making the user experience simpler. Since this issue is about enrichment, I would prefer to have that discussion in a separate one. @davidroth do you mind opening a new issue, if this is important for you?",
                                           "updatedAt":  "2024-01-08T23:12:04Z"
                                       }
                                   ],
                         "totalCount":  10
                     },
        "title":  "[API Proposal]: HttpClientFactory AddMetricsEnrichment",
        "labels":  [
                       "api-suggestion",
                       "area-Extensions-HttpClientFactory"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/104525",
        "createdAt":  "2024-07-07T17:11:43Z",
        "number":  104525,
        "author":  "paulomorgado",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  null,
                          "nodes":  [

                                    ],
                          "totalCount":  0
                      },
        "updatedAt":  "2024-07-12T17:36:36Z",
        "body":  "_Updated by @CarnaViire_\r\n\r\nAPI:\r\n\r\n```csharp\r\nnamespace Microsoft.Extensions.DependencyInjection;\r\n\r\npublic static class HttpClientBuilderExtensions\r\n{\r\n    public static IHttpClientBuilder AddTypedClient(\r\n        this IHttpClientBuilder builder,\r\n        Type clientType,\r\n        Type? ImplementationType = null);\r\n}\r\n```\r\n\r\nUsage:\r\n\r\n```csharp\r\nservices.AddHttpClient(name)\r\n    .AddTypedClient(clientType, clientImplementationType);\r\n```\r\n\r\n---\r\n\r\n_Original issue by @paulomorgado_\r\n\r\n### Background and motivation\r\n\r\nSometimes I have the need to register HTTP clients from configuration files and, for that, I need to construct a generic method for each type.\r\n\r\n### API Proposal\r\n\r\n```csharp\r\nnamespace Microsoft.Extensions.DependencyInjection;\r\n\r\npublic static class HttpClientFactoryServiceCollectionExtensions\r\n{\r\n    public static IHttpClientBuilder AddHttpClient(\r\n        this IServiceCollection services,\r\n        Type clientType,\r\n        Type ImplementationType);\r\n}\r\n```\r\n\r\n\r\n### API Usage\r\n\r\n```csharp\r\nservice.AddHttpClient(clientType, implementationType);\r\n```\r\n\r\n\r\n### Alternative Designs\r\n\r\n_No response_\r\n\r\n### Risks\r\n\r\nThere might be a risk for overloads with factory methods, as correctness might be hard to guarantee.",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOhK7CAw==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6D4ELr",
                                           "createdAt":  "2024-07-07T17:12:09Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/ncl\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2024-07-07T17:12:09Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6D-TjP",
                                           "createdAt":  "2024-07-08T13:55:33Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "julealgon",
                                           "body":  "\u003e Sometimes I have the need to register HTTP clients from configuration files...\r\n\r\nWould you mind sharing an example of what you are doing? \r\n\r\nI fail to see why you are not using named (but untyped) HTTP client registrations and using `IHttpClientFactory` explicitly with a dynamic setup. No need to call that overload you are proposing then: you just register the various `HttpClient`s separately.",
                                           "updatedAt":  "2024-07-08T13:55:33Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6D-fLn",
                                           "createdAt":  "2024-07-08T14:13:30Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "paulomorgado",
                                           "body":  "@julealgon,\r\n\r\n\u003e \u003e Sometimes I have the need to register HTTP clients from configuration files...\r\n\u003e \r\n\u003e Would you mind sharing an example of what you are doing?\r\n\u003e \r\n\u003e I fail to see why you are not using named (but untyped) HTTP client registrations and using `IHttpClientFactory` explicitly with a dynamic setup. No need to call that overload you are proposing then: you just register the various `HttpClient`s separately.\r\n\r\nInstead of explicitly registering the HTTP clients in code, I use configuration for that.\r\n\r\nAt startup, I add all the HTTP clients in the configuration. And the configuration might have type HTTP clients.",
                                           "updatedAt":  "2024-07-08T14:13:30Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6D-hbm",
                                           "createdAt":  "2024-07-08T14:17:16Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "julealgon",
                                           "body":  "@paulomorgado I think you misunderstood what I asked. I 100% understand that you are dynamically registering the clients based on configuration, but my point specifically was that you _don\u0027t_ need to use the typed registration methods to achieve that, you can just used named registrations instead and then inject `IHttpClientFactory` into your consumers and grab the named client from that.\r\n\r\nIf you know how WCF config-based bindings worked in the past, this would be very similar to that.",
                                           "updatedAt":  "2024-07-08T14:17:16Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6D-lFh",
                                           "createdAt":  "2024-07-08T14:23:04Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "paulomorgado",
                                           "body":  "@julealgon,\r\n\r\n\u003e @paulomorgado I think you misunderstood what I asked. I 100% understand that you are dynamically registering the clients based on configuration, but my point specifically was that you _don\u0027t_ need to use the typed registration methods to achieve that, you can just used named registrations instead and then inject `IHttpClientFactory` into your consumers and grab the named client from that.\r\n\u003e \r\n\u003e If you know how WCF config-based bindings worked in the past, this would be very similar to that.\r\n\r\nI know I can do that, but my components have the typed clients injected and I never inject the `IHttpClientFactory`.\r\n\r\nJust because I can inject `IHttpClientFactory`, doesn\u0027t mean I should.",
                                           "updatedAt":  "2024-07-08T14:23:04Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6D-ttJ",
                                           "createdAt":  "2024-07-08T14:36:26Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "julealgon",
                                           "body":  "\u003e I know I can do that, but my components have the typed clients injected and I never inject the `IHttpClientFactory`.\r\n\u003e \r\n\u003e Just because I can inject `IHttpClientFactory`, doesn\u0027t mean I should.\r\n\r\nFair enough. I was just checking whether the named registrations could be a way for your use case: looks like it isn\u0027t.\r\n\r\nWould still be nice if you could share a sample of your problem to make a stronger case for the proposed API.\r\n\r\nIn the meantime, you could just register the types yourself using `ActivatorUtilities`:\r\n```csharp\r\nservices.AddHttpClient(myHttpClientName, //...configure here...\r\nservices.AddTransient(myInterface, provider =\u003e ActivatorUtilities.CreateInstance(\r\n    provider, \r\n    myType, \r\n    provider.GetRequiredService\u003cIHttpClientFactory\u003e().CreateClient(myHttpClientName))\r\n```\r\n\r\nWhich you could, of course, abstract away into your own generic helper method.\r\n\r\nThe problem I see with the original `AddHttpClient\u003cT\u003e` methods is that they.... don\u0027t scale as an API: eventually, people will request for every single variation that exists for other `Add...` methods, and I\u0027m personally not that fond of that design: I\u0027d rather see it die in favor of a general purpose \"dependent\" registration feature. But alas.",
                                           "updatedAt":  "2024-07-08T14:36:26Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6D_QjO",
                                           "createdAt":  "2024-07-08T15:10:11Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "paulomorgado",
                                           "body":  "I have a working solution. I just don\u0027t think this is my requirement only and the factory usability would benefit from this.",
                                           "updatedAt":  "2024-07-08T15:10:11Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6D_juw",
                                           "createdAt":  "2024-07-08T15:41:57Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "julealgon",
                                           "body":  "\u003e I have a working solution.\r\n\r\nAgain, I would suggest sharing your use case and your current workaround so more people can see the benefit of the new API and can rely on your workaround in the meantime.\r\n\r\n\u003e I just don\u0027t think this is my requirement only and the factory usability would benefit from this.\r\n\r\nI\u0027ve never seen anyone else request this myself. All dynamic registration discussions revolved around named httpclient registrations or even using the new keyed registration support.\r\n\r\n",
                                           "updatedAt":  "2024-07-08T15:41:57Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6D_vfD",
                                           "createdAt":  "2024-07-08T15:57:07Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODo2Qhg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "julealgon",
                                                                               "createdAt":  "2024-07-08T18:17:15Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "paulomorgado",
                                           "body":  "I am dynamically registering typed HTTP clients.\r\n\r\nThe particulars of why I need to do it are not important nor I will discuss them publicly.\r\n",
                                           "updatedAt":  "2024-07-08T15:57:07Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6EKCEK",
                                           "createdAt":  "2024-07-09T10:03:49Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODpAu6w==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "julealgon",
                                                                               "createdAt":  "2024-07-09T17:06:36Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "CarnaViire",
                                           "body":  "Thanks for the proposal @paulomorgado \r\n\r\nTriage:\r\n\r\nThere are already 20 (!) overloads of `AddHttpClient`. We are extremely reluctant to expand this even further, as it will hurt the usability more than it will help. Given that there are working solutions for the problem described (incl. the workarounds proposed above, thanks @julealgon), and there is not much customer ask for that (this is the first one that I\u0027m aware of), we\u0027re inclined towards closing the issue.\r\n\r\nPlease let me know if I missed something, or there\u0027s some additional reasons why we should reconsider. Thanks!",
                                           "updatedAt":  "2024-07-09T10:03:49Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6EXzTo",
                                           "createdAt":  "2024-07-10T15:30:59Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODpTDdQ==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "HEART",
                                                                               "user":  "CarnaViire",
                                                                               "createdAt":  "2024-07-11T11:09:31Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "paulomorgado",
                                           "body":  "This is what I have working now (in case anyone needs it):\r\n\r\n```csharp\r\npublic static class MyHttpClientFactoryDependencyInjectionExtensions\r\n{\r\n    private static readonly MethodInfo _addHttpClientByClientTypeMethodInfo =\r\n        typeof(HttpClientFactoryServiceCollectionExtensions)\r\n            .GetMethod(\r\n                nameof(HttpClientFactoryServiceCollectionExtensions.AddHttpClient),\r\n                1,\r\n                new Type[] { typeof(IServiceCollection) })!;\r\n\r\n    private static readonly MethodInfo _addHttpClientByClientTypeWithNameMethodInfo =\r\n        typeof(HttpClientFactoryServiceCollectionExtensions)\r\n            .GetMethod(\r\n                nameof(HttpClientFactoryServiceCollectionExtensions.AddHttpClient),\r\n                1,\r\n                new Type[] { typeof(IServiceCollection), typeof(string) })!;\r\n\r\n    private static readonly MethodInfo _addHttpClientByClientAndClientImplementationTypeMethodInfo =\r\n        typeof(HttpClientFactoryServiceCollectionExtensions)\r\n            .GetMethod(\r\n                nameof(HttpClientFactoryServiceCollectionExtensions.AddHttpClient),\r\n                2,\r\n                new Type[] { typeof(IServiceCollection) })!;\r\n\r\n    private static readonly MethodInfo _addHttpClientByClientAndClientImplementationTypeWithNameMethodInfo =\r\n        typeof(HttpClientFactoryServiceCollectionExtensions)\r\n            .GetMethod(\r\n                nameof(HttpClientFactoryServiceCollectionExtensions.AddHttpClient),\r\n                2,\r\n                new Type[] { typeof(IServiceCollection), typeof(string) })!;\r\n\r\n    public static IServiceCollection AddHttpClients(this IServiceCollection services, IConfiguration configuration)\r\n    {\r\n        // ...\r\n        \r\n        foreach (var section in configuration.GetChildren())\r\n        {\r\n            var name = section.Key;\r\n            var clientTypeName = section.GetSection(\"ClientType\")?.Value ?? name;\r\n            var clientImplementationTypeName = section.GetSection(\"ClientImplementationType\")?.Value;\r\n\r\n            var clientType = Type.GetType(clientTypeName);\r\n            var clientImplementationType = string.IsNullOrEmpty(clientImplementationTypeName)\r\n                ? null\r\n                : Type.GetType(clientImplementationTypeName) ?? throw new InvalidOperationException($\"The implementation type \u0027{clientImplementationTypeName}\u0027 was not found for client \u0027{name}\u0027.\");\r\n\r\n            if (clientImplementationType is not null \u0026\u0026 clientType is null)\r\n            {\r\n                throw new InvalidOperationException($\"The implementation type \u0027{clientImplementationType.AssemblyQualifiedName}\u0027 was configured, but the client type \u0027{clientTypeName}\u0027 was not found for client \u0027{name}\u0027.\");\r\n            }\r\n\r\n            var http = clientType is null\r\n                ? services.AddHttpClient(name)\r\n                : clientImplementationType is null\r\n                    ? services.AddHttpClient(clientType, name)\r\n                    : services.AddHttpClient(clientType, clientImplementationType, name);\r\n\r\n            http\r\n                .ConfigureHttpClient(httpClient =\u003e\r\n                {\r\n                    // ...\r\n                });\r\n\r\n            ConfigureClientCredentialsTokenHandler(http, section);\r\n\r\n            ConfigureStandardResilience(http, section);\r\n        }\r\n\r\n        return services;\r\n    }\r\n\r\n    public static IHttpClientBuilder AddHttpClient(this IServiceCollection services, Type clientType)\r\n        =\u003e (IHttpClientBuilder) _addHttpClientByClientTypeMethodInfo\r\n            .MakeGenericMethod(clientType)\r\n            .Invoke(null, new object[] { services })!;\r\n\r\n    public static IHttpClientBuilder AddHttpClient(this IServiceCollection services, Type clientType, string name)\r\n        =\u003e (IHttpClientBuilder) _addHttpClientByClientTypeWithNameMethodInfo\r\n            .MakeGenericMethod(clientType)\r\n            .Invoke(null, new object[] { services, name })!;\r\n\r\n    public static IHttpClientBuilder AddHttpClient(this IServiceCollection services, Type clientType, Type clientImplementationType)\r\n        =\u003e (IHttpClientBuilder) _addHttpClientByClientAndClientImplementationTypeMethodInfo\r\n            .MakeGenericMethod(clientType, clientImplementationType)\r\n            .Invoke(null, new object[] { services })!;\r\n\r\n    public static IHttpClientBuilder AddHttpClient(this IServiceCollection services, Type clientType, Type clientImplementationType, string name)\r\n        =\u003e (IHttpClientBuilder) _addHttpClientByClientAndClientImplementationTypeWithNameMethodInfo\r\n            .MakeGenericMethod(clientType, clientImplementationType)\r\n            .Invoke(null, new object[] { services, name })!;\r\n}\r\n```",
                                           "updatedAt":  "2024-07-10T15:30:59Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6EfKZD",
                                           "createdAt":  "2024-07-11T12:07:36Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODpTfaw==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "paulomorgado",
                                                                               "createdAt":  "2024-07-11T12:11:52Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "CarnaViire",
                                           "body":  "Thanks for sharing @paulomorgado!\r\n\r\nWhile that would 100% align with what the factory is doing with the Typed clients (given the actual methods are used), for the sake of simplicity let me also save here how it would look like with the Activator approach:\r\n\r\n```c#\r\npublic static class MyHttpClientFactoryDependencyInjectionExtensions\r\n{\r\n    public static IHttpClientBuilder AddHttpClient(this IServiceCollection services, string name, Type? clientType, Type? clientImplementationType)\r\n    {\r\n        if (clientImplementationType is not null \u0026\u0026 clientType is null)\r\n        {\r\n            throw new InvalidOperationException($\"The implementation type \u0027{clientImplementationType.AssemblyQualifiedName}\u0027 was configured, but the client type \u0027{clientTypeName}\u0027 was not found for client \u0027{name}\u0027.\");\r\n        }\r\n\r\n        if (clientType is not null)\r\n        {\r\n            clientImplementationType ??= clientType;\r\n\r\n            services.AddTransient(clientType, serviceProvider =\u003e\r\n                ActivatorUtilities.CreateInstance(\r\n                    serviceProvider,\r\n                    clientImplementationType,\r\n                    serviceProvider.GetRequiredService\u003cIHttpClientFactory\u003e().CreateClient(name)));\r\n        }\r\n\r\n        return services.AddHttpClient(name);\r\n    }\r\n```\r\n\r\nThis _could_ be expanded further to e.g. cache the object activator method like `DefaultTypedHttpClientFactory` is doing under the hood.\r\n\r\n(technically even `ITypedHttpClientFactory` itself can be used, though this would also require reflection to get access to the `TClient ITypedHttpClientFactory\u003cTImplementation\u003e.CreateClient(HttpClient httpClient)` method)\r\n\r\nThe only problem is that if e.g. https://github.com/dotnet/runtime/issues/89755 gets implemented, then the actual Typed client registration _might_ change a bit (e.g. getting a client as a keyed service instead of a direct `factory.CreateClient(name)`). One _could_ do smth to adapt to such changes in the future, e.g.\r\n\r\n```c#\r\nstatic HttpClient CreateHttpClient(IServiceProvider serviceProvider, string name)\r\n{\r\n    HttpClient? fromKeyed = null;\r\n    if (serviceProvider is IKeyedServiceProvider keyedServiceProvider)\r\n    {\r\n        fromKeyed = keyedServiceProvider.GetKeyedService\u003cHttpClient\u003e(name);\r\n    }\r\n\r\n    return fromKeyed ?? serviceProvider.GetRequiredService\u003cIHttpClientFactory\u003e().CreateClient(name);\r\n}\r\n```\r\n\r\n(-- or maybe even switch from typed clients to services with a keyed dependency?)",
                                           "updatedAt":  "2024-07-11T12:07:36Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6EfRYf",
                                           "createdAt":  "2024-07-11T12:20:35Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "paulomorgado",
                                           "body":  "@CarnaViire,\r\n\r\nWhatever reason justifies having typed clients in `IHttpClientFactory`, justifies loading them from a catalog.\r\n\r\nBy the way, I had created a HTTP client factory that loaded definitions from a catalog before .NET Core had `IHttpClientFactory`. I\u0027m just dropping it and replacing it with `IHttpClientFactory`.\r\n\r\nMy catalogue already as a feature (omitted in the code) to register a keyed `HttpClient`.\r\n\r\nAlso, there\u0027s a special keyed `IHttpClientFactory` that creates only one type of client.\r\n\r\nAs for the `ActivatorUtilities`, I though about that, but I tried to stay as much away from duplicating the internals of `AddHttpClient`. But you got me thinking about it again.",
                                           "updatedAt":  "2024-07-11T12:20:35Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6EgizX",
                                           "createdAt":  "2024-07-11T14:43:10Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "CarnaViire",
                                           "body":  "@paulomorgado\r\n\r\n\u003e My catalogue already as a feature (omitted in the code) to register a keyed HttpClient.\r\n\r\nIf this feature is already used in production -- would you mind sharing more re: your experience with keyed clients? (here or in the related issue https://github.com/dotnet/runtime/issues/89755) I don\u0027t know the circumstances in which your catalogue is used, but I\u0027m still curious about the perspective. I\u0027m asking because there are some tricky issues, like HttpClient being IDisposable, which leads to it being captured by DI. I wonder whether you\u0027ve hit them in practice.\r\n\r\nAlso -- if HttpClientFactory ends up registering keyed clients by default, will that break your code?\r\n\r\n\u003e Also, there\u0027s a special keyed IHttpClientFactory that creates only one type of client.\r\n\r\nThat is a very interesting idea, actually 👀\r\n\r\n\u003e I though about that, but I tried to stay as much away from duplicating the internals of AddHttpClient.\r\n\r\nYeah, I know it\u0027s a pain. Sorry about that 😞",
                                           "updatedAt":  "2024-07-11T14:43:10Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6Eg3Fl",
                                           "createdAt":  "2024-07-11T15:13:53Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODpVlWg==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "CarnaViire",
                                                                               "createdAt":  "2024-07-11T16:05:19Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "paulomorgado",
                                           "body":  "So far, I haven\u0027t hit any issues regarding `HttpClient` being disposable. I always use it as transient and inject the factory for other scopes.\r\n\r\nIf clients are registered as keyed, I\u0027ll have to remove some code. 😄 ",
                                           "updatedAt":  "2024-07-11T15:13:53Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6EreDH",
                                           "createdAt":  "2024-07-12T17:09:09Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHODpibzA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "paulomorgado",
                                                                               "createdAt":  "2024-07-12T17:27:52Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "CarnaViire",
                                           "body":  "@paulomorgado\r\n\r\nI\u0027ve been thinking about it a bit more, and I believe if we add an overload to `httpClientBuilder.AddTypedClient` then it can fit your case https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.dependencyinjection.httpclientbuilderextensions.addtypedclient?view=net-8.0\r\n\r\n```c#\r\nservices.AddHttpClient(name)\r\n    .AddTypedClient(clientType, clientImplementationType);\r\n```\r\n\r\n(It\u0027s not as heavy as `AddHttpClient` overload-wise, so we won\u0027t be as opposed to that 😄)\r\n\r\nI think I can resurrect the issue (and this can also help to gauge interest)\r\n\r\nI\u0027d still have to triage it to Future as a nice-to-have at this point (just setting expectations)",
                                           "updatedAt":  "2024-07-12T17:09:10Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6ErhFr",
                                           "createdAt":  "2024-07-12T17:18:03Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "CarnaViire",
                                           "body":  "If you are interested in the feature, please upvote the top post, it will help us prioritize. Thanks!",
                                           "updatedAt":  "2024-07-12T17:18:03Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6Erkur",
                                           "createdAt":  "2024-07-12T17:28:42Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "paulomorgado",
                                           "body":  "@julealgon,\r\n\r\n\u003e @paulomorgado\r\n\u003e \r\n\u003e I\u0027ve been thinking about it a bit more, and I believe if we add an overload to `httpClientBuilder.AddTypedClient` then it can fit your case https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.dependencyinjection.httpclientbuilderextensions.addtypedclient?view=net-8.0\r\n\u003e \r\n\u003e ```cs\r\n\u003e services.AddHttpClient(name)\r\n\u003e     .AddTypedClient(clientType, clientImplementationType);\r\n\u003e ```\r\n\u003e \r\n\u003e (It\u0027s not as heavy as `AddHttpClient` overload-wise, so we won\u0027t be as opposed to that 😄)\r\n\u003e \r\n\u003e I think I can resurrect the issue (and this can also help to gauge interest)\r\n\u003e \r\n\u003e I\u0027d still have to triage it to Future as a nice-to-have at this point (just setting expectations)\r\n\r\nThat would work for me just fine.\r\n\r\nI wouldn\u0027t even mind not having\r\n\r\n```csharp\r\nservices.AddHttpClient(name)\r\n    .AddTypedClient(clientType);\r\n```\r\n\r\nbut I\u0027m sure someone will complain about that. 😄 ",
                                           "updatedAt":  "2024-07-12T17:30:20Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6ErsID",
                                           "createdAt":  "2024-07-12T17:36:35Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "julealgon",
                                           "body":  "\u003e but I\u0027m sure someone will complain about that. 😄\r\n\r\nFrom my perspective, the issue is not really the specific methods being suggested, those are completely fine. I have a problem with perpetuating this _entire_ set of special-cased `HttpClient` APIs.\r\n\r\nIMHO, the more we keep piling on it, the worse it will become overall. I\u0027ve made a comment here with a bit more detail on that thought:\r\n- https://github.com/dotnet/runtime/issues/89755#issuecomment-2223267213\r\n\r\nTo me, _none_ of these APIs should even exist. They should be replaced and deprecated.",
                                           "updatedAt":  "2024-07-12T17:36:35Z"
                                       }
                                   ],
                         "totalCount":  19
                     },
        "title":  "[API Proposal]: Consider adding methods to the HTTP Client factory that receive Type parameters instead of generic type parameters",
        "labels":  [
                       "api-suggestion",
                       "area-Extensions-HttpClientFactory"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/106399",
        "createdAt":  "2024-08-14T15:26:37Z",
        "number":  106399,
        "author":  "Ilchert",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOC6NPNQ==",
                          "nodes":  [
                                        {
                                            "content":  "EYES",
                                            "user":  "neon-sunset",
                                            "createdAt":  "2024-08-15T06:06:44Z"
                                        }
                                    ],
                          "totalCount":  1
                      },
        "updatedAt":  "2024-08-14T15:47:23Z",
        "body":  "### Description\r\n\r\nAfter updating to .net 8 from .net 7 we faced with many of first chance exceptions in our services with following stack trace.\r\n\r\n```console\r\nSystem.ObjectDisposedException: Cannot access a disposed object.\r\nObject name: \u0027IServiceProvider\u0027.\r\n   at Microsoft.Extensions.DependencyInjection.ServiceLookup.ThrowHelper.ThrowObjectDisposedException()\r\n   at Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService(IServiceProvider provider, Type serviceType)\r\n   at Microsoft.Extensions.Http.DefaultHttpClientFactory.\u003c.ctor\u003eb__14_1()\r\n   at System.Lazy`1.ViaFactory(LazyThreadSafetyMode mode)\r\n--- End of stack trace from previous location ---\r\n   at System.Lazy`1.CreateValue()\r\n   at Microsoft.Extensions.Http.DefaultHttpClientFactory.Log.TryGetLogger(Lazy`1 loggerLazy, ILogger\u0026 logger)\r\n```\r\n\r\n\r\n### Reproduction Steps\r\n\r\n```Csharp\r\nAppDomain.CurrentDomain.FirstChanceException += CurrentDomain_FirstChanceException;\r\n\r\nvoid CurrentDomain_FirstChanceException(object? sender, System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs e)\r\n{\r\n    Console.WriteLine(e.Exception.ToString()); // this will print ObjectDisposedException\r\n}\r\n\r\nvar sc = new ServiceCollection();\r\nsc.AddHttpClient(\"client\").SetHandlerLifetime(TimeSpan.FromSeconds(3));\r\nvar sp = sc.BuildServiceProvider();\r\n\r\nvar f = sp.GetRequiredService\u003cIHttpClientFactory\u003e();\r\nusing var httpClient = f.CreateClient(\"client\");\r\n\r\nsp.Dispose();\r\n\r\nawait Task.Delay(10000);\r\n```\r\n\r\n### Expected behavior\r\n\r\nShould not throw unnecessary exceptions.\r\n\r\n### Actual behavior\r\n\r\nThrow ObjectDisposedException.\r\n\r\n### Regression?\r\n\r\nYes, works fine in .net 7\r\n\r\n### Known Workarounds\r\n\r\n_No response_\r\n\r\n### Configuration\r\n\r\n.NET 8 SDK  8.0.303\r\n\r\n### Other information\r\n\r\nIt is related to this empty catch block and captured by our logging system.\r\nhttps://github.com/dotnet/runtime/blob/ed13b35174ac5b282adf0aaade335276a762159b/src/libraries/Microsoft.Extensions.Http/src/DefaultHttpClientFactory.cs#L382-L386",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOiHEVxg==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6IcRXG",
                                           "createdAt":  "2024-08-14T15:27:04Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/ncl\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2024-08-14T15:27:04Z"
                                       }
                                   ],
                         "totalCount":  1
                     },
        "title":  "Reduce number of exceptions in HttpClientFactory",
        "labels":  [
                       "area-Extensions-HttpClientFactory"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/110167",
        "createdAt":  "2024-11-25T22:26:38Z",
        "number":  110167,
        "author":  "CarnaViire",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHOC8-UvQ==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "iliar-turdushev",
                                            "createdAt":  "2024-11-26T08:36:33Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "julealgon",
                                            "createdAt":  "2024-11-26T14:09:21Z"
                                        }
                                    ],
                          "totalCount":  2
                      },
        "updatedAt":  "2025-06-26T00:51:18Z",
        "body":  "Related to #101719\n\nIn `ConfigureHttpClientDefaults`, `IHttpClientBuilder.Name` will be null by design, because by the time of registration, the name is not known, it will be only known at the moment of execution. In general any \"global\" (=\"for all clients\") configuration with e.g. `ConfigureAll\u003cHttpClientFactoryOptions\u003e` -- a specific options (=client\u0027s) name is not available. `ConfigureHttpClientDefaults` aligns to the nature of the Options pattern, which regards null as \"all\".\n\nHowever, that means that any callback provided to HttpClientFactory configuration methods, e.g. to AddHttpMessageHandler, can\u0027t get the name from the `IHttpClientBuilder.Name` closure (how it usually does in an \"ordinary\" named case). And even though by the time the callback is executed, client\u0027s name is known already, it is not passed to the callback, and there is no way to access it.\n\nThe only existing workaround is to resort to configuration methods/approaches that are _not advised_ to be used, namely the ones giving access to the full `HttpMessageHandlerBuilder`: `ConfigureHttpMessageHandlerBuilder` (deprecated), `IHttpMessageHandlerBuilderFilter` or `HttpClientFactoryOptions.HttpMessageHandlerBuilderActions`. \n\nWe should introduce a new API to enable access to the specific client name from within the callbacks registered via  `ConfigureHttpClientDefaults`",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOszW0ww==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6U9jUJ",
                                           "createdAt":  "2024-11-25T22:27:02Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/ncl\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2024-11-25T22:27:02Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6VEM7I",
                                           "createdAt":  "2024-11-26T14:11:29Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "julealgon",
                                           "body":  "This to me feels like the whole concept of named options should be redesigned and be built around keyed registrations.\n\nNamed options were introduced at a point where there was no support for named or keyed registrations in the container and basically ended up being a gigantic hack around the lack of that capability.",
                                           "updatedAt":  "2024-11-26T14:11:29Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6yGPMI",
                                           "createdAt":  "2025-06-19T12:44:10Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "CarnaViire",
                                           "body":  "Triage: There are existing workarounds, and the proper solution is not straightforward. Punting to Future",
                                           "updatedAt":  "2025-06-19T12:44:10Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6zNbTD",
                                           "createdAt":  "2025-06-26T00:51:18Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "CarnaViire",
                                           "body":  "For the reference:\n\nWorkaround via `IConfigureNamedOptions`:\n\n```c#\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Http;\nusing Microsoft.Extensions.Options;\n\nvar services = new ServiceCollection();\n\nservices.AddHttpClient(\"Test\");\nservices.ConfigureHttpClientDefaults((name, client) =\u003e client.BaseAddress = new Uri($\"https://example.com/{name}\"));\n\nvar provider = services.BuildServiceProvider();\n\nvar factory = provider.GetRequiredService\u003cIHttpClientFactory\u003e();\nvar client = factory.CreateClient(\"Test\");\nConsole.WriteLine(\"Test BaseAddress: \" + client.BaseAddress);\nvar client2 = factory.CreateClient(\"Test2\");\nConsole.WriteLine(\"Test2 BaseAddress: \" + client2.BaseAddress);\n\n// This is a HACK to get access to the name of the client from the callback\nstatic class HttpClientFactoryExtensions\n{\n    public static void ConfigureHttpClientDefaults(this ServiceCollection services, Action\u003cstring, HttpClient\u003e configure)\n    {\n        services.ConfigureHttpClientDefaults(b =\u003e b.Services.ConfigureOptions(\n            new Configurator((name, options) =\u003e options.HttpClientActions.Add(c =\u003e configure(name, c))));\n    }\n\n    private class Configurator(Action\u003cstring, HttpClientFactoryOptions\u003e configure) : IConfigureNamedOptions\u003cHttpClientFactoryOptions\u003e\n    {\n        public void Configure(string? name, HttpClientFactoryOptions options)\n        {\n            if (name is not null)\n            {\n                configure(name, options);\n            }\n        }\n\n        public void Configure(HttpClientFactoryOptions options) { }\n    }\n}\n```\n\nOutput:\n\n```\nTest BaseAddress: https://example.com/Test\nTest2 BaseAddress: https://example.com/Test2\n```",
                                           "updatedAt":  "2025-06-26T00:51:18Z"
                                       }
                                   ],
                         "totalCount":  4
                     },
        "title":  "Add access to name from HttpClientFactory callbacks",
        "labels":  [
                       "area-Extensions-HttpClientFactory"
                   ]
    },
    {
        "url":  "https://github.com/dotnet/runtime/issues/113494",
        "createdAt":  "2025-03-13T20:31:40Z",
        "number":  113494,
        "author":  "ItsVeryWindy",
        "reactions":  {
                          "hasNextPage":  false,
                          "endCursor":  "Y3Vyc29yOnYyOpHODMEubg==",
                          "nodes":  [
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "julealgon",
                                            "createdAt":  "2025-03-14T22:50:58Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "aayjaychan",
                                            "createdAt":  "2025-05-20T15:18:57Z"
                                        },
                                        {
                                            "content":  "EYES",
                                            "user":  "Copilot",
                                            "createdAt":  "2025-05-21T12:12:27Z"
                                        },
                                        {
                                            "content":  "THUMBS_UP",
                                            "user":  "JanEggers",
                                            "createdAt":  "2025-08-21T07:20:57Z"
                                        }
                                    ],
                          "totalCount":  4
                      },
        "updatedAt":  "2025-08-24T08:15:48Z",
        "body":  "### Description\n\nRecently I ran into an issue running tests using dotnet test that it would crash without any obvious reason.\nRunning my tests also showed memory would steadily increase over time whilst they were being run which indicated the presence of a memory leak.\nAnalysing the memory dump there were 1000s of timers holding on to objects that I would\u0027ve expected to be disposed of all centered around ActiveHandlerTrackingEntry.\n\n\n### Reproduction Steps\n\nJudging by the code, I\u0027d say you could just get away with a for loop that creates a service collection, adds the http client factory, creates a service provider and then create a dozen or so http clients with it.\n\n### Expected behavior\n\nWhen the service provider it\u0027s associated with is disposed of, all resources the http client factory is associated with should be disposed of and freed up, including any timers that it creates.\n\n### Actual behavior\n\nTimers still hang around in the background, long after that instance of the http client factory is no longer in use. Which eventually consumes all available resources.\n\n### Regression?\n\n_No response_\n\n### Known Workarounds\n\nWhen running the tests ensuring the handler lifetime is set to infinite effectively bypasses the handler lifetime logic that creates the timers. Which stops the crashes that I was experiencing.\n\n### Configuration\n\nRunning .net 8.\nMacOS and Linux, ARM64 and x64.\nI don\u0027t think the configuration matters.\n\n### Other information\n\n_No response_",
        "comments":  {
                         "hasNextPage":  false,
                         "endCursor":  "Y3Vyc29yOnYyOpHOv1rhdQ==",
                         "nodes":  [
                                       {
                                           "id":  "IC_kwDODI9FZc6iTxMD",
                                           "createdAt":  "2025-03-14T01:20:33Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "dotnet-policy-service",
                                           "body":  "Tagging subscribers to this area: @dotnet/ncl\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003c!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003e",
                                           "updatedAt":  "2025-03-14T01:20:33Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6ierzw",
                                           "createdAt":  "2025-03-14T22:52:46Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "julealgon",
                                           "body":  "@CarnaViire is this all due to lack of custom lifetime scope support in Microsoft DI? That\u0027s what this sounds like to me...\n\nIf the `HttpMessageHandler` pooling was implemented within a custom lifetime, the lifetime scope would be disposed with the container which would naturally trigger disposal of anything created inside it. I assume this is handled today in an \"ad-hoc manner\" and that\u0027s one of the reasons why it opens the door for these problems.",
                                           "updatedAt":  "2025-03-14T22:52:46Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6irFJ3",
                                           "createdAt":  "2025-03-17T11:52:05Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  "Y3Vyc29yOnYyOpHOEKN3sA==",
                                                             "nodes":  [
                                                                           {
                                                                               "content":  "THUMBS_UP",
                                                                               "user":  "julealgon",
                                                                               "createdAt":  "2025-03-17T17:49:07Z"
                                                                           }
                                                                       ],
                                                             "totalCount":  1
                                                         },
                                           "author":  "CarnaViire",
                                           "body":  "I will investigate",
                                           "updatedAt":  "2025-03-17T11:52:05Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6lh8ui",
                                           "createdAt":  "2025-04-03T22:31:52Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "CarnaViire",
                                           "body":  "My investigation has show that the factory resources are _not leaking_, they are _eventually_ cleaned up. Yes, it doesn\u0027t happen right away upon container disposal, but it happens after all the handlers expire (dependent on HandlerLifetime value) _plus_ all the HttpClients and anything that could be holding onto them are _garbage collected_, _plus_ the clean up timer fired one last time after the GC. Clean up starts every 10s _after_ the first handler expires (by default 2 min).\n\nHere is the code I used for the verification, in addition to the loop that creates SP -- gets HttpClient -- disposes SP, I\u0027ve added a manual trigger of GC and a wait for a specified period of time. The period of time is just a bit longer than (serviceLifetime + cleanup timer interval) value.\n\n\u003cdetails\u003e\n\n```c#\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Logging;\n\nnamespace _113494\n{\n    class Program\n    {\n        static async Task Main(string[] args)\n        {\n            for (int i = 0; i \u003c 10; i++)\n            {\n                var services = new ServiceCollection();\n                services.AddLogging(builder =\u003e\n                {\n                    builder.AddConsole().SetMinimumLevel(LogLevel.Trace);\n                });\n\n                services.AddScoped\u003cDisposableService\u003e();\n                services.AddTransient\u003cTrackingHandler\u003e();\n\n                services.AddHttpClient(\"TestClient\")\n                        .AddHttpMessageHandler\u003cTrackingHandler\u003e()\n                        .RemoveAllLoggers()\n                        .SetHandlerLifetime(TimeSpan.FromSeconds(1)); // Set a short lifetime to force handler to expire quickly.\n\n                using var serviceProvider = services.BuildServiceProvider();\n                var httpClientFactory = serviceProvider.GetRequiredService\u003cIHttpClientFactory\u003e();\n                var client = httpClientFactory.CreateClient(\"TestClient\");\n                Console.WriteLine($\"Iteration {i + 1}: HttpClient acquired\");\n\n                try\n                {\n                    _ = await client.GetAsync(\"https://example.com\");\n                }\n                catch (Exception)\n                {\n                    // ignore\n                }\n            }\n\n            Console.WriteLine(\"Waiting for handlers to expire (lifetime = 1s)...\");\n            await Task.Delay(TimeSpan.FromSeconds(2));\n\n            Console.WriteLine(\"Forcing garbage collection... collecting HttpClients to enable expired handler cleanup\");\n            GC.Collect();\n            GC.WaitForPendingFinalizers();\n            Console.WriteLine(\"GC finished\");\n\n            Console.WriteLine(\"Waiting for the cleanup timer to fire (every 10s)...\");\n            await Task.Delay(TimeSpan.FromSeconds(15));\n            Console.WriteLine(\"15s wait completed\");\n\n            // Output disposal statistics\n            DisposableService.PrintStats();\n            TrackingHandler.PrintStats();\n\n            Console.WriteLine(\"Press any key to exit...\");\n            Console.ReadKey();\n        }\n    }\n    public class DisposableService : IDisposable\n    {\n        private static int s_ctorCount;\n        private static int s_disposeCount;\n        public string DebugId { get; } = $\"{nameof(DisposableService)}#{Interlocked.Increment(ref s_ctorCount)}\";\n\n        private bool _disposed;\n\n        public DisposableService()\n        {\n            Console.WriteLine($\"{DebugId} created\");\n        }\n\n        private void Dispose(bool disposing)\n        {\n            if (_disposed)\n            {\n                return;\n            }\n            _disposed = true;\n\n            Interlocked.Increment(ref s_disposeCount);\n            Console.WriteLine(disposing ? $\"{DebugId} disposed\" : $\"{DebugId} finalized without disposing\");\n        }\n\n        public void Dispose()\n        {\n            Dispose(true);\n            GC.SuppressFinalize(this);\n        }\n\n        ~DisposableService()\n        {\n            Dispose(false);\n        }\n\n        public static void PrintStats()\n        {\n            Console.WriteLine($\"{nameof(DisposableService)} instances created: {s_ctorCount}, disposed: {s_disposeCount}\");\n        }\n    }\n\n    public class TrackingHandler : DelegatingHandler\n    {\n        private static int s_ctorCount;\n        private static int s_disposeCount;\n        public int Id { get; } = Interlocked.Increment(ref s_ctorCount);\n        public string DebugId =\u003e $\"{nameof(TrackingHandler)}#{Id}\";\n\n        private readonly DisposableService _service;\n        private bool _disposed;\n\n        public TrackingHandler(DisposableService service)\n        {\n            _service = service;\n            Console.WriteLine($\"{DebugId} created with {_service.DebugId}\");\n        }\n\n        protected override async Task\u003cHttpResponseMessage\u003e SendAsync(HttpRequestMessage request, CancellationToken cancellationToken)\n            =\u003e await base.SendAsync(request, cancellationToken);\n\n        protected override void Dispose(bool disposing)\n        {\n            if (_disposed)\n            {\n                return;\n            }\n            _disposed = true;\n\n            Interlocked.Increment(ref s_disposeCount);\n            Console.WriteLine(disposing ? $\"{DebugId} disposed\" : $\"{DebugId} finalized without disposing\");\n            base.Dispose(disposing);\n        }\n\n        public static void PrintStats()\n        {\n            Console.WriteLine($\"{nameof(TrackingHandler)} instances created: {s_ctorCount}, disposed: {s_disposeCount}\");\n        }\n    }\n}\n\n```\n\n\u003c/details\u003e\n\n\nOutput that shows all the disposables being cleaned up:\n\n\u003cdetails\u003e\n\n```\n➜ 113494  dotnet run\nDisposableService#1 created\nTrackingHandler#1 created with DisposableService#1\nIteration 1: HttpClient acquired\nDisposableService#2 created\nTrackingHandler#2 created with DisposableService#2\nIteration 2: HttpClient acquired\nDisposableService#3 created\nTrackingHandler#3 created with DisposableService#3\nIteration 3: HttpClient acquired\nDisposableService#4 created\nTrackingHandler#4 created with DisposableService#4\nIteration 4: HttpClient acquired\nDisposableService#5 created\nTrackingHandler#5 created with DisposableService#5\nIteration 5: HttpClient acquired\nDisposableService#6 created\nTrackingHandler#6 created with DisposableService#6\nIteration 6: HttpClient acquired\nDisposableService#7 created\nTrackingHandler#7 created with DisposableService#7\nIteration 7: HttpClient acquired\nDisposableService#8 created\nTrackingHandler#8 created with DisposableService#8\nIteration 8: HttpClient acquired\nDisposableService#9 created\nTrackingHandler#9 created with DisposableService#9\nIteration 9: HttpClient acquired\nDisposableService#10 created\nTrackingHandler#10 created with DisposableService#10\nIteration 10: HttpClient acquired\nWaiting for handlers to expire (lifetime = 1s)...\nForcing garbage collection... collecting HttpClients to enable expired handler cleanup\nGC finished\nWaiting for the cleanup timer to fire (every 10s)...\nTrackingHandler#1 disposed\nDisposableService#1 disposed\nTrackingHandler#2 disposed\nDisposableService#2 disposed\nTrackingHandler#3 disposed\nDisposableService#3 disposed\nTrackingHandler#4 disposed\nDisposableService#4 disposed\nTrackingHandler#5 disposed\nDisposableService#5 disposed\nTrackingHandler#6 disposed\nDisposableService#6 disposed\nTrackingHandler#7 disposed\nDisposableService#7 disposed\nTrackingHandler#8 disposed\nDisposableService#8 disposed\nTrackingHandler#9 disposed\nDisposableService#9 disposed\nTrackingHandler#10 disposed\nDisposableService#10 disposed\n15s wait completed\nDisposableService instances created: 10, disposed: 10\nTrackingHandler instances created: 10, disposed: 10\nPress any key to exit...\n```\n\n\u003c/details\u003e\n\nThe timers are also eventually properly garbage collected (verified by a heap dump)\n\n\nEven though I don\u0027t consider it a bug, this is something we might consider to optimize in the future, though I an not sure how many users would need to create and dispose the whole providers in a loop...\n\n@ItsVeryWindy can you please check out the example and let me know whether this is a scenario you had in mind, and if yes, then what is the difference. Thanks!",
                                           "updatedAt":  "2025-04-03T22:31:52Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6lmZBb",
                                           "createdAt":  "2025-04-04T10:51:52Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "ItsVeryWindy",
                                           "body":  "Thanks for looking into it 👍 \n\nThe loop was more just to demonstrate how it could be triggered. As mentioned above, we\u0027re running tests, in our case we\u0027re running a suite of tests, lets say approximately 3000 or so, each one of these tests boots up a AspNetCore TestServer and disposes it at the end of the test, each one will create approximately 20 or so different clients/lifetimes. So over the lifespan of the tests 60000 lifetimes will be created.\n\nI don\u0027t know if it\u0027s specific to our setup or ootb but somewhere in the handlers there\u0027s something hanging on to the Host itself, but I guess the important thing is that whilst the timers exist it prevents any resources that those handlers are using from being garbage collected.\n\nDepending on the project, most of test suites are actually fairly quick and can complete in less than two minutes.\n",
                                           "updatedAt":  "2025-04-04T10:51:52Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6l4s-M",
                                           "createdAt":  "2025-04-07T12:04:55Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "CarnaViire",
                                           "body":  "\u003e  whilst the timers exist it prevents any resources that those handlers are using from being garbage collected\n\nIt does not -- well, they _eventually_ let them go 😅 It\u0027s a bit more complex because there are different timers.\n\n1. The _expiration_ timers (their callbacks, to be precise) _do_ hold onto the related handlers for the duration of the _handler lifetime_. These are started on every handler creation, and they fire only _once_, after which they are disposed.\n \nTimings:\n\n```\nT_c    ----/ h      /----\u003e T_e = T_c + h\nhandler    /handler /      handler \ncreated    /lifetime/      expired\n```\n\n2. After the expiration, if it is a _first_ expired handler in the queue, the _cleanup_ timer is started. The cleanup timer _never_ holds on the handlers, only on their weak references -- more specifically, the cleanup timer _is waiting_ for the handlers _to be garbage collected_. The following regular cleanup is scheduled _only_ if there\u0027s anything left to clean.\n\nTimings:\n\n```\n                                                                                      (loop) \u003c--+\n                                                                                                |\nT_s = T_e ----/ d      /----\u003e T + d    ==={ if ?      }----/I = 10s /----\u003e T_n = T_s + d + I ---+\ncleanup       /cleanup /      cleanup     {any expired}    /cleanup /      next\nstarted       /duration/      completed   {is pending }    /interval/      cleanup\n                                            |\n                                            +--{ else }-----------------------------------------\u003e (exit)\n```\n\n@ItsVeryWindy I suspect that you don\u0027t change the handler lifetimes, so they remain the default 2 minutes? If so, it explains why all the handlers are still alive during the tests (that are under 2 min in total).\n\nCan you try setting all the handler lifetimes to 1s (minimal allowed value)? Then the handlers are expected to be cleaned up within 10-20s after GC being triggered, as I have shown in the snippet above. You don\u0027t _have to_ trigger GC manually, it should happen automatically, but you can try that as well to see if that will make the memory consumption pattern more predictable.\n\nP.S.: you can set up the handler lifetime as a default setting via `ConfigureHttpClientDefaults`, so that you won\u0027t have to touch every single `AddHttpClient`:\n\n```c#\nservices.ConfigureHttpClientDefaults(b =\u003e b.SetHandlerLifetime(TimeSpan.FromSeconds(1)));\n```",
                                           "updatedAt":  "2025-04-07T12:04:55Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6l4zOS",
                                           "createdAt":  "2025-04-07T12:14:05Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "Maximys",
                                           "body":  "@CarnaViire , if I correctly understand, `IHttpClientFactory` implemented by [DefaultHttpClientFactory](https://github.com/dotnet/runtime/blob/8b05691bb7eef36df2af2490dffe53c3f6c7a835/src/libraries/Microsoft.Extensions.Http/src/DefaultHttpClientFactory.cs) and it have static field [_cleanupCallback](https://github.com/dotnet/runtime/blob/8b05691bb7eef36df2af2490dffe53c3f6c7a835/src/libraries/Microsoft.Extensions.Http/src/DefaultHttpClientFactory.cs#L21) , which use very intresting method [CleanupTimer_Tick()](https://github.com/dotnet/runtime/blob/8b05691bb7eef36df2af2490dffe53c3f6c7a835/src/libraries/Microsoft.Extensions.Http/src/DefaultHttpClientFactory.cs#L243).\nI think, we can inherit `DefaultHttpClientFactory` from [IDisposable](https://learn.microsoft.com/en-us/dotnet/api/system.idisposable?view=net-9.0) and reuse logic from `CleanupTimer_Tick` . What do you think about it? I can try to make this changes",
                                           "updatedAt":  "2025-04-07T12:14:30Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6mDmQe",
                                           "createdAt":  "2025-04-08T10:22:24Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "CarnaViire",
                                           "body":  "@Maximys in general, yes, and I will be more than happy to guide you through if you wish to contribute!\n\nAs I mentioned above, there are 2 kinds of timers associated with 2 types of handler entries (active and expired), so we will just need to reuse the logic of stopping the timer and disposing the handler(s) together with the handler scope(s) for both of them.",
                                           "updatedAt":  "2025-04-08T10:22:24Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc690j23",
                                           "createdAt":  "2025-08-13T16:46:32Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "CarnaViire",
                                           "body":  "Triage: nice to have, not critical for 10.0, punting to 11.0",
                                           "updatedAt":  "2025-08-13T16:46:32Z"
                                       },
                                       {
                                           "id":  "IC_kwDODI9FZc6_WuF1",
                                           "createdAt":  "2025-08-21T12:29:21Z",
                                           "reactions":  {
                                                             "hasNextPage":  false,
                                                             "endCursor":  null,
                                                             "nodes":  [

                                                                       ],
                                                             "totalCount":  0
                                                         },
                                           "author":  "JanEggers",
                                           "body":  "for anyone having the same issue with this code i was able to workaround the issue:\n\ncreate a custom service that is disposable and resolve the IhttpClientFactory and during dispose do this:\n\n```csharp\nvar handlers = (IDictionary)httpCLientFactory.GetType().GetField(\"_activeHandlers\", BindingFlags.Instance | BindingFlags.NonPublic)\n    .GetValue(httpCLientFactory);\n\nforeach (var entry in handlers)\n{\n    var lazyValue = entry.GetType().GetProperty(\"Value\").GetValue(entry);\n    var value = lazyValue.GetType().GetProperty(\"Value\").GetValue(lazyValue);\n    var timer = value.GetType().GetField(\"_timer\", BindingFlags.Instance | BindingFlags.NonPublic).GetValue(value);\n    if (timer != null)\n    {\n        value.GetType().GetMethod(\"Timer_Tick\", BindingFlags.Instance | BindingFlags.NonPublic).Invoke(value, null);\n    }\n    \n    value.GetType().GetField(\"_callback\", BindingFlags.Instance | BindingFlags.NonPublic).SetValue(value, null);\n}\n\nhandlers.Clear();\n\n\nhttpCLientFactory.GetType().GetMethod(\"StopCleanupTimer\", BindingFlags.Instance | BindingFlags.NonPublic).Invoke(httpCLientFactory, null);\n```",
                                           "updatedAt":  "2025-08-24T08:15:48Z"
                                       }
                                   ],
                         "totalCount":  10
                     },
        "title":  "HttpClientFactory doesn\u0027t clean up after itself",
        "labels":  [
                       "help wanted",
                       "area-Extensions-HttpClientFactory"
                   ]
    }
]
